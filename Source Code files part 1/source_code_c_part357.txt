ransfer);

    // is the transfer complete?
    if (IsListEmpty(&transfer->SplitTransferList)) {
        LOGENTRY(NULL, fdoDeviceObject, LOG_XFERS, 'cpSC',
            transfer, 0, 0);

        InsertTailList(&endpoint->CancelList, &transfer->TransferLink);            
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\usbport.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    usbport.c

Abstract:

    Port driver for USB host controllers

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBPORT_QueryCapabilities)
#pragma alloc_text(PAGE, USBPORT_CalculateUsbBandwidth)
#pragma alloc_text(PAGE, USBPORT_ReadWriteConfigSpace)
#pragma alloc_text(PAGE, USBPORT_ReadWriteConfigSpace)
#pragma alloc_text(PAGE, USBPORT_InTextmodeSetup)
#pragma alloc_text(PAGE, USBPORT_IsCompanionController)
#pragma alloc_text(PAGE, USBPORT_GetHcFlavor)
#pragma alloc_text(PAGE, USBPORT_ComputeAllocatedBandwidth)
#endif

// non paged functions
// USBPORT_StopDevice
// USBPORT_StartDevice
// USBPORT_CompleteIrp
// USBPORT_Dispatch
// USBPORT_TrackPendingRequest
// USBPORT_GetConfigValue
// USBPORT_DeferIrpCompletion
// USBPORT_AllocPool

NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    NT status code

--*/
{
    // BUGBUG
    // This function is never called

    return STATUS_SUCCESS;
}


NTSTATUS
USBPORT_StopDevice(
     PDEVICE_OBJECT FdoDeviceObject,
     BOOLEAN HardwarePresent
     )

/*++

Routine Description:

    Stop the port and miniport

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    PDEVICE_EXTENSION devExt;
    ULONG deviceCount;
    BOOLEAN haveWork;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'stpD', 0, 0, HardwarePresent);

    DEBUG_BREAK();

    USBPORT_FlushCahcedRegistryKeys(FdoDeviceObject);

    // the reoot hub and ALL devices should be 'stopped' at
    // this point.  We should have no device handles in the
    // system, if we do these are orphaned and we need to
    // remove them now.
    deviceCount = USBPORT_GetDeviceCount(FdoDeviceObject);

    while (deviceCount != 0 ) {

        PUSBD_DEVICE_HANDLE zombieDeviceHandle;
        KIRQL irql;
        PLIST_ENTRY listEntry;

        USBPORT_KdPrint((0, "%d zombie device handles on STOP\n",
            deviceCount));

        KeAcquireSpinLock(&devExt->Fdo.DevHandleListSpin.sl, &irql);

        USBPORT_ASSERT(!IsListEmpty(&devExt->Fdo.DeviceHandleList));
        listEntry = devExt->Fdo.DeviceHandleList.Flink;

        zombieDeviceHandle = (PUSBD_DEVICE_HANDLE) CONTAINING_RECORD(
                    listEntry,
                    struct _USBD_DEVICE_HANDLE,
                    ListEntry);

        ASSERT_DEVICE_HANDLE(zombieDeviceHandle)

        KeReleaseSpinLock(&devExt->Fdo.DevHandleListSpin.sl, irql);

        USBPORT_KdPrint((0, "deleting zombie handle %x\n",
            zombieDeviceHandle));

        DEBUG_BREAK();
        USBPORT_RemoveDevice(zombieDeviceHandle,
                             FdoDeviceObject,
                             0);

        deviceCount = USBPORT_GetDeviceCount(FdoDeviceObject);

    }

    // make sure all lists are empty and all endpoints
    // are freed before terminating the worker thread

    do {

        KIRQL irql;

        haveWork = FALSE;

        KeAcquireSpinLock(&devExt->Fdo.EpClosedListSpin.sl, &irql);
        if (!IsListEmpty(&devExt->Fdo.EpClosedList)) {
            haveWork = TRUE;
        }
        KeReleaseSpinLock(&devExt->Fdo.EpClosedListSpin.sl, irql);

        KeAcquireSpinLock(&devExt->Fdo.EndpointListSpin.sl, &irql);
        if (!IsListEmpty(&devExt->Fdo.GlobalEndpointList)) {
            haveWork = TRUE;
        }
        KeReleaseSpinLock(&devExt->Fdo.EndpointListSpin.sl, irql);

        if (haveWork) {
            USBPORT_Wait(FdoDeviceObject, 10);
        }

    } while (haveWork);

    // all of our lists should be empty
    USBPORT_ASSERT(IsListEmpty(&devExt->Fdo.EpClosedList) == TRUE);
    USBPORT_ASSERT(IsListEmpty(&devExt->Fdo.MapTransferList) == TRUE);
    USBPORT_ASSERT(IsListEmpty(&devExt->Fdo.DoneTransferList) == TRUE);
    USBPORT_ASSERT(IsListEmpty(&devExt->Fdo.EpStateChangeList) == TRUE);
    USBPORT_ASSERT(IsListEmpty(&devExt->Fdo.EpClosedList) == TRUE);

    // kill our system thread
    USBPORT_TerminateWorkerThread(FdoDeviceObject);

    if (devExt->Fdo.MpStateFlags & MP_STATE_STARTED) {
        // stop the miniport, disable interrupts
        // if hw is not present then it can't be interrupting
        // now can it.
        if (HardwarePresent) {
            MP_DisableInterrupts(FdoDeviceObject, devExt);
        }
        devExt->Fdo.MpStateFlags &= ~MP_STATE_STARTED;

        MP_StopController(devExt, HardwarePresent);
    }

    // kill our deadman timer
    USBPORT_StopDM_Timer(FdoDeviceObject);

    // see if we have an interrupt
    // if so disconnect it
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_CONNECTED)) {

        // fortunately this cannot fail
        IoDisconnectInterrupt(devExt->Fdo.InterruptObject);

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'IOCd', 0, 0, 0);
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_CONNECTED);
    }

    USBPORT_FreeIrpTable(FdoDeviceObject,
                         devExt->PendingTransferIrpTable);

    USBPORT_FreeIrpTable(FdoDeviceObject,
                         devExt->ActiveTransferIrpTable);

    // free any common buffer we allocated for the miniport
    if (devExt->Fdo.ControllerCommonBuffer != NULL) {
        USBPORT_HalFreeCommonBuffer(FdoDeviceObject,
                                    devExt->Fdo.ControllerCommonBuffer);
        devExt->Fdo.ControllerCommonBuffer = NULL;
    }

    if (devExt->Fdo.ScratchCommonBuffer != NULL) {
        USBPORT_HalFreeCommonBuffer(FdoDeviceObject,
                                    devExt->Fdo.ScratchCommonBuffer);
        devExt->Fdo.ScratchCommonBuffer = NULL;
    }

    if (devExt->Fdo.AdapterObject) {
        (devExt->Fdo.AdapterObject->DmaOperations->PutDmaAdapter)
            (devExt->Fdo.AdapterObject);
        devExt->Fdo.AdapterObject = NULL;
    }

    // delete the HCD symbolic link
    if (TEST_FLAG(devExt->Flags, USBPORT_FLAG_SYM_LINK)) {
        USBPORT_SymbolicLink(FALSE,
                             devExt,
                             devExt->Fdo.PhysicalDeviceObject,
                             (LPGUID)&GUID_CLASS_USB_HOST_CONTROLLER);
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_LEGACY_SYM_LINK)) {
        IoDeleteSymbolicLink(&devExt->Fdo.LegacyLinkUnicodeString);
        RtlFreeUnicodeString(&devExt->Fdo.LegacyLinkUnicodeString);
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_LEGACY_SYM_LINK);
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_FDO_REGISTERED)) {
        if (USBPORT_IS_USB20(devExt)) {
            USBPORT_DeregisterUSB2fdo(FdoDeviceObject);
        } else {
            USBPORT_DeregisterUSB1fdo(FdoDeviceObject);
        }
    }

    // successful stop clears the 'started flag'
    CLEAR_FLAG(devExt->PnpStateFlags, USBPORT_PNP_STARTED);

    return STATUS_SUCCESS;
}


NTSTATUS
USBPORT_DeferIrpCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PKEVENT event = Context;

    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBPORT_QueryCapabilities(
    PDEVICE_OBJECT FdoDeviceObject,
    PDEVICE_CAPABILITIES DeviceCapabilities
    )
/*++

Routine Description:

Arguments:

Return Value:

    ntstatus

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;
    PDEVICE_EXTENSION devExt;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // init the caps structure before calldown
    RtlZeroMemory(DeviceCapabilities, sizeof(DEVICE_CAPABILITIES));
    DeviceCapabilities->Size = sizeof(DEVICE_CAPABILITIES);
    DeviceCapabilities->Version = 1;
    DeviceCapabilities->Address = -1;
    DeviceCapabilities->UINumber = -1;

    irp =
        IoAllocateIrp(devExt->Fdo.TopOfStackDeviceObject->StackSize, FALSE);

    if (!irp) {

        USBPORT_KdPrint((1, "failed to allocate Irp\n"));
        DEBUG_BREAK();
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        // All PnP IRP's need the Status field initialized
        // to STATUS_NOT_SUPPORTED before calldown
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        nextStack = IoGetNextIrpStackLocation(irp);
        USBPORT_ASSERT(nextStack != NULL);
        nextStack->MajorFunction = IRP_MJ_PNP;
        nextStack->MinorFunction = IRP_MN_QUERY_CAPABILITIES;

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoSetCompletionRoutine(irp,
                               USBPORT_DeferIrpCompletion,
                               &event,
                               TRUE,
                               TRUE,
                               TRUE);

        nextStack->Parameters.DeviceCapabilities.Capabilities =
            DeviceCapabilities;

        ntStatus = IoCallDriver(devExt->Fdo.TopOfStackDeviceObject,
                                irp);

        if (ntStatus == STATUS_PENDING) {

           // wait for irp to complete
           KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL);

            ntStatus = irp->IoStatus.Status;
        }
    }

    IoFreeIrp(irp);

    return ntStatus;
}


NTSTATUS
USBPORT_StartDevice(
     PDEVICE_OBJECT FdoDeviceObject,
     PHC_RESOURCES HcResources
     )

/*++

Routine Description:

    Stop the port and miiport

Arguments:

    DeviceObject - DeviceObject of the controller to stop

Return Value:

    NT status code.

--*/

{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USB_MINIPORT_STATUS mpStatus;
    DEVICE_DESCRIPTION  deviceDescription;
    ULONG mpOptionFlags, i, legsup;
    ULONG globalDisableSS = 0;
    ULONG globalDisableCCDetect = 0;
    ULONG enIdleEndpointSupport = 0;
    ULONG hactionFlag;
    ULONG tmpLength;
    BOOLEAN isCC;

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'SRT>', FdoDeviceObject, 0, 0);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    //
    // hardcoded initialization, not failable
    //
    USBPORT_InitializeSpinLock(&devExt->Fdo.CoreFunctionSpin, 'CRS+', 'CRS-');
    USBPORT_InitializeSpinLock(&devExt->Fdo.MapTransferSpin, 'MPS+', 'MPS-');
    USBPORT_InitializeSpinLock(&devExt->Fdo.DoneTransferSpin, 'DNS+', 'DNS-');
    KeInitializeSpinLock(&devExt->Fdo.EndpointListSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.EpStateChangeListSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.EpClosedListSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.TtEndpointListSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.DevHandleListSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.HcSyncSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.RootHubSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.WorkerThreadSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.PowerSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.DM_TimerSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.PendingIrpSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.WakeIrpSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.IdleIrpSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.BadRequestSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.IsrDpcSpin.sl);
    USBPORT_InitializeSpinLock(&devExt->Fdo.ActiveTransferIrpSpin, 'ALS+', 'ALS-');
    KeInitializeSpinLock(&devExt->Fdo.PendingTransferIrpSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.StatCounterSpin.sl);
    KeInitializeSpinLock(&devExt->Fdo.HcPendingWakeIrpSpin.sl);

    devExt->Fdo.LastSystemSleepState = PowerSystemUnspecified;

    devExt->Fdo.HcWakeState = HCWAKESTATE_DISARMED;
    // this event will be signalled when the wake irp completes
    KeInitializeEvent(&devExt->Fdo.HcPendingWakeIrpEvent,
            NotificationEvent, TRUE);


    devExt->Fdo.BadReqFlushThrottle = 0;
    switch(USBPORT_DetectOSVersion(FdoDeviceObject)) {
    case Win2K:
        // need a long delay for win2k hidclass
        USBPORT_KdPrint((0, "We are running on Win2k!\n"));
        devExt->Fdo.BadReqFlushThrottle = 5;
        globalDisableSS = 1;
    }

    devExt->PendingTransferIrpTable = NULL;
    devExt->ActiveTransferIrpTable = NULL;

    // Always start with the default address (0) assigned.
    // Address array has one bit for every address 0..127
    devExt->Fdo.AddressList[0] = 1;
    devExt->Fdo.AddressList[1] =
        devExt->Fdo.AddressList[2] =
        devExt->Fdo.AddressList[3] = 0;

    KeInitializeDpc(&devExt->Fdo.TransferFlushDpc,
                    USBPORT_TransferFlushDpc,
                    FdoDeviceObject);

    KeInitializeDpc(&devExt->Fdo.SurpriseRemoveDpc,
                    USBPORT_SurpriseRemoveDpc,
                    FdoDeviceObject);

    KeInitializeDpc(&devExt->Fdo.HcResetDpc,
                    USBPORT_HcResetDpc,
                    FdoDeviceObject);

    KeInitializeDpc(&devExt->Fdo.HcWakeDpc,
                    USBPORT_HcWakeDpc,
                    FdoDeviceObject);

    KeInitializeDpc(&devExt->Fdo.IsrDpc,
                    USBPORT_IsrDpc,
                    FdoDeviceObject);
    devExt->Fdo.DmaBusy = -1;
    devExt->Fdo.WorkerDpc = -1;
    // set up adapter object
    RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));

    deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    deviceDescription.Master = TRUE;
    deviceDescription.ScatterGather = TRUE;
    deviceDescription.Dma32BitAddresses = TRUE;

    deviceDescription.InterfaceType = PCIBus;
    deviceDescription.DmaWidth = Width32Bits;
    deviceDescription.DmaSpeed = Compatible;

    deviceDescription.MaximumLength = (ULONG)-1;

    devExt->Fdo.NumberOfMapRegisters = (ULONG)-1;
    devExt->Fdo.AdapterObject = NULL;

    // miniport common buffer
    devExt->Fdo.ControllerCommonBuffer = NULL;

    // fetch the global BIOS hacks from the registry
    USBPORT_GetDefaultBIOS_X(FdoDeviceObject,
                             &devExt->Fdo.BiosX,
                             &globalDisableSS,
                             &globalDisableCCDetect,
                             &enIdleEndpointSupport);

    if (globalDisableSS) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DISABLE_SS);
    }
    // check reg for SS flag, note that miniport can
    // stil override
    if (USBPORT_SelectiveSuspendEnabled(FdoDeviceObject) &&
        !globalDisableSS) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
    }

    //
    // failable initailization
    //

    // make sure we got all the resources we need
    // note that we check here becuase problems may occurr
    // if we attempt to connect the interrupt without all
    // the necessary resources

    mpOptionFlags = REGISTRATION_PACKET(devExt).OptionFlags;
    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'mpOP',
        mpOptionFlags, 0, HcResources->Flags);

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_POLL_CONTROLLER)) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_POLL_CONTROLLER);
    }

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_POLL_IN_SUSPEND)) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_POLL_IN_SUSPEND);
    }

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NO_SS)) {
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_RH_CAN_SUSPEND);
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_DISABLE_SS);
    }

    // make sure we got an IRQ
    if ( (mpOptionFlags & USB_MINIPORT_OPT_NEED_IRQ) &&
        !(HcResources->Flags & HCR_IRQ)) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'noIQ', 0, 0, 0);
        goto USBPORT_StartDevice_Done;
    }

    if ( (mpOptionFlags & USB_MINIPORT_OPT_NEED_IOPORT) &&
        !(HcResources->Flags & HCR_IO_REGS)) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'noRG', 0, 0, 0);
        goto USBPORT_StartDevice_Done;
    }

    if ( (mpOptionFlags & USB_MINIPORT_OPT_NEED_MEMORY) &&
        !(HcResources->Flags & HCR_MEM_REGS)) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'noMM', 0, 0, 0);
        goto USBPORT_StartDevice_Done;
    }

    // simulates a failry common scenario where PnP gives us
    // the wrong resources.
    TEST_PATH(ntStatus, FAILED_NEED_RESOURCE);
    if (!NT_SUCCESS(ntStatus)) {
        goto USBPORT_StartDevice_Done;
    }

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NO_PNP_RESOURCES)) {
        TEST_TRAP();
        devExt->Fdo.PciVendorId = 0;
        devExt->Fdo.PciDeviceId = 0;
        devExt->Fdo.PciRevisionId = 0;
        devExt->Fdo.PciClass = 0;
        devExt->Fdo.PciSubClass = 0;
        devExt->Fdo.PciProgIf = 0;
    } else {
        // fetch the Dev Prod and Rev IDs from config space

        ULONG ClassCodeRev;

        ntStatus = USBPORT_ReadConfigSpace(
                                 FdoDeviceObject,
                                 &devExt->Fdo.PciVendorId,
                                 0,
                                 sizeof(devExt->Fdo.PciVendorId));
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Gvid',
            devExt->Fdo.PciVendorId, 0, ntStatus);
        if (!NT_SUCCESS(ntStatus)) {
            goto USBPORT_StartDevice_Done;
        }
        ntStatus = USBPORT_ReadConfigSpace(
                                 FdoDeviceObject,
                                 &devExt->Fdo.PciDeviceId,
                                 2,
                                 sizeof(devExt->Fdo.PciDeviceId));
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Gdid',
            devExt->Fdo.PciDeviceId, 0, ntStatus);
        if (!NT_SUCCESS(ntStatus)) {
            goto USBPORT_StartDevice_Done;
        }

        ntStatus = USBPORT_ReadConfigSpace(
                                 FdoDeviceObject,
                                 &ClassCodeRev,
                                 8,
                                 sizeof(ClassCodeRev));
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'Grev',
            ClassCodeRev, 0, ntStatus);
        if (!NT_SUCCESS(ntStatus)) {
            goto USBPORT_StartDevice_Done;
        }

        devExt->Fdo.PciRevisionId   = (UCHAR)ClassCodeRev;
        devExt->Fdo.PciClass        = (UCHAR)(ClassCodeRev >> 24);
        devExt->Fdo.PciSubClass     = (UCHAR)(ClassCodeRev >> 16);
        devExt->Fdo.PciProgIf       = (UCHAR)(ClassCodeRev >>  8);

        USBPORT_ASSERT(devExt->Fdo.PciClass     == PCI_CLASS_SERIAL_BUS_CTLR);
        USBPORT_ASSERT(devExt->Fdo.PciSubClass  == PCI_SUBCLASS_SB_USB);
        USBPORT_ASSERT(devExt->Fdo.PciProgIf    == 0x00 ||
                       devExt->Fdo.PciProgIf    == 0x10 ||
                       devExt->Fdo.PciProgIf    == 0x20);
    }

    USBPORT_KdPrint((1, "USB Controller VID %x DEV %x REV %x\n",
        devExt->Fdo.PciVendorId,
        devExt->Fdo.PciDeviceId,
        devExt->Fdo.PciRevisionId));

    // set the HW flavor so that the miniports and possibly
    // the port know what hacks to do to make the controller
    // be good.
    HcResources->ControllerFlavor =
        devExt->Fdo.HcFlavor =
        USBPORT_GetHcFlavor(FdoDeviceObject,
                            devExt->Fdo.PciVendorId,
                            devExt->Fdo.PciDeviceId,
                            devExt->Fdo.PciRevisionId);


    // check for Fredbhs global idle endpoint support, if the global key is set
    // the write the instanced key
    USBPORT_KdPrint((1, "Idle Endpoint Support %d%x\n",enIdleEndpointSupport));
    USBPORT_SetRegistryKeyValueForPdo(devExt->Fdo.PhysicalDeviceObject,
                                      USBPORT_SW_BRANCH,
                                      REG_DWORD,
                                      EN_IDLE_ENDPOINT_SUPPORT,
                                      sizeof(EN_IDLE_ENDPOINT_SUPPORT),
                                      &enIdleEndpointSupport,
                                      sizeof(enIdleEndpointSupport));

    //
    // If this is an OHCI or UHCI controller check if it is a companion
    // controller.
    //
    if ((devExt->Fdo.PciClass     == PCI_CLASS_SERIAL_BUS_CTLR) &&
        (devExt->Fdo.PciSubClass  == PCI_SUBCLASS_SB_USB) &&
        (devExt->Fdo.PciProgIf    <  0x20) &&
        NT_SUCCESS(USBPORT_IsCompanionController(FdoDeviceObject, &isCC)))
    {
        if (isCC)
        {
            SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC);
        }
        else
        {
            CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC);
        }
    }

    /* global flag overrides registry settings from inf and
        any hard coded detection
    */
    if (globalDisableCCDetect) {
        CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC);
    }

    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC))
    {
        USBPORT_KdPrint((1,"Is CC %04X %04X %02X  %02X %02X %02X\n",
                         devExt->Fdo.PciVendorId,
                         devExt->Fdo.PciDeviceId,
                         devExt->Fdo.PciRevisionId,
                         devExt->Fdo.PciClass,
                         devExt->Fdo.PciSubClass,
                         devExt->Fdo.PciProgIf
                        ));
    }
    else
    {
        USBPORT_KdPrint((1,"Is not CC %04X %04X %02X  %02X %02X %02X\n",
                         devExt->Fdo.PciVendorId,
                         devExt->Fdo.PciDeviceId,
                         devExt->Fdo.PciRevisionId,
                         devExt->Fdo.PciClass,
                         devExt->Fdo.PciSubClass,
                         devExt->Fdo.PciProgIf
                        ));
    }

    // detect companion controller by registry method
    if (USBPORT_GetRegistryKeyValueForPdo(devExt->HcFdoDeviceObject,
                                          devExt->Fdo.PhysicalDeviceObject,
                                          USBPORT_HW_BRANCH,
                                          HACTION_KEY,
                                          sizeof(HACTION_KEY),
                                          &hactionFlag,
                                          sizeof(hactionFlag)) != STATUS_SUCCESS) {

        // default is to NO_WAIT on HC if no key is found, UNLESS
        // textmode setup is currently running.
        //
        // note: the goatpack default is to wait

        if (USBPORT_InTextmodeSetup())
        {
            USBPORT_KdPrint((1, "Textmode Setup Detected: hactionFlag=1\n"));

            hactionFlag = 1;
        }
        else
        {
            USBPORT_KdPrint((1, "Textmode Setup Not Detected: hactionFlag=0\n"));

            hactionFlag = 0;
        }
    }
    if (hactionFlag == 0 ) {
        USBPORT_KdPrint((1, "Detected HACTION 0 -- OK to enumerate\n"));
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_CC_ENUM_OK);
    }


    devExt->Fdo.TotalBusBandwidth =
        REGISTRATION_PACKET(devExt).BusBandwidth;

    // allow a registry override of the total BW for
    // this bus
    {
    ULONG busBandwidth = devExt->Fdo.TotalBusBandwidth;
    USBPORT_GetRegistryKeyValueForPdo(devExt->HcFdoDeviceObject,
                                          devExt->Fdo.PhysicalDeviceObject,
                                          USBPORT_SW_BRANCH,
                                          BW_KEY,
                                          sizeof(BW_KEY),
                                          &busBandwidth,
                                          sizeof(busBandwidth));
    if (busBandwidth != devExt->Fdo.TotalBusBandwidth) {
        USBPORT_KdPrint((0, "Warning: Registry Override of bus bandwidth\n"));
        devExt->Fdo.TotalBusBandwidth = busBandwidth;
    }
    }

    // init the bandwidth table
    for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
        devExt->Fdo.BandwidthTable[i]
            = devExt->Fdo.TotalBusBandwidth -
              devExt->Fdo.TotalBusBandwidth/10;
    }

    // allocate internal irp tracking tables

    ALLOC_POOL_Z(devExt->PendingTransferIrpTable, NonPagedPool,
                 sizeof(USBPORT_IRP_TABLE));

    ALLOC_POOL_Z(devExt->ActiveTransferIrpTable, NonPagedPool,
                 sizeof(USBPORT_IRP_TABLE));

    if (devExt->PendingTransferIrpTable == NULL ||
        devExt->ActiveTransferIrpTable == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBPORT_StartDevice_Done;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'irpT',
        devExt->PendingTransferIrpTable,
        devExt->ActiveTransferIrpTable, 0);

    ntStatus = USBPORT_CreateWorkerThread(FdoDeviceObject);
    if (!NT_SUCCESS(ntStatus)) {
        goto USBPORT_StartDevice_Done;
    }

    // query our device caps from the PDO and save them
    ntStatus =
        USBPORT_QueryCapabilities(FdoDeviceObject,
                                  &devExt->DeviceCapabilities);

    if (!NT_SUCCESS(ntStatus)) {
        goto USBPORT_StartDevice_Done;
    }

    ntStatus = IoGetDeviceProperty(devExt->Fdo.PhysicalDeviceObject,
                                   DevicePropertyBusNumber,
                                   sizeof(devExt->Fdo.BusNumber),
                                   &devExt->Fdo.BusNumber,
                                   &tmpLength);

    if (!NT_SUCCESS(ntStatus)) {
        goto USBPORT_StartDevice_Done;
    }

    // extract device and function number from the caps
    devExt->Fdo.BusDevice = devExt->DeviceCapabilities.Address>>16;
    devExt->Fdo.BusFunction = devExt->DeviceCapabilities.Address & 0x0000ffff;
    USBPORT_KdPrint((1, "'BUS %x, device %x, function %x\n",
        devExt->Fdo.BusNumber, devExt->Fdo.BusDevice, devExt->Fdo.BusFunction));

    if (!NT_SUCCESS(ntStatus)) {
        goto USBPORT_StartDevice_Done;
    }

    // this will modify the DeviceCaps reported by the BIOS
    USBPORT_ApplyBIOS_X(FdoDeviceObject,
                        &devExt->DeviceCapabilities,
                        devExt->Fdo.BiosX);

    // got the capabilities, compute the power state table
    USBPORT_ComputeHcPowerStates(
        FdoDeviceObject,
        &devExt->DeviceCapabilities,
        &devExt->Fdo.HcPowerStateTbl);

    //
    // Create our adapter object for a standard USB PCI adapter
    //

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NO_PNP_RESOURCES)) {
        devExt->Fdo.AdapterObject = NULL;
    } else {
        devExt->Fdo.AdapterObject =
            IoGetDmaAdapter(devExt->Fdo.PhysicalDeviceObject,
                            &deviceDescription,
                            &devExt->Fdo.NumberOfMapRegisters);

        if (devExt->Fdo.AdapterObject == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto USBPORT_StartDevice_Done;
        }
    }

    // see if we have an interrupt
    if (HcResources->Flags & HCR_IRQ) {

        ntStatus = IoConnectInterrupt(
                     &devExt->Fdo.InterruptObject,
                     (PKSERVICE_ROUTINE) USBPORT_InterruptService,
                     (PVOID) FdoDeviceObject,
                     (PKSPIN_LOCK)NULL,
                     HcResources->InterruptVector,
                     HcResources->InterruptLevel,
                     HcResources->InterruptLevel,
                     HcResources->InterruptMode,
                     HcResources->ShareIRQ,
                     HcResources->Affinity,
                     FALSE);            // BUGBUG FloatingSave, this is configurable

        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'IOCi', 0, 0, ntStatus);
        if (NT_SUCCESS(ntStatus)) {
            SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_CONNECTED);
        } else {
            goto USBPORT_StartDevice_Done;
        }

    }

    if (TEST_FLAG(mpOptionFlags, USB_MINIPORT_OPT_NO_PNP_RESOURCES)) {
        REGISTRATION_PACKET(devExt).CommonBufferBytes = 0;
    }

    if (REGISTRATION_PACKET(devExt).CommonBufferBytes) {
        PUSBPORT_COMMON_BUFFER commonBuffer;
        ULONG bytesNeeded =
            REGISTRATION_PACKET(devExt).CommonBufferBytes;

        commonBuffer =
            USBPORT_HalAllocateCommonBuffer(FdoDeviceObject,
                bytesNeeded);

        if (commonBuffer == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto USBPORT_StartDevice_Done;
        } else {
            devExt->Fdo.ControllerCommonBuffer = commonBuffer;
            HcResources->CommonBufferVa =
                 commonBuffer->MiniportVa;
            HcResources->CommonBufferPhys =
                 commonBuffer->MiniportPhys;
        }

        // allocate some scratch space
        bytesNeeded = USB_PAGE_SIZE - sizeof(USBPORT_COMMON_BUFFER);
        commonBuffer =
            USBPORT_HalAllocateCommonBuffer(FdoDeviceObject,
                bytesNeeded);

        if (commonBuffer == NULL) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto USBPORT_StartDevice_Done;
        } else {
            devExt->Fdo.ScratchCommonBuffer = commonBuffer;
        }

    } else {
        // no common buffer for this controller
        devExt->Fdo.ControllerCommonBuffer = NULL;
    }

    // zero the controller extension
    RtlZeroMemory(devExt->Fdo.MiniportDeviceData,
                  devExt->Fdo.MiniportDriver->RegistrationPacket.DeviceDataSize);


    // attempt to start the miniport
    USBPORT_FlushCahcedRegistryKeys(FdoDeviceObject);
    SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_ON_PNP_THREAD);
    MP_StartController(devExt, HcResources, mpStatus);
    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_ON_PNP_THREAD);

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'mpST', mpStatus, 0, 0);

    if (HcResources->DetectedLegacyBIOS) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_LEGACY_BIOS);

        legsup = 1;
    } else {
        legsup = 0;
    }

    USBPORT_SetRegistryKeyValueForPdo(
                            devExt->Fdo.PhysicalDeviceObject,
                            USBPORT_HW_BRANCH,
                            REG_DWORD,
                            SYM_LEGSUP_KEY,
                            sizeof(SYM_LEGSUP_KEY),
                            &legsup,
                            sizeof(legsup));

    // since common buff signature is at the end this will detect if
    // the miniport overwrites the allocated block
#if DBG
    if (devExt->Fdo.ControllerCommonBuffer != NULL) {
        ASSERT_COMMON_BUFFER(devExt->Fdo.ControllerCommonBuffer);
    }
#endif

    if (mpStatus == USBMP_STATUS_SUCCESS) {
        // controller started, set flag and begin passing
        // interrupts to the miniport
        SET_FLAG(devExt->Fdo.MpStateFlags, MP_STATE_STARTED);
        LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'eIRQ', mpStatus, 0, 0);
        MP_EnableInterrupts(devExt);
    } else {
        // error occured, disconnect interrupt now
        if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_CONNECTED)) {
            IoDisconnectInterrupt(devExt->Fdo.InterruptObject);
            CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_IRQ_CONNECTED);
        }
        // free memory resources
        if (devExt->Fdo.ControllerCommonBuffer != NULL) {
            USBPORT_HalFreeCommonBuffer(FdoDeviceObject,
                                        devExt->Fdo.ControllerCommonBuffer);
            devExt->Fdo.ControllerCommonBuffer = NULL;
        }
    }

    ntStatus = MPSTATUS_TO_NTSTATUS(mpStatus);

    // placing the faiure here simulates a failure from
    // some point above.  We won't start the DM timer unless
    // everything succeeds
    TEST_PATH(ntStatus, FAILED_USBPORT_START);

    // start up the 'DEADMAN' timer
    if (NT_SUCCESS(ntStatus)) {
        devExt->Fdo.DM_TimerInterval = USBPORT_DM_TIMER_INTERVAL;
        USBPORT_StartDM_Timer(FdoDeviceObject,
                              USBPORT_DM_TIMER_INTERVAL);
    }

    // create symbolic links for user mode
    if (NT_SUCCESS(ntStatus)) {

        // create the link based on guid for USB 2.0
        ntStatus = USBPORT_CreatePortFdoSymbolicLink(FdoDeviceObject);
    }

    if (NT_SUCCESS(ntStatus)) {
        // create the legacy link only for USB 1.1 controllers
        //
        // BUGBUG
        // Failure to create the legacy link will not keep the
        // driver from loading.
        // This fails during text mode setup if you still have the
        // UHCD loaded, we can remove this when UHCD is completely
        // out of the build.
        // ntStatus =
        USBPORT_CreateLegacyFdoSymbolicLink(FdoDeviceObject);
    }

USBPORT_StartDevice_Done:

    if (!NT_SUCCESS(ntStatus)) {

        // stop_device will(should) cleanup for us
        USBPORT_KdPrint((0, "'Start Device Failed (status  %08.8x)\n", ntStatus));
        DEBUG_BREAK();

        // since we won't be marked 'started' call stop here
        // to cleanup a failed start

        USBPORT_StopDevice(FdoDeviceObject,
                           TRUE);

    } else {
        // enable system wake support
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE);
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_PNP, 'SRT<', ntStatus, 0, 0);

    return ntStatus;
}


NTSTATUS
USBPORT_PassIrp(
    PDEVICE_OBJECT DeviceObject,
    PIO_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    BOOLEAN InvokeOnSuccess,
    BOOLEAN InvokeOnError,
    BOOLEAN InvokeOnCancel,
    PIRP Irp
    )
/*++

Routine Description:

    Passes an irp to the next lower driver,
    this is done by the FDO for all PnP Irps

Arguments:

Return Value:


--*/
{
    PDEVICE_EXTENSION devExt;
    NTSTATUS ntStatus;

    GET_DEVICE_EXT(devExt, DeviceObject);
    ASSERT_FDOEXT(devExt);

    // note that we do not dec the pending request count
    // if we set a completion routine.
    // We do not want to 'go away' before the completion
    // routine is called.

    if (CompletionRoutine) {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,
                               CompletionRoutine,
                               Context,
                               InvokeOnSuccess,
                               InvokeOnError,
                               InvokeOnCancel);
    } else {
        IoSkipCurrentIrpStackLocation(Irp);
        DECREMENT_PENDING_REQUEST_COUNT(DeviceObject, Irp);
    }

    ntStatus = IoCallDriver(devExt->Fdo.TopOfStackDeviceObject, Irp);

    return ntStatus;
}


VOID
USBPORT_CompleteIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    NTSTATUS ntStatus,
    ULONG_PTR Information
    )
/*++

Routine Description:

    Completes an I/O Request

Arguments:

Return Value:


--*/
{
    USBPORT_KdPrint((2, "'USBPORT_CompleteIrp status = %x\n", ntStatus));

    DECREMENT_PENDING_REQUEST_COUNT(DeviceObject, Irp);

    Irp->IoStatus.Status      = ntStatus;
    Irp->IoStatus.Information = Information;

//    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'irpC', Irp, DeviceObject, Urb);

    IoCompleteRequest(Irp,
                      IO_NO_INCREMENT);

}


NTSTATUS
USBPORT_Dispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION devExt;
    BOOLEAN forRootHubPdo = FALSE;
    KIRQL irql;

    USBPORT_KdPrint((2, "'enter USBPORT_Dispatch\n"));

    GET_DEVICE_EXT(devExt, DeviceObject);
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    USBPORT_KdPrint((2, "'USBPORT_Dispatch IRP = %x, stack = %x (func) %x %x\n",
        Irp, irpStack, irpStack->MajorFunction, irpStack->MinorFunction));

    // figure out if this is the FDO for the HC or the PDO
    // for the root hub
    if (devExt->Sig == ROOTHUB_DEVICE_EXT_SIG) {
        forRootHubPdo = TRUE;
        USBPORT_KdPrint((2, "'IRP->PDO\n"));
    } else if (devExt->Sig == USBPORT_DEVICE_EXT_SIG) {
        forRootHubPdo = FALSE;
        USBPORT_KdPrint((2, "'IRP->FDO\n"));
    } else {
        // this is a bug, bugcheck
        USBPORT_ASSERT(FALSE);
    }

    // *BEGIN SPECIAL CASE
    // Before doing anything see if this devobj is 'removed'
    // if so do some 'special' handling

    KeAcquireSpinLock(&devExt->PendingRequestSpin.sl, &irql);

    if (TEST_FLAG(devExt->PnpStateFlags, USBPORT_PNP_REMOVED)) {

        // someone has managed to call us after the remove

        USBPORT_KdPrint((1, "'(irp after remove) IRP = %x, DO %x MJx%x MNx%x\n",
            Irp, DeviceObject, irpStack->MajorFunction,
                irpStack->MinorFunction));

        KeReleaseSpinLock(&devExt->PendingRequestSpin.sl, irql);

        if (forRootHubPdo) {

            switch(irpStack->MajorFunction) {

            // in the removed state complete all power irps with
            // success, this happens if you suspend with the root
            // hub disbaled
            case IRP_MJ_POWER:
                Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;
                PoStartNextPowerIrp(Irp);
                IoCompleteRequest(Irp,
                                  IO_NO_INCREMENT);
                goto USBPORT_Dispatch_Done;

            // since the root hub pdo exists even when the device
            // is removed by PnP we still allow irps thru
            default:
                break;
            }

        } else {

            switch(irpStack->MajorFunction) {

            // allow PnP irps even though we are removed
            case IRP_MJ_PNP:
                break;

            case IRP_MJ_POWER:

                TEST_TRAP();
                Irp->IoStatus.Status = ntStatus = STATUS_DEVICE_REMOVED;
                PoStartNextPowerIrp(Irp);
                IoCompleteRequest(Irp,
                                  IO_NO_INCREMENT);
                goto USBPORT_Dispatch_Done;

            default:
                Irp->IoStatus.Status = ntStatus = STATUS_DEVICE_REMOVED;
                IoCompleteRequest(Irp,
                                  IO_NO_INCREMENT);
                goto USBPORT_Dispatch_Done;
            }
        }

    } else {

        KeReleaseSpinLock(&devExt->PendingRequestSpin.sl, irql);

    }
    // *END SPECIAL CASE

    INCREMENT_PENDING_REQUEST_COUNT(DeviceObject, Irp);

    switch (irpStack->MajorFunction) {

    case IRP_MJ_CREATE:

        USBPORT_KdPrint((2, "'IRP_MJ_CREATE\n"));
        USBPORT_CompleteIrp(DeviceObject, Irp, ntStatus, 0);

        break;

    case IRP_MJ_CLOSE:

        USBPORT_KdPrint((2, "'IRP_MJ_CLOSE\n"));
        USBPORT_CompleteIrp(DeviceObject, Irp, ntStatus, 0);

        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        USBPORT_KdPrint((2, "'IRP_MJ_NTERNAL_DEVICE_CONTROL\n"));
        if (forRootHubPdo) {
            ntStatus = USBPORT_PdoInternalDeviceControlIrp(DeviceObject, Irp);
        } else {
            ntStatus = USBPORT_FdoInternalDeviceControlIrp(DeviceObject, Irp);
        }
        break;

    case IRP_MJ_DEVICE_CONTROL:
        USBPORT_KdPrint((2, "'IRP_MJ_DEVICE_CONTROL\n"));
        if (forRootHubPdo) {
            ntStatus = USBPORT_PdoDeviceControlIrp(DeviceObject, Irp);
        } else {
            ntStatus = USBPORT_FdoDeviceControlIrp(DeviceObject, Irp);
        }
        break;

    case IRP_MJ_POWER:
        if (forRootHubPdo) {
            ntStatus = USBPORT_PdoPowerIrp(DeviceObject, Irp);
        } else {
            ntStatus = USBPORT_FdoPowerIrp(DeviceObject, Irp);
        }
        break;

    case IRP_MJ_PNP:
        if (forRootHubPdo) {
            ntStatus = USBPORT_PdoPnPIrp(DeviceObject, Irp);

        } else {
            ntStatus = USBPORT_FdoPnPIrp(DeviceObject, Irp);
        }
        break;

     case IRP_MJ_SYSTEM_CONTROL:
        if (forRootHubPdo) {
            USBPORT_KdPrint((2, "'IRP_MJ_SYSTEM_CONTROL\n"));
            ntStatus = Irp->IoStatus.Status;
            USBPORT_CompleteIrp(DeviceObject, Irp, ntStatus, 0);
        } else {
            USBPORT_KdPrint((2, "'IRP_MJ_SYSTEM_CONTROL\n"));
            //
            // pass on to our PDO
            //
            ntStatus =
                USBPORT_PassIrp(DeviceObject,
                            NULL,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE,
                            Irp);
        }
        break;

    default:
        USBPORT_KdPrint((2, "'unrecognized IRP_MJ_ function (%x)\n", irpStack->MajorFunction));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        USBPORT_CompleteIrp(DeviceObject, Irp, ntStatus, 0);
    } /* case MJ_FUNCTION */

    USBPORT_KdPrint((2, "'exit USBPORT_Dispatch 0x%x\n", ntStatus));

USBPORT_Dispatch_Done:

    return ntStatus;
}


VOID
USBPORT_TrackPendingRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp,
    BOOLEAN        AddToList
    )
/*++

Routine Description:

    Keep track of Irps sent to our DevObjs

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    KIRQL irql;

    GET_DEVICE_EXT(devExt, DeviceObject);

    if (AddToList) {
        KeAcquireSpinLock(&devExt->PendingRequestSpin.sl, &irql);
        // -1 to 0 means we are starting, initialize the event
        if (devExt->PendingRequestCount == -1) {
            KeInitializeEvent(&devExt->PendingRequestEvent,
                              NotificationEvent,
                              FALSE);
        }
        USBPORT_KdPrint((4, "'INC pending Request(%x) %d\n",
                devExt, devExt->PendingRequestCount));
        devExt->PendingRequestCount++;
// the following is debug only code
#ifdef TRACK_IRPS
        if (Irp != NULL) {
            PTRACK_IRP trackIrp;
            PLIST_ENTRY listEntry;

            listEntry = devExt->TrackIrpList.Flink;
            while (listEntry != &devExt->TrackIrpList) {

                trackIrp = (PTRACK_IRP) CONTAINING_RECORD(
                    listEntry,
                    struct _TRACK_IRP,
                    ListEntry);

                if (trackIrp->Irp == Irp) {
                    USBPORT_KdPrint((0, "  IRP %x already pending\n",
                                Irp));
                    BUGCHECK();
                }

                listEntry = trackIrp->ListEntry.Flink;
            }

            ALLOC_POOL_Z(trackIrp,
                         NonPagedPool,
                         sizeof(*trackIrp));

            USBPORT_ASSERT(trackIrp != NULL);
            if (trackIrp != NULL) {
                trackIrp->Irp = Irp;
                InsertTailList(&devExt->TrackIrpList,
                               &trackIrp->ListEntry);
            }
        }
#endif
        KeReleaseSpinLock(&devExt->PendingRequestSpin.sl, irql);
    } else {
        KeAcquireSpinLock(&devExt->PendingRequestSpin.sl, &irql);
        USBPORT_KdPrint((4, "'DEC pending Request(%x) %d\n",
                devExt, devExt->PendingRequestCount));
#ifdef TRACK_IRPS
        if (Irp != NULL) {
            PTRACK_IRP trackIrp;
            PLIST_ENTRY listEntry;

            listEntry = devExt->TrackIrpList.Flink;
            while (listEntry != &devExt->TrackIrpList) {

                trackIrp = (PTRACK_IRP) CONTAINING_RECORD(
                    listEntry,
                    struct _TRACK_IRP,
                    ListEntry);

                if (trackIrp->Irp == Irp) {
                    goto found_irp;
                }

                listEntry = trackIrp->ListEntry.Flink;
            }
            trackIrp = NULL;
found_irp:
            if (trackIrp == NULL) {
                USBPORT_KdPrint((0, "  Pending IRP %x not found\n",
                    Irp));
                BUGCHECK();
            }

            RemoveEntryList(&trackIrp->ListEntry);
            FREE_POOL(NULL, trackIrp);
        }
#endif
        devExt->PendingRequestCount--;

        //  0 -> -1 indicates we have no more pending io
        // signal the event

        if (devExt->PendingRequestCount == -1) {

            KeSetEvent(&devExt->PendingRequestEvent,
               1,
               FALSE);
        }

        KeReleaseSpinLock(&devExt->PendingRequestSpin.sl, irql);
    }
}


NTSTATUS
USBPORT_GetConfigValue(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
    ValueType - The type of the value
    ValueData - The data for the value.
    ValueLength - The length of ValueData.
    Context - A pointer to the CONFIG structure.
    EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    USBPORT_KdPrint((2, "'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));

    switch (ValueType) {
    case REG_DWORD:
        RtlCopyMemory(EntryContext, ValueData, sizeof(ULONG));
        break;
    case REG_BINARY:
        // BUGBUG we are only set up to read a byte
        RtlCopyMemory(EntryContext, ValueData, 1);
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}


VOID
USBPORT_Wait(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG Milliseconds
    )
/*++

Routine Description:

    Synchrounously wait the specified number of miliseconds

Return Value:

    None

--*/
{
    LONG time;
    ULONG timerIncerent;
    LARGE_INTEGER time64;

    USBPORT_KdPrint((2,"'Wait for %d ms\n", Milliseconds));

    //
    // work only when LowPart is not overflown.
    //
    USBPORT_ASSERT(21474 > Milliseconds);

    //
    // wait MilliSeconds( 10000 100ns unit)
    //
    timerIncerent = KeQueryTimeIncrement() - 1;

    // round up to the next highest timer increment
    time = -1 * (MILLISECONDS_TO_100_NS_UNITS(Milliseconds) + timerIncerent);

    time64 = RtlConvertLongToLargeInteger(time),

    KeDelayExecutionThread(KernelMode, FALSE, &time64);

    USBPORT_KdPrint((2,"'Wait done\n"));

    return;
}


ULONG
USBPORT_CalculateUsbBandwidth(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Computes the bandwidth that must be reserved for a
    given endpoint

Arguments:

Return Value:

    banwidth required in bits/ms, returns 0 for bulk
    and control endpoints

--*/
{
    ULONG bw;
    ULONG overhead;
    ULONG maxPacketSize;
    BOOLEAN lowSpeed = FALSE;

#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13

    PAGED_CODE();

    ASSERT_ENDPOINT(Endpoint);
    maxPacketSize = Endpoint->Parameters.MaxPacketSize;
    if (Endpoint->Parameters.DeviceSpeed == LowSpeed) {
        lowSpeed = TRUE;
    }

    //
    // control, iso, bulk, interrupt
    //

    switch(Endpoint->Parameters.TransferType) {
    case Bulk:
    case Control:
        overhead = 0;
        break;
    case Isochronous:
        overhead = USB_ISO_OVERHEAD_BYTES;
        break;
    case Interrupt:
        overhead = USB_INTERRUPT_OVERHEAD_BYTES;
        break;
    }

    //
    // Calculate bandwidth for endpoint.  We will use the
    // approximation: (overhead bytes plus MaxPacket bytes)
    // times 8 bits/byte times worst case bitstuffing overhead.
    // This gives bit times, for low speed endpoints we multiply
    // by 8 again to convert to full speed bits.
    //

    //
    // Figure out how many bits are required for the transfer.
    // (multiply by 7/6 because, in the worst case you might
    // have a bit-stuff every six bits requiring 7 bit times to
    // transmit 6 bits of data.)
    //

    // overhead(bytes) * maxpacket(bytes/ms) * 8
    //      (bits/byte) * bitstuff(7/6) = bits/ms

    bw = ((overhead+maxPacketSize) * 8 * 7) / 6;

    // return zero for control or bulk
    if (!overhead) {
        bw = 0;
    }

    if (lowSpeed) {
        bw *= 8;
    }

    return bw;
}


VOID
USBPORT_UpdateAllocatedBw(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG alloced_bw, i, m;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    m = 0;

    for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
        alloced_bw = devExt->Fdo.TotalBusBandwidth -
                devExt->Fdo.BandwidthTable[i];

        if (alloced_bw > m) {
            m = alloced_bw;
        }
    }

    devExt->Fdo.MaxAllocedBw = m;

    m = devExt->Fdo.TotalBusBandwidth;

    for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
        alloced_bw = devExt->Fdo.TotalBusBandwidth -
                devExt->Fdo.BandwidthTable[i];

        if (alloced_bw < m) {
            m = alloced_bw;
        }
    }

    devExt->Fdo.MinAllocedBw = m;
    if (m == devExt->Fdo.TotalBusBandwidth) {
        devExt->Fdo.MinAllocedBw = 0;
    }
}


VOID
USBPORT_UpdateAllocatedBwTt(
    PTRANSACTION_TRANSLATOR Tt
    )
/*++

Routine Description:
    This function and the one above it should be merged

Arguments:

Return Value:

--*/
{
    ULONG alloced_bw, i, m;

    m = 0;

    for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
        alloced_bw = Tt->TotalBusBandwidth -
                Tt->BandwidthTable[i];

        if (alloced_bw > m) {
            m = alloced_bw;
        }
    }

    Tt->MaxAllocedBw = m;

    m = Tt->TotalBusBandwidth;

    for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
        alloced_bw = Tt->TotalBusBandwidth -
                Tt->BandwidthTable[i];

        if (alloced_bw < m) {
            m = alloced_bw;
        }
    }

    Tt->MinAllocedBw = m;
    if (m == Tt->TotalBusBandwidth) {
        Tt->MinAllocedBw = 0;
    }
}


BOOLEAN
USBPORT_AllocateBandwidthUSB11(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Computes the best schedule offset for this endpoint
    and allocates the bandwidth.

    Offsets in the bw allocation table orrespond to the values
    in the following tree structure.

    The schedule offset is the best possible posoition for the
    endpoint to reside in the schedule based on its period.

    for 32 ms or mf ep there are 32 possible positions
    for 16 there are 16
    for 8 there are 8
    ...
fr <32>  <16>  <08>   <04>      <02>              <01>


0   ( 0) -\
          ( 0)-\
16  ( 1) -/     \
                ( 0)-\
8   ( 2) -\     /     \
          ( 1)-/       \
24  ( 3) -/             \
                        (0)-\
4   ( 4) -\             /    \
          ( 2)-\       /      \
20  ( 5) -/     \     /        \
                ( 1)-/          \
12  ( 6) -\     /                \
          ( 3)-/                  \
28  ( 7) -/                        \
                                   (0)-\
2   ( 8) -\                        /    \
          ( 4)-\                  /      \
18  ( 9) -/     \                /        \
                ( 2)-\          /          \
10  (10) -\     /     \        /            \
          ( 5)-/       \      /              \
26  (11) -/             \    /                \
                        (1)-/                  \
6   (12) -\             /                       \
          ( 6)-\       /                         \
22  (13) -/     \     /                           \
                ( 3)-/                             \
14  (14) -\     /                                   \
          ( 7)-/                                     \
30  (15) -/                                           \
                                                      (0)
1   (16) -\                                           /
          ( 8)-\                                     /
17  (17) -/     \                                   /
                ( 4)-\                             /
9   (18) -\     /     \                           /
          ( 9)-/       \                         /
25  (19) -/             \                       /
                        (2)-\                  /
5   (20) -\             /    \                /
          (10)-\       /      \              /
21  (21) -/     \     /        \            /
                ( 5)-/          \          /
13  (22) -\     /                \        /
          (11)-/                  \      /
29  (23) -/                        \    /
                                   (1)-/
3   (24) -\                        /
          (12)-\                  /
19  (25) -/     \                /
                ( 6)-\          /
11  (26) -\     /     \        /
          (13)-/       \      /
27  (27) -/             \    /
                        (3)-/
7   (28) -\             /
          (14)-\       /
23  (29) -/     \     /
                ( 7)-/
15  (30) -\     /
          (15)-/
31  (32) -/

Allocations:
    period.offset           table entries
      1                    0, 1, 2.........31

      2.0                  0, 1, 2.........15
      2.1                 16,17,18.........31

      4.0                  0, 1, 2..........7
      4.1                  8, 9,10.........15
      4.2                 16,17,18.........23
      4.3                 24,25,26.........31

      8.0                  0, 1, 2, 3
      8.1                  4, 5, 6, 7
      8.2                  8, 9,10,11
      8.3                 12,13,14,15
      8.4                 16,17,18,19
      8.5                 20,21,22,23
      8.6                 24,25,26,27
      8.7                 28,29,30,31

      ...


frame     nodes visited (period.offset)
    0   32.0   16.0    8.0    4.0    2.0
    1   32.16  16.8    8.4    4.2    2.1
    2   32.8   16.4    8.2    4.1    2.0
    3   32.24  16.12   8.6    4.3    2.1
    4   32.4   16.2    8.1    4.0    2.0
    5   32.20  16.10   8.5    4.2    2.1
    6   32.12  16.6    8.3    4.1    2.0
    7   32.28  16.14   8.7    4.3    2.1

    ...

    all miniports should maintain a 32 entry table for
    interrupt endpoints, the lower 5 bits of the current
    frame are used as an index in to this table. see the
    above graph for index to frame mappings



Arguments:

Return Value:

    FALSE if no bandwidth availble

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG period, bandwidth, scheduleOffset, i;
    ULONG bestFitBW, min, n;
    LONG bestScheduleOffset;
    BOOLEAN willFit;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);

    if (Endpoint->Parameters.TransferType == Bulk ||
        Endpoint->Parameters.TransferType == Control ||
        TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {

        // control/bulk come out of our standard 10%
        // and root hub endpoints consume no BW
        Endpoint->Parameters.ScheduleOffset = 0;
        return TRUE;
    }

    // Iso and interrupt -- iso is just like interrupt with
    // a period of 1

    // see if we can fit it

    scheduleOffset = 0;
    period = Endpoint->Parameters.Period;
    USBPORT_ASSERT(period != 0);
    bandwidth = Endpoint->Parameters.Bandwidth;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'rqBW', scheduleOffset,
            bandwidth, Endpoint);

    // The bandwidth table conatins the bw avaialble for all
    // possible schedule offsets up to the max polling interval
    // we support.

    bestFitBW = 0;
    bestScheduleOffset = -1;

    // scan all possible offsets and select the 'best fit'
    // our goal here is to position the ep in the location
    // with the most free bw

    do {
        // assume it will fit
        willFit = TRUE;
        min = devExt->Fdo.TotalBusBandwidth;
        n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;

        for (i=0; i<n; i++) {

            if (devExt->Fdo.BandwidthTable[n*scheduleOffset+i] < bandwidth) {
                willFit = FALSE;
                break;
            }
            // set min to the lowest free entry for this
            // offset
            if (min > devExt->Fdo.BandwidthTable[n*scheduleOffset+i]) {
                min = devExt->Fdo.BandwidthTable[n*scheduleOffset+i];
            }
        }

        if (willFit && min > bestFitBW) {
            // it will fit compare this to the we have found
            bestFitBW = min;
            bestScheduleOffset = scheduleOffset;
        }

        scheduleOffset++;

    } while (scheduleOffset < period);

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'ckBW', bestScheduleOffset,
            bandwidth, period);

    if (bestScheduleOffset != -1) {

        scheduleOffset = bestScheduleOffset;

        LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'alBW', scheduleOffset,
            bandwidth, period);

        // we found an offset that will work for the
        // given period, alloc the bw and return the
        // offset

        Endpoint->Parameters.ScheduleOffset =
            scheduleOffset;

        n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;

        for (i=0; i<n; i++) {

            USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
            USBPORT_ASSERT(devExt->Fdo.BandwidthTable[n*scheduleOffset+i] >= bandwidth);
            devExt->Fdo.BandwidthTable[n*scheduleOffset+i] -= bandwidth;

        }

        // update our bw tracking info
        if (Endpoint->Parameters.TransferType == Isochronous) {
            devExt->Fdo.AllocedIsoBW += bandwidth;
        } else {
            USBPORT_GET_BIT_SET(period, n);
            USBPORT_ASSERT(n<6);
            devExt->Fdo.AllocedInterruptBW[n] += bandwidth;
        }
    }

    USBPORT_UpdateAllocatedBw(FdoDeviceObject);

    return bestScheduleOffset == -1 ? FALSE : TRUE;
}


VOID
USBPORT_FreeBandwidthUSB11(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Frees the bw reserved for a give endpoint

Arguments:

Return Value:

    FALSE if no bandwidth availble

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG period, bandwidth, scheduleOffset, i, n;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);

    if (Endpoint->Parameters.TransferType == Bulk ||
        Endpoint->Parameters.TransferType == Control ||
        TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
        // these come out of our standard 10%
        return;
    }

    scheduleOffset = Endpoint->Parameters.ScheduleOffset;
    bandwidth = Endpoint->Parameters.Bandwidth;
    period = Endpoint->Parameters.Period;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'frBW', scheduleOffset, bandwidth, period);

    n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;

    for (i=0; i<n; i++) {

        USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
        devExt->Fdo.BandwidthTable[n*scheduleOffset+i] += bandwidth;

    }
    //for (i=sheduleOffset; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i+=period) {
    //    USBPORT_ASSERT(i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
    //    devExt->Fdo.BandwidthTable[i] += bandwidth;
    //}

    // update our bw tracking info
    if (Endpoint->Parameters.TransferType == Isochronous) {
        devExt->Fdo.AllocedIsoBW -= bandwidth;
    } else {
        USBPORT_GET_BIT_SET(period, n);
        USBPORT_ASSERT(n<6);
        devExt->Fdo.AllocedInterruptBW[n] -= bandwidth;
    }

    // update max allocated BW
    USBPORT_UpdateAllocatedBw(FdoDeviceObject);

    return;
}


NTSTATUS
USBPORT_ReadWriteConfigSpace(
    PDEVICE_OBJECT FdoDeviceObject,
    BOOLEAN Read,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine reads or writes config space.

Arguments:

    DeviceObject        - .

    Read                - TRUE if read, FALSE if write.

    Buffer              - The info to read or write.

    Offset              - The offset in config space to read or write.

    Length              - The length to transfer.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION devExt;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    deviceObject = devExt->Fdo.PhysicalDeviceObject;

    if (Read) {
        RtlZeroMemory(Buffer, Length);
    }

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           USBPORT_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);


    nextStack = IoGetNextIrpStackLocation(irp);
    USBPORT_ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= Read ? IRP_MN_READ_CONFIG : IRP_MN_WRITE_CONFIG;
    nextStack->Parameters.ReadWriteConfig.WhichSpace = PCI_WHICHSPACE_CONFIG;
    nextStack->Parameters.ReadWriteConfig.Buffer = Buffer;
    nextStack->Parameters.ReadWriteConfig.Offset = Offset;
    nextStack->Parameters.ReadWriteConfig.Length = Length;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'rwC>', 0, 0, 0);

    ntStatus = IoCallDriver(deviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {
       // wait for irp to complete

       KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = irp->IoStatus.Status;
    }

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'rwC<', 0, 0, ntStatus);

    IoFreeIrp(irp);

    return ntStatus;
}


VOID
USBPORTSVC_Wait(
    PDEVICE_DATA DeviceData,
    ULONG MillisecondsToWait
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    fdoDeviceObject = devExt->HcFdoDeviceObject;

    USBPORT_Wait(fdoDeviceObject, MillisecondsToWait);
}


VOID
USBPORT_InvalidateController(
    PDEVICE_OBJECT FdoDeviceObject,
    USB_CONTROLLER_STATE ControllerState
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    switch(ControllerState) {
    case UsbMpControllerPowerFault:
        USBPORT_PowerFault(FdoDeviceObject,
                           "Miniport Raised Exception");
        break;
    case UsbMpControllerNeedsHwReset:
        USBPORT_KdPrint((1,"'<UsbMpControllerNeedsHwReset>\n"));

        if (KeInsertQueueDpc(&devExt->Fdo.HcResetDpc, 0, 0)) {
            SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_HW_RESET_PENDING);
            INCREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);
        }
        break;

    case UsbMpControllerRemoved:

        // set our flag indicating the controller has been
        // removed and signal the worker thread.
        USBPORT_KdPrint((1,"'<UsbMpControllerRemoved>\n"));
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_CONTROLLER_GONE);

        if (KeInsertQueueDpc(&devExt->Fdo.SurpriseRemoveDpc, 0, 0)) {
            INCREMENT_PENDING_REQUEST_COUNT(FdoDeviceObject, NULL);
        }
        break;

    case UsbMpSimulateInterrupt:
        // queue the ISR DPC as if we got a hardware interrupt
        KeInsertQueueDpc(&devExt->Fdo.IsrDpc,
                         NULL,
                         NULL);
        break;

    default:
        TEST_TRAP();
    }
}


VOID
USBPORTSVC_InvalidateController(
    PDEVICE_DATA DeviceData,
    USB_CONTROLLER_STATE ControllerState
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    fdoDeviceObject = devExt->HcFdoDeviceObject;

    USBPORT_InvalidateController(fdoDeviceObject, ControllerState);
}


VOID
USBPORT_HcResetDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies FdoDeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = DeferredContext;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    devExt->Fdo.StatHardResetCount++;

    // allow Dr. Slick to work his magic on the ohci controller

    CLEAR_FDO_FLAG(devExt, USBPORT_FDOFLAG_HW_RESET_PENDING);

    // core lock is held here so that we don't poll the
    // controler endpoints while we reset
    MP_ResetController(devExt);

    DECREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, NULL);
}


VOID
USBPORT_SurpriseRemoveDpc(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.

Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - supplies FdoDeviceObject.

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PDEVICE_OBJECT fdoDeviceObject = DeferredContext;
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, fdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_NukeAllEndpoints(fdoDeviceObject);

    DECREMENT_PENDING_REQUEST_COUNT(fdoDeviceObject, NULL);
}


VOID
USBPORTSVC_BugCheck(
    PDEVICE_DATA DeviceData
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;
    ULONG vidDev;
    ULONG ilog;
    PLOG_ENTRY lelog;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    fdoDeviceObject = devExt->HcFdoDeviceObject;

    vidDev = devExt->Fdo.PciVendorId;
    vidDev <<=16;
    vidDev |= devExt->Fdo.PciDeviceId;

    ilog &= devExt->Log.LogSizeMask;
    lelog = devExt->Log.LogStart+ilog;

    BUGCHECK(USBBUGCODE_MINIPORT_ERROR, vidDev, (ULONG_PTR)lelog, 0);
}


USB_MINIPORT_STATUS
USBPORTSVC_ReadWriteConfigSpace(
    PDEVICE_DATA DeviceData,
    BOOLEAN Read,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )
/*++

Routine Description:

    Service Exported to miniports for accessing config
    spzce if needed.  This service is synchronous and cannot
    be called at raised IRQL

    USBUHCI uses this service to clear set the PIRQD bit which
    enables/disables the controller.

Arguments:

Return Value:

    None.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    PDEVICE_OBJECT fdoDeviceObject;

    DEVEXT_FROM_DEVDATA(devExt, DeviceData);
    ASSERT_FDOEXT(devExt);
    fdoDeviceObject = devExt->HcFdoDeviceObject;

    ntStatus = USBPORT_ReadWriteConfigSpace(
        fdoDeviceObject,
        Read,
        Buffer,
        Offset,
        Length);

    return USBPORT_NtStatus_TO_MiniportStatus(ntStatus);
}


BOOLEAN
USBPORT_InTextmodeSetup(
    VOID
    )
/*++

Routine Description:

Arguments:

    None

Return Value:

    TRUE if textmode setup is currently running, else FALSE

Notes:

--*/
{
    UNICODE_STRING      keyName;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hKey;
    BOOLEAN             textmodeSetup;
    NTSTATUS            ntStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&keyName,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\setupdd");

    InitializeObjectAttributes(&objectAttributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwOpenKey(&hKey,
                         KEY_READ,
                         &objectAttributes);

    if (!NT_SUCCESS(ntStatus))
    {
        textmodeSetup = FALSE;
    }
    else
    {
        textmodeSetup = TRUE;

        ZwClose(hKey);
    }

    return textmodeSetup;
}



NTSTATUS
USBPORT_IsCompanionController(
    PDEVICE_OBJECT FdoDeviceObject,
    PBOOLEAN       ReturnResult
    )
/*++

Routine Description:



Arguments:

    FdoDeviceObject - USB 1.0 OHCI or UHCI Host Controller FDO for which
                      an associated USB 2.0 EHCI Host Controller is searched.

    ReturnResult - TRUE if the query is successful and an associated USB 2.0
                   EHCI Host Controller is found, otherwise FALSE.

Return Value:

    Success or failure of the query, not the answer to the query.

Notes:

--*/
{
    KEVENT                          irpCompleted;
    PDEVICE_OBJECT                  targetDevice;
    IO_STATUS_BLOCK                 statusBlock;
    PIRP                            irp;
    PIO_STACK_LOCATION              irpStack;
    PCI_DEVICE_PRESENT_INTERFACE    dpInterface;
    PCI_DEVICE_PRESENCE_PARAMETERS  dpParameters;
    BOOLEAN                         result;
    NTSTATUS                        status;

    PAGED_CODE();

    //
    // Set the default return value;
    //
    *ReturnResult = FALSE;

    //
    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    //
    // Find out where we are sending the irp
    //
    targetDevice = IoGetAttachedDeviceReference(FdoDeviceObject);

    //
    // Get an IRP
    //
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       targetDevice,
                                       NULL,            // Buffer
                                       0,               // Length
                                       0,               // StartingOffset
                                       &irpCompleted,
                                       &statusBlock
                                      );

    if (!irp)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;

        goto USBPORT_IsCompanionControllerDone;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Initialize the stack location
    //
    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCI_DEVICE_PRESENT_INTERFACE;
    irpStack->Parameters.QueryInterface.Version = PCI_DEVICE_PRESENT_INTERFACE_VERSION;
    irpStack->Parameters.QueryInterface.Size = sizeof(PCI_DEVICE_PRESENT_INTERFACE);
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE)&dpInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //
    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);

        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status))
    {
        USBPORT_KdPrint((1,"PCI_DEVICE_PRESENT_INTERFACE query interface failed\n"));

        //
        // Don't have the interface so don't free it.
        //
        goto USBPORT_IsCompanionControllerDone;
    }
    else
    {
        USBPORT_KdPrint((1,"PCI_DEVICE_PRESENT_INTERFACE query interface succeeded\n"));
    }

    if (dpInterface.Size < sizeof(PCI_DEVICE_PRESENT_INTERFACE))
    {
        USBPORT_KdPrint((1,"PCI_DEVICE_PRESENT_INTERFACE old version\n"));

        //
        // Do have the interface so do free it.
        //
        goto USBPORT_IsCompanionControllerFreeInterface;
    }

    //
    // Initialize the Device Presence Parameters
    //
    dpParameters.Size = sizeof(dpParameters);

    // We care about the Class / SubClass / Programming Interface
    // and the search target Function has to be on the same Bus and
    // Device.

    dpParameters.Flags = PCI_USE_CLASS_SUBCLASS | PCI_USE_PROGIF |
                         PCI_USE_LOCAL_BUS | PCI_USE_LOCAL_DEVICE;



    dpParameters.VendorID       = 0;        // We don't care.
    dpParameters.DeviceID       = 0;        // We don't care.
    dpParameters.RevisionID     = 0;        // We don't care.
    dpParameters.SubVendorID    = 0;        // We don't care.
    dpParameters.SubSystemID    = 0;        // We don't care.
    dpParameters.BaseClass      = PCI_CLASS_SERIAL_BUS_CTLR;
    dpParameters.SubClass       = PCI_SUBCLASS_SB_USB;
    dpParameters.ProgIf         = 0x20;     // USB 2.0 Programming Interface

    //
    // Now call the Device Present Interface to see if the specified
    // device is present.
    //
    result = dpInterface.IsDevicePresentEx(dpInterface.Context,
                                           &dpParameters);

    if (result)
    {
        USBPORT_KdPrint((1,"Found EHCI controller for FDO %08X\n", FdoDeviceObject));
    }
    else
    {
        USBPORT_KdPrint((1,"Did not find EHCI controller for FDO %08X\n", FdoDeviceObject));
    }

    //
    // Set the return value
    //
    *ReturnResult = result;

USBPORT_IsCompanionControllerFreeInterface:
    //
    // We're done with this interface
    //
    dpInterface.InterfaceDereference(dpInterface.Context);

USBPORT_IsCompanionControllerDone:
    //
    // We're done with this device stack
    //
    ObDereferenceObject(targetDevice);

    return status;
}


USB_CONTROLLER_FLAVOR
USBPORT_GetHcFlavor(
    PDEVICE_OBJECT FdoDeviceObject,
    USHORT PciVendorId,
    USHORT PciProductId,
    UCHAR PciRevision
    )
/*++

Routine Description:

    See if this is some known broken HW.

    We look at the VID,PID and rev in addition to
    reg keys.

Arguments:

Return Value:

    HC Flavor

--*/
{
    USB_CONTROLLER_FLAVOR flavor;
    PDEVICE_EXTENSION devExt;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // set a base type from what the miniport told us

    switch (REGISTRATION_PACKET(devExt).HciType) {
    case USB_OHCI:
        flavor = OHCI_Generic;
        break;
    case USB_UHCI:
        flavor = UHCI_Generic;
        break;
    case USB_EHCI:
        flavor = EHCI_Generic;
        break;
    default:
        flavor = USB_HcGeneric;
    }

    // hardcoded checks of vid pid
//    if (PciVendorId == HC_VID_INTEL &&
//        PciProductId == 0x7112) {
//        flavor = UHCI_Piix4;
//    }

    if (PciVendorId == HC_VID_OPTI &&
        PciProductId == HC_PID_OPTI_HYDRA) {
        flavor = OHCI_Hydra;
    }

    if (PciVendorId == HC_VID_INTEL) {
        if (PciProductId == HC_PID_INTEL_ICH2_1) {
            flavor = UHCI_Ich2_1;
        } else if (PciProductId == HC_PID_INTEL_ICH2_2) {
            flavor = UHCI_Ich2_2;
        } else if (PciProductId == HC_PID_INTEL_ICH1) {
            flavor = UHCI_Ich1;
        }
    }

    if (PciVendorId == HC_VID_VIA &&
        PciProductId == HC_PID_VIA) {
        flavor = UHCI_VIA + PciRevision;
    }

    // for now consider rest of UHCI as PIIX4
    if (flavor == UHCI_Generic) {
        flavor = UHCI_Piix4;
    }

    if (flavor == EHCI_Generic) {
        // check for variations of EHCI controllers
        if (PciVendorId == 0x1033) {
            flavor = EHCI_NEC;
        }

        //if (PciProductId == 0x1033) {
        //    flavor == EHCI_Lucent;
        //}
    }

    // identify NEC companion controllers by VID/PID
    if (PciVendorId == HC_VID_NEC_CC &&
        PciProductId == HC_PID_NEC_CC &&
        PciRevision == HC_REV_NEC_CC) {

        // this controller used func 2 for the USB 2 controller
        devExt->Fdo.Usb2BusFunction = 2;
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC);
    }

    // identify VIA companion controllers by VID/PID
    if (PciVendorId == HC_VID_VIA_CC &&
        PciProductId == HC_PID_VIA_CC &&
        PciRevision == HC_REV_VIA_CC) {

        // this controller used func 2 for the USB 2 controller
        devExt->Fdo.Usb2BusFunction = 2;
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC);
    }


    // identify INTEL companion controllers by VID/PID
    if (PciVendorId == HC_VID_INTEL_CC &&
        (PciProductId == HC_PID_INTEL_CC1 ||
         PciProductId == HC_PID_INTEL_CC2 ||
         PciProductId == HC_PID_INTEL_CC3)) {

        // this controller used func 7 for the USB 2 controller
        devExt->Fdo.Usb2BusFunction = 7;
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_IS_CC);
    }


    // now check the registry
    // NOTE: checking the registry last allows this to override
    // any setting from the miniport or the port

    USBPORT_GetRegistryKeyValueForPdo(devExt->HcFdoDeviceObject,
                                          devExt->Fdo.PhysicalDeviceObject,
                                          USBPORT_SW_BRANCH,
                                          FLAVOR_KEY,
                                          sizeof(FLAVOR_KEY),
                                          &flavor,
                                          sizeof(flavor));

    return flavor;
}


ULONG
USBPORT_ComputeTotalBandwidth(
    PDEVICE_OBJECT FdoDeviceObject,
    PVOID BusContext
    )
/*++

Routine Description:

    Compute total bandwidth for this virtual bus

Arguments:

Return Value:

    bandwidth availble on this bus

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG bw;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);
    if (USBPORT_IS_USB20(devExt)) {
        PTRANSACTION_TRANSLATOR translator = BusContext;

        // bus conetext will be a TT if the query
        // is for a 1.1 device atached to a TT or
        // the root hub Pdo if it is a native 2.0
        // device

        if (translator->Sig == SIG_TT) {
            bw = translator->TotalBusBandwidth;
        } else {
            // return bw on or 2.0 bus
            bw = devExt->Fdo.TotalBusBandwidth;
        }
    } else {
        bw = devExt->Fdo.TotalBusBandwidth;
    }

    USBPORT_KdPrint((1,"'Total bus BW %d\n", bw));

    return bw;
}


ULONG
USBPORT_ComputeAllocatedBandwidth(
    PDEVICE_OBJECT FdoDeviceObject,
    PVOID BusContext
    )
/*++

Routine Description:

    Compute total bandwidth currently allocated

Arguments:

Return Value:

    consumed bandwidth in bits/sec

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG totalBW, used, i;
    PTRANSACTION_TRANSLATOR translator = BusContext;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (USBPORT_IS_USB20(devExt) &&
        translator->Sig == SIG_TT) {

        // bus conetext will be a TT if the query
        // is for a 1.1 device atached to a TT or
        // the root hub Pdo if it is a native 2.0
        // device
        totalBW = translator->TotalBusBandwidth;
        used = 0;

        // table contains available bw, total-available = used

        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            if (totalBW - translator->BandwidthTable[i] > used) {
                used = totalBW - translator->BandwidthTable[i];
            }
        }

    } else {
        totalBW = devExt->Fdo.TotalBusBandwidth;
        used = 0;

        // table contains available bw, total-available = used

        for (i=0; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i++) {
            if (totalBW - devExt->Fdo.BandwidthTable[i] > used) {
                used = totalBW - devExt->Fdo.BandwidthTable[i];
            }
        }
    }

    USBPORT_KdPrint((1,"'Bus BW used %d\n", used));

    return used;
}


BOOLEAN
USBPORT_SelectiveSuspendEnabled(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Compute total bandwidth currently allocated

Arguments:

Return Value:

    TRUE if selective suspend supported for this HC

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG disableSelectiveSuspend = 0;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_GetRegistryKeyValueForPdo(devExt->HcFdoDeviceObject,
                                          devExt->Fdo.PhysicalDeviceObject,
                                          USBPORT_SW_BRANCH,
                                          DISABLE_SS_KEY,
                                          sizeof(DISABLE_SS_KEY),
                                          &disableSelectiveSuspend,
                                          sizeof(disableSelectiveSuspend));

#if DBG
    if (disableSelectiveSuspend) {
        USBPORT_KdPrint((1,"'<Selective Suspend> Disabled in Registry for HC\n"));
    }
#endif

    return disableSelectiveSuspend ? FALSE : TRUE;
}


VOID
USBPORT_InitializeSpinLock(
    PUSBPORT_SPIN_LOCK SpinLock,
    LONG SigA,
    LONG SigR
    )
{
    KeInitializeSpinLock(&(SpinLock->sl));
    SpinLock->Check = -1;
    SpinLock->SigA = SigA;
    SpinLock->SigR = SigR;
}

#if DBG
VOID
USBPORT_DbgAcquireSpinLock(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_SPIN_LOCK SpinLock,
    PKIRQL OldIrql
    )
{
    PDEVICE_EXTENSION devExt;
    LONG n;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    KeAcquireSpinLock(&(SpinLock->sl), OldIrql);
    n = InterlockedIncrement(&SpinLock->Check);
    LOGENTRY(NULL, FdoDeviceObject, LOG_SPIN, SpinLock->SigA, 0, 0, n);

    // detect recursively acquired spinlock
    USBPORT_ASSERT(n == 0);
}


VOID
USBPORT_DbgReleaseSpinLock(
    PDEVICE_OBJECT FdoDeviceObject,
    PUSBPORT_SPIN_LOCK SpinLock,
    KIRQL NewIrql
    )
{
    PDEVICE_EXTENSION devExt;
    LONG n;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    n = InterlockedDecrement(&SpinLock->Check);
    LOGENTRY(NULL, FdoDeviceObject, LOG_SPIN, SpinLock->SigR, 0xFFFFFFFF, 0, n);
    USBPORT_ASSERT(n == -1);
    KeReleaseSpinLock(&(SpinLock->sl), NewIrql);
}
#endif

VOID
USBPORT_PowerFault(
    PDEVICE_OBJECT FdoDeviceObject,
    PUCHAR MessageText
    )
/*++

Routine Description:

    A power fault has occurred, dump information we will need
    to debug it.

    In the future we may take additional action such as event
    logging and disabling the controller.

Arguments:

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // take a power dump,
    // lets see the comment police find this one
    USBPORT_KdPrint((0, "*** USBPORT POWER FAULT ***\n"));
    USBPORT_KdPrint((0, "Warning:\n"));
    USBPORT_KdPrint((0, "The USB controller as failed a consistency check\n"));
    USBPORT_KdPrint((0, "following an OS power event.\n"));
    USBPORT_KdPrint((0, "The controller will not function and the system\n"));
    USBPORT_KdPrint((0, "may bugcheck or hang.\n"));

    // print the specific cause
    USBPORT_KdPrint((0, "CAUSE: <%s>\n", MessageText));

    // now dump relevent power information

    USBPORT_KdPrint((0, "FdoDeviceObject: %x\n", FdoDeviceObject));
    USBPORT_KdPrint((0, "Returning from? (SystemState): "));

    switch(devExt->Fdo.LastSystemSleepState) {
    case PowerSystemUnspecified:
        USBPORT_KdPrint((0, "PowerSystemUnspecified"));
        break;
    case PowerSystemWorking:
        USBPORT_KdPrint((0, "PowerSystemWorking"));
        break;
    case PowerSystemSleeping1:
        USBPORT_KdPrint((0, "PowerSystemSleeping1"));
        break;
    case PowerSystemSleeping2:
        USBPORT_KdPrint((0, "PowerSystemSleeping2"));
        break;
    case PowerSystemSleeping3:
        USBPORT_KdPrint((0, "PowerSystemSleeping3"));
        break;
    case PowerSystemHibernate:
        USBPORT_KdPrint((0, "PowerSystemHibernate"));
        break;
    case PowerSystemShutdown:
        USBPORT_KdPrint((0, "PowerSystemShutdown"));
        break;
    }
    USBPORT_KdPrint((0, "\n"));
#if DBG
    // break if we are in debug mode, otherwise this ends up being a warning
    DEBUG_BREAK();
#endif

}


NTSTATUS
USBPORT_CreateLegacyFdoSymbolicLink(
    PDEVICE_OBJECT FdoDeviceObject
    )
/*++

Routine Description:

    Create the legacy symbolic name \\DosDevices\HCDn where
    n = 0...9,A...Z

    Many older applications detect the presence of USB by opening
    HCDn

Arguments:

Return Value:

    none.

--*/
{
    PDEVICE_EXTENSION devExt;
    WCHAR legacyLinkBuffer[]  = L"\\DosDevices\\HCD0";
    WCHAR *buffer;
    UNICODE_STRING deviceNameUnicodeString;
    NTSTATUS ntStatus;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    USBPORT_ASSERT(!TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_LEGACY_SYM_LINK));

    ntStatus = USBPORT_MakeHcdDeviceName(&deviceNameUnicodeString,
                                         devExt->Fdo.DeviceNameIdx);

    if (NT_SUCCESS(ntStatus)) {

        ALLOC_POOL_Z(buffer,
                     PagedPool,
                     sizeof(legacyLinkBuffer));

        if (buffer != NULL) {

            RtlCopyMemory(buffer,
                          legacyLinkBuffer,
                          sizeof(legacyLinkBuffer));

            USBPORT_ASSERT(devExt->Fdo.DeviceNameIdx < 10);
            buffer[15] = (WCHAR)('0'+ devExt->Fdo.DeviceNameIdx);

            RtlInitUnicodeString(&devExt->Fdo.LegacyLinkUnicodeString,
                                 buffer);

            ntStatus =
                IoCreateSymbolicLink(&devExt->Fdo.LegacyLinkUnicodeString,
                                     &deviceNameUnicodeString);

            if (!NT_SUCCESS(ntStatus)) {
                // free now since we won't be setting our flag
                RtlFreeUnicodeString(&devExt->Fdo.LegacyLinkUnicodeString);
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlFreeUnicodeString(&deviceNameUnicodeString);
    }

    if (NT_SUCCESS(ntStatus)) {
        SET_FDO_FLAG(devExt, USBPORT_FDOFLAG_LEGACY_SYM_LINK);
    }

    return ntStatus;
}


#if 0
VOID
USBPORT_WriteErrorLogEntry(
    PDEVICE_OBJECT FdoDeviceObject,
    ULONG DumpDataSize,
    PULONG DumData
    )
/*++

Routine Description:

Arguments:

Return Value:

    none

--*/
{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    ASSERT_PASSIVE();
    errorLogEntry = IoAllocateErrorLogEntry(
        FdoDeviceObject,
        sizeof(IO_ERROR_LOG_PACKET) + DumpDataSize * sizeof(ULONG) +
            sizeof(InsertionStrings)
        );

    if (errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 0;
        errorLogEntry->DumpData[0] = DumpData;
    }

    if (InsertionString) {

        errorLogEntry->StringOffset =
            sizeof(IO_ERROR_LOG_PACKET);

        errorLogEntry->NumberOfStrings = 1;

        RtlCopyMemory(
            ((PCHAR)(errorLogEntry) + errorLogEntry->StringOffset),
            InsertionString->Buffer,
            InsertionString->Length);

    }

    IoWriteErrorLogEntry(errorLogEntry);
}
#endif


NTSTATUS
USBPORT_GetDefaultBIOS_X(
     PDEVICE_OBJECT FdoDeviceObject,
     PULONG BiosX,
     PULONG GlobalDisableSS,
     PULONG GlobalDisableCCDetect,
     PULONG EnIdleEndpointSupport
     )

/*++

Routine Description:

    Read the regkeys defining BIOS specific hacks, these hacks are
    applied globaly to all controllers in the system and usualy
    involve power management.

Arguments:

    DeviceObject - DeviceObject of the controller

Return Value:

    NT status code.

--*/

{
    PDEVICE_EXTENSION devExt;
#define MAX_HACK_KEYS    5
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[MAX_HACK_KEYS];
    PWCHAR usb = L"usb";
    ULONG k = 0;

    PAGED_CODE();

    // Set default BIOS hacks here, these can be overriden by
    // global reg keys based on a particular BIOS rev.

    // set the default behavior then override with the key
    *BiosX = BIOS_X_NO_USB_WAKE_S2;

    //
    // Set up QueryTable to do the following:
    //

    // bios hacks
    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = BIOS_X_KEY;
    QueryTable[k].EntryContext = BiosX;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = BiosX;
    QueryTable[k].DefaultLength = sizeof(*BiosX);
    k++;

    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = G_DISABLE_SS_KEY;
    QueryTable[k].EntryContext = GlobalDisableSS;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = GlobalDisableSS;
    QueryTable[k].DefaultLength = sizeof(*GlobalDisableSS);
    k++;

    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = G_DISABLE_CC_DETECT_KEY;
    QueryTable[k].EntryContext = GlobalDisableCCDetect;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = GlobalDisableCCDetect;
    QueryTable[k].DefaultLength = sizeof(*GlobalDisableCCDetect);
    k++;

    QueryTable[k].QueryRoutine = USBPORT_GetConfigValue;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = G_EN_IDLE_ENDPOINT_SUPPORT;
    QueryTable[k].EntryContext = EnIdleEndpointSupport;
    QueryTable[k].DefaultType = REG_DWORD;
    QueryTable[k].DefaultData = EnIdleEndpointSupport;
    QueryTable[k].DefaultLength = sizeof(*EnIdleEndpointSupport);
    k++;

    USBPORT_ASSERT(k < MAX_HACK_KEYS);

    // stop
    QueryTable[k].QueryRoutine = NULL;
    QueryTable[k].Flags = 0;
    QueryTable[k].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment



#undef MAX_HACK_KEYS

    return ntStatus;
}


VOID
USBPORT_ApplyBIOS_X(
     PDEVICE_OBJECT FdoDeviceObject,
     PDEVICE_CAPABILITIES DeviceCaps,
     ULONG BiosX
     )

/*++

Routine Description:


Arguments:

    DeviceObject - DeviceObject of the controller

Return Value:

--*/

{
    PDEVICE_EXTENSION devExt;
    ULONG wakeHack;
    HC_POWER_STATE_TABLE tmpPowerTable;
    PHC_POWER_STATE hcPowerState;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    if (BiosX == 0) {
        return;
    }

    USBPORT_KdPrint((1, "'USB Apply BIOS Hacks\n"));

    wakeHack = BiosX;

    // change Device Caps to reflect the fact that the controller
    // cannot wake from a given S state

    USBPORT_ComputeHcPowerStates(
        FdoDeviceObject,
        DeviceCaps,
        &tmpPowerTable);

    switch (wakeHack) {
    case BIOS_X_NO_USB_WAKE_S4:
        // this has never been tested
        if (DeviceCaps->SystemWake >= PowerSystemHibernate) {
            USBPORT_KdPrint((1, "'USB BIOS X - disable remote wakeup (S4)\n"));
            TEST_TRAP();
            DeviceCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
            DeviceCaps->SystemWake = PowerSystemSleeping3;
        }
        break;

    case BIOS_X_NO_USB_WAKE_S3:
        // this has never been tested
        if (DeviceCaps->SystemWake >= PowerSystemSleeping3) {
            USBPORT_KdPrint((1, "'USB BIOS X - disable remote wakeup (S3)\n"));
            TEST_TRAP();
            DeviceCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
            DeviceCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
            DeviceCaps->SystemWake = PowerSystemSleeping2;
        }
        break;

    case BIOS_X_NO_USB_WAKE_S2:
        if (DeviceCaps->SystemWake >= PowerSystemSleeping2) {
            USBPORT_KdPrint((1, "'USB BIOS X - disable remote wakeup (S2)\n"));
            DeviceCaps->DeviceState[PowerSystemHibernate] = PowerDeviceUnspecified;
            DeviceCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceUnspecified;
            DeviceCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceUnspecified;
            // mimic how we deterine wake for the root hub
            hcPowerState = USBPORT_GetHcPowerState(FdoDeviceObject,
                                                   &tmpPowerTable,
                                                   PowerSystemSleeping1);
            if (hcPowerState &&
                hcPowerState->Attributes == HcPower_Y_Wakeup_Y) {
                DeviceCaps->SystemWake = PowerSystemSleeping1;
            } else {
                DeviceCaps->SystemWake = PowerSystemUnspecified;
            }
        }
        break;

    case BIOS_X_NO_USB_WAKE_S1:
        // this has never been tested
        if (DeviceCaps->SystemWake >= PowerSystemSleeping1) {
            USBPORT_KdPrint((1, "'USB BIOS X - disable remote wakeup (S1)\n"));
            TEST_TRAP();
            DeviceCaps->DeviceState[PowerSystemHibernate] = PowerDeviceUnspecified;
            DeviceCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceUnspecified;
            DeviceCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceUnspecified;
            DeviceCaps->DeviceState[PowerSystemSleeping1] = PowerDeviceUnspecified;
            DeviceCaps->SystemWake = PowerSystemUnspecified;
        }
        break;

    }

}


USBPORT_OS_VERSION
USBPORT_DetectOSVersion(
     PDEVICE_OBJECT FdoDeviceObject
     )

/*++

Routine Description:


Arguments:

    DeviceObject - DeviceObject of the controller

Return Value:

--*/

{
    PDEVICE_EXTENSION devExt;
    USBPORT_OS_VERSION osVersion;

    if (IoIsWdmVersionAvailable(1, 0x20)) {
        USBPORT_KdPrint((1, "Detected: WinXP\n"));
        osVersion = WinXP;
    } else if (IoIsWdmVersionAvailable(1, 0x10)) {
        USBPORT_KdPrint((1, "Detected: Win2K\n"));
        osVersion = Win2K;
    } else if (IoIsWdmVersionAvailable(1, 0x05)) {
        USBPORT_KdPrint((1, "Detected: WinMe\n"));
        osVersion = WinMe;
    } else {
        // 98 or 98se
        USBPORT_KdPrint((1, "Detected: Win98\n"));
        osVersion = Win98;
    }

    return osVersion;
}


VOID
USBPORT_WriteHaction(
     PDEVICE_OBJECT Usb2FdoDeviceObject,
     ULONG Haction
     )

/*++

Routine Description:

    specify 'hactions' for the CC to be taken by the
    coinstaller

Arguments:

    DeviceObject - DeviceObject of the USB 2 controller

Return Value:

--*/

{
    PDEVICE_EXTENSION devExt;
    PDEVICE_RELATIONS devRelations;
    NTSTATUS ntStatus;
    ULONG i;

    PAGED_CODE();

    devRelations =
        USBPORT_FindCompanionControllers(Usb2FdoDeviceObject,
                                         FALSE,
                                         FALSE);

    for (i=0; devRelations && i< devRelations->Count; i++) {
        PDEVICE_OBJECT pdo = devRelations->Objects[i];

        ntStatus = USBPORT_SetRegistryKeyValueForPdo(
                            pdo,
                            USBPORT_HW_BRANCH,
                            REG_DWORD,
                            HACTION_KEY,
                            sizeof(HACTION_KEY),
                            &Haction,
                            sizeof(Haction));

        LOGENTRY(NULL, Usb2FdoDeviceObject, LOG_PNP, 'Hact', pdo,
            Haction, ntStatus);

    }

    // thou shall not leak memory
    if (devRelations != NULL) {
        FREE_POOL(Usb2FdoDeviceObject, devRelations);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\usbport.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usbport.h

Abstract:

    private header for usb port driver

Environment:

    Kernel & user mode

Revision History:

    10-27-95 : created

--*/

#ifndef   __USBPORT_H__
#define   __USBPORT_H__

/* This is the goatcode */
#define USBPORT_TRACKING_ID              3

//#define USBPERF // perf changes for windows XP second edition, longhorn?
#define XPSE   // bug fixes for XP second edition, longhorn or SP?
#define LOG_OCA_DATA    // enable saving oca crash data on stack

/* OS version we recognize */

typedef enum _USBPORT_OS_VERSION {
    Win98 = 0,
    WinMe,
    Win2K,
    WinXP
} USBPORT_OS_VERSION;


#define USBD_STATUS_NOT_SET     0xFFFFFFFF

#define SIG_DEVICE_HANDLE       'HveD'  //DevH
#define SIG_PIPE_HANDLE         'HpiP'  //PipH
#define SIG_TRANSFER            'CxrT'  //TrxC
#define SIG_CMNBUF              'BnmC'  //CmnB
#define SIG_CONFIG_HANDLE       'HgfC'  //CfgH
#define SIG_INTERFACE_HANDLE    'HxfI'  //IfxH
#define SIG_ENDPOINT            'PEch'  //hcEP
#define SIG_ISOCH               'cosI'  //Isoc
#define SIG_MP_TIMR             'MITm'  //mTIM
#define SIG_TT                  'TTch'  //hcTT
#define SIG_FREE                'xbsu'  //usbx
#define SIG_DB                  'BBsu'  //usBB
#define SIG_IRPC                'Cpri'  //irpC
#define SIG_REG_CACHE           'Cger'  //regC

// The USBPORT_ADDRESS_AND_SIZE_TO_SPAN_PAGES_4K macro takes a virtual address
// and size and returns the number of host controller 4KB pages spanned by
// the size.
//
#define USBPORT_ADDRESS_AND_SIZE_TO_SPAN_PAGES_4K(Va,Size) \
   (((((Size) - 1) >> USB_PAGE_SHIFT) + \
   (((((ULONG)(Size-1)&(USB_PAGE_SIZE-1)) + (PtrToUlong(Va) & (USB_PAGE_SIZE -1)))) >> USB_PAGE_SHIFT)) + 1L)


#define STATUS_BOGUS            0xFFFFFFFF

// deadman timer interval in milliseconds
#define USBPORT_DM_TIMER_INTERVAL   500

/*
    Dummy USBD extension
*/
extern PUCHAR USBPORT_DummyUsbdExtension;
#define USBPORT_DUMMY_USBD_EXT_SIZE 512

/*
    Registry Keys
*/

// Software Branch PDO Keys
#define USBPORT_SW_BRANCH   TRUE

#define FLAVOR_KEY                      L"HcFlavor"
#define BW_KEY                          L"TotalBusBandwidth"
#define DISABLE_SS_KEY                  L"HcDisableSelectiveSuspend"
#define USB2_CC_ID                      L"Usb2cc"
#define EN_IDLE_ENDPOINT_SUPPORT        L"EnIdleEndpointSupport"


// Hardware Branch PDO Keys
// HKLM\CCS\ENUM\PCI\DeviceParameters
#define USBPORT_HW_BRANCH   FALSE

#define SYM_LINK_KEY                    L"SymbolicName"
#define SYM_LEGSUP_KEY                  L"DetectedLegacyBIOS"
#define PORT_ATTRIBUTES_KEY             L"PortAttrX"
#define HACTION_KEY                     L"Haction"

// Global Reg Keys HKLM\CCS\Services\USB
#define DEBUG_LEVEL_KEY                 L"debuglevel"
#define DEBUG_WIN9X_KEY                 L"debugWin9x"
#define DEBUG_BREAK_ON                  L"debugbreak"
#define DEBUG_LOG_MASK                  L"debuglogmask"
#define DEBUG_CLIENTS                   L"debugclients"
#define DEBUG_CATC_ENABLE               L"debugcatc"
#define DEBUG_LOG_ENABLE                L"debuglogenable"

#define BIOS_X_KEY                      L"UsbBIOSx"
#define G_DISABLE_SS_KEY                L"DisableSelectiveSuspend"
#define G_DISABLE_CC_DETECT_KEY         L"DisableCcDetect"
#define G_EN_IDLE_ENDPOINT_SUPPORT      L"EnIdleEndpointSupport"


#define ENABLE_DCA                      L"EnableDCA"

/*
    BIOS Hacks
*/

// Wake hacks, these are exclusive
// diable wake s1 and deeper
#define BIOS_X_NO_USB_WAKE_S1    0x000000001
// disable wake s2 and deeper
#define BIOS_X_NO_USB_WAKE_S2    0x000000002
// disable wake s3 and deeper
#define BIOS_X_NO_USB_WAKE_S3    0x000000004
// disable wake s4 and deeper
#define BIOS_X_NO_USB_WAKE_S4    0x000000008


/*
    HC types
    define known HC types

*/

// Opti Hydra derivative
#define HC_VID_OPTI             0x1045
#define HC_PID_OPTI_HYDRA       0xC861

// Intel USB 2.0 controller emulator
#define HC_VID_INTEL            0x8086
#define HC_PID_INTEL_960        0x6960
#define HC_PID_INTEL_ICH2_1     0x2442
#define HC_PID_INTEL_ICH2_2     0x2444
#define HC_PID_INTEL_ICH1       0x2412

// VIA USB controller
#define HC_VID_VIA              0x1106
#define HC_PID_VIA              0x3038

// NEC USB companion controller
#define HC_VID_NEC_CC           0x1033
#define HC_PID_NEC_CC           0x0035
#define HC_REV_NEC_CC           0x41

// VIA USB companion controller
#define HC_VID_VIA_CC           0x1106
#define HC_PID_VIA_CC           0x3038
#define HC_REV_VIA_CC           0x50


// Intel USB companion controller
#define HC_VID_INTEL_CC         0x8086
#define HC_PID_INTEL_CC1        0x24C2
#define HC_PID_INTEL_CC2        0x24C4
#define HC_PID_INTEL_CC3        0x24C7


#define PENDPOINT_DATA PVOID
#define PDEVICE_DATA PVOID
#define PTRANSFER_CONTEXT PVOID

// the maximum interval we support for an interrupt
// endpoint in the schedule, larger intervals are
// rounded down
#define USBPORT_MAX_INTEP_POLLING_INTERVAL    32

/*
    Power sttructures
*/

#define USBPORT_MAPPED_SLEEP_STATES     4

typedef enum _HC_POWER_ATTRIBUTES {
    HcPower_Y_Wakeup_Y = 0,
    HcPower_N_Wakeup_N,
    HcPower_Y_Wakeup_N,
    HcPower_N_Wakeup_Y
} HC_POWER_ATTRIBUTES;

typedef struct _HC_POWER_STATE {
    SYSTEM_POWER_STATE  SystemState;
    DEVICE_POWER_STATE  DeviceState;
    HC_POWER_ATTRIBUTES Attributes;
} HC_POWER_STATE, *PHC_POWER_STATE;

typedef struct _HC_POWER_STATE_TABLE {
    HC_POWER_STATE PowerState[USBPORT_MAPPED_SLEEP_STATES];
} HC_POWER_STATE_TABLE, *PHC_POWER_STATE_TABLE;


/*
    common structure used to represent transfer
    requests
*/

typedef struct _TRANSFER_URB {

    struct _URB_HEADER Hdr;

    PVOID UsbdPipeHandle;
    ULONG TransferFlags;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;
    PVOID ReservedMBNull;           // no Linked Urbs

    struct _USBPORT_DATA pd;        // fields for USBPORT use

    union {
        struct {
            ULONG StartFrame;
            ULONG NumberOfPackets;
            ULONG ErrorCount;
            USBD_ISO_PACKET_DESCRIPTOR IsoPacket[0];
        } Isoch;
        UCHAR SetupPacket[8];
    } u;

} TRANSFER_URB, *PTRANSFER_URB;

/* Internal IRP tracking structure */

typedef struct _TRACK_IRP {
    PIRP Irp;
    LIST_ENTRY ListEntry;
} TRACK_IRP, *PTRACK_IRP;


/* Internal work item structure */

typedef struct _USB_POWER_WORK {
     WORK_QUEUE_ITEM QueueItem;
     PDEVICE_OBJECT FdoDeviceObject;
} USB_POWER_WORK, *PUSB_POWER_WORK;

/* tracking information for OCA online crash analysis */

#define SIG_USB_OCA1       '1aco'  //oca1
#define SIG_USB_OCA2       '2aco'  //oca2

// save 16 chars of driver name
#define USB_DRIVER_NAME_LEN 16

#ifdef LOG_OCA_DATA
typedef struct _OCA_DATA {
    ULONG OcaSig1;
    PIRP Irp;
    USHORT DeviceVID;
    USHORT DevicePID;
    UCHAR AnsiDriverName[USB_DRIVER_NAME_LEN];
    USB_CONTROLLER_FLAVOR HcFlavor;
    ULONG OcaSig2;
} OCA_DATA, *POCA_DATA;
#endif

/*
    this is the structure we use to track
       common buffer blocks we allocate.

    The virtual address of this structure is the
    pointer returned from HalAllocateCommonBuffer
*/

typedef struct _USBPORT_COMMON_BUFFER {

    ULONG Sig;
    ULONG Flags;

    // total length of block,
    // including header and any padding
    ULONG TotalLength;
    // va address returned by the hal
    PVOID VirtualAddress;
    // phys address returned by the hal
    PHYSICAL_ADDRESS LogicalAddress;

    // page aligned VirtualAddress
    PUCHAR BaseVa;
    // page aligned 32 bit phyical address
    HW_32BIT_PHYSICAL_ADDRESS BasePhys;

    // va passed to the miniport
    ULONG MiniportLength;
    ULONG PadLength;

    // va passed to the miniport
    PVOID MiniportVa;
    // phys address passed to miniport
    HW_32BIT_PHYSICAL_ADDRESS MiniportPhys;

} USBPORT_COMMON_BUFFER, *PUSBPORT_COMMON_BUFFER;

//
// use to track transfer irps in the port driver
// this size is totally arbitrary -- I just picked 512
#define IRP_TABLE_LENGTH  512

typedef struct _USBPORT_IRP_TABLE {
    struct _USBPORT_IRP_TABLE *NextTable;
    PIRP Irps[IRP_TABLE_LENGTH];
} USBPORT_IRP_TABLE, *PUSBPORT_IRP_TABLE;

#define USBPORT_InsertActiveTransferIrp(fdo, irp) \
    {\
    PDEVICE_EXTENSION devExt;\
    GET_DEVICE_EXT(devExt, (fdo));\
    ASSERT_FDOEXT(devExt);\
    USBPORT_InsertIrpInTable((fdo), devExt->ActiveTransferIrpTable, (irp));\
    }

#define USBPORT_InsertPendingTransferIrp(fdo, irp) \
    {\
    PDEVICE_EXTENSION devExt;\
    GET_DEVICE_EXT(devExt, (fdo));\
    ASSERT_FDOEXT(devExt);\
    USBPORT_InsertIrpInTable((fdo), devExt->PendingTransferIrpTable, (irp));\
    }

#define USBPORT_CHECK_URB_ACTIVE(fdo, urb, inIrp) \
    {\
    PDEVICE_EXTENSION devExt;\
    GET_DEVICE_EXT(devExt, (fdo));\
    ASSERT_FDOEXT(devExt);\
    USBPORT_FindUrbInIrpTable((fdo), devExt->ActiveTransferIrpTable, (urb), \
        (inIrp));\
    }

/*
    The goal of these structures is to keep the
    spinlocks a cache line away from each other
    and a cache line away from the data structures
    they protect.

    Apparently there is an advantage to doing this
    on MP systems
*/

typedef struct _USBPORT_SPIN_LOCK {

    union {
        KSPIN_LOCK sl;
        // bugbug -- needs to be cache line size
        UCHAR CacheLineSize[16];
    };

    LONG Check;
    ULONG SigA;
    ULONG SigR;

} USBPORT_SPIN_LOCK, *PUSBPORT_SPIN_LOCK;


/*
    structure we use to track bound drivers
*/

typedef struct _USBPORT_MINIPORT_DRIVER {

    // driver object assocaited with this particular
    // miniport
    PDRIVER_OBJECT DriverObject;

    LIST_ENTRY ListEntry;

    PDRIVER_UNLOAD MiniportUnload;

    ULONG HciVersion;
    // copy of the registration packet passed in
    USBPORT_REGISTRATION_PACKET RegistrationPacket;

} USBPORT_MINIPORT_DRIVER, *PUSBPORT_MINIPORT_DRIVER;


/*
    A separate context structure used for IRP tracking.
    we do this because clients frequently free the IRP
    while it is pending corrupting any lists linked with
    the irp itself.
*/
typedef struct _USB_IRP_CONTEXT {
    ULONG Sig;
    LIST_ENTRY ListEntry;
    struct _USBD_DEVICE_HANDLE *DeviceHandle;
    PIRP Irp;
} USB_IRP_CONTEXT, *PUSB_IRP_CONTEXT;


#define USBPORT_TXFLAG_CANCELED             0x00000001
#define USBPORT_TXFLAG_MAPPED               0x00000002
#define USBPORT_TXFLAG_HIGHSPEED            0x00000004
#define USBPORT_TXFLAG_IN_MINIPORT          0x00000008
#define USBPORT_TXFLAG_ABORTED              0x00000010
#define USBPORT_TXFLAG_ISO                  0x00000020
#define USBPORT_TXFLAG_TIMEOUT              0x00000040
#define USBPORT_TXFLAG_DEVICE_GONE          0x00000080
#define USBPORT_TXFLAG_SPLIT_CHILD          0x00000100
#define USBPORT_TXFLAG_MPCOMPLETED          0x00000200
#define USBPORT_TXFLAG_SPLIT                0x00000400
#define USBPORT_TXFLAG_KILL_SPLIT           0x00000800


typedef enum _USBPORT_TRANSFER_DIRECTION {
    NotSet = 0,
    ReadData,       // ie in
    WriteData,      // ie out
} USBPORT_TRANSFER_DIRECTION;


typedef struct _HCD_TRANSFER_CONTEXT {

    ULONG Sig;

    ULONG Flags;

    // Total length of this structure
    ULONG TotalLength;
    // length up to miniport context
    ULONG PrivateLength;

    USBPORT_TRANSFER_DIRECTION Direction;
    // timeout, 0 = no timeout
    ULONG MillisecTimeout;
    LARGE_INTEGER TimeoutTime;

    // for perf work
    ULONG MiniportFrameCompleted;
    // track bytes transferred this transfer
    ULONG MiniportBytesTransferred;
    USBD_STATUS UsbdStatus;

    // irp to signal on completion
    PIRP Irp;
    // event to signal on completion
    PKEVENT CompleteEvent;

    // point back to the original URB
    PTRANSFER_URB Urb;

    // for linkage on endpoint lists
    LIST_ENTRY TransferLink;

    KSPIN_LOCK Spin;

    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;

    TRANSFER_PARAMETERS Tp;
    PMDL TransferBufferMdl;
    // used for perf
    ULONG IoMapStartFrame;

    // for Double buffering
    LIST_ENTRY DoubleBufferList;

    // parent transfer
    struct _HCD_TRANSFER_CONTEXT *Transfer;
    struct _HCD_ENDPOINT *Endpoint;

    PUCHAR MiniportContext;

    LIST_ENTRY SplitTransferList;
    LIST_ENTRY SplitLink;

    PMINIPORT_ISO_TRANSFER IsoTransfer;

    // OCA info from device
    USHORT DeviceVID;
    USHORT DevicePID;
    WCHAR DriverName[USB_DRIVER_NAME_LEN];

    TRANSFER_SG_LIST SgList;

} HCD_TRANSFER_CONTEXT, *PHCD_TRANSFER_CONTEXT;


/*
    The pipe handle structure us our primary means of
    tracking USB endpoints.  Contained within the handle
    is our endpoint data structure as well as the
    miniport endpoint data structure.
*/

typedef VOID
    (__stdcall *PENDPOINT_WORKER_FUNCTION) (
        struct _HCD_ENDPOINT *
    );

#define EPFLAG_MAP_XFERS        0x00000001
// ep is part of root hub
#define EPFLAG_ROOTHUB          0x00000002
//replaced with dedicated flag
//#define EPFLAG_LOCKED           0x00000004
// power management hosed this endpoint
#define EPFLAG_NUKED            0x00000008
// cleared when we receive a transfer for
// the endpoint reset when the pipe gets
// reset
#define EPFLAG_VIRGIN           0x00000010

#define EPFLAG_DEVICE_GONE      0x00000020
// enpoint used by vbus (virtual bus)
#define EPFLAG_VBUS             0x00000040
// enpoint is large ISO allowed for this TT
#define EPFLAG_FATISO           0x00000080

typedef struct _HCD_ENDPOINT {

    ULONG Sig;
    ULONG Flags;
    ULONG LockFlag;
    LONG Busy;
    PDEVICE_OBJECT FdoDeviceObject;

    DEBUG_LOG Log;

    // NOTE: must be careful with this pointer as the
    // endpoint can exist after the device handle
    // is removed
    struct _USBD_DEVICE_HANDLE *DeviceHandle;
    struct _TRANSACTION_TRANSLATOR *Tt;

    MP_ENDPOINT_STATUS CurrentStatus;
    MP_ENDPOINT_STATE CurrentState;
    MP_ENDPOINT_STATE NewState;
    ULONG StateChangeFrame;

    PENDPOINT_WORKER_FUNCTION EpWorkerFunction;
    LIST_ENTRY ActiveList;
    LIST_ENTRY PendingList;
    LIST_ENTRY CancelList;
    LIST_ENTRY AbortIrpList;

    // for linkage to global endpoint list
    LIST_ENTRY GlobalLink;
    LIST_ENTRY AttendLink;
    LIST_ENTRY StateLink;
    LIST_ENTRY ClosedLink;
    LIST_ENTRY BusyLink;
    LIST_ENTRY KillActiveLink;
    LIST_ENTRY TimeoutLink;
    LIST_ENTRY FlushLink;
    LIST_ENTRY PriorityLink;
    LIST_ENTRY RebalanceLink;
    LIST_ENTRY TtLink;

    USBPORT_SPIN_LOCK ListSpin;
    USBPORT_SPIN_LOCK StateChangeSpin;

    KIRQL LockIrql;
    KIRQL ScLockIrql;
    UCHAR Pad[2];

    // iso stuff
    ULONG NextTransferStartFrame;

    PUSBPORT_COMMON_BUFFER CommonBuffer;
    ENDPOINT_PARAMETERS Parameters;

    PVOID Usb2LibEpContext;
    // used to stall close endpoint when we may still need access
    LONG EndpointRef;

    struct _HCD_ENDPOINT *BudgetNextEndpoint;

    // iso stat counters
    // late frames - count of packets passed by calling driver that were
    // too late to transmit
    ULONG lateFrames;
    // gap frames - these are empty frames resulting from gaps in the
    // stream, these are casued by periods between iso submissions
    ULONG gapFrames;
    // error frames - these are frames for which we passed a packet to
    // the miniport and were completed with an error
    ULONG errorFrames;

    // iso transaction log
    DEBUG_LOG IsoLog;

    PVOID MiniportEndpointData[0];  // PVOID for IA64 alignment

} HCD_ENDPOINT, *PHCD_ENDPOINT;

#define USBPORT_TTFLAG_REMOVED      0x00000001

typedef struct _TRANSACTION_TRANSLATOR {

    ULONG Sig;

    ULONG TtFlags;
    USHORT DeviceAddress;
    USHORT Port;

    LIST_ENTRY EndpointList;
    LIST_ENTRY TtLink;
    PDEVICE_OBJECT PdoDeviceObject;

    ULONG TotalBusBandwidth;
    ULONG BandwidthTable[USBPORT_MAX_INTEP_POLLING_INTERVAL];

    ULONG MaxAllocedBw;
    ULONG MinAllocedBw;

    PVOID Usb2LibTtContext[0];  // PVOID for IA64 alignment

} TRANSACTION_TRANSLATOR, *PTRANSACTION_TRANSLATOR;


#define EP_MAX_TRANSFER(ep) ((ep)->Parameters.MaxTransferSize)
#define EP_MAX_PACKET(ep) ((ep)->Parameters.MaxPacketSize)


#define USBPORT_PIPE_STATE_CLOSED  0x00000001
#define USBPORT_PIPE_ZERO_BW       0x00000002

typedef struct _USBD_PIPE_HANDLE_I {

    ULONG Sig;
    USB_ENDPOINT_DESCRIPTOR EndpointDescriptor;

    ULONG PipeStateFlags;

    ULONG UsbdPipeFlags;

    PHCD_ENDPOINT Endpoint;

    // for pipe handle list attached to device
    LIST_ENTRY ListEntry;

} USBD_PIPE_HANDLE_I, *PUSBD_PIPE_HANDLE_I;

#define INITIALIZE_DEFAULT_PIPE(dp, mp) \
    do {\
    (dp).UsbdPipeFlags = 0;\
    (dp).EndpointDescriptor.bLength =\
            sizeof(USB_ENDPOINT_DESCRIPTOR);\
    (dp).EndpointDescriptor.bDescriptorType =\
            USB_ENDPOINT_DESCRIPTOR_TYPE;\
    (dp).EndpointDescriptor.bEndpointAddress =\
            USB_DEFAULT_ENDPOINT_ADDRESS;\
    (dp).EndpointDescriptor.bmAttributes =\
            USB_ENDPOINT_TYPE_CONTROL;\
    (dp).EndpointDescriptor.wMaxPacketSize =\
            mp;\
    (dp).EndpointDescriptor.bInterval = 0;\
    (dp).Sig = SIG_PIPE_HANDLE;\
    (dp).PipeStateFlags = USBPORT_PIPE_STATE_CLOSED;\
    } while(0)


typedef struct _USBD_INTERFACE_HANDLE_I {
    ULONG Sig;
    LIST_ENTRY InterfaceLink;
    BOOLEAN HasAlternateSettings;
    // number associated with this interface defined
    // in the interface descriptor
    UCHAR Pad[3];
    // copy of interface descriptor (header) ie no endpoints
    // the endpoint descriptors are in the PipeHandles
    USB_INTERFACE_DESCRIPTOR InterfaceDescriptor;
    // array of pipe handle structures
    USBD_PIPE_HANDLE_I PipeHandle[0];
} USBD_INTERFACE_HANDLE_I, *PUSBD_INTERFACE_HANDLE_I;


typedef struct _USBD_CONFIG_HANDLE {
    ULONG Sig;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;
    LIST_ENTRY InterfaceHandleList;
} USBD_CONFIG_HANDLE, *PUSBD_CONFIG_HANDLE;

#define TEST_DEVICE_FLAG(dh, flag) ((dh)->DeviceFlags & (flag)) ? TRUE : FALSE
#define SET_DEVICE_FLAG(dh, flag) ((dh)->DeviceFlags |= (flag))
#define CLEAR_DEVICE_FLAG(dh, flag) ((dh)->DeviceFlags &= ~(flag))

// values for DveiceFlags
#define USBPORT_DEVICEFLAG_FREED_BY_HUB         0x00000001
#define USBPORT_DEVICEFLAG_ROOTHUB              0x00000002
#define USBPORT_DEVICEFLAG_RAWHANDLE            0x00000004
#define USBPORT_DEVICEFLAG_REMOVED              0x00000008
#define USBPORT_DEVICEFLAG_HSHUB                0x00000010


#define IS_ROOT_HUB(dh) (BOOLEAN)((dh)->DeviceFlags & USBPORT_DEVICEFLAG_ROOTHUB)

/*
  TopologyAddress
The USB topology address is a string of bytes
representing a the devices location in the usb
tree. This address is unique bud depends entirely
on which port the device is attached.

 The byte array is 5 bytes long looks like this:

 [0] root hub
 [1] 1st tier hub
 [2] 2nd tier hub
 [3] 3rd tier hub

 [4] 4th tier hub
 [5] 5th tier hub
 [6] reserved MBZ
 [7] reserved MBZ

* the spec defines a maximum of five hubs
* the spec defines a maximum of 127 ports/hub

 the entry in the array indicates the port to which the
 device is attached

0, 0, 0, 0, 0, 0, r0, r0 - defines the root hub
1, 0, 0, 0, 0, 0, r0, r0 - defines a device attached to port 1 of the root hub

                                 --p1
              / p1               |-p2
       p1-HUB1- p2     / p1      |-p3
     /        \ p3-HUB2- p2 -HUB3--p4
 root                  \ p3      \-p5-HUB4-p1-DEV
     \                                    \p2
       p2

1, 3, 2, 5, 1, 0, r0, r0 - defines the above device
*/

typedef struct _USBD_DEVICE_HANDLE {
    ULONG Sig;
     // USB address assigned to the device
    USHORT DeviceAddress;
    USHORT TtPortNumber;

    LONG PendingUrbs;

    struct _TRANSACTION_TRANSLATOR *Tt;
    struct _USBD_DEVICE_HANDLE *HubDeviceHandle;

    PUSBD_CONFIG_HANDLE ConfigurationHandle;

    USBD_PIPE_HANDLE_I DefaultPipe;
    USB_DEVICE_SPEED DeviceSpeed;

    // a copy of the USB device descriptor
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;

    ULONG DeviceFlags;

    // used to created a list of valid device
    // handles
    LIST_ENTRY ListEntry;

    // keep a list of valid open
    // pipes
    LIST_ENTRY PipeHandleList;

    ULONG TtCount;
    // keep a list of tt structures for high speed
    // hubs
    LIST_ENTRY TtList;

    PDEVICE_OBJECT  DevicePdo;
    WCHAR DriverName[USB_DRIVER_NAME_LEN];

} USBD_DEVICE_HANDLE, *PUSBD_DEVICE_HANDLE;

// we serialize access to the device handle thru a
// semaphore, the reason for this is that we need
// exclusive access when we set the configuration or
// interface


#define LOCK_DEVICE(dh, fdo) \
        { \
            PDEVICE_EXTENSION devExt;\
            GET_DEVICE_EXT(devExt, (fdo)); \
            USBPORT_KdPrint((2, "'***LOCK_DEVICE %x\n", (dh))); \
            LOGENTRY(NULL, (fdo), LOG_PNP, 'LKdv', (dh), 0, 0);\
            KeWaitForSingleObject(&(devExt)->Fdo.DeviceLock, \
                                  Executive,\
                                  KernelMode, \
                                  FALSE, \
                                  NULL); \
         }

#define UNLOCK_DEVICE(dh, fdo) \
        { \
            PDEVICE_EXTENSION devExt;\
            GET_DEVICE_EXT(devExt, (fdo)); \
            USBPORT_KdPrint((2, "'***UNLOCK_DEVICE %x\n", (dh))); \
            LOGENTRY(NULL, (fdo), LOG_PNP, 'UKdv', (dh), 0, 0);\
            KeReleaseSemaphore(&(devExt)->Fdo.DeviceLock,\
                               LOW_REALTIME_PRIORITY,\
                               1,\
                               FALSE);\
         }


#define USBPORT_BAD_HANDLE ((PVOID)(-1))
#define USBPORT_BAD_POINTER ((PVOID)(-1))


// PnPStateFlags

#define USBPORT_PNP_STOPPED             0x00000001
#define USBPORT_PNP_STARTED             0x00000002
#define USBPORT_PNP_REMOVED             0x00000004
#define USBPORT_PNP_START_FAILED        0x00000008
#define USBPORT_PNP_DELETED             0x00000010

// Flags:both FDO and PDO
#define USBPORT_FLAG_SYM_LINK           0x00000001


#define TEST_FDO_FLAG(de, flag) (((de)->Fdo.FdoFlags & (flag)) ? TRUE : FALSE)
#define SET_FDO_FLAG(de, flag) ((de)->Fdo.FdoFlags |= (flag))
#define CLEAR_FDO_FLAG(de, flag) ((de)->Fdo.FdoFlags &= ~(flag))


#define TEST_PDO_FLAG(de, flag) (((de)->Pdo.PdoFlags & (flag)) ? TRUE : FALSE)
#define SET_PDO_FLAG(de, flag) ((de)->Pdo.PdoFlags |= (flag))
#define CLEAR_PDO_FLAG(de, flag) ((de)->Pdo.PdoFlags &= ~(flag))


// FdoFlags: Fdo Only
#define USBPORT_FDOFLAG_IRQ_CONNECTED           0x00000001
#define USBPORT_FDOFLAG_ENABLE_SYSTEM_WAKE      0x00000002
#define USBPORT_FDOFLAG_POLL_CONTROLLER         0x00000004
// set to indicate the worker thread should
// terminate
#define USBPORT_FDOFLAG_KILL_THREAD             0x00000008
// set if the HC should be wake enabled on the
// next D power state transition
#define USBPORT_FDOFLAG_WAKE_ENABLED            0x00000010
// set to indicate the controller should
// be put in D0 by the worker thread
#define USBPORT_FDOFLAG_NEED_SET_POWER_D0       0x00000020
// set when the DM_timer is running
#define USBPORT_FDOFLAG_DM_TIMER_ENABLED        0x00000040
// set to disable the DM tiners work
// while controller is in low power
#define USBPORT_FDOFLAG_SKIP_TIMER_WORK         0x00000080

// **NOTE: the following two flags are
// Mutually Exclusive
//
// since the true power state of the HW must remain independent
// of OS power management we have our own flags for this.
// set to indicate the controller is 'suspended'
#define USBPORT_FDOFLAG_SUSPENDED               0x00000100
// set to indicate the controller is 'OFF'
#define USBPORT_FDOFLAG_OFF                     0x00000200

#define USBPORT_FDOFLAG_IRQ_EN                  0x00000400
// set if the controller can 'suspend' the root hub
// this is the dynamic flag use to turn SS on and off
#define USBPORT_FDOFLAG_RH_CAN_SUSPEND          0x00000800
// set if controller detects resume signalling
#define USBPORT_FDOFLAG_RESUME_SIGNALLING       0x00001000

#define USBPORT_FDOFLAG_HCPENDING_WAKE_IRP      0x00002000
// set if we initialize the dm timer, used to
// bypass timer stop on failure
#define USBPORT_FDOFLAG_DM_TIMER_INIT           0x00004000
// set if we init the worker thread
#define USBPORT_FDOFLAG_THREAD_INIT             0x00008000
// means we created the HCDn symbolic name
#define USBPORT_FDOFLAG_LEGACY_SYM_LINK         0x00010000
// some knucklehead pulled out the controller
#define USBPORT_FDOFLAG_CONTROLLER_GONE         0x00020000
// miniport has requested hw reset
#define USBPORT_FDOFLAG_HW_RESET_PENDING        0x00040000
// set if tlegacy BIOS detected
#define USBPORT_FDOFLAG_LEGACY_BIOS             0x00080000

#define USBPORT_FDOFLAG_CATC_TRAP               0x00100000
/* polls hw while suspended */
#define USBPORT_FDOFLAG_POLL_IN_SUSPEND         0x00200000
#define USBPORT_FDOFLAG_FAIL_URBS               0x00400000
/* turn on Intel USB diag mode */
#define USBPORT_FDOFLAG_DIAG_MODE               0x00800000
/* set if 1.1 controller is CC */
#define USBPORT_FDOFLAG_IS_CC                   0x01000000
/* synchronize registration with our ouwn start
   stop routine, not intened to sync between instances */
#define USBPORT_FDOFLAG_FDO_REGISTERED          0x02000000
/* OK to enumerate devices on CC (usb 2o disabled) */
#define USBPORT_FDOFLAG_CC_ENUM_OK              0x04000000
/* This is a static flag that causes selective
   suspend to always be disabled */
#define USBPORT_FDOFLAG_DISABLE_SS              0x08000000
#define USBPORT_FDOFLAG_CC_LOCK                 0x10000000
/* indicates we are on the PNP thread */
#define USBPORT_FDOFLAG_ON_PNP_THREAD           0x20000000

/* signals OK to enumerate on the root hub */
#define USBPORT_FDOFLAG_SIGNAL_RH               0x80000000


// PdoFlags: Pdo Only
#define USBPORT_PDOFLAG_HAVE_IDLE_IRP           0x00000001

// MiniportStateFlags
//  miniport is either started (set) OR not started (clear)
#define MP_STATE_STARTED                0x00000001
#define MP_STATE_SUSPENDED              0x00000002

// USB HC wake states

typedef enum _USBHC_WAKE_STATE {
    HCWAKESTATE_DISARMED             =1,
    HCWAKESTATE_WAITING              =2,
    HCWAKESTATE_WAITING_CANCELLED    =3,
    HCWAKESTATE_ARMED                =4,
    HCWAKESTATE_ARMING_CANCELLED     =5,
    HCWAKESTATE_COMPLETING           =7
} USBHC_WAKE_STATE;


typedef struct _FDO_EXTENSION {

    // Device object that the bus extender created for
    // us
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Device object of the first guy on the stack
    // -- the guy we pass our Irps on to.
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // PhysicalDeviceObject we create for the
    // root hub
    PDEVICE_OBJECT RootHubPdo;
    // serialize access to the root hub data structures
    USBPORT_SPIN_LOCK RootHubSpin;

    // pointer to miniport Data
    PDEVICE_DATA MiniportDeviceData;
    PUSBPORT_MINIPORT_DRIVER MiniportDriver;

    PUSBPORT_COMMON_BUFFER ScratchCommonBuffer;

    ULONG DeviceNameIdx;
    LONG WorkerDpc;

    // total bandwidth of the wire in bits/sec
    // USB 1.1 is 12000 (12 MBits/sec)
    // USB 2.0 is 400000 (400 MBits/sec)
    ULONG TotalBusBandwidth;
    ULONG BandwidthTable[USBPORT_MAX_INTEP_POLLING_INTERVAL];

    // track alloactions
    // for periods 1, 2, 4, 8, 16, 32
    // in bits/sec
    ULONG AllocedInterruptBW[6];
    ULONG AllocedIsoBW;
    ULONG AllocedLowSpeedBW;

    ULONG MaxAllocedBw;
    ULONG MinAllocedBw;

    ULONG FdoFlags;
    ULONG MpStateFlags;
    LONG DmaBusy;

    USB_CONTROLLER_FLAVOR HcFlavor;
    USHORT PciVendorId;
    // PCI deviceId == USB productId
    USHORT PciDeviceId;
    // PCI revision == USB bcdDevice
    UCHAR PciRevisionId;
    UCHAR PciClass;
    UCHAR PciSubClass;
    UCHAR PciProgIf;

    PIRP HcPendingWakeIrp;

    ULONG AddressList[4];

    PUSBD_DEVICE_HANDLE RawDeviceHandle;

    HC_POWER_STATE_TABLE HcPowerStateTbl;
    SYSTEM_POWER_STATE LastSystemSleepState;

    KSEMAPHORE DeviceLock;
    KSEMAPHORE CcLock;


    UNICODE_STRING LegacyLinkUnicodeString;

    HC_RESOURCES HcResources;

    // protects core functions called thru
    // registration packet in MiniportDriver
    USBPORT_SPIN_LOCK CoreFunctionSpin;
    USBPORT_SPIN_LOCK MapTransferSpin;
    USBPORT_SPIN_LOCK DoneTransferSpin;
    USBPORT_SPIN_LOCK EndpointListSpin;
    USBPORT_SPIN_LOCK EpStateChangeListSpin;
    USBPORT_SPIN_LOCK DevHandleListSpin;
    USBPORT_SPIN_LOCK EpClosedListSpin;
    USBPORT_SPIN_LOCK TtEndpointListSpin;

    USBPORT_SPIN_LOCK PendingTransferIrpSpin;
    USBPORT_SPIN_LOCK ActiveTransferIrpSpin;
    USBPORT_SPIN_LOCK WorkerThreadSpin;
    USBPORT_SPIN_LOCK PowerSpin;
    USBPORT_SPIN_LOCK DM_TimerSpin;
    USBPORT_SPIN_LOCK PendingIrpSpin;
    USBPORT_SPIN_LOCK WakeIrpSpin;
    USBPORT_SPIN_LOCK HcPendingWakeIrpSpin;
    USBPORT_SPIN_LOCK IdleIrpSpin;
    USBPORT_SPIN_LOCK BadRequestSpin;
    USBPORT_SPIN_LOCK IsrDpcSpin;
    USBPORT_SPIN_LOCK StatCounterSpin;
    USBPORT_SPIN_LOCK HcSyncSpin;

    LONG CoreSpinCheck;

    KEVENT WorkerThreadEvent;
    HANDLE WorkerThreadHandle;
    PKTHREAD WorkerPkThread;

    KEVENT HcPendingWakeIrpEvent;
    KEVENT HcPendingWakeIrpPostedEvent;

    PDMA_ADAPTER AdapterObject;
    ULONG NumberOfMapRegisters;
    LONG NextTransferSequenceNumber;

    PKINTERRUPT InterruptObject;
    KDPC IsrDpc;
    KDPC TransferFlushDpc;
    KDPC SurpriseRemoveDpc;
    KDPC HcResetDpc;
    KDPC HcWakeDpc;

    KDPC DM_TimerDpc;
    KTIMER DM_Timer;
    LONG DM_TimerInterval;

    // global common buffer allocated and
    // passed to miniport on start.
    PUSBPORT_COMMON_BUFFER ControllerCommonBuffer;

    // no longer used
    USBPORT_SPIN_LOCK LogSpinLock;

    LIST_ENTRY DeviceHandleList;
    LIST_ENTRY MapTransferList;
    LIST_ENTRY DoneTransferList;
    LIST_ENTRY EpStateChangeList;
    LIST_ENTRY EpClosedList;
    LIST_ENTRY BadRequestList;
    LIST_ENTRY RegistryCache;

    LIST_ENTRY GlobalEndpointList;
    LIST_ENTRY AttendEndpointList;

    // stat counters
    ULONG StatBulkDataBytes;
    ULONG StatIsoDataBytes;
    ULONG StatInterruptDataBytes;
    ULONG StatControlDataBytes;
    ULONG StatPciInterruptCount;
    ULONG StatHardResetCount;
    ULONG StatWorkSignalCount;
    ULONG StatWorkIdleTime;
    ULONG StatCommonBufferBytes;


    ULONG BadRequestFlush;
    ULONG BadReqFlushThrottle;

    // context for USB2 budgeter engine
    PVOID Usb2LibHcContext;
    ULONG BiosX;

    USBHC_WAKE_STATE HcWakeState;

    ULONG Usb2BusFunction;
    ULONG BusNumber; // slot
    ULONG BusDevice;
    ULONG BusFunction;

    // usbed to synchronize CCs and USB 2 controllers
    LONG DependentControllers;
    LONG PendingRhCallback;

    LIST_ENTRY ControllerLink;

#ifdef XPSE
    // additional stat tracking
    LARGE_INTEGER D0ResumeTimeStart;
    LARGE_INTEGER S0ResumeTimeStart;
    LARGE_INTEGER ThreadResumeTimeStart;
    ULONG ThreadResumeTime;
    ULONG ControllerResumeTime;
    ULONG D0ResumeTime;
    ULONG S0ResumeTime;
#endif

    ULONG InterruptOrdinalTable[65];

    PVOID MiniportExtension[0]; // PVOID for IA64 alignment

} FDO_EXTENSION, *PFDO_EXTENSION;

// this is where we keep
// all the root hub data

typedef struct _PDO_EXTENSION {

    USBD_DEVICE_HANDLE RootHubDeviceHandle;
    PHCD_ENDPOINT RootHubInterruptEndpoint;

    ULONG PdoFlags;

    UCHAR ConfigurationValue;
    UCHAR Pad3[3];

    // pointers to our root hub descriptors
    // NOTE: these ptrs point in to the 'Descriptors'
    // buffer so son't try to free them
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;
    PUSB_HUB_DESCRIPTOR HubDescriptor;

    // irp associated with remote wakeup,
    // ie irp posted by the HUB driver
    PIRP PendingWaitWakeIrp;
    PIRP PendingIdleNotificationIrp;

    // pointer to buffer contining descriptors
    PUCHAR Descriptors;

    PRH_INIT_CALLBACK HubInitCallback;
    PVOID HubInitContext;

} PDO_EXTENSION, *PPDO_EXTENSION;

// signatures for our device extensions
#define USBPORT_DEVICE_EXT_SIG  'ODFH'  //HFDO
#define ROOTHUB_DEVICE_EXT_SIG  'ODPR'  //RPDO

/* USB spec defined port flags */
#define PORT_STATUS_CONNECT         0x001
#define PORT_STATUS_ENABLE          0x002
#define PORT_STATUS_SUSPEND         0x004
#define PORT_STATUS_OVER_CURRENT    0x008
#define PORT_STATUS_RESET           0x010
#define PORT_STATUS_POWER           0x100
#define PORT_STATUS_LOW_SPEED       0x200
#define PORT_STATUS_HIGH_SPEED      0x400

/*
    root hub status codes
*/
typedef enum _RHSTATUS {

     RH_SUCCESS = 0,
     RH_NAK,
     RH_STALL

} RHSTATUS;

/* port operations */

typedef enum _PORT_OPERATION {

  SetFeaturePortReset = 0,
  SetFeaturePortPower,
  SetFeaturePortEnable,
  SetFeaturePortSuspend,
  ClearFeaturePortEnable,
  ClearFeaturePortPower,
  ClearFeaturePortSuspend,
  ClearFeaturePortEnableChange,
  ClearFeaturePortConnectChange,
  ClearFeaturePortResetChange,
  ClearFeaturePortSuspendChange,
  ClearFeaturePortOvercurrentChange

} PORT_OPERATION;

#define NUMBER_OF_PORTS(de) ((de)->Pdo.HubDescriptor->bNumberOfPorts)
#define HUB_DESRIPTOR_LENGTH(de) ((de)->Pdo.HubDescriptor->bDescriptorLength)


typedef struct _DEVICE_EXTENSION {
    // Necessary to support Legacy USB hub driver(s)
    // AKA 'backport'
    PUCHAR DummyUsbdExtension;
    // The following fields are common to both the
    // root hub PDO and the HC FDO

    // signature
    ULONG Sig;

    // for the FDO this points to ourselves
    // for PDO this points to FDO
    PDEVICE_OBJECT HcFdoDeviceObject;

    // put the log ptrs at the beginning
    // to make them easy to find
    DEBUG_LOG Log;
    DEBUG_LOG TransferLog;
    DEBUG_LOG EnumLog;

    // these ptrs are in the global extension to
    // make them easier to find on win9x
    PUSBPORT_IRP_TABLE PendingTransferIrpTable;
    PUSBPORT_IRP_TABLE ActiveTransferIrpTable;

    ULONG Flags;
    ULONG PnpStateFlags;

    // current power state of this DO
    // this is the state the OS has placed us in
    DEVICE_POWER_STATE CurrentDevicePowerState;
    PIRP SystemPowerIrp;

    // device caps for this DO
    DEVICE_CAPABILITIES DeviceCapabilities;

    //
    // count of requests currently 'in' our driver
    // this is tracked per DevObj.
    // We also keep a list of irps in the debug driver.
    //
    LONG PendingRequestCount;
    LIST_ENTRY TrackIrpList;

    USBPORT_SPIN_LOCK PendingRequestSpin;
    KEVENT PendingRequestEvent;

    UNICODE_STRING SymbolicLinkName;

    union {
        PDO_EXTENSION Pdo;
        FDO_EXTENSION Fdo;
    };

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

/*
    used to track cached registry keys for miniports
*/

typedef struct _USBPORT_REG_CACHE_ENTRY {
    ULONG Sig;
    LIST_ENTRY RegLink;
    BOOLEAN SoftwareBranch;
    // length in bytes
    ULONG DataLength;
    PUCHAR Data;
    ULONG KeyNameStringLength;
    WCHAR KeyNameString[0];
} USBPORT_REG_CACHE_ENTRY, *PUSBPORT_REG_CACHE_ENTRY;



// define an interlocked version of RemoveEntryList
#define USBPORT_InterlockedRemoveEntryList(ListEntry, Spinlock) \
    {\
        KIRQL irql;\
        KeAcquireSpinLock((Spinlock), &irql);\
        RemoveEntryList((ListEntry));\
        KeReleaseSpinLock((Spinlock), irql);\
    }

#define GET_HEAD_LIST(head, le) \
    if (IsListEmpty(&(head))) {\
        le = NULL;\
    } else {\
        le = (head).Flink;\
    }


#define FREE_POOL(fdo, p)  ExFreePool((p))

//
// allocates a zeroed buffer that the OS is expedected to free
//
#define ALLOC_POOL_OSOWNED(p, PoolType, NumberOfBytes) \
    do { \
    (p) = ExAllocatePoolWithTag((PoolType), (NumberOfBytes), USBPORT_TAG); \
    if ((p)) { \
        RtlZeroMemory((p), (NumberOfBytes)); \
    } \
    } while (0) \

//
// allocates a zeroed buffer that we are expected to free
//
#define ALLOC_POOL_Z(p, PoolType, NumberOfBytes) \
    do { \
    (p) = ExAllocatePoolWithTag((PoolType), (NumberOfBytes), USBPORT_TAG); \
    if ((p)) { \
        RtlZeroMemory((p), (NumberOfBytes)); \
    } \
    } while (0) \

#define GET_DEVICE_EXT(e, d) (e) = (d)->DeviceExtension
#define GET_DEVICE_HANDLE(dh, urb) (dh) = ((PURB)(urb))->UrbHeader.UsbdDeviceHandle;

#define DEVEXT_FROM_DEVDATA(de, dd) \
    (de) = (PDEVICE_EXTENSION) \
            CONTAINING_RECORD((dd),\
                              struct _DEVICE_EXTENSION, \
                              Fdo.MiniportExtension)

#define ENDPOINT_FROM_EPDATA(ep, epd) \
    (ep) = (PHCD_ENDPOINT) \
            CONTAINING_RECORD((epd),\
                              struct _HCD_ENDPOINT, \
                              MiniportEndpointData)

#define TRANSFER_FROM_TPARAMETERS(t, tp) \
    (t) = (PHCD_TRANSFER_CONTEXT) \
            CONTAINING_RECORD((tp),\
                              struct _HCD_TRANSFER_CONTEXT, \
                              Tp)

#define SET_USBD_ERROR(u, s) USBPORT_SetUSBDError((PURB)(u),(s))

#define INCREMENT_PENDING_REQUEST_COUNT(devobj, irp) \
    USBPORT_TrackPendingRequest((devobj), (irp), TRUE)

#define DECREMENT_PENDING_REQUEST_COUNT(devobj, irp) \
    USBPORT_TrackPendingRequest((devobj), (irp), FALSE)

//328555
#define REF_DEVICE(urb) \
    do {\
    PUSBD_DEVICE_HANDLE dh;\
    GET_DEVICE_HANDLE(dh, (urb));\
    ASSERT_DEVICE_HANDLE(dh);\
    InterlockedIncrement(&dh->PendingUrbs);\
    } while (0)

#define DEREF_DEVICE(urb) \
    do {\
    PUSBD_DEVICE_HANDLE dh;\
    GET_DEVICE_HANDLE(dh, (urb));\
    ASSERT_DEVICE_HANDLE(dh);\
    InterlockedDecrement(&dh->PendingUrbs);\
    } while (0)
//328555

#define INITIALIZE_PENDING_REQUEST_COUNTER(de)  \
     KeInitializeSpinLock(&(de)->PendingRequestSpin.sl);\
     (de)->PendingRequestCount = -1; \
     InitializeListHead(&(de)->TrackIrpList);

//328555
#define REF_DEVICE(urb) \
    do {\
    PUSBD_DEVICE_HANDLE dh;\
    GET_DEVICE_HANDLE(dh, (urb));\
    ASSERT_DEVICE_HANDLE(dh);\
    InterlockedIncrement(&dh->PendingUrbs);\
    } while (0)

#define DEREF_DEVICE(urb) \
    do {\
    PUSBD_DEVICE_HANDLE dh;\
    GET_DEVICE_HANDLE(dh, (urb));\
    ASSERT_DEVICE_HANDLE(dh);\
    InterlockedDecrement(&dh->PendingUrbs);\
    } while (0)
//328555

#define ACQUIRE_TRANSFER_LOCK(fdo, t, i) \
     do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_MISC, 'tfL+', 0, (fdo), 0);\
    KeAcquireSpinLock(&(t)->Spin, &(i));\
    } while (0)

#define RELEASE_TRANSFER_LOCK(fdo, t, i) \
    do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_MISC, 'tfL-', 0, (fdo), (i));\
    KeReleaseSpinLock(&t->Spin, (i));\
    } while (0)


#define ACQUIRE_IDLEIRP_LOCK(fdo, i) \
    do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_MISC, 'idL+', 0, (fdo), 0);\
    KeAcquireSpinLock(&ext->Fdo.IdleIrpSpin.sl, &(i));\
    } while (0)

#define RELEASE_IDLEIRP_LOCK(fdo, i) \
    do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_MISC, 'idL-', 0, (fdo), (i));\
    KeReleaseSpinLock(&ext->Fdo.IdleIrpSpin.sl, (i));\
    } while (0)


#define ACQUIRE_BADREQUEST_LOCK(fdo, i) \
    do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_MISC, 'brL+', 0, (fdo), 0);\
    KeAcquireSpinLock(&ext->Fdo.BadRequestSpin.sl, &(i));\
    } while (0)

#define RELEASE_BADREQUEST_LOCK(fdo, i) \
    do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_MISC, 'brL-', 0, (fdo), (i));\
    KeReleaseSpinLock(&ext->Fdo.BadRequestSpin.sl, (i));\
    } while (0)


#define ACQUIRE_WAKEIRP_LOCK(fdo, i) \
    do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_POWER, 'wwL+', 0, (fdo), 0);\
    KeAcquireSpinLock(&ext->Fdo.WakeIrpSpin.sl, &(i));\
    } while (0)

#define RELEASE_WAKEIRP_LOCK(fdo, i) \
    do {\
    PDEVICE_EXTENSION ext;\
    GET_DEVICE_EXT(ext, (fdo));\
    ASSERT_FDOEXT(ext);\
    LOGENTRY(NULL, fdo, LOG_POWER, 'wwL-', 0, (fdo), (i));\
    KeReleaseSpinLock(&ext->Fdo.WakeIrpSpin.sl, (i));\
    } while (0)

#define ACQUIRE_ENDPOINT_LOCK(ep, fdo, s) \
    do {\
    LOGENTRY(NULL, fdo, LOG_SPIN, s, (ep), 0, 0);\
    USBPORT_AcquireSpinLock((fdo), &(ep)->ListSpin, &(ep)->LockIrql);\
    LOGENTRY(NULL, fdo, LOG_SPIN, s, (ep), (ep)->LockFlag, 1);\
    USBPORT_ASSERT((ep)->LockFlag == 0); \
    (ep)->LockFlag++;\
    } while (0)

#define RELEASE_ENDPOINT_LOCK(ep, fdo, s) \
    do {\
    LOGENTRY(NULL, fdo, LOG_SPIN, s, (ep), (ep)->LockFlag, 0);\
    USBPORT_ASSERT((ep)->LockFlag == 1); \
    (ep)->LockFlag--;\
    USBPORT_ReleaseSpinLock(fdo, &(ep)->ListSpin, (ep)->LockIrql);\
    } while (0)

#define ACQUIRE_STATECHG_LOCK(fdo, ep) \
    USBPORT_AcquireSpinLock((fdo), &(ep)->StateChangeSpin, &(ep)->ScLockIrql);

#define RELEASE_STATECHG_LOCK(fdo, ep) \
    USBPORT_ReleaseSpinLock((fdo), &(ep)->StateChangeSpin, (ep)->ScLockIrql);

#define ACQUIRE_ROOTHUB_LOCK(fdo, i) \
    {\
    PDEVICE_EXTENSION de;\
    de = (fdo)->DeviceExtension;\
    LOGENTRY(NULL, (fdo), LOG_MISC, 'Lhub', 0, 0, 0);\
    KeAcquireSpinLock(&de->Fdo.RootHubSpin.sl, &(i));\
    }

#define RELEASE_ROOTHUB_LOCK(fdo, i) \
    {\
    PDEVICE_EXTENSION de;\
    de = (fdo)->DeviceExtension;\
    LOGENTRY(NULL, (fdo), LOG_MISC, 'Uhub', 0, 0, 0);\
    KeReleaseSpinLock(&de->Fdo.RootHubSpin.sl, (i));\
    }

#define ACQUIRE_ACTIVE_IRP_LOCK(fdo, de, i) \
    {\
    USBPORT_AcquireSpinLock((fdo), &(de)->Fdo.ActiveTransferIrpSpin, &(i));\
    }

#define RELEASE_ACTIVE_IRP_LOCK(fdo, de, i) \
    {\
    USBPORT_ReleaseSpinLock((fdo), &(de)->Fdo.ActiveTransferIrpSpin, (i));\
    }

#define USBPORT_IS_USB20(de)\
    (REGISTRATION_PACKET((de)).OptionFlags & USB_MINIPORT_OPT_USB20)


#define ACQUIRE_PENDING_IRP_LOCK(de, i) \
    KeAcquireSpinLock(&(de)->Fdo.PendingIrpSpin.sl, &(i))

#define RELEASE_PENDING_IRP_LOCK(de, i) \
    KeReleaseSpinLock(&(de)->Fdo.PendingIrpSpin.sl, (i))

#define USBPORT_ACQUIRE_DM_LOCK(de, i) \
    KeAcquireSpinLock(&(de)->Fdo.DM_TimerSpin.sl, &(i))

#define USBPORT_RELEASE_DM_LOCK(de, i) \
    KeReleaseSpinLock(&(de)->Fdo.DM_TimerSpin.sl, (i))

//#define USBPORT_ACQUIRE_DM_LOCK(de, i) \
//    KeAcquireSpinLock(&(de)->Fdo.DM_TimerSpin.sl, &(i));
//
//#define USBPORT_RELEASE_DM_LOCK(de, i) \
//    KeReleaseSpinLock(&(de)->Fdo.DM_TimerSpin.sl, (i));


#define IS_ON_ATTEND_LIST(ep) \
    (BOOLEAN) ((ep)->AttendLink.Flink != NULL \
    && (ep)->AttendLink.Blink != NULL)


//
// Macros to set transfer direction flag
//

#define USBPORT_SET_TRANSFER_DIRECTION_IN(tf)  ((tf) |= USBD_TRANSFER_DIRECTION_IN)

#define USBPORT_SET_TRANSFER_DIRECTION_OUT(tf) ((tf) &= ~USBD_TRANSFER_DIRECTION_IN)


//
// Flags for the URB header flags field used by port
//

#define USBPORT_REQUEST_IS_TRANSFER        0x00000001
#define USBPORT_REQUEST_MDL_ALLOCATED      0x00000002
#define USBPORT_REQUEST_USES_DEFAULT_PIPE  0x00000004
#define USBPORT_REQUEST_NO_DATA_PHASE      0x00000008
#define USBPORT_RESET_DATA_TOGGLE          0x00000010
#define USBPORT_TRANSFER_ALLOCATED         0x00000020

// defined in USB100.h
#if 0
//
// Values for the bmRequest field
//

//bmRequest.Dir
#define BMREQUEST_HOST_TO_DEVICE        0
#define BMREQUEST_DEVICE_TO_HOST        1

//bmRequest.Type
#define BMREQUEST_STANDARD              0
#define BMREQUEST_CLASS                 1
#define BMREQUEST_VENDOR                2

//bmRequest.Recipient
#define BMREQUEST_TO_DEVICE             0
#define BMREQUEST_TO_INTERFACE          1
#define BMREQUEST_TO_ENDPOINT           2
#define BMREQUEST_TO_OTHER              3


typedef union _BM_REQUEST_TYPE {
    struct _BM {
        UCHAR   Recipient:2;
        UCHAR   Reserved:3;
        UCHAR   Type:2;
        UCHAR   Dir:1;
    };
    UCHAR B;
} BM_REQUEST_TYPE, *PBM_REQUEST_TYPE;

typedef struct _USB_DEFAULT_PIPE_SETUP_PACKET {

    BM_REQUEST_TYPE bmRequestType;
    UCHAR bRequest;

    union _wValue {
        struct {
            UCHAR lowPart;
            UCHAR hiPart;
        };
        USHORT W;
    } wValue;
    USHORT wIndex;
    USHORT wLength;
} USB_DEFAULT_PIPE_SETUP_PACKET, *PUSB_DEFAULT_PIPE_SETUP_PACKET;


// setup packet is eight bytes -- defined by spec
C_ASSERT(sizeof(USB_DEFAULT_PIPE_SETUP_PACKET) == 8);
#endif

#define USBPORT_INIT_SETUP_PACKET(s, brequest, \
    direction, recipient, typ, wvalue, windex, wlength) \
    {\
    (s).bRequest = (brequest);\
    (s).bmRequestType.Dir = (direction);\
    (s).bmRequestType.Type = (typ);\
    (s).bmRequestType.Recipient = (recipient);\
    (s).bmRequestType.Reserved = 0;\
    (s).wValue.W = (wvalue);\
    (s).wIndex.W = (windex);\
    (s).wLength = (wlength);\
    }


// ************************************************
// miniport callout Macros to CORE FUNCTIONS
// ************************************************

#define REGISTRATION_PACKET(de) \
    ((de)->Fdo.MiniportDriver->RegistrationPacket)

//xxxjd
//#define MP_GetEndpointState(de, ep, state) \
//    {\
//    KIRQL irql;\
//    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
//        RegistrationPacket.MINIPORT_GetEndpointState != NULL); \
//    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
//    (state) = \
//        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_GetEndpointState(\
//                                                (de)->Fdo.MiniportDeviceData,\
//                                                &(ep)->MiniportEndpointData[0]);\
//    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
//    }

#define MP_GetEndpointStatus(de, ep, status) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_GetEndpointStatus != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (status) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_GetEndpointStatus(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->MiniportEndpointData[0]);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_SetEndpointState(de, ep, state) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_SetEndpointState != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_SetEndpointState(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->MiniportEndpointData[0],\
                                                (state));\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_SetEndpointStatus(de, ep, status) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_SetEndpointState != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_SetEndpointStatus(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->MiniportEndpointData[0],\
                                                (status));\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_SetEndpointDataToggle(de, ep, t) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_SetEndpointDataToggle != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_SetEndpointDataToggle(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->MiniportEndpointData[0],\
                                                (t));\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }


#define MP_PollEndpoint(de, ep) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_PollEndpoint != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_PollEndpoint(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->MiniportEndpointData[0]);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_OpenEndpoint(de, ep, mpStatus) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_OpenEndpoint != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (mpStatus) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_OpenEndpoint(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->Parameters,\
                                                &(ep)->MiniportEndpointData[0]);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_RebalanceEndpoint(de, ep) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_RebalanceEndpoint != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
   (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_RebalanceEndpoint(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->Parameters,\
                                                &(ep)->MiniportEndpointData[0]);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_CloseEndpoint(de, ep) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_OpenEndpoint != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_CloseEndpoint(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->MiniportEndpointData[0]);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_PokeEndpoint(de, ep, mpStatus) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_PokeEndpoint != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (mpStatus) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_PokeEndpoint(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->Parameters,\
                                                &(ep)->MiniportEndpointData[0]);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_InterruptNextSOF(de) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_InterruptNextSOF != NULL); \
    LOGENTRY(NULL, (de)->HcFdoDeviceObject, LOG_MISC, 'rSOF', 0, 0, 0);\
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_InterruptNextSOF(\
                                                (de)->Fdo.MiniportDeviceData);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_Get32BitFrameNumber(de, f) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_Get32BitFrameNumber != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (f) = (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_Get32BitFrameNumber(\
                                                       (de)->Fdo.MiniportDeviceData);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

MINIPORT_SubmitTransfer(
    PDEVICE_DATA DeviceData,
    PENDPOINT_DATA EndpointData,
    PTRANSFER_PARAMETERS TransferParameters,
    PTRANSFER_CONTEXT TransferContext,
    PTRANSFER_SG_LIST TransferSGList
    );

#define MP_SubmitTransfer(de, ep, t, mpStatus) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_SubmitTransfer != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (mpStatus) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_SubmitTransfer(\
                               (de)->Fdo.MiniportDeviceData,\
                               &(ep)->MiniportEndpointData[0],\
                               &(t)->Tp,\
                               (t)->MiniportContext,\
                               &(t)->SgList);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_SubmitIsoTransfer(de, ep, t, mpStatus) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_SubmitIsoTransfer != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (mpStatus) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_SubmitIsoTransfer(\
                               (de)->Fdo.MiniportDeviceData,\
                               &(ep)->MiniportEndpointData[0],\
                               &(t)->Tp,\
                               (t)->MiniportContext,\
                               (t)->IsoTransfer);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_AbortTransfer(de, ep, t, b) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_AbortTransfer != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_AbortTransfer(\
                               (de)->Fdo.MiniportDeviceData,\
                               &(ep)->MiniportEndpointData[0],\
                               (t)->MiniportContext,\
                               &(b));\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }


#define MP_QueryEndpointRequirements(de, ep, r) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_QueryEndpointRequirements != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_QueryEndpointRequirements(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                &(ep)->Parameters,\
                                                (r));\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }


#define MP_InterruptDpc(de, e) {\
        USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_InterruptDpc != NULL); \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_InterruptDpc(\
                                                (de)->Fdo.MiniportDeviceData, \
                                                (e));\
        }

#define MP_StartSendOnePacket(de, p, mpd, mpl, vaddr, phys, len, u, mpStatus) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_StartSendOnePacket != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    mpStatus = (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_StartSendOnePacket(\
                               (de)->Fdo.MiniportDeviceData,\
                               (p),\
                               (mpd),\
                               (mpl),\
                               (vaddr),\
                               (phys),\
                               (len),\
                               (u));\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }


#define MP_EndSendOnePacket(de,p, mpd, mpl, vaddr, phys, len, u, mpStatus) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_EndSendOnePacket != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    mpStatus = (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_EndSendOnePacket(\
                               (de)->Fdo.MiniportDeviceData,\
                               (p),\
                               (mpd),\
                               (mpl),\
                               (vaddr),\
                               (phys),\
                               (len),\
                               (u));\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_PollController(de) \
    {\
    KIRQL irql;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_PollController != NULL); \
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_PollController(\
                               (de)->Fdo.MiniportDeviceData);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    }

#define MP_CheckController(de) \
    do {\
    KIRQL irql;\
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    if (!TEST_FDO_FLAG((de), USBPORT_FDOFLAG_CONTROLLER_GONE) && \
        !TEST_FDO_FLAG((de), USBPORT_FDOFLAG_SUSPENDED) && \
        !TEST_FDO_FLAG((de), USBPORT_FDOFLAG_OFF)) {\
    LOGENTRY(NULL, (de)->HcFdoDeviceObject, LOG_MISC, 'chkC', \
        (de)->HcFdoDeviceObject, (de)->Fdo.FdoFlags, 0);\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_CheckController != NULL); \
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_CheckController(\
                               (de)->Fdo.MiniportDeviceData);\
    }\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    } while (0)


#define MP_ResetController(de) \
    do {\
    KIRQL irql;\
    USBPORT_AcquireSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, &irql);\
    LOGENTRY(NULL, (de)->HcFdoDeviceObject, LOG_MISC, 'rset', \
        (de)->HcFdoDeviceObject, (de)->Fdo.FdoFlags, 0);\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
        RegistrationPacket.MINIPORT_ResetController != NULL); \
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_ResetController(\
                               (de)->Fdo.MiniportDeviceData);\
    USBPORT_ReleaseSpinLock((de)->HcFdoDeviceObject, &(de)->Fdo.CoreFunctionSpin, irql);\
    } while (0)



// *************************************************
// miniport callout Macros to NON CORE FUNCTIONS
// *************************************************

#define MP_StopController(de, hw) \
    {\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_StopController != NULL);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_StopController(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                (hw));\
    }

#define MP_StartController(de, r, mpStatus) \
    {\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_StartController != NULL);\
    (mpStatus) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_StartController(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                (r));\
    }

#define MP_SuspendController(de) \
    {\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_SuspendController != NULL);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_SuspendController(\
                                                (de)->Fdo.MiniportDeviceData);\
    }

#define MP_ResumeController(de, s) \
    {\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_ResumeController != NULL);\
    (s) = (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_ResumeController(\
                                                (de)->Fdo.MiniportDeviceData);\
    }

#define MP_DisableInterrupts(fdo, de) \
    do {\
    KIRQL iql;\
    BOOLEAN sync = TRUE;\
    if (REGISTRATION_PACKET(de).OptionFlags & USB_MINIPORT_OPT_NO_IRQ_SYNC) {\
        sync = FALSE;}\
    if (sync) {KeAcquireSpinLock(&(de)->Fdo.IsrDpcSpin.sl, &iql);}\
    LOGENTRY(NULL, (fdo), LOG_MISC, 'irqD', (fdo), 0, 0);\
    REGISTRATION_PACKET((de)).MINIPORT_DisableInterrupts(\
                                      (de)->Fdo.MiniportDeviceData);\
    CLEAR_FDO_FLAG((de), USBPORT_FDOFLAG_IRQ_EN);\
    if (sync) {KeReleaseSpinLock(&(de)->Fdo.IsrDpcSpin.sl, iql);}\
    } while (0)


#define MP_EnableInterrupts(de) \
    do {\
    KIRQL iql;\
    BOOLEAN sync = TRUE;\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_EnableInterrupts != NULL);\
    if ((REGISTRATION_PACKET(de).OptionFlags & USB_MINIPORT_OPT_NO_IRQ_SYNC)) {\
        sync = FALSE;}\
    if (sync) {KeAcquireSpinLock(&(de)->Fdo.IsrDpcSpin.sl, &iql);}\
    SET_FDO_FLAG((de), USBPORT_FDOFLAG_IRQ_EN);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_EnableInterrupts(\
                                                (de)->Fdo.MiniportDeviceData);\
    if (sync) {KeReleaseSpinLock(&(de)->Fdo.IsrDpcSpin.sl, iql);}\
    } while (0)


#define MP_FlushInterrupts(de) \
    do {\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_FlushInterrupts != NULL);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_FlushInterrupts(\
                                                (de)->Fdo.MiniportDeviceData);\
    } while (0)

// note that take port control and chirp_ports are version 2 specific
// and we need them for power managemnt to work properly
#define MP_TakePortControl(de) \
    do {\
    if ((de)->Fdo.MiniportDriver->HciVersion >= USB_MINIPORT_HCI_VERSION_2) {\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_TakePortControl != NULL);\
    (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_TakePortControl(\
                                                (de)->Fdo.MiniportDeviceData);\
    };\
    } while (0)

#define MP_InterruptService(de, usbint) {\
    USBPORT_ASSERT((de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_InterruptService != NULL);\
    (usbint) = (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_InterruptService(\
                                                (de)->Fdo.MiniportDeviceData);\
    }

#define MPRH_GetStatus(de, s, mpStatus) \
    (mpStatus) = (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_RH_GetStatus(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                (s))

#define MPRH_GetPortStatus(de, port, status, mpStatus) \
    (mpStatus) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_RH_GetPortStatus(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                (port),\
                                                (status))

#define MPRH_GetHubStatus(de, status, mpStatus) \
    (mpStatus) = \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_RH_GetHubStatus(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                (status))

#define MPRH_GetRootHubData(de, data) \
        (de)->Fdo.MiniportDriver->\
            RegistrationPacket.MINIPORT_RH_GetRootHubData(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                (data))

#define MPRH_DisableIrq(de) \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_RH_DisableIrq(\
                                                (de)->Fdo.MiniportDeviceData)

#define MPRH_EnableIrq(de) \
        (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_RH_EnableIrq(\
                                                (de)->Fdo.MiniportDeviceData)

#define MP_PassThru(de, guid, l, data, mpStatus) \
                                                 \
        if ((de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_PassThru) { \
            (mpStatus) = (de)->Fdo.MiniportDriver->RegistrationPacket.MINIPORT_PassThru(\
                                                (de)->Fdo.MiniportDeviceData,\
                                                (guid),\
                                                (l),\
                                                (data)); \
        } \
        else { \
            (mpStatus) = USBMP_STATUS_NOT_SUPPORTED; \
        }

#define MILLISECONDS_TO_100_NS_UNITS(ms) (((LONG)(ms)) * 10000)


#define USBPORT_GET_BIT_SET(d, bit) \
    do {   \
        UCHAR tmp = (d);\
        (bit)=0; \
        while (!(tmp & 0x01)) {\
            (bit)++;\
            tmp >>= 1;\
        };\
    } while (0)


#endif /*  __USBPORT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\hcd\usbport\urb.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    urb.c

Abstract:

    main urb "handler"

Environment:

    kernel mode only

Notes:

Revision History:

    6-20-99 : created

--*/

#include "common.h"

// paged functions
#ifdef ALLOC_PRAGMA
#endif

// non paged functions
//USBPORT_ProcessURB
//USBPORT_SelectConfiguration;
//USBPORT_SelectInterface;
//USBPORT_AsyncTransfer;
//USBPORT_IsochTransfer;
//USBPORT_AbortPipe;
//USBPORT_ResetPipe;
//USBPORT_SCT_GetSetDescriptor;
//USBPORT_SCT_SetClearFeature;
//USBPORT_SCT_GetStatus;
//USBPORT_SCT_VendorClassCommand;
//USBPORT_SCT_GetInterface;
//USBPORT_SCT_GetConfiguration;
//USBPORT_TakeFrameLengthControl;
//USBPORT_ReleaseFrameLengthControl;
//USBPORT_GetFrameLength;
//USBPORT_SetFrameLength;
//USBPORT_BulkTransfer;
//USBPORT_GetCurrentFrame;
//USBPORT_InvalidFunction
//USBPORT_GetMSFeartureDescriptor
//USBPORT_SyncClearStall
//USBPORT_GetMSFeartureDescriptor

/*
** URB handler routines

Handler -- 
    This function handles the specific USBDI request, if the request is queued 
    by the handler the STATUS_PENDING is returned
*/



typedef NTSTATUS URB_HANDLER(PDEVICE_OBJECT FdoDeviceObject, PIRP Irp, PURB Urb);

typedef struct _URB_DISPATCH_ENTRY {
    // USB API handler
    URB_HANDLER    *UrbHandler;    
    // length of the URB expected for this request
    USHORT         UrbRequestLength;   
    USHORT         Pad2;
    // request code for setup packet if standard command        
    UCHAR          Direction; 
    UCHAR          Type;
    UCHAR          Recipient;
    UCHAR          bRequest;         
    
    // tell the generic urb dispatch routine what to do    
    ULONG          Flags;
#if DBG    
    ULONG ExpectedFunctionCode;
#endif    
} URB_DISPATCH_ENTRY;

URB_HANDLER USBPORT_SelectConfiguration;
URB_HANDLER USBPORT_SelectInterface;
URB_HANDLER USBPORT_AsyncTransfer;
URB_HANDLER USBPORT_IsochTransfer;
URB_HANDLER USBPORT_AbortPipe;
URB_HANDLER USBPORT_SyncResetPipeAndClearStall;
URB_HANDLER USBPORT_SyncResetPipe;
URB_HANDLER USBPORT_SyncClearStall;
URB_HANDLER USBPORT_SCT_GetSetDescriptor;
URB_HANDLER USBPORT_SCT_SetClearFeature;
URB_HANDLER USBPORT_SCT_GetStatus;
URB_HANDLER USBPORT_SCT_VendorClassCommand;
URB_HANDLER USBPORT_SCT_GetInterface;
URB_HANDLER USBPORT_SCT_GetConfiguration;
URB_HANDLER USBPORT_TakeFrameLengthControl;
URB_HANDLER USBPORT_ReleaseFrameLengthControl;
URB_HANDLER USBPORT_GetFrameLength;
URB_HANDLER USBPORT_SetFrameLength;
URB_HANDLER USBPORT_BulkTransfer;
URB_HANDLER USBPORT_GetCurrentFrame;
URB_HANDLER USBPORT_InvalidFunction;
URB_HANDLER USBPORT_GetMSFeartureDescriptor;

// last supported function
#define URB_FUNCTION_LAST   URB_FUNCTION_SYNC_CLEAR_STALL

// last valid function
URB_DISPATCH_ENTRY UrbDispatchTable[URB_FUNCTION_LAST+1] =
{
    //URB_FUNCTION_SELECT_CONFIGURATION                    
    USBPORT_SelectConfiguration, 
    0,  // Length, handler will validate length 
    0,  // Pad2
    0,  // bmRequestType.Dir 
    0,  // bmRequestType.Type
    0,  // bmRequestType.Recipient
    0,  // bRequest
    0,  // Flags
#if DBG
    URB_FUNCTION_SELECT_CONFIGURATION,
#endif    
    //URB_FUNCTION_SELECT_INTERFACE                        
    USBPORT_SelectInterface, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags 
#if DBG
    URB_FUNCTION_SELECT_INTERFACE,
#endif        
    //URB_FUNCTION_ABORT_PIPE                     
    USBPORT_AbortPipe, // Function
    sizeof(struct _URB_PIPE_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags 
#if DBG
    URB_FUNCTION_ABORT_PIPE,
#endif        
    //URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL            
    USBPORT_TakeFrameLengthControl,  // Function
    sizeof(struct _URB_FRAME_LENGTH_CONTROL), // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags 
#if DBG
    URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL,
#endif        
    //URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL        
    USBPORT_ReleaseFrameLengthControl, // Function 
    sizeof(struct _URB_FRAME_LENGTH_CONTROL), // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags 
#if DBG
    URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL,
#endif        
    //URB_FUNCTION_GET_FRAME_LENGTH                    
    USBPORT_GetFrameLength, // Function
    sizeof(struct _URB_GET_FRAME_LENGTH), // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags 
#if DBG
    URB_FUNCTION_GET_FRAME_LENGTH,
#endif        
    //URB_FUNCTION_SET_FRAME_LENGTH                    
    USBPORT_SetFrameLength, // Function
    sizeof(struct _URB_SET_FRAME_LENGTH), // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags 
#if DBG
    URB_FUNCTION_SET_FRAME_LENGTH,
#endif        
    //URB_FUNCTION_GET_CURRENT_FRAME_NUMBER            
    USBPORT_GetCurrentFrame, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags 
#if DBG
    URB_FUNCTION_GET_CURRENT_FRAME_NUMBER,
#endif        
    //URB_FUNCTION_CONTROL_TRANSFER            
    USBPORT_AsyncTransfer,  // Function
    sizeof(struct _URB_CONTROL_TRANSFER), // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    USBPORT_REQUEST_IS_TRANSFER,    // Flags
#if DBG
    URB_FUNCTION_CONTROL_TRANSFER,
#endif        
    //URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER                         
    USBPORT_AsyncTransfer, // Function
    sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER), // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    USBPORT_REQUEST_IS_TRANSFER,    // Flags
#if DBG
    URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER,
#endif        
    //URB_FUNCTION_ISOCH_TRANSFER            
    USBPORT_IsochTransfer, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    USBPORT_REQUEST_IS_TRANSFER, // Flags
#if DBG
    URB_FUNCTION_ISOCH_TRANSFER,
#endif        
    //URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE                        
    USBPORT_SCT_GetSetDescriptor, // Function
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    USB_REQUEST_GET_DESCRIPTOR, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
#endif        
    //URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE                        
    USBPORT_SCT_GetSetDescriptor, // Function
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    USB_REQUEST_SET_DESCRIPTOR, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE,
#endif        
    //URB_FUNCTION_SET_FEATURE_TO_DEVICE                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    USB_REQUEST_SET_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | \
        USBPORT_REQUEST_USES_DEFAULT_PIPE | \
        USBPORT_REQUEST_NO_DATA_PHASE, // Flags
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_DEVICE,
#endif        
    //URB_FUNCTION_SET_FEATURE_TO_INTERFACE                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    USB_REQUEST_SET_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | \
        USBPORT_REQUEST_USES_DEFAULT_PIPE | \
        USBPORT_REQUEST_NO_DATA_PHASE, // Flags
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_INTERFACE,
#endif        
    //URB_FUNCTION_SET_FEATURE_TO_ENDPOINT                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_ENDPOINT, // bmRequestType.Recipient
    USB_REQUEST_SET_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | \
        USBPORT_REQUEST_USES_DEFAULT_PIPE | \
        USBPORT_REQUEST_NO_DATA_PHASE, // Length
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_ENDPOINT,
#endif        
    //URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    USB_REQUEST_CLEAR_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | \
        USBPORT_REQUEST_USES_DEFAULT_PIPE | \
        USBPORT_REQUEST_NO_DATA_PHASE, // Flags
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE,
#endif        
    //URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    USB_REQUEST_CLEAR_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | \
        USBPORT_REQUEST_USES_DEFAULT_PIPE | \
        USBPORT_REQUEST_NO_DATA_PHASE, // Flags
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE,
#endif        
    //URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_ENDPOINT, // bmRequestType.Recipient
    USB_REQUEST_CLEAR_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | \
        USBPORT_REQUEST_USES_DEFAULT_PIPE | \
        USBPORT_REQUEST_NO_DATA_PHASE, // Flags
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT,
#endif        
    //URB_FUNCTION_GET_STATUS_FROM_DEVICE                            
    USBPORT_SCT_GetStatus, // Function 
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    USB_REQUEST_GET_STATUS, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_DEVICE,
#endif        
    //URB_FUNCTION_GET_STATUS_FROM_INTERFACE                            
    USBPORT_SCT_GetStatus, // Function
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    USB_REQUEST_GET_STATUS, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_INTERFACE,
#endif        
    //URB_FUNCTION_GET_STATUS_FROM_ENDPOINT                            
    USBPORT_SCT_GetStatus, // Function
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir 
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_ENDPOINT, // bmRequestType.Recipient
    USB_REQUEST_GET_STATUS, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_ENDPOINT,
#endif        
    //URB_FUNCTION_SYNC_FRAME                            
    NULL, // Function
    0,  // Length
    0, // Pad2
    0, // bmRequestType.Dir 
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    0, //URB_FUNCTION_SYNC_FRAME,
#endif        
    //URB_FUNCTION_VENDOR_DEVICE                                                    
    USBPORT_SCT_VendorClassCommand,  // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_VENDOR, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_VENDOR_DEVICE,
#endif        
    //URB_FUNCTION_VENDOR_INTERFACE                
    USBPORT_SCT_VendorClassCommand, // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_VENDOR, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Length
#if DBG
    URB_FUNCTION_VENDOR_INTERFACE,
#endif        
    //URB_FUNCTION_VENDOR_ENDPOINT                
    USBPORT_SCT_VendorClassCommand, // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_VENDOR, // bmRequestType.Type
    BMREQUEST_TO_ENDPOINT, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_VENDOR_ENDPOINT,
#endif        
    //URB_FUNCTION_CLASS_DEVICE                    
    USBPORT_SCT_VendorClassCommand, // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_CLASS, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_CLASS_DEVICE,
#endif        
    //URB_FUNCTION_CLASS_INTERFACE                
    USBPORT_SCT_VendorClassCommand, // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_CLASS, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_CLASS_INTERFACE,
#endif        
    //URB_FUNCTION_CLASS_ENDPOINT                
    USBPORT_SCT_VendorClassCommand, // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_CLASS, // bmRequestType.Type
    BMREQUEST_TO_ENDPOINT, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_CLASS_ENDPOINT,
#endif
    //URB_FUNCTION_ NOT USED
    NULL, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    URB_FUNCTION_RESERVE_0X001D,
#endif            
    //URB_FUNCTION_RESET_PIPE                    
    USBPORT_SyncResetPipeAndClearStall, // Function
    sizeof(struct _URB_PIPE_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL,
#endif        
    //URB_FUNCTION_CLASS_OTHER                    
    USBPORT_SCT_VendorClassCommand, // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_CLASS, // bmRequestType.Type
    BMREQUEST_TO_OTHER, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Length
#if DBG
    URB_FUNCTION_CLASS_OTHER,
#endif        
    //URB_FUNCTION_VENDOR_OTHER                
    USBPORT_SCT_VendorClassCommand, // Function
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir, user defined
    BMREQUEST_VENDOR, // bmRequestType.Type
    BMREQUEST_TO_OTHER, // bmRequestType.Recipient
    0, // bRequest, user defined
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_VENDOR_OTHER,
#endif        
    //URB_FUNCTION_GET_STATUS_FROM_OTHER                            
    USBPORT_SCT_GetStatus, // Function
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_OTHER, // bmRequestType.Recipient
    USB_REQUEST_GET_STATUS, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_OTHER,
#endif    
    //URB_FUNCTION_CLEAR_FEATURE_TO_OTHER                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_OTHER, // bmRequestType.Recipient
    USB_REQUEST_CLEAR_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | 
        USBPORT_REQUEST_USES_DEFAULT_PIPE | 
        USBPORT_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_OTHER,
#endif    
    //URB_FUNCTION_SET_FEATURE_TO_OTHER                        
    USBPORT_SCT_SetClearFeature, // Function
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_OTHER, // bmRequestType.Recipient
    USB_REQUEST_SET_FEATURE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | 
        USBPORT_REQUEST_USES_DEFAULT_PIPE | 
        USBPORT_REQUEST_NO_DATA_PHASE, // Flags
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_INTERFACE,
#endif                    
     //URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT                        
    USBPORT_SCT_GetSetDescriptor, // Function
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_ENDPOINT, // bmRequestType.Recipient
    USB_REQUEST_GET_DESCRIPTOR, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT,
#endif                    
     //URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT                        
    USBPORT_SCT_GetSetDescriptor, // Function
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_ENDPOINT, // bmRequestType.Recipient
    USB_REQUEST_SET_DESCRIPTOR, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT,
#endif         
    //URB_FUNCTION_GET_CONFIGURATION                        
    USBPORT_SCT_GetConfiguration, // Function
    sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_DEVICE, // bmRequestType.Recipient
    USB_REQUEST_GET_CONFIGURATION, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_CONFIGURATION,
#endif                    
    //URB_FUNCTION_GET_INTERFACE                        
    USBPORT_SCT_GetInterface, // Function
    sizeof(struct _URB_CONTROL_GET_INTERFACE_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    USB_REQUEST_GET_INTERFACE, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_INTERFACE,
#endif    
    //URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE                        
    USBPORT_SCT_GetSetDescriptor, // Function
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), // Length
    0, // Pad2
    BMREQUEST_DEVICE_TO_HOST, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    USB_REQUEST_GET_DESCRIPTOR, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE,
#endif        
    //URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE                        
    USBPORT_SCT_GetSetDescriptor, // Function
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), // Length
    0, // Pad2
    BMREQUEST_HOST_TO_DEVICE, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    USB_REQUEST_SET_DESCRIPTOR, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE,
#endif        
    //URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR                        
    USBPORT_GetMSFeartureDescriptor, // Function
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir
    BMREQUEST_STANDARD, // bmRequestType.Type
    BMREQUEST_TO_INTERFACE, // bmRequestType.Recipient
    USB_REQUEST_SET_DESCRIPTOR, // bRequest
    USBPORT_REQUEST_IS_TRANSFER | USBPORT_REQUEST_USES_DEFAULT_PIPE, // Flags
#if DBG
    URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR,
#endif    
     //URB_FUNCTION_2b                       
    USBPORT_InvalidFunction, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    0x002b,
#endif    
    //URB_FUNCTION_2c                       
    USBPORT_InvalidFunction, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    0x002c,
#endif    
    //URB_FUNCTION_2d                       
    USBPORT_InvalidFunction, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    0x002d,
#endif    
    //URB_FUNCTION_2e                       
    USBPORT_InvalidFunction, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    0x002e,
#endif    
    //URB_FUNCTION_2f                       
    USBPORT_InvalidFunction, // Function
    0, // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    0x002f,
#endif    
    //URB_FUNCTION_SYNC_RESET_PIPE                       
    USBPORT_SyncResetPipe, // Function
    sizeof(struct _URB_PIPE_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    URB_FUNCTION_SYNC_RESET_PIPE,
#endif    
     //URB_FUNCTION_SYNC_CLEAR_STALL                       
    USBPORT_SyncClearStall, // Function
    sizeof(struct _URB_PIPE_REQUEST), // Length
    0, // Pad2
    0, // bmRequestType.Dir
    0, // bmRequestType.Type
    0, // bmRequestType.Recipient
    0, // bRequest
    0, // Flags
#if DBG
    URB_FUNCTION_SYNC_CLEAR_STALL,
#endif    
}; 


PURB 
USBPORT_UrbFromIrp(
    PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PURB urb;
    
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    urb = irpStack->Parameters.Others.Argument1;

    USBPORT_ASSERT(urb);

    return urb;
}    


NTSTATUS
USBPORT_ProcessURB(
    PDEVICE_OBJECT PdoDeviceObject,
    PDEVICE_OBJECT FdoDeviceObject,
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Processes a URB from a client IRP.

    Essentially what we do here is look at the URB and validate some 
    of the the parameters for the client.

    In some cases we translate the urb in to multiple bus transactions.
    

Arguments:

    FdoDeviceObject - Device object associated with this IRP request

    Irp -  IO request block

    Urb -  ptr to USB request block

    IrpIsPending - FALSE if USBPORT completes the IRP

Return Value:


--*/
{
    NTSTATUS ntStatus;
    USHORT function;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    PUSBD_DEVICE_HANDLE deviceHandle = NULL;
    PDEVICE_EXTENSION devExt;
    
    USBPORT_KdPrint((3, "'enter USBPORT_ProcessURB\n"));

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    // assume success
    ntStatus = STATUS_SUCCESS;
    
    // initialize the error code to success,
    // some drivers do not initailize on entry
    Urb->UrbHeader.Status = USBD_STATUS_SUCCESS;

    function = Urb->UrbHeader.Function;
    // don't log to dev handle since it may not be valid
    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_URB, 'pURB', Urb, Irp, function);

    // Initialize flags field for this request
    Urb->UrbHeader.UsbdFlags = 0;

    USBPORT_KdPrint((3, "'USBPORT_ProcessURB, function = 0x%x\n", function));

    if (function > URB_FUNCTION_LAST) {
        ntStatus = 
            SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_URB_FUNCTION);

        goto USBPORT_ProcessURB_Done;
    }        
#if DBG
      else {
        USBPORT_ASSERT(UrbDispatchTable[function].ExpectedFunctionCode == function);        
    }    
#endif

    // 
    // do some special transfer specific stuff
    //

    GET_DEVICE_HANDLE(deviceHandle, Urb);


    // check for requests and fail them at low power
//#if 0
    if (TEST_FDO_FLAG(devExt, USBPORT_FDOFLAG_FAIL_URBS)) {
    
        KIRQL irql;
        PUSB_IRP_CONTEXT irpContext;

        USBPORT_KdPrint((1, "'Error: Bad Request to root hub\n"));
        
        LOGENTRY(NULL, 
            FdoDeviceObject, LOG_URB, '!URr', Urb, Irp, function);

        ALLOC_POOL_Z(irpContext, NonPagedPool, sizeof(*irpContext));
        if (irpContext) {
            
            irpContext->Sig = SIG_IRPC;
            irpContext->DeviceHandle = deviceHandle;
            irpContext->Irp = Irp;

            ACQUIRE_BADREQUEST_LOCK(FdoDeviceObject, irql);
            // put it on our list to complete
            //InsertTailList(&devExt->Fdo.BadRequestList, 
            //               &Irp->Tail.Overlay.ListEntry);
            InsertTailList(&devExt->Fdo.BadRequestList, 
                           &irpContext->ListEntry);
            
            // if handle is invalid assume this device has been removed
            // this will set the USBD status
            ntStatus = 
                SET_USBD_ERROR(Urb, USBD_STATUS_DEVICE_GONE);

            // overwrite ntStatus,
            // mark pending for the delayed failure
            ntStatus = Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            RELEASE_BADREQUEST_LOCK(FdoDeviceObject, irql);
         

        } else {
            TEST_TRAP();
            // no memory for link, just complete it now
            ntStatus = 
                SET_USBD_ERROR(Urb, USBD_STATUS_DEVICE_GONE);
  
        }

        goto USBPORT_ProcessURB_Done;
    }
//#endif        
    
    if (deviceHandle == NULL) {
        PDEVICE_EXTENSION rhDevExt;
        
        GET_DEVICE_EXT(rhDevExt, PdoDeviceObject);
        ASSERT_PDOEXT(rhDevExt);
        
        // null device handle indicates a urb for 
        // the root hub, set the devhandle to the
        // roothub
        deviceHandle = Urb->UrbHeader.UsbdDeviceHandle = 
            &rhDevExt->Pdo.RootHubDeviceHandle;
    }

    // don't log with dev handle since it may not be valid
    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_URB, 'devH', deviceHandle, Urb, 0);

    // if this is request for the deafult pipe
    
    
    // validate the state of the device
    if (!USBPORT_ValidateDeviceHandle(FdoDeviceObject,
                                      deviceHandle, 
                                      TRUE)) {
        KIRQL irql;
        PUSB_IRP_CONTEXT irpContext;
        
        USBPORT_DebugClient(("'Invalid Device Handle Passed in\n"));
        LOGENTRY(NULL, 
            FdoDeviceObject, LOG_URB, '!URB', Urb, Irp, function);

        // set to NULL, we can't defrefence it
        deviceHandle = NULL;
        
        ALLOC_POOL_Z(irpContext, NonPagedPool, sizeof(*irpContext));
        if (irpContext) {
            
            irpContext->Sig = SIG_IRPC;
            irpContext->DeviceHandle = (PUSBD_DEVICE_HANDLE) -1;
            irpContext->Irp = Irp;

            ACQUIRE_BADREQUEST_LOCK(FdoDeviceObject, irql);
            // put it on our list to complete
            //InsertTailList(&devExt->Fdo.BadRequestList, 
            //               &Irp->Tail.Overlay.ListEntry);
            InsertTailList(&devExt->Fdo.BadRequestList, 
                           &irpContext->ListEntry);
            
            // if handle is invalid assume this device has been removed
            ntStatus = 
                SET_USBD_ERROR(Urb, USBD_STATUS_DEVICE_GONE);

            // mark pending for the delayed failure
            ntStatus = Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            RELEASE_BADREQUEST_LOCK(FdoDeviceObject, irql);
         
            
//             ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_DEVICE_GONE);
        } else {
            ntStatus = 
                SET_USBD_ERROR(Urb, USBD_STATUS_DEVICE_GONE);
 
        }
        
        goto USBPORT_ProcessURB_Done;
    }

    // device handle is valid
    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_URB, 'dURB', Urb, Irp, function);
    /*
    This action is performed by passing TRUE to ValidateDeviceHandle above       
    InterlockedIncrement(&deviceHandle->PendingUrbs);        
    */
    // is this a transfer request for the default pipe
    // set the pipe handle in the urb
    if (UrbDispatchTable[function].Flags & USBPORT_REQUEST_USES_DEFAULT_PIPE) {
    
        PTRANSFER_URB transferUrb = (PTRANSFER_URB) Urb;
        
        transferUrb->UsbdPipeHandle = 
            &deviceHandle->DefaultPipe;

        SET_FLAG(transferUrb->TransferFlags, USBD_DEFAULT_PIPE_TRANSFER);
    }
    
    if (UrbDispatchTable[function].Flags & USBPORT_REQUEST_IS_TRANSFER) {
    
        PTRANSFER_URB transferUrb = (PTRANSFER_URB) Urb;
        
        if (TEST_FLAG(transferUrb->TransferFlags, USBD_DEFAULT_PIPE_TRANSFER) &&
            function == URB_FUNCTION_CONTROL_TRANSFER) {
    
            transferUrb->UsbdPipeHandle = 
                &deviceHandle->DefaultPipe;
        }
        
        // we do not support linked URBs
        if (transferUrb->ReservedMBNull != NULL) {
            ntStatus =                                   
                SET_USBD_ERROR(transferUrb, USBD_STATUS_INVALID_PARAMETER);  
            DEBUG_BREAK();                
            goto USBPORT_ProcessURB_Done; 
        }

        // zero out context field now in case the client 
        // is recycling the urb
        transferUrb->pd.HcdTransferContext = NULL;

        // no data phase therefore no buffer
        if (UrbDispatchTable[function].Flags & USBPORT_REQUEST_NO_DATA_PHASE) {
            transferUrb->TransferBuffer = NULL;
            transferUrb->TransferBufferMDL = NULL;
            transferUrb->TransferBufferLength = 0;
        }

        if (function == URB_FUNCTION_CONTROL_TRANSFER &&
            transferUrb->UsbdPipeHandle == 0) {

            TEST_TRAP(); // old diag code baggage?
        }

        if (TEST_FLAG(transferUrb->TransferFlags, USBD_DEFAULT_PIPE_TRANSFER)) {

            // usbd never supported control transfers > 4k
            if (transferUrb->TransferBufferLength > 4096) {
                TEST_TRAP();
                ntStatus =                                   
                    SET_USBD_ERROR(transferUrb, USBD_STATUS_INVALID_PARAMETER);      
                goto USBPORT_ProcessURB_Done; 
            }
        }

        // fetch the pipe handle
        pipeHandle = transferUrb->UsbdPipeHandle;

        // make sure the pipe handle the client s passing is still valid 
         
        if (!USBPORT_ValidatePipeHandle(deviceHandle, pipeHandle)) {

            USBPORT_KdPrint((1, "'Error: Invalid Device Handle Passed in\n"));
            DEBUG_BREAK();

            ntStatus = 
               SET_USBD_ERROR(transferUrb, USBD_STATUS_INVALID_PIPE_HANDLE);
               
            goto USBPORT_ProcessURB_Done;
        }

        // If there is a non-zero transfer length then either an MDL or
        // or system buffer address is required.
        //
        if (transferUrb->TransferBuffer       == NULL &&
            transferUrb->TransferBufferMDL    == NULL && 
            transferUrb->TransferBufferLength != 0) {
            ntStatus =                                   
                SET_USBD_ERROR(transferUrb, USBD_STATUS_INVALID_PARAMETER);  
            goto USBPORT_ProcessURB_Done;                    
        }                

        // if only a system buffer address is specified then
        // the caller has passed in a buffer allocated from the
        // non-paged pool.

        // in this case we allocate an MDL for the request 

        if (transferUrb->TransferBufferMDL == NULL &&
            transferUrb->TransferBufferLength != 0) {

            if ((transferUrb->TransferBufferMDL =
                IoAllocateMdl(transferUrb->TransferBuffer,
                              transferUrb->TransferBufferLength,
                              FALSE,
                              FALSE,
                              NULL)) == NULL) {
                ntStatus =                                   
                    SET_USBD_ERROR(transferUrb, 
                                   USBD_STATUS_INSUFFICIENT_RESOURCES);                                  
                 goto USBPORT_ProcessURB_Done;                        
            } else {
                SET_FLAG(transferUrb->Hdr.UsbdFlags, 
                    USBPORT_REQUEST_MDL_ALLOCATED);
                MmBuildMdlForNonPagedPool(transferUrb->TransferBufferMDL);
            }
        }

        if (transferUrb->TransferBufferMDL != NULL && 
            transferUrb->TransferBufferLength == 0) {
            ntStatus =                                   
                SET_USBD_ERROR(transferUrb, USBD_STATUS_INVALID_PARAMETER);  
            goto USBPORT_ProcessURB_Done;                    
        }                

        // transfer looks valid,
        // set up the per transfer context
        {
            USBD_STATUS usbdStatus;

            // inialize the transfer 
            usbdStatus = USBPORT_AllocTransfer(FdoDeviceObject,
                                               transferUrb,
                                               deviceHandle,
                                               Irp,
                                               NULL,
                                               0);
            if (!USBD_SUCCESS(usbdStatus)) {                                   
                ntStatus = SET_USBD_ERROR(transferUrb, usbdStatus);  
                DEBUG_BREAK();
                goto USBPORT_ProcessURB_Done; 
            }            
        }
    } 

    // non-transfer functions must validate their own parameters

    //
    // validate the length field based on the function
    //

    USBPORT_ASSERT(NT_SUCCESS(ntStatus));
    
    if (UrbDispatchTable[function].UrbRequestLength &&
        UrbDispatchTable[function].UrbRequestLength != Urb->UrbHeader.Length) {
               
        USBPORT_KdPrint((1, "'Inavlid parameter length  length = 0x%x, expected = 0x%x\n", 
                 Urb->UrbHeader.Length, 
                 UrbDispatchTable[function].UrbRequestLength));
        DEBUG_BREAK();        
        ntStatus =                                   
              SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PARAMETER);  
        goto USBPORT_ProcessURB_Done;                     
    }

    USBPORT_ASSERT(NT_SUCCESS(ntStatus));

    // call our handler for this specific USBDI function
    
    if (UrbDispatchTable[function].UrbHandler) {
        LOGENTRY(NULL, FdoDeviceObject, LOG_URB, 'Urb>', 0, function, Irp);
        
        ntStatus = 
            (UrbDispatchTable[function].UrbHandler)
                (FdoDeviceObject, Irp, Urb);
                
        LOGENTRY(NULL, FdoDeviceObject, LOG_URB, 'Urb<', ntStatus, function, 0);
        // NOTE that the URB and Irp may be gone at this point
        // if STATUS_PENDING is returned
                
    } else {
        //
        // really should not get here
        //
        DEBUG_BREAK();        
        ntStatus =                                   
              SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PARAMETER); 
        USBPORT_ASSERT(FALSE);              
    }

USBPORT_ProcessURB_Done:

    //
    // if the URB error code is set then we should also be returning
    // an error in ntStatus
    //

    if (ntStatus != STATUS_PENDING) {
        // request was not queued, complete the irp now
#if DBG        
        // if there is an error code in the URB then
        // we should be returning an error in ntstatus
        // as well
        if (Urb->UrbHeader.Status != USBD_STATUS_SUCCESS &&
            NT_SUCCESS(ntStatus)) {

            // this is a bug
            USBPORT_ASSERT(FALSE);     
        }
#endif        
        // if we allocate a transfer structure we will need to free it
        if (TEST_FLAG(Urb->UrbHeader.UsbdFlags,  USBPORT_TRANSFER_ALLOCATED)) {
            PHCD_TRANSFER_CONTEXT t;
            t = USBPORT_UnlinkTransfer(FdoDeviceObject, (PTRANSFER_URB) Urb);            
            FREE_POOL(FdoDeviceObject, t);
        }
    
        LOGENTRY(NULL, 
            FdoDeviceObject, LOG_URB, 'Uerr', ntStatus, function, Irp);

        if (deviceHandle != NULL) {
            ASSERT_DEVICE_HANDLE(deviceHandle);
            InterlockedDecrement(&deviceHandle->PendingUrbs);        
        }            

        // complete the irp status code returned by the
        // handler
        // NOTE: we complete to the PDO becuse that is the DeviceObject 
        // that the client driver passed the URB to

        USBPORT_CompleteIrp(PdoDeviceObject, Irp, ntStatus, 0);
        
    }
    
    USBPORT_KdPrint((3, "'exit USBPORT_ProcessURB 0x%x\n", ntStatus));

    return ntStatus;    
}


NTSTATUS
USBPORT_SCT_GetSetDescriptor(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Control transfer to get or set a descriptor

Arguments:

    FdoDeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    PUSB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    USBPORT_KdPrint((3, "' enter USBPORT_SCT_GetSetDescriptor\n"));
    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_URB, 'gsDE', 0, 0, Urb);

    setupPacket = 
        (PUSB_DEFAULT_PIPE_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;
    
    setupPacket->bRequest = 
        UrbDispatchTable[Urb->UrbHeader.Function].bRequest;    
    setupPacket->bmRequestType.Type = 
        UrbDispatchTable[Urb->UrbHeader.Function].Type;         
    setupPacket->bmRequestType.Dir = 
        UrbDispatchTable[Urb->UrbHeader.Function].Direction;        
    setupPacket->bmRequestType.Recipient = 
        UrbDispatchTable[Urb->UrbHeader.Function].Recipient;          
    setupPacket->bmRequestType.Reserved = 0;        

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;                    
    if (setupPacket->bmRequestType.Dir == BMREQUEST_DEVICE_TO_HOST) {
        USBPORT_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBPORT_SET_TRANSFER_DIRECTION_OUT(Urb->UrbControlTransfer.TransferFlags);
    }        

    USBPORT_QueueTransferUrb((PTRANSFER_URB)Urb); 
    
    return STATUS_PENDING;
}


NTSTATUS
USBPORT_SCT_SetClearFeature(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

Arguments:

    FdoDeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    PUSB_DEFAULT_PIPE_SETUP_PACKET setupPacket;

    USBPORT_KdPrint((2, "'SCT_SetClearFeature\n"));
    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_URB, 'scFE', 0, 0, 0);

    setupPacket = 
        (PUSB_DEFAULT_PIPE_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = 0;
    
    setupPacket->bmRequestType.Type = 
        UrbDispatchTable[Urb->UrbHeader.Function].Type;         
    setupPacket->bmRequestType.Dir = 
        UrbDispatchTable[Urb->UrbHeader.Function].Direction;        
    setupPacket->bmRequestType.Recipient = 
        UrbDispatchTable[Urb->UrbHeader.Function].Recipient; 
    setupPacket->bmRequestType.Reserved = 0;            
    //setupPacket->wValue = Urb->UrbControlFeatureRequest.FeatureSelector;            
    //setupPacket->wIndex = Urb->UrbControlFeatureRequest.Index;

    setupPacket->bRequest = 
        UrbDispatchTable[Urb->UrbHeader.Function].bRequest;            

    Urb->UrbControlTransfer.TransferBufferLength = 0;

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   
    if (setupPacket->bmRequestType.Dir == BMREQUEST_DEVICE_TO_HOST) {
        USBPORT_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBPORT_SET_TRANSFER_DIRECTION_OUT( Urb->UrbControlTransfer.TransferFlags);
    }        

    USBPORT_QueueTransferUrb((PTRANSFER_URB)Urb); 
    
    return STATUS_PENDING;
}


NTSTATUS
USBPORT_SCT_GetStatus(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

Arguments:

    FdoDeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    PUSB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    NTSTATUS ntStatus;

    USBPORT_KdPrint((2, "'SCT_GetStatus\n"));

    setupPacket
        = (PUSB_DEFAULT_PIPE_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    //
    // setup common fields
    //
    
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;
    setupPacket->wValue.W = 0;   
    setupPacket->bmRequestType.Type = 
        UrbDispatchTable[Urb->UrbHeader.Function].Type;         
    setupPacket->bmRequestType.Dir = 
        UrbDispatchTable[Urb->UrbHeader.Function].Direction;        
    setupPacket->bmRequestType.Recipient = 
        UrbDispatchTable[Urb->UrbHeader.Function].Recipient;
    setupPacket->bmRequestType.Reserved = 0;            
    setupPacket->bRequest = 
        UrbDispatchTable[Urb->UrbHeader.Function].bRequest;            
        

    // some parameter validation
    if (setupPacket->wLength != 2) {
        ntStatus =                                   
              SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PARAMETER);         
        USBPORT_DebugClient(("Bad wLength for GetStatus\n"));
        goto USBD_SCT_GetStatus_Done;
    }

    ntStatus = STATUS_PENDING;

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   
    if (setupPacket->bmRequestType.Dir == BMREQUEST_DEVICE_TO_HOST) {
        USBPORT_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBPORT_SET_TRANSFER_DIRECTION_OUT(Urb->UrbControlTransfer.TransferFlags);
    }        

    USBPORT_QueueTransferUrb((PTRANSFER_URB)Urb); 

USBD_SCT_GetStatus_Done:

    return ntStatus;
}


NTSTATUS
USBPORT_SCT_VendorClassCommand(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

Arguments:

    FdoDeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    PUSB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    UCHAR direction;

    USBPORT_KdPrint((2, "'SCT_VendorClassCommand\n"));

    setupPacket = 
        (PUSB_DEFAULT_PIPE_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;

    // if a direction was specified in the URB then
    // set direction based on URB transfer flags                
    direction = (UCHAR)( (Urb->UrbControlTransfer.TransferFlags & 
                USBD_TRANSFER_DIRECTION_IN) ?
            BMREQUEST_DEVICE_TO_HOST : BMREQUEST_HOST_TO_DEVICE);

    // note that we override only the Recipient,Dir and Type fields

    setupPacket->bmRequestType.Dir = direction;
    setupPacket->bmRequestType.Type = 
        UrbDispatchTable[Urb->UrbHeader.Function].Type;         
    setupPacket->bmRequestType.Recipient = 
        UrbDispatchTable[Urb->UrbHeader.Function].Recipient; 
        
    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   

    USBPORT_QueueTransferUrb((PTRANSFER_URB)Urb); 
    
    return STATUS_PENDING;
}


NTSTATUS
USBPORT_AsyncTransfer(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    pass interrupt or bulk transfer to HCD

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    PUSBD_PIPE_HANDLE_I pipeHandle;
    PTRANSFER_URB transferUrb = (PTRANSFER_URB) Urb;
    PHCD_ENDPOINT endpoint;
        
    USBPORT_KdPrint((2, "'AsyncTransfer\n"));

    // extract the pipe handle
    pipeHandle = transferUrb->UsbdPipeHandle;    
    // pipe handle should have been validated
    // before we got here
    ASSERT_PIPE_HANDLE(pipeHandle);
    
    endpoint = pipeHandle->Endpoint;
    ASSERT_ENDPOINT(endpoint);
    
    // set the proper direction based on the direction bit stored with the 
    // endpoint address. if this is a control transfer then leave the direction 
    // bit alone.

    if (endpoint->Parameters.TransferType != Control) {
        if (endpoint->Parameters.TransferDirection == In) {
            USBPORT_SET_TRANSFER_DIRECTION_IN(transferUrb->TransferFlags);
        } else {
            USBPORT_SET_TRANSFER_DIRECTION_OUT(transferUrb->TransferFlags);
        }        
    }

    USBPORT_QueueTransferUrb(transferUrb); 

    return STATUS_PENDING;
}

#define UHCD_ASAP_LATENCY   5

NTSTATUS
USBPORT_IsochTransfer(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    pass interrupt transfer to HCD

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PTRANSFER_URB transferUrb = (PTRANSFER_URB) Urb;
    ULONG startFrame, frameCount, p , i, cf, packetCount, maxPacketCount;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    PHCD_ENDPOINT endpoint;
    PDEVICE_EXTENSION devExt;
    KIRQL oldIrql;
    BOOLEAN highSpeed = FALSE;
    
#define ABS(x) ( (0 < (x)) ? (x) : (0 - (x)))

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
     
    USBPORT_KdPrint((2, "'IsochTransfer\n"));
    
    LOGENTRY(NULL, 
        FdoDeviceObject, LOG_URB, 'sISO', Urb, 0, 0);

    // extract the pipe handle
    pipeHandle = transferUrb->UsbdPipeHandle;    
    // pipe handle should have been validated
    // before we got here
    ASSERT_PIPE_HANDLE(pipeHandle);

    if (TEST_FLAG(pipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
        // bugbug better error code please
        ntStatus =                                   
             SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PARAMETER);                
        goto USBPORT_IsochTransfer_Done;                
    }
    
    endpoint = pipeHandle->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    if (endpoint->Parameters.DeviceSpeed == HighSpeed) {
        highSpeed = TRUE;    
    }

    MP_Get32BitFrameNumber(devExt, cf);    
    LOGENTRY(endpoint, 
        FdoDeviceObject, LOG_ISO, '>ISO', Urb, 0, cf);
        
    // process an iso transfer request
    
    // validate the number of packets per urb, USBD validated 
    // the the count was less than 256 and some tests rely on this.
    // NOTE that usbport is capable of handling 
    // larger requests so we allow larger requests thru an 
    // enhanced URB or if the device is high speed.
    maxPacketCount = 255;
    if (highSpeed) {
        // size of schedule
        maxPacketCount = 1024;
    }

    // more validation or 'security'
    // we will just fail this case with error since it doesn't make sense
    //
    if (transferUrb->TransferBufferLength == 0 &&
        transferUrb->TransferBufferMDL == NULL &&  
        transferUrb->TransferBuffer == NULL) {
        
        // this is invalid
        USBPORT_DebugClient((
            "Isoch, no buffer\n"));
        TEST_TRAP();            
            
        LOGENTRY(endpoint, 
            FdoDeviceObject, LOG_ISO, 'badP', transferUrb, 0, 0);

        ntStatus =                                   
             SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PARAMETER);                

        goto USBPORT_IsochTransfer_Done;             
    }

    
    if (transferUrb->u.Isoch.NumberOfPackets == 0 ||
        transferUrb->u.Isoch.NumberOfPackets > maxPacketCount) {
        
        // this is invalid
        USBPORT_DebugClient((
            "Isoch, numberOfPackets = 0\n"));
            
        LOGENTRY(endpoint, 
            FdoDeviceObject, LOG_ISO, 'badF', transferUrb, 0, 0);

        ntStatus =                                   
             SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PARAMETER);                

        goto USBPORT_IsochTransfer_Done;             
    }

    // first get the current USB frame number
    MP_Get32BitFrameNumber(devExt, cf);    

    packetCount = transferUrb->u.Isoch.NumberOfPackets;
    if (highSpeed) {
        frameCount = packetCount / 8;    
    } else {
        frameCount = transferUrb->u.Isoch.NumberOfPackets;
    }

    // initailize all packet status codes to 'not_set'
    for (p = 0;
         p < packetCount;
         p++) {
         
        transferUrb->u.Isoch.IsoPacket[p].Status = USBD_STATUS_NOT_SET;
    }

    // see if ASAP flag is set
    if (TEST_FLAG(transferUrb->TransferFlags,
            USBD_START_ISO_TRANSFER_ASAP)) {
        // Yes,
        // if this is the first transfer on the endpoint
        // AKA virgin then set the current frame
        if (TEST_FLAG(endpoint->Flags, EPFLAG_VIRGIN)) {
            LOGENTRY(endpoint, 
                 FdoDeviceObject, LOG_ISO, 'aspV', Urb, 0, cf);

            // use the same asap latency as the UHCD driver for 
            // compatibility
            startFrame =
                endpoint->NextTransferStartFrame = cf+UHCD_ASAP_LATENCY;
        } else {
            startFrame = endpoint->NextTransferStartFrame; 
            LOGENTRY(endpoint, 
                 FdoDeviceObject, LOG_ISO, 'aspN', Urb, startFrame, cf);

            if (ABS((LONG)(cf - startFrame)) > 256) {
                // next asap request out of range, treat this like 
                // the virgin case instead of erroring out
                LOGENTRY(endpoint, 
                         FdoDeviceObject, LOG_ISO, 'resV', Urb, 0, cf);
                           
                startFrame =
                    endpoint->NextTransferStartFrame = cf+UHCD_ASAP_LATENCY;                        
            }
        }

    } else {
        // No,
        // absolute frame number set
        startFrame = 
            endpoint->NextTransferStartFrame = 
                transferUrb->u.Isoch.StartFrame;
            
        LOGENTRY(endpoint, 
            FdoDeviceObject, LOG_ISO, 'absF', Urb, startFrame, cf);
            
        
    }

    LOGENTRY(endpoint, 
        FdoDeviceObject, LOG_ISO, 'ISsf', Urb, startFrame, cf);

    transferUrb->u.Isoch.StartFrame = startFrame;

#if DBG    
    if (!highSpeed) {
        USBPORT_ASSERT(frameCount == packetCount);
    }
#endif
    endpoint->NextTransferStartFrame += frameCount;

    // now that we have computed a start frame validate it

    if (ABS((LONG)(startFrame - cf)) > USBD_ISO_START_FRAME_RANGE)  {

        // set all iso packet status codes to not_accessed
       
        LOGENTRY(endpoint, 
            FdoDeviceObject, LOG_ISO, 'iLAT', Urb, 0, 0);
        
        for (p = 0;
             p < packetCount;
             p++) {
             
            USBPORT_ASSERT(transferUrb->u.Isoch.IsoPacket[p].Status  == 
                USBD_STATUS_NOT_SET);
                
            transferUrb->u.Isoch.IsoPacket[p].Status =
                    USBD_STATUS_ISO_NOT_ACCESSED_LATE;
        }
        
        ntStatus =                                   
             SET_USBD_ERROR(Urb, USBD_STATUS_BAD_START_FRAME);  
                     
    } else {

        // we can transmit at least some of the data 

        // set the errors for any packets that got to us too late 
        // from the client

        for (i = startFrame;
             i < startFrame + frameCount;
             i++) {
             
            if (i <= cf) {
                
                p = i - startFrame;

                if (highSpeed) {
                    ULONG j;
                    
                    p = p*8;
                    
                    for (j=0; j< 8; j++) {
                        USBPORT_ASSERT(transferUrb->u.Isoch.IsoPacket[p+j].Status == 
                            USBD_STATUS_NOT_SET);
                        
                        transferUrb->u.Isoch.IsoPacket[p+j].Status =
                            USBD_STATUS_ISO_NOT_ACCESSED_LATE;
                    }
                } else {
                    USBPORT_ASSERT(transferUrb->u.Isoch.IsoPacket[p].Status == 
                        USBD_STATUS_NOT_SET);
                        
                    transferUrb->u.Isoch.IsoPacket[p].Status =
                        USBD_STATUS_ISO_NOT_ACCESSED_LATE;
                }                        
            }
        }             

        if (endpoint->Parameters.TransferDirection == In) {
            USBPORT_SET_TRANSFER_DIRECTION_IN(transferUrb->TransferFlags);
        } else {
            USBPORT_SET_TRANSFER_DIRECTION_OUT(transferUrb->TransferFlags);
        }        

        // now queue the urb for processing by HW
        USBPORT_QueueTransferUrb(transferUrb); 
        
        LOGENTRY(endpoint, 
            FdoDeviceObject, LOG_ISO, 'ISO<',0, 0, 0);
        
        ntStatus = STATUS_PENDING;
    }
    
USBPORT_IsochTransfer_Done:              

    KeLowerIrql(oldIrql);

    return ntStatus;
}


NTSTATUS
USBPORT_GetMSFeartureDescriptor(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    pass interrupt transfer to HCD

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    TEST_TRAP();

    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_NOT_SUPPORTED);  
              
    return ntStatus;
}


NTSTATUS
USBPORT_InvalidFunction(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    pass interrupt transfer to HCD

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    TEST_TRAP();

    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_URB_FUNCTION);  
              
    return ntStatus;
}



NTSTATUS
USBPORT_SyncResetPipe(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    This API resets the host side pipe state in response to 
    a stall pid.  

    data toggle is reset if the USBDFLAGS feild specifies data 
    toggle reset

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    PUSBD_DEVICE_HANDLE deviceHandle;
    PHCD_ENDPOINT endpoint;
    PDEVICE_EXTENSION devExt;

    // this function blocks so it must not be called at DPC level
    
    USBPORT_KdPrint((2, "'SyncResetPipe\n"));
    LOGENTRY(NULL,
        FdoDeviceObject, LOG_URB, 'syrP', Urb, 0, 0);

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    GET_DEVICE_HANDLE(deviceHandle, Urb);
    pipeHandle = (PUSBD_PIPE_HANDLE_I) Urb->UrbPipeRequest.PipeHandle;

    if (!USBPORT_ValidatePipeHandle(deviceHandle, pipeHandle)) {

        USBPORT_KdPrint((1, "'Error: Invalid Device Handle Passed in\n"));
        DEBUG_BREAK();

        ntStatus = 
           SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PIPE_HANDLE);
           
        goto USBPORT_SyncResetPipe_Done;
    }

    // our bug
    ASSERT_PIPE_HANDLE(pipeHandle);
    endpoint = pipeHandle->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    LOGENTRY(endpoint,
        FdoDeviceObject, LOG_URB, 'syrp', Urb, 0, 0);

    ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeH0');

    // see if we have active transfers, if so we cannot 
    // reset the pipe.
    // NOTE: this is a synchronization bug in the client.
    if (IsListEmpty(&endpoint->ActiveList)) {
        // clear the pipe state

        if (TEST_FLAG(Urb->UrbHeader.UsbdFlags, USBPORT_RESET_DATA_TOGGLE)) {
            MP_SetEndpointDataToggle(devExt, endpoint, 0);
        }    

        ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);
    
    } else {
        
        USBPORT_DebugClient((
            "reset pipe with active transfers\n"));
        ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_ERROR_BUSY);
    }

    LOGENTRY(endpoint,
        FdoDeviceObject, LOG_ISO, 'virg', Urb, 0, 0);
    SET_FLAG(endpoint->Flags, EPFLAG_VIRGIN);
    // set the endpoint state to Active
    MP_SetEndpointStatus(devExt, endpoint, ENDPOINT_STATUS_RUN);

    RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeH0');

USBPORT_SyncResetPipe_Done:

    return ntStatus;
}


NTSTATUS
USBPORT_SyncClearStall(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Clear stall on an endpoint note: data toggle is unaffected
Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    PUSBD_DEVICE_HANDLE deviceHandle;
    PHCD_ENDPOINT endpoint;
    USB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    USBD_STATUS usbdStatus;

    // this function blocks so it must not be called at DPC level
    
    PAGED_CODE();

    USBPORT_KdPrint((2, "'SyncClearStall\n"));

    GET_DEVICE_HANDLE(deviceHandle, Urb);
    pipeHandle = (PUSBD_PIPE_HANDLE_I) Urb->UrbPipeRequest.PipeHandle;

    if (!USBPORT_ValidatePipeHandle(deviceHandle, pipeHandle)) {

        USBPORT_KdPrint((1, "'Error: Invalid Device Handle Passed in\n"));
        DEBUG_BREAK();

        ntStatus = 
           SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PIPE_HANDLE);
           
        goto USBPORT_SyncClearStall_Done;
    }

    // our bug
    ASSERT_PIPE_HANDLE(pipeHandle);
    endpoint = pipeHandle->Endpoint;
    ASSERT_ENDPOINT(endpoint);

    // setup packet for clear endpoint stall
    USBPORT_INIT_SETUP_PACKET(setupPacket,
        USB_REQUEST_CLEAR_FEATURE, // bRequest
        BMREQUEST_HOST_TO_DEVICE, // Dir
        BMREQUEST_TO_ENDPOINT, // Recipient
        BMREQUEST_STANDARD, // Type
        USB_FEATURE_ENDPOINT_STALL, // wValue
        endpoint->Parameters.EndpointAddress, // wIndex
        0); // wLength
  
    ntStatus =
        USBPORT_SendCommand(deviceHandle,
                            FdoDeviceObject,
                            &setupPacket,
                            NULL,
                            0,
                            NULL,
                            &usbdStatus);
                            
    ntStatus = SET_USBD_ERROR(Urb, usbdStatus);
    
USBPORT_SyncClearStall_Done:
              
    return ntStatus;
}


NTSTATUS
USBPORT_SyncResetPipeAndClearStall(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Process a reset pipe request from the client driver
    synchronously

    legacy function from usb 1.1 stack sends the clear endpoint 
    stall command and resets ths host side state including data 
    toggle for the endpoint.

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    PUSBD_DEVICE_HANDLE deviceHandle;
    PHCD_ENDPOINT endpoint;
    USBD_STATUS usbdStatus;
        
    GET_DEVICE_HANDLE(deviceHandle, Urb);
    pipeHandle = (PUSBD_PIPE_HANDLE_I) Urb->UrbPipeRequest.PipeHandle;

    if (!USBPORT_ValidatePipeHandle(deviceHandle, pipeHandle)) {

        USBPORT_KdPrint((1, "'Error: Invalid Pipe Handle Passed in\n"));
        DEBUG_BREAK();

        ntStatus = 
           SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PIPE_HANDLE);
           
    } else {

        // our bug
        ASSERT_PIPE_HANDLE(pipeHandle);
        
        // check for a zero load (BW) endpoint, if so there is 
        // nothing to do -- just complete the request with success
        
        if (TEST_FLAG(pipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
            ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);
        } else {
            endpoint = pipeHandle->Endpoint;
            ASSERT_ENDPOINT(endpoint);

            InterlockedIncrement(&deviceHandle->PendingUrbs);        
  
            // clear the stall first on the device
            // then reset the pipe

            if (endpoint->Parameters.TransferType == Isochronous) {
            
                // This is a nop for iso endpoints
                //
                // the orginal win9x/2k stack did not send this request
                // for iso endpoints so we don't either. Some devices
                // are confused by this. A client driver may override
                // this behavior by call ing clear_stall and reset_pipe
                // directly
                
                LOGENTRY(endpoint,
                         FdoDeviceObject, LOG_ISO, 'iRES', endpoint, 0, 0);


                ntStatus = SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);

            } else {
                // only need to reset data toggle if we cleared stall
                // ie only for non-iso endpoints
                SET_FLAG(Urb->UrbHeader.UsbdFlags, USBPORT_RESET_DATA_TOGGLE); 
                ntStatus = USBPORT_SyncClearStall(FdoDeviceObject, 
                                                  Irp,
                                                  Urb); 
            }
            
            if (NT_SUCCESS(ntStatus)) {
                ntStatus = USBPORT_SyncResetPipe(FdoDeviceObject, 
                                             Irp,
                                             Urb);

                if (endpoint->Parameters.TransferType == Isochronous) {
                
                    MP_ENDPOINT_STATE currentState;

                    do {
                
                        ACQUIRE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'LeH0');

                        currentState = USBPORT_GetEndpointState(endpoint);
                        LOGENTRY(endpoint,
                                FdoDeviceObject, LOG_ISO, 'iWAT', endpoint, 
                                currentState, 0);

                        if (currentState == ENDPOINT_PAUSE && 
                            IsListEmpty(&endpoint->ActiveList))  {
                            LOGENTRY(endpoint,
                                FdoDeviceObject, LOG_ISO, 'frcA', endpoint, 
                                0, 0);
                                
                            USBPORT_SetEndpointState(endpoint, ENDPOINT_ACTIVE);
                        }                                                    

                        RELEASE_ENDPOINT_LOCK(endpoint, FdoDeviceObject, 'UeH0');

                        if (currentState == ENDPOINT_ACTIVE) {
                            // quick release
                            break;
                        }

                        ASSERT_PASSIVE();
                        USBPORT_Wait(FdoDeviceObject, 1);
                        
                    } while (currentState != ENDPOINT_ACTIVE);
                    
                }                
                                                    
            } 

            InterlockedDecrement(&deviceHandle->PendingUrbs);        
        }
    }
              
    return ntStatus;
}


NTSTATUS
USBPORT_AbortPipe(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PUSBD_PIPE_HANDLE_I pipeHandle;
    PHCD_ENDPOINT endpoint;
    PUSBD_DEVICE_HANDLE deviceHandle;        
    
    USBPORT_KdPrint((2, "'AbortPipe\n"));
    LOGENTRY(Endpoint, 
             FdoDeviceObject, LOG_URB, 'ARP>', 0, Irp, Urb);

    // extract the pipe handle
    GET_DEVICE_HANDLE(deviceHandle, Urb);
    pipeHandle = Urb->UrbPipeRequest.PipeHandle; 
    
    // processurb only validate transfer pipe handles so 
    // we need to do it here
    if (!USBPORT_ValidatePipeHandle(deviceHandle, pipeHandle)) {

        USBPORT_KdPrint((1, "'Error: Invalid Pipe Handle Passed in\n"));
        DEBUG_BREAK();

        ntStatus = 
           SET_USBD_ERROR(Urb, USBD_STATUS_INVALID_PIPE_HANDLE);
    } else {               

        if (TEST_FLAG(pipeHandle->PipeStateFlags, USBPORT_PIPE_ZERO_BW)) {
            // just succeed the request if its a no bw pipe          
            ntStatus = 
                SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);    
        } else {
            endpoint = pipeHandle->Endpoint;
            ASSERT_ENDPOINT(endpoint);

            // the USBD/UHCD driver always pended this request when it passed
            // it thru startio so we are safe to pend it here as well.
            
            // We will pend this request until all outstanding transfers 
            // (at the time of the abort) have been completed
            
            ntStatus = Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            // now do the abort
            USBPORT_AbortEndpoint(FdoDeviceObject,
                                  endpoint,
                                  Irp);
        }                                  
    }

    LOGENTRY(Endpoint, 
             FdoDeviceObject, LOG_URB, 'ARP<', 0, Irp, ntStatus);

    
    return ntStatus;
}


NTSTATUS
USBPORT_SCT_GetInterface(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

Arguments:

    FdoDeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    TEST_TRAP();

    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_NOT_SUPPORTED);  
              
    return ntStatus;
}


NTSTATUS
USBPORT_SCT_GetConfiguration(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

Arguments:

    FdoDeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    PUSB_DEFAULT_PIPE_SETUP_PACKET setupPacket;
    UCHAR direction;

    USBPORT_KdPrint((2, "'SCT_GetConfiguration\n"));

    setupPacket = 
        (PUSB_DEFAULT_PIPE_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    setupPacket->bRequest = 
        UrbDispatchTable[Urb->UrbHeader.Function].bRequest;    
    setupPacket->bmRequestType.Type = 
        UrbDispatchTable[Urb->UrbHeader.Function].Type;         
    setupPacket->bmRequestType.Dir = 
        UrbDispatchTable[Urb->UrbHeader.Function].Direction;        
    setupPacket->bmRequestType.Recipient = 
        UrbDispatchTable[Urb->UrbHeader.Function].Recipient;          
    setupPacket->bmRequestType.Reserved = 0;        
    setupPacket->wValue.W = 0;            
    setupPacket->wIndex.W = 0;
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;

    if (setupPacket->bmRequestType.Dir == BMREQUEST_DEVICE_TO_HOST) {
        USBPORT_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBPORT_SET_TRANSFER_DIRECTION_OUT(Urb->UrbControlTransfer.TransferFlags);
    }   
    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;  
    
    USBPORT_QueueTransferUrb((PTRANSFER_URB)Urb); 
    
    return STATUS_PENDING;
}


NTSTATUS
USBPORT_TakeFrameLengthControl(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    TEST_TRAP();

    // This function is no longer supported
    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_NOT_SUPPORTED);  
              
    return ntStatus;
}


NTSTATUS
USBPORT_ReleaseFrameLengthControl(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    TEST_TRAP();

    // This function is no longer supported
    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_NOT_SUPPORTED);  
              
    return ntStatus;
}


NTSTATUS
USBPORT_GetFrameLength(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    TEST_TRAP();

    // This function is no longer supported
    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_NOT_SUPPORTED);  
              
    return ntStatus;
}


NTSTATUS
USBPORT_SetFrameLength(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    TEST_TRAP();
    // This function is no longer supported

    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_NOT_SUPPORTED);  
              
    return ntStatus;
}


NTSTATUS
USBPORT_GetCurrentFrame(
    PDEVICE_OBJECT FdoDeviceObject, 
    PIRP Irp,
    PURB Urb
    )
/*++

Routine Description:

    get the 32 bit frame number from the miniport

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION devExt;
    ULONG cf;

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    MP_Get32BitFrameNumber(devExt, cf);    

    LOGENTRY(NULL,
        FdoDeviceObject, LOG_URB, 'Ugcf', Urb, cf, 0);

    Urb->UrbGetCurrentFrameNumber.FrameNumber = cf;
    
    ntStatus =                                   
         SET_USBD_ERROR(Urb, USBD_STATUS_SUCCESS);  
              
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\inc\enumlog.h ===
/*++

Copyright (c) 1995      Microsoft Corporation

Module Name:

        ENUMLOG.H

Abstract:

   structures for enumeration logging in USB client drivers using 
   usbport bus interface function.

Environment:

    Kernel & user mode

Revision History:

    12-19-01 : created

--*/

#ifndef   __ENUMLOG_H__
#define   __ENUMLOG_H__

/*
    driver tags
*/

#define USBDTAG_HUB     'hbsu'
#define USBDTAG_USBPORT 'pbsu'

#define ENUMLOG(businterface, driverTag, sig, param1, param2) \
    (businterface)->EnumLogEntry((businterface)->BusContext,\
                          driverTag,\
                          sig,      \
                          (ULONG) param1,   \
                          (ULONG) param2)


#endif //__ENUMLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\inc\usbdlibi.h ===
/*++

Copyright (c) 1995	Microsoft Corporation

Module Name:

    USBDLIBI.H

Abstract:

   Services exported by USBD for use by USB port drivers and
   the usb hub driver.

Environment:

    Kernel & user mode

Revision History:

    01-27-96 : created

--*/

#ifndef   __USBDLIBI_H__
#define   __USBDLIBI_H__

#pragma message ("warning: using obsolete header file usbdlibi.h")

#define USBD_KEEP_DEVICE_DATA   0x01
#define USBD_MARK_DEVICE_BUSY   0x02

#ifndef USBD

typedef PVOID PUSBD_DEVICE_DATA;

//
// Services exported by USBD
//

DECLSPEC_IMPORT
VOID 
USBD_RegisterHostController(
    IN PDEVICE_OBJECT PhysicalDeviceObject, 
    IN PDEVICE_OBJECT HcdDeviceObject,
    IN PDEVICE_OBJECT HcdTopOfPdoStackDeviceObject,
    IN PDRIVER_OBJECT HcdDriverObject,
    IN HCD_DEFFERED_START_FUNCTION *HcdDeffreredStart,
    IN HCD_SET_DEVICE_POWER_STATE *HcdSetDevicePowerState,
    IN HCD_GET_CURRENT_FRAME *HcdGetCurrentFrame,
    IN HCD_GET_CONSUMED_BW *HcdGetConsumedBW,
    IN HCD_SUBMIT_ISO_URB *HcdSubmitIsoUrb,
    IN ULONG HcdDeviceNameHandle
    ); 

DECLSPEC_IMPORT
BOOLEAN
USBD_Dispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_OBJECT *HcdDeviceObject,
    NTSTATUS *NtStatus
    );

DECLSPEC_IMPORT
VOID
USBD_CompleteRequest(
    PIRP Irp,
    CCHAR PriorityBoost
    );

DECLSPEC_IMPORT
NTSTATUS
USBD_CreateDevice(
    IN OUT PUSBD_DEVICE_DATA *DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeviceIsLowSpeed,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG NonCompliantDevice
    );

DECLSPEC_IMPORT
NTSTATUS
USBD_InitializeDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    );

DECLSPEC_IMPORT
NTSTATUS
USBD_RemoveDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Flags
    );

DECLSPEC_IMPORT
NTSTATUS
USBD_RestoreDevice(
    IN OUT PUSBD_DEVICE_DATA OldDeviceData,
    IN OUT PUSBD_DEVICE_DATA NewDeviceData,
    IN PDEVICE_OBJECT DeviceObject
    );

DECLSPEC_IMPORT
ULONG
USBD_AllocateDeviceName(
    PUNICODE_STRING DeviceNameUnicodeString
    );

DECLSPEC_IMPORT
VOID
USBD_FreeDeviceName(
    ULONG DeviceNameHandle
    );    

DECLSPEC_IMPORT
VOID
USBD_WaitDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    );      

DECLSPEC_IMPORT
VOID
USBD_FreeDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    );   

DECLSPEC_IMPORT   
NTSTATUS
USBD_GetDeviceInformation(
    IN PUSB_NODE_CONNECTION_INFORMATION DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSBD_DEVICE_DATA DeviceData
    );

DECLSPEC_IMPORT
NTSTATUS
USBD_MakePdoName(
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    );

DECLSPEC_IMPORT
VOID
USBD_RegisterHcDeviceCapabilities(
    PDEVICE_OBJECT DeviceObject, 
    PDEVICE_CAPABILITIES DeviceCapabilities,
    ROOT_HUB_POWER_FUNCTION *RootHubPower
    );

DECLSPEC_IMPORT    
ULONG
USBD_CalculateUsbBandwidth(
    ULONG MaxPacketSize,
    UCHAR EndpointType,
    BOOLEAN LowSpeed
    );    

#endif    
    
#endif /* __USBDLIBI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\inc\hcdi.h ===
/*++

Copyright (c) 1995      Microsoft Corporation

Module Name:

        HCDI.H

Abstract:

   structures common to the usbd and hcd device drivers.

Environment:

    Kernel & user mode

Revision History:

    09-29-95 : created

--*/

#ifndef   __HCDI_H__
#define   __HCDI_H__

typedef NTSTATUS ROOT_HUB_POWER_FUNCTION(PDEVICE_OBJECT DeviceObject,
                                         PIRP Irp);
typedef NTSTATUS HCD_DEFFERED_START_FUNCTION(PDEVICE_OBJECT DeviceObject,
                                             PIRP Irp);
typedef NTSTATUS HCD_SET_DEVICE_POWER_STATE(PDEVICE_OBJECT DeviceObject,
                                            PIRP Irp,
                                            DEVICE_POWER_STATE DeviceState);
typedef NTSTATUS HCD_GET_CURRENT_FRAME(PDEVICE_OBJECT DeviceObject,
                                       PULONG CurrentFrame);

typedef NTSTATUS HCD_GET_CONSUMED_BW(PDEVICE_OBJECT DeviceObject);

typedef NTSTATUS HCD_SUBMIT_ISO_URB(PDEVICE_OBJECT DeviceObject, PURB Urb);



//
// values for DeviceExtension Flags
//
#define USBDFLAG_PDO_REMOVED                0x00000001
#define USBDFLAG_HCD_SHUTDOWN               0x00000002
#define USBDFLAG_HCD_STARTED                0x00000004
#define USBDFLAG_HCD_D0_COMPLETE_PENDING    0x00000008
#define USBDFLAG_RH_DELAY_SET_D0            0x00000010
#define USBDFLAG_NEED_NEW_HCWAKEIRP         0x00000020

typedef struct _USBD_EXTENSION {
    // ptr to true device extension or NULL if this
    // is the true extension
    PVOID TrueDeviceExtension;
    ULONG Flags;
    // size of this structure
    ULONG Length;

    ROOT_HUB_POWER_FUNCTION *RootHubPower;
    HCD_DEFFERED_START_FUNCTION *HcdDeferredStartDevice;
    HCD_SET_DEVICE_POWER_STATE *HcdSetDevicePowerState;
    HCD_GET_CURRENT_FRAME *HcdGetCurrentFrame;
    HCD_GET_CONSUMED_BW *HcdGetConsumedBW;
    HCD_SUBMIT_ISO_URB *HcdSubmitIsoUrb;

    DEVICE_POWER_STATE HcCurrentDevicePowerState;

    KEVENT PnpStartEvent;

    //
    // Owner of frame length control for this HC
    //
    PVOID FrameLengthControlOwner;

    //
    // HCD device object we are connected to.
    //
    PDEVICE_OBJECT HcdDeviceObject;

    // wake irp passed to us by the hub driver
    // for the root hub
    PIRP PendingWakeIrp;

    // wakeup irp we send down the HC stack
    PIRP HcWakeIrp;

    //
    // device object for top of the HCD stack
    // this = HcdDeviceObject when no filters
    // are present.
    //

    PDEVICE_OBJECT HcdTopOfStackDeviceObject;

    PDEVICE_OBJECT HcdTopOfPdoStackDeviceObject;

    //
    // copy of the host controller device
    // capabilities
    //
    DEVICE_CAPABILITIES HcDeviceCapabilities;

    DEVICE_CAPABILITIES RootHubDeviceCapabilities;

    PIRP PowerIrp;

    //
    // Used to serialize open/close endpoint and
    // device configuration
    //
    KSEMAPHORE UsbDeviceMutex;

    //
    // Bitmap of assigned USB addresses
    //
    ULONG AddressList[4];

    //
    // Remember the Root Hub PDO we created.
    //

    PDEVICE_OBJECT RootHubPDO;

    PDRIVER_OBJECT DriverObject;

    //
    // symbolic link created for HCD stack
    //

    UNICODE_STRING DeviceLinkUnicodeString;

    BOOLEAN DiagnosticMode;
    BOOLEAN DiagIgnoreHubs;

    BOOLEAN Reserved; // used to be supportNonComp
    UCHAR HcWakeFlags;

    ULONG DeviceHackFlags;

    KSPIN_LOCK WaitWakeSpin;

    //
    // Store away the PDO
    //
    PDEVICE_OBJECT HcdPhysicalDeviceObject;

    PVOID RootHubDeviceData;

    DEVICE_POWER_STATE RootHubDeviceState;

    // current USB defined power state of the bus
    // during last suspend.
    DEVICE_POWER_STATE SuspendPowerState;

    UNICODE_STRING RootHubSymbolicLinkName;

    KSPIN_LOCK RootHubPowerSpin;
    PDEVICE_OBJECT RootHubPowerDeviceObject;
    PIRP RootHubPowerIrp;

    PIRP IdleNotificationIrp;
    BOOLEAN IsPIIX3or4;
    BOOLEAN WakeSupported;

} USBD_EXTENSION, *PUSBD_EXTENSION;

#define HC_ENABLED_FOR_WAKEUP           0x01
#define HC_WAKE_PENDING                 0x02


// device hack flags, these flags alter the stacks default behavior
// in order to support certain broken "legacy" devices

#define USBD_DEVHACK_SLOW_ENUMERATION   0x00000001
#define USBD_DEVHACK_DISABLE_SN         0x00000002

//
// This macro returns the true device object for the HCD give
// either the true device_object or a PDO owned by the HCD/BUS
// driver.
//

//
// HCD specific URB commands
//

#define URB_FUNCTION_HCD_OPEN_ENDPOINT                0x1000
#define URB_FUNCTION_HCD_CLOSE_ENDPOINT               0x1001
#define URB_FUNCTION_HCD_GET_ENDPOINT_STATE           0x1002
#define URB_FUNCTION_HCD_SET_ENDPOINT_STATE           0x1003
#define URB_FUNCTION_HCD_ABORT_ENDPOINT               0x1004

// this bit is set for all functions that must be handled by HCD
#define HCD_URB_FUNCTION                              0x1000  
// this bit is set in the function code by USBD to indicate that
// this is an internal call originating from USBD 
#define HCD_NO_USBD_CALL                              0x2000  

//
// values for HcdEndpointState
//

//
// set if the current state of the endpoint in the HCD is 'stalled'
//
#define HCD_ENDPOINT_HALTED_BIT            0
#define HCD_ENDPOINT_HALTED                (1<<HCD_ENDPOINT_HALTED_BIT)

//
// set if the HCD has any transfers queued for the endpoint
//
#define HCD_ENDPOINT_TRANSFERS_QUEUED_BIT  1
#define HCD_ENDPOINT_TRANSFERS_QUEUED      (1<<HCD_ENDPOINT_TRANSFERS_QUEUED_BIT)


//
// set if the HCD should reset the data toggle on the host side
//
#define HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT 2
#define HCD_ENDPOINT_RESET_DATA_TOGGLE     (1<<HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT )


//
// HCD specific URBs
//

#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002
#define USBD_EP_FLAG_DOUBLE_BUFFER           0x0004
#define USBD_EP_FLAG_FAST_ISO                0x0008
#define USBD_EP_FLAG_MAP_ADD_IO              0x0010
    
struct _URB_HCD_OPEN_ENDPOINT {
    struct _URB_HEADER;
    USHORT DeviceAddress;
    USHORT HcdEndpointFlags;
    PUSB_ENDPOINT_DESCRIPTOR EndpointDescriptor;
    ULONG MaxTransferSize;
    PVOID HcdEndpoint;
    ULONG ScheduleOffset;
};
    
struct _URB_HCD_CLOSE_ENDPOINT {
    struct _URB_HEADER;
    PVOID HcdEndpoint;
};

struct _URB_HCD_ENDPOINT_STATE {
    struct _URB_HEADER;
    PVOID HcdEndpoint;
    ULONG HcdEndpointState;
};

struct _URB_HCD_ABORT_ENDPOINT {
    struct _URB_HEADER;
    PVOID HcdEndpoint;
};


//
// Common transfer request definition, all transfer
// requests passed to the HCD will be mapped to this
// format.  The HCD will can use this structure to
// reference fields that are common to all transfers
// as well as fields specific to isochronous and
// control transfers.
//

typedef struct _COMMON_TRANSFER_EXTENSION {
    union {
        struct {
            ULONG StartFrame;
            ULONG NumberOfPackets;
            ULONG ErrorCount;
            USBD_ISO_PACKET_DESCRIPTOR IsoPacket[0];     
        } Isoch;
        UCHAR SetupPacket[8];    
    } u;
} COMMON_TRANSFER_EXTENSION, *PCOMMON_TRANSFER_EXTENSION;


struct _URB_HCD_COMMON_TRANSFER {
    struct _URB_HEADER;
    PVOID UsbdPipeHandle;
    ULONG TransferFlags;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;
    struct _HCD_URB *UrbLink;   // link to next urb request
                                // if this is a chain of requests
    struct _URB_HCD_AREA hca;       // fields for HCD use

    COMMON_TRANSFER_EXTENSION Extension; 
/*    
    //add fields for isoch and
    //control transfers
    UCHAR SetupPacket[8];

    ULONG StartFrame;
    // number of packets that make up this request
    ULONG NumberOfPackets;
    // number of packets that completed with errors
    ULONG ErrorCount;
    USBD_ISO_PACKET_DESCRIPTOR IsoPacket[0]; 
*/    
};

typedef struct _HCD_URB {
    union {
            struct _URB_HEADER                      UrbHeader;
            struct _URB_HCD_OPEN_ENDPOINT           HcdUrbOpenEndpoint;
            struct _URB_HCD_CLOSE_ENDPOINT          HcdUrbCloseEndpoint;
            struct _URB_GET_FRAME_LENGTH            UrbGetFrameLength;
            struct _URB_SET_FRAME_LENGTH            UrbSetFrameLength;
            struct _URB_GET_CURRENT_FRAME_NUMBER    UrbGetCurrentFrameNumber;
            struct _URB_HCD_ENDPOINT_STATE          HcdUrbEndpointState;
            struct _URB_HCD_ABORT_ENDPOINT          HcdUrbAbortEndpoint;
            //formats for USB transfer requests.
            struct _URB_HCD_COMMON_TRANSFER         HcdUrbCommonTransfer;
            //formats for specific transfer types
            //that have fields not contained in
            //CommonTransfer.
            //this will be merged with commontransfer
            struct _URB_ISOCH_TRANSFER              UrbIsochronousTransfer;

    };
} HCD_URB, *PHCD_URB;


//
// bandwidth related definitions
//

// overhead in bytes/ms

#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13



#endif /* __HCDI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\debug.c ===
/*
 *************************************************************************
 *  File:       DEBUG.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "debug.h"


#if DBG
    BOOLEAN dbgTrapOnWarn = FALSE;   
    BOOLEAN dbgVerbose = FALSE;
    BOOLEAN dbgShowIsochProgress = FALSE; 

    VOID DbgLogIrpMajor(ULONG_PTR irpPtr, ULONG majorFunc, ULONG isForParentFdo, ULONG isComplete, ULONG status)
    {

        if (dbgVerbose){
            char *funcName;

            switch (majorFunc){
                #undef MAKE_CASE
                #define MAKE_CASE(fnc) case fnc: funcName = #fnc; break;

                MAKE_CASE(IRP_MJ_CREATE)
                MAKE_CASE(IRP_MJ_CREATE_NAMED_PIPE)
                MAKE_CASE(IRP_MJ_CLOSE)
                MAKE_CASE(IRP_MJ_READ)
                MAKE_CASE(IRP_MJ_WRITE)
                MAKE_CASE(IRP_MJ_QUERY_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_INFORMATION)
                MAKE_CASE(IRP_MJ_QUERY_EA)
                MAKE_CASE(IRP_MJ_SET_EA)
                MAKE_CASE(IRP_MJ_FLUSH_BUFFERS)
                MAKE_CASE(IRP_MJ_QUERY_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_SET_VOLUME_INFORMATION)
                MAKE_CASE(IRP_MJ_DIRECTORY_CONTROL)
                MAKE_CASE(IRP_MJ_FILE_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_INTERNAL_DEVICE_CONTROL)
                MAKE_CASE(IRP_MJ_SHUTDOWN)
                MAKE_CASE(IRP_MJ_LOCK_CONTROL)
                MAKE_CASE(IRP_MJ_CLEANUP)
                MAKE_CASE(IRP_MJ_CREATE_MAILSLOT)
                MAKE_CASE(IRP_MJ_QUERY_SECURITY)
                MAKE_CASE(IRP_MJ_SET_SECURITY)
                MAKE_CASE(IRP_MJ_POWER)
                MAKE_CASE(IRP_MJ_SYSTEM_CONTROL)
                MAKE_CASE(IRP_MJ_DEVICE_CHANGE)
                MAKE_CASE(IRP_MJ_QUERY_QUOTA)
                MAKE_CASE(IRP_MJ_SET_QUOTA)
                MAKE_CASE(IRP_MJ_PNP)

                default: funcName = "????";    break;
            }

            if (isComplete){
                DBGOUT(("< %s for %s status=%xh %s (irp=%ph)",
                       funcName,
                       isForParentFdo ? "parent" : "function",
                       status,
                       NT_SUCCESS(status) ? "" : "<** ERROR **>",
                       irpPtr));
            }
            else {
                DBGOUT(("> %s for %s (irp=%ph)", 
                       funcName, 
                       isForParentFdo ? "parent" : "function",
                       irpPtr));
            }
        }

    }




    VOID DbgLogPnpIrp(ULONG_PTR irpPtr, ULONG minorFunc, ULONG isForParentFdo, ULONG isComplete, ULONG status)
    {
        char *funcName;

        switch (minorFunc){
            #undef MAKE_CASE
            #define MAKE_CASE(fnc) case fnc: funcName = #fnc; break;

            MAKE_CASE(IRP_MN_START_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
            MAKE_CASE(IRP_MN_STOP_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
            MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
            MAKE_CASE(IRP_MN_QUERY_DEVICE_RELATIONS)
            MAKE_CASE(IRP_MN_QUERY_INTERFACE)
            MAKE_CASE(IRP_MN_QUERY_CAPABILITIES)
            MAKE_CASE(IRP_MN_QUERY_RESOURCES)
            MAKE_CASE(IRP_MN_QUERY_RESOURCE_REQUIREMENTS)
            MAKE_CASE(IRP_MN_QUERY_DEVICE_TEXT)
            MAKE_CASE(IRP_MN_READ_CONFIG)
            MAKE_CASE(IRP_MN_WRITE_CONFIG)
            MAKE_CASE(IRP_MN_EJECT)
            MAKE_CASE(IRP_MN_SET_LOCK)
            MAKE_CASE(IRP_MN_QUERY_ID)
            MAKE_CASE(IRP_MN_QUERY_PNP_DEVICE_STATE)
            MAKE_CASE(IRP_MN_QUERY_BUS_INFORMATION)

            default: funcName = "????"; break;
        }

        if (dbgVerbose){
            if (isComplete){
                DBGOUT((" < %s for %s status=%xh (irp=%ph)", 
                        funcName, 
                        isForParentFdo ? "parent" : "function",
                        status,
                        irpPtr));
            }
            else {
                DBGOUT((" > %s for %s (irp=%ph)", 
                        funcName, 
                        isForParentFdo ? "parent" : "function",
                        irpPtr));
            }
        }


    }


    VOID DbgLogIoctl(ULONG ioControlCode, ULONG status)
    {
        if (dbgVerbose){
            PCHAR ioctlStr;

            switch (ioControlCode){
                #undef MAKE_CASE
                #define MAKE_CASE(ioctl) case ioctl: ioctlStr = #ioctl; break;

                MAKE_CASE(IOCTL_INTERNAL_USB_SUBMIT_URB) 
                MAKE_CASE(IOCTL_INTERNAL_USB_RESET_PORT)
                MAKE_CASE(IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO)
                MAKE_CASE(IOCTL_INTERNAL_USB_GET_PORT_STATUS) 
                MAKE_CASE(IOCTL_INTERNAL_USB_ENABLE_PORT)   
                MAKE_CASE(IOCTL_INTERNAL_USB_GET_HUB_COUNT)   
                MAKE_CASE(IOCTL_INTERNAL_USB_CYCLE_PORT)
                MAKE_CASE(IOCTL_INTERNAL_USB_GET_HUB_NAME)  
                MAKE_CASE(IOCTL_INTERNAL_USB_GET_BUS_INFO) 
                MAKE_CASE(IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME)

                default: ioctlStr = "???"; break;
            }

            DBGOUT(("  IOCTL: %s (%xh) status=%xh", ioctlStr, ioControlCode, status));
        }
    }


    PUCHAR DbgGetUrbName(ULONG urbFunc)
    {
        PUCHAR urbName;

        switch (urbFunc){

            #undef MAKE_CASE
            #define MAKE_CASE(func) case func: urbName = #func; break;

            MAKE_CASE(URB_FUNCTION_SELECT_CONFIGURATION)
            MAKE_CASE(URB_FUNCTION_SELECT_INTERFACE)
            MAKE_CASE(URB_FUNCTION_ABORT_PIPE)
            MAKE_CASE(URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL)
            MAKE_CASE(URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL)
            MAKE_CASE(URB_FUNCTION_GET_FRAME_LENGTH)
            MAKE_CASE(URB_FUNCTION_SET_FRAME_LENGTH)
            MAKE_CASE(URB_FUNCTION_GET_CURRENT_FRAME_NUMBER)
            MAKE_CASE(URB_FUNCTION_CONTROL_TRANSFER)
            MAKE_CASE(URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
            MAKE_CASE(URB_FUNCTION_ISOCH_TRANSFER)
            MAKE_CASE(URB_FUNCTION_RESET_PIPE)
            MAKE_CASE(URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE)
            MAKE_CASE(URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT)
            MAKE_CASE(URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE)
            MAKE_CASE(URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE)
            MAKE_CASE(URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT)
            MAKE_CASE(URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE)
            MAKE_CASE(URB_FUNCTION_SET_FEATURE_TO_DEVICE)
            MAKE_CASE(URB_FUNCTION_SET_FEATURE_TO_INTERFACE)
            MAKE_CASE(URB_FUNCTION_SET_FEATURE_TO_ENDPOINT)
            MAKE_CASE(URB_FUNCTION_SET_FEATURE_TO_OTHER)
            MAKE_CASE(URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE)
            MAKE_CASE(URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE)
            MAKE_CASE(URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT)
            MAKE_CASE(URB_FUNCTION_CLEAR_FEATURE_TO_OTHER)
            MAKE_CASE(URB_FUNCTION_GET_STATUS_FROM_DEVICE)
            MAKE_CASE(URB_FUNCTION_GET_STATUS_FROM_INTERFACE)
            MAKE_CASE(URB_FUNCTION_GET_STATUS_FROM_ENDPOINT)
            MAKE_CASE(URB_FUNCTION_GET_STATUS_FROM_OTHER)
            MAKE_CASE(URB_FUNCTION_RESERVED0)
            MAKE_CASE(URB_FUNCTION_VENDOR_DEVICE)
            MAKE_CASE(URB_FUNCTION_VENDOR_INTERFACE)
            MAKE_CASE(URB_FUNCTION_VENDOR_ENDPOINT)
            MAKE_CASE(URB_FUNCTION_VENDOR_OTHER)
            MAKE_CASE(URB_FUNCTION_CLASS_DEVICE)
            MAKE_CASE(URB_FUNCTION_CLASS_INTERFACE)
            MAKE_CASE(URB_FUNCTION_CLASS_ENDPOINT)
            MAKE_CASE(URB_FUNCTION_CLASS_OTHER)
            MAKE_CASE(URB_FUNCTION_RESERVED)
            MAKE_CASE(URB_FUNCTION_GET_CONFIGURATION)
            MAKE_CASE(URB_FUNCTION_GET_INTERFACE)

            default: urbName = NULL; break;
        }

        return urbName;
    }

    VOID DbgLogUrb(PURB urb)
    {
        if (dbgVerbose){
            PCHAR urbStr = DbgGetUrbName(urb->UrbHeader.Function);

            if (urbStr){
                DBGOUT(("  URB: %s (%ph)", urbStr, urb));
            }
            else {
                DBGOUT(("  URB: func=%xh (%ph)", (ULONG)urb->UrbHeader.Function, urb));
            }
        }

    }

	VOID DbgDumpBytes(PUCHAR msg, PVOID bufPtr, ULONG len)
	{
        PUCHAR buf = bufPtr;

        #define PRNT(ch) ((((ch) < ' ') || ((ch) > '~')) ? '.' : (ch))

		if (dbgVerbose){
			ULONG i;
			DbgPrint("%s (len %xh @ %p): \r\n", msg, len, buf);
			
			for (i = 0; i < len; i += 0x10){
                if (i && !(i & 0x007f)){
                    DbgPrint("\r\n");
                }
				DbgPrint("    ");

                if (len-i >= 16){
                    PUCHAR ptr = buf+i;
                    DbgPrint("%02x %02x %02x %02x %02x %02x %02x %02x  "
                             "%02x %02x %02x %02x %02x %02x %02x %02x "
                             "  "
                             "%c%c%c%c%c%c%c%c %c%c%c%c%c%c%c%c",
                             ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], 
                             ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15], 
                             PRNT(ptr[0]), PRNT(ptr[1]), PRNT(ptr[2]), PRNT(ptr[3]), 
                             PRNT(ptr[4]), PRNT(ptr[5]), PRNT(ptr[6]), PRNT(ptr[7]), 
                             PRNT(ptr[8]), PRNT(ptr[9]), PRNT(ptr[10]), PRNT(ptr[11]), 
                             PRNT(ptr[12]), PRNT(ptr[13]), PRNT(ptr[14]), PRNT(ptr[15])
                            );
                }
                else {
                    ULONG j;
				    for (j = 0; j < 16; j++){
                        if (j == 8) DbgPrint(" ");
					    if (i+j < len){
						    DbgPrint("%02x ", (ULONG)buf[i+j]);
					    }
					    else {
						    DbgPrint("   ");
					    }
				    }
				    DbgPrint("  ");
				    for (j = 0; j < 16; j++){
                        if (j == 8) DbgPrint(" ");
					    if (i+j < len){
						    UCHAR ch = buf[i+j];
						    DbgPrint("%c", PRNT(ch));
					    }
					    else {
						    // DbgPrint(" ");
					    }
				    }
                }

				DbgPrint("\r\n");
			}
		}
	}


    VOID DbgShowIsochProgress()
    {
        if (dbgShowIsochProgress){
            DbgPrint(".");
        }
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\inc\msosdesc.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    MSOSDESC.H

Abstract:

    Internal definitions for the MS OS Descriptors.  Public definitions
    are in USB.H.

Environment:

    Kernel & user mode

Revision History:

    05-01-01 : created

--*/

#ifndef   __MSOSDESC_H__
#define   __MSOSDESC_H__

#include <pshpack1.h>

//
// Definitions for internal MS OS Descriptor support
//

#define MS_EXT_CONFIG_DESCRIPTOR_INDEX      0x0004

#define MS_EXT_CONFIG_DESC_VER              0x0100

// Define header section returned for MS_EXT_CONFIG_DESCRIPTOR request.

typedef struct _MS_EXT_CONFIG_DESC_HEADER {
    ULONG   dwLength;           // Length of the entire descriptor
    USHORT  bcdVersion;         // Version level of this descriptor in BCD
    USHORT  wIndex;             // MS_EXT_CONFIG_DESCRIPTOR_INDEX
    UCHAR   bCount;             // Number of function sections that follow
    UCHAR   reserved[7];        // Number of function sections that follow
} MS_EXT_CONFIG_DESC_HEADER, *PMS_EXT_CONFIG_DESC_HEADER;

// Define function section returned for MS_EXT_CONFIG_DESCRIPTOR request.

typedef struct _MS_EXT_CONFIG_DESC_FUNCTION {
    UCHAR   bFirstInterfaceNumber;  // Starting Interface Number for this funct
    UCHAR   bInterfaceCount;        // Number of interfaces in this function
    UCHAR   CompatibleID[8];
    UCHAR   SubCompatibleID[8];
    UCHAR   reserved[6];
} MS_EXT_CONFIG_DESC_FUNCTION, *PMS_EXT_CONFIG_DESC_FUNCTION;

// This is the descriptor returned for a MS_EXT_CONFIG_DESCRIPTOR request.

typedef struct _MS_EXT_CONFIG_DESC {
    MS_EXT_CONFIG_DESC_HEADER   Header;
    MS_EXT_CONFIG_DESC_FUNCTION Function[1];  // Variable length array of these
} MS_EXT_CONFIG_DESC, *PMS_EXT_CONFIG_DESC;



#define MS_EXT_PROP_DESCRIPTOR_INDEX        0x0005

#define MS_EXT_PROP_DESC_VER                0x0100

typedef struct _MS_EXT_PROP_DESC_HEADER {
    ULONG   dwLength;           // Length of the entire descriptor
    USHORT  bcdVersion;         // Version level of this descriptor in BCD
    USHORT  wIndex;             // MS_EXT_PROP_DESCRIPTOR_INDEX
    USHORT  wCount;             // Number of custom property sections that follow
} MS_EXT_PROP_DESC_HEADER, *PMS_EXT_PROP_DESC_HEADER;

// The custom property section(s) are of variable length.

typedef struct _MS_EXT_PROP_DESC_CUSTOM_PROP {
    ULONG   dwSize;             // Size of this custom property section
    ULONG   dwPropertyDataType; // REG_SZ, etc.
    USHORT  wPropertyNameLength;// Length of key name
    WCHAR   PropertyName[1];
} MS_EXT_PROP_DESC_CUSTOM_PROP, *PMS_EXT_PROP_DESC_CUSTOM_PROP;

typedef struct _MS_EXT_PROP_DESC_CUSTOM_PROP_DATA {
    ULONG   dwPropertyDataLength;
    PVOID   PropertyData[1];
} MS_EXT_PROP_DESC_CUSTOM_PROP_DATA, *PMS_EXT_PROP_DESC_CUSTOM_PROP_DATA;

typedef struct _MS_EXT_PROP_DESC {
    MS_EXT_PROP_DESC_HEADER             Header;
    MS_EXT_PROP_DESC_CUSTOM_PROP_DATA   CustomSection[1];
} MS_EXT_PROP_DESC, *PMS_EXT_PROP_DESC;


#include <poppack.h>

#endif /* __MSOSDESC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\debug.h ===
/*
 *************************************************************************
 *  File:       DEBUG.H
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#ifdef _WIN64
#define BAD_POINTER ((PVOID)0xFFFFFFFFFFFFFF00)
#else
#define BAD_POINTER ((PVOID)0xFFFFFF00)
#endif

#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))

#if DBG

    #if WIN95_BUILD
        #define DBG_LEADCHAR ' '
    #else
        #define DBG_LEADCHAR '\''   // required for kd debugger routing on NT
    #endif

    extern BOOLEAN dbgTrapOnWarn;
    extern BOOLEAN dbgVerbose;
    extern BOOLEAN dbgShowIsochProgress;

    #define TRAP(msg)                                        \
        {                                               \
            DbgPrint("%cUSBCCGP> Code coverage trap: '%s' file %s, line %d \n",  DBG_LEADCHAR, (msg), __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #undef ASSERT
    #define ASSERT(fact)                                        \
        if (!(fact)){                                               \
            DbgPrint("%cUSBCCGP> Assertion '%s' failed: file %s, line %d \n",  DBG_LEADCHAR, #fact, __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("%cUSBCCGP> *** WARNING *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("%cUSBCCGP> *** ERROR *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("%cUSBCCGP> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
    #define DBGVERBOSE(args_in_parens)                                \
        if (dbgVerbose){                                               \
            DbgPrint("%cUSBCCGP> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }


    VOID DbgLogIrpMajor(ULONG_PTR irpPtr, ULONG majorFunc, ULONG isForParentFdo, ULONG isComplete, ULONG status);
    VOID DbgLogPnpIrp(ULONG_PTR irpPtr, ULONG minorFunc, ULONG isForParentFdo, ULONG isComplete, ULONG status);
    VOID DbgLogIoctl(ULONG ioControlCode, ULONG status);
    VOID DbgLogUrb(PURB urb);
    VOID DbgDumpBytes(PUCHAR msg, PVOID bufPtr, ULONG dataLen);
    PUCHAR DbgGetUrbName(ULONG urbFunc);
    VOID DbgShowIsochProgress();

    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isForParentFdo, isComplete, status) \
                DbgLogIrpMajor((ULONG_PTR)(irp), (ULONG)(majorFunc), (ULONG)(isForParentFdo), (ULONG)(isComplete), (ULONG)(status));
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isForParentFdo, isComplete, status) \
                DbgLogPnpIrp((ULONG_PTR)(irp), (ULONG)(minorFunc), (ULONG)(isForParentFdo), (ULONG)(isComplete), (ULONG)(status));
    #define DBG_LOG_IOCTL(ioControlCode, status) \
                DbgLogIoctl(ioControlCode, status)
    #define DBG_LOG_URB(urb) DbgLogUrb(urb)
    #define DBGDUMPBYTES(msg, data, dataLen) DbgDumpBytes(msg, data, dataLen)
    #define DBGSHOWISOCHPROGRESS() DbgShowIsochProgress()
#else
    #define DBGWARN(args_in_parens)                               
    #define DBGERR(args_in_parens)                               
    #define DBGOUT(args_in_parens)                               
    #define DBGVERBOSE(args_in_parens)                               
    #define TRAP(msg)

    #define DBG_LOG_IRP_MAJOR(irp, majorFunc, isForParentFdo, isComplete, status) 
    #define DBG_LOG_PNP_IRP(irp, minorFunc, isForParentFdo, isComplete, status) 
    #define DBG_LOG_IOCTL(ioControlCode, status)
    #define DBG_LOG_URB(urb)
    #define DBGDUMPBYTES(msg, data, dataLen)
    #define DBGSHOWISOCHPROGRESS()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\function.c ===
/*
 *************************************************************************
 *  File:       FUNCTION.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <stdio.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "security.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CreateStaticFunctionPDOs)
        #pragma alloc_text(PAGE, BuildCompatibleIDs)
        #pragma alloc_text(PAGE, QueryFunctionPdoID)
        #pragma alloc_text(PAGE, QueryFunctionDeviceRelations)
        #pragma alloc_text(PAGE, QueryFunctionCapabilities)
        #pragma alloc_text(PAGE, HandleFunctionPdoPower)
        #pragma alloc_text(PAGE, FreeFunctionPDOResources)
        #pragma alloc_text(PAGE, InstallExtPropDesc)
        #pragma alloc_text(PAGE, InstallExtPropDescSections)
#endif


/*
 *  CreateStaticFunctionPDOs
 *
 *
 *      Create a PDO for each function on the device.
 *      Treat each interface as a function (with exceptions for audio).
 */
NTSTATUS CreateStaticFunctionPDOs(PPARENT_FDO_EXT parentFdoExt)
{
    NTSTATUS status;
    PUSB_CONFIGURATION_DESCRIPTOR configDesc;
    ULONG numFuncIfaces;
    ULONG i;

    PAGED_CODE();

    configDesc = parentFdoExt->selectedConfigDesc;
    ASSERT(configDesc);
    ASSERT(configDesc->bNumInterfaces > 0);

    ASSERT(!parentFdoExt->deviceRelations);
    ASSERT(parentFdoExt->interfaceList);

    /*
     *  See if there is a Content Security Interface and if so initialize.
     *  (There should be at most one CS interface).
     */
    for (i = 0; i < configDesc->bNumInterfaces; i++){
        UCHAR ifaceClass = parentFdoExt->interfaceList[i].InterfaceDescriptor->bInterfaceClass;
        if (ifaceClass == USB_DEVICE_CLASS_CONTENT_SECURITY){
            ULONG ifaceNum = parentFdoExt->interfaceList[i].InterfaceDescriptor->bInterfaceNumber;
            DBGVERBOSE(("Found CS interface #%d.", ifaceNum));
            ASSERT(!parentFdoExt->haveCSInterface);
            InitCSInfo(parentFdoExt, ifaceNum);
            ASSERT(parentFdoExt->haveCSInterface);
        }
    }


    /*
     *  The configuration descriptor contains a series of interfaces,
     *  which are grouped into some number of "functions".
     *  Count the number of "function" interface groupings.
     */
    if (ISPTR(parentFdoExt->msExtConfigDesc))
    {
        parentFdoExt->numFunctions = parentFdoExt->msExtConfigDesc->Header.bCount;
    }
    else
    {
        for (i = 0; GetFunctionInterfaceListBase(parentFdoExt, i, &numFuncIfaces); i++);
        
        parentFdoExt->numFunctions = i;
    }

    ASSERT(parentFdoExt->numFunctions);

    DBGVERBOSE((" Device has %d interfaces and %d functions", (ULONG)configDesc->bNumInterfaces, parentFdoExt->numFunctions));

    /*
     *  Allocate a PDO for each function
     */
    parentFdoExt->deviceRelations =
        ALLOCPOOL(  NonPagedPool,
                    sizeof(DEVICE_RELATIONS) + (parentFdoExt->numFunctions *
                                                sizeof(PDEVICE_OBJECT)));
    if (parentFdoExt->deviceRelations){

        for (i = 0; i < parentFdoExt->numFunctions; i++){
            PDEVICE_OBJECT functionPdo = NULL;

            status = IoCreateDevice(parentFdoExt->driverObj,
                                    sizeof(DEVEXT),    // Device Extension size
                                    NULL, // device name
                                    FILE_DEVICE_UNKNOWN,
                                    FILE_AUTOGENERATED_DEVICE_NAME,// Device Chars
                                    FALSE,
                                    &functionPdo);
            if (NT_SUCCESS(status)){
                PDEVEXT devExt;
                PFUNCTION_PDO_EXT functionPdoExt;

                ASSERT(functionPdo);
                devExt = functionPdo->DeviceExtension;
                RtlZeroMemory(devExt, sizeof(DEVEXT));

                devExt->signature = USBCCGP_TAG;
                devExt->isParentFdo = FALSE;

                functionPdo->Flags |= DO_POWER_PAGABLE;

                functionPdoExt = &devExt->functionPdoExt;
                functionPdoExt->functionIndex = i;
                functionPdoExt->pdo = functionPdo;
                functionPdoExt->parentFdoExt = parentFdoExt;
                functionPdoExt->idleNotificationIrp = NULL;

                KeInitializeSpinLock(&functionPdoExt->functionPdoExtSpinLock);

                /*
                 *  The parent's config descriptor contains a list
                 *  of interface descriptors, sorted by function.
                 *  Get a pointer to the first interface descriptor
                 *  for this function.
                 */
                if (ISPTR(parentFdoExt->msExtConfigDesc))
                {
                    functionPdoExt->baseInterfaceNumber = 
                        parentFdoExt->msExtConfigDesc->Function[i].bFirstInterfaceNumber;

                    functionPdoExt->numInterfaces =
                        parentFdoExt->msExtConfigDesc->Function[i].bInterfaceCount;

                    functionPdoExt->functionInterfaceList =
                        &parentFdoExt->interfaceList[functionPdoExt->baseInterfaceNumber];
                }
                else
                {
                    functionPdoExt->functionInterfaceList = GetFunctionInterfaceListBase(parentFdoExt, i, &numFuncIfaces);
                    functionPdoExt->numInterfaces = numFuncIfaces;
                    ASSERT(functionPdoExt->functionInterfaceList);

                    functionPdoExt->baseInterfaceNumber = functionPdoExt->functionInterfaceList[0].InterfaceDescriptor->bInterfaceNumber;
                }

                /*
                 *  Create the device descriptor that clients see for this function.
                 *  This is the same as the parent's device descriptor except:
                 *      if the first interface of this function has an iInterface string
                 *      descriptor, then we substitute the parent device descriptor's iProduct
                 *      string with the iInterface string.  That way, the client's view of
                 *      the device will only represent the interfaces in that function.
                 */
                RtlCopyMemory(  &functionPdoExt->functionDeviceDesc,
                                &parentFdoExt->deviceDesc,
                                sizeof(USB_DEVICE_DESCRIPTOR));
                ASSERT(functionPdoExt->numInterfaces > 0);
                if (functionPdoExt->functionInterfaceList[0].InterfaceDescriptor->iInterface){
                    functionPdoExt->functionDeviceDesc.iProduct =
                        functionPdoExt->functionInterfaceList[0].InterfaceDescriptor->iInterface;
                }


                parentFdoExt->deviceRelations->Objects[i] = functionPdo;

                /*
                 *  We may pass IRPs from the function PDO to the
                 *  parent FDO.  Since we are not calling
                 *  IoAttachDeviceToDeviceStack to physically
                 *  attach this function PDO to a device stack,
                 *  we must set the "height" of this PDO ourselves,
                 *  so that any IRPs sent to this PDO have enough
                 *  IRP stack locations to go all the way down
                 *  the parent FDO's stack.
                 */
                functionPdo->StackSize = parentFdoExt->fdo->StackSize+1;

                DBGVERBOSE(("Created function PDO %p (#%d)", (ULONG_PTR)functionPdo, i));
            }
            else {
                break;
            }
        }

        if (i == parentFdoExt->numFunctions){
            parentFdoExt->deviceRelations->Count = parentFdoExt->numFunctions;
            status = STATUS_SUCCESS;
        }
        else {
            FREEPOOL(parentFdoExt->deviceRelations);
            parentFdoExt->deviceRelations = NULL;
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}


#define NibbleToHexW( byte ) (NibbleW[byte])
WCHAR NibbleW[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

typedef struct _CLASS_COMAPTIBLE_IDS
{
    // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
    //
    WCHAR   ClassStr1[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex1[2];
    WCHAR   SubClassStr1[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex1[2];
    WCHAR   Prot1[sizeof(L"&Prot_")/sizeof(WCHAR)-1];
    WCHAR   ProtHex1[2];
    WCHAR   Null1[1];

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr2[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex2[2];
    WCHAR   SubClassStr2[sizeof(L"&SubClass_")/sizeof(WCHAR)-1];
    WCHAR   SubClassHex2[2];
    WCHAR   Null2[1];

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    WCHAR   ClassStr3[sizeof(L"USB\\Class_")/sizeof(WCHAR)-1];
    WCHAR   ClassHex3[2];
    WCHAR   Null3[1];

    WCHAR   DoubleNull[1];

} CLASS_COMAPTIBLE_IDS, *PCLASS_COMAPTIBLE_IDS;

static CLASS_COMAPTIBLE_IDS ClassCompatibleIDs =
{
    // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {'&','P','r','o','t','_'},
    {'n','n'},
    {0},

    // L"USB\\Class_nn&SubClass_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {'&','S','u','b','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    // L"USB\\Class_nn\0"
    //
    {'U','S','B','\\','C','l','a','s','s','_'},
    {'n','n'},
    {0},

    {0}
};

PWCHAR
BuildCompatibleIDs(
    IN PUCHAR   CompatibleID,
    IN PUCHAR   SubCompatibleID,
    IN UCHAR    Class,
    IN UCHAR    SubClass,
    IN UCHAR    Protocol
    )
{
    ULONG                   ulTotal;
    PWCHAR                  pwch;
    PWCHAR                  pwchTmp;
    PCLASS_COMAPTIBLE_IDS   pClassIds;
    ULONG                   i;

    WCHAR   ClassHi     = NibbleToHexW((Class) >> 4);
    WCHAR   ClassLo     = NibbleToHexW((Class) & 0x0f);
    WCHAR   SubClassHi  = NibbleToHexW((SubClass) >> 4);
    WCHAR   SubClassLo  = NibbleToHexW((SubClass) & 0x0f);
    WCHAR   ProtocolHi  = NibbleToHexW((Protocol) >> 4);
    WCHAR   ProtocolLo  = NibbleToHexW((Protocol) & 0x0f);

    PAGED_CODE();

    ulTotal = sizeof(CLASS_COMAPTIBLE_IDS);

    if (SubCompatibleID && SubCompatibleID[0] != 0)
    {
        ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx&MS_SUBCOMP_xxxxxxxx");
    }

    if (CompatibleID && CompatibleID[0] != 0)
    {
        ulTotal += sizeof(L"USB\\MS_COMP_xxxxxxxx");
    }

    pwch = ALLOCPOOL(PagedPool, ulTotal);

    if (pwch)
    {
        pwchTmp = pwch;

        if (SubCompatibleID && SubCompatibleID[0] != 0)
        {
            RtlCopyMemory(pwchTmp,
                          L"USB\\MS_COMP_",
                          sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

            (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

            for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
            {
                *pwchTmp++ = (WCHAR)CompatibleID[i];
            }

            RtlCopyMemory(pwchTmp,
                          L"&MS_SUBCOMP_",
                          sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR));

            (PUCHAR)pwchTmp += sizeof(L"&MS_SUBCOMP_")-sizeof(WCHAR);

            for (i = 0; i < 8 && SubCompatibleID[i] != 0; i++)
            {
                *pwchTmp++ = (WCHAR)SubCompatibleID[i];
            }

            *pwchTmp++ = '\0';
        }

        if (CompatibleID && CompatibleID[0] != 0)
        {
            RtlCopyMemory(pwchTmp,
                          L"USB\\MS_COMP_",
                          sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR));

            (PUCHAR)pwchTmp += sizeof(L"USB\\MS_COMP_")-sizeof(WCHAR);

            for (i = 0; i < 8 && CompatibleID[i] != 0; i++)
            {
                *pwchTmp++ = (WCHAR)CompatibleID[i];
            }

            *pwchTmp++ = '\0';
        }

        pClassIds = (PCLASS_COMAPTIBLE_IDS)pwchTmp;

        // Copy over the constant set of strings:
        // L"USB\\Class_nn&SubClass_nn&Prot_nn\0"
        // L"USB\\Class_nn&SubClass_nn\0"
        // L"USB\\Class_nn\0"
        //
        RtlCopyMemory(pClassIds,
                      &ClassCompatibleIDs,
                      sizeof(CLASS_COMAPTIBLE_IDS));

        // Fill in the 'nn' blanks
        //
        pClassIds->ClassHex1[0] =
        pClassIds->ClassHex2[0] =
        pClassIds->ClassHex3[0] = ClassHi;

        pClassIds->ClassHex1[1] =
        pClassIds->ClassHex2[1] =
        pClassIds->ClassHex3[1] = ClassLo;

        pClassIds->SubClassHex1[0] =
        pClassIds->SubClassHex2[0] = SubClassHi;

        pClassIds->SubClassHex1[1] =
        pClassIds->SubClassHex2[1] = SubClassLo;

        pClassIds->ProtHex1[0] = ProtocolHi;

        pClassIds->ProtHex1[1] = ProtocolLo;
    }

    return pwch;
}


/*
 ********************************************************************************
 *  QueryFunctionPdoID
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS QueryFunctionPdoID(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION  irpSp;
    NTSTATUS            status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    switch (irpSp->Parameters.QueryId.IdType){

        case BusQueryHardwareIDs:

            /*
             *  Call down the parent FDO's stack to get a multi-string of hardware ids for the PDO.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallDriverSync(functionPdoExt->parentFdoExt->fdo, irp);
            if (NT_SUCCESS(status)){
                PWCHAR oldIDs, newIDs;

                /*
                 *  Append '&MI_xx' to each hardware id in the multi-string,
                 *  where 'xx' is the function number.
                 */
                oldIDs = (PWCHAR)irp->IoStatus.Information;
                irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                newIDs = AppendInterfaceNumber(oldIDs, functionPdoExt->baseInterfaceNumber);
                ExFreePool(oldIDs);

                if (newIDs){
                    irp->IoStatus.Information = (ULONG_PTR)newIDs;
                    status = STATUS_SUCCESS;
                }
                else {
                    irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                    status = STATUS_UNSUCCESSFUL;
                }
            }

            ASSERT(NT_SUCCESS(status));
            break;

        case BusQueryDeviceID:
            /*
             *  Call down the parent FDO's stack to get a the device id for the device's PDO.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallDriverSync(functionPdoExt->parentFdoExt->fdo, irp);
            if (NT_SUCCESS(status)){
                PWCHAR oldId, newId, tmpId;

                /*
                 *  Append '&MI_xx' to the device id,
                 *  where 'xx' is the function number.
                 */

                /*
                 *  First make this string into a multi-string.
                 */
                oldId = (PWCHAR)irp->IoStatus.Information;
                tmpId = ALLOCPOOL(PagedPool, (WStrLen(oldId)+2)*sizeof(WCHAR));
                if (tmpId){
                    ULONG len = WStrCpy(tmpId, oldId);

                    /*
                     *  Add the extra NULL to terminate the multi-string.
                     */
                    tmpId[len+1] = UNICODE_NULL;

                    /*
                     *  Append the function-number ending '&MI_xx' .
                     */
                    newId = AppendInterfaceNumber(tmpId, functionPdoExt->baseInterfaceNumber);
                    if (newId){
                        irp->IoStatus.Information = (ULONG_PTR)newId;
                    }
                    else {
                        status = STATUS_DEVICE_DATA_ERROR;
                        irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                    }

                    ExFreePool(tmpId);
                }
                else {
                    status = STATUS_DEVICE_DATA_ERROR;
                    irp->IoStatus.Information = (ULONG_PTR)BAD_POINTER;
                }
                ExFreePool(oldId);
            }

            ASSERT(NT_SUCCESS(status));
            break;

        case BusQueryInstanceID:

            /*
             *  Produce an instance-id for this function-PDO.
             *
             *  Note: NTKERN frees the returned pointer, so we must provide a fresh pointer.
             */
            {
                PWSTR instanceId = MemDup(L"0000", sizeof(L"0000"));
                if (instanceId){
                    swprintf(instanceId, L"%04x", functionPdoExt->baseInterfaceNumber);
                    irp->IoStatus.Information = (ULONG_PTR)instanceId;
                    status = STATUS_SUCCESS;
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            ASSERT(NT_SUCCESS(status));
            break;

        case BusQueryCompatibleIDs:
            {
                PUSB_INTERFACE_DESCRIPTOR ifaceDesc;
                PUCHAR  compatibleID;
                PUCHAR  subCompatibleID;

                /*
                 *  Build the MS Extended Compatible ID strings.
                 */

                if (ISPTR(functionPdoExt->parentFdoExt->msExtConfigDesc))
                {
                    PMS_EXT_CONFIG_DESC msExtConfigDesc;
                    ULONG               i;

                    msExtConfigDesc = functionPdoExt->parentFdoExt->msExtConfigDesc;

                    i = functionPdoExt->functionIndex;

                    ASSERT(i < msExtConfigDesc->Header.bCount);

                    compatibleID = msExtConfigDesc->Function[i].CompatibleID;
                    subCompatibleID = msExtConfigDesc->Function[i].SubCompatibleID;
                }
                else
                {
                    compatibleID = NULL;
                    subCompatibleID = NULL;
                }

                ifaceDesc = functionPdoExt->functionInterfaceList->InterfaceDescriptor;
                ASSERT(ifaceDesc);


                irp->IoStatus.Information = (ULONG_PTR)
                    BuildCompatibleIDs(compatibleID,
                                       subCompatibleID,
                                       ifaceDesc->bInterfaceClass,
                                       ifaceDesc->bInterfaceSubClass,
                                       ifaceDesc->bInterfaceProtocol);

                if (irp->IoStatus.Information)
                {
                    status = STATUS_SUCCESS;
                }
                else
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            break;

        default:
			/*
			 *  Do not return STATUS_NOT_SUPPORTED;
			 *  keep the default status
			 *  (this allows filter drivers to work).
			 */
            status = irp->IoStatus.Status;
            break;
    }

    return status;
}


/*
 ********************************************************************************
 *  QueryFunctionDeviceRelations
 ********************************************************************************
 *
 *
 */
NTSTATUS QueryFunctionDeviceRelations(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    if (irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation){
        /*
         *  Return a reference to this PDO
         */
        PDEVICE_RELATIONS devRel = ALLOCPOOL(PagedPool, sizeof(DEVICE_RELATIONS));
        if (devRel){
            /*
             *  Add a reference to the PDO, since CONFIGMG will free it.
             */
            ObReferenceObject(functionPdoExt->pdo);
            devRel->Objects[0] = functionPdoExt->pdo;
            devRel->Count = 1;
            irp->IoStatus.Information = (ULONG_PTR)devRel;
            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        /*
         *  Fail this Irp by returning the default
         *  status (typically STATUS_NOT_SUPPORTED).
         */
        status = irp->IoStatus.Status;
    }


    return status;
}



/*
 ********************************************************************************
 *  QueryFunctionCapabilities
 ********************************************************************************
 *
 *
 */
NTSTATUS QueryFunctionCapabilities(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    PDEVICE_CAPABILITIES deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;

    PAGED_CODE();

    /*
     *  Copy the parent device's capabilities,
     *  then set the flags we care about
     */
    ASSERT(deviceCapabilities);
    *deviceCapabilities = functionPdoExt->parentFdoExt->deviceCapabilities;
    deviceCapabilities->Removable = TRUE;
    deviceCapabilities->UniqueID = FALSE;
//  SurpriseRemovalOK is FALSE by default, and some clients (NDIS)
//  set it to true on the way down, in accordance with the DDK.
//  Also, some clients (USBSTOR) leave it as the default, FALSE, and
//  expect it to remain so.
//    deviceCapabilities->SurpriseRemovalOK = TRUE;
    deviceCapabilities->RawDeviceOK = FALSE;

    return STATUS_SUCCESS;
}


/*
 *  HandleFunctionPdoPower
 *
 *
 */
NTSTATUS HandleFunctionPdoPower(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    BOOLEAN queuedIrp = FALSE;
    BOOLEAN calledPoStartNextPowerIrp = FALSE;
    NTSTATUS status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:
            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    status = STATUS_SUCCESS;
                    break;

                case DevicePowerState:

                    // If the parent has been selectively suspended, then
                    // power it up now to service this request.

                    if (functionPdoExt->parentFdoExt->state == STATE_SUSPENDED ||
                        functionPdoExt->parentFdoExt->pendingIdleIrp) {

                        ParentSetD0(functionPdoExt->parentFdoExt);
                    }

                    ASSERT(functionPdoExt->parentFdoExt->state != STATE_SUSPENDED);

                    switch (irpSp->Parameters.Power.State.DeviceState){

                        case PowerDeviceD0:
                            if (functionPdoExt->state == STATE_SUSPENDED){
                                functionPdoExt->state = STATE_STARTED;
                            }
                            CompleteFunctionIdleNotification(functionPdoExt);
                            status = STATUS_SUCCESS;
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (functionPdoExt->state == STATE_STARTED){
                                functionPdoExt->state = STATE_SUSPENDED;
                            }
                            status = STATUS_SUCCESS;
                            break;

                        default:
                            /*
                             *  Return the default status.
                             */
                            status = irp->IoStatus.Status;
                            break;
                    }
                    break;

                default:
                    /*
                     *  Return the default status.
                     */
                    status = irp->IoStatus.Status;
                    break;
            }
            break;

        case IRP_MN_WAIT_WAKE:
            /*
             *  We queue all WW irps on function PDO's and issue
             *  just one irp down to the parent.
             */

            /*
             *  Call PoStartNextPowerIrp first since we can't
             *  touch the irp after queuing it.
             */
            PoStartNextPowerIrp(irp);
            calledPoStartNextPowerIrp = TRUE;

            status = EnqueueFunctionWaitWakeIrp(functionPdoExt, irp);
            if (status == STATUS_PENDING){
                queuedIrp = TRUE;
            }
            break;

        case IRP_MN_POWER_SEQUENCE:
            TRAP("IRP_MN_POWER_SEQUENCE (coverage trap)");
            status = irp->IoStatus.Status;
            break;

        case IRP_MN_QUERY_POWER:
            /*
             *  We allow all power transitions
             */
            status = STATUS_SUCCESS;
            break;

        default:
            /*
             *  Return the default status;
             */
            status = irp->IoStatus.Status;
            break;
    }

    if (!calledPoStartNextPowerIrp){
        PoStartNextPowerIrp(irp);
    }

    if (!queuedIrp){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}


/*
 *  BuildFunctionConfigurationDescriptor
 *
 *
 *      Note:  this function cannot be pageable because internal
 *             ioctls may be sent at IRQL==DISPATCH_LEVEL.
 */
NTSTATUS BuildFunctionConfigurationDescriptor(
                    PFUNCTION_PDO_EXT functionPdoExt,
                    PUCHAR buffer,
                    ULONG bufferLength,
                    PULONG bytesReturned)
{
    PUSB_CONFIGURATION_DESCRIPTOR parentConfigDesc;
    PUSB_CONFIGURATION_DESCRIPTOR functionConfigDesc;
    PUCHAR parentConfigDescEnd;
    PUSB_COMMON_DESCRIPTOR commonDesc;
    PUSB_INTERFACE_DESCRIPTOR thisIfaceDesc;
    PUCHAR scratch;
    ULONG totalLength;
    NTSTATUS status;
    ULONG i;

    // BUGBUG - change this to use the USBD ParseConfiguration function

    /*
     *  The function's configuration descriptor will include
     *  a subset of the interface descriptors in the parent's
     *  configuration descriptor.
     */
    parentConfigDesc = functionPdoExt->parentFdoExt->selectedConfigDesc;
    parentConfigDescEnd = (PUCHAR)((PUCHAR)parentConfigDesc + parentConfigDesc->wTotalLength);

    /*
     *  First calculate the total length of what we'll be copying.
     *  It will include a configuration descriptor followed by
     *  some number of interface descriptors.
     *  Each interface descriptor may be followed by a some number
     *  of class-specific descriptors.
     */
    totalLength = sizeof(USB_CONFIGURATION_DESCRIPTOR);
    for (i = 0; i < functionPdoExt->numInterfaces; i++) {

        /*
         *  We will copy the interface descriptor and all following
         *  descriptors until either the next interface
         *  descriptor or the end of the entire
         *  configuration descriptor.
         */
        thisIfaceDesc = functionPdoExt->functionInterfaceList[i].InterfaceDescriptor;
        ASSERT(thisIfaceDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE);
        commonDesc = (PUSB_COMMON_DESCRIPTOR)thisIfaceDesc;
        do {
            totalLength += commonDesc->bLength;
            commonDesc = (PUSB_COMMON_DESCRIPTOR)(((PUCHAR)commonDesc) + commonDesc->bLength);
        }
        while (((PUCHAR)commonDesc < parentConfigDescEnd) &&
               ((commonDesc->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE) ||
                (((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceNumber == thisIfaceDesc->bInterfaceNumber)));
    }

    scratch = ALLOCPOOL(NonPagedPool, totalLength);
    if (scratch){
        PUCHAR pch;

        pch = scratch;

        RtlCopyMemory(pch, parentConfigDesc, sizeof(USB_CONFIGURATION_DESCRIPTOR));
        pch += sizeof(USB_CONFIGURATION_DESCRIPTOR);

        for (i = 0; i < functionPdoExt->numInterfaces; i++) {

            /*
             *  Copy the interface descriptor and all following
             *  descriptors until either the next interface
             *  descriptor or the end of the entire
             *  configuration descriptor.
             */
            thisIfaceDesc = functionPdoExt->functionInterfaceList[i].InterfaceDescriptor;
            ASSERT(thisIfaceDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE);
            commonDesc = (PUSB_COMMON_DESCRIPTOR)thisIfaceDesc;
            do {
                RtlCopyMemory(pch, commonDesc, commonDesc->bLength);
                pch += commonDesc->bLength;
                commonDesc = (PUSB_COMMON_DESCRIPTOR)(((PUCHAR)commonDesc) + commonDesc->bLength);
            }
            while (((PUCHAR)commonDesc < parentConfigDescEnd) &&
                   ((commonDesc->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE) ||
                    (((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceNumber == thisIfaceDesc->bInterfaceNumber)));

        }

        /*
         *  This 'function' child's config descriptor contains
         *  a subset of the parent's interface descriptors.
         *  Update the child's configuration descriptor's size
         *  to reflect the possibly-reduced number of interface descriptors.
         */
        functionConfigDesc = (PUSB_CONFIGURATION_DESCRIPTOR)scratch;
        functionConfigDesc->bNumInterfaces = (UCHAR)functionPdoExt->numInterfaces;
        functionConfigDesc->wTotalLength = (USHORT)totalLength;

        /*
         *  Copy as much of the config descriptor as will fit in the caller's buffer.
         *  Return success whether or not the caller's buffer was actually big enough (BUGBUG ? - this is what usbhub did).
         */
        *bytesReturned = MIN(bufferLength, totalLength);
        RtlCopyMemory(buffer, scratch, *bytesReturned);

        DBGDUMPBYTES("BuildFunctionConfigurationDescriptor built config desc for function", buffer, *bytesReturned);

        FREEPOOL(scratch);

        status = STATUS_SUCCESS;
    }
    else {
        ASSERT(scratch);
        status = STATUS_INSUFFICIENT_RESOURCES;
        *bytesReturned = 0;
    }

    return status;
}



#if DBG
    /*
     *  FunctionIoctlCompletion
     *
     *      Monitor URB completion status for DEBUG ONLY.
     */
    NTSTATUS FunctionIoctlCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
    {
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
        ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
        NTSTATUS status = irp->IoStatus.Status;
        PURB urb;
        PUCHAR urbFuncName;

        switch (ioControlCode){
            case IOCTL_INTERNAL_USB_SUBMIT_URB:
                urb = irpSp->Parameters.Others.Argument1;
                urbFuncName = DbgGetUrbName(urb->UrbHeader.Function);
                if (!urbFuncName) urbFuncName = "???";
                if (((status != STATUS_SUCCESS) && (status != STATUS_CANCELLED)) ||
                    !USBD_SUCCESS(urb->UrbHeader.Status)){
                    DBGVERBOSE(("FunctionIoctlCompletion: %s (%xh) returned ntstatus %xh, urbstatus %xh.", urbFuncName, urb->UrbHeader.Function, status, urb->UrbHeader.Status));
                    DBG_LOG_URB(urb);
                    DBGVERBOSE(("<>"));
                }
                break;
            default:
                if (status != STATUS_SUCCESS){
                    DBGWARN(("FunctionIoctlCompletion: ioctl %xh returned %xh.", ioControlCode, status));
                }
                break;
        }

        /*
         *  Must propagate the pending bit if a lower driver returned pending.
         */
        if (irp->PendingReturned){
            IoMarkIrpPending(irp);
        }

        return status;
    }
#endif


VOID FunctionIdleNotificationCancelRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    PDEVEXT devExt;
    PFUNCTION_PDO_EXT functionPdoExt;
    PPARENT_FDO_EXT parentFdoExt;
    KIRQL oldIrql;
    PIRP parentIdleIrpToCancel = NULL;

    DBGVERBOSE(("Idle notification IRP %x cancelled", Irp));

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    devExt = DeviceObject->DeviceExtension;
    functionPdoExt = &devExt->functionPdoExt;
    parentFdoExt = functionPdoExt->parentFdoExt;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    ASSERT(Irp == functionPdoExt->idleNotificationIrp);
    functionPdoExt->idleNotificationIrp = NULL;

    /*
     *  One of the functions on this composite device no longer wants
     *  the device to be idled.  So we can no longer allow the parent
     *  device to be idle.  Cancel it after we drop the spinlock.
     */
    if (parentFdoExt->pendingIdleIrp){
        parentIdleIrpToCancel = parentFdoExt->pendingIdleIrp;
        parentFdoExt->pendingIdleIrp = NULL;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (parentIdleIrpToCancel){
        IoCancelIrp(parentIdleIrpToCancel);
    }

    // Also, power up the parent here before we complete this Idle IRP.
    //
    // (HID will start to send requests immediately upon its completion,
    // which may be before the parent's Idle IRP cancel routine is called
    // which powers up the parent.)

    if (parentFdoExt->state == STATE_SUSPENDED ||
        parentFdoExt->pendingIdleIrp) {

        ParentSetD0(parentFdoExt);
    }

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}



VOID CompleteFunctionIdleNotification(PFUNCTION_PDO_EXT functionPdoExt)
{
    PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
    NTSTATUS status;
    KIRQL oldIrql;
    PIRP irp;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    if (functionPdoExt->idleNotificationIrp){
        PDRIVER_CANCEL oldCancelRoutine;

        irp = functionPdoExt->idleNotificationIrp;

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == FunctionIdleNotificationCancelRoutine);
            functionPdoExt->idleNotificationIrp = NULL;
        }
        else {
            /*
             *  The irp was cancelled AND the cancel routine was called.
             *  The cancel routine will complete this irp, so don't complete
             *  it here.
             */
            ASSERT(irp->Cancel);
            irp = NULL;
        }
    }
    else {
        irp = NULL;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (irp) {
        DBGVERBOSE(("Completing idle request IRP %x", irp));
        irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


/*
 *  FunctionIdleNotificationRequest
 *
 *
 *      This function handles a request by a USB client driver to tell us
 *      that the device wants to idle (selective suspend).
 *
 *
 */
NTSTATUS FunctionIdleNotificationRequest(PFUNCTION_PDO_EXT functionPdoExt, PIRP Irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    NTSTATUS ntStatus = STATUS_PENDING;

    DBGVERBOSE(("Idle request %x, IRP %x", functionPdoExt, Irp));

    idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    if (idleCallbackInfo && idleCallbackInfo->IdleCallback){
        PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
        BOOLEAN doCheckParentIdle = FALSE;
        KIRQL oldIrql;

        KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

        if (functionPdoExt->idleNotificationIrp){
            DBGVERBOSE(("Idle request: already have idle IRP"));
            ntStatus = STATUS_DEVICE_BUSY;
        }
        else {
            PDRIVER_CANCEL oldCancelRoutine;

            functionPdoExt->idleNotificationIrp = Irp;

            /*
             *  Must set cancel routine before checking Cancel flag
             */
            oldCancelRoutine = IoSetCancelRoutine(Irp, FunctionIdleNotificationCancelRoutine);
            ASSERT(!oldCancelRoutine);

            if (Irp->Cancel){
                /*
                 *  Irp was cancelled. Check whether cancel routine was called.
                 */
                oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
                if (oldCancelRoutine){
                    /*
                     *  Cancel routine was NOT called. So complete the irp here.
                     */
                    functionPdoExt->idleNotificationIrp = NULL;
                    ntStatus = STATUS_CANCELLED;
                }
                else {
                    /*
                     *  Cancel routine was called, and it will complete the IRP
                     *  as soon as we drop the spinlock.
                     *  Return STATUS_PENDING so we don't touch the IRP.
                     */
                    IoMarkIrpPending(Irp);
                    ntStatus = STATUS_PENDING;
                }
            }
            else {
                doCheckParentIdle = TRUE;
            }
        }

        KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

        if (doCheckParentIdle){
            /*
             *  See if we are ready to idle out this hub (after dropping spinlock).
             */
            CheckParentIdle(parentFdoExt);
        }
    }
    else {
        DBGVERBOSE(("Idle request: No callback provided with idle IRP!"));
        ntStatus = STATUS_NO_CALLBACK_ACTIVE;
    }

    return ntStatus;
}


/*
 *  FunctionInternalDeviceControl
 *
 *
 *      Note:  this function cannot be pageable because internal
 *             ioctls may be sent at IRQL==DISPATCH_LEVEL.
 */
NTSTATUS FunctionInternalDeviceControl(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    PURB urb;
    USHORT urbFunc;
    NTSTATUS status = NO_STATUS;

    switch (ioControlCode){

        case IOCTL_INTERNAL_USB_SUBMIT_URB:

            urb = irpSp->Parameters.Others.Argument1;
            ASSERT(urb);
            DBG_LOG_URB(urb);

            urbFunc = urb->UrbHeader.Function;

            if (functionPdoExt->state != STATE_STARTED){
                DBGWARN(("FunctionInternalDeviceControl: failing urb (func %xh) because child pdo state is %xh.", urbFunc, functionPdoExt->state));
                status = STATUS_DEVICE_NOT_READY;
            }
            else if (functionPdoExt->parentFdoExt->state != STATE_STARTED){
                DBGERR(("FunctionInternalDeviceControl: BAD PNP state! - child is started while parent has state %xh.", functionPdoExt->parentFdoExt->state));
                status = STATUS_DEVICE_NOT_READY;
            }
            else {

                switch (urbFunc){

                    case URB_FUNCTION_SELECT_CONFIGURATION:
                        status = UrbFunctionSelectConfiguration(functionPdoExt, urb);
                        irp->IoStatus.Information = 0;
                        break;

                    case URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE:
                        status = UrbFunctionGetDescriptorFromDevice(functionPdoExt, urb);
                        break;

                    case URB_FUNCTION_SELECT_INTERFACE:
                        /*
                         *  Pass this URB down to the parent
                         */
                        ASSERT(urb->UrbSelectInterface.ConfigurationHandle);
                        break;

                    case URB_FUNCTION_ISOCH_TRANSFER:
                        /*
                         *  Pass this URB down to the parent
                         */
                        DBGSHOWISOCHPROGRESS();
                        break;

                    case URB_FUNCTION_ABORT_PIPE:
                    case URB_FUNCTION_RESET_PIPE:
                        /*
                         *  Pass ABORT and RESET URBs down to the parent.
                         */
                        DBGVERBOSE((DbgGetUrbName(urbFunc)));
                        break;

                    case URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE:
                    case URB_FUNCTION_CLASS_INTERFACE:
                    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
                    default:
                        /*
                         *  Pass unsupported URBs down to the parent
                         */
                        DBGVERBOSE(("URB function %xh not implemented - passing to parent", (ULONG)urbFunc));
                        break;
                }
            }

            /*
             *  Set the URB status
             */
            switch (status){
                case NO_STATUS:                                                         break;
                case STATUS_PENDING:    urb->UrbHeader.Status = USBD_STATUS_PENDING;    break;
                case STATUS_SUCCESS:    urb->UrbHeader.Status = USBD_STATUS_SUCCESS;    break;
                default:                urb->UrbHeader.Status = USBD_STATUS_ERROR;      break;
            }

            break;

        case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:
            status = FunctionIdleNotificationRequest(functionPdoExt, irp);
            break;

        case IOCTL_INTERNAL_USB_GET_BUS_INFO:
        case IOCTL_INTERNAL_USB_GET_PORT_STATUS:
            /*
             *  Leave the status as NO_STATUS so that these IRPs get passed down to the parent.
             */
            break;

        case IOCTL_INTERNAL_USB_RESET_PORT:
        case IOCTL_INTERNAL_USB_CYCLE_PORT:
            /*
             *  Pass RESET and CYCLE IRPs down to the parent.
             *  ParentInternalDeviceControl will synchronize
             *  multiple abort/resets on the parent device.
             */
            DBGWARN(("RESET or CYCLE PORT -- pass down to parent"));
            break;

        case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
            TRAP("IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO - shouldn't get this");
            status = STATUS_NOT_IMPLEMENTED;
            break;

        default:
            /*
             *  This is not a pnp/power/syscntrl irp, so we fail unsupported irps
             *  with an actual error code (not with the default status).
             */
            status = STATUS_NOT_SUPPORTED;
            break;
    }

    if (status == NO_STATUS){
        /*
         *  We didn't handle this IRP, so send it down to our own parent FDO.
         */
        IoCopyCurrentIrpStackLocationToNext(irp);
        #if DBG
            IoSetCompletionRoutine(irp, FunctionIoctlCompletion, functionPdoExt, TRUE, TRUE, TRUE);
        #endif
        status = IoCallDriver(functionPdoExt->parentFdoExt->fdo, irp);
    }
    else if (status != STATUS_PENDING){
        /*
         *  We serviced this IRP, so complete it.
         */
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}


VOID FreeFunctionPDOResources(PFUNCTION_PDO_EXT functionPdoExt)
{
    PAGED_CODE();

    DBGVERBOSE(("Removing function PDO %xh (#%d)", functionPdoExt->pdo, functionPdoExt->functionIndex));

    /*
     *  functionInterfaceList points inside
     *  the parent's interface list, so don't free it here.
     */

    IoDeleteDevice(functionPdoExt->pdo);
}


PFUNCTION_PDO_EXT FindFunctionByIndex(PPARENT_FDO_EXT parentFdoExt, ULONG functionIndex)
{
    PFUNCTION_PDO_EXT functionPdoExt = NULL;
    KIRQL oldIrql;
    ULONG i;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    ASSERT(parentFdoExt->deviceRelations);
    for (i = 0; i < parentFdoExt->deviceRelations->Count; i++){
        PDEVICE_OBJECT devObj = parentFdoExt->deviceRelations->Objects[i];
        PDEVEXT devExt;
        PFUNCTION_PDO_EXT thisFuncPdoExt;

        ASSERT(devObj);
        devExt = devObj->DeviceExtension;
        ASSERT(devExt);
        ASSERT(devExt->signature == USBCCGP_TAG);
        ASSERT(!devExt->isParentFdo);
        thisFuncPdoExt = &devExt->functionPdoExt;

        if (thisFuncPdoExt->functionIndex == functionIndex){
            functionPdoExt = thisFuncPdoExt;
            break;
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    return functionPdoExt;
}


/*
 ********************************************************************************
 *  EnqueueFunctionWaitWakeIrp
 ********************************************************************************
 *
 *  Enqueue the function's WaitWake IRP in the PARENT's queue.
 *  If no WaitWake IRP is pending on the parent, send one down.
 */
NTSTATUS EnqueueFunctionWaitWakeIrp(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
    PDRIVER_CANCEL oldCancelRoutine;
    BOOLEAN submitParentWWirp = FALSE;
    KIRQL oldIrql;
    NTSTATUS status;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    /*
     *  Must set a cancel routine before checking the Cancel flag
     *  (this makes the cancel code path for the IRP have to contend
     *  for our local spinlock).
     */
    oldCancelRoutine = IoSetCancelRoutine(irp, FunctionWaitWakeIrpCancelRoutine);
    ASSERT(!oldCancelRoutine);

    if (irp->Cancel){
        /*
         *  This IRP has already been cancelled.
         */
        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            /*
             *  Cancel routine was NOT called, so complete the IRP here
             *  (caller will do this when we return error).
             */
            ASSERT(oldCancelRoutine == FunctionWaitWakeIrpCancelRoutine);
            status = STATUS_CANCELLED;
        }
        else {
            /*
             *  Cancel routine was called, and it will dequeue and complete the IRP
             *  as soon as we drop the spinlock.
             *  Initialize the IRP's listEntry so the dequeue doesn't corrupt the list.
             *  Then return STATUS_PENDING so we don't touch the IRP
             */
            InitializeListHead(&irp->Tail.Overlay.ListEntry);

            IoMarkIrpPending(irp);
            status = STATUS_PENDING;
        }
    }
    else {
        /*
         *  Enqueue this WW irp in the parent's queue.
         */
        InsertTailList(&parentFdoExt->functionWaitWakeIrpQueue, &irp->Tail.Overlay.ListEntry);

        /*
         *  IoMarkIrpPending sets a bit in the current stack location
         *  to indicate that the Irp may complete on a different thread.
         */
        IoMarkIrpPending(irp);

        /*
         *  If a WW irp is not pending on the parent,
         *  then submit one after we drop the spinlock.
         */
        if (!parentFdoExt->isWaitWakePending){
            submitParentWWirp = TRUE;
            parentFdoExt->isWaitWakePending = TRUE;
        }

        status = STATUS_PENDING;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (submitParentWWirp){
        SubmitParentWaitWakeIrp(parentFdoExt);
    }

    return status;
}


/*
 ********************************************************************************
 *  FunctionWaitWakeIrpCancelRoutine
 ********************************************************************************
 *
 */
VOID FunctionWaitWakeIrpCancelRoutine(IN PDEVICE_OBJECT deviceObject, IN PIRP irp)
{
    PDEVEXT devExt = (PDEVEXT)deviceObject->DeviceExtension;
    PFUNCTION_PDO_EXT functionPdoExt;
    PPARENT_FDO_EXT parentFdoExt;
    PIRP parentWaitWakeIrpToCancel = NULL;
    KIRQL oldIrql;

    ASSERT(devExt->signature == USBCCGP_TAG);
    ASSERT(!devExt->isParentFdo);
    functionPdoExt = &devExt->functionPdoExt;
    parentFdoExt = functionPdoExt->parentFdoExt;


    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    /*
     *  Dequeue the client's WaitWake IRP.
     */
    RemoveEntryList(&irp->Tail.Overlay.ListEntry);

    /*
     *  If the last function WaitWake IRP just got cancelled,
     *  cancel the parent's WaitWake IRP as well.
     */
    if (IsListEmpty(&parentFdoExt->functionWaitWakeIrpQueue) &&
        parentFdoExt->isWaitWakePending){

        ASSERT(parentFdoExt->parentWaitWakeIrp);
        parentWaitWakeIrpToCancel = parentFdoExt->parentWaitWakeIrp;
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    IoReleaseCancelSpinLock(irp->CancelIrql);

    irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(irp, IO_NO_INCREMENT);

    if (parentWaitWakeIrpToCancel){
        // BUGBUG - slight race - what if parent WW irp completes just before this ?
        //          (we can't block in the completion routine, so there may not be a fix for this)
        IoCancelIrp(parentWaitWakeIrpToCancel);
    }
}


/*
 *  CompleteAllFunctionWaitWakeIrps
 *
 *      Complete all WaitWake irps in the parent's queue
 *      with the given status.
 */
VOID CompleteAllFunctionWaitWakeIrps(PPARENT_FDO_EXT parentFdoExt, NTSTATUS status)
{
    LIST_ENTRY irpsToComplete;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;
    PIRP irp;

    /*
     *  Complete all the irps in the parent's WW irp list.
     *  The irps can get resubmitted on the same thread that we
     *  complete them on; so in order to avoid an infinite loop,
     *  empty the list into a private queue first, then complete
     *  the irps out of the private queue.
     */
    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    while (!IsListEmpty(&parentFdoExt->functionWaitWakeIrpQueue)){
        PDRIVER_CANCEL oldCancelRoutine;

        listEntry = RemoveHeadList(&parentFdoExt->functionWaitWakeIrpQueue);
        InitializeListHead(listEntry);  // in case cancel routine tries to dequeue again

        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
        if (oldCancelRoutine){
            ASSERT(oldCancelRoutine == FunctionWaitWakeIrpCancelRoutine);

            /*
             *  We can't complete an IRP while holding a spinlock.
             *  Also, we don't want to complete a WaitWake IRP while
             *  still processing queue because a driver
             *  may resend an IRP on the same thread, causing us to loop forever.
             *  So just move the IRPs to a private queue and we'll complete them later.
             */
            InsertTailList(&irpsToComplete, listEntry);
        }
        else {
            /*
             *  This IRP was cancelled and the cancel routine WAS called.
             *  The cancel routine will complete the IRP as soon as we drop the spinlock.
             *  So don't touch the IRP.
             */
            ASSERT(irp->Cancel);
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    while (!IsListEmpty(&irpsToComplete)){
        listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

}


/*
 *  CompleteAllFunctionIdleIrps
 *
 *      Complete all child function PDO Idle IRPs for the given parent
 *      with the given status.
 */
VOID CompleteAllFunctionIdleIrps(PPARENT_FDO_EXT parentFdoExt, NTSTATUS status)
{
    LIST_ENTRY irpsToComplete;
    KIRQL oldIrql;
    PIRP irp;
    ULONG i;

    DBGVERBOSE(("Complete all child Idle IRPs for parent %x", parentFdoExt));

    InitializeListHead(&irpsToComplete);

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    ASSERT(parentFdoExt->deviceRelations);

    for (i = 0; i < parentFdoExt->deviceRelations->Count; i++) {
        PDEVICE_OBJECT devObj = parentFdoExt->deviceRelations->Objects[i];
        PDEVEXT devExt;
        PFUNCTION_PDO_EXT thisFuncPdoExt;

        ASSERT(devObj);
        devExt = devObj->DeviceExtension;
        ASSERT(devExt);
        ASSERT(devExt->signature == USBCCGP_TAG);
        ASSERT(!devExt->isParentFdo);
        thisFuncPdoExt = &devExt->functionPdoExt;

        irp = thisFuncPdoExt->idleNotificationIrp;

        // complete the Idle IRP if we have one.
        if (irp){
            PDRIVER_CANCEL oldCancelRoutine;

            oldCancelRoutine = IoSetCancelRoutine(irp, NULL);
            if (oldCancelRoutine){
                ASSERT(oldCancelRoutine == FunctionIdleNotificationCancelRoutine);
                InsertTailList(&irpsToComplete, &irp->Tail.Overlay.ListEntry);
                thisFuncPdoExt->idleNotificationIrp = NULL;
            }
            else {
                /*
                 *  The IRP was cancelled and the cancel routine was called.
                 *  The cancel routine will dequeue and complete the irp, 
                 *  so don't do it here.
                 */
                ASSERT(irp->Cancel);
            }
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    while (!IsListEmpty(&irpsToComplete)){
        PLIST_ENTRY listEntry;
        listEntry = RemoveHeadList(&irpsToComplete);
        irp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


/*
 ********************************************************************************
 *  InstallExtPropDesc
 ********************************************************************************
 *
 *
 */
VOID
InstallExtPropDesc (
    IN PFUNCTION_PDO_EXT FunctionPdoExt
    )
/*++

Routine Description:

    This routines queries a device for an Extended Properties Descriptor, but
    only once the very first time for a given instance of a device.

    If the Extended Properties Descriptor and all of the Custom Property
    Sections appear valid then each Custom Property section <ValueName,
    ValueData> pair is installed in the device instance specific registry key
    for the PDO.

    The registry value entries would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    FunctionPdoExt - The Function PDO Device Extension

Return Value:

    None

--*/
{
    PDEVICE_OBJECT          deviceObject;
    static WCHAR            DidExtPropDescKey[] = L"ExtPropDescSemaphore";
    ULONG                   didExtPropDesc;
    MS_EXT_PROP_DESC_HEADER msExtPropDescHeader;
    PMS_EXT_PROP_DESC       pMsExtPropDesc;
    ULONG                   bytesReturned;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceObject = FunctionPdoExt->pdo;

    // Check if the semaphore value is already set in the registry.  We only
    // care whether or not it already exists, not what data it has.
    //
    ntStatus = GetPdoRegistryParameter(deviceObject,
                                       DidExtPropDescKey,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL);
    
    if (NT_SUCCESS(ntStatus))
    {
        // Already did this once for this device instance.  Don't do it again.
        //
        return;
    }

    // Set the semaphore key in the registry so that we only run the following
    // code once per device.

    didExtPropDesc = 1;

    SetPdoRegistryParameter(deviceObject,
                            DidExtPropDescKey,
                            &didExtPropDesc,
                            sizeof(didExtPropDesc),
                            REG_DWORD,
                            PLUGPLAY_REGKEY_DEVICE);


    RtlZeroMemory(&msExtPropDescHeader, sizeof(MS_EXT_PROP_DESC_HEADER));

    // Request just the header of the MS Extended Property Descriptor 
    //
    ntStatus = GetMsOsFeatureDescriptor(
                   FunctionPdoExt->parentFdoExt,
                   1,   // Recipient Interface
                   (UCHAR)FunctionPdoExt->baseInterfaceNumber,
                   MS_EXT_PROP_DESCRIPTOR_INDEX,
                   &msExtPropDescHeader,
                   sizeof(MS_EXT_PROP_DESC_HEADER),
                   &bytesReturned);

    // Make sure the MS Extended Property Descriptor header looks ok
    //
    if (NT_SUCCESS(ntStatus) &&
        bytesReturned == sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.dwLength >= sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.bcdVersion == MS_EXT_PROP_DESC_VER &&
        msExtPropDescHeader.wIndex == MS_EXT_PROP_DESCRIPTOR_INDEX &&
        msExtPropDescHeader.wCount > 0)
    {
        // Allocate a buffer large enough for the entire descriptor
        //
        pMsExtPropDesc = ALLOCPOOL(NonPagedPool,
                                   msExtPropDescHeader.dwLength);

        
        if (pMsExtPropDesc)
        {
            RtlZeroMemory(pMsExtPropDesc, msExtPropDescHeader.dwLength);

            // Request the entire MS Extended Property Descriptor
            //
            ntStatus = GetMsOsFeatureDescriptor(
                           FunctionPdoExt->parentFdoExt,
                           1,   // Recipient Interface
                           (UCHAR)FunctionPdoExt->baseInterfaceNumber,
                           MS_EXT_PROP_DESCRIPTOR_INDEX,
                           pMsExtPropDesc,
                           msExtPropDescHeader.dwLength,
                           &bytesReturned);

            if (NT_SUCCESS(ntStatus) &&
                bytesReturned == msExtPropDescHeader.dwLength &&
                RtlCompareMemory(&msExtPropDescHeader,
                                 pMsExtPropDesc,
                                 sizeof(MS_EXT_PROP_DESC_HEADER)) ==
                sizeof(MS_EXT_PROP_DESC_HEADER))
            {
                // MS Extended Property Descriptor retrieved ok, parse and
                // install each Custom Property Section it contains.
                //
                InstallExtPropDescSections(deviceObject,
                                           pMsExtPropDesc);
            }

            // Done with the MS Extended Property Descriptor buffer, free it
            //
            FREEPOOL(pMsExtPropDesc);
        }
    }
}

/*
 ********************************************************************************
 *  InstallExtPropDescSections
 ********************************************************************************
 *
 *
 */
VOID
InstallExtPropDescSections (
    PDEVICE_OBJECT      DeviceObject,
    PMS_EXT_PROP_DESC   pMsExtPropDesc
    )
/*++

Routine Description:

    This routines parses an Extended Properties Descriptor and validates each
    Custom Property Section contained in the Extended Properties Descriptor.

    If all of the Custom Property Sections appear valid then each Custom
    Property section <ValueName, ValueData> pair is installed in the device
    instance specific registry key for the PDO.

    The registry value entries would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    DeviceObject - The PDO

    pMsExtPropDesc - Pointer to an Extended Properties Descriptor buffer.
                     It is assumed that the header of this descriptor has
                     already been validated.

Return Value:

    None

--*/
{
    PUCHAR  p;
    PUCHAR  end;
    ULONG   pass;
    ULONG   i;

    ULONG   dwSize;
    ULONG   dwPropertyDataType;
    USHORT  wPropertyNameLength;
    PWCHAR  bPropertyName;
    ULONG   dwPropertyDataLength;
    PVOID   bPropertyData;

    NTSTATUS    ntStatus;

    PAGED_CODE();

    // Get a pointer to the end of the entire Extended Properties Descriptor
    //
    end = (PUCHAR)pMsExtPropDesc + pMsExtPropDesc->Header.dwLength;

    // First pass:  Validate each Custom Property Section
    // Second pass: Install  each Custom Property Section (if first pass ok)
    //
    for (pass = 0; pass < 2; pass++)
    {
        // Get a pointer to the first Custom Property Section
        //
        p = (PUCHAR)&pMsExtPropDesc->CustomSection[0];

        // Iterate over all of the Custom Property Sections
        //
        for (i = 0; i < pMsExtPropDesc->Header.wCount; i++)
        {
            ULONG   offset;

            // Make sure the dwSize field is in bounds 
            //
            if (p + sizeof(ULONG) > end)
            {
                break;
            }

            // Extract the dwSize field and advance running offset
            //
            dwSize = *((PULONG)p);

            offset = sizeof(ULONG);

            // Make sure the entire structure is in bounds
            //
            if (p + dwSize > end)
            {
                break;
            }

            // Make sure the dwPropertyDataType field is in bounds

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

            // Extract the dwPropertyDataType field and advance running offset
            //
            dwPropertyDataType = *((PULONG)(p + offset));

            offset += sizeof(ULONG);

            // Make sure the wPropertyNameLength field is in bounds
            //
            if (dwSize < offset + sizeof(USHORT))
            {
                break;
            }

            // Extract the wPropertyNameLength field and advance running offset
            //
            wPropertyNameLength = *((PUSHORT)(p + offset));

            offset += sizeof(USHORT);

            // Make sure the bPropertyName field is in bounds
            //
            if (dwSize < offset + wPropertyNameLength)
            {
                break;
            }

            // Set the bPropertyName pointer and advance running offset
            //
            bPropertyName = (PWCHAR)(p + offset);

            offset += wPropertyNameLength;

            // Make sure the dwPropertyDataLength field is in bounds

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

            // Extract the dwPropertyDataLength field and advance running offset
            //
            dwPropertyDataLength = *((ULONG UNALIGNED*)(p + offset));

            offset += sizeof(ULONG);

            // Make sure the bPropertyData field is in bounds
            //
            if (dwSize < offset + dwPropertyDataLength)
            {
                break;
            }

            // Set the bPropertyData pointer and advance running offset
            //
            bPropertyData = p + offset;

            offset += wPropertyNameLength;


            // Make sure the dwPropertyDataType is valid
            //
            if (dwPropertyDataType < REG_SZ ||
                dwPropertyDataType > REG_MULTI_SZ)
            {
                break;
            }

            // Make sure the wPropertyNameLength is valid
            //
            if (wPropertyNameLength == 0 ||
                (wPropertyNameLength % sizeof(WCHAR)) != 0)
            {
                break;
            }

            // Make sure bPropertyName is NULL terminated
            //
            if (bPropertyName[(wPropertyNameLength / sizeof(WCHAR)) - 1] !=
                UNICODE_NULL)
            {
                break;
            }

            // Everything looks ok, 
            //
            if (pass > 0)
            {
                ntStatus = SetPdoRegistryParameter(
                               DeviceObject,
                               bPropertyName,
                               bPropertyData,
                               dwPropertyDataLength,
                               dwPropertyDataType,
                               PLUGPLAY_REGKEY_DEVICE);
            }
        }     
        
        // Skip the second pass if we bailed out of the first pass
        //
        if (i < pMsExtPropDesc->Header.wCount)
        {
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\pnp.c ===
/*
 *************************************************************************
 *  File:       PNP.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */


#include <wdm.h>
#include <stdio.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>
#include <wdmguid.h>

#include "usbccgp.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, USBC_PnP)
        #pragma alloc_text(PAGE, GetDeviceText)

#endif


NTSTATUS USBC_PnP(PDEVEXT devExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    UCHAR minorFunction;
    BOOLEAN isParentFdo;
    enum deviceState oldState;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    minorFunction = irpSp->MinorFunction;
    isParentFdo = devExt->isParentFdo;

    DBG_LOG_PNP_IRP(irp, minorFunction, isParentFdo, FALSE, 0);

    if (isParentFdo){
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
        BOOLEAN irpAlreadyCompleted = FALSE;
        status = NO_STATUS;

        if (parentFdoExt->state == STATE_SUSPENDED ||
            parentFdoExt->pendingIdleIrp) {

            ParentSetD0(parentFdoExt);
        }

        switch (minorFunction){

            case IRP_MN_START_DEVICE:
                status = StartParentFdo(parentFdoExt, irp);
                break;

            case IRP_MN_QUERY_STOP_DEVICE:
                if (parentFdoExt->state == STATE_SUSPENDED){
                    status = STATUS_DEVICE_POWER_FAILURE;
                }
                else {
                    /*
                     *  We will pass this IRP down the driver stack.
                     *  However, we need to change the default status
                     *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
                     */
                    irp->IoStatus.Status = STATUS_SUCCESS;
                }
                break;

            case IRP_MN_STOP_DEVICE:
                if (parentFdoExt->state == STATE_SUSPENDED){
                    DBGERR(("Got STOP while device suspended"));
                    status = STATUS_DEVICE_POWER_FAILURE;
                }
                else {
                    /*
                     *  Only set state to STOPPED if the device was
                     *  previously started successfully.
                     */
                    if (parentFdoExt->state == STATE_STARTED){
                        parentFdoExt->state = STATE_STOPPING;
                        ParentCloseConfiguration(parentFdoExt);
                    }
                    else {
                        DBGWARN(("Got STOP while in state is %xh.", parentFdoExt->state));
                    }
                }
                break;
          
            case IRP_MN_QUERY_REMOVE_DEVICE:
                /*
                 *  We will pass this IRP down the driver stack.
                 *  However, we need to change the default status
                 *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
                 */
                irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            case IRP_MN_REMOVE_DEVICE:

                /*
                 *  Cancel downward IO
                 *  Set default status to SUCCESS
                 *  Send the IRP down
                 *  Detach
                 *  Cleanup
                 */
                PrepareParentFDOForRemove(parentFdoExt);

                irp->IoStatus.Status = STATUS_SUCCESS;
                IoSkipCurrentIrpStackLocation(irp);
                status = IoCallDriver(parentFdoExt->topDevObj, irp);
                irpAlreadyCompleted = TRUE;

                IoDetachDevice(parentFdoExt->topDevObj);

                FreeParentFDOResources(parentFdoExt);

                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                status = QueryParentDeviceRelations(parentFdoExt, irp);
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                /*
                 *  Return the USB PDO's capabilities, but add the SurpriseRemovalOK bit.
                 */
                ASSERT(irpSp->Parameters.DeviceCapabilities.Capabilities);
                IoCopyCurrentIrpStackLocationToNext(irp);
                status = CallDriverSync(parentFdoExt->topDevObj, irp);
                if (NT_SUCCESS(status)){
	                irpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
                }
                break;

        }

        if (status == NO_STATUS){
            IoCopyCurrentIrpStackLocationToNext(irp);
            IoSetCompletionRoutine(irp, USBC_PnpComplete, (PVOID)devExt, TRUE, TRUE, TRUE);
            status = IoCallDriver(parentFdoExt->topDevObj, irp);
        }
        else if (irpAlreadyCompleted){
            /*
             *  Don't touch the irp.
             */
        }
        else if (status != STATUS_PENDING){
            /*
             *  Complete the IRP here
             */
            irp->IoStatus.Status = status;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
        }
    }
    else {
        /*
         *  This is a child function PDO.
         */
        PFUNCTION_PDO_EXT functionPdoExt = &devExt->functionPdoExt;
        
        switch (minorFunction){

            case IRP_MN_START_DEVICE:
                functionPdoExt->state = STATE_STARTED;
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_STOP_DEVICE:
            case IRP_MN_CANCEL_STOP_DEVICE:
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_STOP_DEVICE:
                /*
                 *  Only set state to STOPPED if the device was
                 *  previously started successfully.
                 */
                if (functionPdoExt->state == STATE_STARTED){
                    functionPdoExt->state = STATE_STOPPED;
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_REMOVE_DEVICE:
            case IRP_MN_CANCEL_REMOVE_DEVICE:
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_REMOVE_DEVICE:
                /*
                 *  Since we are the bus driver for the function-PDOs, we cannot
                 *  delete the function pdo on a remove-device.  We must wait
                 *  for the parent to get the remove before deleting the function pdo.
                 */
				oldState = functionPdoExt->state;
                functionPdoExt->state = STATE_REMOVED;
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_ID:
                status = QueryFunctionPdoID(functionPdoExt, irp);
                break;

            case IRP_MN_QUERY_DEVICE_RELATIONS:
                status = QueryFunctionDeviceRelations(functionPdoExt, irp);
                break;

            case IRP_MN_QUERY_CAPABILITIES:
                status = QueryFunctionCapabilities(functionPdoExt, irp);
                break;

            case IRP_MN_QUERY_PNP_DEVICE_STATE:
                irp->IoStatus.Information = 0;
                switch (functionPdoExt->state){
                    case STATE_START_FAILED:
                            irp->IoStatus.Information |= PNP_DEVICE_FAILED;
                            break;
                    case STATE_STOPPED:
                            irp->IoStatus.Information |= PNP_DEVICE_DISABLED;
                            break;
                    case STATE_REMOVING:
                    case STATE_REMOVED:
                            irp->IoStatus.Information |= PNP_DEVICE_REMOVED;
                            break;
                }
                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                // Adrian says that once PnP sends this IRP, the PDO is valid for
                // PnP functions like IoGetDeviceProperty, etc.
                //
                // And since we know that the PDO is valid and the DevNode now exists,
                // this would also be a good time to handle the MS ExtPropDesc.
                //
                InstallExtPropDesc(functionPdoExt);

                status = STATUS_SUCCESS;
                break;

            case IRP_MN_QUERY_BUS_INFORMATION:
                {
                    PPNP_BUS_INFORMATION busInfo = ALLOCPOOL(PagedPool, sizeof(PNP_BUS_INFORMATION));
                    if (busInfo) {
                        busInfo->BusTypeGuid = GUID_BUS_TYPE_USB;
                        busInfo->LegacyBusType = PNPBus;
                        busInfo->BusNumber = 0;
                        irp->IoStatus.Information = (ULONG_PTR)busInfo;
                        status = STATUS_SUCCESS;
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                break;

            case IRP_MN_QUERY_DEVICE_TEXT:
                status = GetDeviceText(functionPdoExt, irp);
                break;

            case IRP_MN_QUERY_INTERFACE:
                /*
                 *  Send this down to the parent.
                 */
                IoCopyCurrentIrpStackLocationToNext(irp);
                status = CallDriverSync(functionPdoExt->parentFdoExt->fdo, irp);
                break;

            default:
                /*
                 *  Complete the IRP with the default status.
                 */
                status = irp->IoStatus.Status;
                break;
        }

        /*
         *  Complete the IRP here
         */
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    DBG_LOG_PNP_IRP(irp, minorFunction, isParentFdo, TRUE, status);

    return status;
}


NTSTATUS USBC_PnpComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    PDEVEXT devExt = (PDEVEXT)context;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    NTSTATUS status = irp->IoStatus.Status;
        
    ASSERT(devExt->signature == USBCCGP_TAG);

    if (devExt->isParentFdo){
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;

        switch (irpSp->MinorFunction){

            case IRP_MN_START_DEVICE:
                ASSERT(0);
                break;

            case IRP_MN_STOP_DEVICE:
                /*
                 *  Only set the state to STOPPED if the device
                 *  was previously successfully started;
                 *  otherwise, leave the state alone.
                 */
                if (parentFdoExt->state == STATE_STOPPING){

                    /*
                     *  Free the interface list's .Interface pointers, 
                     *  which we have to re-allocate on a start-after-stop.
                     */
                    FreeInterfaceList(parentFdoExt, FALSE);

                    parentFdoExt->state = STATE_STOPPED;
                }
                break;
        }

    }

    /*
     *  Must propagate the pending bit if a lower driver returned pending.
     */
    if (irp->PendingReturned){
        IoMarkIrpPending(irp);
    }

    return STATUS_SUCCESS;
}



/*
 ********************************************************************************
 *  GetDeviceText
 ********************************************************************************
 *
 *  If the interface descriptor for this function has a non-zero iInterface
 *  string, return that string.  Otherwise, pass this request off to the
 *  parent, which will return the iProduct string from the device descriptor.
 *
 */
NTSTATUS GetDeviceText(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp)
{
    NTSTATUS status;
    UCHAR ifaceStringIndex;
    ULONG ulBytes = 0;

    PAGED_CODE();

    ifaceStringIndex = functionPdoExt->functionInterfaceList[0].InterfaceDescriptor->iInterface;
    if (ifaceStringIndex){
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
        PUSB_STRING_DESCRIPTOR ifaceStringDesc;
        PWCHAR deviceText;

        switch (irpSp->Parameters.QueryDeviceText.DeviceTextType){

            case DeviceTextDescription:
                ifaceStringDesc = ALLOCPOOL(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);
                if (ifaceStringDesc){
                    LANGID langId = (LANGID)(irpSp->Parameters.QueryDeviceText.LocaleId >> 16);

                    if (langId == 0){
                        /*
                         *  Force to English.
                         */
                        langId = 0x0409;
                    }

QDT_Retry:
                    status = GetStringDescriptor(   functionPdoExt->parentFdoExt,
                                                    ifaceStringIndex,
                                                    langId,
                                                    ifaceStringDesc,
                                                    MAXIMUM_USB_STRING_LENGTH);

                    if (NT_SUCCESS(status) &&
                        ifaceStringDesc->bLength == 0) {

                        status = STATUS_UNSUCCESSFUL;
                    }

                    if (NT_SUCCESS(status)){
                        ULONG numWchars = (ifaceStringDesc->bLength - 2*sizeof(UCHAR))/sizeof(WCHAR);

                        deviceText = ALLOCPOOL(PagedPool, (numWchars+1)*sizeof(WCHAR));
                        if (deviceText){
                            RtlZeroMemory(deviceText, (numWchars+1)*sizeof(WCHAR));
                            RtlCopyMemory(deviceText, ifaceStringDesc->bString, numWchars*sizeof(WCHAR));
                            irp->IoStatus.Information = (ULONG_PTR)deviceText;
                        }
                        else {
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    } else if (langId != 0x409) {
                        // We are running a non-English flavor of the OS, but the
                        // attached USB device does not contain device text in
                        // the requested language.  Let's try again for English.

                        langId = 0x0409;
                        goto QDT_Retry;
                    }

                    FREEPOOL(ifaceStringDesc);
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (!NT_SUCCESS(status) && GenericCompositeUSBDeviceString) {
                    // Return generic English string if one could not be
                    // obtained from the device.

                    STRLEN(ulBytes, GenericCompositeUSBDeviceString);

                    ulBytes += sizeof(UNICODE_NULL);

                    deviceText = ALLOCPOOL(PagedPool, ulBytes);
                    if (deviceText) {
                        RtlZeroMemory(deviceText, ulBytes);
                        RtlCopyMemory(deviceText,
                                      GenericCompositeUSBDeviceString,
                                      ulBytes);
                        irp->IoStatus.Information = (ULONG_PTR) deviceText;
                        status = STATUS_SUCCESS;
                    } else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                break;

            case DeviceTextLocationInformation:
                /*
                 *  BUGBUG
                 *  Supporting this call to return phys port # is optional.
                 *
                 *  We may be able to service it with
                 *  a call to IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO
	             *  (Pass a PULONG in Argument2, this will be filled in with the port #.).
                 */
                status = irp->IoStatus.Status;
                break;

            default:
                DBGWARN(("GetDeviceText: unhandled DeviceTextType %xh.", (ULONG)irpSp->Parameters.QueryDeviceText.DeviceTextType));
                status = irp->IoStatus.Status;
                break;
        }
    }
    else {
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = CallNextDriverSync(functionPdoExt->parentFdoExt, irp);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\dispatch.c ===
/*
 *************************************************************************
 *  File:       DISPATCH.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#include <ksdrmhlp.h>
#endif
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, USBC_Create)
        #pragma alloc_text(PAGE, USBC_DeviceControl)
        #pragma alloc_text(PAGE, USBC_SystemControl)
        #pragma alloc_text(PAGE, USBC_Power)
#ifdef DRM_SUPPORT
        #pragma alloc_text(PAGE, USBC_SetContentId)
#endif
#endif


/*
 *  USBC_Dispatch
 *
 *      Note:  this function cannot be pageable because reads can
 *             come in at DISPATCH level.
 */
NTSTATUS USBC_Dispatch(IN PDEVICE_OBJECT devObj, IN PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    PDEVEXT devExt;
    PPARENT_FDO_EXT parentFdoExt;
    PFUNCTION_PDO_EXT functionPdoExt;
    ULONG majorFunction, minorFunction;
    BOOLEAN isParentFdo;
    NTSTATUS status;
    BOOLEAN abortIrp = FALSE;

    devExt = devObj->DeviceExtension;
    ASSERT(devExt);
    ASSERT(devExt->signature == USBCCGP_TAG);

    irpSp = IoGetCurrentIrpStackLocation(irp);

    /*
     *  Keep these privately so we still have it after the IRP completes
     *  or after the device extension is freed on a REMOVE_DEVICE
     */
    majorFunction = irpSp->MajorFunction;
    minorFunction = irpSp->MinorFunction;
    isParentFdo = devExt->isParentFdo;

    DBG_LOG_IRP_MAJOR(irp, majorFunction, isParentFdo, FALSE, 0);

    if (isParentFdo){
        parentFdoExt = &devExt->parentFdoExt;
        functionPdoExt = BAD_POINTER;
    }
    else {
        functionPdoExt = &devExt->functionPdoExt;
        parentFdoExt = functionPdoExt->parentFdoExt;
    }

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunction == IRP_MJ_PNP) && (minorFunction == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(parentFdoExt);
    }


    /*
     *  Make sure we don't process any IRPs besides PNP and CLOSE
     *  while a device object is getting removed.
     *  Do this after we've incremented the pendingActionCount for this IRP.
     */
    if ((majorFunction != IRP_MJ_PNP) && (majorFunction != IRP_MJ_CLOSE)){
        enum deviceState state = (isParentFdo) ? parentFdoExt->state : functionPdoExt->state;
        if (!isParentFdo && majorFunction == IRP_MJ_POWER) {
            /*
             *  Don't abort power IRP's on child function PDO's, even if
             *  state is STATE_REMOVING or STATE_REMOVED as this will veto
             *  a suspend request if the child function PDO is disabled.
             */
            ;
        } else if ((state == STATE_REMOVING) || (state == STATE_REMOVED)){
            abortIrp = TRUE;
        }
    }

    if (abortIrp){
        /*
         *  Fail all irps after a remove irp.
         *  This should never happen except:
         *  we can get a power irp on a function pdo after a remove
         *  because (per splante) the power state machine is not synchronized
         *  with the pnp state machine.  We now handle this case above.
         */
        DBGWARN(("Aborting IRP %ph (function %xh/%xh) because delete pending", irp, majorFunction, minorFunction));
        ASSERT((majorFunction == IRP_MJ_POWER) && !isParentFdo);
        status = irp->IoStatus.Status = STATUS_DELETE_PENDING;
        if (majorFunction == IRP_MJ_POWER){
            PoStartNextPowerIrp(irp);
        }
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        switch (majorFunction){

            case IRP_MJ_CREATE:
                status = USBC_Create(devExt, irp);
                break;

            case IRP_MJ_CLOSE:
                status = USBC_Close(devExt, irp);
                break;

            case IRP_MJ_DEVICE_CONTROL:
                status = USBC_DeviceControl(devExt, irp);
                break;

            case IRP_MJ_SYSTEM_CONTROL:
                status = USBC_SystemControl(devExt, irp);
                break;

            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
                status = USBC_InternalDeviceControl(devExt, irp);
                break;

            case IRP_MJ_PNP:
                status = USBC_PnP(devExt, irp);
                break;

            case IRP_MJ_POWER:
                status = USBC_Power(devExt, irp);
                break;

            default:
                DBGERR(("USBC_Dispatch: unsupported irp majorFunction %xh.", majorFunction));
                if (isParentFdo){
                    /*
                     *  Pass this IRP to the parent device.
                     */
                    IoSkipCurrentIrpStackLocation(irp);
                    status = IoCallDriver(parentFdoExt->topDevObj, irp);
                }
                else {
                    /*
                     *  This is not a pnp/power/syscntrl irp, so we fail unsupported irps
                     *  with an actual error code (not with the default status).
                     */
                    status = irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
                    IoCompleteRequest(irp, IO_NO_INCREMENT);
                }
                break;
        }
    }


    DBG_LOG_IRP_MAJOR(irp, majorFunction, isParentFdo, TRUE, status);

    /*
     *  Balance the increment above
     */
    if (!((majorFunction == IRP_MJ_PNP) && (minorFunction == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(parentFdoExt);
    }

    return status;
}


NTSTATUS USBC_Create(PDEVEXT devExt, PIRP irp)
{
    NTSTATUS status;

    PAGED_CODE();

    if (devExt->isParentFdo){
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
        IoSkipCurrentIrpStackLocation(irp);
        status = IoCallDriver(parentFdoExt->topDevObj, irp);
    }
    else {
        /*
         *  This is not a pnp/power/syscntrl irp, so we fail unsupported irps
         *  with an actual error code (not with the default status).
         */
        status = irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}

NTSTATUS USBC_Close(PDEVEXT devExt, PIRP irp)
{
    NTSTATUS status;

    if (devExt->isParentFdo){
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
        IoSkipCurrentIrpStackLocation(irp);
        status = IoCallDriver(parentFdoExt->topDevObj, irp);
    }
    else {
        /*
         *  This is not a pnp/power/syscntrl irp, so we fail unsupported irps
         *  with an actual error code (not with the default status).
         */
        status = irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}


#ifdef DRM_SUPPORT

/*****************************************************************************
 * USBC_SetContentId
 *****************************************************************************
 *
 */
NTSTATUS
USBC_SetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
{
    ULONG ContentId;
    PIO_STACK_LOCATION iostack;
    PDEVEXT devExt;
    USBD_PIPE_HANDLE hPipe;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    iostack = IoGetCurrentIrpStackLocation(irp);
    devExt = iostack->DeviceObject->DeviceExtension;
    hPipe = pKsProperty->Context;
    ContentId = pvData->ContentId;

    if (devExt->isParentFdo){
        // IOCTL sent to parent FDO.  Forward to down the stack.
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
        status = pKsProperty->DrmForwardContentToDeviceObject(ContentId, parentFdoExt->topDevObj, hPipe);
    }
    else {
        // IOCTL send to function PDO.  Forward to parent FDO on other stack.
        PFUNCTION_PDO_EXT functionPdoExt = &devExt->functionPdoExt;
        PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
        status = pKsProperty->DrmForwardContentToDeviceObject(ContentId, parentFdoExt->fdo, hPipe);
    }

    return status;
}

#endif


NTSTATUS USBC_DeviceControl(PDEVEXT devExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status;

    PAGED_CODE();

#ifdef DRM_SUPPORT

    if (IOCTL_KS_PROPERTY == ioControlCode) {
        status = KsPropertyHandleDrmSetContentId(irp, USBC_SetContentId);
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    } else {
#endif
        if (devExt->isParentFdo){
            PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
            status = ParentDeviceControl(parentFdoExt, irp);
        }
        else {
            /*
             *  Pass the IOCTL IRP sent to our child PDO to our own parent FDO.
             */
            PFUNCTION_PDO_EXT functionPdoExt = &devExt->functionPdoExt;
            PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = IoCallDriver(parentFdoExt->fdo, irp);
        }
#ifdef DRM_SUPPORT
    }
#endif

    DBG_LOG_IOCTL(ioControlCode, status);

    return status;
}

NTSTATUS USBC_SystemControl(PDEVEXT devExt, PIRP irp)
{
    NTSTATUS status;

    PAGED_CODE();

    if (devExt->isParentFdo){
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
        IoSkipCurrentIrpStackLocation(irp);
        status = IoCallDriver(parentFdoExt->topDevObj, irp);
    }
    else {
        /*
         *  Pass the IOCTL IRP sent to our child PDO to our own parent FDO.
         */
        PFUNCTION_PDO_EXT functionPdoExt = &devExt->functionPdoExt;
        PPARENT_FDO_EXT parentFdoExt = functionPdoExt->parentFdoExt;
        IoCopyCurrentIrpStackLocationToNext(irp);
        status = IoCallDriver(parentFdoExt->fdo, irp);
    }

    return status;
}


/*
 *  USBC_InternalDeviceControl
 *
 *
 *      Note:  this function cannot be pageable because internal
 *             ioctls may be sent at IRQL==DISPATCH_LEVEL.
 */
NTSTATUS USBC_InternalDeviceControl(PDEVEXT devExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status;

    if (devExt->isParentFdo){
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
        status = ParentInternalDeviceControl(parentFdoExt, irp);
    }
    else {
        PFUNCTION_PDO_EXT functionPdoExt = &devExt->functionPdoExt;
        status = FunctionInternalDeviceControl(functionPdoExt, irp);
    }

    DBG_LOG_IOCTL(ioControlCode, status);

    return status;
}


NTSTATUS USBC_Power(PDEVEXT devExt, PIRP irp)
{
    NTSTATUS status;

    PAGED_CODE();

    if (devExt->isParentFdo){
        PPARENT_FDO_EXT parentFdoExt = &devExt->parentFdoExt;
        status = HandleParentFdoPower(parentFdoExt, irp);
    }
    else {
        PFUNCTION_PDO_EXT functionPdoExt = &devExt->functionPdoExt;
        status = HandleFunctionPdoPower(functionPdoExt, irp);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\security.c ===
/*
 *************************************************************************
 *  File:       SECURITY.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "security.h"
#include "debug.h"







NTSTATUS GetUniqueIdFromCSInterface(PPARENT_FDO_EXT parentFdoExt, PMEDIA_SERIAL_NUMBER_DATA serialNumData, ULONG serialNumLen)
{
	PUCHAR uniqueIdBuf;
	NTSTATUS status;
    ULONG bufLen = 0;

	// BUGBUG - check CSM#

    /*
     *  Need to allocate a locked buffer for the call to USB.
     */
	uniqueIdBuf = ALLOCPOOL(NonPagedPool, CSM1_GET_UNIQUE_ID_LENGTH);
	if (uniqueIdBuf){
        URB urb = { 0 };

        urb.UrbHeader.Length = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
        urb.UrbHeader.Function = URB_FUNCTION_CLASS_INTERFACE;
        urb.UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_IN;
        urb.UrbControlVendorClassRequest.TransferBufferLength = CSM1_GET_UNIQUE_ID_LENGTH;
        urb.UrbControlVendorClassRequest.TransferBuffer = uniqueIdBuf;
        urb.UrbControlVendorClassRequest.Request = CSM1_REQUEST_GET_UNIQUE_ID;
        urb.UrbControlVendorClassRequest.Value = 0;
        urb.UrbControlVendorClassRequest.Index = (USHORT)(parentFdoExt->CSInterfaceNumber | (parentFdoExt->CSChannelId << 8));

        status = SubmitUrb(parentFdoExt, &urb, TRUE, NULL, NULL);
        if (NT_SUCCESS(status)){

            bufLen = urb.UrbControlVendorClassRequest.TransferBufferLength;
            ASSERT(bufLen <= CSM1_GET_UNIQUE_ID_LENGTH);
            ASSERT(serialNumLen > 0);
            bufLen = MIN(bufLen, CSM1_GET_UNIQUE_ID_LENGTH);
            bufLen = MIN(bufLen, serialNumLen);

            RtlCopyMemory(serialNumData->SerialNumberData, uniqueIdBuf, bufLen);

            DBGDUMPBYTES("GetUniqueIdFromCSInterface - unique id:", serialNumData->SerialNumberData, bufLen);
		}
        else {
            DBGERR(("CSM1_REQUEST_GET_UNIQUE_ID failed with %xh.", status));
        }

        FREEPOOL(uniqueIdBuf);
	}
    else {
        DBGERR(("couldn't allocate unique id buf"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    serialNumData->SerialNumberLength = bufLen;
    serialNumData->Result = status;

    return status;
}


NTSTATUS GetMediaSerialNumber(PPARENT_FDO_EXT parentFdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    PMEDIA_SERIAL_NUMBER_DATA serialNumData;
    NTSTATUS status;
    ULONG serialNumLen;

    DBGVERBOSE(("*** IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER ***"));

    /*
     *  IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER is a METHOD_BUFFERED irp.
     *  So the kernel allocated a systemBuffer for us IF the app passed
     *  in a non-zero buffer size.  So we don't need to probe the buffer
     *  itself, but we do need to:
     *      1.  verify that the buffer was indeed allocated
     *      2.  that it is large enough
     *
     *  The buffer is a var-size struct; be careful to not dereference any
     *  field until it is verified that the struct is longer than the offset
     *  of that field.
     *  Note that serialNumData->SerialNumberLength is the alleged size
     *  of the serialNumData->SerialNumberData array, not of the entire structure.
     */
    serialNumData = irp->AssociatedIrp.SystemBuffer;
    if (serialNumData &&
        (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(MEDIA_SERIAL_NUMBER_DATA))) {

        // Serial number buffer length is the size of the output buffer minus
        // the size of the MEDIA_SERIAL_NUMBER_DATA structure.

        serialNumLen = irpSp->Parameters.DeviceIoControl.OutputBufferLength -
                       sizeof(MEDIA_SERIAL_NUMBER_DATA);

        status = GetUniqueIdFromCSInterface(parentFdoExt, serialNumData, serialNumLen);
        irp->IoStatus.Information = FIELD_OFFSET(MEDIA_SERIAL_NUMBER_DATA, SerialNumberData) +
                                    serialNumData->SerialNumberLength;
    }
    else {
        DBGERR(("Bad buffer with IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER, irp=%ph.", irp));
        status = STATUS_INVALID_BUFFER_SIZE;
    }

    return status;
}


/*
 *  GetChannelDescForInterface
 *
 *      BUGBUG - INCOMPLETE
 *      We don't support multiple channel descriptors yet.
 *      Eventually we'll need to return a channel id
 *      for a particular protected interface/endpoint.
 */
CS_CHANNEL_DESCRIPTOR *GetChannelDescForInterface(PPARENT_FDO_EXT parentFdoExt, ULONG interfaceNum)
{
    PUSB_INTERFACE_DESCRIPTOR interfaceDesc;
    CS_CHANNEL_DESCRIPTOR *channelDesc = NULL;
    CS_METHOD_AND_VARIANT *methodAndVar;

    interfaceDesc = USBD_ParseConfigurationDescriptorEx(
                        parentFdoExt->configDesc,
                        parentFdoExt->configDesc,
                        -1,
                        0,  // BUGBUG - allow alternate CS interfaces ?
                        USB_DEVICE_CLASS_CONTENT_SECURITY,
                        -1,
                        -1);
    if (interfaceDesc){
        PUSB_COMMON_DESCRIPTOR commonDesc = (PUSB_COMMON_DESCRIPTOR)interfaceDesc;

        while (POINTER_DISTANCE(commonDesc, parentFdoExt->configDesc) < parentFdoExt->configDesc->wTotalLength){
            if (commonDesc->bDescriptorType == CS_DESCRIPTOR_TYPE_CHANNEL){
                channelDesc = (CS_CHANNEL_DESCRIPTOR *)commonDesc;
                break;
            }
            (PUCHAR)commonDesc += commonDesc->bLength;
        }
    }

    if (channelDesc){
        /*
         *  Make sure that this channel descriptor supports CSM1,
         *  which is all we support right now.
         *  BUGBUG
         */
        BOOLEAN foundSupportedCSM = FALSE;

        for (methodAndVar = channelDesc->methodAndVariant;
             POINTER_DISTANCE(methodAndVar, channelDesc) < channelDesc->bLength;
             methodAndVar++){

            if (methodAndVar->bMethod == CSM_BASIC){
                foundSupportedCSM = TRUE;
                break;
            }
        }

         if (!foundSupportedCSM){
             DBGERR(("Did not find supported CSM !"));
             channelDesc = NULL;
         }
    }

    ASSERT(channelDesc);
    return channelDesc;
}


VOID InitCSInfo(PPARENT_FDO_EXT parentFdoExt, ULONG CSIfaceNumber)
{
	CS_CHANNEL_DESCRIPTOR *channelDesc;

    channelDesc = GetChannelDescForInterface(parentFdoExt, 0); // BUGBUG iface# not used because only support one channel desc
    if (channelDesc){
        parentFdoExt->CSChannelId = channelDesc->bChannelID;
        parentFdoExt->CSInterfaceNumber = CSIfaceNumber;
        parentFdoExt->haveCSInterface = TRUE;
    }
    else {
        ASSERT(channelDesc);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\parent.c ===
/*
 *************************************************************************
 *  File:       PARENT.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>
#include <ntddstor.h>

#include "usbccgp.h"
#include "security.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, GetInterfaceList)
        #pragma alloc_text(PAGE, GetConfigDescriptor)
        #pragma alloc_text(PAGE, TryGetConfigDescriptor)
        #pragma alloc_text(PAGE, GetDeviceDescriptor)
        #pragma alloc_text(PAGE, GetParentFdoCapabilities)
        #pragma alloc_text(PAGE, StartParentFdo)
        #pragma alloc_text(PAGE, QueryParentDeviceRelations)
#endif


/*
 ********************************************************************************
 *  SubmitUrb
 ********************************************************************************
 *
 *
 *      Send the URB to the USB device.
 *      If synchronous is TRUE,
 *      ignore the completion info and synchonize the IRP;
 *      otherwise, don't synchronize and set the provided completion
 *      routine for the IRP.
 */
NTSTATUS SubmitUrb( PPARENT_FDO_EXT parentFdoExt,
                    PURB urb,
                    BOOLEAN synchronous,
                    PVOID completionRoutine,
                    PVOID completionContext)
{
    PIRP irp;
    NTSTATUS status;

	/*
	 *  Allocate the IRP to send the buffer down the USB stack.
	 *
	 *  Don't use IoBuildDeviceIoControlRequest (because it queues
	 *  the IRP on the current thread's irp list and may
	 *  cause the calling process to hang if the IopCompleteRequest APC
	 *  does not fire and dequeue the IRP).
	 */
	irp = IoAllocateIrp(parentFdoExt->topDevObj->StackSize, FALSE);

    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

		nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
		nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

		/*
		 *  Attach the URB to this IRP.
		 */
        nextSp->Parameters.Others.Argument1 = urb;

        if (synchronous){
            status = CallNextDriverSync(parentFdoExt, irp);
			IoFreeIrp(irp);
        }
        else {
            /*
             *  Caller's completion routine will free the irp when it completes.
             *  It will also decrement the pendingActionCount.
             */
            ASSERT(completionRoutine);
            ASSERT(completionContext);
            IoSetCompletionRoutine( irp,
                                    completionRoutine,
                                    completionContext,
                                    TRUE, TRUE, TRUE);
            IncrementPendingActionCount(parentFdoExt);

            status = IoCallDriver(parentFdoExt->topDevObj, irp);
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/*
 *  GetInterfaceList
 *
 *
 */
PUSBD_INTERFACE_LIST_ENTRY GetInterfaceList(
                            PPARENT_FDO_EXT parentFdoExt,
                            PUSB_CONFIGURATION_DESCRIPTOR configDesc)
{
    PUSBD_INTERFACE_LIST_ENTRY interfaceList;

    PAGED_CODE();

    if (configDesc->bNumInterfaces > 0){

        interfaceList = ALLOCPOOL(  NonPagedPool,
                                    (configDesc->bNumInterfaces+1) * sizeof(USBD_INTERFACE_LIST_ENTRY));
        if (interfaceList){
            ULONG i;

            /*
             *  Parse out the interface descriptors
             */
            for (i = 0; i < configDesc->bNumInterfaces; i++){
                PUSB_INTERFACE_DESCRIPTOR interfaceDesc;

                interfaceDesc = USBD_ParseConfigurationDescriptorEx(
                                    configDesc,
                                    configDesc,
                                    i,
                                    0,
                                    -1,
                                    -1,
                                    -1);
                ASSERT(interfaceDesc);
                interfaceList[i].InterfaceDescriptor = interfaceDesc;

                /*
                 *  The .Interface field will be filled in when we do the SELECT_CONFIG.
                 */
                interfaceList[i].Interface = BAD_POINTER;
            }

            /*
             *  Terminate the list.
             */
            interfaceList[i].InterfaceDescriptor = NULL;
            interfaceList[i].Interface = NULL;
        }
        else {
            TRAP("Memory allocation failed");
        }
    }
    else {
        ASSERT(configDesc->bNumInterfaces > 0);
        interfaceList = NULL;
    }

    ASSERT(interfaceList);
    return interfaceList;
}


VOID FreeInterfaceList(PPARENT_FDO_EXT parentFdoExt, BOOLEAN freeListItself)
{
    if (ISPTR(parentFdoExt->interfaceList)){
        ULONG i;

        for (i = 0; i < parentFdoExt->configDesc->bNumInterfaces; i++){
            if (ISPTR(parentFdoExt->interfaceList[i].Interface)){
                PUSBD_INTERFACE_LIST_ENTRY iface = &parentFdoExt->interfaceList[i];

                ASSERT(iface->Interface->Length >= FIELD_OFFSET(USBD_INTERFACE_INFORMATION, Pipes));
                FREEPOOL(iface->Interface);
                iface->Interface = BAD_POINTER;
            }
        }

        if (freeListItself){
            FREEPOOL(parentFdoExt->interfaceList);
            parentFdoExt->interfaceList = BAD_POINTER;
        }
    }

}


NTSTATUS ParentSelectConfiguration( PPARENT_FDO_EXT parentFdoExt,
                                    PUSB_CONFIGURATION_DESCRIPTOR configDesc,
                                    PUSBD_INTERFACE_LIST_ENTRY interfaceList)
{
    NTSTATUS status;
    PURB urb;

    /*
     *  Use USBD_CreateConfigurationRequestEx to allocate
     *  an URB of the right size (including the appended
     *  interface and pipe info we'll get back from
     *  the URB_FUNCTION_SELECT_CONFIGURATION urb).
     */
    urb = USBD_CreateConfigurationRequestEx(configDesc, interfaceList);
    if (urb){

        status = SubmitUrb(parentFdoExt, urb, TRUE, NULL, NULL);

        if (NT_SUCCESS(status)){
            ULONG i;

            /*
             *  This new SELECT_CONFIGURATION URB call caused
             *  USBD_SelectConfiguration to close the current
             *  configuration handle.  So we need to update
             *  our handles.
             */
            parentFdoExt->selectedConfigHandle = urb->UrbSelectConfiguration.ConfigurationHandle;

            /*
             *  Each interfaceList's Interface pointer points
             *  to a part of the URB's buffer.  So copy these
             *  out before freeing the urb.
             */
            for (i = 0; i < configDesc->bNumInterfaces; i++){
                PVOID ifaceInfo = interfaceList[i].Interface;

                if (ifaceInfo){
                    ULONG len = interfaceList[i].Interface->Length;

                    ASSERT(len >= FIELD_OFFSET(USBD_INTERFACE_INFORMATION, Pipes));
                    interfaceList[i].Interface = ALLOCPOOL(NonPagedPool, len);
                    if (interfaceList[i].Interface){
                        RtlCopyMemory(interfaceList[i].Interface, ifaceInfo, len);
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                }
                else {
                    ASSERT(ifaceInfo);
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }
        }
        else {
            DBGWARN(("URB_FUNCTION_SELECT_CONFIGURATION failed with %xh", status));
        }

        FREEPOOL(urb);
    }
    else {
        DBGERR(("USBD_CreateConfigurationRequest... failed"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


VOID ParentCloseConfiguration(PPARENT_FDO_EXT parentFdoExt)
{
    URB urb;
    NTSTATUS status;

    urb.UrbHeader.Length = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb.UrbHeader.Function = URB_FUNCTION_SELECT_CONFIGURATION;
    urb.UrbSelectConfiguration.ConfigurationDescriptor = NULL;

    status = SubmitUrb(parentFdoExt, &urb, TRUE, NULL, NULL);

    ASSERT(NT_SUCCESS(status));
}


/*
 *  TryGetConfigDescriptor
 *
 *      Try to get configuration descriptor for device .
 *
 *
 */
NTSTATUS TryGetConfigDescriptor(PPARENT_FDO_EXT parentFdoExt)
{
    URB urb;
    NTSTATUS status;
    USB_CONFIGURATION_DESCRIPTOR configDescBase = {0};

    PAGED_CODE();

    /*
     *  Get the first part of the configuration descriptor.
     *  It will tell us the size of the full configuration descriptor,
     *  including all the following interface descriptors, etc.
     */
    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 (PVOID)&configDescBase,
                                 NULL,
                                 sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                 NULL);
    status = SubmitUrb(parentFdoExt, &urb, TRUE, NULL, NULL);
    if (NT_SUCCESS(status)){
        ULONG configDescLen = configDescBase.wTotalLength;

        /*
         *  Now allocate the right-sized buffer for the full configuration descriptor.
         */
        ASSERT(configDescLen < 0x1000);
        parentFdoExt->configDesc = ALLOCPOOL(NonPagedPool, configDescLen);
        if (parentFdoExt->configDesc){

            RtlZeroMemory(parentFdoExt->configDesc, configDescLen);

            UsbBuildGetDescriptorRequest(&urb,
                                         (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         parentFdoExt->configDesc,
                                         NULL,
                                         configDescLen,
                                         NULL);

            status = SubmitUrb(parentFdoExt, &urb, TRUE, NULL, NULL);

            if (NT_SUCCESS(status)){
                ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == configDescLen);
                ASSERT(parentFdoExt->configDesc->wTotalLength == configDescLen);
                DBGDUMPBYTES("Got config desc", parentFdoExt->configDesc, parentFdoExt->configDesc->wTotalLength);
                parentFdoExt->selectedConfigDesc = parentFdoExt->configDesc;
                parentFdoExt->selectedConfigHandle = urb.UrbSelectConfiguration.ConfigurationHandle;
            } else {
                /*
                 * Deallocate the configDesc buffer if URB submission failed.
                 */
                FREEPOOL(parentFdoExt->configDesc);
                parentFdoExt->configDesc = NULL;
            }
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return status;
}


/*
 *  GetConfigDescriptor
 *
 *      Get configuration descriptor for device.
 *      Some devices (expecially speakers, which can have huge config descriptors)
 *      are flaky returning their config descriptors.  So we try up to 3 times.
 */
NTSTATUS GetConfigDescriptor(PPARENT_FDO_EXT parentFdoExt)
{
    const ULONG numAttempts = 3;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    for (i = 1; i <= numAttempts; i++){
        status = TryGetConfigDescriptor(parentFdoExt);
        if (NT_SUCCESS(status)){
            if (i != 1) DBGOUT(("GetConfigDescriptor: got config descriptor on retry (@ %ph)", parentFdoExt->configDesc));
            break;
        }
        else {
            if (i < numAttempts){
                DBGWARN(("GetConfigDescriptor: failed with %xh (attempt #%d).", status, i));
            }
            else {
                DBGWARN(("GetConfigDescriptor: failed %d times (status = %xh).", numAttempts, status));
            }
        }
    }

    return status;
}


NTSTATUS GetDeviceDescriptor(PPARENT_FDO_EXT parentFdoExt)
{
    URB urb;
    NTSTATUS status;

    PAGED_CODE();

    RtlZeroMemory(&parentFdoExt->deviceDesc, sizeof(parentFdoExt->deviceDesc));

    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 (PVOID)&parentFdoExt->deviceDesc,
                                 NULL,
                                 sizeof(parentFdoExt->deviceDesc),
                                 NULL);

    status = SubmitUrb(parentFdoExt, &urb, TRUE, NULL, NULL);

    if (NT_SUCCESS(status)){
        DBGVERBOSE(("Got device desc @ %ph, len=%xh (should be %xh).", (PVOID)&parentFdoExt->deviceDesc, urb.UrbControlDescriptorRequest.TransferBufferLength, sizeof(parentFdoExt->deviceDesc)));
    }

    return status;
}


VOID PrepareParentFDOForRemove(PPARENT_FDO_EXT parentFdoExt)
{
    enum deviceState oldState;
    KIRQL oldIrql;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    oldState = parentFdoExt->state;
    parentFdoExt->state = STATE_REMOVING;

    /*
     *  Careful, we may not have allocated the deviceRelations if the previous start failed.
     */
    if (ISPTR(parentFdoExt->deviceRelations)){
        DBGVERBOSE(("PrepareParentFDOForRemove: removing %d child PDOs.", parentFdoExt->deviceRelations->Count));
        while (parentFdoExt->deviceRelations->Count > 0){
            PDEVICE_OBJECT devObj;
            PDEVEXT devExt;
            PFUNCTION_PDO_EXT functionPdoExt;

            /*
             *  Remove the last child pdo from the parent's deviceRelations.
             */
            parentFdoExt->deviceRelations->Count--;
            devObj = parentFdoExt->deviceRelations->Objects[parentFdoExt->deviceRelations->Count];
            parentFdoExt->deviceRelations->Objects[parentFdoExt->deviceRelations->Count] = BAD_POINTER;

            ASSERT(devObj->Type == IO_TYPE_DEVICE);
            devExt = devObj->DeviceExtension;
            ASSERT(!devExt->isParentFdo);
            functionPdoExt = &devExt->functionPdoExt;

            /*
             *  Free this child pdo.  Must drop spinlock around call outside driver.
             */
            KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);
            FreeFunctionPDOResources(functionPdoExt);
            KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if ((oldState != STATE_REMOVING) && (oldState != STATE_REMOVED)){

        /*
         *  Do an extra decrement on the pendingActionCount.
         *  This will cause the count to eventually go to -1
         *  (once all IO completes),
         *  at which time we'll continue.
         */
        DecrementPendingActionCount(parentFdoExt);

        KeWaitForSingleObject( &parentFdoExt->removeEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

    }
}




VOID FreeParentFDOResources(PPARENT_FDO_EXT parentFdoExt)
{
	parentFdoExt->state = STATE_REMOVED;

    FreeInterfaceList(parentFdoExt, TRUE);

    // It is possible that after a failed start, the deviceRelations
    // and configDesc buffers will not have been allocated.

    if (ISPTR(parentFdoExt->deviceRelations)){
	    FREEPOOL(parentFdoExt->deviceRelations);
    }
	parentFdoExt->deviceRelations = BAD_POINTER;

    if (ISPTR(parentFdoExt->configDesc)){
        FREEPOOL(parentFdoExt->configDesc);
    }
    parentFdoExt->configDesc = BAD_POINTER;
    parentFdoExt->selectedConfigDesc = BAD_POINTER;

    if (ISPTR(parentFdoExt->msExtConfigDesc)){
        FREEPOOL(parentFdoExt->msExtConfigDesc);
    }
    parentFdoExt->msExtConfigDesc = BAD_POINTER;

    /*
     *  Delete the device object.  This will also delete the device extension.
     */
    IoDeleteDevice(parentFdoExt->fdo);
}


/*
 *  GetParentFdoCapabilities
 *
 */
NTSTATUS GetParentFdoCapabilities(PPARENT_FDO_EXT parentFdoExt)
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(parentFdoExt->topDevObj->StackSize, FALSE);

    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);
        nextSp->MajorFunction= IRP_MJ_PNP;
        nextSp->MinorFunction= IRP_MN_QUERY_CAPABILITIES;

        RtlZeroMemory(&parentFdoExt->deviceCapabilities, sizeof(DEVICE_CAPABILITIES));
        parentFdoExt->deviceCapabilities.Size = sizeof(DEVICE_CAPABILITIES);
        parentFdoExt->deviceCapabilities.Version = 1;
        parentFdoExt->deviceCapabilities.Address = -1;
        parentFdoExt->deviceCapabilities.UINumber = -1;

        nextSp->Parameters.DeviceCapabilities.Capabilities = &parentFdoExt->deviceCapabilities;

        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;  // default status for PNP irps is STATUS_NOT_SUPPORTED
        status = CallDriverSync(parentFdoExt->topDevObj, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}



/*
 ************************************************************
 *  StartParentFdo
 ************************************************************
 *
 */
NTSTATUS StartParentFdo(PPARENT_FDO_EXT parentFdoExt, PIRP irp)
{
    NTSTATUS status;
    BOOLEAN resumingFromStop;

    PAGED_CODE();

    resumingFromStop = ((parentFdoExt->state == STATE_STOPPING) || (parentFdoExt->state == STATE_STOPPED));
    parentFdoExt->state = STATE_STARTING;

    /*
     *  Chain the call down the stack synchronously first
     *  (have to start the lower stack before sending other calls to it).
     */
    IoCopyCurrentIrpStackLocationToNext(irp);
    status = CallDriverSync(parentFdoExt->topDevObj, irp);

    if (NT_SUCCESS(status)){

        if (resumingFromStop){
            /*
             *  If we're resuming from a STOP, we don't need to get descriptors, etc., again.
             *  All we have to do is a SELECT_CONFIGURATION.
             *  The function PDOs are presumably already created and are already
             *  pointing into the parent's interfaceList.
             *
             *  ** This call will change the .Interface fields inside each element
             *     of the parent's interfaceList; when we're done, the interfaceList
             *     AND the function PDOs' pointers into that list will be valid.
             */

            status = ParentSelectConfiguration( parentFdoExt,
                                                parentFdoExt->selectedConfigDesc,
                                                parentFdoExt->interfaceList);
        }
        else {

            status = GetDeviceDescriptor(parentFdoExt);
            if (NT_SUCCESS(status)){

                status = GetConfigDescriptor(parentFdoExt);
                if (NT_SUCCESS(status)){

                    status = GetParentFdoCapabilities(parentFdoExt);
                    if (NT_SUCCESS(status)){

                        if (NT_SUCCESS(status)){

                            parentFdoExt->interfaceList = GetInterfaceList(parentFdoExt, parentFdoExt->selectedConfigDesc);
                            if (parentFdoExt->interfaceList){

                                status = ParentSelectConfiguration( parentFdoExt,
                                                                    parentFdoExt->selectedConfigDesc,
                                                                    parentFdoExt->interfaceList);

                                GetMsExtendedConfigDescriptor(parentFdoExt);

                                if (NT_SUCCESS(status)){

                                    status = CreateStaticFunctionPDOs(parentFdoExt);
                                    if (NT_SUCCESS(status)){
                                        /*
                                         *  Alert the system that we are creating
                                         *  new PDOs.  The kernel should respond by
                                         *  sending us the
                                         *  IRP_MN_QUERY_DEVICE_RELATIONS PnP IRP.
                                         */
                                        IoInvalidateDeviceRelations(parentFdoExt->pdo, BusRelations);
                                    }
			                        else {
                                        if (parentFdoExt->deviceRelations) {
                                            FREEPOOL(parentFdoExt->deviceRelations);
                                        }
				                        parentFdoExt->deviceRelations = BAD_POINTER;
			                        }
                                }

                                if (!NT_SUCCESS(status)){
				                    FREEPOOL(parentFdoExt->interfaceList);
				                    parentFdoExt->interfaceList = BAD_POINTER;
                                }
                            }
                            else {
                                status = STATUS_DEVICE_DATA_ERROR;
                            }
                        }
                    }
                }
            }
        }
    }
    else {
        DBGWARN(("Chained start irp failed with %xh.", status));
    }

    if (NT_SUCCESS(status)){
        parentFdoExt->state = STATE_STARTED;
    }
    else {
        DBGWARN(("StartParentFdo failed with %xh.", status));
        parentFdoExt->state = STATE_START_FAILED;
    }

    return status;
}

/*
 ********************************************************************************
 *  QueryParentDeviceRelations
 ********************************************************************************
 *
 *
 */
NTSTATUS QueryParentDeviceRelations(PPARENT_FDO_EXT parentFdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    if (irpSp->Parameters.QueryDeviceRelations.Type == BusRelations){

        if (parentFdoExt->deviceRelations){
            /*
             *  NTKERN expects a new pointer each time it calls QUERY_DEVICE_RELATIONS;
             *  it then FREES THE POINTER.
             *  So we have to return a new pointer each time, whether or not we actually
             *  created our copy of the device relations for this call.
             */
            irp->IoStatus.Information = (ULONG_PTR)CopyDeviceRelations(parentFdoExt->deviceRelations);
            if (irp->IoStatus.Information){
                ULONG i;

                /*
                 *  The kernel dereferences each device object
                 *  in the device relations list after each call.
                 *  So for each call, add an extra reference.
                 */
                for (i = 0; i < parentFdoExt->deviceRelations->Count; i++){
                    ObReferenceObject(parentFdoExt->deviceRelations->Objects[i]);
                    parentFdoExt->deviceRelations->Objects[i]->Flags &= ~DO_DEVICE_INITIALIZING;
                }

                DBGVERBOSE(("Parent returned %d child PDOs", parentFdoExt->deviceRelations->Count));

                /*
                 *  If we are succeeding this PnP IRP, then we pass it down
                 *  the stack but change its default status to success.
                 */
                irp->IoStatus.Status = STATUS_SUCCESS;
                status = NO_STATUS;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            ASSERT(parentFdoExt->deviceRelations);
            status = STATUS_DEVICE_DATA_ERROR;
        }
    }
    else {
        /*
         *  Pass this IRP down to the next driver.
         */
        status = NO_STATUS;
    }

    if (!NT_SUCCESS(status) && (status != NO_STATUS)) {
        DBGWARN(("QueryParentDeviceRelations: failed with %xh.", status));
    }
    return status;
}



/*
 ********************************************************************************
 *  ParentPowerRequestCompletion
 ********************************************************************************
 *
 *
 */
VOID ParentPowerRequestCompletion(
                                IN PDEVICE_OBJECT devObj,
                                IN UCHAR minorFunction,
                                IN POWER_STATE powerState,
                                IN PVOID context,
                                IN PIO_STATUS_BLOCK ioStatus)
{
    PPARENT_FDO_EXT parentFdoExt = (PPARENT_FDO_EXT)context;
    PIRP parentSetPowerIrp;

    ASSERT(parentFdoExt->currentSetPowerIrp->Type == IO_TYPE_IRP);
    parentSetPowerIrp = parentFdoExt->currentSetPowerIrp;
    parentFdoExt->currentSetPowerIrp = NULL;

    /*
     *  This is the completion routine for the device-state power
     *  Irp which we've requested.  Complete the original system-state
     *  power Irp with the result of the device-state power Irp.
     */
    ASSERT(devObj->Type == IO_TYPE_DEVICE);
    ASSERT(NT_SUCCESS(ioStatus->Status));
    parentSetPowerIrp->IoStatus.Status = ioStatus->Status;
    PoStartNextPowerIrp(parentSetPowerIrp);

    if (NT_SUCCESS(ioStatus->Status)){
        IoCopyCurrentIrpStackLocationToNext(parentSetPowerIrp);
        IoSetCompletionRoutine(parentSetPowerIrp, ParentPdoPowerCompletion, (PVOID)parentFdoExt, TRUE, TRUE, TRUE);
        PoCallDriver(parentFdoExt->topDevObj, parentSetPowerIrp);
    }
    else {
        IoCompleteRequest(parentSetPowerIrp, IO_NO_INCREMENT);
    }
}


/*
 ********************************************************************************
 *  ParentPdoPowerCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS ParentPdoPowerCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    PIO_STACK_LOCATION irpSp;
    PPARENT_FDO_EXT parentFdoExt = (PPARENT_FDO_EXT)context;

    ASSERT(parentFdoExt);

    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (parentFdoExt->state == STATE_SUSPENDED){
                                    parentFdoExt->state = STATE_STARTED;
                                    CompleteAllFunctionWaitWakeIrps(parentFdoExt, STATUS_SUCCESS);
                                    CompleteAllFunctionIdleIrps(parentFdoExt, STATUS_SUCCESS);
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }

    /*
     *  Must propagate the pending bit if a lower driver returned pending.
     */
    if (irp->PendingReturned){
        IoMarkIrpPending(irp);
    }

    return STATUS_SUCCESS;
}



/*
 *  HandleParentFdoPower
 *
 *
 */
NTSTATUS HandleParentFdoPower(PPARENT_FDO_EXT parentFdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnPending = FALSE;
    NTSTATUS status = NO_STATUS;
    KIRQL oldIrql;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    if ((parentFdoExt->state == STATE_REMOVING) ||
        (parentFdoExt->state == STATE_REMOVED)){

        status = STATUS_DEVICE_NOT_CONNECTED;
        completeIrpHere = TRUE;
    }
    else {
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case SystemPowerState:

                        {
                            SYSTEM_POWER_STATE systemState = irpSp->Parameters.Power.State.SystemState;

                            ASSERT((ULONG)systemState < PowerSystemMaximum);

                            if (systemState <= PowerSystemHibernate){
                                /*
                                 *  For the 'regular' system power states,
                                 *  we convert to a device power state
                                 *  and request a callback with the device power state.
                                 */
                                POWER_STATE powerState;

                                ASSERT(!parentFdoExt->currentSetPowerIrp);
                                parentFdoExt->currentSetPowerIrp = irp;

                                if (systemState == PowerSystemWorking) {
                                    powerState.DeviceState = PowerDeviceD0;
                                } else if (parentFdoExt->isWaitWakePending) {
                                    powerState.DeviceState = parentFdoExt->deviceCapabilities.DeviceState[systemState];
                                    ASSERT(PowerDeviceUnspecified != powerState.DeviceState);
                                } else {
                                    powerState.DeviceState = PowerDeviceD3;
                                }

                                IoMarkIrpPending(irp);
                                status = irp->IoStatus.Status = STATUS_PENDING;
                                PoRequestPowerIrp(  parentFdoExt->pdo,
                                                    IRP_MN_SET_POWER,
                                                    powerState,
                                                    ParentPowerRequestCompletion,
                                                    parentFdoExt, // context
                                                    NULL);

                                /*
                                 *  We want to complete the system-state power Irp
                                 *  with the result of the device-state power Irp.
                                 *  We'll complete the system-state power Irp when
                                 *  the device-state power Irp completes.
                                 *
                                 *  Note: this may have ALREADY happened, so don't
                                 *        touch the original Irp anymore.
                                 */
                                justReturnPending = TRUE;
                            }
                            else {
                                /*
                                 *  For the remaining system power states,
                                 *  just pass down the IRP.
                                 */
                            }
                        }

                        break;

                    case DevicePowerState:

                        switch (irpSp->Parameters.Power.State.DeviceState) {

                            case PowerDeviceD0:
                                /*
                                 *  Resume from APM Suspend
                                 *
                                 *  Do nothing here; Send down the read IRPs in the
                                 *  completion routine for this (the power) IRP.
                                 */
                                break;

                            case PowerDeviceD1:
                            case PowerDeviceD2:
                            case PowerDeviceD3:
                                /*
                                 *  Suspend
                                 */
                                if (parentFdoExt->state == STATE_STARTED){
                                    parentFdoExt->state = STATE_SUSPENDED;
                                }
                                break;

                        }
                        break;

                }
                break;

            case IRP_MN_WAIT_WAKE:
                /*
                 *  This is the WaitWake IRP that we requested for ourselves
                 *  via PoRequestPowerIrp.  Send it down to the parent,
                 *  but record it in case we have to cancel it later.
                 */
                KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);
                ASSERT(parentFdoExt->isWaitWakePending);
                ASSERT(!parentFdoExt->parentWaitWakeIrp);
                parentFdoExt->parentWaitWakeIrp = irp;
                KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);
                break;
        }
    }


    if (!justReturnPending){

        /*
         *  Whether we are completing or relaying this power IRP,
         *  we must call PoStartNextPowerIrp on Windows NT.
         */
        PoStartNextPowerIrp(irp);

        /*
         *  If this is a call for a collection-PDO, we complete it ourselves here.
         *  Otherwise, we pass it to the minidriver stack for more processing.
         */
        if (completeIrpHere){
            ASSERT(status != NO_STATUS);
            irp->IoStatus.Status = status;
            IoCompleteRequest(irp, IO_NO_INCREMENT);
        }
        else {
            /*
             *  Call the parent driver with this Irp.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            IoSetCompletionRoutine(irp, ParentPdoPowerCompletion, (PVOID)parentFdoExt, TRUE, TRUE, TRUE);
            status = PoCallDriver(parentFdoExt->topDevObj, irp);
        }
    }

    return status;
}


NTSTATUS ParentResetOrCyclePort(PPARENT_FDO_EXT parentFdoExt, PIRP irp, ULONG ioControlCode)
{
    NTSTATUS status;
    KIRQL oldIrql;
    BOOLEAN proceed;
    PBOOLEAN actionInProgress;
    PLIST_ENTRY pendingIrpQueue;

    if (ioControlCode == IOCTL_INTERNAL_USB_CYCLE_PORT) {
        actionInProgress = &parentFdoExt->cyclePortInProgress;
        pendingIrpQueue = &parentFdoExt->pendingCyclePortIrpQueue;
    } else {
        /*
         * IOCTL_INTERNAL_USB_RESET_PORT
         */
        actionInProgress = &parentFdoExt->resetPortInProgress;
        pendingIrpQueue = &parentFdoExt->pendingResetPortIrpQueue;
    }

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);
    if (*actionInProgress){
        /*
         *  This is an overlapped RESET or CYCLE irp on the same parent.
         *  Queue the irp and return pending; we'll complete it
         *  _AFTER_ the first reset irp completes.
         *  (No need for a cancel routine here since RESET is quick).
         */
        DBGWARN(("ParentInternalDeviceControl: queuing overlapping reset/cycle port call on parent"));
        /*
         *  Need to mark the IRP pending if we are returning STATUS_PENDING.
         *  Failure to do so results in the IRP's completion routine not
         *  being called when the IRP is later completed asynchronously,
         *  and this results in a system hang if there is a thread waiting
         *  on that completion routine.
         */
        IoMarkIrpPending(irp);
        status = STATUS_PENDING;
        InsertTailList(pendingIrpQueue, &irp->Tail.Overlay.ListEntry);
        proceed = FALSE;
    }
    else {
        *actionInProgress = TRUE;
        proceed = TRUE;
    }
    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (proceed){
        LIST_ENTRY irpsToComplete;
        PLIST_ENTRY listEntry;

        IoCopyCurrentIrpStackLocationToNext(irp);
        status = CallNextDriverSync(parentFdoExt, irp);

        /*
         *  Some redundant RESET or CYCLE irps may have been sent while we
         *  were processing this one, and gotten queued.
         *  We'll complete these now that the parent has been reset.
         */
        InitializeListHead(&irpsToComplete);

        KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

        ASSERT(*actionInProgress);
        *actionInProgress = FALSE;

        /*
         *  Move the irps to a local queue with spinlock held.
         *  Then complete them after dropping the spinlock.
         */
        while (!IsListEmpty(pendingIrpQueue)){
            listEntry = RemoveHeadList(pendingIrpQueue);
            InsertTailList(&irpsToComplete, listEntry);
        }

        KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

        /*
         *  Complete the dequeued irps _after_ dropping the spinlock.
         */
        while (!IsListEmpty(&irpsToComplete)){
            PIRP dequeuedIrp;

            listEntry = RemoveHeadList(&irpsToComplete);
            dequeuedIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);
            dequeuedIrp->IoStatus.Status = status;
            IoCompleteRequest(dequeuedIrp, IO_NO_INCREMENT);
        }
    }

    return status;
}



NTSTATUS ParentDeviceControl(PPARENT_FDO_EXT parentFdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    NTSTATUS status = NO_STATUS;

    if (parentFdoExt->state == STATE_SUSPENDED ||
        parentFdoExt->pendingIdleIrp) {

        ParentSetD0(parentFdoExt);
    }

    switch (ioControlCode){
        case IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER:
            if (parentFdoExt->haveCSInterface){
                status = GetMediaSerialNumber(parentFdoExt, irp);
            }
            else {
                DBGWARN(("ParentDeviceControl - passing IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER to parent because no Content Security interface on device"));
            }
            break;
    }

    if (status == NO_STATUS){
        IoSkipCurrentIrpStackLocation(irp);
        status = IoCallDriver(parentFdoExt->topDevObj, irp);
    }
    else {
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS ParentInternalDeviceControl(PPARENT_FDO_EXT parentFdoExt, PIRP irp)
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    ULONG ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
    PURB urb;
    NTSTATUS status = NO_STATUS;

    switch (ioControlCode){

        case IOCTL_INTERNAL_USB_RESET_PORT:
        case IOCTL_INTERNAL_USB_CYCLE_PORT:
            if (parentFdoExt->state == STATE_STARTED){
                status = ParentResetOrCyclePort(parentFdoExt, irp, ioControlCode);
            }
            else {
                DBGERR(("ParentInternalDeviceControl (IOCTL_INTERNAL_USB_RESET_PORT): BAD PNP state! - parent has state %xh.", parentFdoExt->state));
                status = STATUS_DEVICE_NOT_READY;
            }
			break;

        case IOCTL_INTERNAL_USB_SUBMIT_URB:
            urb = irpSp->Parameters.Others.Argument1;
            ASSERT(urb);
            DBG_LOG_URB(urb);

            if (parentFdoExt->state == STATE_STARTED){
                /*
                 *  Send the URB down to the parent.
                 *  It's ok to not synchronize URB_FUNCTION_ABORT_PIPE
                 *  and URB_FUNCTION_RESET_PIPE because they only effect
                 *  the resources of one function.
                 */
            }
            else {
                DBGERR(("ParentInternalDeviceControl (abort/reset): BAD PNP state! - parent has state %xh.", parentFdoExt->state));
                status = STATUS_DEVICE_NOT_READY;
            }

            break;
    }

    if (status == NO_STATUS){
        /*
         *  Pass this irp to the parent driver.
         */
        IoSkipCurrentIrpStackLocation(irp);
        status = IoCallDriver(parentFdoExt->topDevObj, irp);
    }
    else if (status == STATUS_PENDING){

    }
    else {
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return status;
}


VOID ParentIdleNotificationCallback(PPARENT_FDO_EXT parentFdoExt)
{
    PIRP idleIrp;
    PIRP parentIdleIrpToCancel = FALSE;
    KIRQL oldIrql;
    POWER_STATE powerState;
    NTSTATUS ntStatus;
    ULONG i;
    BOOLEAN bIdleOk = TRUE;

    DBGVERBOSE(("Parent %x going idle!", parentFdoExt));

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    ASSERT(parentFdoExt->deviceRelations);

    for (i = 0; i < parentFdoExt->deviceRelations->Count; i++){
        PDEVICE_OBJECT devObj = parentFdoExt->deviceRelations->Objects[i];
        PDEVEXT devExt;
        PFUNCTION_PDO_EXT thisFuncPdoExt;

        ASSERT(devObj);
        devExt = devObj->DeviceExtension;
        ASSERT(devExt);
        ASSERT(devExt->signature == USBCCGP_TAG);
        ASSERT(!devExt->isParentFdo);
        thisFuncPdoExt = &devExt->functionPdoExt;

        idleIrp = thisFuncPdoExt->idleNotificationIrp;

        ASSERT(idleIrp);

        if (idleIrp) {
            PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

            idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
                IoGetCurrentIrpStackLocation(idleIrp)->\
                    Parameters.DeviceIoControl.Type3InputBuffer;

            ASSERT(idleCallbackInfo && idleCallbackInfo->IdleCallback);

            if (idleCallbackInfo && idleCallbackInfo->IdleCallback) {

                // Here we actually call the driver's callback routine,
                // telling the driver that it is OK to suspend their
                // device now.

                DBGVERBOSE(("ParentIdleNotificationCallback: Calling driver's idle callback routine! %x %x",
                    idleCallbackInfo, idleCallbackInfo->IdleCallback));

                KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);
                idleCallbackInfo->IdleCallback(idleCallbackInfo->IdleContext);
                KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

                // Be sure that the child actually powered down.
                // Abort if the child aborted.

                if (thisFuncPdoExt->state != STATE_SUSPENDED) {
                    bIdleOk = FALSE;
                    break;
                }

            } else {

                // No callback

                bIdleOk = FALSE;
                break;
            }

        } else {

            // No Idle IRP

            bIdleOk = FALSE;
            break;
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (bIdleOk) {

        // If all the child function PDOs have been powered down,
        // it is time to power down the parent.

        powerState.DeviceState = PowerDeviceD2;     // DeviceWake

        PoRequestPowerIrp(parentFdoExt->topDevObj,
                          IRP_MN_SET_POWER,
                          powerState,
                          NULL,
                          NULL,
                          NULL);
    } else {

        // One or more of the child function PDOs did not have an Idle IRP
        // (i.e. it was just cancelled), or the Idle IRP did not have a
        // callback function pointer.  Abort this Idle procedure and cancel
        // the Idle IRP to the parent.

        KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

        if (parentFdoExt->pendingIdleIrp){
            parentIdleIrpToCancel = parentFdoExt->pendingIdleIrp;
            parentFdoExt->pendingIdleIrp = NULL;
        }

        KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

        if (parentIdleIrpToCancel){
            IoCancelIrp(parentIdleIrpToCancel);
        }
    }
}


NTSTATUS ParentIdleNotificationRequestComplete(PDEVICE_OBJECT DeviceObject, PIRP Irp, PPARENT_FDO_EXT parentFdoExt)
{
    NTSTATUS ntStatus;
    KIRQL oldIrql;

    //
    // DeviceObject is NULL because we sent the irp
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    DBGVERBOSE(("Idle notification IRP for parent %x completed %x\n", parentFdoExt, Irp->IoStatus.Status));

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    parentFdoExt->pendingIdleIrp = NULL;

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    ntStatus = Irp->IoStatus.Status;

    /*
     *  If parent Idle IRP failed, fail all function Idle IRPs.
     */
    if (!NT_SUCCESS(ntStatus)){

        if (parentFdoExt->state == STATE_SUSPENDED ||
            parentFdoExt->pendingIdleIrp) {

            ParentSetD0(parentFdoExt);
        }

        CompleteAllFunctionIdleIrps(parentFdoExt, ntStatus);
    }

    /*  Since we allocated the IRP we must free it, but return
     *  STATUS_MORE_PROCESSING_REQUIRED so the kernel does not try to touch
     *  the IRP after we've freed it.
     */

    IoFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS SubmitParentIdleRequestIrp(PPARENT_FDO_EXT parentFdoExt)
{
    PIRP irp = NULL;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS ntStatus;
    KIRQL oldIrql;

    DBGVERBOSE(("SubmitParentIdleRequestIrp %x", parentFdoExt));

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    if (parentFdoExt->pendingIdleIrp){
        ntStatus = STATUS_DEVICE_BUSY;
    }
    else {
        parentFdoExt->idleCallbackInfo.IdleCallback = ParentIdleNotificationCallback;
        parentFdoExt->idleCallbackInfo.IdleContext = (PVOID)parentFdoExt;

        irp = IoAllocateIrp(parentFdoExt->topDevObj->StackSize, FALSE);

        if (irp){
            /*
             *  Set pendingIdleIrp with lock held so that we don't
             *  send down more than one.
             *  Then send this one down after dropping the lock.
             */
            parentFdoExt->pendingIdleIrp = irp;
        }
        else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (irp){
        nextStack = IoGetNextIrpStackLocation(irp);
        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;
        nextStack->Parameters.DeviceIoControl.Type3InputBuffer = &parentFdoExt->idleCallbackInfo;
        nextStack->Parameters.DeviceIoControl.InputBufferLength = sizeof(struct _USB_IDLE_CALLBACK_INFO);

        IoSetCompletionRoutine(irp,
                               ParentIdleNotificationRequestComplete,
                               parentFdoExt,
                               TRUE,
                               TRUE,
                               TRUE);

        ntStatus = IoCallDriver(parentFdoExt->topDevObj, irp);
        ASSERT(ntStatus == STATUS_PENDING);
    }


    return ntStatus;
}


/*
 *  CheckParentIdle
 *
 *
 *      This function determines if a composite device is ready to be idled out,
 *      and does so if ready.
 *
 */
VOID CheckParentIdle(PPARENT_FDO_EXT parentFdoExt)
{
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    KIRQL oldIrql;
    BOOLEAN bAllIdle;
    ULONG i;

    DBGVERBOSE(("Check Parent Idle %x", parentFdoExt));

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);

    bAllIdle = TRUE;    // Assume that everyone wants to idle.

    ASSERT(parentFdoExt->deviceRelations);
    for (i = 0; i < parentFdoExt->deviceRelations->Count; i++) {
        PDEVICE_OBJECT devObj = parentFdoExt->deviceRelations->Objects[i];
        PDEVEXT devExt;
        PFUNCTION_PDO_EXT thisFuncPdoExt;

        ASSERT(devObj);
        devExt = devObj->DeviceExtension;
        ASSERT(devExt);
        ASSERT(devExt->signature == USBCCGP_TAG);
        ASSERT(!devExt->isParentFdo);
        thisFuncPdoExt = &devExt->functionPdoExt;

        if (!thisFuncPdoExt->idleNotificationIrp){
            bAllIdle = FALSE;
            break;
        }
    }

    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    /*
     *  If all functions have received an idle request,
     *  then submit an idle request for the parent.
     */
    if (bAllIdle ) {
        DBGVERBOSE(("CheckParentIdle: All function PDOs on parent %x idle!", parentFdoExt));
        SubmitParentIdleRequestIrp(parentFdoExt);
    }

}


NTSTATUS SubmitParentWaitWakeIrp(PPARENT_FDO_EXT parentFdoExt)
{
    NTSTATUS status;
    POWER_STATE powerState;
    PIRP dummyIrp;

    ASSERT(parentFdoExt->isWaitWakePending);

    powerState.SystemState = PowerSystemWorking;

    status = PoRequestPowerIrp( parentFdoExt->topDevObj,
                                IRP_MN_WAIT_WAKE,
                                powerState,
                                ParentWaitWakeComplete,
                                parentFdoExt, // context
                                &dummyIrp);

    ASSERT(NT_SUCCESS(status));

    return status;
}


/*
 ********************************************************************************
 *  ParentWaitWakePowerRequestCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS ParentWaitWakePowerRequestCompletion(
                                IN PDEVICE_OBJECT devObj,
                                IN UCHAR minorFunction,
                                IN POWER_STATE powerState,
                                IN PVOID context,
                                IN PIO_STATUS_BLOCK ioStatus)
{
    PPARENT_FDO_EXT parentFdoExt = (PPARENT_FDO_EXT)context;
    NTSTATUS status;

    status = ioStatus->Status;

    CompleteAllFunctionWaitWakeIrps(parentFdoExt, STATUS_SUCCESS);

    return status;
}


/*
 ********************************************************************************
 *  ParentWaitWakeComplete
 ********************************************************************************
 *
 */
NTSTATUS ParentWaitWakeComplete(
                        IN PDEVICE_OBJECT       deviceObject,
                        IN UCHAR                minorFunction,
                        IN POWER_STATE          powerState,
                        IN PVOID                context,
                        IN PIO_STATUS_BLOCK     ioStatus)
{
    PPARENT_FDO_EXT parentFdoExt = (PPARENT_FDO_EXT)context;
    NTSTATUS status;
    KIRQL oldIrql;
    POWER_STATE pwrState;

    status = ioStatus->Status;

    KeAcquireSpinLock(&parentFdoExt->parentFdoExtSpinLock, &oldIrql);
    ASSERT(parentFdoExt->isWaitWakePending);
    parentFdoExt->isWaitWakePending = FALSE;
    parentFdoExt->parentWaitWakeIrp = NULL;
    KeReleaseSpinLock(&parentFdoExt->parentFdoExtSpinLock, oldIrql);

    if (NT_SUCCESS(status) && (parentFdoExt->state == STATE_SUSPENDED)){
        /*
         *  Per the DDK: if parent is suspended,
         *  do not complete the function PDOs' WaitWake irps here;
         *  wait for the parent to get the D0 irp.
         */
        pwrState.DeviceState = PowerDeviceD0;

        PoRequestPowerIrp(  parentFdoExt->pdo,
                            IRP_MN_SET_POWER,
                            pwrState,
                            ParentWaitWakePowerRequestCompletion,
                            parentFdoExt, // context
                            NULL);
    }
    else {
        CompleteAllFunctionWaitWakeIrps(parentFdoExt, status);
    }

    return STATUS_SUCCESS;
}


/*
 ********************************************************************************
 *  ParentSetD0Completion
 ********************************************************************************
 *
 */
NTSTATUS ParentSetD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    NTSTATUS ntStatus;
    PKEVENT pEvent = Context;

    KeSetEvent(pEvent, 1, FALSE);

    ntStatus = IoStatus->Status;

    return ntStatus;
}


/*
 ********************************************************************************
 *  ParentSetD0
 ********************************************************************************
 *
 */
NTSTATUS ParentSetD0(IN PPARENT_FDO_EXT parentFdoExt)
{
    KEVENT event;
    POWER_STATE powerState;
    NTSTATUS ntStatus;

    PAGED_CODE();

    DBGVERBOSE(("ParentSetD0, power up devext %x\n", parentFdoExt));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    powerState.DeviceState = PowerDeviceD0;

    // Power up the device.
    ntStatus = PoRequestPowerIrp(parentFdoExt->topDevObj,
                                 IRP_MN_SET_POWER,
                                 powerState,
                                 ParentSetD0Completion,
                                 &event,
                                 NULL);

    ASSERT(ntStatus == STATUS_PENDING);
    if (ntStatus == STATUS_PENDING) {

        ntStatus = KeWaitForSingleObject(&event,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\usbccgp.c ===
/*
 *************************************************************************
 *  File:       USBCCGP.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, DriverEntry)
        #pragma alloc_text(PAGE, USBC_AddDevice)
        #pragma alloc_text(PAGE, USBC_DriverUnload)
        #pragma alloc_text(PAGE, RegQueryGenericCompositeUSBDeviceString)
#endif


PWCHAR GenericCompositeUSBDeviceString = NULL;


NTSTATUS GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

	This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
	ValueType - The type of the value
	ValueData - The data for the value.
	ValueLength - The length of ValueData.
	Context - A pointer to the CONFIG structure.
	EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PWCHAR tmpStr;

    switch (ValueType) {
//    case REG_DWORD:
//        *(PVOID*)EntryContext = *(PVOID*)ValueData;
//        break;
//    case REG_BINARY:
//        RtlCopyMemory(EntryContext, ValueData, ValueLength);
//        break;
    case REG_SZ:
        if (ValueLength) {
            tmpStr = ExAllocatePool(PagedPool, ValueLength);
            if (tmpStr) {
                RtlZeroMemory(tmpStr, ValueLength);
                RtlCopyMemory(tmpStr, ValueData, ValueLength);
                *(PWCHAR *)EntryContext = tmpStr;
            } else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        break;
    default:
//        TEST_TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}



NTSTATUS RegQueryGenericCompositeUSBDeviceString(IN OUT PWCHAR *GenericCompositeUSBDeviceString)
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usbstr = L"usbflags";
    PWCHAR valuename = L"GenericCompositeUSBDeviceString";

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // Upgrade install flag
    QueryTable[0].QueryRoutine = GetConfigValue;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = valuename;
    QueryTable[0].EntryContext = GenericCompositeUSBDeviceString;
    QueryTable[0].DefaultType = 0;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                usbstr,
                QueryTable,					// QueryTable
                NULL,						// Context
                NULL);						// Environment

    return ntStatus;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT driverObj, IN PUNICODE_STRING uniRegistryPath)
{

    PAGED_CODE();

    driverObj->MajorFunction[IRP_MJ_CREATE] =
        driverObj->MajorFunction[IRP_MJ_CLOSE] =
        driverObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        driverObj->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
        driverObj->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        driverObj->MajorFunction[IRP_MJ_PNP] =
        driverObj->MajorFunction[IRP_MJ_POWER] = USBC_Dispatch;

    driverObj->DriverUnload = USBC_DriverUnload;
    driverObj->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)USBC_AddDevice;

    RegQueryGenericCompositeUSBDeviceString(&GenericCompositeUSBDeviceString);

    return STATUS_SUCCESS;
}


/*
 *  USBC_AddDevice
 *
 */
NTSTATUS USBC_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo)
{
    NTSTATUS status;
    PDEVICE_OBJECT fdo = NULL;

    PAGED_CODE();

    status = IoCreateDevice(    driverObj,
                                sizeof(DEVEXT),
                                NULL,       // name for this device
                                FILE_DEVICE_UNKNOWN,
                                FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                FALSE,      // not exclusive
                                &fdo);      // our device object

    if (NT_SUCCESS(status)){
        PDEVEXT devExt;
        PPARENT_FDO_EXT parentFdoExt;

        ASSERT(fdo);

        devExt = (PDEVEXT)fdo->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(DEVEXT));

        devExt->signature = USBCCGP_TAG;
        devExt->isParentFdo = TRUE;

        parentFdoExt = &devExt->parentFdoExt;

        parentFdoExt->driverObj = driverObj;
        parentFdoExt->pdo = pdo;
        parentFdoExt->fdo = fdo;
        parentFdoExt->state = STATE_INITIALIZED;
        parentFdoExt->topDevObj = IoAttachDeviceToDeviceStack(fdo, pdo);

        parentFdoExt->pendingActionCount = 0;
        KeInitializeEvent(&parentFdoExt->removeEvent, NotificationEvent, FALSE);

        KeInitializeSpinLock(&parentFdoExt->parentFdoExtSpinLock);

        InitializeListHead(&parentFdoExt->functionWaitWakeIrpQueue);
        InitializeListHead(&parentFdoExt->pendingResetPortIrpQueue);
        InitializeListHead(&parentFdoExt->pendingCyclePortIrpQueue);

        fdo->Flags |= (parentFdoExt->topDevObj->Flags & DO_POWER_PAGABLE);
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;

        DBGVERBOSE(("Created parent FDO %p", pdo));
    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID USBC_DriverUnload(IN PDRIVER_OBJECT DriverObject)
{
    PAGED_CODE();

    if (GenericCompositeUSBDeviceString) {
        ExFreePool(GenericCompositeUSBDeviceString);
        GenericCompositeUSBDeviceString = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\security.h ===
/*
 *************************************************************************
 *  File:       SECURITY.H
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */



#pragma pack(1)

	typedef struct {
						UCHAR bMethod;
						UCHAR bMethodVariant;
	} CS_METHOD_AND_VARIANT;

	typedef struct {
						UCHAR bLength;
						UCHAR bDescriptorType;
						UCHAR bChannelID;
						UCHAR bmAttributes;
						UCHAR bRecipient;
						UCHAR bRecipientAlt;
						UCHAR bRecipientLogicalUnit;
						CS_METHOD_AND_VARIANT methodAndVariant[0];
	} CS_CHANNEL_DESCRIPTOR;

	typedef struct {
						UCHAR bLength;
						UCHAR bDescriptorType;
						UCHAR bMethodID;
						UCHAR iCSMDescriptor;
						USHORT bcdVersion;
						UCHAR CSMData[0];
	} CSM_DESCRIPTOR;

#pragma pack()


            // BUGBUG - get this into a shared header
typedef struct _MEDIA_SERIAL_NUMBER_DATA {
    ULONG  SerialNumberLength;  // byte size of SerialNumberData[] (not of entire struct)
    ULONG  Result;
    ULONG  Reserved[2];
    UCHAR  SerialNumberData[1];
} MEDIA_SERIAL_NUMBER_DATA, *PMEDIA_SERIAL_NUMBER_DATA;


/*
 *  Values from USB Authentication Device spec
 */
#define USB_AUTHENTICATION_HOST_COMMAND_PUT     0x00
#define USB_AUTHENTICATION_DEVICE_RESPONSE_GET  0x01
#define USB_AUTHENTICATION_SET_CHANNEL_SETTING  0x05

#define USB_DEVICE_CLASS_CONTENT_SECURITY  0x0D

#define CS_DESCRIPTOR_TYPE_CHANNEL	0x22
#define CS_DESCRIPTOR_TYPE_CSM		0x23
#define CS_DESCRIPTOR_TYPE_CSM_VER	0x24


#define CSM_BASIC           1       // Microsoft
#define CSM_DTCP            2       // Intel
#define CSM_OCPS            3       // Philips
#define CSM_ELLIPTIC_CURVE  4

#define CSM1_REQUEST_GET_UNIQUE_ID (UCHAR)0x80
#define CSM1_GET_UNIQUE_ID_LENGTH 0x100			// this value is fixed in the CSM1 spec


CS_CHANNEL_DESCRIPTOR *     GetChannelDescForInterface(PPARENT_FDO_EXT parentFdoExt, ULONG interfaceNum);
NTSTATUS                    GetUniqueIdFromCSInterface(PPARENT_FDO_EXT parentFdoExt, PMEDIA_SERIAL_NUMBER_DATA serialNumData, ULONG serialNumLen);
NTSTATUS                    GetMediaSerialNumber(PPARENT_FDO_EXT parentFdoExt, PIRP irp);
VOID                        InitCSInfo(PPARENT_FDO_EXT parentFdoExt, ULONG CSIfaceNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\usbccgp.h ===
/*
 *************************************************************************
 *  File:       USBCCGP.H
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <msosdesc.h>   // Internal definitions for MS OS Desc.

/*
 *  USBCCGP signature tag for memory allocations
 */
#define USBCCGP_TAG (ULONG)'CbsU'

#define GUARD_WORD 'draG'


extern PWCHAR GenericCompositeUSBDeviceString;


enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPING,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};


typedef struct PARENT_FDO_EXTENSION {

    enum deviceState    state;

    PDRIVER_OBJECT      driverObj;
    PDEVICE_OBJECT      pdo;
    PDEVICE_OBJECT      fdo;
    PDEVICE_OBJECT      topDevObj;

    /*
     *  Counter to keep driver from getting unloaded before all IO completes to us.
     */
    LONG                pendingActionCount;
    KEVENT              removeEvent;

    /*
     *  This buffer will hold a USB_CONFIGURATION_DESCRIPTOR plus
     *  the following interface descriptors.
     */
    PUSB_CONFIGURATION_DESCRIPTOR configDesc;
    PUSB_CONFIGURATION_DESCRIPTOR selectedConfigDesc;
    USBD_CONFIGURATION_HANDLE selectedConfigHandle;

    PUSBD_INTERFACE_LIST_ENTRY interfaceList;

    USB_DEVICE_DESCRIPTOR deviceDesc;

    /*
     *  The parent device has some number of functions.
     *  For each function, we create a PDO and store
     *  it in the deviceRelations array.
     */
    ULONG               numFunctions;
    PDEVICE_RELATIONS   deviceRelations;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    PURB                dynamicNotifyUrb;

    PIRP                parentWaitWakeIrp;
    PIRP                currentSetPowerIrp;
    BOOLEAN             isWaitWakePending;
    LIST_ENTRY          functionWaitWakeIrpQueue;  // WW irps from function client drivers

    KSPIN_LOCK          parentFdoExtSpinLock;

    BOOLEAN             haveCSInterface;
    ULONG               CSInterfaceNumber;
	ULONG				CSChannelId;

    BOOLEAN             resetPortInProgress;
    LIST_ENTRY          pendingResetPortIrpQueue;

    BOOLEAN             cyclePortInProgress;
    LIST_ENTRY          pendingCyclePortIrpQueue;

    PIRP                   pendingIdleIrp;
    USB_IDLE_CALLBACK_INFO idleCallbackInfo;

    PMS_EXT_CONFIG_DESC msExtConfigDesc;

} PARENT_FDO_EXT, *PPARENT_FDO_EXT;


typedef struct FUNCTION_PDO_EXTENSION {

    ULONG               functionIndex;
    ULONG               baseInterfaceNumber;
    ULONG               numInterfaces;
    enum deviceState    state;

    PDEVICE_OBJECT      pdo;
    PPARENT_FDO_EXT     parentFdoExt;

    /*
     *  functionInterfaceList is a pointer into the parent's interfaceList array.
     */
    PUSBD_INTERFACE_LIST_ENTRY functionInterfaceList;

    PUSB_CONFIGURATION_DESCRIPTOR dynamicFunctionConfigDesc;

    USB_DEVICE_DESCRIPTOR functionDeviceDesc;

    KSPIN_LOCK functionPdoExtSpinLock;

    PIRP idleNotificationIrp;

} FUNCTION_PDO_EXT, *PFUNCTION_PDO_EXT;


typedef struct DEVICE_EXTENSION {

    ULONG signature;

    /*
     *  Does the associated device object represent
     *  the parent FDO that we attached to the device object
     *  we got from USBHUB
     *  (as opposed to the function PDO we created
     *   to represent a single function on that device) ?
     */
    BOOLEAN         isParentFdo;

    union {
        PARENT_FDO_EXT      parentFdoExt;
        FUNCTION_PDO_EXT    functionPdoExt;
    };

} DEVEXT, *PDEVEXT;


typedef struct _USB_REQUEST_TIMEOUT_CONTEXT {

    PKEVENT event;
    PLONG   lock;

} USB_REQUEST_TIMEOUT_CONTEXT, *PUSB_REQUEST_TIMEOUT_CONTEXT;


#define ALLOCPOOL(pooltype, size)   ExAllocatePoolWithTag(pooltype, size, USBCCGP_TAG)
#define FREEPOOL(ptr)               ExFreePool(ptr)

#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
#define MIN(a, b) (((a) <= (b)) ? (a) : (b))

#define POINTER_DISTANCE(ptr1, ptr2) (ULONG)(((PUCHAR)(ptr1))-((PUCHAR)(ptr2)))

//  Counting the byte count of an ascii string or wide char string
//
#define STRLEN( Length, p )\
    {\
    int i;\
    for ( i=0; (p)[i]; i++ );\
    Length = i*sizeof(*p);\
    }

/*
 *  We use this value, which is guaranteed to never be defined as a status by the kernel,
 *  as a default status code to indicate "do nothing and pass the irp down".
 */
#define NO_STATUS   0x80000000



NTSTATUS                    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING UniRegistryPath);
NTSTATUS                    USBC_AddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject);
VOID                        USBC_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS                    USBC_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS                    USBC_Create(PDEVEXT devExt, PIRP irp);
NTSTATUS                    USBC_Close(PDEVEXT devExt, PIRP irp);
NTSTATUS                    USBC_DeviceControl(PDEVEXT devExt, PIRP irp);
NTSTATUS                    USBC_SystemControl(PDEVEXT devExt, PIRP irp);
NTSTATUS                    USBC_InternalDeviceControl(PDEVEXT devExt, PIRP irp);
NTSTATUS                    USBC_PnP(PDEVEXT devExt, PIRP irp);
NTSTATUS                    USBC_PnpComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS                    USBC_Power(PDEVEXT devExt, PIRP irp);
NTSTATUS                    CreateStaticFunctionPDOs(PPARENT_FDO_EXT fdoExt);
NTSTATUS                    TryGetConfigDescriptor(PPARENT_FDO_EXT parentFdoExt);
NTSTATUS                    GetConfigDescriptor(PPARENT_FDO_EXT fdoExt);
VOID                        PrepareParentFDOForRemove(PPARENT_FDO_EXT parentFdoExt);
VOID                        FreeParentFDOResources(PPARENT_FDO_EXT fdoExt);
PWCHAR                      BuildCompatibleIDs(IN PUCHAR CompatibleID, IN PUCHAR SubCompatibleID, IN UCHAR Class, IN UCHAR SubClass, IN UCHAR Protocol);
NTSTATUS                    QueryFunctionPdoID(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
NTSTATUS                    QueryParentDeviceRelations(PPARENT_FDO_EXT parentFdoExt, PIRP irp);
NTSTATUS                    QueryFunctionDeviceRelations(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
NTSTATUS                    QueryFunctionCapabilities(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
NTSTATUS                    HandleParentFdoPower(PPARENT_FDO_EXT parentFdoExt, PIRP irp);
NTSTATUS                    HandleFunctionPdoPower(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
VOID                        ParentPowerRequestCompletion(IN PDEVICE_OBJECT devObj, IN UCHAR minorFunction, IN POWER_STATE powerState, IN PVOID context, IN PIO_STATUS_BLOCK ioStatus);
NTSTATUS                    StartParentFdo(PPARENT_FDO_EXT parentFdoExt, PIRP irp);
NTSTATUS                    QueryFunctionCapabilities(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
NTSTATUS                    ParentPdoPowerCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS                    FunctionInternalDeviceControl(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
NTSTATUS                    ParentInternalDeviceControl(PPARENT_FDO_EXT parentFdoExt, PIRP irp);
NTSTATUS                    ParentResetOrCyclePort(PPARENT_FDO_EXT parentFdoExt, PIRP irp, ULONG ioControlCode);
NTSTATUS                    BuildFunctionConfigurationDescriptor(PFUNCTION_PDO_EXT functionPdoExt, PUCHAR buffer, ULONG bufferLength, PULONG bytesReturned);
VOID                        FreeFunctionPDOResources(PFUNCTION_PDO_EXT functionPdoExt);
NTSTATUS                    GetParentFdoCapabilities(PPARENT_FDO_EXT parentFdoExt);
NTSTATUS                    CallDriverSyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context);
NTSTATUS                    CallDriverSync(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);
NTSTATUS                    CallNextDriverSync(PPARENT_FDO_EXT parentFdoExt, PIRP irp);
VOID                        IncrementPendingActionCount(PPARENT_FDO_EXT parentFdoExt);
VOID                        DecrementPendingActionCount(PPARENT_FDO_EXT parentFdoExt);
PWCHAR                      AppendInterfaceNumber(PWCHAR oldIDs, ULONG interfaceNum);
PVOID                       MemDup(PVOID dataPtr, ULONG length);
ULONG                       WStrLen(PWCHAR str);
ULONG                       WStrCpy(PWCHAR dest, PWCHAR src);
BOOLEAN                     WStrCompareN(PWCHAR str1, PWCHAR str2, ULONG maxChars);
NTSTATUS                    GetDeviceDescriptor(PPARENT_FDO_EXT parentFdoExt);
NTSTATUS                    SubmitUrb(PPARENT_FDO_EXT parentFdoExt, PURB urb, BOOLEAN synchronous, PVOID completionRoutine, PVOID completionContext);
NTSTATUS                    UrbFunctionSelectConfiguration(PFUNCTION_PDO_EXT functionPdoExt, PURB urb);
NTSTATUS                    UrbFunctionGetDescriptorFromDevice(PFUNCTION_PDO_EXT functionPdoExt, PURB urb);
PFUNCTION_PDO_EXT           FindFunctionByIndex(PPARENT_FDO_EXT parentFdoExt, ULONG functionIndex);
PUSBD_INTERFACE_LIST_ENTRY  GetFunctionInterfaceListBase(PPARENT_FDO_EXT parentFdoExt, ULONG functionIndex, PULONG numFunctionInterfaces);
PDEVICE_RELATIONS           CopyDeviceRelations(PDEVICE_RELATIONS deviceRelations);
PUSBD_INTERFACE_LIST_ENTRY  GetInterfaceList(PPARENT_FDO_EXT parentFdoExt, PUSB_CONFIGURATION_DESCRIPTOR configDesc);
VOID                        FreeInterfaceList(PPARENT_FDO_EXT parentFdoExt, BOOLEAN freeListItself);
NTSTATUS                    ParentSelectConfiguration(PPARENT_FDO_EXT parentFdoExt, PUSB_CONFIGURATION_DESCRIPTOR configDesc, PUSBD_INTERFACE_LIST_ENTRY interfaceList);
VOID                        ParentCloseConfiguration(PPARENT_FDO_EXT parentFdoExt);
NTSTATUS                    GetStringDescriptor(PPARENT_FDO_EXT parentFdoExt, UCHAR stringIndex, LANGID langId, PUSB_STRING_DESCRIPTOR stringDesc, ULONG bufferLen);
NTSTATUS                    SetPdoRegistryParameter(IN PDEVICE_OBJECT PhysicalDeviceObject, IN PWCHAR KeyName, IN PVOID Data, IN ULONG DataLength, IN ULONG KeyType, IN ULONG DevInstKeyType);
NTSTATUS                    GetPdoRegistryParameter(IN PDEVICE_OBJECT PhysicalDeviceObject, IN PWCHAR ValueName, OUT PVOID Data, IN ULONG DataLength, OUT PULONG Type, OUT PULONG ActualDataLength);
NTSTATUS                    GetMsOsFeatureDescriptor(PPARENT_FDO_EXT ParentFdoExt, UCHAR Recipient, UCHAR InterfaceNumber, USHORT Index, PVOID DataBuffer, ULONG DataBufferLength, PULONG BytesReturned);
NTSTATUS                    GetMsExtendedConfigDescriptor(IN PPARENT_FDO_EXT ParentFdoExt);
BOOLEAN                     ValidateMsExtendedConfigDescriptor(IN PMS_EXT_CONFIG_DESC MsExtConfigDesc, IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor);
NTSTATUS                    GetDeviceText(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
NTSTATUS                    EnqueueFunctionWaitWakeIrp(PFUNCTION_PDO_EXT functionPdoExt, PIRP irp);
VOID                        FunctionWaitWakeIrpCancelRoutine(IN PDEVICE_OBJECT deviceObject, IN PIRP irp);
NTSTATUS                    SubmitParentWaitWakeIrp(PPARENT_FDO_EXT parentFdoExt);
NTSTATUS                    ParentWaitWakeComplete(IN PDEVICE_OBJECT deviceObject, IN UCHAR minorFunction, IN POWER_STATE powerState, IN PVOID context, IN PIO_STATUS_BLOCK ioStatus);
VOID                        CompleteAllFunctionWaitWakeIrps(PPARENT_FDO_EXT parentFdoExt, NTSTATUS status);
VOID                        CompleteAllFunctionIdleIrps(PPARENT_FDO_EXT parentFdoExt, NTSTATUS status);
VOID                        InstallExtPropDesc(IN PFUNCTION_PDO_EXT FunctionPdoExt);
VOID                        InstallExtPropDescSections(PDEVICE_OBJECT DeviceObject, PMS_EXT_PROP_DESC pMsExtPropDesc);
NTSTATUS                    ParentDeviceControl(PPARENT_FDO_EXT parentFdoExt, PIRP irp);
VOID                        CompleteFunctionIdleNotification(PFUNCTION_PDO_EXT functionPdoExt);
VOID                        CheckParentIdle(PPARENT_FDO_EXT parentFdoExt);
NTSTATUS                    ParentSetD0(IN PPARENT_FDO_EXT parentFdoExt);
NTSTATUS                    USBC_SetContentId(IN PIRP irp, IN PVOID pKsProperty, IN PVOID pvData);
NTSTATUS                    RegQueryGenericCompositeUSBDeviceString(PWCHAR *GenericCompositeUSBDeviceString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\urbfunc.c ===
/*
 *************************************************************************
 *  File:       URBFUNC.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <stdio.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "debug.h"



/*
 *  UrbFunctionSelectConfiguration
 *
 *
 */
NTSTATUS UrbFunctionSelectConfiguration(PFUNCTION_PDO_EXT functionPdoExt, PURB urb)
{
    NTSTATUS status = NO_STATUS;

    if (urb->UrbSelectConfiguration.ConfigurationDescriptor){
        PUSBD_INTERFACE_INFORMATION urbIface = &urb->UrbSelectConfiguration.Interface;
        PUSBD_INTERFACE_LIST_ENTRY iface, funcIface = NULL;
        ULONG i;

        ASSERT(ISPTR(functionPdoExt->functionInterfaceList));

        iface = functionPdoExt->functionInterfaceList;
        for (i = 0; i < functionPdoExt->numInterfaces; i++){
            if (iface->Interface->InterfaceNumber == urbIface->InterfaceNumber){
                funcIface = iface;
                break;
            }
            iface++;
        }

        if (funcIface && funcIface->Interface){
            BOOLEAN sendSelectIface = FALSE;
            BOOLEAN selectAltIface = FALSE;

            /*
             *  To service the client's SELECT_CONFIGURATION call, we only need to
             *  call the parent if the client is:
             *      1.  Selecting a different alternate interface
             *          or
             *      2.  Changing the MaximumTransferSize for one of the pipes.
             *
             *  In either of those cases, we send down a SELECT_INTERFACE request.
             */
            if (funcIface->Interface->AlternateSetting != urbIface->AlternateSetting){
                DBGWARN(("Coverage: Changing alt iface in UrbFunctionSelectConfiguration (iface #%xh from %xh to %xh).", urbIface->InterfaceNumber, funcIface->Interface->AlternateSetting, urbIface->AlternateSetting));
                sendSelectIface = TRUE;
                selectAltIface = TRUE;
            }
            else {
                ULONG numPipes;
//
// We shouldn't be looking at NumberOfPipes in the URB because this is an
// OUTPUT field.
//                ASSERT(urbIface->NumberOfPipes == funcIface->Interface->NumberOfPipes);
//                numPipes = MIN(urbIface->NumberOfPipes, funcIface->Interface->NumberOfPipes);
                numPipes = funcIface->Interface->NumberOfPipes;
                for (i = 0; i < numPipes; i++){
                    if (urbIface->Pipes[i].MaximumTransferSize != funcIface->Interface->Pipes[i].MaximumTransferSize){
                        DBGWARN(("Coverage: Changing MaximumTransferSize in UrbFunctionSelectConfiguration (from %xh to %xh).", funcIface->Interface->Pipes[i].MaximumTransferSize, urbIface->Pipes[i].MaximumTransferSize));
                        sendSelectIface = TRUE;
                    }
                }
            }

            if (sendSelectIface){
                PURB selectIfaceUrb;
                USHORT size;
//
// BUT, when choosing an alternate interface, we must use the NumberOfPipes in
// the URB.
//
                if (selectAltIface){
                    size = (USHORT)(GET_SELECT_INTERFACE_REQUEST_SIZE(urbIface->NumberOfPipes));
                }
                else {
                    size = (USHORT)(GET_SELECT_INTERFACE_REQUEST_SIZE(funcIface->Interface->NumberOfPipes));
                }
                selectIfaceUrb = ALLOCPOOL(NonPagedPool, size);
                if (selectIfaceUrb){
                    PUSBD_INTERFACE_INFORMATION selectIface = &selectIfaceUrb->UrbSelectInterface.Interface;

                    selectIfaceUrb->UrbSelectInterface.Hdr.Function = URB_FUNCTION_SELECT_INTERFACE;
                    selectIfaceUrb->UrbSelectInterface.Hdr.Length = size;
                    ASSERT(functionPdoExt->parentFdoExt->selectedConfigHandle);
                    selectIfaceUrb->UrbSelectInterface.ConfigurationHandle = functionPdoExt->parentFdoExt->selectedConfigHandle;

                    RtlCopyMemory(selectIface, urbIface, urbIface->Length);
                    status = SubmitUrb(functionPdoExt->parentFdoExt, selectIfaceUrb, TRUE, NULL, NULL);
                    if (NT_SUCCESS(status)){
                        /*
                         *  Replace the old PUSBD_INTERFACE_INFORMATION
                         *  (which we got when we did select-configuration for the parent)
                         *  with the new one.
                         */
                        ASSERT(funcIface->Interface);
                        FREEPOOL(funcIface->Interface);
                        funcIface->Interface = MemDup(selectIface, selectIface->Length);
                        if (!funcIface->Interface){
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }
                    else {
                        ASSERT(NT_SUCCESS(status));
                    }

                    FREEPOOL(selectIfaceUrb);
                }
                else {
                    ASSERT(selectIfaceUrb);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else {
                status = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(status)){
                /*
                 *  Copy the interface information
                 */
                ASSERT(urbIface->Length == funcIface->Interface->Length);
                RtlCopyMemory(urbIface, funcIface->Interface, funcIface->Interface->Length);

                ASSERT(functionPdoExt->parentFdoExt->selectedConfigHandle);
                urb->UrbSelectConfiguration.ConfigurationHandle = functionPdoExt->parentFdoExt->selectedConfigHandle;
            }
        }
        else {
            DBGERR(("invalid interface number"));
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else {
        DBGVERBOSE(("FunctionInternalDeviceControl - closing configuration"));
        status = STATUS_SUCCESS;
    }

    return status;
}


/*
 *  UrbFunctionGetDescriptorFromDevice
 *
 *
 *      Note:  this function cannot be pageable because internal
 *             ioctls may be sent at IRQL==DISPATCH_LEVEL.
 */
NTSTATUS UrbFunctionGetDescriptorFromDevice(PFUNCTION_PDO_EXT functionPdoExt, PURB urb)
{
    NTSTATUS status;

    switch (urb->UrbControlDescriptorRequest.DescriptorType){

        case USB_DEVICE_DESCRIPTOR_TYPE:
            DBGVERBOSE(("  USB_DEVICE_DESCRIPTOR_TYPE"));
            if (urb->UrbControlDescriptorRequest.TransferBufferLength >= sizeof(USB_DEVICE_DESCRIPTOR)){
                RtlCopyMemory(  urb->UrbControlDescriptorRequest.TransferBuffer,
                                &functionPdoExt->functionDeviceDesc,
                                sizeof(USB_DEVICE_DESCRIPTOR));
                status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            urb->UrbControlDescriptorRequest.TransferBufferLength = sizeof(USB_DEVICE_DESCRIPTOR);
            break;

        case USB_CONFIGURATION_DESCRIPTOR_TYPE:
            DBGVERBOSE(("  USB_CONFIGURATION_DESCRIPTOR_TYPE"));
            status = BuildFunctionConfigurationDescriptor(
                            functionPdoExt,
                            urb->UrbControlDescriptorRequest.TransferBuffer,
                            urb->UrbControlDescriptorRequest.TransferBufferLength,
                            &urb->UrbControlDescriptorRequest.TransferBufferLength);
            break;

        default:
            /*
             *  Return NO_STATUS so that URB gets passed down to USBHUB.
             */
            DBGVERBOSE(("UrbFunctionGetDescriptorFromDevice: Unhandled desc type: %xh.", (ULONG)urb->UrbControlDescriptorRequest.DescriptorType));
            status = NO_STATUS;
            break;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\config.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    CONFIG.C

Abstract:

    This module contains the code to process the select configuration
    and select interface commands.

Environment:

    kernel mode only

Notes:


Revision History:

    01-10-96 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"        //public data structures
#include "hcdi.h"

#include "usbd.h"        //private data strutures


#ifdef USBD_DRIVER      // USBPORT supercedes most of USBD, so we will remove
                        // the obsolete code by compiling it only if
                        // USBD_DRIVER is set.

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBD_InternalParseConfigurationDescriptor)
#pragma alloc_text(PAGE, USBD_InitializeConfigurationHandle)
#pragma alloc_text(PAGE, USBD_InternalInterfaceBusy)
#pragma alloc_text(PAGE, USBD_InternalOpenInterface)
#pragma alloc_text(PAGE, USBD_SelectConfiguration)
#pragma alloc_text(PAGE, USBD_InternalCloseConfiguration)
#pragma alloc_text(PAGE, USBD_SelectInterface)
#endif
#endif


USBD_PIPE_TYPE PipeTypes[4] = {UsbdPipeTypeControl, UsbdPipeTypeIsochronous,
                                    UsbdPipeTypeBulk, UsbdPipeTypeInterrupt};


PUSB_INTERFACE_DESCRIPTOR
USBD_InternalParseConfigurationDescriptor(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN UCHAR InterfaceNumber,
    IN UCHAR AlternateSetting,
    PBOOLEAN HasAlternateSettings
    )
/*++

Routine Description:

    Get the configuration descriptor for a given device.

Arguments:

    DeviceObject -

    DeviceData -

    Urb -

    ConfigurationDescriptor -

Return Value:


--*/
{
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptorSetting = NULL;
    PUCHAR pch = (PUCHAR) ConfigurationDescriptor, end;
    ULONG i, len;
    PUSB_COMMON_DESCRIPTOR commonDescriptor;

    PAGED_CODE();
    if (HasAlternateSettings) {
        *HasAlternateSettings = FALSE;
    }

    commonDescriptor =
        (PUSB_COMMON_DESCRIPTOR) (pch + ConfigurationDescriptor->bLength);

    while (commonDescriptor->bDescriptorType != USB_INTERFACE_DESCRIPTOR_TYPE) {
        ((PUCHAR)(commonDescriptor))+= commonDescriptor->bLength;
    }

    interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) commonDescriptor;
    ASSERT(interfaceDescriptor->bDescriptorType ==
                USB_INTERFACE_DESCRIPTOR_TYPE);

    end = pch + ConfigurationDescriptor->wTotalLength;

    //
    // First find the matching InterfaceNumber
    //
    while (pch < end && interfaceDescriptor->bInterfaceNumber != InterfaceNumber) {
        pch = (PUCHAR) interfaceDescriptor;
        len = USBD_InternalGetInterfaceLength(interfaceDescriptor, end);
        if (len == 0) {
            // Descriptors are bad, fail.
            interfaceDescriptorSetting = NULL;
            goto USBD_InternalParseConfigurationDescriptor_exit;
        }
        pch += len;

        // point to the next interface
        interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) pch;
#if DBG
        if (pch < end) {
            ASSERT(interfaceDescriptor->bDescriptorType ==
                    USB_INTERFACE_DESCRIPTOR_TYPE);
        }
#endif //MAX_DEBUG
    }

#ifdef MAX_DEBUG
    if (pch >= end) {
        USBD_KdPrint(3, ("'Interface %x alt %x not found!\n", InterfaceNumber,
            AlternateSetting));
        TEST_TRAP();
    }
#endif //MAX_DEBUG

    i = 0;
    // Now find the proper alternate setting
    while (pch < end && interfaceDescriptor->bInterfaceNumber == InterfaceNumber) {

        if (interfaceDescriptor->bAlternateSetting == AlternateSetting) {
            interfaceDescriptorSetting = interfaceDescriptor;
        }

        pch = (PUCHAR) interfaceDescriptor;
        len = USBD_InternalGetInterfaceLength(interfaceDescriptor, end);
        if (len == 0) {
            // Descriptors are bad, fail.
            interfaceDescriptorSetting = NULL;
            goto USBD_InternalParseConfigurationDescriptor_exit;
        }
        pch += len;

        // point to next interface
        interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR) pch;
#if DBG
        if (pch < end) {
            ASSERT(interfaceDescriptor->bDescriptorType ==
                    USB_INTERFACE_DESCRIPTOR_TYPE);
        }
#endif
        i++;
    }

    if (i>1 && HasAlternateSettings) {
        *HasAlternateSettings = TRUE;
        USBD_KdPrint(3, ("'device has alternate settings!\n"));
    }

USBD_InternalParseConfigurationDescriptor_exit:

    return interfaceDescriptorSetting;
}


NTSTATUS
USBD_InitializeConfigurationHandle(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN ULONG NumberOfInterfaces,
    IN OUT PUSBD_CONFIG *ConfigHandle
    )
/*++

Routine Description:

    Initialize the configuration handle structure

Arguments:

    DeviceData -

    DeviceObject -

    ConfigurationDescriptor -

    ConfigHandle -

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_CONFIG configHandle;
    ULONG i;

    PAGED_CODE();
    USBD_KdPrint(3, ("' enter USBD_InitializeConfigurationHandle\n"));

    USBD_ASSERT(ConfigurationDescriptor->bNumInterfaces > 0);

    configHandle = GETHEAP(PagedPool,
                           sizeof(USBD_CONFIG) +
                                 sizeof(PUSBD_INTERFACE) *
                                 (NumberOfInterfaces-1));

    if (configHandle) {

        configHandle->ConfigurationDescriptor =
            GETHEAP(PagedPool, ConfigurationDescriptor->wTotalLength);

        if (configHandle->ConfigurationDescriptor) {

            RtlCopyMemory(configHandle->ConfigurationDescriptor,
                          ConfigurationDescriptor,
                          ConfigurationDescriptor->wTotalLength);
            configHandle->Sig = SIG_CONFIG;
            *ConfigHandle = configHandle;

            //
            // Initilaize the interface handles
            //

            for (i=0; i< NumberOfInterfaces; i++) {
                configHandle->InterfaceHandle[i] = NULL;
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            RETHEAP(configHandle);
        }
    } else
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    USBD_KdPrint(3, ("' exit USBD_InitializeConfigurationHandle 0x%x\n", ntStatus));

    return ntStatus;
}


BOOLEAN
USBD_InternalInterfaceBusy(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_INTERFACE InterfaceHandle
    )
/*++

Routine Description:


Arguments:

    DeviceObject - deviceobject for specific BUS

    DeviceData - device data structure for specific device

    InterfaceHandle - Interface Handle to close

Return Value:


--*/
{
    BOOLEAN busy = FALSE;
    ULONG i, endpointState;
    NTSTATUS ntStatus;
    USBD_STATUS usbdStatus;

    PAGED_CODE();
    USBD_KdPrint(3, ("' enter USBD_InternalInterfaceBusy\n"));

    for (i=0; i<InterfaceHandle->InterfaceDescriptor.bNumEndpoints; i++) {

        USBD_KdPrint(3, ("'checking pipe %x\n", &InterfaceHandle->PipeHandle[i]));

        if (!PIPE_CLOSED(&InterfaceHandle->PipeHandle[i])) {
            // get the state of the endpoint
            ntStatus = USBD_GetEndpointState(DeviceData,
                                             DeviceObject,
                                             &InterfaceHandle->PipeHandle[i],
                                             &usbdStatus,
                                             &endpointState);

            if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(usbdStatus) &&
                (endpointState & HCD_ENDPOINT_TRANSFERS_QUEUED)) {
                busy = TRUE;
                break;
            }
        }
    }

    USBD_KdPrint(3, ("' exit USBD_InternalInterfaceBusy %d\n", busy));

    return busy;
}


NTSTATUS
USBD_InternalOpenInterface(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_CONFIG ConfigHandle,
    IN OUT PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN OUT PUSBD_INTERFACE *InterfaceHandle,
    IN BOOLEAN SendSetInterfaceCommand,
    IN PBOOLEAN NoBandwidth
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

    DeviceData - USBD device handle for this device.

    ConfigHandle - USBD configuration handle.

    InterfaceInformation - pointer to USBD interface information structure
        passed in by the client.
        On success the .Length field is filled in with the actual length
        of the interface_information structure and the Pipe[] fields are filled
        in with the handles for the opened pipes.

    InterfaceHandle - pointer to an interface handle pointer, filled in
        with the allocated interface handle structure if NULL otherwise the
        structure passed in is used.

    SendSetInterfaceCommand - indicates if the set_interface command should be
        sent.

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    NTSTATUS ntStatusHold = STATUS_SUCCESS;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    BOOLEAN hasAlternateSettings;
    PUSBD_INTERFACE interfaceHandle = NULL;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUCHAR pch;
    ULONG i;
    BOOLEAN allocated = FALSE;
    PUSB_COMMON_DESCRIPTOR descriptor;

    PAGED_CODE();
    if (NoBandwidth) {
        *NoBandwidth = FALSE;
    }
//    LOGENTRY("ioIf", DeviceData, ConfigHandle, SendSetInterfaceCommand);
    ASSERT_CONFIG(ConfigHandle);

#ifdef MAX_DEBUG
    if (*InterfaceHandle != NULL) {
        // using a previously allocated interface handle
        ASSERT_INTERFACE(*InterfaceHandle);
        TEST_TRAP();
    }
#endif

    USBD_KdPrint(3, ("' enter USBD_InternalOpenInterface\n"));
    USBD_KdPrint(3, ("' Interface %d Altsetting %d\n",
        InterfaceInformation->InterfaceNumber,
        InterfaceInformation->AlternateSetting));

    //
    // Find the interface descriptor we are interested in inside
    // the configuration descriptor.
    //

    interfaceDescriptor =
        USBD_InternalParseConfigurationDescriptor(ConfigHandle->ConfigurationDescriptor,
                                          InterfaceInformation->InterfaceNumber,
                                          InterfaceInformation->AlternateSetting,
                                          &hasAlternateSettings);

    //
    // We got the interface descriptor, now try
    // to open all the pipes.
    //

    if (interfaceDescriptor) {
        USHORT need;

        USBD_KdPrint(3, ("'Interface Descriptor\n"));
        USBD_KdPrint(3, ("'bLength 0x%x\n", interfaceDescriptor->bLength));
        USBD_KdPrint(3, ("'bDescriptorType 0x%x\n", interfaceDescriptor->bDescriptorType));
        USBD_KdPrint(3, ("'bInterfaceNumber 0x%x\n", interfaceDescriptor->bInterfaceNumber));
        USBD_KdPrint(3, ("'bAlternateSetting 0x%x\n", interfaceDescriptor->bAlternateSetting));
        USBD_KdPrint(3, ("'bNumEndpoints 0x%x\n", interfaceDescriptor->bNumEndpoints));

        // found the requested interface in the configuration descriptor.

        // Here is where we verify there is enough room in the client
        // buffer since we know how many pipes we'll need based on the
        // interface descriptor.

        need = (USHORT) ((interfaceDescriptor->bNumEndpoints * sizeof(USBD_PIPE_INFORMATION) +
                sizeof(USBD_INTERFACE_INFORMATION)));

        USBD_KdPrint(3, ("'Interface.Length = %d need = %d\n", InterfaceInformation->Length, need));

        if (InterfaceInformation->Length < need) {
            TEST_TRAP();
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        } else if (hasAlternateSettings && SendSetInterfaceCommand) {

            //
            // If we have alternate settings we need
            // to send the set interface command.
            //

            ntStatus = USBD_SendCommand(DeviceData,
                                        DeviceObject,
                                        STANDARD_COMMAND_SET_INTERFACE,
                                        InterfaceInformation->AlternateSetting,
                                        InterfaceInformation->InterfaceNumber,
                                        0,
                                        NULL,
                                        0,
                                        NULL,
                                        &usbdStatus);
        }

        if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(usbdStatus)) {

            //
            // we successfully selected the alternate interface
            // initialize the interface handle and open the pipes
            //

            if (*InterfaceHandle == NULL) {
                interfaceHandle = GETHEAP(NonPagedPool,
                                      sizeof(USBD_INTERFACE) +
                                      sizeof(USBD_PIPE) * interfaceDescriptor->bNumEndpoints +
                                      need);
                if (interfaceHandle) {
                    interfaceHandle->InterfaceInformation =
                    (PUSBD_INTERFACE_INFORMATION)
                        ((PUCHAR) interfaceHandle +
                            sizeof(USBD_INTERFACE) +
                            sizeof(USBD_PIPE) * interfaceDescriptor->bNumEndpoints);
                    allocated = TRUE;
                }
            } else {
                // using old handle
                interfaceHandle = *InterfaceHandle;
            }

            if (interfaceHandle) {
                interfaceHandle->Sig = SIG_INTERFACE;
                interfaceHandle->HasAlternateSettings = hasAlternateSettings;

                InterfaceInformation->NumberOfPipes = interfaceDescriptor->bNumEndpoints;
                InterfaceInformation->Class =
                    interfaceDescriptor->bInterfaceClass;
                InterfaceInformation->SubClass =
                     interfaceDescriptor->bInterfaceSubClass;
                InterfaceInformation->Protocol =
                     interfaceDescriptor->bInterfaceProtocol;
                InterfaceInformation->Reserved =
                     0;
                // start with first endpoint
                // skip over any non-endpoint descriptors
                pch = (PUCHAR) (interfaceDescriptor) +
                    interfaceDescriptor->bLength;

                //
                // initialize all endpoints to closed state
                //

                for (i=0; i<interfaceDescriptor->bNumEndpoints; i++) {
                    interfaceHandle->PipeHandle[i].HcdEndpoint = NULL;
                }

                interfaceHandle->InterfaceDescriptor = *interfaceDescriptor;
                for (i=0; i<interfaceDescriptor->bNumEndpoints; i++) {

                    descriptor = (PUSB_COMMON_DESCRIPTOR) pch;
                    while (descriptor->bDescriptorType != USB_ENDPOINT_DESCRIPTOR_TYPE) {
                        pch += descriptor->bLength;
                        descriptor = (PUSB_COMMON_DESCRIPTOR) pch;
                    }

                    endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR) pch;
                    ASSERT(endpointDescriptor->bDescriptorType ==
                        USB_ENDPOINT_DESCRIPTOR_TYPE);

                    USBD_KdPrint(3, ("'Endpoint Descriptor\n"));
                    USBD_KdPrint(3, ("'bLength 0x%x\n", endpointDescriptor->bLength));
                    USBD_KdPrint(3, ("'bDescriptorType 0x%x\n", endpointDescriptor->bDescriptorType));
                    USBD_KdPrint(3, ("'bMaxPacket 0x%x\n", endpointDescriptor->wMaxPacketSize));
                    USBD_KdPrint(3, ("'bInterval 0x%x\n", endpointDescriptor->bInterval));
                    USBD_KdPrint(3, ("'bmAttributes 0x%x\n", endpointDescriptor->bmAttributes));
                    USBD_KdPrint(3, ("'bEndpointAddress 0x%x\n", endpointDescriptor->bEndpointAddress));
                    USBD_KdPrint(3, ("'MaxTransferSize 0x%x\n", InterfaceInformation->Pipes[i].MaximumTransferSize));

#if DBG
                    if (InterfaceInformation->Pipes[i].PipeFlags & ~ USBD_PF_VALID_MASK) {
                        // client driver may have uninitialized pipe flags
                        TEST_TRAP();
                    }
#endif

                    // init pipe flags
                    interfaceHandle->PipeHandle[i].UsbdPipeFlags =
                        InterfaceInformation->Pipes[i].PipeFlags;

                    if (InterfaceInformation->Pipes[i].PipeFlags &
                        USBD_PF_CHANGE_MAX_PACKET) {
                        // client want sto override original max_packet
                        // size in endpoint descriptor
                         endpointDescriptor->wMaxPacketSize =
                            InterfaceInformation->Pipes[i].MaximumPacketSize;

                        USBD_KdPrint(3,
                            ("'new bMaxPacket 0x%x\n", endpointDescriptor->wMaxPacketSize));
                    }

                    //
                    // copy the endpoint descriptor into the
                    // pipe handle structure.
                    //

                    RtlCopyMemory(&interfaceHandle->PipeHandle[i].EndpointDescriptor,
                                   pch,
                                   sizeof(interfaceHandle->PipeHandle[i].EndpointDescriptor) );

                    // advance to next endpoint
                    // first field in endpoint descriptor is length
                    pch += endpointDescriptor->bLength;

                    interfaceHandle->PipeHandle[i].MaxTransferSize =
                        InterfaceInformation->Pipes[i].MaximumTransferSize;

                    ntStatus = USBD_OpenEndpoint(DeviceData,
                                                 DeviceObject,
                                                 &interfaceHandle->PipeHandle[i],
                                                 &usbdStatus,
                                                 FALSE);

                    //
                    // return information about the pipe
                    //

                    InterfaceInformation->Pipes[i].EndpointAddress =
                        endpointDescriptor->bEndpointAddress;
                    InterfaceInformation->Pipes[i].PipeType =
                        PipeTypes[endpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK];
                    InterfaceInformation->Pipes[i].MaximumPacketSize =
                        endpointDescriptor->wMaxPacketSize;
                    InterfaceInformation->Pipes[i].Interval =
                        endpointDescriptor->bInterval;

                    if (NT_SUCCESS(ntStatus)) {

                        InterfaceInformation->Pipes[i].PipeHandle = &interfaceHandle->PipeHandle[i];

                        USBD_KdPrint(3, ("'pipe handle = 0x%x\n", InterfaceInformation->Pipes[i].PipeHandle ));

                    } else {
                        USBD_KdPrint(1,
                            ("'error opening one of the pipes in interface (%x)\n", usbdStatus));
                        if (usbdStatus == USBD_STATUS_NO_BANDWIDTH &&
                            NoBandwidth) {
                            *NoBandwidth = TRUE;
                        }
                        ntStatusHold = ntStatus;    // Remember ntStatus for later.
                    }
                }

            } else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (!NT_SUCCESS(ntStatusHold)) {
                ntStatus = ntStatusHold;    // Get back any error condition.
            }

            if (NT_SUCCESS(ntStatus)) {

                //
                // successfully opened the interface, return the handle
                //

                *InterfaceHandle =
                    InterfaceInformation->InterfaceHandle = interfaceHandle;

                //
                // set the length properly
                //

                InterfaceInformation->Length = (USHORT)
                    ((sizeof(USBD_INTERFACE_INFORMATION) ) +
                     sizeof(USBD_PIPE_INFORMATION) *
                     interfaceDescriptor->bNumEndpoints);

                // make a copy of the interface information
                RtlCopyMemory(interfaceHandle->InterfaceInformation,
                              InterfaceInformation,
                              InterfaceInformation->Length);

            } else {

                //
                // had a problem, go back thru and close anything we opened.
                //

                if (interfaceHandle) {

                    for (i=0; i<interfaceDescriptor->bNumEndpoints; i++) {
                        if (!PIPE_CLOSED(&interfaceHandle->PipeHandle[i])) {

                            USBD_KdPrint(3, ("'open interface cleanup -- closing endpoint %x\n",
                                          &interfaceHandle->PipeHandle[i]));

                            //
                            // if this guy fails we just drop the endpoint
                            // on the floor
                            //

                            USBD_CloseEndpoint(DeviceData,
                                               DeviceObject,
                                               &interfaceHandle->PipeHandle[i],
                                               NULL);

                        }
                    }

                    if (allocated) {
                        RETHEAP(interfaceHandle);
                    }
                }
            }
        }
#ifdef MAX_DEBUG
          else {
            //
            // interface length was too small, or device failed the select
            // interface request.
            //
            TEST_TRAP();
        }
#endif
    } else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

//    LOGENTRY("ioIx", 0, 0, ntStatus);
    USBD_KdPrint(3, ("' exit USBD_InternalOpenInterface 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_InternalRestoreInterface(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_CONFIG ConfigHandle,
    IN OUT PUSBD_INTERFACE InterfaceHandle
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION interfaceInformation;
    ULONG i;

    PAGED_CODE();
//    LOGENTRY("ioIf", DeviceData, ConfigHandle, SendSetInterfaceCommand);
    ASSERT_CONFIG(ConfigHandle);

    // using a previously allocated interface handle
    ASSERT_INTERFACE(InterfaceHandle);

    if (!InterfaceHandle) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBD_InternalRestoreInterfaceExit;
    }

    interfaceDescriptor = &InterfaceHandle->InterfaceDescriptor;
    interfaceInformation = InterfaceHandle->InterfaceInformation;


    USBD_KdPrint(3, ("' enter USBD_InternalRestoreInterface\n"));
    USBD_KdPrint(3, ("' Interface %d Altsetting %d\n",
        interfaceInformation->InterfaceNumber,
        interfaceInformation->AlternateSetting));

    //
    // We got the interface descriptor, now try
    // to open all the pipes.
    //

    USBD_KdPrint(3, ("'Interface Descriptor\n"));
    USBD_KdPrint(3, ("'bLength 0x%x\n", interfaceDescriptor->bLength));
    USBD_KdPrint(3, ("'bDescriptorType 0x%x\n", interfaceDescriptor->bDescriptorType));
    USBD_KdPrint(3, ("'bInterfaceNumber 0x%x\n", interfaceDescriptor->bInterfaceNumber));
    USBD_KdPrint(3, ("'bAlternateSetting 0x%x\n", interfaceDescriptor->bAlternateSetting));
    USBD_KdPrint(3, ("'bNumEndpoints 0x%x\n", interfaceDescriptor->bNumEndpoints));

    // found the requested interface in the configuration descriptor.

    // Here is where we verify there is enough room in the client
    // buffer since we know how many pipes we'll need based on the
    // interface descriptor.

#if 0
    need = (USHORT) ((interfaceDescriptor->bNumEndpoints * sizeof(USBD_PIPE_INFORMATION) +
            sizeof(USBD_INTERFACE_INFORMATION)));

    USBD_KdPrint(3, ("'Interface.Length = %d need = %d\n", interfaceInformation->Length, need));
#endif
    if (InterfaceHandle->HasAlternateSettings) {

        //
        // If we have alternate settings we need
        // to send the set interface command.
        //

        ntStatus = USBD_SendCommand(DeviceData,
                                    DeviceObject,
                                    STANDARD_COMMAND_SET_INTERFACE,
                                    interfaceInformation->AlternateSetting,
                                    interfaceInformation->InterfaceNumber,
                                    0,
                                    NULL,
                                    0,
                                    NULL,
                                    &usbdStatus);
    }

    if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(usbdStatus)) {

        //
        // we successfully selected the alternate interface
        // initialize the interface handle and open the pipes
        //

        ASSERT(interfaceInformation->NumberOfPipes ==
            interfaceDescriptor->bNumEndpoints);
        ASSERT(interfaceInformation->Class ==
                interfaceDescriptor->bInterfaceClass);
        ASSERT(interfaceInformation->SubClass ==
                 interfaceDescriptor->bInterfaceSubClass);
        ASSERT(interfaceInformation->Protocol ==
                 interfaceDescriptor->bInterfaceProtocol);

        //
        // initialize all endpoints to closed state
        //

        for (i=0; i<interfaceDescriptor->bNumEndpoints; i++) {
            InterfaceHandle->PipeHandle[i].HcdEndpoint = NULL;
        }

        for (i=0; i<interfaceDescriptor->bNumEndpoints; i++) {

            endpointDescriptor =
                &InterfaceHandle->PipeHandle[i].EndpointDescriptor;

            ASSERT(endpointDescriptor->bDescriptorType ==
                USB_ENDPOINT_DESCRIPTOR_TYPE);

            USBD_KdPrint(3, ("'Endpoint Descriptor\n"));
            USBD_KdPrint(3, ("'bLength 0x%x\n", endpointDescriptor->bLength));
            USBD_KdPrint(3, ("'bDescriptorType 0x%x\n", endpointDescriptor->bDescriptorType));
            USBD_KdPrint(3, ("'bMaxPacket 0x%x\n", endpointDescriptor->wMaxPacketSize));
            USBD_KdPrint(3, ("'bInterval 0x%x\n", endpointDescriptor->bInterval));
            USBD_KdPrint(3, ("'bmAttributes 0x%x\n", endpointDescriptor->bmAttributes));
            USBD_KdPrint(3, ("'bEndpointAddress 0x%x\n", endpointDescriptor->bEndpointAddress));
            USBD_KdPrint(3, ("'MaxTransferSize 0x%x\n", interfaceInformation->Pipes[i].MaximumTransferSize));

            //
            // open the eendpoint again
            //

            ntStatus = USBD_OpenEndpoint(DeviceData,
                                         DeviceObject,
                                         &InterfaceHandle->PipeHandle[i],
                                         NULL,
                                         FALSE);

            if (NT_SUCCESS(ntStatus)) {
                //
                // return information about the pipe
                //
                ASSERT(interfaceInformation->Pipes[i].EndpointAddress ==
                    endpointDescriptor->bEndpointAddress);
                ASSERT(interfaceInformation->Pipes[i].PipeType ==
                    PipeTypes[endpointDescriptor->bmAttributes & USB_ENDPOINT_TYPE_MASK]);
                ASSERT(interfaceInformation->Pipes[i].MaximumPacketSize ==
                    endpointDescriptor->wMaxPacketSize);
                ASSERT(interfaceInformation->Pipes[i].Interval ==
                    endpointDescriptor->bInterval);
                ASSERT(interfaceInformation->Pipes[i].PipeHandle ==
                    &InterfaceHandle->PipeHandle[i]);

                USBD_KdPrint(3, ("'pipe handle = 0x%x\n", interfaceInformation->Pipes[i].PipeHandle ));

            } else {
                USBD_KdPrint(3, ("'error opening one of the pipes in an interface\n"));
                TEST_TRAP();
                break;
            }
        }

    } else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

USBD_InternalRestoreInterfaceExit:

//    LOGENTRY("ioIx", 0, 0, ntStatus);
    USBD_KdPrint(3, ("' exit USBD_InternalRestoreInterface 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_InternalRestoreConfiguration(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_CONFIG ConfigHandle
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    USBD_STATUS usbdStatus = USBD_STATUS_SUCCESS;
    ULONG i;
    BOOLEAN noBandwidth = FALSE;

    if (!ConfigHandle) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBD_InternalRestoreConfigurationExit;
    }

    configurationDescriptor = ConfigHandle->ConfigurationDescriptor;

    ntStatus = USBD_SendCommand(DeviceData,
                                DeviceObject,
                                STANDARD_COMMAND_SET_CONFIGURATION,
                                configurationDescriptor->bConfigurationValue,
                                0,
                                0,
                                NULL,
                                0,
                                NULL,
                                &usbdStatus);

    USBD_KdPrint(3, ("' SendCommand, SetConfiguration returned 0x%x\n", ntStatus));

    if (NT_SUCCESS(ntStatus)) {

        for (i=0; i<configurationDescriptor->bNumInterfaces; i++) {

            ntStatus = USBD_InternalRestoreInterface(DeviceData,
                                                     DeviceObject,
                                                     ConfigHandle,
                                                     ConfigHandle->InterfaceHandle[i]);

            USBD_KdPrint(3, ("' InternalRestoreInterface returned 0x%x\n", ntStatus));

            if (!NT_SUCCESS(ntStatus)) {
                TEST_TRAP();
                break;
            }
        }
    }

USBD_InternalRestoreConfigurationExit:

    return ntStatus;
}


NTSTATUS
USBD_SelectConfiguration(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Open a configuration for a USB device.

    Client will pass in a buffer that looks like this:

    -----------------
    Config Info
        - client inputs:
            Length of entire URB
            ConfigurationDescriptor
        - class driver outputs:
            ConfigurationHandle

    -----------------
    Interface Info 0  one of these for each interface in the
                        configuration
        - client inputs:
            InterfaceNumber        (can be zero)
            AlternateSetting    (can be zero)

        - class driver outputs:
            Length
            InterfaceHandle

    -----------------
    pipe info 0,0      one of these for each pipe in the
                        interface
        - client inputs:

        - class driver outputs:
    -----------------
    pipe info 0,1

    -----------------
    Interface  Info 1

    -----------------
    pipe info 1, 0

    -----------------
    pipe info 1, 1

    -----------------
    ...

    On input:
    The Config Info must specify the number of interfaces
    in the configuration

    The Interface Info will specify a specific alt setting
    to be selected for the interface.


    1. First we look at the configuration descriptor for the
        requested configuration and validate the client
        input buffer agianst it.

    2. We open the interfaces for the requested configuration
        and open the pipes within those interfaces, setting
        alt settings were appropriate.

    3. We set the configuration for the device with the
        appropriate control request.

Arguments:

    DeviceObject -

    Irp -  IO request block

    Urb -  ptr to USB request block

    IrpIsPending -

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_CONFIG configHandle = NULL;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;
    PUSBD_INTERFACE_INFORMATION interfaceInformation;
    PUCHAR pch;
    ULONG i;
    PUSBD_EXTENSION deviceExtension;
    ULONG numInterfaces;
    PUCHAR end;
    BOOLEAN noBandwidth = FALSE;

    PAGED_CODE();
    USBD_KdPrint(3, ("' enter USBD_SelectConfiguration\n"));

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    USBD_WaitForUsbDeviceMutex(deviceExtension);

    deviceData = Urb->UrbHeader.UsbdDeviceHandle;

    if (deviceData == NULL) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBD_SelectConfiguration_Done;
    }

    //
    // dump old configuration data if we have any
    //

    if (deviceData->ConfigurationHandle) {
        // This is where we close the old configuration
        // handle, all pipes and all interfaces.

        ntStatus = USBD_InternalCloseConfiguration(deviceData,
                                                   DeviceObject,
                                                   &Urb->UrbSelectConfiguration.Status,
                                                   FALSE,
                                                   FALSE);

        if (!USBD_SUCCESS(Urb->UrbSelectConfiguration.Status) ||
            !NT_SUCCESS(ntStatus)) {
            //
            // if we got an error closing the current
            // config then abort the select configuration operation.
            //
            goto USBD_SelectConfiguration_Done;
        }
    }

    configurationDescriptor =
        Urb->UrbSelectConfiguration.ConfigurationDescriptor;

    //
    // if null pased in set configuration to 0
    // 'unconfigured'
    //

    if (configurationDescriptor == NULL) {

        // device needs to be in the unconfigured state

        //
        // This may fail if the configuration is being
        // closed as the result of the device being unplugged
        //
        ntStatus = USBD_SendCommand(deviceData,
                                    DeviceObject,
                                    STANDARD_COMMAND_SET_CONFIGURATION,
                                    0,
                                    0,
                                    0,
                                    NULL,
                                    0,
                                    NULL,
                                    &Urb->UrbSelectConfiguration.Status);

        goto USBD_SelectConfiguration_Done;
    }

    //
    // count the number of interfaces to process in this
    // request
    //

    pch = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;
    numInterfaces = 0;
    end = ((PUCHAR) Urb) + Urb->UrbSelectConfiguration.Length;

    do {
        numInterfaces++;

        interfaceInformation = (PUSBD_INTERFACE_INFORMATION) pch;
        pch+=interfaceInformation->Length;

    } while (pch < end);

    USBD_KdPrint(3, ("'USBD_SelectConfiguration -- %d interfaces\n", numInterfaces));

    if (numInterfaces != configurationDescriptor->bNumInterfaces) {
        //
        // driver is broken, config request does not match
        // config descriptor passes in!!!
        //
        USBD_KdTrap(
            ("config request does not match config descriptor passes in!!!\n"));

        ntStatus = STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate a configuration handle and
    // verify there is enough room to store
    // all the information in the client buffer.
    //

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBD_InitializeConfigurationHandle(deviceData,
                                                      DeviceObject,
                                                      configurationDescriptor,
                                                      numInterfaces,
                                                      &configHandle);
    }

    //
    // Send the 'set configuration' command
    //

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = USBD_SendCommand(deviceData,
                                    DeviceObject,
                                    STANDARD_COMMAND_SET_CONFIGURATION,
                                    configurationDescriptor->bConfigurationValue,
                                    0,
                                    0,
                                    NULL,
                                    0,
                                    NULL,
                                    &Urb->UrbSelectConfiguration.Status);

        USBD_KdPrint(3, ("' SendCommand, SetConfiguration returned 0x%x\n", ntStatus));


    }

    if (NT_SUCCESS(ntStatus)) {
        //
        // Users buffer checks out, parse thru the configuration
        // descriptor and open the interfaces.
        //

        // At this stage of the game we are not strict with validation,
        // we assume the client passed in a configuration request buffer
        // of the proper size and format.  All we do for now is walk through
        // the client buffer and open the interfaces specified.

        pch = (PUCHAR) &Urb->UrbSelectConfiguration.Interface;
        for (i=0; i<configurationDescriptor->bNumInterfaces; i++) {
            //
            // all interface handles to null for this config
            //
            configHandle->InterfaceHandle[i] = NULL;
        }

        for (i=0; i<numInterfaces; i++) {
            interfaceInformation = (PUSBD_INTERFACE_INFORMATION) pch;
            ntStatus = USBD_InternalOpenInterface(deviceData,
                                                  DeviceObject,
                                                  configHandle,
                                                  interfaceInformation,
                                                  &configHandle->InterfaceHandle[i],
                                                  TRUE,
                                                  &noBandwidth);

            pch+=interfaceInformation->Length;

            USBD_KdPrint(3, ("' InternalOpenInterface returned 0x%x\n", ntStatus));

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }
        }
    }

    //
    // If interfaces were successfully set up then return
    // success.
    //

USBD_SelectConfiguration_Done:

    if (NT_SUCCESS(ntStatus) &&
        USBD_SUCCESS(Urb->UrbSelectConfiguration.Status)) {

        Urb->UrbSelectConfiguration.ConfigurationHandle = configHandle;
        deviceData->ConfigurationHandle = configHandle;

    } else {

        //
        // something failed, clean up before we return an error.
        //

        if (configHandle) {

            ASSERT_DEVICE(deviceData);
            //
            // if we have a configHandle then we need to free it
            deviceData->ConfigurationHandle =
                configHandle;

            //
            // attempt to close it
            //
            USBD_InternalCloseConfiguration(deviceData,
                                            DeviceObject,
                                            &Urb->UrbSelectConfiguration.Status,
                                            FALSE,
                                            FALSE);

            deviceData->ConfigurationHandle = NULL;
        }

        // make sure we return an error in the URB.
        if (!USBD_ERROR(Urb->UrbSelectConfiguration.Status)) {
            if (noBandwidth) {
                Urb->UrbSelectConfiguration.Status =
                    SET_USBD_ERROR(USBD_STATUS_NO_BANDWIDTH);
                USBD_KdPrint(1, ("Failing SelectConfig -- No BW\n"));

            } else {
                Urb->UrbSelectConfiguration.Status = SET_USBD_ERROR(USBD_STATUS_REQUEST_FAILED);
                USBD_KdPrint(1, ("Failing SelectConfig\n"));
            }
        }
    }

    //
    // We did everything synchronously
    //

    *IrpIsPending = FALSE;

    USBD_ReleaseUsbDeviceMutex(deviceExtension);

    USBD_KdPrint(3, ("' exit USBD_SelectConfiguration 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_InternalCloseConfiguration(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT USBD_STATUS *UsbdStatus,
    IN BOOLEAN AbortTransfers,
    IN BOOLEAN KeepConfig
    )
/*++

Routine Description:

    Closes the current configuration for a device.

Arguments:


Return Value:


--*/
{
    ULONG i, j;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_CONFIG configHandle = NULL;
    BOOLEAN retry = TRUE;

    PAGED_CODE();
    *UsbdStatus = USBD_STATUS_SUCCESS;

    if (DeviceData == NULL || DeviceData->ConfigurationHandle == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    configHandle = DeviceData->ConfigurationHandle;

    //
    // first see if all the endpoints are idle
    //
 USBD_InternalCloseConfiguration_Retry:

    for (i=0; i<configHandle->ConfigurationDescriptor->bNumInterfaces; i++) {
        if ( configHandle->InterfaceHandle[i] &&
             USBD_InternalInterfaceBusy(DeviceData,
                                        DeviceObject,
                                        configHandle->InterfaceHandle[i]) ) {
            //
            // We have a busy interface on this config
            //
            if (AbortTransfers) {

                //
                // If we get here it means that the device driver
                // has pending transfers even though it has processed
                // the pnp REMOVE message!
                //
                // This is a bug in the driver, we'll loop here
                // on the chance that the driver did manage to send
                // an abort first and the transfers will soon
                // complete.
                //

                USBD_Warning(DeviceData,
                  "Driver still has pending transfers while closing the configuration, wait\n",
                  TRUE);

                //
                // wait for any pending transfers to abort
                //
                goto USBD_InternalCloseConfiguration_Retry;
            } else {

                // The driver has closed the configuration while
                // it still has active tranfers -- this is a bug
                // in the driver -- all we do here is fail the
                // close request

                USBD_Warning(DeviceData,
                   "Driver still has pending transfers while closing the configuration, fail\n",
                   TRUE);

                *UsbdStatus =
                    SET_USBD_ERROR(USBD_STATUS_ERROR_BUSY);
                if (retry) {
                    LARGE_INTEGER deltaTime;

                    deltaTime.QuadPart = 50 * -10000;
                    (VOID) KeDelayExecutionThread(KernelMode,
                                  FALSE,
                                  &deltaTime);
                    retry = FALSE;
                    *UsbdStatus = USBD_STATUS_SUCCESS;
                    goto USBD_InternalCloseConfiguration_Retry;
                } else {
                    goto USBD_InternalCloseConfiguration_Done;
                }
            }
        }
    }

    //
    // endpoints are idle, go ahead and clean up all pipes and
    // interfaces for this configuration.
    //

    for (i=0; i<configHandle->ConfigurationDescriptor->bNumInterfaces; i++) {

        //
        // found an open interface, close it
        //

        if (configHandle->InterfaceHandle[i]) {

            USBD_KdPrint(3, ("'%d endpoints to close\n",
                           configHandle->InterfaceHandle[i]->InterfaceDescriptor.bNumEndpoints));

            for (j=0; j<configHandle->InterfaceHandle[i]->InterfaceDescriptor.bNumEndpoints; j++) {

                if (!PIPE_CLOSED(&configHandle->InterfaceHandle[i]->PipeHandle[j])) {
                    USBD_KdPrint(3, ("'close config -- closing endpoint %x\n",
                        &configHandle->InterfaceHandle[i]->PipeHandle[j]));
                    ntStatus = USBD_CloseEndpoint(DeviceData,
                                                  DeviceObject,
                                                  &configHandle->InterfaceHandle[i]->PipeHandle[j],
                                                  UsbdStatus);
                }
                //
                // problem closing an endpoint, abort the
                // SelectConfiguration operation and return an error.
                //
                if (NT_SUCCESS(ntStatus)) {
                    configHandle->InterfaceHandle[i]->PipeHandle[j].HcdEndpoint
                        = NULL;
                } else {
                    USBD_KdTrap(("Unable to close configuration\n"));
                    goto USBD_InternalCloseConfiguration_Done;

                }
            }

            if (!KeepConfig) {
                RETHEAP(configHandle->InterfaceHandle[i]);
                configHandle->InterfaceHandle[i] = NULL;
            }
        }
    }

    if (!KeepConfig) {
        RETHEAP(DeviceData->ConfigurationHandle->ConfigurationDescriptor);
        RETHEAP(DeviceData->ConfigurationHandle);
        DeviceData->ConfigurationHandle = NULL;
    }

USBD_InternalCloseConfiguration_Done:

    USBD_KdPrint(3, ("'USBD_SelectConfiguration, current configuration closed\n"));

    return ntStatus;
}


NTSTATUS
USBD_InternalCloseDefaultPipe(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT USBD_STATUS *UsbdStatus,
    IN BOOLEAN AbortTransfers
    )
/*++

Routine Description:

    Closes the current configuration for a device.

Arguments:


Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN retry = TRUE;
    ULONG endpointState = 0;
    PUSBD_PIPE defaultPipe;

    PAGED_CODE();
    *UsbdStatus = USBD_STATUS_SUCCESS;

    //
    // first see if eop is idle
    //

    defaultPipe = &DeviceData->DefaultPipe;

 USBD_InternalCloseDefaultPipe_Retry:

    ntStatus = USBD_GetEndpointState(DeviceData,
                                     DeviceObject,
                                     defaultPipe,
                                     UsbdStatus,
                                     &endpointState);


    if (NT_SUCCESS(ntStatus) &&
        (endpointState & HCD_ENDPOINT_TRANSFERS_QUEUED)) {

        //
        // We have busy pipe
        //

        if (AbortTransfers) {

            //
            // If we get here it means that the device driver
            // has pending transfers even though it has processed
            // the pnp REMOVE message!
            //
            // This is a bug in the driver, we'll loop here
            // on the chance that the driver did manage to send
            // an abort first and the transfers will soon
            // complete.
            //

            USBD_Warning(DeviceData,
              "Driver still has pending transfers while closing pipe 0, wait\n",
              TRUE);

            //
            // wait for any pending transfers to abort
            //
            goto USBD_InternalCloseDefaultPipe_Retry;
        } else {

            // The driver has closed the configuration while
            // it still has active tranfers -- this is a bug
            // in the driver -- all we do here is fail the
            // close request

            USBD_Warning(DeviceData,
               "Driver still has pending transfers while closing pipe 0, fail\n",
               TRUE);

            *UsbdStatus =
                SET_USBD_ERROR(USBD_STATUS_ERROR_BUSY);
            if (retry) {
                LARGE_INTEGER deltaTime;

                deltaTime.QuadPart = 50 * -10000;
                (VOID) KeDelayExecutionThread(KernelMode,
                              FALSE,
                              &deltaTime);
                retry = FALSE;
                *UsbdStatus = USBD_STATUS_SUCCESS;
                goto USBD_InternalCloseDefaultPipe_Retry;
            } else {
                goto USBD_InternalCloseDefaultPipe_Done;
            }
        }
    }

    //
    // idle pipe, close it now
    //

    if (!PIPE_CLOSED(defaultPipe)) {
        USBD_KdPrint(3, ("'close pipe 0 -- closing endpoint %x\n",
                    defaultPipe));
        ntStatus = USBD_CloseEndpoint(DeviceData,
                                      DeviceObject,
                                      defaultPipe,
                                      UsbdStatus);
    }
    //
    // problem closing an endpoint, abort the
    // SelectConfiguration operation and return an error.
    //
    if (NT_SUCCESS(ntStatus)) {
        defaultPipe->HcdEndpoint = NULL;
    } else {
        USBD_KdTrap(("Unable to close configuration\n"));
        goto USBD_InternalCloseDefaultPipe_Done;

    }

USBD_InternalCloseDefaultPipe_Done:

    USBD_KdPrint(3, ("'USBD_InternalCloseDefaultPipe, closed (%x)\n", ntStatus));

    return ntStatus;
}



NTSTATUS
USBD_SelectInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Select an alternate interface for a USB device.

    Client will pass in a buffer that looks like this:

    -----------------
    Config Info
        - client inputs
            Configuration Handle

    -----------------
    Interface Info
        - client Inputs
            InterfaceNumber
            AlternateSetting

        - class driver outputs:
            Length
            InterfaceHandle

    -----------------
    pipe info 0,0      one of these for each pipe in the
                        interface
        - client inputs:

        - class driver outputs:
    -----------------
    pipe info 0,1

    -----------------
    ...


Arguments:

    DeviceObject -

    Irp -  IO request block

    Urb -  ptr to USB request block

    IrpIsPending -

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_CONFIG configHandle = NULL;
    ULONG i, j;
    PUSBD_INTERFACE oldInterfaceHandle;
    PUSBD_EXTENSION deviceExtension;
    BOOLEAN noBandwidth = FALSE;

    PAGED_CODE();
    deviceData = Urb->UrbHeader.UsbdDeviceHandle;

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    USBD_WaitForUsbDeviceMutex(deviceExtension);

    configHandle = Urb->UrbSelectInterface.ConfigurationHandle;
    ASSERT_CONFIG(configHandle);

    //
    // Select the interface number we are interested in
    //

    i = Urb->UrbSelectInterface.Interface.InterfaceNumber;

    //
    // first close the current interface
    //

    ASSERT_INTERFACE(configHandle->InterfaceHandle[i]);

    if (USBD_InternalInterfaceBusy(deviceData,
                                   DeviceObject,
                                   configHandle->InterfaceHandle[i])) {
        Urb->UrbSelectInterface.Status =
             SET_USBD_ERROR(USBD_STATUS_ERROR_BUSY);
        // Note: usbd will map the urb error to to IoStatus
        // block when the irp completes
        goto USBD_SelectInterface_Done;
    }


    //
    // Interface is not busy go ahead and close it
    //

    USBD_KdPrint(3, ("'close interface -- %d endpoints to close\n",
                configHandle->InterfaceHandle[i]->InterfaceDescriptor.bNumEndpoints));

    for (j=0; j<configHandle->InterfaceHandle[i]->InterfaceDescriptor.bNumEndpoints; j++) {

        if (!PIPE_CLOSED(&configHandle->InterfaceHandle[i]->PipeHandle[j])) {

            USBD_KdPrint(3, ("'close interface -- closing endpoint %x\n",
                &configHandle->InterfaceHandle[i]->PipeHandle[j]));
            ntStatus = USBD_CloseEndpoint(deviceData,
                                          DeviceObject,
                                          &configHandle->InterfaceHandle[i]->PipeHandle[j],
                                          &Urb->UrbSelectInterface.Status);

            //
            // problem closing an endpoint, abort the SelectInterface operation.
            // Note: This leaves the interface handle in an odd state ie some
            // of the pipes are closed and some are not.  We set a flag so that
            // we can keep track of the pipes that have already beem closed
            //

            if (NT_SUCCESS(ntStatus)) {
                // note that we closed this pipe
                configHandle->InterfaceHandle[i]->PipeHandle[j].HcdEndpoint =
                    NULL;
            } else {
                TEST_TRAP();
                goto USBD_SelectInterface_Done;
            }
        }
#if DBG
          else {
//            TEST_TRAP();  // This is normal in some multi-endpoint
                            // configurations if one has a bandwidth error.

            USBD_KdPrint(3, ("'close interface -- encountered previously closed endpoint %x\n",
                &configHandle->InterfaceHandle[i]->PipeHandle[j]));
        }
#endif
    }


    USBD_ASSERT(NT_SUCCESS(ntStatus));

    //
    // All pipes in the current interface are now closed, free the memory
    // associated with this interface
    //

    //
    // save the old interface handle
    //
    oldInterfaceHandle = configHandle->InterfaceHandle[i];

    configHandle->InterfaceHandle[i] = NULL;

    //
    // Now open the new interface with the new alternate setting
    //

    ntStatus = USBD_InternalOpenInterface(deviceData,
                                          DeviceObject,
                                          configHandle,
                                          &Urb->UrbSelectInterface.Interface,
                                          &configHandle->InterfaceHandle[i],
                                          TRUE,
                                          &noBandwidth);

    if (NT_SUCCESS(ntStatus)) {

        //
        // successfully opened the new interface, we can free the old
        // handle now.
        //

        RETHEAP(oldInterfaceHandle);

    } else {

        NTSTATUS status;
        //
        // selecting the aternate interface failed,
        // possible reasons:
        //
        // 1. we didn't have enough BW
        // 2. the device stalled the set_interface request
        //

        if (noBandwidth) {
            Urb->UrbSelectInterface.Status = SET_USBD_ERROR(USBD_STATUS_NO_BANDWIDTH);
            USBD_KdPrint(1, ("Failing SelectInterface -- No BW\n"));
        }
        // make sure everything is cleaned up.
        //



        USBD_ASSERT(configHandle->InterfaceHandle[i] == NULL);

        // At this point we will attempt to restore the original interface,
        // since the pipe handles are just pointers in to the interface structure
        // they will remain valid even though the hcd endpoint handles have changed
        // from being closed and re-opening.

        configHandle->InterfaceHandle[i] = oldInterfaceHandle;

        status = USBD_InternalOpenInterface(deviceData,
                                            DeviceObject,
                                            configHandle,
                                            oldInterfaceHandle->InterfaceInformation,
                                            &configHandle->InterfaceHandle[i],
                                            FALSE,
                                            NULL);

#if DBG
        if (!NT_SUCCESS(status)) {
            USBD_KdPrint(1, ("failed to restore the original interface\n"));
        }
#endif

    }

USBD_SelectInterface_Done:

    //
    // We did everything synchronously
    //

    USBD_ReleaseUsbDeviceMutex(deviceExtension);

    *IrpIsPending = FALSE;

    USBD_KdPrint(3, ("' exit USBD_SelectInterface 0x%x\n", ntStatus));

    return ntStatus;

}

#endif      // USBD_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\dbg.h ===
/*++

Copyright (c) 1995    Microsoft Corporation

Module Name:

    DBG.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the usbd driver.

Environment:

    Kernel & user mode

Revision History:

    09-29-95 : created

--*/


#define NAME_MAX 64

#define USBD_TAG         0x44425355     /* "USBD" */
#define USBD_FREE_TAG     0x65657266    /* "free" */

#if DBG
#define DEBUG_LOG
#define DEBUG_HEAP
#endif

#define SIG_CONFIG          0x464E4F43        //"CONF" signature for config handle
#define SIG_PIPE            0x45504950        //"PIPE" signature for pipe handle
#define SIG_INTERFACE       0x43414658        //"XFAC" signature for interface handle 
#define SIG_DEVICE          0x56454455        //"UDEV" signature for device handle


#if DBG
                                
#define ASSERT_CONFIG(ch)       USBD_ASSERT((ch)->Sig == SIG_CONFIG)
#define ASSERT_PIPE(ph)         USBD_ASSERT((ph)->Sig == SIG_PIPE)
#define ASSERT_INTERFACE(ih)    USBD_ASSERT((ih)->Sig == SIG_INTERFACE)
#define ASSERT_DEVICE(d)        USBD_ASSERT((d)->Sig == SIG_DEVICE)



ULONG
_cdecl
USBD_KdPrintX(
    PCH Format,
    ...
    );

extern ULONG USBD_Debug_Trace_Level;

// the convention here is to print to the ntkern log if 
// l (level) is > 1 otherwise print to the terminal
// in usbd you have to manully specify the ' in the output 
// string
#define USBD_KdPrint(l, _x_) if (((l) == 0) || (((l)-1) < USBD_Debug_Trace_Level)) \
    {\
        if ((l) == 1) {\
            DbgPrint("USBD: ");\
        } else {\
            DbgPrint("'USBD: ");\
        }\
        USBD_KdPrintX _x_;\
    }

VOID
USBD_Assert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define USBD_ASSERT( exp ) \
    if (!(exp)) \
        USBD_Assert( #exp, __FILE__, __LINE__, NULL )

#define USBD_ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        USBD_Assert( #exp, __FILE__, __LINE__, msg )

// TEST_TRAP() is a code coverage trap these should be removed
// if you are able to 'g' past the OK
// 
// TRAP() breaks in the debugger on the debugger build
// these indicate bugs in client drivers or fatal error 
// conditions that should be debugged. also used to mark 
// code for features not implemented yet.
//
// KdBreak() breaks in the debugger when in MAX_DEBUG mode
// ie debug trace info is turned on, these are intended to help
// debug drivers devices and special conditions on the
// bus.

#ifdef NTKERN
// Ntkern currently implements DebugBreak with a global int 3,
// we really would like the int 3 in our own code.
    
#define DBGBREAK() _asm { int 3 }
#else
#define DBGBREAK() DbgBreakPoint()
#endif /* NTKERN */

#define TEST_TRAP() { DbgPrint( " Code Coverage Trap %s %d\n", __FILE__, __LINE__); \
                      DBGBREAK(); }

#ifdef MAX_DEBUG
#define USBD_KdBreak(_x_) { DbgPrint("USBD:"); \
                            DbgPrint _x_ ; \
                            DBGBREAK(); }
#else
#define USBD_KdBreak(_x_)
#endif

#define USBD_KdTrap(_x_)  { DbgPrint( "USBD: "); \
                            DbgPrint _x_; \
                            DBGBREAK(); }

VOID 
USBD_Debug_LogEntry(
    IN CHAR *Name, 
    IN ULONG_PTR Info1, 
    IN ULONG_PTR Info2, 
    IN ULONG_PTR Info3
    );

#define LOGENTRY(sig, info1, info2, info3) \
    USBD_Debug_LogEntry(sig, (ULONG_PTR)info1, (ULONG_PTR)info2, (ULONG_PTR)info3)

extern LONG USBDTotalHeapAllocated;

PVOID
USBD_Debug_GetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );
    
#define GETHEAP(pooltype, numbytes) USBD_Debug_GetHeap(pooltype, numbytes,\
                                         USBD_TAG, &USBDTotalHeapAllocated)               

VOID
USBD_Debug_RetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

#define RETHEAP(p)    USBD_Debug_RetHeap(p, USBD_TAG, &USBDTotalHeapAllocated)    

#else /* DBG not defined */

#define USBD_KdBreak(_x_) 

#define USBD_KdPrint(l, _x_) 

#define USBD_KdTrap(_x_)  

#define TEST_TRAP()

#define ASSERT_CONFIG(ch)        
#define ASSERT_PIPE(ph)            
#define ASSERT_INTERFACE(ih)    
#define ASSERT_DEVICE(d)   

#define USBD_ASSERT( exp )

#define USBD_ASSERTMSG( msg, exp )

#define GETHEAP(pooltype, numbytes) ExAllocatePoolWithTag(pooltype, numbytes, USBD_TAG)               

#define RETHEAP(p) ExFreePool(p)               

#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\busif.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    busif.c

Abstract:

    Exports PnP services thru a bus interface, this eleminates
    any dependency of usbhub on usbd.sys with regard to the 'port'
    driver support.

    Old services have been renamed ServiceNameX and a dummy entrypoint
    added



Environment:

    kernel mode only

Notes:



Revision History:

    10-29-95 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


//#include "usbdi.h"       //public data structures
#include "usbdi.h"
#include "hcdi.h"

#include "usb200.h"
#include "usbd.h"        //private data strutures
#include <initguid.h>
#include "hubbusif.h"    // hub service bus interface
#include "usbbusif.h"    // hub service bus interface


#ifdef USBD_DRIVER      // USBPORT supercedes most of USBD, so we will remove
                        // the obsolete code by compiling it only if
                        // USBD_DRIVER is set.


NTSTATUS
USBD_RestoreDeviceX(
    IN OUT PUSBD_DEVICE_DATA OldDeviceData,
    IN OUT PUSBD_DEVICE_DATA NewDeviceData,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBD_CreateDeviceX(
    IN OUT PUSBD_DEVICE_DATA *DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeviceIsLowSpeed,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags
    );

NTSTATUS
USBD_RemoveDeviceX(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Flags
    );

NTSTATUS
USBD_InitializeDeviceX(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    );


NTSTATUS
USBD_BusCreateDevice(
    IN PVOID BusContext,
    IN OUT PUSB_DEVICE_HANDLE *DeviceHandle,
    IN PUSB_DEVICE_HANDLE HubDevicehandle,
    IN USHORT PortStatus,
    IN USHORT PortNumber
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    BOOLEAN isLowSpeed;
    PDEVICE_OBJECT rootHubPdo;
    ULONG hackFlags;
    PUSBD_DEVICE_DATA deviceData;

    rootHubPdo = BusContext;

    isLowSpeed = (PortStatus & USB_PORT_STATUS_LOW_SPEED) ? TRUE : FALSE;
    
    ntStatus = USBD_CreateDeviceX(
            &deviceData,
            rootHubPdo,
            isLowSpeed,
            0,  // max packet size override, it turns out we 
                // never use this
            &hackFlags);

    *DeviceHandle = deviceData;

    return ntStatus;  
}


NTSTATUS
USBD_BusInitializeDevice(
    IN PVOID BusContext,
    IN OUT PUSB_DEVICE_HANDLE DeviceHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT rootHubPdo;

    rootHubPdo = BusContext;

    ntStatus = USBD_InitializeDeviceX(DeviceHandle,
                                      rootHubPdo,
                                      NULL,
                                      0,
                                      NULL,
                                      0);

    return ntStatus;                                      
}


NTSTATUS
USBD_BusRemoveDevice(
    IN PVOID BusContext,
    IN OUT PUSB_DEVICE_HANDLE DeviceHandle,
    IN ULONG Flags
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT rootHubPdo;

    rootHubPdo = BusContext;

    // note old remove device only supports 8 flags
    
    ntStatus = USBD_RemoveDeviceX(
            DeviceHandle,
            rootHubPdo,
            (UCHAR) Flags);

    return ntStatus;                
}    


NTSTATUS
USBD_BusGetUsbDescriptors(
    IN PVOID BusContext,
    IN OUT PUSB_DEVICE_HANDLE DeviceHandle,
    IN OUT PUCHAR DeviceDescriptorBuffer,
    IN OUT PULONG DeviceDescriptorBufferLength,
    IN OUT PUCHAR ConfigDescriptorBuffer,
    IN OUT PULONG ConfigDescriptorBufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT rootHubPdo;
    PUSBD_DEVICE_DATA deviceData = DeviceHandle;

    rootHubPdo = BusContext;

    // use the cached device descriptor
    if (DeviceDescriptorBuffer && *DeviceDescriptorBufferLength) {
        RtlCopyMemory(DeviceDescriptorBuffer,
                      &deviceData->DeviceDescriptor,
                      *DeviceDescriptorBufferLength);
        *DeviceDescriptorBufferLength = sizeof(USB_DEVICE_DESCRIPTOR);                    
    }

    // Fetch the config descriptor.  If all that is desired is the 9 byte
    // config descriptor header, just return the cached config descriptor
    // header so that we don't send back to back requests for just the 9 byte
    // header to the device.  That seems to confuse some devices, some usb
    // audio devices in particular when enumerating on OHCI host controllers.
    //
    if (ConfigDescriptorBuffer &&
        *ConfigDescriptorBufferLength == sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        RtlCopyMemory(ConfigDescriptorBuffer,
                      &deviceData->ConfigDescriptor,
                      sizeof(USB_CONFIGURATION_DESCRIPTOR));
    }
    else if (ConfigDescriptorBuffer && *ConfigDescriptorBufferLength) {
    
        ULONG bytesReturned;
        
        ntStatus = 
            USBD_SendCommand(deviceData,
                            rootHubPdo,
                            STANDARD_COMMAND_GET_DESCRIPTOR,
                            USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(
                                USB_CONFIGURATION_DESCRIPTOR_TYPE, 0),
                            0,
                            (USHORT) *ConfigDescriptorBufferLength,
                            (PUCHAR) ConfigDescriptorBuffer,
                            *ConfigDescriptorBufferLength,
                            &bytesReturned,
                            NULL);
                            
        if (NT_SUCCESS(ntStatus) &&
            bytesReturned < sizeof(USB_CONFIGURATION_DESCRIPTOR)) {
            // truncated config descriptor returned
            USBD_KdPrint(0, 
("'WARNING: Truncated Config Descriptor returned - get JD\n"));
             
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }
    }

    return ntStatus;
}    


NTSTATUS
USBD_BusRestoreDevice(
    IN PVOID BusContext,
    IN OUT PUSB_DEVICE_HANDLE OldDeviceHandle,
    IN OUT PUSB_DEVICE_HANDLE NewDeviceHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT rootHubPdo;

    rootHubPdo = BusContext;

    ntStatus = USBD_RestoreDeviceX(OldDeviceHandle,
                                   NewDeviceHandle,
                                   rootHubPdo);
                                   
    return ntStatus; 
}    


NTSTATUS
USBD_BusGetUsbDeviceHackFlags(
    IN PVOID BusContext,
    IN PUSB_DEVICE_HANDLE DeviceHandle,
    IN OUT PULONG HackFlags
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT rootHubPdo;
    PUSBD_DEVICE_DATA deviceData = DeviceHandle;

    rootHubPdo = BusContext;

    TEST_TRAP();        
    return ntStatus; 
}    


NTSTATUS
USBD_BusGetUsbPortHackFlags(
    IN PVOID BusContext,
    IN OUT PULONG HackFlags
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT rootHubPdo;
    PUSBD_EXTENSION deviceExtensionUsbd;

    rootHubPdo = BusContext;
    *HackFlags = 0;
    
    deviceExtensionUsbd = ((PUSBD_EXTENSION)rootHubPdo->DeviceExtension)->TrueDeviceExtension;
    if (deviceExtensionUsbd->DiagnosticMode) {
        *HackFlags |= USBD_DEVHACK_SET_DIAG_ID;
    }
    
    return ntStatus; 
}    


VOID
USBD_BusInterfaceReference(
    IN PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
}    


VOID
USBD_BusInterfaceDereference(
    IN PVOID BusContext
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
}    


NTSTATUS
USBD_BusQueryBusTime(
    IN PVOID BusContext,
    IN PULONG CurrentFrame
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/    
{
    PUSBD_EXTENSION deviceExtensionUsbd;
    PDEVICE_OBJECT rootHubPdo = BusContext;

    deviceExtensionUsbd = rootHubPdo->DeviceExtension;
    deviceExtensionUsbd = deviceExtensionUsbd->TrueDeviceExtension;

    return deviceExtensionUsbd->HcdGetCurrentFrame(
                deviceExtensionUsbd->HcdDeviceObject,
                CurrentFrame);
}    

VOID 
USBD_GetUSBDIVersion(
        PUSBD_VERSION_INFORMATION VersionInformation
        );  
        
VOID
USBD_BusGetUSBDIVersion(
    IN PVOID BusContext,
    IN OUT PUSBD_VERSION_INFORMATION VersionInformation,
    IN OUT PULONG HcdCapabilities
    )
/*++

Routine Description:

    returns the current USB frame

Arguments:

Return Value:

    NT status code.

--*/    
{
    PUSBD_EXTENSION deviceExtensionUsbd;
    PDEVICE_OBJECT rootHubPdo = BusContext;

    deviceExtensionUsbd = rootHubPdo->DeviceExtension;
    deviceExtensionUsbd = deviceExtensionUsbd->TrueDeviceExtension;

    USBD_GetUSBDIVersion(VersionInformation);
    
    *HcdCapabilities = 0;
    
    if (deviceExtensionUsbd->HcdSubmitIsoUrb != NULL) {
        *HcdCapabilities = USB_HCD_CAPS_SUPPORTS_RT_THREADS;
    }                
}    


NTSTATUS
USBD_BusSubmitIsoOutUrb(
    IN PVOID BusContext,
    IN OUT PURB Urb            
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    PUSBD_EXTENSION deviceExtensionUsbd;
    PDEVICE_OBJECT rootHubPdo = BusContext;
    NTSTATUS ntStatus;
//    PUSBD_DEVICE_DATA deviceData;
    PUSBD_PIPE pipeHandle;

    pipeHandle =  (PUSBD_PIPE)Urb->UrbIsochronousTransfer.PipeHandle;  
    
    ASSERT_PIPE(pipeHandle);
    deviceExtensionUsbd = rootHubPdo->DeviceExtension;
    deviceExtensionUsbd = deviceExtensionUsbd->TrueDeviceExtension;

    ((PHCD_URB)Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = 
        pipeHandle->HcdEndpoint;    

    if (pipeHandle->EndpointDescriptor.bEndpointAddress & 
        USB_ENDPOINT_DIRECTION_MASK) {
        USBD_SET_TRANSFER_DIRECTION_IN(((PHCD_URB)Urb)->HcdUrbCommonTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT(((PHCD_URB)Urb)->HcdUrbCommonTransfer.TransferFlags);
    }            

    if (deviceExtensionUsbd->HcdSubmitIsoUrb == NULL) {
        // fast iso interface not supported by HCD
        TEST_TRAP();        
        ntStatus = STATUS_NOT_SUPPORTED;
    } else {
        ntStatus = deviceExtensionUsbd->HcdSubmitIsoUrb(
            deviceExtensionUsbd->HcdDeviceObject,
            Urb);
    }

    return ntStatus;
}    


NTSTATUS
USBD_BusQueryDeviceInformation(
    IN PVOID BusContext,
    IN PUSB_DEVICE_HANDLE DeviceHandle,
    IN OUT PVOID DeviceInformationBuffer,
    IN ULONG DeviceInformationBufferLength,
    IN OUT PULONG LengthOfDataCopied
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    ULONG need;
    PUSBD_CONFIG configHandle;
    ULONG i,j,k;
    PUSB_DEVICE_INFORMATION_0 level_0 = DeviceInformationBuffer;
    PUSB_LEVEL_INFORMATION levelInfo = DeviceInformationBuffer;
    ULONG numberOfPipes = 0;
    PUSBD_DEVICE_DATA deviceData = DeviceHandle;


    // bugbug 
    // need more validation here
    
    PAGED_CODE();
    
    *LengthOfDataCopied = 0;   
    
    if (DeviceInformationBufferLength < sizeof(*levelInfo)) {
        return STATUS_BUFFER_TOO_SMALL;            
    }

    if (levelInfo->InformationLevel > 0) {
        // usbd only supports level 0
        return STATUS_NOT_SUPPORTED;                     
    }

    // figure out how much room we need
    configHandle = deviceData->ConfigurationHandle;
    if (configHandle) {
    
        // count the pipes in each interface
        for (i=0;
             i< configHandle->ConfigurationDescriptor->bNumInterfaces;
             i++) {
            numberOfPipes +=
                configHandle->InterfaceHandle[i]->
                    InterfaceInformation->NumberOfPipes;
        }
        
    }
    
    need = (numberOfPipes-1) * sizeof(USB_PIPE_INFORMATION_0) +
            sizeof(USB_DEVICE_INFORMATION_0);


    if (DeviceInformationBufferLength < need) {
        // report how much space if possible
        levelInfo->ActualLength = need;
        *LengthOfDataCopied = sizeof(*levelInfo);
        return STATUS_BUFFER_TOO_SMALL;
    }    

    RtlZeroMemory(level_0, need);
    
    // 
    // enough room, fill in the buffer
    //

    level_0->InformationLevel = 0;
    level_0->ActualLength = need;        
    level_0->DeviceAddress = deviceData->DeviceAddress;
    level_0->DeviceDescriptor = deviceData->DeviceDescriptor;
    
    if (deviceData->LowSpeed) {
        level_0->DeviceSpeed = UsbLowSpeed;
    } else {
        level_0->DeviceSpeed = UsbFullSpeed;
    }

//    if (DeviceData->xxx) {
        level_0->DeviceType = Usb11Device;
//    } else {
//        level_0->DeviceSpeed = UsbFullSpeed;
//    }

//    level_0->PortNumber = xxx;
    level_0->NumberOfOpenPipes = numberOfPipes;
    level_0->CurrentConfigurationValue = 0;
    // get the pipe information
    if (configHandle) {
    
        level_0->CurrentConfigurationValue =
            configHandle->ConfigurationDescriptor->bConfigurationValue;

        j=0;
        for (i=0;
             i<configHandle->ConfigurationDescriptor->bNumInterfaces;
             i++) {

            PUSBD_INTERFACE interfaceHandle =
                configHandle->InterfaceHandle[i];

            for (k=0;
                 k<interfaceHandle->InterfaceInformation->NumberOfPipes;
                 k++, j++) {
                 
                    ASSERT(j < numberOfPipes);
                    
                    level_0->PipeList[j].ScheduleOffset = 
                        interfaceHandle->PipeHandle[k].ScheduleOffset;
                    RtlCopyMemory(&level_0->PipeList[j].
                                    EndpointDescriptor,
                                  &interfaceHandle->PipeHandle[k].
                                    EndpointDescriptor,
                                  sizeof(USB_ENDPOINT_DESCRIPTOR));
        
            }
        }
    }

    *LengthOfDataCopied = need;

    // dump the level data returned
    USBD_KdPrint(1, ("  USBD level 0 Device Information:\n"));
    USBD_KdPrint(1, ("  InformationLevel %d\n", 
        level_0->InformationLevel));
//    USBD_KdPrint(1, ("  DeviceDescriptor %d\n", 
//        level_0->InformationLevel));
    USBD_KdPrint(1, ("  ActualLength %d\n", 
        level_0->ActualLength));
    USBD_KdPrint(1, ("  DeviceSpeed %d\n", 
        level_0->DeviceSpeed));                
    USBD_KdPrint(1, ("  PortNumber %d\n", 
        level_0->PortNumber));
    USBD_KdPrint(1, ("  CurrentConfigurationValue %d\n", 
        level_0->CurrentConfigurationValue));
    USBD_KdPrint(1, ("  DeviceAddress %d\n", 
        level_0->DeviceAddress));
    USBD_KdPrint(1, ("  NumberOfOpenPipes %d\n", 
        level_0->NumberOfOpenPipes));
        
    for (i=0; i< level_0->NumberOfOpenPipes; i++) {         
        USBD_KdPrint(1, ("  ScheduleOffset[%d] %d\n", i,
            level_0->PipeList[i].ScheduleOffset));
        USBD_KdPrint(1, ("  MaxPacket %d\n", 
            level_0->PipeList[i].EndpointDescriptor.wMaxPacketSize));
        USBD_KdPrint(1, ("  Interval %d\n", 
            level_0->PipeList[i].EndpointDescriptor.bInterval));            
//        USBD_KdPrint(1, ("' \n", level_0->));
//        USBD_KdPrint(1, ("' \n", level_0->));
    }
    
    return STATUS_SUCCESS;
}    


NTSTATUS
USBD_BusQueryBusInformation(
    IN PVOID BusContext,
    IN ULONG Level,
    IN OUT PVOID BusInformationBuffer,
    IN OUT PULONG BusInformationBufferLength,
    OUT PULONG BusInformationActulaLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;
    PUSB_BUS_INFORMATION_LEVEL_0 level_0;
    PUSB_BUS_INFORMATION_LEVEL_1 level_1;
    PDEVICE_OBJECT rootHubPdo = BusContext;
    PUSBD_EXTENSION deviceExtensionUsbd;
    ULONG len, need;
    
    deviceExtensionUsbd = rootHubPdo->DeviceExtension;
    deviceExtensionUsbd = deviceExtensionUsbd->TrueDeviceExtension;

    switch (Level) {
    case 0:
        level_0 =  BusInformationBuffer;
        if (BusInformationActulaLength != NULL) {
            *BusInformationActulaLength = sizeof(*level_0);
        }
        
        if (*BusInformationBufferLength >= sizeof(*level_0)) {
            *BusInformationBufferLength = sizeof(*level_0);

            level_0->TotalBandwidth = 12000; // 12 Mbits
            level_0->ConsumedBandwidth =
                deviceExtensionUsbd->HcdGetConsumedBW(
                    deviceExtensionUsbd->HcdDeviceObject);
            
            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        
        break;

    case 1:
        level_1 =  BusInformationBuffer;

        need = sizeof(*level_1) + 
             deviceExtensionUsbd->DeviceLinkUnicodeString.Length;
        
        if (BusInformationActulaLength != NULL) {
            *BusInformationActulaLength = need;
        }
        
        if (*BusInformationBufferLength >= need) {
            *BusInformationBufferLength = need;

            level_1->TotalBandwidth = 12000; // 12 Mbits
            level_1->ConsumedBandwidth =
                deviceExtensionUsbd->HcdGetConsumedBW(
                    deviceExtensionUsbd->HcdDeviceObject);
                    
            level_1->ControllerNameLength =
                deviceExtensionUsbd->DeviceLinkUnicodeString.Length;

            len = deviceExtensionUsbd->DeviceLinkUnicodeString.Length;

            if (len > sizeof(level_1->ControllerNameUnicodeString)) {
                len =  sizeof(level_1->ControllerNameUnicodeString);
            }
            
            RtlCopyMemory(&level_1->ControllerNameUnicodeString[0],
                          deviceExtensionUsbd->DeviceLinkUnicodeString.Buffer,
                          len);
                
            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        
        break;        
    }
    
    return ntStatus; 
}    


NTSTATUS
USBD_BusGetBusInformation(
    IN PVOID BusContext,
    IN ULONG Level,
    IN PUSB_DEVICE_HANDLE DeviceHandle,
    IN OUT PVOID DeviceInformationBuffer,
    IN OUT PULONG DeviceInformationBufferLength
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/    
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    TEST_TRAP();        
    return ntStatus; 
}    



NTSTATUS
USBD_GetBusInterfaceHub(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PIRP Irp
    )
/*++

Routine Description:

    Return the Hub Bus Interface to the caller

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    // assume success
    ntStatus = STATUS_SUCCESS;


    if (requestedVersion >= USB_BUSIF_HUB_VERSION_0) {
    
        PUSB_BUS_INTERFACE_HUB_V0 busInterface0;
        
        busInterface0 = (PUSB_BUS_INTERFACE_HUB_V0) 
            irpStack->Parameters.QueryInterface.Interface;

        busInterface0->BusContext = 
            RootHubPdo;                
        busInterface0->InterfaceReference = 
            USBD_BusInterfaceReference;        
        busInterface0->InterfaceDereference =
            USBD_BusInterfaceDereference;

        busInterface0->Size = sizeof(USB_BUS_INTERFACE_HUB_V0);
        busInterface0->Version = USB_BUSIF_HUB_VERSION_0;
    }

    if (requestedVersion >= USB_BUSIF_HUB_VERSION_1) {
    
        PUSB_BUS_INTERFACE_HUB_V1 busInterface1;
        
        busInterface1 = (PUSB_BUS_INTERFACE_HUB_V1)
            irpStack->Parameters.QueryInterface.Interface;

        busInterface1->CreateUsbDevice =
            USBD_BusCreateDevice;
        busInterface1->InitializeUsbDevice =
            USBD_BusInitializeDevice;
        busInterface1->GetUsbDescriptors =
            USBD_BusGetUsbDescriptors;
        busInterface1->RemoveUsbDevice =
            USBD_BusRemoveDevice;
        busInterface1->RestoreUsbDevice =
            USBD_BusRestoreDevice;
        busInterface1->GetPortHackFlags =     
            USBD_BusGetUsbPortHackFlags;
        busInterface1->QueryDeviceInformation =  
            USBD_BusQueryDeviceInformation;

        busInterface1->Size = sizeof(USB_BUS_INTERFACE_HUB_V1);
        busInterface1->Version = USB_BUSIF_HUB_VERSION_1;
    }
        
    return ntStatus;
}


NTSTATUS
USBD_GetBusInterfaceUSBDI(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PIRP Irp
    )
/*++

Routine Description:

    Return the Hub Bus Interface to the caller

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

    // assume success
    ntStatus = STATUS_SUCCESS;

    if (requestedVersion >= USB_BUSIF_USBDI_VERSION_0) {
    
        PUSB_BUS_INTERFACE_USBDI_V0 busInterface0;
        
        busInterface0 = (PUSB_BUS_INTERFACE_USBDI_V0) 
            irpStack->Parameters.QueryInterface.Interface;

        busInterface0->BusContext = 
            RootHubPdo;                
        busInterface0->InterfaceReference = 
            USBD_BusInterfaceReference;        
        busInterface0->InterfaceDereference =
            USBD_BusInterfaceDereference;

        busInterface0->GetUSBDIVersion = 
            USBD_BusGetUSBDIVersion;
        busInterface0->QueryBusTime = 
            USBD_BusQueryBusTime;            
        busInterface0->SubmitIsoOutUrb = 
            USBD_BusSubmitIsoOutUrb;
        busInterface0->QueryBusInformation = 
            USBD_BusQueryBusInformation;
            

        busInterface0->Size = sizeof(USB_BUS_INTERFACE_USBDI_V0);
        busInterface0->Version = USB_BUSIF_USBDI_VERSION_0;
    }

    return ntStatus;
}


NTSTATUS
USBD_GetBusInterface(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PIRP Irp
    )
/*++

Routine Description:

    Return the Hub Bus Interface to the caller

Arguments:

Return Value:

    NT status code.

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    USHORT requestedSize, requestedVersion;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    requestedSize = irpStack->Parameters.QueryInterface.Size;
    requestedVersion = irpStack->Parameters.QueryInterface.Version;

//    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - Requested version = %d\n",
//            requestedVersion));
//    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - Requested size = %d\n",
//            requestedSize));  
//    USBPORT_KdPrint((1, "'USBPORT_GetBusInterface - interface data = %x\n",
//            irpStack->Parameters.QueryInterface.InterfaceSpecificData));              
            
            
    // Initialize ntStatus as IRP status, because we're not supposed to
    // touch the IRP status for interfaces that we do not support.
    // (USBD_PdoPnP sets IRP status to ntStatus on exit.)
    ntStatus = Irp->IoStatus.Status;

    // validate version, size and GUID
    if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
                         &USB_BUS_INTERFACE_HUB_GUID,
                         sizeof(GUID)) == sizeof(GUID)) {

        ntStatus = USBD_GetBusInterfaceHub(RootHubPdo,
                                           Irp);

    } else if (RtlCompareMemory(irpStack->Parameters.QueryInterface.InterfaceType,
                         &USB_BUS_INTERFACE_USBDI_GUID,
                         sizeof(GUID)) == sizeof(GUID)) {

        ntStatus = USBD_GetBusInterfaceUSBDI(RootHubPdo,
                                             Irp);

    }

    return ntStatus;
}

#endif      // USBD_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbccgp\util.c ===
/*
 *************************************************************************
 *  File:       UTIL.C
 *
 *  Module:     USBCCGP.SYS
 *              USB Common Class Generic Parent driver.
 *
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *
 *  Author:     ervinp
 *
 *************************************************************************
 */

#include <wdm.h>
#include <stdio.h>
#include <usb.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usbccgp.h"
#include "security.h"
#include "debug.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, AppendInterfaceNumber)
        #pragma alloc_text(PAGE, CopyDeviceRelations)
        #pragma alloc_text(PAGE, GetFunctionInterfaceListBase)
        #pragma alloc_text(PAGE, CallDriverSync)
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, SetPdoRegistryParameter)
        #pragma alloc_text(PAGE, GetPdoRegistryParameter)
        #pragma alloc_text(PAGE, GetMsOsFeatureDescriptor)

#endif

#define USB_REQUEST_TIMEOUT     5000    // Timeout in ms (5 sec)


NTSTATUS CallNextDriverSync(PPARENT_FDO_EXT parentFdoExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    parentFdoExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(parentFdoExt);
    status = CallDriverSync(parentFdoExt->topDevObj, irp);
    DecrementPendingActionCount(parentFdoExt);

    return status;
}


VOID IncrementPendingActionCount(PPARENT_FDO_EXT parentFdoExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(parentFdoExt->pendingActionCount >= 0);
    InterlockedIncrement(&parentFdoExt->pendingActionCount);
}



VOID DecrementPendingActionCount(PPARENT_FDO_EXT parentFdoExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(parentFdoExt->pendingActionCount >= 0);
    InterlockedDecrement(&parentFdoExt->pendingActionCount);    

    if (parentFdoExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((parentFdoExt->state == STATE_REMOVING) || 
               (parentFdoExt->state == STATE_REMOVED));
        KeSetEvent(&parentFdoExt->removeEvent, 0, FALSE);
    }
}


/*
 ********************************************************************************
 *  CallDriverSyncCompletion
 ********************************************************************************
 *
 *
 */
NTSTATUS CallDriverSyncCompletion(IN PDEVICE_OBJECT devObjOrNULL, IN PIRP irp, IN PVOID Context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL -
            Usually, this is this driver's device object.
             However, if this driver created the IRP,
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync.


Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PUSB_REQUEST_TIMEOUT_CONTEXT timeoutContext = Context;
    PKEVENT event = timeoutContext->event;
    PLONG lock = timeoutContext->lock;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    InterlockedExchange(lock, 3);
    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS CallDriverSync(IN PDEVICE_OBJECT devObj, IN OUT PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PUSB_REQUEST_TIMEOUT_CONTEXT timeoutContext;
    KEVENT event;
    LONG lock;
    LARGE_INTEGER dueTime;
    PIO_STACK_LOCATION irpStack;
    ULONG majorFunction;
    ULONG minorFunction;
    NTSTATUS status;

    PAGED_CODE();

    irpStack = IoGetNextIrpStackLocation(irp);
    majorFunction = irpStack->MajorFunction;
    minorFunction = irpStack->MinorFunction;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    lock = 0;

    timeoutContext = ALLOCPOOL(NonPagedPool, sizeof(USB_REQUEST_TIMEOUT_CONTEXT));

    if (timeoutContext) {

        timeoutContext->event = &event;
        timeoutContext->lock = &lock;

        IoSetCompletionRoutine( irp,
                                CallDriverSyncCompletion, // context
                                timeoutContext,
                                TRUE, TRUE, TRUE);

        status = IoCallDriver(devObj, irp);

        if (status == STATUS_PENDING) {

            dueTime.QuadPart = -10000 * USB_REQUEST_TIMEOUT;

            status = KeWaitForSingleObject(
                        &event,
                        Executive,      // wait reason
                        KernelMode,
                        FALSE,          // not alertable
                        &dueTime);

            if (status == STATUS_TIMEOUT) {

                DBGWARN(("CallDriverSync timed out!\n"));

                if (InterlockedExchange(&lock, 1) == 0) {

                    //
                    // We got it to the IRP before it was completed. We can cancel
                    // the IRP without fear of losing it, as the completion routine
                    // won't let go of the IRP until we say so.
                    //
                    IoCancelIrp(irp);

                    //
                    // Release the completion routine. If it already got there,
                    // then we need to complete it ourselves. Otherwise we got
                    // through IoCancelIrp before the IRP completed entirely.
                    //
                    if (InterlockedExchange(&lock, 2) == 3) {

                        //
                        // Mark it pending because we switched threads.
                        //
                        IoMarkIrpPending(irp);
                        IoCompleteRequest(irp, IO_NO_INCREMENT);
                    }
                }

                KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

                // Return an error code because STATUS_TIMEOUT is a successful
                // code.
                irp->IoStatus.Status = STATUS_DEVICE_DATA_ERROR;
            }
        }

        FREEPOOL(timeoutContext);

        status = irp->IoStatus.Status;

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status)){
        DBGVERBOSE(("IRP 0x%02X/0x%02X failed in CallDriverSync w/ status %xh.",
                    majorFunction, minorFunction, status));
    }

    return status;
}



/*
 ********************************************************************************
 *  AppendInterfaceNumber
 ********************************************************************************
 *
 *  oldIDs is a multi-String of hardware IDs.
 *  Return a new string with '&MI_xx' appended to each id,
 *  where 'xx' is the interface number of the first interface in that function.
 */
PWCHAR AppendInterfaceNumber(PWCHAR oldIDs, ULONG interfaceNum)
{
    ULONG newIdLen;
    PWCHAR id, newIDs;
    WCHAR suffix[] = L"&MI_xx";

    PAGED_CODE();

    /*
     *  Calculate the length of the final multi-string.
     */
    for (id = oldIDs, newIdLen = 0; *id; ){
        ULONG thisIdLen = WStrLen(id);
        newIdLen += thisIdLen + 1 + sizeof(suffix);
        id += thisIdLen + 1;
    }

    /*
     *  Add one for the extra NULL at the end of the multi-string.
     */
    newIdLen++;

    newIDs = ALLOCPOOL(NonPagedPool, newIdLen*sizeof(WCHAR));
    if (newIDs){
        ULONG oldIdOff, newIdOff;

        /*
         *  Copy each string in the multi-string, replacing the bus name.
         */
        for (oldIdOff = newIdOff = 0; oldIDs[oldIdOff]; ){
            ULONG thisIdLen = WStrLen(oldIDs+oldIdOff);

            swprintf(suffix, L"&MI_%02x", interfaceNum);

            /*
             *  Copy the new bus name to the new string.
             */
            newIdOff += WStrCpy(newIDs+newIdOff, oldIDs+oldIdOff);
            newIdOff += WStrCpy(newIDs+newIdOff, (PWSTR)suffix) + 1;

            oldIdOff += thisIdLen + 1;
        }

        /*
         *  Add extra NULL to terminate multi-string.
         */
        newIDs[newIdOff] = UNICODE_NULL;
    }

    return newIDs;
}


/*
 ********************************************************************************
 *  CopyDeviceRelations
 ********************************************************************************
 *
 *
 */
PDEVICE_RELATIONS CopyDeviceRelations(PDEVICE_RELATIONS deviceRelations)
{
    PDEVICE_RELATIONS newDeviceRelations;

    PAGED_CODE();

    if (deviceRelations){
        ULONG size = sizeof(DEVICE_RELATIONS) + (deviceRelations->Count*sizeof(PDEVICE_OBJECT));
        newDeviceRelations = MemDup(deviceRelations, size);
    }
    else {
        newDeviceRelations = NULL;
    }

    return newDeviceRelations;
}


PUSBD_INTERFACE_LIST_ENTRY GetFunctionInterfaceListBase(
                                    PPARENT_FDO_EXT parentFdoExt, 
                                    ULONG functionIndex,
                                    PULONG numFunctionInterfaces)
{
    PUSBD_INTERFACE_LIST_ENTRY iface = NULL;
    PUSB_CONFIGURATION_DESCRIPTOR configDesc;
    ULONG i, func;
    UCHAR ifaceClass;
    ULONG audFuncBaseIndex = -1;

    PAGED_CODE();

    configDesc = parentFdoExt->selectedConfigDesc;
    ASSERT(configDesc->bNumInterfaces);

    for (func = 0, i = 0; i < (ULONG)configDesc->bNumInterfaces-1; i++){

        ifaceClass = parentFdoExt->interfaceList[i].InterfaceDescriptor->bInterfaceClass;
        if (ifaceClass == USB_DEVICE_CLASS_CONTENT_SECURITY){
            /*
             *  We don't expose the CS interface(s).
             */
            continue;
        }

        if (func == functionIndex){
            break;
        }

        switch (ifaceClass){

            case USB_DEVICE_CLASS_AUDIO:

                /*
                 *  For USB_DEVICE_CLASS_AUDIO, we return groups of interfaces
                 *  with common class as functions.
                 *
                 *  BUT, only while the interface subclass is different than the
                 *  first one in this grouping.  If the subclass is the same,
                 *  then this is a different function.
                 *  Note that it is conceivable that a device could be created
                 *  where a second audio function starts with an interface with
                 *  a different subclass than the previous audio interface, but
                 *  this is how USBHUB's generic parent driver works and thus we
                 *  are bug-compatible with the older driver.
                 */
                if (audFuncBaseIndex == -1){
                    audFuncBaseIndex = i;      
                }
                if ((parentFdoExt->interfaceList[i+1].InterfaceDescriptor->bInterfaceClass !=
                     USB_DEVICE_CLASS_AUDIO) ||
                    (parentFdoExt->interfaceList[audFuncBaseIndex].InterfaceDescriptor->bInterfaceSubClass ==
                     parentFdoExt->interfaceList[i+1].InterfaceDescriptor->bInterfaceSubClass)) {

                    func++;
                    audFuncBaseIndex = -1;     // Reset base index for next audio function.
                }
                break;

            default:

                audFuncBaseIndex = -1;     // Reset base index for next audio function.

                /*
                 *  For other classes, each interface is a function.
                 *  Count alternate interfaces as part of the same function.
                 */
                ASSERT(parentFdoExt->interfaceList[i+1].InterfaceDescriptor->bAlternateSetting == 0); 
                if (parentFdoExt->interfaceList[i+1].InterfaceDescriptor->bAlternateSetting == 0){
                    func++;
                }
                break;
        }
    }



    // note: need this redundant check outside in case bNumInterfaces == 1
    if (func == functionIndex){
        iface = &parentFdoExt->interfaceList[i];
        ifaceClass = iface->InterfaceDescriptor->bInterfaceClass;
        *numFunctionInterfaces = 1;

        if (ifaceClass == USB_DEVICE_CLASS_CONTENT_SECURITY){
            /*
             *  The CS interface was the last interface on the device.
             *  Don't return it as a function.
             */
            iface = NULL;
        }
        else if (ifaceClass == USB_DEVICE_CLASS_AUDIO){
            for (i = i + 1; i < (ULONG)configDesc->bNumInterfaces; i++){
                if ((parentFdoExt->interfaceList[i].InterfaceDescriptor->bInterfaceClass ==
                     iface->InterfaceDescriptor->bInterfaceClass) &&
                    (parentFdoExt->interfaceList[i].InterfaceDescriptor->bInterfaceSubClass !=
                     iface->InterfaceDescriptor->bInterfaceSubClass)){

                    (*numFunctionInterfaces)++;
                }
                else {
                    break;
                }
            }
        }
    }
    else {
        *numFunctionInterfaces = 0;
    }

    return iface;
}



/*
 ********************************************************************************
 *  GetStringDescriptor
 ********************************************************************************
 *
 *  
 *
 */
NTSTATUS GetStringDescriptor(   PPARENT_FDO_EXT parentFdoExt, 
                                UCHAR stringIndex,
                                LANGID langId,
                                PUSB_STRING_DESCRIPTOR stringDesc, 
                                ULONG bufferLen)
{
    NTSTATUS status;
    URB urb;

    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_STRING_DESCRIPTOR_TYPE,
                                 stringIndex,
                                 langId,
                                 stringDesc,
                                 NULL,
                                 bufferLen,
                                 NULL);
    status = SubmitUrb(parentFdoExt, &urb, TRUE, NULL, NULL);

    return status;
}


/*
 ********************************************************************************
 *  SetPdoRegistryParameter
 ********************************************************************************
 *
 *  
 *
 */
NTSTATUS SetPdoRegistryParameter (
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PWCHAR           KeyName,
    IN PVOID            Data,
    IN ULONG            DataLength,
    IN ULONG            KeyType,
    IN ULONG            DevInstKeyType
    )
{
    UNICODE_STRING  keyNameUnicodeString;
    HANDLE          handle;
    NTSTATUS        ntStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&keyNameUnicodeString, KeyName);

    ntStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                       DevInstKeyType,
                                       STANDARD_RIGHTS_ALL,
                                       &handle);


    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ZwSetValueKey(handle,
                                 &keyNameUnicodeString,
                                 0,
                                 KeyType,
                                 Data,
                                 DataLength);

        ZwClose(handle);
    }

    DBGVERBOSE(("SetPdoRegistryParameter status 0x%x\n", ntStatus));

    return ntStatus;
}


/*
 ********************************************************************************
 *  GetPdoRegistryParameter
 ********************************************************************************
 *
 *  
 *
 */
NTSTATUS GetPdoRegistryParameter (
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PWCHAR           ValueName,
    OUT PVOID           Data,
    IN ULONG            DataLength,
    OUT PULONG          Type,
    OUT PULONG          ActualDataLength
    )
/*++

Routine Description:

    This routines queries the data for a registry value entry associated
    with the device instance specific registry key for the PDO.

    The registry value entry would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    PhysicalDeviceObject - Yep, the PDO

    ValueName - Name of the registry value entry for which the data is requested

    Data - Buffer in which the requested data is returned

    DataLength - Length of the data buffer

    Type - (optional) The data type (e.g. REG_SZ, REG_DWORD) is returned here

    ActualDataLength - (optional) The actual length of the data is returned here
                       If this is larger than DataLength then not all of the
                       value data has been returned.

Return Value:

--*/
{
    HANDLE      handle;
    NTSTATUS    ntStatus;

    PAGED_CODE();
    
    ntStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_ALL,
                                       &handle);

    if (NT_SUCCESS(ntStatus))
    {
        PKEY_VALUE_PARTIAL_INFORMATION  partialInfo;
        UNICODE_STRING                  valueName;
        ULONG                           length;
        ULONG                           resultLength;

        RtlInitUnicodeString(&valueName, ValueName);

        // Size and allocate a KEY_VALUE_PARTIAL_INFORMATION structure,
        // including room for the returned value data.
        //
        length = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) +
                 DataLength;

        partialInfo = ALLOCPOOL(PagedPool, length);

        if (partialInfo)
        {
            // Query the value data.
            //
            ntStatus = ZwQueryValueKey(handle,
                                       &valueName,
                                       KeyValuePartialInformation,
                                       partialInfo,
                                       length,
                                       &resultLength);

            // If we got any data that is good enough
            //
            if (ntStatus == STATUS_BUFFER_OVERFLOW)
            {
                ntStatus = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(ntStatus))
            {
                // Only copy the smaller of the the requested data length or
                // the actual data length.
                //
                RtlCopyMemory(Data,
                              partialInfo->Data,
                              DataLength < partialInfo->DataLength ?
                              DataLength :
                              partialInfo->DataLength);

                // Return the value data type and actual length, if requested.
                //
                if (Type)
                {
                    *Type = partialInfo->Type;
                }

                if (ActualDataLength)
                {
                    *ActualDataLength = partialInfo->DataLength;
                }
            }

            FREEPOOL(partialInfo);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        ZwClose(handle);
    }

    return ntStatus;
}

/*
 ********************************************************************************
 *  GetMsOsFeatureDescriptor
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS GetMsOsFeatureDescriptor (
    PPARENT_FDO_EXT ParentFdoExt,
    UCHAR           Recipient,
    UCHAR           InterfaceNumber,
    USHORT          Index,
    PVOID           DataBuffer,
    ULONG           DataBufferLength,
    PULONG          BytesReturned
    )
{
    struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST   *urb;
    NTSTATUS                                    ntStatus;

    PAGED_CODE();

    if (BytesReturned)
    {
        *BytesReturned = 0;
    }

    urb = ALLOCPOOL(NonPagedPool, sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST));

    if (urb != NULL)
    {
        // Initialize the URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR request
        //
        RtlZeroMemory(urb, sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST));

        urb->Hdr.Function = URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR;

        urb->Hdr.Length = sizeof(struct _URB_OS_FEATURE_DESCRIPTOR_REQUEST);

        urb->TransferBufferLength = DataBufferLength;

        urb->TransferBuffer = DataBuffer;

        urb->Recipient = Recipient;

        urb->InterfaceNumber = InterfaceNumber;

        urb->MS_FeatureDescriptorIndex = Index;

        // Submit the URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR request
        //
        ntStatus = SubmitUrb(ParentFdoExt, (PURB)urb, TRUE, NULL, NULL);

        if (NT_SUCCESS(ntStatus) &&
            BytesReturned)
        {
            *BytesReturned = urb->TransferBufferLength;
        }

        FREEPOOL(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*
 ********************************************************************************
 *  GetMsExtendedConfigDescriptor
 ********************************************************************************
 *
 *
 *
 */
NTSTATUS
GetMsExtendedConfigDescriptor (
    IN PPARENT_FDO_EXT ParentFdoExt
    )
/*++

Routine Description:

    This routines queries a device for an Extended Configuration Descriptor.

Arguments:

    ParentFdoExt - The device extension of the parent FDO

Return Value:

    If successful, a pointer to the Extended Configuration Descriptor, which the
    caller must free, else NULL.

--*/
{
    MS_EXT_CONFIG_DESC_HEADER   msExtConfigDescHeader;
    PMS_EXT_CONFIG_DESC         pMsExtConfigDesc;
    ULONG                       bytesReturned;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    ntStatus = STATUS_NOT_SUPPORTED;

    pMsExtConfigDesc = NULL;

    RtlZeroMemory(&msExtConfigDescHeader, sizeof(MS_EXT_CONFIG_DESC_HEADER));

    // Request just the header of the MS Extended Configuration Descriptor 
    //
    ntStatus = GetMsOsFeatureDescriptor(
                   ParentFdoExt,
                   0,   // Recipient Device
                   0,   // Interface
                   MS_EXT_CONFIG_DESCRIPTOR_INDEX,
                   &msExtConfigDescHeader,
                   sizeof(MS_EXT_CONFIG_DESC_HEADER),
                   &bytesReturned);

    // Make sure the MS Extended Configuration Descriptor header looks ok
    //
    if (NT_SUCCESS(ntStatus) &&
        bytesReturned == sizeof(MS_EXT_CONFIG_DESC_HEADER) &&
        msExtConfigDescHeader.bcdVersion == MS_EXT_CONFIG_DESC_VER &&
        msExtConfigDescHeader.wIndex == MS_EXT_CONFIG_DESCRIPTOR_INDEX &&
        msExtConfigDescHeader.bCount > 0 &&
        msExtConfigDescHeader.dwLength == sizeof(MS_EXT_CONFIG_DESC_HEADER) +
        msExtConfigDescHeader.bCount * sizeof(MS_EXT_CONFIG_DESC_FUNCTION))
        
    {
        // Allocate a buffer large enough for the entire descriptor
        //
        pMsExtConfigDesc = ALLOCPOOL(NonPagedPool,
                                     msExtConfigDescHeader.dwLength);

        
        if (pMsExtConfigDesc)
        {
            RtlZeroMemory(pMsExtConfigDesc, msExtConfigDescHeader.dwLength);

            // Request the entire MS Extended Configuration Descriptor
            //
            ntStatus = GetMsOsFeatureDescriptor(
                           ParentFdoExt,
                           0,   // Recipient Device
                           0,   // Interface
                           MS_EXT_CONFIG_DESCRIPTOR_INDEX,
                           pMsExtConfigDesc,
                           msExtConfigDescHeader.dwLength,
                           &bytesReturned);

            if (!( NT_SUCCESS(ntStatus) &&
                   bytesReturned == msExtConfigDescHeader.dwLength &&
                   RtlCompareMemory(&msExtConfigDescHeader,
                                    pMsExtConfigDesc,
                                    sizeof(MS_EXT_CONFIG_DESC_HEADER)) ==
                   sizeof(MS_EXT_CONFIG_DESC_HEADER) &&
                   ValidateMsExtendedConfigDescriptor(
                       pMsExtConfigDesc,
                       ParentFdoExt->selectedConfigDesc) ))
            {
                // Something went wrong retrieving the MS Extended Configuration
                // Descriptor, or it doesn't look valid.  Free the buffer.
                //
                FREEPOOL(pMsExtConfigDesc);

                pMsExtConfigDesc = NULL;
            }
            else
            {
                ntStatus = STATUS_SUCCESS;
            }
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    ASSERT(!ISPTR(ParentFdoExt->msExtConfigDesc));

    ParentFdoExt->msExtConfigDesc = pMsExtConfigDesc;

    return ntStatus;
}

/*
 ********************************************************************************
 *  ValidateMsExtendedConfigDescriptor
 ********************************************************************************
 *
 *
 *
 */
BOOLEAN
ValidateMsExtendedConfigDescriptor (
    IN PMS_EXT_CONFIG_DESC              MsExtConfigDesc,
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor
    )
/*++

Routine Description:

    This routines validates an Extended Configuration Descriptor.

Arguments:

    MsExtConfigDesc - The Extended Configuration Descriptor to be validated.
                      It is assumed that the header of this descriptor has
                      already been validated.

    ConfigurationDescriptor - Configuration Descriptor, assumed to already
                              validated.

Return Value:

    TRUE if the Extended Configuration Descriptor appears to be valid,
    else FALSE.

--*/
{
    UCHAR   interfacesRemaining;
    ULONG   i;
    ULONG   j;
    UCHAR   c;
    BOOLEAN gotNull;

    PAGED_CODE();

    interfacesRemaining = ConfigurationDescriptor->bNumInterfaces;

    for (i = 0; i < MsExtConfigDesc->Header.bCount; i++)
    {
        // Make sure that there is at least one interface in this function.
        //
        if (MsExtConfigDesc->Function[i].bInterfaceCount == 0)
        {
            return FALSE;
        }

        // Make sure that there are not too many interfaces in this function.
        //
        if (MsExtConfigDesc->Function[i].bInterfaceCount > interfacesRemaining)
        {
            return FALSE;
        }

        interfacesRemaining -= MsExtConfigDesc->Function[i].bInterfaceCount;

        // Make sure the no interfaces were skipped between the interfaces
        // of the previous function and the interfaces of this function.
        //
        if (i &&
            MsExtConfigDesc->Function[i-1].bFirstInterfaceNumber +
            MsExtConfigDesc->Function[i-1].bInterfaceCount !=
            MsExtConfigDesc->Function[i].bFirstInterfaceNumber)
        {
            return FALSE;
        }

        // Make sure that the CompatibleID is valid.
        // Valid characters are 'A' through 'Z', '0' through '9', and '_"
        // and null padded to the the right end of the array, but not
        // necessarily null terminated.
        //
        for (j = 0, gotNull = FALSE;
             j < sizeof(MsExtConfigDesc->Function[i].CompatibleID);
             j++)
        {
            c = MsExtConfigDesc->Function[i].CompatibleID[j];

            if (c == 0)
            {
                gotNull = TRUE;
            }
            else
            {
                if (gotNull ||
                    !((c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') ||
                      (c == '_')))
                {
                    return FALSE;
                }
            }
        }

        // Make sure that the SubCompatibleID is valid.
        // Valid characters are 'A' through 'Z', '0' through '9', and '_"
        // and null padded to the the right end of the array, but not
        // necessarily null terminated.
        //
        for (j = 0, gotNull = FALSE;
             j < sizeof(MsExtConfigDesc->Function[i].SubCompatibleID);
             j++)
        {
            c = MsExtConfigDesc->Function[i].SubCompatibleID[j];

            if (c == 0)
            {
                gotNull = TRUE;
            }
            else
            {
                if (gotNull ||
                    !((c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') ||
                      (c == '_')))
                {
                    return FALSE;
                }
            }
        }

        // Make sure that if the SubCompatibleID is non-null then the
        // CompatibleID is also non-null.
        //
        if (MsExtConfigDesc->Function[i].SubCompatibleID[0] != 0 &&
            MsExtConfigDesc->Function[i].CompatibleID[0] == 0)
        {
            return FALSE;
        }
    }

    // Make sure that all of the interfaces were consumed by functions.
    //
    if (interfacesRemaining > 0)
    {
        return FALSE;
    }

    return TRUE;
}



/*
 ********************************************************************************
 *  MemDup
 ********************************************************************************
 *
 *  Return a fresh copy of the argument.
 *
 */
PVOID MemDup(PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    newPtr = (PVOID)ALLOCPOOL(NonPagedPool, length); 
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }
    else {
        DBGWARN(("MemDup: Memory allocation (size %xh) failed -- not a bug if verifier pool failures enabled.", length));
    }
    
    return newPtr;
}

/*
 ********************************************************************************
 *  WStrLen
 ********************************************************************************
 *
 */
ULONG WStrLen(PWCHAR str)
{
    ULONG result = 0;

    while (*str++ != UNICODE_NULL){
        result++;
    }

    return result;
}


/*
 ********************************************************************************
 *  WStrCpy
 ********************************************************************************
 *
 */
ULONG WStrCpy(PWCHAR dest, PWCHAR src)
{
    ULONG result = 0;

    while (*dest++ = *src++){
        result++;
    }

    return result;
}

BOOLEAN WStrCompareN(PWCHAR str1, PWCHAR str2, ULONG maxChars)
{
    while ((maxChars > 0) && *str1 && (*str1 == *str2)){
            maxChars--;
            str1++;
            str2++;
    }

    return (BOOLEAN)((maxChars == 0) || (!*str1 && !*str2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\dbgsrvic.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    DBGSRVIC.C

Abstract:

    Devug services exported by USBD

Environment:

    kernel mode only

Notes:



Revision History:

    09-29-95 : created

--*/


#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"        //public data structures
#include "hcdi.h"

#include "usbd.h"        //private data strutures

#if DBG

// default debug trace level is 0

#ifdef DEBUG1
ULONG USBD_Debug_Trace_Level = 1;    
#else
    #ifdef DEBUG2
    ULONG USBD_Debug_Trace_Level = 2;        
    #else
        #ifdef DEBUG3   
        ULONG USBD_Debug_Trace_Level = 3;      
        #else 
        ULONG USBD_Debug_Trace_Level = 0;
        #endif /* DEBUG3 */
    #endif /* DEBUG2 */
#endif /* DEBUG1 */

LONG USBDTotalHeapAllocated = 0;
#endif /* DBG */

#ifdef DEBUG_LOG
struct USBD_LOG_ENTRY {
    CHAR         le_name[4];      // Identifying string
    ULONG_PTR    le_info1;        // entry specific info
    ULONG_PTR    le_info2;        // entry specific info
    ULONG_PTR    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct USBD_LOG_ENTRY *LStart = 0;    // No log yet
struct USBD_LOG_ENTRY *LPtr;
struct USBD_LOG_ENTRY *LEnd;
#endif /* DEBUG_LOG */

VOID
USBD_Debug_LogEntry(
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
    )
/*++

Routine Description:

    Adds an Entry to USBD log.

Arguments:

Return Value:

    None.

--*/
{
#ifdef DEBUG_LOG
    if (LStart == 0)
        return;

    if (LPtr > LStart)
        LPtr -= 1;    // Decrement to next entry
    else
        LPtr = LEnd;

    RtlCopyMemory(LPtr->le_name, Name, 4);
//    LPtr->le_ret = (stk[1] & 0x00ffffff) | (CurVMID()<<24);
    LPtr->le_info1 = Info1;
    LPtr->le_info2 = Info2;
    LPtr->le_info3 = Info3;

#endif /* DEBUG_LOG */

    return;
}


#ifdef DEBUG_LOG
VOID
USBD_LogInit(
    )
/*++

Routine Description:

    Init the debug log - remember interesting information in a circular buffer

Arguments:

    LogSize - maximum size of log in pages

Return Value:

    None.

--*/
{
    ULONG LogSize = 4096;    //1 page of log entries

    LStart = ExAllocatePool(NonPagedPool,
                              LogSize);

    if (LStart) {
        LPtr = LStart;

        // Point the end (and first entry) 1 entry from the end of the segment
        LEnd = LStart + (LogSize / sizeof(struct USBD_LOG_ENTRY)) - 1;
    }

    return;
}
#endif /* DEBUG_LOG */

//
// tag buffer we use to mark heap blocks we allocate
//

typedef struct _HEAP_TAG_BUFFER {
    ULONG Sig;
    ULONG Length;
} HEAP_TAG_BUFFER, *PHEAP_TAG_BUFFER;


PVOID
USBD_Debug_GetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since
    most NT debug functions are not supported by NTKERN.

Arguments:

    PoolType - pool type passed to ExAllocatePool

    NumberOfBytes - number of bytes for item

    Signature - four byte signature supplied by caller

    TotalAllocatedHeapSpace - pointer to variable where client stores
                the total accumulated heap space allocated.

Return Value:

    pointer to allocated memory

--*/
{
    PUCHAR p;
#ifdef DEBUG_HEAP
    ULONG *stk = NULL;
    PHEAP_TAG_BUFFER tagBuffer;

    // we call ExAllocatePoolWithTag but no tag will be added
    // when running under NTKERN

#ifdef _M_IX86
    _asm     mov stk, ebp
#endif

    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes + sizeof(HEAP_TAG_BUFFER),
                                       Signature);

    if (p) {
        tagBuffer = (PHEAP_TAG_BUFFER) p;
        tagBuffer->Sig = Signature;
        tagBuffer->Length = NumberOfBytes;
        p += sizeof(HEAP_TAG_BUFFER);
        *TotalAllocatedHeapSpace += NumberOfBytes;
    }

    LOGENTRY((PUCHAR) &Signature, 0, 0, 0);
#ifdef _M_IX86    
    LOGENTRY("GetH", p, NumberOfBytes, stk[1] & 0x00FFFFFF);
#else 
     LOGENTRY("GetH", p, NumberOfBytes, 0);
#endif     
#else
    p = (PUCHAR) ExAllocatePoolWithTag(PoolType,
                                       NumberOfBytes,
                                       Signature);

#endif /* DEBUG_HEAP */
    return p;
}


VOID
USBD_Debug_RetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    )
/*++

Routine Description:

    Debug routine, used to debug heap problems.  We are using this since
    most NT debug functions are not supported by NTKERN.

Arguments:

    P - pointer to free

Return Value:

    none.

--*/
{
#ifdef DEBUG_HEAP
    PHEAP_TAG_BUFFER tagBuffer;
    ULONG *stk = NULL   ;

    USBD_ASSERT(P != 0);

#ifdef _M_IX86
    _asm     mov stk, ebp
#endif

    tagBuffer = (PHEAP_TAG_BUFFER) ((PUCHAR)P  - sizeof(HEAP_TAG_BUFFER));

    *TotalAllocatedHeapSpace -= tagBuffer->Length;

    LOGENTRY((PUCHAR) &Signature, 0, 0, 0);
#ifdef _M_IX86    
    LOGENTRY("RetH", P, tagBuffer->Length, stk[1] & 0x00FFFFFF);
#else 
    LOGENTRY("RetH", P, tagBuffer->Length, 0);
#endif

    USBD_ASSERT(*TotalAllocatedHeapSpace >= 0);
    USBD_ASSERT(tagBuffer->Sig == Signature);

    // fill the buffer with bad data
    RtlFillMemory(P, tagBuffer->Length, 0xff);
    tagBuffer->Sig = USBD_FREE_TAG;

    // free the original block
    ExFreePool(tagBuffer);
#else
    ExFreePool(P);
#endif /* DEBUG_HEAP */
}


#if DBG
ULONG
_cdecl
USBD_KdPrintX(
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[5];

    va_start(list, Format);
    for (i=0; i<4; i++)
        arg[i] = va_arg(list, int);

    DbgPrint(Format, arg[0], arg[1], arg[2], arg[3]);

    return 0;
}


VOID
USBD_Warning(
    PUSBD_DEVICE_DATA DeviceData,
    PUCHAR Message,
    BOOLEAN DebugBreak
    )
{                                                                                               
    DbgPrint("USBD: Warning ****************************************************************\n");
    if (DeviceData) {
        DbgPrint("Device PID %04.4x, VID %04.4x\n",     
                 DeviceData->DeviceDescriptor.idProduct, 
                 DeviceData->DeviceDescriptor.idVendor); 
    }
    DbgPrint("%s", Message);

    DbgPrint("******************************************************************************\n");

    if (DebugBreak) {
        DBGBREAK();
    }
}
 

VOID
USBD_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    DBGBREAK();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}
#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\makefile.inc ===
$(O)\usbdp.lib : usbd.src $(IMPLIB_DEPEND)
    cl /nologo /c /D_X86_ /DNO_DEF_ALIAS /EP /Tc usbd.src > $(O)\usbdp.def
    link -lib -nologo -out:$(O)\usbdp.lib -def:$(O)\usbdp.def -machine:IX86 $(IMPLIB_DEPEND)
    copy $(O)\usbdp.lib $(O)\usbd.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\device.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    DEVICE.C

Abstract:

    This module contains the code that implements various support functions
    related to device configuration.

Environment:

    kernel mode only

Notes:



Revision History:

    10-29-95 : created

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"       //public data structures
#include "hcdi.h"

#include "usbd.h"        //private data strutures


#ifdef USBD_DRIVER      // USBPORT supercedes most of USBD, so we will remove
                        // the obsolete code by compiling it only if
                        // USBD_DRIVER is set.


#define DEADMAN_TIMER
#define DEADMAN_TIMEOUT     5000     //timeout in ms
                                     //use a 5 second timeout
typedef struct _USBD_TIMEOUT_CONTEXT {
    PIRP Irp;
    KTIMER TimeoutTimer;
    KDPC TimeoutDpc;
    KSPIN_LOCK TimeoutSpin;
    KEVENT Event;
    BOOLEAN Complete;
} USBD_TIMEOUT_CONTEXT, *PUSBD_TIMEOUT_CONTEXT;

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBD_SubmitSynchronousURB)
#pragma alloc_text(PAGE, USBD_SendCommand)
#pragma alloc_text(PAGE, USBD_OpenEndpoint)
#pragma alloc_text(PAGE, USBD_CloseEndpoint)
#pragma alloc_text(PAGE, USBD_FreeUsbAddress)
#pragma alloc_text(PAGE, USBD_AllocateUsbAddress)
#pragma alloc_text(PAGE, USBD_GetEndpointState)
#endif
#endif

#ifdef DEADMAN_TIMER
VOID
USBD_SyncUrbTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    
    
Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - 

    SystemArgument1 - not used.
    
    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PUSBD_TIMEOUT_CONTEXT usbdTimeoutContext = DeferredContext;
    BOOLEAN complete;
#if DBG    
    BOOLEAN status;
#endif    
    KIRQL irql;

    KeAcquireSpinLock(&usbdTimeoutContext->TimeoutSpin, &irql);
    complete = usbdTimeoutContext->Complete;
    KeReleaseSpinLock(&usbdTimeoutContext->TimeoutSpin, irql);

    if (!complete) {
    
#if DBG
    status = 
#endif
        IoCancelIrp(usbdTimeoutContext->Irp);

#if DBG
        USBD_ASSERT(status == TRUE);    
#endif  
    }

    //OK to free it
    KeSetEvent(&usbdTimeoutContext->Event, 1, FALSE);
}


NTSTATUS
USBD_SyncIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBD_TIMEOUT_CONTEXT usbdTimeoutContext = Context;
    KIRQL irql;
    BOOLEAN cancelled;
    NTSTATUS ntStatus;
    
    KeAcquireSpinLock(&usbdTimeoutContext->TimeoutSpin, &irql);
    
    usbdTimeoutContext->Complete = TRUE;
    cancelled = KeCancelTimer(&usbdTimeoutContext->TimeoutTimer);    
    
    KeReleaseSpinLock(&usbdTimeoutContext->TimeoutSpin, irql);

    // see if the timer was in the queue, if it was then it is safe to free 
    // it
    
    if (cancelled) {
        // safe to free it
        KeSetEvent(&usbdTimeoutContext->Event, 1, FALSE);
    }

    ntStatus = Irp->IoStatus.Status;  
    return ntStatus;
}

#endif /* DEADMAN_TIMER */


NTSTATUS
USBD_SubmitSynchronousURB(
    IN PURB Urb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_DEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Submit a Urb to HCD synchronously

Arguments:

    Urb - Urb to submit

    DeviceObject USBD device object

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
#ifdef DEADMAN_TIMER
    BOOLEAN haveTimer = FALSE;
    PUSBD_TIMEOUT_CONTEXT usbdTimeoutContext;
#endif /* DEADMAN_TIMER */

    PAGED_CODE();

    USBD_KdPrint(3, ("'enter USBD_SubmitSynchronousURB\n"));
    ASSERT_DEVICE(DeviceData);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                HCD_DEVICE_OBJECT(DeviceObject),
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (NULL == irp) {
        USBD_KdBreak(("USBD_SubmitSynchronousURB build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the hc driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

#ifdef DEADMAN_TIMER
    usbdTimeoutContext = GETHEAP(NonPagedPool,
                                 sizeof(*usbdTimeoutContext));
    if (usbdTimeoutContext) {
        LARGE_INTEGER dueTime;

        usbdTimeoutContext->Irp = irp;
        usbdTimeoutContext->Complete = FALSE;

        KeInitializeEvent(&usbdTimeoutContext->Event, NotificationEvent, FALSE);
        KeInitializeSpinLock(&usbdTimeoutContext->TimeoutSpin);
        KeInitializeTimer(&usbdTimeoutContext->TimeoutTimer);
        KeInitializeDpc(&usbdTimeoutContext->TimeoutDpc,
                        USBD_SyncUrbTimeoutDPC,
                        usbdTimeoutContext);

        dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

        KeSetTimer(&usbdTimeoutContext->TimeoutTimer,
                   dueTime,
                   &usbdTimeoutContext->TimeoutDpc);

        haveTimer = TRUE;

        IoSetCompletionRoutine(irp,
                           USBD_SyncIrp_Complete,
                           // always pass FDO to completion routine
                           usbdTimeoutContext,
                           TRUE,
                           TRUE,
                           TRUE);
    }
#endif

    //
    // initialize flags field
    // for internal request
    //
    Urb->UrbHeader.UsbdFlags = 0;

    //
    // Init the Irp field for transfers
    //

    switch(Urb->UrbHeader.Function) {
    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        HC_URB(Urb)->HcdUrbCommonTransfer.hca.HcdIrp = irp;

        if (HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferMDL == NULL &&
            HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferLength != 0) {

            if ((HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferMDL =
                IoAllocateMdl(HC_URB(Urb)->HcdUrbCommonTransfer.TransferBuffer,
                              HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferLength,
                              FALSE,
                              FALSE,
                              NULL)) == NULL)
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            else {
                Urb->UrbHeader.UsbdFlags |= USBD_REQUEST_MDL_ALLOCATED;
                MmBuildMdlForNonPagedPool(HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferMDL);
            }

        }
        break;
    }

    USBD_KdPrint(3, ("'USBD_SubmitSynchronousURB: calling HCD with URB\n"));

    if (NT_SUCCESS(ntStatus)) {
        // set the renter bit on the URB function code
        Urb->UrbHeader.Function |= HCD_NO_USBD_CALL;

        ntStatus = IoCallDriver(HCD_DEVICE_OBJECT(DeviceObject),
                                irp);
    }                                

    USBD_KdPrint(3, ("'ntStatus from IoCallDriver = 0x%x\n", ntStatus));

    status = STATUS_SUCCESS;
    if (ntStatus == STATUS_PENDING) {
    
        status = KeWaitForSingleObject(
                            &event,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);  
                            
        ntStatus = ioStatus.Status;
    } else {
        ioStatus.Status = ntStatus;
    }   

#ifdef DEADMAN_TIMER
    // the completion routine should have canceled the timer
    // so we should never find it in the queue
    //
    // remove our timeoutDPC from the queue
    //
    if (haveTimer) {
        USBD_ASSERT(KeCancelTimer(&usbdTimeoutContext->TimeoutTimer) == FALSE);
        KeWaitForSingleObject(&usbdTimeoutContext->Event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        RETHEAP(usbdTimeoutContext);
    }  
#endif 

// NOTE:
// mapping is handled by completion routine
// called by HCD

    USBD_KdPrint(3, ("'urb status = 0x%x ntStatus = 0x%x\n", Urb->UrbHeader.Status, ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_SendCommand(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT RequestCode,
    IN USHORT WValue,
    IN USHORT WIndex,
    IN USHORT WLength,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned,
    OUT USBD_STATUS *UsbStatus
    )
/*++

Routine Description:

    Send a standard USB command on the default pipe.

Arguments:

    DeviceData - ptr to USBD device structure the command will be sent to

    DeviceObject -

    RequestCode -

    WValue - wValue for setup packet

    WIndex - wIndex for setup packet

    WLength - wLength for setup packet

    Buffer - Input/Output Buffer for command
  BufferLength - Length of Input/Output buffer.

    BytesReturned - pointer to ulong to copy number of bytes
                    returned (optional)

    UsbStatus - USBD status code returned in the URB.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PHCD_URB urb = NULL;
    PUSBD_PIPE defaultPipe;
    PUSB_STANDARD_SETUP_PACKET setupPacket;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_SendCommand\n"));
    ASSERT_DEVICE(DeviceData);

    if (!DeviceData || DeviceData->Sig != SIG_DEVICE) {
        USBD_Warning(NULL,
                     "Bad DeviceData passed to USBD_SendCommand, fail!\n",
                     FALSE);

        return STATUS_INVALID_PARAMETER;
    }

    defaultPipe = &(DeviceData->DefaultPipe);

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    if (deviceExtension->DeviceHackFlags &
        USBD_DEVHACK_SLOW_ENUMERATION) {

        //
        // if noncomplience switch is on in the
        // registry we'll pause here to give the
        // device a chance to respond.
        //

        LARGE_INTEGER deltaTime;
        deltaTime.QuadPart = 100 * -10000;
        (VOID) KeDelayExecutionThread(KernelMode,
                                      FALSE,
                                      &deltaTime);
    }

    urb = GETHEAP(NonPagedPool,
                  sizeof(struct _URB_CONTROL_TRANSFER));

    if (!urb) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_TRANSFER);

        urb->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;

        setupPacket = (PUSB_STANDARD_SETUP_PACKET)
            urb->HcdUrbCommonTransfer.Extension.u.SetupPacket;
        setupPacket->RequestCode = RequestCode;
        setupPacket->wValue = WValue;
        setupPacket->wIndex = WIndex;
        setupPacket->wLength = WLength;

        if (!USBD_ValidatePipe(defaultPipe) ||
            !defaultPipe->HcdEndpoint) {

            USBD_Warning(DeviceData,
                         "Bad DefaultPipe or Endpoint in USBD_SendCommand, fail!\n",
                         FALSE);

            ntStatus = STATUS_INVALID_PARAMETER;
            goto USBD_SendCommand_done;
        }

        urb->HcdUrbCommonTransfer.hca.HcdEndpoint = defaultPipe->HcdEndpoint;
        urb->HcdUrbCommonTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK;

        // USBD is responsible for setting the transfer direction
        //
        // TRANSFER direction is implied in the command

        if (RequestCode & USB_DEVICE_TO_HOST)
            USBD_SET_TRANSFER_DIRECTION_IN(urb->HcdUrbCommonTransfer.TransferFlags);
        else
            USBD_SET_TRANSFER_DIRECTION_OUT(urb->HcdUrbCommonTransfer.TransferFlags);

        urb->HcdUrbCommonTransfer.TransferBufferLength = BufferLength;
        urb->HcdUrbCommonTransfer.TransferBuffer = Buffer;
        urb->HcdUrbCommonTransfer.TransferBufferMDL = NULL;
        urb->HcdUrbCommonTransfer.UrbLink = NULL;

        USBD_KdPrint(3, ("'SendCommand cmd = 0x%x buffer = 0x%x length = 0x%x direction = 0x%x\n",
                         setupPacket->RequestCode,
                         urb->HcdUrbCommonTransfer.TransferBuffer,
                         urb->HcdUrbCommonTransfer.TransferBufferLength,
                         urb->HcdUrbCommonTransfer.TransferFlags
                         ));

        ntStatus = USBD_SubmitSynchronousURB((PURB)urb, DeviceObject, DeviceData);

        if (BytesReturned) {
            *BytesReturned = urb->HcdUrbCommonTransfer.TransferBufferLength;
        }

        if (UsbStatus) {
            *UsbStatus = urb->HcdUrbCommonTransfer.Status;
        }

USBD_SendCommand_done:

        // free the transfer URB

        RETHEAP(urb);

    }

    USBD_KdPrint(3, ("'exit USBD_SendCommand 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_OpenEndpoint(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSBD_PIPE PipeHandle,
    OUT USBD_STATUS *UsbStatus,
    BOOLEAN IsDefaultPipe
    )
/*++

Routine Description:

    open an endpoint on a USB device.

Arguments:

    DeviceData - data describes the device this endpoint is on.

    DeviceObject - USBD device object.

    PipeHandle - USBD PipeHandle to associate with the endpoint.
                 on input MaxTransferSize initialize to the largest
                 transfer that will be sent on this endpoint, 

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PHCD_URB urb;
    PUSBD_EXTENSION deviceExtension;
    extern UCHAR ForceDoubleBuffer;
    extern UCHAR ForceFastIso;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_OpenEndpoint\n"));

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    ASSERT_DEVICE(DeviceData);
    USBD_ASSERT(PIPE_CLOSED(PipeHandle) == TRUE);

    urb = GETHEAP(NonPagedPool,
                  sizeof(struct _URB_HCD_OPEN_ENDPOINT));

    if (!urb) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        urb->UrbHeader.Length = sizeof(struct _URB_HCD_OPEN_ENDPOINT);
        urb->UrbHeader.Function = URB_FUNCTION_HCD_OPEN_ENDPOINT;

        urb->HcdUrbOpenEndpoint.EndpointDescriptor = &PipeHandle->EndpointDescriptor;
        urb->HcdUrbOpenEndpoint.DeviceAddress = DeviceData->DeviceAddress;
        urb->HcdUrbOpenEndpoint.HcdEndpointFlags = 0;

        if (DeviceData->LowSpeed == TRUE) {
            urb->HcdUrbOpenEndpoint.HcdEndpointFlags |= USBD_EP_FLAG_LOWSPEED;
        }            

        // default pipe and iso pipes never halt
        if (IsDefaultPipe ||
              (PipeHandle->EndpointDescriptor.bmAttributes & 
              USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_ISOCHRONOUS) {
            urb->HcdUrbOpenEndpoint.HcdEndpointFlags |= USBD_EP_FLAG_NEVERHALT;
        } 

        if (ForceDoubleBuffer && 
            ((PipeHandle->EndpointDescriptor.bmAttributes & 
                USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_BULK)) {
            PipeHandle->UsbdPipeFlags |= USBD_PF_DOUBLE_BUFFER;
            USBD_KdPrint(1, (">>Forcing Double Buffer -- Bulk <<\n")); 
        }                

        if (ForceFastIso && 
            ((PipeHandle->EndpointDescriptor.bmAttributes & 
                USB_ENDPOINT_TYPE_MASK) == USB_ENDPOINT_TYPE_ISOCHRONOUS)) {
            PipeHandle->UsbdPipeFlags |= USBD_PF_ENABLE_RT_THREAD_ACCESS;
            USBD_KdPrint(1, (">>Forcing Fast Iso <<\n")); 
        }    

        urb->HcdUrbOpenEndpoint.MaxTransferSize = 
            PipeHandle->MaxTransferSize;

        // check client option flags
        if (PipeHandle->UsbdPipeFlags & USBD_PF_DOUBLE_BUFFER) {
            
            USBD_KdPrint(1, (">>Setting Double Buffer Flag<<\n"));
            urb->HcdUrbOpenEndpoint.HcdEndpointFlags |= 
                USBD_EP_FLAG_DOUBLE_BUFFER;
        }

        if (PipeHandle->UsbdPipeFlags & USBD_PF_ENABLE_RT_THREAD_ACCESS) {
            
            USBD_KdPrint(1, (">>Setting Fast ISO Flag<<\n"));
            urb->HcdUrbOpenEndpoint.HcdEndpointFlags |= 
                USBD_EP_FLAG_FAST_ISO;
        }

        if (PipeHandle->UsbdPipeFlags & USBD_PF_MAP_ADD_TRANSFERS) {
            
            USBD_KdPrint(1, (">>Setting Map Add Flag<<\n"));
            urb->HcdUrbOpenEndpoint.HcdEndpointFlags |= 
                USBD_EP_FLAG_MAP_ADD_IO;
        }            
            
        //
        // Serialize Open Endpoint requests
        //

        ntStatus = USBD_SubmitSynchronousURB((PURB) urb, DeviceObject, 
                DeviceData);


        if (NT_SUCCESS(ntStatus)) {
            PipeHandle->HcdEndpoint = urb->HcdUrbOpenEndpoint.HcdEndpoint;
            PipeHandle->ScheduleOffset = urb->HcdUrbOpenEndpoint.ScheduleOffset;
            PipeHandle->Sig = SIG_PIPE;
        }

        if (UsbStatus) {
            *UsbStatus = urb->UrbHeader.Status;
        }            

        RETHEAP(urb);
    }

    USBD_KdPrint(3, ("'exit USBD_OpenEndpoint 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_CloseEndpoint(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    IN OUT USBD_STATUS *UsbStatus
    )
/*++

Routine Description:

    Close an Endpoint

Arguments:

    DeviceData - ptr to USBD device data structure.

    DeviceObject - USBD device object.

    PipeHandle - USBD pipe handle associated with the endpoint.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PHCD_URB urb;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_CloseEndpoint\n"));
    ASSERT_DEVICE(DeviceData);

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    urb = GETHEAP(NonPagedPool,
                  sizeof(struct _URB_HCD_CLOSE_ENDPOINT));

    if (!urb) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        urb->UrbHeader.Length = sizeof(struct _URB_HCD_CLOSE_ENDPOINT);
        urb->UrbHeader.Function = URB_FUNCTION_HCD_CLOSE_ENDPOINT;


        urb->HcdUrbCloseEndpoint.HcdEndpoint = PipeHandle->HcdEndpoint;

        //
        // Serialize Close Endpoint requests
        //

        ntStatus = USBD_SubmitSynchronousURB((PURB) urb, DeviceObject, 
                DeviceData);

        if (UsbStatus) {
            *UsbStatus = urb->UrbHeader.Status;
        }            

        RETHEAP(urb);
    }

    USBD_KdPrint(3, ("'exit USBD_CloseEndpoint 0x%x\n", ntStatus));

    return ntStatus;
}


VOID
USBD_FreeUsbAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT DeviceAddress
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    PUSBD_EXTENSION deviceExtension;
    USHORT address = 0, i, j;
    ULONG bit;

    PAGED_CODE();

    // we should never see a free to device address 0
    
    USBD_ASSERT(DeviceAddress != 0);
    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    for (j=0; j<4; j++) {
        bit = 1;
        for (i=0; i<32; i++) {
            address = (USHORT)(j*32+i);
            if (address == DeviceAddress) {
                deviceExtension->AddressList[j] &= ~bit;
                goto USBD_FreeUsbAddress_Done;
            }
            bit = bit<<1;
        }
    }

USBD_FreeUsbAddress_Done:

    USBD_KdPrint(3, ("'USBD free Address %d\n", address));

}


USHORT
USBD_AllocateUsbAddress(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:


Arguments:

Return Value:

    Valid USB address (1..127) to use for this device,
    returns 0 if no device address available.

--*/
{
    PUSBD_EXTENSION deviceExtension;
    USHORT address = 0, i, j;
    ULONG bit;

    PAGED_CODE();
    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    for (j=0; j<4; j++) {
        bit = 1;
        for (i=0; i<32; i++) {

            if (!(deviceExtension->AddressList[j] & bit)) {
                deviceExtension->AddressList[j] |= bit;
                address = (USHORT)(j*32+i);
                goto USBD_AllocateUsbAddress_Done;
            }
            bit = bit<<1;
        }
    }

 USBD_AllocateUsbAddress_Done:

    USBD_KdPrint(3, ("'USBD assigning Address %d\n", address));

    return address;
}


NTSTATUS
USBD_GetEndpointState(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    OUT USBD_STATUS *UsbStatus,
    OUT PULONG EndpointState
    )
/*++

Routine Description:

    open an endpoint on a USB device.

Arguments:

    DeviceData - data describes the device this endpoint is on.

    DeviceObject - USBD device object.

    PipeHandle - USBD PipeHandle to associate with the endpoint.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PHCD_URB urb;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_GetEndpointState\n"));
    ASSERT_DEVICE(DeviceData);

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    USBD_ASSERT(PIPE_CLOSED(PipeHandle) == FALSE);

    urb = GETHEAP(NonPagedPool,
                  sizeof(struct _URB_HCD_OPEN_ENDPOINT));

    if (!urb) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        urb->UrbHeader.Length = sizeof(struct _URB_HCD_OPEN_ENDPOINT);
        urb->UrbHeader.Function = URB_FUNCTION_HCD_GET_ENDPOINT_STATE;

        urb->HcdUrbEndpointState.HcdEndpoint = PipeHandle->HcdEndpoint;
        urb->HcdUrbEndpointState.HcdEndpointState = 0;

        // Serialize Open Endpoint requests
        //

        ntStatus = USBD_SubmitSynchronousURB((PURB) urb, 
                                              DeviceObject, 
                                              DeviceData);

        if (UsbStatus) {
            *UsbStatus = urb->UrbHeader.Status;
        }            
        
        *EndpointState = urb->HcdUrbEndpointState.HcdEndpointState;
        
        RETHEAP(urb);
    }

    USBD_KdPrint(3, ("'exit USBD_GetEndpointState 0x%x\n", ntStatus));

    return ntStatus;
}


#endif      // USBD_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\urb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    URB.C

Abstract:

    This module contains the code to process URBs passed
    in by client drivers.

Environment:

    kernel mode only

Notes:


** URB handler routines

Handler -- This function handles the specific USBD request, if the function passes
           the urb on to the port driver then it must return STATUS_PENDING.  If any
           parameters are invalid then it returns the appropriate NT status code, and
           the IRP will completed by the deviceControl function.


PostHandler -- This function is called when the Irp/Urb completes through the iocompletion
               routine. This routine is responsible for performing any cleanup and completing
               the request.


Revision History:

    09-29-95 : created
    07-19-96 : removed device object

--*/

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


#include "usbdi.h"        //public data structures
#include "hcdi.h"

#include "usbd.h"        //private data strutures


#ifdef USBD_DRIVER      // USBPORT supercedes most of USBD, so we will remove
                        // the obsolete code by compiling it only if
                        // USBD_DRIVER is set.



typedef NTSTATUS URB_HANDLER(PDEVICE_OBJECT DeviceObject, PIRP Irp, PURB Urb, BOOLEAN *IrpIsPending);
typedef NTSTATUS URB_POSTHANDLER(PDEVICE_OBJECT DeviceObject, PIRP Irp, PURB Urb, PVOID Context);

typedef struct _URB_DISPATCH_ENTRY {
    URB_HANDLER    *UrbHandler;    // API handler
    USHORT UrbRequestLength;    // Length of the URB expected for this request
    USHORT RequestCode;            // Request code for setup packet if standard command
    ULONG Flags;
#if DBG
    ULONG ExpectedFunctionCode;
#endif    
} URB_DISPATCH_ENTRY;

URB_HANDLER USBD_SelectConfiguration;

URB_HANDLER USBD_SelectInterface;

URB_HANDLER USBD_AsyncTransfer;

URB_HANDLER USBD_IsochTransfer;

URB_HANDLER USBD_PassThru;

URB_HANDLER USBD_AbortPipe;

URB_HANDLER USBD_ResetPipe;

URB_HANDLER USBD_SCT_GetSetDescriptor;

URB_HANDLER USBD_SCT_SetClearFeature;

URB_HANDLER USBD_SCT_GetStatus;

URB_HANDLER USBD_SCT_VendorClassCommand;

URB_HANDLER USBD_SCT_GetInterface;

URB_HANDLER USBD_SCT_GetConfiguration;

URB_HANDLER USBD_TakeFrameLengthControl;

URB_HANDLER USBD_ReleaseFrameLengthControl;

URB_HANDLER USBD_GetFrameLength;

URB_HANDLER USBD_SetFrameLength;

URB_HANDLER USBD_BulkTransfer;

URB_DISPATCH_ENTRY UrbDispatchTable[URB_FUNCTION_LAST+1] =
{
    //URB_FUNCTION_SELECT_CONFIGURATION                    
    USBD_SelectConfiguration, 
    0,  // handler will validate length 
    0,  
    0,
#if DBG
    URB_FUNCTION_SELECT_CONFIGURATION,
#endif    
    //URB_FUNCTION_SELECT_INTERFACE                        
    USBD_SelectInterface, 
    0,
    0,
    0,
#if DBG
    URB_FUNCTION_SELECT_INTERFACE,
#endif        
    //URB_FUNCTION_ABORT_PIPE                     
    USBD_AbortPipe, 
    sizeof(struct _URB_PIPE_REQUEST),
    0,
    0,
#if DBG
    URB_FUNCTION_ABORT_PIPE,
#endif        
    //URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL            
    USBD_TakeFrameLengthControl, 
    sizeof(struct _URB_FRAME_LENGTH_CONTROL),
    0,
    0,
#if DBG
    URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL,
#endif        
    //URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL        
    USBD_ReleaseFrameLengthControl, 
    sizeof(struct _URB_FRAME_LENGTH_CONTROL),
    0,
    0,
#if DBG
    URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL,
#endif        
    //URB_FUNCTION_GET_FRAME_LENGTH                    
    USBD_GetFrameLength, 
    sizeof(struct _URB_GET_FRAME_LENGTH),
    0,
    0,
#if DBG
    URB_FUNCTION_GET_FRAME_LENGTH,
#endif        
    //URB_FUNCTION_SET_FRAME_LENGTH                    
    USBD_SetFrameLength, 
    sizeof(struct _URB_SET_FRAME_LENGTH),
    0,
    0,
#if DBG
    URB_FUNCTION_SET_FRAME_LENGTH,
#endif        
    //URB_FUNCTION_GET_CURRENT_FRAME_NUMBER            
    USBD_PassThru, 
    0,
    0,
    0,
#if DBG
    URB_FUNCTION_GET_CURRENT_FRAME_NUMBER,
#endif        
    //URB_FUNCTION_CONTROL_TRANSFER            
    USBD_AsyncTransfer, 
    sizeof(struct _URB_CONTROL_TRANSFER),
    0,
    USBD_REQUEST_IS_TRANSFER,
#if DBG
    URB_FUNCTION_CONTROL_TRANSFER,
#endif        
    //URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER                         
    USBD_AsyncTransfer, 
    sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
    0,
    USBD_REQUEST_IS_TRANSFER,
#if DBG
    URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER,
#endif        
    //URB_FUNCTION_ISOCH_TRANSFER            
    USBD_IsochTransfer, 
    0,
    0,
    USBD_REQUEST_IS_TRANSFER,
#if DBG
    URB_FUNCTION_ISOCH_TRANSFER,
#endif        
    //URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE                        
    USBD_SCT_GetSetDescriptor, 
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
    STANDARD_COMMAND_GET_DESCRIPTOR,
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE,
#endif        
    //URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE                        
    USBD_SCT_GetSetDescriptor, 
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
    STANDARD_COMMAND_SET_DESCRIPTOR,
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE,
#endif        
    //URB_FUNCTION_SET_FEATURE_TO_DEVICE                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_DEVICE) | (USB_REQUEST_SET_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_DEVICE,
#endif        
    //URB_FUNCTION_SET_FEATURE_TO_INTERFACE                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_INTERFACE) | (USB_REQUEST_SET_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_INTERFACE,
#endif        
    //URB_FUNCTION_SET_FEATURE_TO_ENDPOINT                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_ENDPOINT) | (USB_REQUEST_SET_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_ENDPOINT,
#endif        
    //URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_DEVICE) | (USB_REQUEST_CLEAR_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE,
#endif        
    //URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_INTERFACE) | (USB_REQUEST_CLEAR_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE,
#endif        
    //URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_ENDPOINT) | (USB_REQUEST_CLEAR_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT,
#endif        
    //URB_FUNCTION_GET_STATUS_FROMDEVICE                            
    USBD_SCT_GetStatus, 
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_DEVICE) | (USB_REQUEST_GET_STATUS<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_DEVICE,
#endif        
    //URB_FUNCTION_GET_STATUS_FROM_INTERFACE                            
    USBD_SCT_GetStatus, 
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_INTERFACE) | (USB_REQUEST_GET_STATUS<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_INTERFACE,
#endif        
    //URB_FUNCTION_GET_STATUS_FROMENDPOINT                            
    USBD_SCT_GetStatus, 
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_ENDPOINT) | (USB_REQUEST_GET_STATUS<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_ENDPOINT,
#endif        
    //URB_FUNCTION_SYNC_FRAME                            
    NULL, 
    0,
    0,
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    0, //URB_FUNCTION_SYNC_FRAME,
#endif        
    //URB_FUNCTION_VENDOR_DEVICE                                                    
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_DEVICE | USB_VENDOR_COMMAND),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_VENDOR_DEVICE,
#endif        
    //URB_FUNCTION_VENDOR_INTERFACE                
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_INTERFACE | USB_VENDOR_COMMAND),    
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_VENDOR_INTERFACE,
#endif        
    //URB_FUNCTION_VENDOR_ENDPOINT                
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_ENDPOINT | USB_VENDOR_COMMAND),            
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_VENDOR_ENDPOINT,
#endif        
    //URB_FUNCTION_CLASS_DEVICE                    
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_DEVICE | USB_CLASS_COMMAND),    
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_CLASS_DEVICE,
#endif        
    //URB_FUNCTION_CLASS_INTERFACE                
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_INTERFACE | USB_CLASS_COMMAND),    
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_CLASS_INTERFACE,
#endif        
    //URB_FUNCTION_CLASS_ENDPOINT                
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_ENDPOINT | USB_CLASS_COMMAND),    
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_CLASS_ENDPOINT,
#endif
    //URB_FUNCTION_ NOT USED
    NULL, 
    0,
    0,
    0,
#if DBG
    URB_FUNCTION_RESERVED,
#endif            
    //URB_FUNCTION_RESET_PIPE                    
    USBD_ResetPipe, 
    sizeof(struct _URB_PIPE_REQUEST),
    (USB_COMMAND_TO_DEVICE),        
    0,
#if DBG
    URB_FUNCTION_RESET_PIPE,
#endif        
    //URB_FUNCTION_CLASS_OTHER                    
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_OTHER | USB_CLASS_COMMAND),        
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_CLASS_OTHER,
#endif        
    //URB_FUNCTION_VENDOR_OTHER                
    USBD_SCT_VendorClassCommand, 
    sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
    (USB_COMMAND_TO_OTHER | USB_VENDOR_COMMAND),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_VENDOR_OTHER,
#endif        
    //URB_FUNCTION_GET_STATUS_FROMOTHER                            
    USBD_SCT_GetStatus, 
    sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_OTHER) | (USB_REQUEST_GET_STATUS<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_STATUS_FROM_OTHER,
#endif    
    //URB_FUNCTION_CLEAR_FEATURE_TO_OTHER                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_OTHER) | (USB_REQUEST_CLEAR_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_CLEAR_FEATURE_TO_OTHER,
#endif    
    //URB_FUNCTION_SET_FEATURE_TO_OTHER                        
    USBD_SCT_SetClearFeature, 
    sizeof(struct _URB_CONTROL_FEATURE_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_OTHER) | (USB_REQUEST_SET_FEATURE<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE | USBD_REQUEST_NO_DATA_PHASE,
#if DBG
    URB_FUNCTION_SET_FEATURE_TO_INTERFACE,
#endif                    
     //URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT                        
    USBD_SCT_GetSetDescriptor, 
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_ENDPOINT) | (USB_REQUEST_GET_DESCRIPTOR<<8)),  
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT,
#endif                    
     //URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT
    USBD_SCT_GetSetDescriptor,
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_ENDPOINT) | (USB_REQUEST_SET_DESCRIPTOR<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT,
#endif         
    //URB_FUNCTION_GET_CONFIGURATION                        
    USBD_SCT_GetConfiguration, 
    sizeof(struct _URB_CONTROL_GET_CONFIGURATION_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_DEVICE) | 
        (USB_REQUEST_GET_CONFIGURATION<<8)),  
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_CONFIGURATION,
#endif                    
    //URB_FUNCTION_GET_INTERFACE                        
    USBD_SCT_GetInterface, 
    sizeof(struct _URB_CONTROL_GET_INTERFACE_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_INTERFACE) | 
        (USB_REQUEST_GET_INTERFACE<<8)),  
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_INTERFACE,
#endif
    //URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE
    USBD_SCT_GetSetDescriptor,
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
    ((USB_DEVICE_TO_HOST | USB_COMMAND_TO_INTERFACE) | (USB_REQUEST_GET_DESCRIPTOR<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE,
#endif
    //URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE
    USBD_SCT_GetSetDescriptor,
    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
    ((USB_HOST_TO_DEVICE | USB_COMMAND_TO_INTERFACE) | (USB_REQUEST_SET_DESCRIPTOR<<8)),
    USBD_REQUEST_IS_TRANSFER | USBD_REQUEST_USES_DEFAULT_PIPE,
#if DBG
    URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE,
#endif
};


BOOLEAN
USBD_ValidatePipe(
    PUSBD_PIPE PipeHandle
    )
/*++

Routine Description:

    Validates the pipe flags and anything else that we deem appropriate.

Arguments:

    PipeHandle - PipeHandle associated with the URB in this IRP request

Return Value:

    Boolean value indicating whether PipeHandle should be considered valid
    or not

--*/
{
    if (!PipeHandle ||
        (PipeHandle->Sig != SIG_PIPE) ||
        (PipeHandle->UsbdPipeFlags & ~(USBD_PF_VALID_MASK))) {
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
USBD_ProcessURB(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Processes a URB from a client IRP, this does the guts of the
    processing.

    Two way to tell the caller not to pass the URB on
    1) set IrpIsPending to FALSE or
    2) return an error in

Arguments:

    DeviceObject - Device object associated with this IRP request

    Irp -  IO request block

    Urb -  ptr to USB request block

    IrpIsPending - FALSE if USBD completes the IRP

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT function;
    PHCD_URB hcdUrb = (PHCD_URB) Urb;
    PUSBD_PIPE pipeHandle;
    PUSBD_DEVICE_DATA device;

    USBD_KdPrint(3, ("'enter USBD_ProcessURB\n"));

    if (Urb == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    // initialize the error code to zero,
    // some drivers do not initailize on entry
    hcdUrb->HcdUrbCommonTransfer.Status = 0;

    if (Urb->UrbHeader.UsbdDeviceHandle == NULL) {
        PUSBD_EXTENSION deviceExtension;

        deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

        USBD_KdPrint(3, ("'USBD_ProcessURB -- URB for root hub\n"));
        Urb->UrbHeader.UsbdDeviceHandle =
            deviceExtension->RootHubDeviceData;
    }

    function = Urb->UrbHeader.Function;

    // Initialize flags field for this request
    hcdUrb->UrbHeader.UsbdFlags = 0;

    USBD_KdPrint(3, ("'USBD_ProcessURB, function = 0x%x\n", function));

    if (function > URB_FUNCTION_LAST) {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
#if DBG
      else {
        USBD_ASSERT(UrbDispatchTable[function].ExpectedFunctionCode == function);
    }
#endif

    //
    // do some special transfer specific stuff
    //
    device = DEVICE_FROM_DEVICEHANDLEROBJECT(Urb->UrbHeader.UsbdDeviceHandle);

    if (!device) {
        hcdUrb->HcdUrbCommonTransfer.Status =
                    SET_USBD_ERROR(USBD_STATUS_INVALID_PARAMETER);
        goto USBD_ProcessURB_Done;
    }

    ASSERT_DEVICE(device);

    if (UrbDispatchTable[function].Flags & USBD_REQUEST_IS_TRANSFER) {

        if (!device->AcceptingRequests) {
            //
            // Driver is attempting to transfer data when the device
            // is not in a state to accept requets or is not configured
            //
            USBD_Warning(device,
                         "Failing driver transfer requests\n",
                         FALSE);

            hcdUrb->HcdUrbCommonTransfer.Status =
                        SET_USBD_ERROR(USBD_STATUS_INVALID_PARAMETER);
            goto USBD_ProcessURB_Done;
        }

        while (hcdUrb) {

            hcdUrb->UrbHeader.UsbdFlags |= USBD_REQUEST_IS_TRANSFER;

            if (UrbDispatchTable[function].Flags & USBD_REQUEST_NO_DATA_PHASE) {
                hcdUrb->HcdUrbCommonTransfer.TransferBuffer = NULL;
                hcdUrb->HcdUrbCommonTransfer.TransferBufferMDL = NULL;
                hcdUrb->HcdUrbCommonTransfer.TransferBufferLength = 0;
            }

            if (UrbDispatchTable[function].Flags & USBD_REQUEST_USES_DEFAULT_PIPE) {
                ASSERT_PIPE(&device->DefaultPipe);
                hcdUrb->HcdUrbCommonTransfer.UsbdPipeHandle = &device->DefaultPipe;
            } else if (function == URB_FUNCTION_CONTROL_TRANSFER &&
                       hcdUrb->HcdUrbCommonTransfer.UsbdPipeHandle == 0) {

                PUSBD_EXTENSION deviceExtension;

                deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

        		if  ((deviceExtension->DiagnosticMode) &&
		   			!( (deviceExtension->DiagIgnoreHubs) &&
					   (device->DeviceDescriptor.bDeviceClass == 0x09) ) )
				{

                    // allow 0 to indicate default pipe in diag mode
                    device = DEVICE_FROM_DEVICEHANDLEROBJECT(Urb->UrbHeader.UsbdDeviceHandle);
                    ASSERT_PIPE(&device->DefaultPipe);
                    hcdUrb->HcdUrbCommonTransfer.UsbdPipeHandle =
                        &device->DefaultPipe;
                } else {
                    hcdUrb->HcdUrbCommonTransfer.Status =
                        SET_USBD_ERROR(USBD_STATUS_INVALID_PIPE_HANDLE);
                    goto USBD_ProcessURB_Done;
                }
            }

            pipeHandle = hcdUrb->HcdUrbCommonTransfer.UsbdPipeHandle;

            ASSERT_PIPE(pipeHandle);

            // Validate the pipe flags.
            // BUGBUG: Need to use USBD_STATUS_INVALID_PIPE_FLAGS (usb.h).

            if (!USBD_ValidatePipe(pipeHandle)) {
                USBD_Warning(device,
                             "Invalid PipeFlags passed to USBD_ProcessURB, fail!\n",
                             TRUE);
                hcdUrb->HcdUrbCommonTransfer.Status =
                    SET_USBD_ERROR(USBD_STATUS_INVALID_PIPE_HANDLE);
                goto USBD_ProcessURB_Done;
            }

            // make sure the pipe handle is still valid
            if (PIPE_CLOSED(pipeHandle)) {
                USBD_Warning(device,
                             "PipeHandle closed in USBD_ProcessURB\n",
                             FALSE);
                hcdUrb->HcdUrbCommonTransfer.Status =
                    SET_USBD_ERROR(USBD_STATUS_INVALID_PIPE_HANDLE);
                goto USBD_ProcessURB_Done;
            }

            hcdUrb->HcdUrbCommonTransfer.hca.HcdIrp = Irp;
            hcdUrb->HcdUrbCommonTransfer.hca.HcdExtension = NULL;

            // if only a system buffer address is specified then
            // the caller has passed in a buffer allocated from the
            // non-paged pool -- we allocate an MDL for the request in
            // this case.

            if (hcdUrb->HcdUrbCommonTransfer.TransferBufferMDL == NULL &&
                hcdUrb->HcdUrbCommonTransfer.TransferBufferLength != 0) {

                if ((hcdUrb->HcdUrbCommonTransfer.TransferBufferMDL =
                    IoAllocateMdl(hcdUrb->HcdUrbCommonTransfer.TransferBuffer,
                                  hcdUrb->HcdUrbCommonTransfer.TransferBufferLength,
                                  FALSE,
                                  FALSE,
                                  NULL)) == NULL)
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                else {
                    hcdUrb->UrbHeader.UsbdFlags |= USBD_REQUEST_MDL_ALLOCATED;
                    MmBuildMdlForNonPagedPool(hcdUrb->HcdUrbCommonTransfer.TransferBufferMDL);
                }
                    
            }

            if (hcdUrb->HcdUrbCommonTransfer.TransferBufferMDL != NULL && 
                hcdUrb->HcdUrbCommonTransfer.TransferBufferLength == 0) {
                ntStatus = STATUS_INVALID_PARAMETER;
            }                

            // get next urb in the chain
            hcdUrb = hcdUrb->HcdUrbCommonTransfer.UrbLink;
            
        } /* end while hcd urb */     
        
    } else {
        /* request is not a transfer, we will still attempt some validation */
        switch(function) {
        case URB_FUNCTION_ABORT_PIPE:                      
        case URB_FUNCTION_RESET_PIPE:                      
            /* not valid to attempt these after a remove */
            //
            // NOTE there is no gurantee that device will be valid
            // at this point but we will at least attempt to catch it
            // 
            // in the case whwee the driver is attempting a reset of its 
            // port this will prevent calls to the HCD with bogus endpoint
            // handles.
            //
            if (!device->AcceptingRequests) {
                USBD_Warning(NULL,
                             "Failing ABORT/RESET request\n",
                             FALSE);
                                            
                hcdUrb->HcdUrbCommonTransfer.Status = 
                        SET_USBD_ERROR(USBD_STATUS_INVALID_PARAMETER);
                goto USBD_ProcessURB_Done;   
            }                             
            break;
        }
    }

    //
    // validate the length field based on the function
    //

    if (NT_SUCCESS(ntStatus) &&
             UrbDispatchTable[function].UrbRequestLength &&
             UrbDispatchTable[function].UrbRequestLength != Urb->UrbHeader.Length) {
        ntStatus = STATUS_INVALID_PARAMETER; 
        USBD_KdPrint(3, ("' Inavlid parameter length  length = 0x%x, expected = 0x%x\n", 
                  Urb->UrbHeader.Length, 
                  UrbDispatchTable[function].UrbRequestLength));
    }

    if (NT_SUCCESS(ntStatus)) {
        if (UrbDispatchTable[function].UrbHandler) 
            ntStatus = (UrbDispatchTable[function].UrbHandler)(DeviceObject, Irp, Urb, IrpIsPending);
        else {
            //
            //Complete the Irp now with an error.
            //
            ntStatus = STATUS_NOT_IMPLEMENTED;
        }
    }

USBD_ProcessURB_Done:

    //
    // if the URB error code is set then this will map to
    // the appropriate nt status code to that the irp will
    // be completed.
    //
    
    ntStatus = USBD_MapError_UrbToNT(Urb, ntStatus);

    USBD_KdPrint(3, ("'exit USBD_ProcessURB 0x%x\n", ntStatus));

    return ntStatus;    
}


NTSTATUS
USBD_MapError_UrbToNT(
    IN PURB Urb,
    IN NTSTATUS NtStatus
    )
/*++

Routine Description:

    Map a USBD specific error code in a URB to a NTSTATUS 
    code. 

Arguments:

    Urb -  ptr to USB request block

Return Value:


--*/
{
    //
    // if we have an NT status code then just return
    // that.
    //

    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }        

    // otherwise...

    //
    // if the irp completed with no error code but the URB has an 
    // error, map the error in the urb to an nt error code. 
    //

    if (USBD_SUCCESS(Urb->UrbHeader.Status)) {
        NtStatus = STATUS_SUCCESS;
    } else {
        // 
        // map the USBD status code to 
        // an NT status code.
        //

        switch (Urb->UrbHeader.Status) {
        case USBD_STATUS_NO_MEMORY:
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        case USBD_STATUS_INVALID_URB_FUNCTION:
        case USBD_STATUS_INVALID_PARAMETER:      
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        default:
            NtStatus = STATUS_DEVICE_DATA_ERROR;
        }            
    }

    return NtStatus;
}


NTSTATUS
USBD_SCT_GetSetDescriptor(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

Arguments:

    DeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STANDARD_SETUP_PACKET setupPacket;

    USBD_KdPrint(3, ("' enter USBD_SCT_GetSetDescriptor\n"));

    setupPacket = (PUSB_STANDARD_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;
    
    setupPacket->RequestCode = 
        UrbDispatchTable[Urb->UrbHeader.Function].RequestCode;    

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;                    
    if (USB_DEVICE_TO_HOST & setupPacket->RequestCode) {
        USBD_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT(Urb->UrbControlTransfer.TransferFlags);
    }        

#if DBG
    //
    // some parameter validation
    //
    {
    UCHAR bRequest = (UCHAR) (setupPacket->RequestCode >> 8);
    UCHAR dType, dIndex, *pch;

    dType = (UCHAR) (setupPacket->wValue >> 8);
    dIndex = (UCHAR) setupPacket->wValue;

    pch = (PUCHAR) setupPacket;
    
    USBD_KdPrint(3, ("'USB REQUEST  %02.2x %02.2x %02.2x %02.2x ",
        *pch, *(pch+1), *(pch+2), *(pch+3)));
    USBD_KdPrint(3, ("'USB REQUEST  %02.2x %02.2x %02.2x %02.2x\n",
        *(pch+4), *(pch+5), *(pch+6), *(pch+7)));
        

    USBD_KdPrint(3, ("'USB REQUEST bRequest = %x dType = %x dIndex = %x wLength = %x\n",
        bRequest, dType, dIndex, setupPacket->wLength));
    
    switch (bRequest) {
        // get descriptor command
    case USB_REQUEST_GET_DESCRIPTOR:
    case USB_REQUEST_SET_DESCRIPTOR:
        if (dType == 4 || dType == 5) {
            USBD_Warning(NULL,
                         "USBD detects a bogus Get/Set Descriptor Request from driver\n",
                         TRUE);
        }            
        break;
    default:  
        USBD_KdBreak(("Invalid Get/Set Descriptor request\n"));
    }

    }
#endif
                  
    if (NT_SUCCESS(ntStatus)) {
        ((PHCD_URB) Urb)->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
        ((PHCD_URB) Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = 
            ((PUSBD_PIPE)((PHCD_URB)Urb)->HcdUrbCommonTransfer.UsbdPipeHandle)->HcdEndpoint;

        *IrpIsPending = TRUE;
    }

    USBD_KdPrint(3, ("' exit USBD_SCT_GetSetDescriptor 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_SCT_SetClearFeature(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

Arguments:

    DeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STANDARD_SETUP_PACKET setupPacket;

    USBD_KdPrint(3, ("' enter USBD_SCT_SetClearFeature\n"));

    setupPacket = (PUSB_STANDARD_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = 0;
    //setupPacket->wValue = Urb->UrbControlFeatureRequest.FeatureSelector;            
    //setupPacket->wIndex = Urb->UrbControlFeatureRequest.Index;

    setupPacket->RequestCode = 
        UrbDispatchTable[Urb->UrbHeader.Function].RequestCode;            

    Urb->UrbControlTransfer.TransferBufferLength = 0;

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   
    if (USB_DEVICE_TO_HOST & setupPacket->RequestCode) {
        USBD_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT( Urb->UrbControlTransfer.TransferFlags);
    }        
    
    if (NT_SUCCESS(ntStatus)) {
        ((PHCD_URB) Urb)->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
        ((PHCD_URB) Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = 
            ((PUSBD_PIPE)((PHCD_URB)Urb)->HcdUrbCommonTransfer.UsbdPipeHandle)->HcdEndpoint;
        
        *IrpIsPending = TRUE;
    }

    USBD_KdPrint(3, ("' exit USBD_SCT_SetClearFeature 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_SCT_GetStatus(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

Arguments:

    DeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STANDARD_SETUP_PACKET setupPacket;

    USBD_KdPrint(3, ("' enter USBD_SCT_GetStatus\n"));

    setupPacket = (PUSB_STANDARD_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    //
    // setup common fields
    //
    
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;

    if (setupPacket->wLength != 2) {
        ntStatus = STATUS_INVALID_PARAMETER;
        Urb->UrbHeader.Status = 
                    SET_USBD_ERROR(USBD_STATUS_INVALID_PARAMETER);
        goto USBD_SCT_GetStatus_Done;
    }
    
    setupPacket->wValue = 0;            

    setupPacket->RequestCode = 
        UrbDispatchTable[Urb->UrbHeader.Function].RequestCode;            

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   
    if (USB_DEVICE_TO_HOST & setupPacket->RequestCode) {
        USBD_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT( Urb->UrbControlTransfer.TransferFlags);
    }        

    if (NT_SUCCESS(ntStatus)) {
        ((PHCD_URB) Urb)->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
        ((PHCD_URB) Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = 
            ((PUSBD_PIPE)((PHCD_URB)Urb)->HcdUrbCommonTransfer.UsbdPipeHandle)->HcdEndpoint;
        
        *IrpIsPending = TRUE;
    }

USBD_SCT_GetStatus_Done:

    USBD_KdPrint(3, ("' exit USBD_SCT_GetStatus 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_SCT_VendorClassCommand(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

Arguments:

    DeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STANDARD_SETUP_PACKET setupPacket;
    UCHAR direction;

    USBD_KdPrint(3, ("' enter USBD_SCT_VendorClassCommand\n"));

    setupPacket = (PUSB_STANDARD_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;
    
    direction = (UCHAR)( (Urb->UrbControlTransfer.TransferFlags & 
            USBD_TRANSFER_DIRECTION_IN) ?
            USB_DEVICE_TO_HOST : USB_HOST_TO_DEVICE);

    USBD_KdPrint(3, ("' direction = 0x%x\n", direction));            

    // allow only reserved bits to be set by caller
    setupPacket->RequestCode &= ~0x00e3;
    
    setupPacket->RequestCode |= 
        (direction | UrbDispatchTable[Urb->UrbHeader.Function].RequestCode);

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   
    if (USB_DEVICE_TO_HOST & setupPacket->RequestCode) {
        USBD_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT( Urb->UrbControlTransfer.TransferFlags);
    }            

    if (NT_SUCCESS(ntStatus)) {
        ((PHCD_URB) Urb)->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
        ((PHCD_URB) Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = 
            ((PUSBD_PIPE)((PHCD_URB)Urb)->HcdUrbCommonTransfer.UsbdPipeHandle)->HcdEndpoint;
            
        *IrpIsPending = TRUE;
    }

    USBD_KdPrint(3, ("' exit USBD_SCT_VendorClassCommand 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_AsyncTransfer(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    pass interrupt or bulk transfer to HCD

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_PIPE pipeHandle;

    USBD_KdPrint(3, ("' enter USBD_AsyncTransfer\n"));

    deviceData = Urb->UrbHeader.UsbdDeviceHandle;

    // pass the irp to HCD

    // extract the pipe handle
    pipeHandle =  (PUSBD_PIPE)((PHCD_URB)Urb)->HcdUrbCommonTransfer.UsbdPipeHandle;

    ASSERT_PIPE(pipeHandle);

    ((PHCD_URB)Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = pipeHandle->HcdEndpoint;

    // set the proper direction based on the direction bit stored with the
    // endpoint address. if this is a control transfer then leave the direction
    // bit alone.

    if ((USB_ENDPOINT_TYPE_MASK & pipeHandle->EndpointDescriptor.bmAttributes)
        != USB_ENDPOINT_TYPE_CONTROL) {
        if (pipeHandle->EndpointDescriptor.bEndpointAddress &
                USB_ENDPOINT_DIRECTION_MASK) {
            USBD_SET_TRANSFER_DIRECTION_IN(((PHCD_URB)Urb)->HcdUrbCommonTransfer.TransferFlags);
        } else {
            USBD_SET_TRANSFER_DIRECTION_OUT(((PHCD_URB)Urb)->HcdUrbCommonTransfer.TransferFlags);
        }
    }

    *IrpIsPending = TRUE;

    USBD_KdPrint(3, ("' exit USBD_AsyncTransfer 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_IsochTransfer(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    pass interrupt transfer to HCD

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_PIPE pipeHandle;
    ULONG transferFlags;
    struct _URB_ISOCH_TRANSFER  *iso;

    USBD_KdPrint(3, ("' enter USBD_IsochTransfer\n"));

    deviceData = Urb->UrbHeader.UsbdDeviceHandle;

    // pass the irp to HCD

    // extract the pipe handle
    pipeHandle =  (PUSBD_PIPE)Urb->UrbIsochronousTransfer.PipeHandle;  
    transferFlags = Urb->UrbIsochronousTransfer.TransferFlags;
    iso = (struct _URB_ISOCH_TRANSFER  *)Urb;
    
    ASSERT_PIPE(pipeHandle);

    //
    // limit iso transfers to 255 packets per URB
    //
    if (iso->NumberOfPackets == 0 ||
        iso->NumberOfPackets > 255)
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        Urb->UrbHeader.Status = 
                    SET_USBD_ERROR(USBD_STATUS_INVALID_PARAMETER);
        *IrpIsPending = FALSE;                    
        goto USBD_IsochTransfer_Done;
    }

    ((PHCD_URB)Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = pipeHandle->HcdEndpoint;    

    // set the proper direction based on the direction bit stored with the 
    // endpoint address. 
    
    if (pipeHandle->EndpointDescriptor.bEndpointAddress & 
        USB_ENDPOINT_DIRECTION_MASK) {
        USBD_SET_TRANSFER_DIRECTION_IN(((PHCD_URB)Urb)->HcdUrbCommonTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT(((PHCD_URB)Urb)->HcdUrbCommonTransfer.TransferFlags);
    }        
            
    *IrpIsPending = TRUE;

USBD_IsochTransfer_Done:

    USBD_KdPrint(3, ("' exit USBD_IsochTransfer 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_PassThru(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    pass urb thru unmodified

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    USBD_KdPrint(3, ("' enter USBD_PassThru\n"));

    //deviceData = Urb->UrbHeader.UsbdDeviceHandle;

    *IrpIsPending = TRUE;

    USBD_KdPrint(3, ("' exit USBD_PassThru 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_URB hcdUrb = (PHCD_URB)Urb;
    PUSBD_PIPE pipeHandle;

    // this function blocks so it must not be called at DPC level
    
    PAGED_CODE();
    
    USBD_KdPrint(3, ("' enter USBD_ResetPipe\n"));

    pipeHandle = (PUSBD_PIPE) Urb->UrbPipeRequest.PipeHandle;
    ASSERT_PIPE(pipeHandle);

    //
    // first clear the stall on the device if this is a 
    // bulk or interrupt pipe. 
    //
    // The reason we do this is to ensure that the data toggle 
    // on both the host and the device is reset.
    //

    if (((USB_ENDPOINT_TYPE_MASK & pipeHandle->EndpointDescriptor.bmAttributes) 
         == USB_ENDPOINT_TYPE_BULK) ||
        ((USB_ENDPOINT_TYPE_MASK & pipeHandle->EndpointDescriptor.bmAttributes) 
         == USB_ENDPOINT_TYPE_INTERRUPT)) {
    
        ntStatus = USBD_SendCommand(Urb->UrbHeader.UsbdDeviceHandle,
                                    DeviceObject,
                                    STANDARD_COMMAND_CLEAR_FEATURE_ENDPOINT,
                                    USB_FEATURE_ENDPOINT_STALL,
                                    pipeHandle->EndpointDescriptor.bEndpointAddress,
                                    0,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL);
                                        
    }        

    if (NT_SUCCESS(ntStatus)) {
        //
        // Change the Urb command to set endpoint state
        // note: we rely on these two structures being 
        //  identical so that we can reuse the URB
        //
        
        ASSERT(sizeof(struct _URB_HCD_ENDPOINT_STATE) == 
               sizeof(struct _URB_PIPE_REQUEST));
               
        ASSERT_PIPE((PUSBD_PIPE) Urb->UrbPipeRequest.PipeHandle);
        
        hcdUrb->HcdUrbEndpointState.Function = URB_FUNCTION_HCD_SET_ENDPOINT_STATE;  
        hcdUrb->HcdUrbEndpointState.HcdEndpoint = 
             ((PUSBD_PIPE) (Urb->UrbPipeRequest.PipeHandle))->HcdEndpoint;

        // request to clear halt and reset toggle             
        hcdUrb->HcdUrbEndpointState.HcdEndpointState = HCD_ENDPOINT_RESET_DATA_TOGGLE;
        
        *IrpIsPending = TRUE;
    }
    
    USBD_KdPrint(3, ("' exit USBD_ResetPipe 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_AbortPipe(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PHCD_URB hcdUrb = (PHCD_URB)Urb;

    USBD_KdPrint(3, ("' enter USBD_AbortPipe\n"));

    //
    // Change the Urb command to abort endpoint
    //
    
    ASSERT_PIPE((PUSBD_PIPE) Urb->UrbPipeRequest.PipeHandle);
    
    hcdUrb->HcdUrbAbortEndpoint.Function = URB_FUNCTION_HCD_ABORT_ENDPOINT;  
    hcdUrb->HcdUrbAbortEndpoint.HcdEndpoint = 
         ((PUSBD_PIPE) (Urb->UrbPipeRequest.PipeHandle))->HcdEndpoint;

    *IrpIsPending = TRUE;

    USBD_KdPrint(3, ("' exit USBD_AbortPipe 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_SCT_GetInterface(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

Arguments:

    DeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STANDARD_SETUP_PACKET setupPacket;

    USBD_KdPrint(3, ("' enter USBD_SCT_GetStatus\n"));

    setupPacket = (PUSB_STANDARD_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;

    if (setupPacket->wLength != 1) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBD_SCT_GetInterface_Done;
    }
    
    setupPacket->wValue = 0;            
    setupPacket->wIndex = Urb->UrbControlGetInterfaceRequest.Interface;

    setupPacket->RequestCode = 
        UrbDispatchTable[Urb->UrbHeader.Function].RequestCode;            

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   
    if (USB_DEVICE_TO_HOST & setupPacket->RequestCode) {
        USBD_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT( Urb->UrbControlTransfer.TransferFlags);
    }                

    if (NT_SUCCESS(ntStatus)) {
        ((PHCD_URB) Urb)->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
        ((PHCD_URB) Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = 
            ((PUSBD_PIPE)((PHCD_URB)Urb)->HcdUrbCommonTransfer.UsbdPipeHandle)->HcdEndpoint;
        
        *IrpIsPending = TRUE;
    }

 USBD_SCT_GetInterface_Done:
 
    USBD_KdPrint(3, ("' exit USBD_SCT_GetInterface 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_SCT_GetConfiguration(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

Arguments:

    DeviceObject - 

    Irp - IO request block

    Urb - ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STANDARD_SETUP_PACKET setupPacket;

    USBD_KdPrint(3, ("' enter USBD_SCT_GetStatus\n"));

    setupPacket = (PUSB_STANDARD_SETUP_PACKET) &Urb->UrbControlTransfer.SetupPacket[0];

    // setup common fields
    setupPacket->wLength = (USHORT) Urb->UrbControlTransfer.TransferBufferLength;
    USBD_ASSERT(setupPacket->wLength == 1);
    setupPacket->wValue = 0;            
    setupPacket->wIndex = 0;

    setupPacket->RequestCode = 
        UrbDispatchTable[Urb->UrbHeader.Function].RequestCode;            

    Urb->UrbControlTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;   
    if (USB_DEVICE_TO_HOST & setupPacket->RequestCode) {
        USBD_SET_TRANSFER_DIRECTION_IN(Urb->UrbControlTransfer.TransferFlags);
    } else {
        USBD_SET_TRANSFER_DIRECTION_OUT( Urb->UrbControlTransfer.TransferFlags);
    }        

    if (NT_SUCCESS(ntStatus)) {
        ((PHCD_URB) Urb)->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
        ((PHCD_URB) Urb)->HcdUrbCommonTransfer.hca.HcdEndpoint = 
            ((PUSBD_PIPE)((PHCD_URB)Urb)->HcdUrbCommonTransfer.UsbdPipeHandle)->HcdEndpoint;
        
        *IrpIsPending = TRUE;
    }

    USBD_KdPrint(3, ("' exit USBD_SCT_GetConfiguration 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_TakeFrameLengthControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();

    USBD_KdPrint(3, ("' enter USBD_TakeFrameLengthControl\n"));
    

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);
    deviceData = Urb->UrbHeader.UsbdDeviceHandle;
    *IrpIsPending = FALSE;

    if (deviceExtension->FrameLengthControlOwner != NULL) {
        Urb->UrbHeader.Status = 
                    SET_USBD_ERROR(USBD_STATUS_FRAME_CONTROL_OWNED);
    } else {
        Urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
        deviceExtension->FrameLengthControlOwner = 
            deviceData;
    }

    USBD_KdPrint(3, ("' exit USBD_TakeFrameLengthControl 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_ReleaseFrameLengthControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_EXTENSION deviceExtension;

    USBD_KdPrint(3, ("' enter USBD_ReleaseFrameLengthControl\n"));
    

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);
    deviceData = Urb->UrbHeader.UsbdDeviceHandle;
    *IrpIsPending = FALSE;

    if (deviceExtension->FrameLengthControlOwner == NULL || 
        deviceExtension->FrameLengthControlOwner != deviceData) {
        Urb->UrbHeader.Status = 
                    SET_USBD_ERROR(USBD_STATUS_FRAME_CONTROL_NOT_OWNED);
    } else {
        Urb->UrbHeader.Status = STATUS_SUCCESS;
        deviceExtension->FrameLengthControlOwner = NULL;
    }

    USBD_KdPrint(3, ("' exit USBD_ReleaseFrameLengthControl 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_GetFrameLength(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();

    USBD_KdPrint(3, ("' enter USBD_GetFrameLength\n"));

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);
    deviceData = Urb->UrbHeader.UsbdDeviceHandle;

    if (NT_SUCCESS(ntStatus)) {
        // pass on to HC
        *IrpIsPending = TRUE;
    }        

    USBD_KdPrint(3, ("' exit USBD_GetFrameLength 0x%x\n", ntStatus));
        
    return ntStatus;
}


NTSTATUS
USBD_SetFrameLength(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    )
/*++

Routine Description:

    Process abort pipe request from the client driver

Arguments:

    Irp -  IO request block

    Urb -  ptr to USB request block

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();

    USBD_KdPrint(3, ("' enter USBD_SetFrameLength\n"));

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);
    deviceData = Urb->UrbHeader.UsbdDeviceHandle;

    if (deviceExtension->FrameLengthControlOwner != deviceData) {
        Urb->UrbHeader.Status = 
                    SET_USBD_ERROR(USBD_STATUS_FRAME_CONTROL_NOT_OWNED);
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    if (Urb->UrbSetFrameLength.FrameLengthDelta < -1 || 
        Urb->UrbSetFrameLength.FrameLengthDelta > 1) {

        SET_USBD_ERROR(USBD_STATUS_INVALID_PARAMETER);
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    
    if (NT_SUCCESS(ntStatus)) {
        // pass on to HC
        *IrpIsPending = TRUE;
    }

    USBD_KdPrint(3, ("' exit USBD_SetFrameLength 0x%x\n", ntStatus));
        
    return ntStatus;
}


#endif      // USBD_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\service.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    SERVICE.C

Abstract:

    Services exported by USBD

Environment:

    kernel mode only

Notes:



Revision History:

    09-29-95 : created

--*/

#include "wdm.h"
#include <windef.h>
#include <unknown.h>
#ifdef DRM_SUPPORT
#include <ks.h>
#include <ksmedia.h>
#include <drmk.h>
#include <ksdrmhlp.h>
#endif
#include "stdarg.h"
#include "stdio.h"

#include <initguid.h>
#include <wdmguid.h>
#include "usbdi.h"       //public data structures
#include "hcdi.h"

#include "usbd.h"        //private data strutures
#include "usbdlib.h"
#define USBD
#include "usbdlibi.h"
#undef USBD


NTSTATUS
DllUnload(
    VOID
    );

NTSTATUS
DllInitialize(
    PUNICODE_STRING RegistryPath
    );

NTSTATUS
USBD_GetDeviceInformation(
    IN PUSB_NODE_CONNECTION_INFORMATION DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSBD_DEVICE_DATA DeviceData
    );

ULONG
USBD_AllocateDeviceName(
    PUNICODE_STRING DeviceNameUnicodeString
    );

VOID
USBD_FreeDeviceName(
    ULONG DeviceNameHandle
    );

NTSTATUS
USBD_RegisterHostController(
    IN PDEVICE_OBJECT PnPBusDeviceObject,
    IN PDEVICE_OBJECT HcdDeviceObject,
    IN PDEVICE_OBJECT HcdTopOfStackDeviceObject,
    IN PDRIVER_OBJECT HcdDriverObject,
    IN HCD_DEFFERED_START_FUNCTION *HcdDeferredStartDevice,
    IN HCD_SET_DEVICE_POWER_STATE *HcdSetDevicePowerState,
    IN HCD_GET_CURRENT_FRAME *HcdGetCurrentFrame,
    IN HCD_GET_CONSUMED_BW *HcdGetConsumedBW,
    IN HCD_SUBMIT_ISO_URB *HcdSubmitIsoUrb,
// this parameter is only needed until we resolve device naming
// issues with PNP
    IN ULONG HcdDeviceNameHandle
    );

NTSTATUS
USBD_InitializeDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    );

NTSTATUS
USBD_RemoveDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Flags
    );

PURB
USBD_CreateConfigurationRequestEx(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList
    );

PUSB_INTERFACE_DESCRIPTOR
USBD_ParseConfigurationDescriptorEx(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PVOID StartPosition,
    IN LONG InterfaceNumber,
    IN LONG AlternateSetting,
    IN LONG InterfaceClass,
    IN LONG InterfaceSubClass,
    IN LONG InterfaceProtocol
    );

VOID
USBD_WaitDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    );

VOID
USBD_FreeDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    );

PUSB_COMMON_DESCRIPTOR
USBD_ParseDescriptors(
    IN PVOID DescriptorBuffer,
    IN ULONG TotalLength,
    IN PVOID StartPosition,
    IN LONG DescriptorType
    );

PUSB_INTERFACE_DESCRIPTOR
USBD_ParseConfigurationDescriptor(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN UCHAR InterfaceNumber,
    IN UCHAR AlternateSetting
    );

PURB
USBD_CreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN OUT PUSHORT Siz
    );

NTSTATUS
USBD_GetDeviceName(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING DeviceNameUnicodeString
    );

VOID
USBD_RhDelayedSetPowerD0Worker(
    IN PVOID Context);

PWCHAR
GetString(PWCHAR pwc, BOOLEAN MultiSZ);

NTSTATUS
USBD_GetBusInterface(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PIRP Irp
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DllUnload)
#pragma alloc_text(PAGE, DllInitialize)
#pragma alloc_text(PAGE, USBD_GetDeviceInformation)
#pragma alloc_text(PAGE, USBD_AllocateDeviceName)
#pragma alloc_text(PAGE, USBD_GetDeviceName)
#pragma alloc_text(PAGE, GetString)
#pragma alloc_text(PAGE, USBD_FreeDeviceName)
#pragma alloc_text(PAGE, USBD_RegisterHostController)
#pragma alloc_text(PAGE, USBD_CreateDevice)
#pragma alloc_text(PAGE, USBD_RemoveDevice)
#pragma alloc_text(PAGE, USBD_InitializeDevice)
#pragma alloc_text(PAGE, USBD_CreateConfigurationRequestEx)
#pragma alloc_text(PAGE, USBD_ParseDescriptors)
#pragma alloc_text(PAGE, USBD_ParseConfigurationDescriptorEx)
#pragma alloc_text(PAGE, USBD_ParseConfigurationDescriptor)
#pragma alloc_text(PAGE, USBD_CreateConfigurationRequest)
#pragma alloc_text(PAGE, USBD_WaitDeviceMutex)
#pragma alloc_text(PAGE, USBD_FreeDeviceMutex)
#pragma alloc_text(PAGE, USBD_InternalGetInterfaceLength)
#pragma alloc_text(PAGE, USBD_RhDelayedSetPowerD0Worker)
#ifdef DRM_SUPPORT
#pragma alloc_text(PAGE, USBD_FdoSetContentId)
#endif
#endif
#endif

/*
 ********************************************************************************
 *  DllUnload
 ********************************************************************************
 *
 *  We need this routine so that the driver can get unloaded when all
 *  references have been dropped by the minidriver.
 *
 */
NTSTATUS
DllUnload (VOID)
{
    PAGED_CODE();
    USBD_KdPrint(1, (" DllUnload\n"));
    return STATUS_SUCCESS;
}

/*
 ********************************************************************************
 *  DllInitialize
 ********************************************************************************
 *
 *  This routine called instead of DriverEntry since we're loaded as a DLL.
 *
 */
NTSTATUS
DllInitialize (PUNICODE_STRING RegistryPath)
{
    PAGED_CODE();
    USBD_KdPrint(1, (" DllInitialize\n"));
    return STATUS_SUCCESS;
}

ULONG
USBD_CalculateUsbBandwidth(
    ULONG MaxPacketSize,
    UCHAR EndpointType,
    BOOLEAN LowSpeed
    )
/*++

Routine Description:

Arguments:

Return Value:

    banwidth consumed in bits/ms, returns 0 for bulk
    and control endpoints

--*/
{
    ULONG bw;

    //
    // control, iso, bulk, interrupt
    //

    ULONG overhead[4] = {
            0,
            USB_ISO_OVERHEAD_BYTES,
            0,
            USB_INTERRUPT_OVERHEAD_BYTES
          };

    USBD_ASSERT(EndpointType<4);

    //
    // Calculate bandwidth for endpoint.  We will use the
    // approximation: (overhead bytes plus MaxPacket bytes)
    // times 8 bits/byte times worst case bitstuffing overhead.
    // This gives bit times, for low speed endpoints we multiply
    // by 8 again to convert to full speed bits.
    //

    //
    // Figure out how many bits are required for the transfer.
    // (multiply by 7/6 because, in the worst case you might
    // have a bit-stuff every six bits requiring 7 bit times to
    // transmit 6 bits of data.)
    //

    // overhead(bytes) * maxpacket(bytes/ms) * 8
    //      (bits/byte) * bitstuff(7/6) = bits/ms

    bw = ((overhead[EndpointType]+MaxPacketSize) * 8 * 7) / 6;

    // return zero for control or bulk
    if (!overhead[EndpointType]) {
        bw = 0;
    }

    if (LowSpeed) {
        bw *= 8;
    }

    return bw;
}


//
// These APIS replace USBD_CreateConfigurationRequest,
//                    USBD_ParseConfigurationDescriptor

PURB
USBD_CreateConfigurationRequestEx(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList
    )
/*++

Routine Description:

Arguments:

Return Value:

    Pointer to initailized select_configuration urb.

--*/
{
    PURB urb = NULL;
    ULONG numInterfaces, numPipes;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList;
    USHORT siz;

    PAGED_CODE();
    //
    // Our mission here is to construct a URB of the proper
    // size and format for a select_configuration request.
    //
    // This function uses the configurstion descritor as a
    // reference and builds a URB with interface_information
    // structures for each interface requested in the interface
    // list passed in
    //
    // NOTE: the config descriptor may contain interfaces that
    // the caller does not specify in the list -- in this case
    // the other interfaces will be ignored.
    //

    USBD_KdPrint(3, ("'USBD_CreateConfigurationRequestEx list = %x\n",
        InterfaceList));

    //
    // first figure out how many interfaces we are dealing with
    //

    interfaceList = InterfaceList;
    numInterfaces = 0;
    numPipes = 0;

    while (interfaceList->InterfaceDescriptor) {
        numInterfaces++;
        numPipes+=interfaceList->InterfaceDescriptor->bNumEndpoints;
        interfaceList++;
    }


    siz = (USHORT) GET_SELECT_CONFIGURATION_REQUEST_SIZE(numInterfaces,
                                                         numPipes);

    urb = ExAllocatePoolWithTag(NonPagedPool, siz, USBD_TAG);

    if (urb) {

        PUSBD_INTERFACE_INFORMATION iface;

        //
        // now all we have to do is initialize the urb
        //

        RtlZeroMemory(urb, siz);

        iface = &urb->UrbSelectConfiguration.Interface;
        interfaceList = InterfaceList;

        while (interfaceList->InterfaceDescriptor) {

            PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor =
                interfaceList->InterfaceDescriptor;
            LONG j;

            iface->InterfaceNumber =
                interfaceDescriptor->bInterfaceNumber;

            iface->AlternateSetting =
                interfaceDescriptor->bAlternateSetting;

            iface->NumberOfPipes =
                interfaceDescriptor->bNumEndpoints;

            for (j=0; j<interfaceDescriptor->bNumEndpoints; j++) {
                iface->Pipes[j].MaximumTransferSize =
                    USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
                iface->Pipes[j].PipeFlags = 0;
            }

            iface->Length =
                (USHORT) GET_USBD_INTERFACE_SIZE(
                    interfaceDescriptor->bNumEndpoints);

            USBD_ASSERT(((PUCHAR) iface) + iface->Length <=
                ((PUCHAR) urb) + siz);

            interfaceList->Interface = iface;

            interfaceList++;
            iface = (PUSBD_INTERFACE_INFORMATION) ((PUCHAR) iface +
                            iface->Length);

            USBD_KdPrint(3, ("'next interface = %x\n", iface));
        }

        urb->UrbHeader.Length = siz;
        urb->UrbHeader.Function = URB_FUNCTION_SELECT_CONFIGURATION;
        urb->UrbSelectConfiguration.ConfigurationDescriptor =
            ConfigurationDescriptor;
    }

#if DBG
    interfaceList = InterfaceList;

    while (interfaceList->InterfaceDescriptor) {
        USBD_KdPrint(3, ("'InterfaceList, Interface = %x\n",
            interfaceList->Interface));
        USBD_KdPrint(3, ("'InterfaceList, InterfaceDescriptor = %x\n",
            interfaceList->InterfaceDescriptor));
        interfaceList++;
    }

    USBD_KdPrint(3, ("'urb = %x\n", urb));
#endif

    return urb;
}


PUSB_COMMON_DESCRIPTOR
USBD_ParseDescriptors(
    IN PVOID DescriptorBuffer,
    IN ULONG TotalLength,
    IN PVOID StartPosition,
    IN LONG DescriptorType
    )
/*++

Routine Description:

    Parses a group of standard USB configuration descriptors (returned
    from a device) for a specific descriptor type.

Arguments:

    DescriptorBuffer - pointer to a block of contiguous USB desscriptors
    TotalLength - size in bytes of the Descriptor buffer
    StartPosition - starting position in the buffer to begin parsing,
                    this must point to the begining of a USB descriptor.
    DescriptorType - USB descritor type to locate.


Return Value:

    pointer to a usb descriptor with a DescriptorType field matching the
            input parameter or NULL if not found.

--*/
{
    PUCHAR pch = (PUCHAR) StartPosition, end;
    PUSB_COMMON_DESCRIPTOR usbDescriptor, foundUsbDescriptor = NULL;

    PAGED_CODE();
    end = ((PUCHAR) (DescriptorBuffer)) + TotalLength;

    while (pch < end) {
        // see if we are pointing at an interface
        // if not skip over the other junk
        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        if (usbDescriptor->bDescriptorType ==
            DescriptorType) {
            foundUsbDescriptor = usbDescriptor;
            break;
        }

        // note we still stop in debug because the
        // device passed us bad data, the following
        // test will prevent us from hanging
        if (usbDescriptor->bLength == 0) {
            USBD_KdTrap((
"USB driver passed in bad data!\n-->you have a broken device or driver\n-->hit g to cointinue\n"));
            break;
        }

        pch += usbDescriptor->bLength;
    }

    USBD_KdPrint(3, ("'USBD_ParseDescriptors %x\n", foundUsbDescriptor));

    return foundUsbDescriptor;
}


PUSB_INTERFACE_DESCRIPTOR
USBD_ParseConfigurationDescriptorEx(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PVOID StartPosition,
    IN LONG InterfaceNumber,
    IN LONG AlternateSetting,
    IN LONG InterfaceClass,
    IN LONG InterfaceSubClass,
    IN LONG InterfaceProtocol
    )
/*++

Routine Description:

    Parses a standard USB configuration descriptor (returned from a device)
    for a specific interface, alternate setting class subclass or protocol
    codes

Arguments:

    ConfigurationDescriptor -
    StartPosition -
    InterfaceNumber -
    AlternateSetting
    InterfaceClass -
    InterfaceSubClass -
    InterfaceProtocol -
Return Value:

    NT status code.

--*/
{
    PUSB_INTERFACE_DESCRIPTOR foundInterfaceDescriptor = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;

    PAGED_CODE();
    USBD_KdPrint(3, ("'USBD_ParseConfigurationDescriptorEx\n"));

    ASSERT(ConfigurationDescriptor->bDescriptorType
        == USB_CONFIGURATION_DESCRIPTOR_TYPE);
    //
    // we walk the table of descriptors looking for an
    // interface descriptor with parameters matching those
    // passed in.
    //

    do {
        //
        // Search for descriptor type 'interface'
        //

        interfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR)
            USBD_ParseDescriptors(ConfigurationDescriptor,
                                  ConfigurationDescriptor->wTotalLength,
                                  StartPosition,
                                  USB_INTERFACE_DESCRIPTOR_TYPE);

        //
        // do we have a match?
        //
        if (interfaceDescriptor != NULL) {

            foundInterfaceDescriptor =
                interfaceDescriptor;

            if (InterfaceNumber != -1 &&
                interfaceDescriptor->bInterfaceNumber != InterfaceNumber) {
                foundInterfaceDescriptor = NULL;
            }

            if (AlternateSetting != -1 &&
                interfaceDescriptor->bAlternateSetting != AlternateSetting) {
                foundInterfaceDescriptor = NULL;
            }

            if (InterfaceClass != -1 &&
                interfaceDescriptor->bInterfaceClass != InterfaceClass) {
                foundInterfaceDescriptor = NULL;
            }

            if (InterfaceSubClass != -1 &&
                interfaceDescriptor->bInterfaceSubClass !=
                    InterfaceSubClass) {
                foundInterfaceDescriptor = NULL;
            }

            if (InterfaceProtocol != -1 &&
                interfaceDescriptor->bInterfaceProtocol !=
                    InterfaceProtocol) {
                foundInterfaceDescriptor = NULL;
            }

            StartPosition =
                ((PUCHAR)interfaceDescriptor) + interfaceDescriptor->bLength;
        }

        if (foundInterfaceDescriptor) {
            break;
        }

    } while (interfaceDescriptor != NULL);


    return (foundInterfaceDescriptor);
}


PUSB_INTERFACE_DESCRIPTOR
USBD_ParseConfigurationDescriptor(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN UCHAR InterfaceNumber,
    IN UCHAR AlternateSetting
    )
/*++

Routine Description:

Arguments:

Return Value:

    interface descriptor or NULL.

--*/
{
    PAGED_CODE();
    return USBD_ParseConfigurationDescriptorEx(
                    ConfigurationDescriptor,
                    ConfigurationDescriptor,
                    InterfaceNumber,
                    AlternateSetting,
                    -1,
                    -1,
                    -1);
}


PURB
USBD_CreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN OUT PUSHORT Siz
    )
/*++

Routine Description:

Arguments:

Return Value:

    Pointer to initailized select_configuration urb.

--*/
{
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp;
    LONG numberOfInterfaces, interfaceNumber, i;

    PAGED_CODE();
    USBD_KdPrint(3, ("' enter USBD_CreateConfigurationRequest cd = %x\n",
        ConfigurationDescriptor));

    //
    // build a request structure and call the new api
    //

    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;

    tmp = interfaceList =
        ExAllocatePoolWithTag(PagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) *
                       (numberOfInterfaces+1), USBD_TAG);

    //
    // just grab the first alt setting we find for each interface
    //

    i = interfaceNumber = 0;

    while (i< numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                        ConfigurationDescriptor,
                        ConfigurationDescriptor,
                        interfaceNumber,
                        0, // assume alt setting zero here
                        -1,
                        -1,
                        -1);

        USBD_ASSERT(interfaceDescriptor != NULL);

        if (interfaceDescriptor) {
            interfaceList->InterfaceDescriptor =
                interfaceDescriptor;
            interfaceList++;
            i++;
        } else {
            // could not find the requested interface descriptor
            // bail, we will prorblay crash somewhere in the
            // client driver.

            goto USBD_CreateConfigurationRequest_Done;
        }

        interfaceNumber++;
    }

    //
    // terminate the list
    //
    interfaceList->InterfaceDescriptor = NULL;

    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor,
                                            tmp);

USBD_CreateConfigurationRequest_Done:

    ExFreePool(tmp);

    if (urb) {
        *Siz = urb->UrbHeader.Length;
    }

    return urb;
}


ULONG
USBD_InternalGetInterfaceLength(
    IN PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor,
    IN PUCHAR End
    )
/*++

Routine Description:

    Initialize the configuration handle structure.

Arguments:

    InterfaceDescriptor - pointer to usb interface descriptor
        followed by endpoint descriptors

Return Value:

    Length of the interface plus endpoint descriptors and class specific
    descriptors in bytes.

--*/
{
    PUCHAR pch = (PUCHAR) InterfaceDescriptor;
    ULONG i, numEndpoints;
    PUSB_ENDPOINT_DESCRIPTOR endpointDescriptor;
    PUSB_COMMON_DESCRIPTOR usbDescriptor;

    PAGED_CODE();
    ASSERT(InterfaceDescriptor->bDescriptorType ==
                USB_INTERFACE_DESCRIPTOR_TYPE);
    i = InterfaceDescriptor->bLength;
    numEndpoints = InterfaceDescriptor->bNumEndpoints;

    // advance to the first endpoint
    pch += i;

    while (numEndpoints) {

        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        while (usbDescriptor->bDescriptorType !=
                USB_ENDPOINT_DESCRIPTOR_TYPE) {
            i += usbDescriptor->bLength;
            pch += usbDescriptor->bLength;
            usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;

            if (pch >= End || usbDescriptor->bLength == 0) {

                USBD_Warning(NULL,
                             "Bad USB descriptors in USBD_InternalGetInterfaceLength, fail.\n",
                             FALSE);

                // If descriptors are bad, don't index past the end of the
                // buffer.  Return 0 as the interface length and the caller
                // should then be able to handle this appropriately.

                i = 0;
                goto GetInterfaceLength_exit;
            }
        }

        endpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR) pch;
        ASSERT(endpointDescriptor->bDescriptorType ==
            USB_ENDPOINT_DESCRIPTOR_TYPE);
        i += endpointDescriptor->bLength;
        pch += endpointDescriptor->bLength;
        numEndpoints--;
    }

    while (pch < End) {
        // see if we are pointing at an interface
        // if not skip over the other junk
        usbDescriptor = (PUSB_COMMON_DESCRIPTOR) pch;
        if (usbDescriptor->bDescriptorType ==
            USB_INTERFACE_DESCRIPTOR_TYPE) {
            break;
        }

        USBD_ASSERT(usbDescriptor->bLength != 0);
        i += usbDescriptor->bLength;
        pch += usbDescriptor->bLength;
    }

GetInterfaceLength_exit:

    USBD_KdPrint(3, ("'USBD_GetInterfaceLength %x\n", i));

    return i;
}


ULONG
USBD_GetInterfaceLength(
    IN PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor,
    IN PUCHAR BufferEnd
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return USBD_InternalGetInterfaceLength(InterfaceDescriptor, BufferEnd);
}


NTSTATUS
USBD_GetPdoRegistryParameter(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PVOID Parameter,
    IN ULONG ParameterLength,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;

    PAGED_CODE();
    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = USBD_GetRegistryKeyValue(handle,
                                            KeyName,
                                            KeyNameLength,
                                            Parameter,
                                            ParameterLength);

        ZwClose(handle);
    }

    return ntStatus;
}


VOID
USBD_GetUSBDIVersion(
    PUSBD_VERSION_INFORMATION VersionInformation
    )
{
    if (VersionInformation != NULL) {
        VersionInformation->USBDI_Version = USBDI_VERSION;
        VersionInformation->Supported_USB_Version = 0x100;
    }
}



#ifdef USBD_DRIVER      // USBPORT supercedes most of USBD, so we will remove
                        // the obsolete code by compiling it only if
                        // USBD_DRIVER is set.



//#if DBG
//VOID
//USBD_IoCompleteRequest(
//    IN PIRP Irp,
//    IN CCHAR PriorityBoost
//    )
//{
//    KIRQL irql;

//    KeRaiseIrql(DISPATCH_LEVEL, &irql);
//    IoCompleteRequest(Irp, PriorityBoost);
//    KeLowerIrql(irql);
//}
//#endif

// this code is here to support the old API
// once we eliminate this service it can be removed
NTSTATUS
USBD_GetDeviceInformationX(
    IN PUSB_NODE_CONNECTION_INFORMATION DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSBD_DEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Returns information about a device given the handle

Arguments:

Return Value:

    NT status code

--*/
{
    ULONG need;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_CONFIG configHandle;
    ULONG i,j,k;

    PAGED_CODE();
    DeviceInformation->DeviceAddress = DeviceData->DeviceAddress;
    DeviceInformation->LowSpeed = DeviceData->LowSpeed;

    configHandle = DeviceData->ConfigurationHandle;

    DeviceInformation->NumberOfOpenPipes = 0;
    DeviceInformation->CurrentConfigurationValue = 0;
    // get the pipe information
    if (configHandle) {
        DeviceInformation->CurrentConfigurationValue =
            configHandle->ConfigurationDescriptor->bConfigurationValue;

        for (i=0;
             i< configHandle->ConfigurationDescriptor->bNumInterfaces;
             i++) {
            DeviceInformation->NumberOfOpenPipes +=
                configHandle->InterfaceHandle[i]->
                    InterfaceInformation->NumberOfPipes;
        }

        need = DeviceInformation->NumberOfOpenPipes * sizeof(USB_PIPE_INFO) +
            sizeof(USB_NODE_CONNECTION_INFORMATION);

        if (need > DeviceInformationLength) {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        } else {
            j=0;
            for (i=0;
                 i<configHandle->ConfigurationDescriptor->bNumInterfaces;
                 i++) {

                PUSBD_INTERFACE interfaceHandle =
                    configHandle->InterfaceHandle[i];

                for (k=0;
                     k<interfaceHandle->InterfaceInformation->NumberOfPipes;
                     k++, j++) {
                    DeviceInformation->PipeList[j].ScheduleOffset =
                        interfaceHandle->PipeHandle[k].ScheduleOffset;
                    RtlCopyMemory(&DeviceInformation->PipeList[j].
                                    EndpointDescriptor,
                                  &interfaceHandle->PipeHandle[k].
                                    EndpointDescriptor,
                                  sizeof(USB_ENDPOINT_DESCRIPTOR));

                }

            }
        }
    }

    return ntStatus;
}

NTSTATUS
USBD_GetDeviceInformation(
    IN PUSB_NODE_CONNECTION_INFORMATION DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSBD_DEVICE_DATA DeviceData
    )
{

    USBD_KdPrint(0,
(" WARNING: Driver using obsolete service enrty point (USBD_GetDeviceInformation) - get JD\n"));

    return USBD_GetDeviceInformationX(
            DeviceInformation,
            DeviceInformationLength,
            DeviceData);

}


PWCHAR
GetString(PWCHAR pwc, BOOLEAN MultiSZ)
{
    PWCHAR  psz, p;
    ULONG   Size;

    PAGED_CODE();
    psz=pwc;
    while (*psz!='\0' || (MultiSZ && *(psz+1)!='\0')) {
        psz++;
    }

    Size=(ULONG)(psz-pwc+1+(MultiSZ ? 1: 0))*sizeof(*pwc);

    // We use pool here because these pointers are passed
    // to the PnP code who is responsible for freeing them
    if ((p=ExAllocatePoolWithTag(PagedPool, Size, USBD_TAG))!=NULL) {
        RtlCopyMemory(p, pwc, Size);
    }

    return(p);
}

NTSTATUS
USBD_GetDeviceName(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING DeviceNameUnicodeString
    )
/*++

Routine Description:

    Returns the device name for the give instance of the HCD

Arguments:

    DeviceObject -

    DeviceNameUnicodeString - ptr to unicode string to initialize
                    with device name.

Return Value:

    NT status code

--*/
{
    ULONG ulActualSize;
    NTSTATUS ntStatus;

    PAGED_CODE();

    ntStatus=IoGetDeviceProperty(DeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 0,
                                 NULL,
                                 &ulActualSize);

    if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

        DeviceNameUnicodeString->Length=
            (USHORT)(ulActualSize-sizeof(UNICODE_NULL));
        DeviceNameUnicodeString->MaximumLength=
            (USHORT)ulActualSize;
        DeviceNameUnicodeString->Buffer=
            ExAllocatePoolWithTag(PagedPool, ulActualSize, USBD_TAG);
        if (!DeviceNameUnicodeString->Buffer) {
            ntStatus=STATUS_INSUFFICIENT_RESOURCES;
        } else {

            ntStatus =
                IoGetDeviceProperty(DeviceObject,
                                    DevicePropertyPhysicalDeviceObjectName,
                                    ulActualSize,
                                    DeviceNameUnicodeString->Buffer,
                                    &ulActualSize);

            if (!NT_SUCCESS(ntStatus)) {
                ExFreePool(DeviceNameUnicodeString->Buffer);
            }
        }
    } else {
        ntStatus=STATUS_INSUFFICIENT_RESOURCES;
    }

    return(ntStatus);
}

//
// These functions go away when the PnP naming stuff is fixed
//
UCHAR Instance = 0;

ULONG
USBD_AllocateDeviceName(
    PUNICODE_STRING DeviceNameUnicodeString
    )
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    ULONG bit, i = 0;
    PWCHAR deviceNameBuffer;
    WCHAR nameBuffer[]  = L"\\Device\\HCD0";

    //
    // first find a free instance value
    //

    PAGED_CODE();
    deviceNameBuffer =
        ExAllocatePoolWithTag(NonPagedPool, sizeof(nameBuffer), USBD_TAG);

    if (deviceNameBuffer) {
        RtlCopyMemory(deviceNameBuffer, nameBuffer, sizeof(nameBuffer));
        //
        // grab the first free instance
        //

        bit = 1;
        for (i=0; i<8; i++) {
            if ((Instance & bit) == 0) {
                Instance |= bit;
                break;
            }
            bit = bit <<1;
        }

        deviceNameBuffer[11] = (WCHAR)('0'+ i);
    }

    RtlInitUnicodeString(DeviceNameUnicodeString,
                         deviceNameBuffer);

    return i;
}

VOID
USBD_FreeDeviceName(
    ULONG DeviceNameHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    ULONG bit;

    PAGED_CODE();

    bit = 1;
    bit <<= DeviceNameHandle;
    Instance &= ~bit;


}


NTSTATUS
USBD_RegisterHostController(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT HcdDeviceObject,
    IN PDEVICE_OBJECT HcdTopOfPdoStackDeviceObject,
    IN PDRIVER_OBJECT HcdDriverObject,
    IN HCD_DEFFERED_START_FUNCTION *HcdDeferredStartDevice,
    IN HCD_SET_DEVICE_POWER_STATE *HcdSetDevicePowerState,
    IN HCD_GET_CURRENT_FRAME *HcdGetCurrentFrame,
    IN HCD_GET_CONSUMED_BW *HcdGetConsumedBW,
    IN HCD_SUBMIT_ISO_URB *HcdSubmitIsoUrb,
// this parameter is only needed until we resolve device naming
// issues with PNP
    IN ULONG HcdDeviceNameHandle
    )
/*++

Routine Description:

    Function is called by HCDs to register with the class driver

Arguments:

    PhysicalDeviceObject -
        Physical device object representing this bus, this is
        the PDO created by PCI and pssed to the HCDs AddDevice
        handler.

    HcdDeviceObject -
        Functional device object (FDO) created by the HCD to manage
        the bus

    HcdTopOfPdoStackDeviceObject -
        device object of for the top of the HCD  stack, value returne
        from IoAttachDeviceToDeviceStack

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    PUSBD_EXTENSION deviceExtension;
    UNICODE_STRING localDeviceNameUnicodeString;
    PUNICODE_STRING deviceNameUnicodeString;
    ULONG complienceFlags = 0;
    ULONG diagnosticFlags = 0;
    ULONG i;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_RegisterHostController\n"));

    ASSERT((sizeof(USBD_EXTENSION) % 4) == 0);
    // initialize our device extension, we share the device object
    // with the HCD.
    deviceExtension =  HcdDeviceObject->DeviceExtension;

//#ifdef NTKERN
    //
    // currently on NTKERN supports the ioclt to get the device name
    //

    //
    // get the device name from the PDO
    //

#ifdef USE_PNP_NAME
    ntStatus = USBD_GetDeviceName(PnPBusDeviceObject,
                                  &localDeviceNameUnicodeString);

    deviceNameUnicodeString = &localDeviceNameUnicodeString;
#else
    //
    // Big workaround for broken naming of device objects in NTKERN
    //
    // we would like to use the device name for the PDO but this does not
    // work with NTKERN.
    //

    //
    // build device name from handle passed in
    //
    {
        WCHAR nameBuffer[]  = L"\\Device\\HCD0";
        PWCHAR deviceNameBuffer;

        nameBuffer[11] = (WCHAR) ('0'+HcdDeviceNameHandle);

        deviceNameBuffer = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(nameBuffer),
            USBD_TAG);

        if (deviceNameBuffer) {
            RtlCopyMemory(deviceNameBuffer, nameBuffer, sizeof(nameBuffer));
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlInitUnicodeString(&localDeviceNameUnicodeString,
                             deviceNameBuffer);

    }

#pragma message ("warning: using workaround for bugs in ntkern")
#endif //USE_PNP_NAME
    deviceNameUnicodeString = &localDeviceNameUnicodeString;

    if (NT_SUCCESS(ntStatus) && deviceNameUnicodeString) {

        //
        // got the device name, now create a symbolic
        // link for the host HCD/Roothub stack
        //

        //
        // use hardcoded value of HCDn for now until
        // we have a we to get these names from user mode
        //

        WCHAR deviceLinkBuffer[]  = L"\\DosDevices\\HCD0";
        WCHAR *buffer;

        deviceLinkBuffer[15] = (WCHAR)('0'+ HcdDeviceNameHandle);

        buffer =
            ExAllocatePoolWithTag(PagedPool, sizeof(deviceLinkBuffer), USBD_TAG);

        if (buffer) {
            RtlCopyMemory(buffer,
                          deviceLinkBuffer,
                          sizeof(deviceLinkBuffer));

            RtlInitUnicodeString(&deviceExtension->DeviceLinkUnicodeString,
                                 buffer);
            ntStatus =
                IoCreateSymbolicLink(
                    &deviceExtension->DeviceLinkUnicodeString,
                    deviceNameUnicodeString);

            USBD_KdPrint(3, ("'IoCreateSymbolicLink for HCD returned 0x%x\n",
                            ntStatus));

            // write the symbolic name to the registry
            {
                WCHAR hcdNameKey[] = L"SymbolicName";

                USBD_SetPdoRegistryParameter (
                    PhysicalDeviceObject,
                    &hcdNameKey[0],
                    sizeof(hcdNameKey),
                    &deviceExtension->DeviceLinkUnicodeString.Buffer[0],
                    deviceExtension->DeviceLinkUnicodeString.Length,
                    REG_SZ,
                    PLUGPLAY_REGKEY_DEVICE);
            }
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlFreeUnicodeString(deviceNameUnicodeString);
    }
//#endif

    InitializeUsbDeviceMutex(deviceExtension);
    deviceExtension->Length = sizeof(USBD_EXTENSION);

    // Always start with the default address (0) assigned.
    // Address array has one bit for every address 0..127
    deviceExtension->AddressList[0] = 1;
    deviceExtension->AddressList[1] =
        deviceExtension->AddressList[2] =
        deviceExtension->AddressList[3] = 0;

    deviceExtension->FrameLengthControlOwner = NULL;

    deviceExtension->RootHubPDO = NULL;

    deviceExtension->DriverObject = HcdDriverObject;

    deviceExtension->TrueDeviceExtension = deviceExtension;

    deviceExtension->RootHubDeviceState = PowerDeviceD0;
    // initial HC device state is OFF until we get a start
    deviceExtension->HcCurrentDevicePowerState = PowerDeviceD3;

    KeInitializeSpinLock(&deviceExtension->WaitWakeSpin);
    KeInitializeSpinLock(&deviceExtension->RootHubPowerSpin);

    deviceExtension->RootHubPowerDeviceObject = NULL;
    deviceExtension->RootHubPowerIrp = NULL;

    deviceExtension->IdleNotificationIrp = NULL;
    deviceExtension->IsPIIX3or4 = FALSE;
    deviceExtension->WakeSupported = FALSE;

    for (i=PowerSystemUnspecified; i< PowerSystemMaximum; i++) {
        deviceExtension->
                RootHubDeviceCapabilities.DeviceState[i] = PowerDeviceD3;
    }

//#ifndef WAIT_WAKE
//    #pragma message ("warning: using workaround for bugs in ntkern")
//    deviceExtension->HcWakeFlags |= HC_ENABLED_FOR_WAKEUP;
//#endif

    //
    // intially we are the top of the stack
    //
    deviceExtension->HcdTopOfStackDeviceObject =
        deviceExtension->HcdDeviceObject =
            HcdDeviceObject;

    deviceExtension->HcdPhysicalDeviceObject = PhysicalDeviceObject;

    // remember the top of the PdoStack
    deviceExtension->HcdTopOfPdoStackDeviceObject =
        HcdTopOfPdoStackDeviceObject;

    deviceExtension->HcdDeferredStartDevice =
        HcdDeferredStartDevice;

    deviceExtension->HcdSetDevicePowerState =
        HcdSetDevicePowerState;

    deviceExtension->HcdGetCurrentFrame =
        HcdGetCurrentFrame;

    deviceExtension->HcdGetConsumedBW =
        HcdGetConsumedBW;

    deviceExtension->HcdSubmitIsoUrb =
        HcdSubmitIsoUrb;

    // read params from registry for diagnostic mode and
    // support for non-compliant devices
    USBD_GetPdoRegistryParameters(PhysicalDeviceObject,
                                  &complienceFlags,
                                  &diagnosticFlags,
                                  &deviceExtension->DeviceHackFlags);

    USBD_GetGlobalRegistryParameters(PhysicalDeviceObject,
                                  &complienceFlags,
                                  &diagnosticFlags,
                                  &deviceExtension->DeviceHackFlags);

    deviceExtension->DiagnosticMode = (BOOLEAN) diagnosticFlags;
    deviceExtension->DiagIgnoreHubs = FALSE;

    if (complienceFlags) {
        // support non-com means turn on all hacks
        deviceExtension->DeviceHackFlags = -1;
    }

#if DBG
    if (deviceExtension->DeviceHackFlags) {
        USBD_KdPrint(1, ("Using DeviceHackFlags (%x)\n",
            deviceExtension->DeviceHackFlags));
    }

    //
    // trap if we detect any special flags set
    //
    if (deviceExtension->DiagnosticMode ||
        complienceFlags) {

        if (deviceExtension->DiagnosticMode) {
            USBD_Warning(NULL,
                         "The USB stack is in diagnostic mode\n",
                         FALSE);

            if (deviceExtension->DiagIgnoreHubs) {
                USBD_Warning(NULL,
                             "The USB stack ignoring HUBs in diag mode\n",
                             FALSE);
            }
        }

        if (complienceFlags) {
            USBD_Warning(NULL,
                         "Support for non-compliant devices is enabled\n",
                         FALSE);
        }
    }
#endif

    USBD_KdPrint(3, ("'exit USBD_RegisterHostController ext = 0x%x (0x%x)\n",
        deviceExtension, ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_CreateDeviceX(
    IN OUT PUSBD_DEVICE_DATA *DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeviceIsLowSpeed,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each new device on the USB bus, this function sets
    up the internal data structures we need to keep track of the
    device and assigns it an address.

Arguments:

    DeviceData - ptr to return the ptr to the new device structure
                created by this routine

    DeviceObject - USBD device object for the USB bus this device is on.

    DeviceIsLowSpeed - indicates if a device is low speed

    MaxPacketSize_Endpoint0 (*OPTIONAL*) indicates the default max packet
                    size to use when opening endpiint 0.

    NonCompliantDevice (*OPTIONAL*) pointer to boolean flag, set to true
                    if support for non-compliant usb devices is enabled.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus;
    PUSBD_DEVICE_DATA deviceData;
    PUSBD_PIPE defaultPipe;
    PUSBD_EXTENSION deviceExtension;
    ULONG bytesReturned = 0;
    PUCHAR data = NULL;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_CreateDevice\n"));

    *DeviceData = NULL;

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    //USBD_WaitForUsbDeviceMutex(deviceExtension);

    //
    // this flag tells the hub driver to do a reset port before calling
    // initialize_device
    //
    if (DeviceHackFlags) {
       *DeviceHackFlags = deviceExtension->DeviceHackFlags;
    }

    //
    // Allocate a USBD_DEVICE_DATA structure
    //

    deviceData = *DeviceData = GETHEAP(NonPagedPool,
                                       sizeof(USBD_DEVICE_DATA));

    // buffer for our descriptor
    data = GETHEAP(NonPagedPool,
                   USB_DEFAULT_MAX_PACKET);

    if (deviceData != NULL && data != NULL) {

        //
        // Initialize some fields in the device structure
        //

        deviceData->ConfigurationHandle = NULL;

        deviceData->DeviceAddress = USB_DEFAULT_DEVICE_ADDRESS;

        deviceData->LowSpeed = DeviceIsLowSpeed;

        deviceData->AcceptingRequests = TRUE;
        deviceData->Sig = SIG_DEVICE;

        // **
        // We need to talk to the device, first we open the default pipe
        // using the defined max packet size (defined by USB spec as 8
        // bytes until device receives the GET_DESCRIPTOR (device) command).
        // We set the address get the device descriptor then close the pipe
        // and re-open it with the correct max packet size.
        // **

        //
        // open the default pipe for the device
        //
        defaultPipe = &deviceData->DefaultPipe;
        defaultPipe->HcdEndpoint = NULL;    //default pipe is closed

        //
        // setup the endpoint descriptor for the default pipe
        //
        defaultPipe->UsbdPipeFlags = 0;
        defaultPipe->EndpointDescriptor.bLength =
            sizeof(USB_ENDPOINT_DESCRIPTOR);
        defaultPipe->EndpointDescriptor.bDescriptorType =
            USB_ENDPOINT_DESCRIPTOR_TYPE;
        defaultPipe->EndpointDescriptor.bEndpointAddress =
            USB_DEFAULT_ENDPOINT_ADDRESS;
        defaultPipe->EndpointDescriptor.bmAttributes =
            USB_ENDPOINT_TYPE_CONTROL;
        defaultPipe->EndpointDescriptor.wMaxPacketSize =
            USB_DEFAULT_MAX_PACKET;
        defaultPipe->EndpointDescriptor.bInterval = 0;
        //
        // probably won't be moving more that 4k on the default pipe
        //
        defaultPipe->MaxTransferSize = USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;

        ntStatus = USBD_OpenEndpoint(deviceData,
                                     DeviceObject,
                                     defaultPipe,
                                     NULL,
                                     TRUE);

        if (NT_SUCCESS(ntStatus)) {

            //
            // Configure the default pipe for this device and assign the
            // device an address
            //
            // NOTE: if this operation fails it means that we have a device
            // that will respond to the default endpoint and we can't change
            // it.
            // we have no choice but to disable the port on the hub this
            // device is attached to.
            //


            //
            // Get information about the device
            //
            ntStatus =
                USBD_SendCommand(deviceData,
                                 DeviceObject,
                                 STANDARD_COMMAND_GET_DESCRIPTOR,
                                 USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(
                                    USB_DEVICE_DESCRIPTOR_TYPE, 0),
                                 0,
                                 USB_DEFAULT_MAX_PACKET,
                                 data,
                                 //(PUCHAR) &deviceData->DeviceDescriptor,
                                 USB_DEFAULT_MAX_PACKET,
                                 &bytesReturned,
                                 NULL);

                // NOTE:
                // at this point we only have the first 8 bytes of the
                // device descriptor.
        }

        //
        // if we got at least the first 8 bytes of the
        // descriptor then we are OK
        //

        RtlCopyMemory(&deviceData->DeviceDescriptor,
                      data,
                      sizeof(deviceData->DeviceDescriptor));

        if (bytesReturned == 8 && !NT_SUCCESS(ntStatus)) {
            USBD_KdPrint(3,
                ("'Error returned from get device descriptor -- ignored\n"));
            ntStatus = STATUS_SUCCESS;
        }

        // validate the max packet value and descriptor
        if (NT_SUCCESS(ntStatus) &&
            (bytesReturned < 8 ||
            deviceData->DeviceDescriptor.bMaxPacketSize0 == 0)) {
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        if (!NT_SUCCESS(ntStatus)) {

            //
            // something went wrong, if we assigned any resources to
            // the default pipe then we free them before we get out.
            //

            // we need to signal to the parent hub that this
            // port is to be be disabled we will do this by
            // returning an error.

            if (defaultPipe->HcdEndpoint != NULL) {

                USBD_CloseEndpoint(deviceData,
                                   DeviceObject,
                                   defaultPipe,
                                   NULL);

                defaultPipe->HcdEndpoint = NULL;    //default pipe is closed
            }

            RETHEAP(deviceData);

            //
            // return a null ptr on error
            //

            *DeviceData = NULL;
        }

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        if (deviceData != NULL) {
            RETHEAP(deviceData);
        }

        *DeviceData = NULL;
    }

    if (data != NULL) {
        RETHEAP(data);
    }

    //USBD_ReleaseUsbDeviceMutex(deviceExtension);

    USBD_KdPrint(3, ("'exit USBD_CreateDevice 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_CreateDevice(
    IN OUT PUSBD_DEVICE_DATA *DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeviceIsLowSpeed,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags
    )
{

    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_CreateDevice) - get JD\n"));

    return USBD_CreateDeviceX(
        DeviceData,
        DeviceObject,
        DeviceIsLowSpeed,
        MaxPacketSize_Endpoint0,
        DeviceHackFlags
        );
}



NTSTATUS
USBD_RemoveDeviceX(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Flags
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each device on the USB bus that needs to be removed.
    This routine frees the device handle and the address assigned
    to the device.

    This function should be called after the driver has been notified
    that the device has been removed.

Arguments:

    DeviceData - ptr to device data structure created by class driver
                in USBD_CreateDevice.

    DeviceObject - USBD device object for the USB bus this device is on.

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_EXTENSION deviceExtension;
    PUSBD_PIPE defaultPipe;
    USBD_STATUS usbdStatus;
    BOOLEAN keepDeviceData;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_RemoveDevice\n"));

    if (!DeviceData || !DeviceObject) {
        USBD_KdPrint(1, ("'NULL parameter passed to USBD_RemoveDevice\n"));
        return STATUS_INVALID_PARAMETER;
    }

    if (DeviceData->Sig != SIG_DEVICE) {
        USBD_KdPrint(1, ("'Bad DeviceData parameter passed to USBD_RemoveDevice\n"));
        return STATUS_INVALID_PARAMETER;
    }

    if (Flags & USBD_MARK_DEVICE_BUSY) {
        DeviceData->AcceptingRequests = FALSE;
        return STATUS_SUCCESS;
    }

    keepDeviceData = Flags & USBD_KEEP_DEVICE_DATA;

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    USBD_WaitForUsbDeviceMutex(deviceExtension);
    //
    // make sure and clean up any open pipe handles
    // the device may have
    //
    ASSERT_DEVICE(DeviceData);

    DeviceData->AcceptingRequests = FALSE;

    if (DeviceData->ConfigurationHandle) {


        ntStatus = USBD_InternalCloseConfiguration(DeviceData,
                                                   DeviceObject,
                                                   &usbdStatus,
                                                   TRUE,
                                                   keepDeviceData);

#if DBG
        if (!NT_SUCCESS(ntStatus) ||
            !USBD_SUCCESS(usbdStatus)) {
             USBD_KdTrap(
                ("'error %x usberr %x occurred during RemoveDevice\n",
                ntStatus, usbdStatus));
        }
#endif

    }

    defaultPipe = &DeviceData->DefaultPipe;

    if (defaultPipe->HcdEndpoint != NULL) {
        USBD_STATUS usbdStatus;

        USBD_InternalCloseDefaultPipe(DeviceData,
                                      DeviceObject,
                                      &usbdStatus,
                                      TRUE);

//        USBD_CloseEndpoint(DeviceData,
//                           DeviceObject,
//                           defaultPipe,
//                           NULL);
//
//        defaultPipe->HcdEndpoint = NULL;    //default pipe is closed
    }

    if (DeviceData->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
        USBD_FreeUsbAddress(DeviceObject, DeviceData->DeviceAddress);
    }

    if (!keepDeviceData) {
        // zap the signature
        DeviceData->Sig = 0;
        RETHEAP(DeviceData);
    }

    USBD_ReleaseUsbDeviceMutex(deviceExtension);

    USBD_KdPrint(3, ("'exit USBD_RemoveDevice\n"));

    return ntStatus;
}


NTSTATUS
USBD_RemoveDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Flags
    )
{
       USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_RemoveDevice) - get JD\n"));

    return USBD_RemoveDeviceX(
        DeviceData,
        DeviceObject,
        Flags);
}


NTSTATUS
USBD_InitializeDeviceX(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Called for each device on the USB bus that needs to be initialized.
    This routine allocates an address and assigns it to the device.

    NOTE: on entry the the device descriptor in DeviceData is expected to
        contain at least the first 8 bytes of the device descriptor, this
        information is used to open the default pipe.

    On Error the DeviceData structure is freed.

Arguments:

    DeviceData - ptr to device data structure created by class driver
                from a call to USBD_CreateDevice.

    DeviceObject - USBD device object for the USB bus this device is on.

    DeviceDescriptor -

    DeviceDescriptorLength -

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_PIPE defaultPipe;
    USHORT address;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    USBD_KdPrint(3, ("'enter USBD_InitializeDevice\n"));

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    //USBD_WaitForUsbDeviceMutex(deviceExtension);

    USBD_ASSERT(DeviceData != NULL);

    defaultPipe = &DeviceData->DefaultPipe;

    //
    // Assign Address to the device
    //

    address = USBD_AllocateUsbAddress(DeviceObject);

    USBD_KdPrint(3, ("'SetAddress, assigning 0x%x address\n", address));


    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBD_SendCommand(DeviceData,
                                    DeviceObject,
                                    STANDARD_COMMAND_SET_ADDRESS,
                                    address,
                                    0,
                                    0,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL);

        DeviceData->DeviceAddress = address;
    }

    //
    // done with addressing process...
    //
    // close and re-open the pipe utilizing the
    // true max packet size for the defalt pipe
    // and the address we assigned to the device.
    //

    USBD_CloseEndpoint(DeviceData,
                       DeviceObject,
                       defaultPipe,
                       NULL);

    defaultPipe->HcdEndpoint = NULL;    //default pipe is closed


    if (NT_SUCCESS(ntStatus)) {

        {
        LARGE_INTEGER deltaTime;
        // 10ms delay to allow devices to respond after
        // the setaddress command
        deltaTime.QuadPart = -100000;
        (VOID) KeDelayExecutionThread(KernelMode,
                                      FALSE,
                                      &deltaTime);
        }

        // if we succesfully set the address then
        // go ahead and re-open the pipe.
        defaultPipe->EndpointDescriptor.wMaxPacketSize =
            DeviceData->DeviceDescriptor.bMaxPacketSize0;

        if (NT_SUCCESS(ntStatus)) {

            ntStatus = USBD_OpenEndpoint(DeviceData,
                                         DeviceObject,
                                         defaultPipe,
                                         NULL,
                                         TRUE);
        }

        //
        // Fetch the device descriptor again, this time
        // get the whole thing.
        //

        if (NT_SUCCESS(ntStatus)) {
            ULONG bytesReturned;

            ntStatus =
                USBD_SendCommand(DeviceData,
                                DeviceObject,
                                STANDARD_COMMAND_GET_DESCRIPTOR,
                                USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(
                                    USB_DEVICE_DESCRIPTOR_TYPE, 0),
                                0,
                                sizeof(DeviceData->DeviceDescriptor),
                                (PUCHAR) &DeviceData->DeviceDescriptor,
                                sizeof(DeviceData->DeviceDescriptor),
                                &bytesReturned,
                                NULL);
            if (NT_SUCCESS(ntStatus) &&
                bytesReturned < sizeof(DeviceData->DeviceDescriptor)) {
                ntStatus = STATUS_DEVICE_DATA_ERROR;
            }
        }

        //
        // Fetch the configuration descriptor for the user as well
        // so we can see how many interfaces there are in the configuration.
        // If this is a multiple interface device we might want to load
        // the standard mulitple interface parent driver instead of the
        // diagnostic driver.
        //

        // The 9 byte configuration descriptor is cached in the DeviceData
        // used by USBD_BusGetUsbDescriptors() later instead of bothering
        // the device with another Get Descriptor request again real soon.
        // Some devices don't take too well to being bothered with back to
        // back Get Descriptor requests for only the 9 byte header, especially
        // on OHCI host controllers.

        if (NT_SUCCESS(ntStatus)) {
            ULONG bytesReturned;
            ntStatus = 
                USBD_SendCommand(DeviceData,
                                DeviceObject,
                                STANDARD_COMMAND_GET_DESCRIPTOR,
                                USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(
                                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 0),
                                0,
                                sizeof(DeviceData->ConfigDescriptor),
                                (PUCHAR) &DeviceData->ConfigDescriptor,
                                sizeof(DeviceData->ConfigDescriptor),
                                &bytesReturned,
                                NULL);
            if (NT_SUCCESS(ntStatus) &&
                bytesReturned < sizeof(DeviceData->ConfigDescriptor)) {
                ntStatus = STATUS_DEVICE_DATA_ERROR;
            }
        }
    }

    if (NT_SUCCESS(ntStatus)) {

        //
        // Return copies of the device and the config descriptors to the caller
        //

        if (deviceExtension->DiagnosticMode &&
            !(deviceExtension->DiagIgnoreHubs &&
              (DeviceData->DeviceDescriptor.bDeviceClass == 0x09)))
                {

            if (DeviceData->ConfigDescriptor.bNumInterfaces > 1){
                /*
                 *  This is a COMPOSITE device.
                 *  Alter idProduct slightly so that diagnostic driver
                 *  doesn't load for the parent device.
                 *  The Generic Parent driver will see this and
                 *  set the vid/pid for children to FFFF/FFFF
                 */
                DeviceData->DeviceDescriptor.idVendor = 0xFFFF;
                DeviceData->DeviceDescriptor.idProduct = 0xFFFE;
            }
            else {
                DeviceData->DeviceDescriptor.idVendor = 0xFFFF;
                DeviceData->DeviceDescriptor.idProduct = 0xFFFF;
            }
            DeviceData->DeviceDescriptor.bDeviceClass = 0;
            DeviceData->DeviceDescriptor.bDeviceSubClass = 0;
        }

        if (DeviceDescriptor) {
            RtlCopyMemory(DeviceDescriptor,
                          &DeviceData->DeviceDescriptor,
                          DeviceDescriptorLength);
        }

        if (ConfigDescriptor) {
            RtlCopyMemory(ConfigDescriptor,
                          &DeviceData->ConfigDescriptor,
                          ConfigDescriptorLength);
        }
    } else {

        //
        // something went wrong, if we assigned any resources to
        // the default pipe then we free them before we get out.
        //

        // we need to signal to the parent hub that this
        // port is to be be disabled we will do this by
        // returning an error.

        if (defaultPipe->HcdEndpoint != NULL) {

            USBD_CloseEndpoint(DeviceData,
                               DeviceObject,
                               defaultPipe,
                               NULL);

            defaultPipe->HcdEndpoint = NULL;    //default pipe is closed
        }

        if (DeviceData->DeviceAddress != USB_DEFAULT_DEVICE_ADDRESS) {
            USBD_FreeUsbAddress(DeviceObject, DeviceData->DeviceAddress);
        }

        RETHEAP(DeviceData);
    }

    //USBD_ReleaseUsbDeviceMutex(deviceExtension);

    USBD_KdPrint(3, ("'exit USBD_InitializeDevice 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_InitializeDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    )
{
    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_InitializeDevice) - get JD\n"));

    return USBD_InitializeDeviceX(
        DeviceData,
        DeviceObject,
        DeviceDescriptor,
        DeviceDescriptorLength,
        ConfigDescriptor,
        ConfigDescriptorLength);
}


BOOLEAN
USBD_Dispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_OBJECT *HcdDeviceObject,
    NTSTATUS *NtStatus
    )
/*++

Routine Description:

    Entry point called by HCD to allow USBD to process requests first.  Since
    the root hub (PDO) and the Hos cOntroller FDO share the same dispatch
    routine. The HCD calls this function to allow USBD to handle Irps passed
    to the PDO for the root hub.

Arguments:

Return Value:

    FALSE = Irp completed by USBD
    TRUE = Irp needs completion by HCD

--*/
{
    BOOLEAN irpNeedsCompletion = TRUE;
    PUSBD_EXTENSION deviceExtension;
    BOOLEAN forPDO = FALSE;
    PIO_STACK_LOCATION irpStack;

    USBD_KdPrint(3, ("'enter USBD_Dispatch\n"));

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // apparently the following is valid on NT:
    // remove rh PDO
    // remove hcd FDO
    // remove rh PDO
    // we have a special flag to force failure of any PnP IRPs
    // in case this happens
    //

    if (deviceExtension->Flags & USBDFLAG_PDO_REMOVED &&
        irpStack->MajorFunction == IRP_MJ_PNP &&
        deviceExtension->TrueDeviceExtension != deviceExtension) {

        irpNeedsCompletion = FALSE;
        USBD_KdPrint(0, ("'Warning: PNP irp for RH PDO received after HCD removed\n"));
        *NtStatus =
              Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        USBD_IoCompleteRequest (Irp,
                                 IO_NO_INCREMENT);

        return irpNeedsCompletion;
    }

    if (deviceExtension->TrueDeviceExtension != deviceExtension) {
        // This request is for a PDO we created for the
        // root hub
        deviceExtension = deviceExtension->TrueDeviceExtension;
        forPDO = TRUE;
    }

    //
    // extract the host controller FDO and return it.
    //

    *HcdDeviceObject = deviceExtension->HcdDeviceObject;

    if (forPDO) {

        irpNeedsCompletion = FALSE;
        *NtStatus = USBD_PdoDispatch(DeviceObject,
                                     Irp,
                                     deviceExtension,
                                     &irpNeedsCompletion);

    } else {

        *NtStatus = USBD_FdoDispatch(DeviceObject,
                                     Irp,
                                     deviceExtension,
                                     &irpNeedsCompletion);
    }

    //
    // this flag tells the HCD if they should handle the Irp.
    //

    return irpNeedsCompletion;

}


VOID
USBD_RhDelayedSetPowerD0Worker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a delayed Set Power D0 IRP for the root hub.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBD_RH_DELAYED_SET_POWER_D0_WORK_ITEM workItemSetPowerD0;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PUSBD_EXTENSION deviceExtension = NULL;
    PDEVICE_OBJECT rootHubPowerDeviceObject = NULL;
    PIRP rootHubPowerIrp = NULL;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    workItemSetPowerD0 = Context;

    deviceExtension = workItemSetPowerD0->DeviceExtension;
    rootHubPowerDeviceObject = workItemSetPowerD0->DeviceObject;
    rootHubPowerIrp = workItemSetPowerD0->Irp;

    ExFreePool(Context);

    irpStack = IoGetCurrentIrpStackLocation(rootHubPowerIrp);

    ntStatus = deviceExtension->RootHubPower(
                    deviceExtension->HcdDeviceObject,
                    rootHubPowerIrp);

    // notify after we go on
    PoSetPowerState(rootHubPowerDeviceObject,
                    DevicePowerState,
                    irpStack->Parameters.Power.State);

    //
    // keep track of the power state for this PDO
    //

    deviceExtension->RootHubDeviceState =
            irpStack->Parameters.Power.State.DeviceState;

    USBD_CompleteIdleNotification(deviceExtension);

    rootHubPowerIrp->IoStatus.Status = ntStatus;
    PoStartNextPowerIrp(rootHubPowerIrp);
    USBD_IoCompleteRequest(rootHubPowerIrp, IO_NO_INCREMENT);
}


VOID
USBD_CompleteIdleNotification(
    IN PUSBD_EXTENSION DeviceExtension
    )
{
    NTSTATUS status;
    KIRQL irql;
    PIRP irp = NULL;

    IoAcquireCancelSpinLock(&irql);

    irp = DeviceExtension->IdleNotificationIrp;
    DeviceExtension->IdleNotificationIrp = NULL;

    if (irp && (irp->Cancel)) {
        irp = NULL;
    }

    if (irp) {
        IoSetCancelRoutine(irp, NULL);
    }

    IoReleaseCancelSpinLock(irql);

    if (irp) {
        irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}


NTSTATUS
USBD_HcPoRequestD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PUSBD_RH_DELAYED_SET_POWER_D0_WORK_ITEM workItemSetPowerD0;
    NTSTATUS ntStatus;
    PUSBD_EXTENSION deviceExtension = Context;
    KIRQL irql;
    PIRP pendingWakeIrp;
    PDEVICE_OBJECT rootHubPowerDeviceObject = NULL;
    PIRP rootHubPowerIrp = NULL;

    ntStatus = IoStatus->Status;

    USBD_KdPrint(1, ("USBD_HcPoRequestD0Completion, status = %x\n", ntStatus));

    KeAcquireSpinLock(&deviceExtension->RootHubPowerSpin,
                      &irql);

    deviceExtension->Flags &= ~USBDFLAG_HCD_D0_COMPLETE_PENDING;

    if (deviceExtension->Flags & USBDFLAG_RH_DELAY_SET_D0) {

        deviceExtension->Flags &= ~USBDFLAG_RH_DELAY_SET_D0;

        rootHubPowerDeviceObject = deviceExtension->RootHubPowerDeviceObject;
        deviceExtension->RootHubPowerDeviceObject = NULL;

        rootHubPowerIrp = deviceExtension->RootHubPowerIrp;
        deviceExtension->RootHubPowerIrp = NULL;
    }

    KeReleaseSpinLock(&deviceExtension->RootHubPowerSpin,
                      irql);

    // Power up the RootHub now if we delayed it waiting for the HC set D0
    // to complete.

    if (rootHubPowerIrp) {

        //
        // Schedule a work item to process this.
        //
        workItemSetPowerD0 =
            ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(USBD_RH_DELAYED_SET_POWER_D0_WORK_ITEM),
                                  USBD_TAG);

        if (workItemSetPowerD0) {

            workItemSetPowerD0->DeviceExtension = deviceExtension;
            workItemSetPowerD0->DeviceObject = rootHubPowerDeviceObject;
            workItemSetPowerD0->Irp = rootHubPowerIrp;

            ExInitializeWorkItem(&workItemSetPowerD0->WorkQueueItem,
                                 USBD_RhDelayedSetPowerD0Worker,
                                 workItemSetPowerD0);

            ExQueueWorkItem(&workItemSetPowerD0->WorkQueueItem,
                            DelayedWorkQueue);
        }
    }

    //
    // no wakeup irp pending
    //

    // The only race condition we our concerned about is if
    // the wait wake irp is completed while another is submitted.
    // the WaitWake spinlock protects us in this case

    KeAcquireSpinLock(&deviceExtension->WaitWakeSpin,
                      &irql);

    pendingWakeIrp = deviceExtension->PendingWakeIrp;
    deviceExtension->PendingWakeIrp = NULL;
    deviceExtension->HcWakeFlags &= ~HC_ENABLED_FOR_WAKEUP;

    KeReleaseSpinLock(&deviceExtension->WaitWakeSpin,
                      irql);

    // we just keep the irp pending until it is canceled

    //
    // this means that the HC was the source of
    // a wakeup ie a usbd device generated resume
    // signalling on the bus
    //

    // complete the root hub wakeup irp here

    if (pendingWakeIrp != NULL) {

        IoAcquireCancelSpinLock(&irql);
        if (pendingWakeIrp->Cancel) {
            IoReleaseCancelSpinLock(irql);
        } else {

            IoSetCancelRoutine(pendingWakeIrp, NULL);
            IoReleaseCancelSpinLock(irql);

            // status of this Irp?
            pendingWakeIrp->IoStatus = *IoStatus;

            USBD_IoCompleteRequest(pendingWakeIrp, IO_NO_INCREMENT);
        }
    }

    return ntStatus;
}


NTSTATUS
USBD_HcWaitWakeIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Called when a wake irp completes for a hub

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = IoStatus->Status;
    PUSBD_EXTENSION deviceExtension = Context;
    PIRP irp;
    KIRQL irql;
    PIRP pendingWakeIrp;
    POWER_STATE powerState;
    BOOLEAN bSubmitNewWakeIrp = FALSE;

    ntStatus = IoStatus->Status;

    USBD_KdPrint(1, ("WaitWake completion from HC %x\n", ntStatus));

    // Clear HcWakeIrp pointer now, otherwise we might try to cancel it in
    // USBD_WaitWakeCancel if it is called before our set D0 completes where
    // we used to clear HcWakeIrp.
    //
    // We are still protected from untimely submittal of a new HcWakeIrp
    // because this cannot happen until the PendingWakeIrp pointer (for
    // the RootHub) is cleared.

    KeAcquireSpinLock(&deviceExtension->WaitWakeSpin,
                      &irql);

    // no irp pending in the HC
    deviceExtension->HcWakeFlags &= ~HC_WAKE_PENDING;
    deviceExtension->HcWakeIrp = NULL;

    KeReleaseSpinLock(&deviceExtension->WaitWakeSpin,
                      irql);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        powerState.DeviceState = PowerDeviceD0;

        ntStatus = PoRequestPowerIrp(deviceExtension->
                                            HcdPhysicalDeviceObject,
                                     IRP_MN_SET_POWER,
                                     powerState,
                                     USBD_HcPoRequestD0Completion,
                                     deviceExtension,
                                     &irp);

        USBD_KdPrint(1, ("NTSTATUS return code from HC set D0 request %x, IRP: %x\n", ntStatus, irp));
        ASSERT(ntStatus == STATUS_PENDING);

        if (ntStatus == STATUS_PENDING) {
            deviceExtension->Flags |= USBDFLAG_HCD_D0_COMPLETE_PENDING;
        }

    } else {

        // The only race condition we our concerned about is if
        // the wait wake irp is completed wile another is submitted.
        // the WaitWake spinlock protects us in this case

        KeAcquireSpinLock(&deviceExtension->WaitWakeSpin,
                          &irql);

        pendingWakeIrp = deviceExtension->PendingWakeIrp;
        deviceExtension->PendingWakeIrp = NULL;
        deviceExtension->HcWakeFlags &= ~HC_ENABLED_FOR_WAKEUP;

        KeReleaseSpinLock(&deviceExtension->WaitWakeSpin,
                          irql);

        //
        // Complete the root hub wakeup irp here.
        //

        if (pendingWakeIrp != NULL) {

            IoAcquireCancelSpinLock(&irql);
            if (pendingWakeIrp->Cancel) {
                IoReleaseCancelSpinLock(irql);
            } else {

                IoSetCancelRoutine(pendingWakeIrp, NULL);
                IoReleaseCancelSpinLock(irql);

                // status of this Irp?
                pendingWakeIrp->IoStatus = *IoStatus;

                USBD_IoCompleteRequest(pendingWakeIrp, IO_NO_INCREMENT);
            }
        }
    }

    KeAcquireSpinLock(&deviceExtension->WaitWakeSpin,
                      &irql);

    bSubmitNewWakeIrp =
        (deviceExtension->Flags & USBDFLAG_NEED_NEW_HCWAKEIRP) ? 1 : 0;
    deviceExtension->Flags &= ~USBDFLAG_NEED_NEW_HCWAKEIRP;

    KeReleaseSpinLock(&deviceExtension->WaitWakeSpin,
                      irql);

    if (bSubmitNewWakeIrp) {
        USBD_SubmitWaitWakeIrpToHC(deviceExtension);
    }

    return ntStatus;
}


NTSTATUS
USBD_SubmitWaitWakeIrpToHC(
    IN PUSBD_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    called when a child Pdo is enabled for wakeup, this
    function allocates a wait wake irp and passes it to
    the parents PDO.


Arguments:

Return Value:

--*/
{
    PIRP irp;
    NTSTATUS ntStatus;
    POWER_STATE powerState;
    KIRQL irql;
    PIRP hcWakeIrp;

    KeAcquireSpinLock(&DeviceExtension->WaitWakeSpin,
                      &irql);

    hcWakeIrp = DeviceExtension->HcWakeIrp;

    if (hcWakeIrp && hcWakeIrp->Cancel &&
        !(DeviceExtension->Flags & USBDFLAG_NEED_NEW_HCWAKEIRP)) {

        DeviceExtension->Flags |= USBDFLAG_NEED_NEW_HCWAKEIRP;

        KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                          irql);

        // If we allow a new WW IRP to be posted for the HC now, it will be
        // completed with an error because the previous one has not been
        // completed/canceled yet.  So we set a flag that tells the HC WW IRP
        // completion routine that it needs to submit the WW IRP for the HC.

        USBD_KdPrint(1, (" HC will be re-enabled for wakeup when old WW IRP completes.\n"));
        return STATUS_PENDING;

    } else {

        KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                          irql);
    }

    USBD_ASSERT(DeviceExtension->HcWakeIrp == NULL);

    // call top of HC driver stack

    DeviceExtension->HcWakeFlags |= HC_WAKE_PENDING;

    powerState.DeviceState = DeviceExtension->HcDeviceCapabilities.SystemWake;

    USBD_KdPrint(1, ("Submitting IRP_MN_WAIT_WAKE to HC, powerState: %x\n",
        DeviceExtension->HcDeviceCapabilities.SystemWake));

    ntStatus = PoRequestPowerIrp(DeviceExtension->
                                        HcdPhysicalDeviceObject,
                                 IRP_MN_WAIT_WAKE,
                                 powerState,
                                 USBD_HcWaitWakeIrpCompletion,
                                 DeviceExtension,
                                 &irp);

    if (DeviceExtension->HcWakeFlags & HC_WAKE_PENDING) {
        DeviceExtension->HcWakeIrp = irp;
        USBD_KdPrint(1, (" HC enabled for wakeup\n"));
    }

    USBD_ASSERT(ntStatus == STATUS_PENDING);

    return ntStatus;
}

VOID
USBD_WaitWakeCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

    NT status code.

--*/
{
    PUSBD_EXTENSION deviceExtension;
    KIRQL irql;

    USBD_KdPrint(3, ("'WaitWake Irp %x cancelled\n", Irp));
    USBD_ASSERT(Irp->Cancel == TRUE);

    deviceExtension = (PUSBD_EXTENSION)
        Irp->IoStatus.Information;
    USBD_ASSERT(deviceExtension != NULL);
    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    KeAcquireSpinLock(&deviceExtension->WaitWakeSpin,
                      &irql);

    deviceExtension->PendingWakeIrp = NULL;
    deviceExtension->HcWakeFlags &= ~HC_ENABLED_FOR_WAKEUP;

    // see if we need to cancel a wake irp
    // in the HC

    if (deviceExtension->HcWakeIrp) {
        PIRP irp;

        irp = deviceExtension->HcWakeIrp;
        KeReleaseSpinLock(&deviceExtension->WaitWakeSpin,
                          irql);

        USBD_KdPrint(1, (" Canceling Wake Irp (%x) on HC PDO\n", irp));
        IoCancelIrp(irp);
    } else {
        KeReleaseSpinLock(&deviceExtension->WaitWakeSpin,
                          irql);
    }

    USBD_IoCompleteRequest (Irp,
                            IO_NO_INCREMENT);
}


NTSTATUS
USBD_PdoPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PUSBD_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Disptach routine for Power Irps sent to the PDO for the root hub.

    NOTE:
        irps sent to the PDO are always completed by the bus driver

Arguments:

    DeviceObject - Pdo for the root hub

Return Value:

    None

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    KIRQL irql;
    PDRIVER_CANCEL  oldCancel;
    PDEVICE_CAPABILITIES hcDeviceCapabilities;
    PIRP irp, waitWakeIrp = NULL, idleIrp = NULL;
    POWER_STATE powerState;

    USBD_KdPrint(3, ("'enter USBD_PdoPower\n"));
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);

    switch (irpStack->MinorFunction) {
    case IRP_MN_SET_POWER:
        USBD_KdPrint(3, ("'IRP_MN_SET_POWER root hub PDO\n"));

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            {
            //
            // since the fdo driver for the root hub pdo is our own
            // hub driver and it is well behaved, we don't expect to see
            // a system message where the power state is still undefined
            //
            //
            // we just complete this with success
            //
            ntStatus = STATUS_SUCCESS;
            USBD_KdPrint(1,
("IRP_MJ_POWER RH pdo(%x) MN_SET_POWER(SystemPowerState S%x) status = %x complt\n",
                DeviceObject,
                irpStack->Parameters.Power.State.SystemState - 1,
                ntStatus));
            if (irpStack->Parameters.Power.State.SystemState >=
                PowerSystemShutdown) {
                USBD_KdPrint(1, ("Shutdown Detected for Root Hub PDO\n",
                    DeviceObject, ntStatus));
            }
            }
            break;

        case DevicePowerState:

            USBD_KdPrint(1,
("IRP_MJ_POWER RH pdo(%x) MN_SET_POWER(DevicePowerState D%x) from (D%x)\n",
                DeviceObject,
                irpStack->Parameters.Power.State.DeviceState - 1,
                DeviceExtension->RootHubDeviceState - 1));

            if (irpStack->Parameters.Power.State.DeviceState ==
                    PowerDeviceD0) {

                KeAcquireSpinLock(&DeviceExtension->RootHubPowerSpin,
                                  &irql);

                // Don't power up root hub yet if the HC is not at D0.

                if (DeviceExtension->HcCurrentDevicePowerState == PowerDeviceD0 &&
                    !(DeviceExtension->Flags & USBDFLAG_HCD_D0_COMPLETE_PENDING)) {

                    KeReleaseSpinLock(&DeviceExtension->RootHubPowerSpin,
                                      irql);

                    ntStatus =
                        DeviceExtension->RootHubPower(
                                DeviceExtension->HcdDeviceObject,
                                Irp);
                    // notify after we go on
                    PoSetPowerState(DeviceObject,
                                    DevicePowerState,
                                    irpStack->Parameters.Power.State);

                    USBD_CompleteIdleNotification(DeviceExtension);

                } else if (!(DeviceExtension->Flags & USBDFLAG_RH_DELAY_SET_D0)) {

                    DeviceExtension->Flags |= USBDFLAG_RH_DELAY_SET_D0;

                    ASSERT(DeviceExtension->RootHubPowerDeviceObject == NULL);
                    ASSERT(DeviceExtension->RootHubPowerIrp == NULL);

                    DeviceExtension->RootHubPowerDeviceObject = DeviceObject;
                    DeviceExtension->RootHubPowerIrp = Irp;

                    KeReleaseSpinLock(&DeviceExtension->RootHubPowerSpin,
                                      irql);

                    USBD_KdPrint(1, ("'USBD_PdoPower, not powering up RootHub yet because HC is not at D0.\n"));

                    KeAcquireSpinLock(&DeviceExtension->WaitWakeSpin,
                                      &irql);

                    // see if we need to cancel a wake irp
                    // in the HC

                    if (DeviceExtension->HcWakeIrp) {
                        PIRP hcwakeirp;

                        hcwakeirp = DeviceExtension->HcWakeIrp;
                        KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                                          irql);

                        USBD_KdPrint(1, ("USBD_PdoPower, Set D0: Canceling Wake Irp (%x) on HC PDO\n", hcwakeirp));
                        IoCancelIrp(hcwakeirp);

                    } else {
                        KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                                          irql);
                    }

                    // Set the HC to D0 now.

                    powerState.DeviceState = PowerDeviceD0;

                    ntStatus = PoRequestPowerIrp(DeviceExtension->
                                                        HcdPhysicalDeviceObject,
                                                 IRP_MN_SET_POWER,
                                                 powerState,
                                                 USBD_HcPoRequestD0Completion,
                                                 DeviceExtension,
                                                 &irp);

                    USBD_KdPrint(1, ("NTSTATUS return code from HC set D0 request %x, IRP: %x\n", ntStatus, irp));
                    ASSERT(ntStatus == STATUS_PENDING);

                    goto USBD_PdoPower_Done;

                } else {

                    KeReleaseSpinLock(&DeviceExtension->RootHubPowerSpin,
                                      irql);

                    // Root Hub set D0 is already pending, just complete this
                    // IRP with STATUS_SUCCESS.

                    ntStatus = STATUS_SUCCESS;
                }

            } else {

                //
                // Complete the Wait Wake Irp if we are going to D3.
                //
                // We take the cancel spinlock here to ensure our cancel routine does
                // not complete the Irp for us.
                //

                if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {

                    IoAcquireCancelSpinLock(&irql);

                    if (DeviceExtension->IdleNotificationIrp) {
                        idleIrp = DeviceExtension->IdleNotificationIrp;
                        DeviceExtension->IdleNotificationIrp = NULL;

                        if (idleIrp->Cancel) {
                            idleIrp = NULL;
                        }

                        if (idleIrp) {
                            IoSetCancelRoutine(idleIrp, NULL);
                        }
                    }

                    if (DeviceExtension->PendingWakeIrp) {

                        waitWakeIrp = DeviceExtension->PendingWakeIrp;
                        DeviceExtension->PendingWakeIrp = NULL;
                        DeviceExtension->HcWakeFlags &= ~HC_ENABLED_FOR_WAKEUP;

                        // irp can no longer be cancelled
                        if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
                            waitWakeIrp = NULL;
                        }
                    }

                    IoReleaseCancelSpinLock(irql);

                    if (idleIrp) {
                        idleIrp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
                        IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
                    }

                    if (waitWakeIrp) {
                        waitWakeIrp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
                        PoStartNextPowerIrp(waitWakeIrp);
                        USBD_IoCompleteRequest(waitWakeIrp, IO_NO_INCREMENT);
                    }
                }

                // notify before we go off
                PoSetPowerState(DeviceObject,
                                DevicePowerState,
                                irpStack->Parameters.Power.State);

                ntStatus =
                    DeviceExtension->RootHubPower(
                            DeviceExtension->HcdDeviceObject,
                            Irp);
            }

            //
            // keep track of the power state for this PDO
            //

            DeviceExtension->RootHubDeviceState =
                    irpStack->Parameters.Power.State.DeviceState;

            USBD_KdPrint(1,
("Setting RH pdo(%x) to D%d, status = %x complt\n",
                DeviceObject,
                DeviceExtension->RootHubDeviceState-1,
                ntStatus));

            break;

        default:
            USBD_KdTrap(("unknown system power message \n"));
            ntStatus = Irp->IoStatus.Status;
        }
        break;

    case IRP_MN_QUERY_POWER:

        ntStatus = STATUS_SUCCESS;
        USBD_KdPrint(1,
                     ("IRP_MJ_POWER RH pdo(%x) MN_QUERY_POWER, status = %x complt\n",
            DeviceObject, ntStatus));
        break;

    case IRP_MN_WAIT_WAKE:
        //
        // enabling the root hub for remote wakeup,
        // we need to enable the HC for remote wakeup
        // by posting a wakeup irp to the HC PDO.
        //
        // Technically the owner of the PDO for the
        // HC should know if the HC signalled wakeup.
        //

        // make a wake irp and post it to the HCs PDO

        KeAcquireSpinLock(&DeviceExtension->WaitWakeSpin,
                          &irql);

        if (DeviceExtension->PendingWakeIrp) {
            TEST_TRAP();
            ntStatus = STATUS_DEVICE_BUSY;
            KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin, irql);

        } else {
            USBD_KdPrint(1, (" IRP_MJ_POWER RH pdo(%x) MN_WAIT_WAKE, pending\n",
                             DeviceObject));

            //
            // Since the host controller has only one child we don't need
            // to keep track of the various PDO WaitWakes, and we can turn
            // around and send it directly to the HC.
            //
            // Normally we would have to track the multiple children, but
            // not today.
            //

            oldCancel = IoSetCancelRoutine(Irp, USBD_WaitWakeCancel);
            ASSERT (NULL == oldCancel);

            if (Irp->Cancel) {
                //
                // This IRP has aready been cancelled, so complete it now.
                // we must clear the cancel routine before completing the IRP.
                // We must release the spinlock before calling outside the
                // driver.
                //
                IoSetCancelRoutine (Irp, NULL);
                KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin, irql);
                ntStatus = Irp->IoStatus.Status = STATUS_CANCELLED;
            } else {
                //
                // Keep it.
                //
                IoMarkIrpPending(Irp);
                DeviceExtension->PendingWakeIrp = Irp;
                DeviceExtension->HcWakeFlags |= HC_ENABLED_FOR_WAKEUP;
                Irp->IoStatus.Information = (ULONG_PTR) DeviceExtension;

                hcDeviceCapabilities = &DeviceExtension->HcDeviceCapabilities;
                if (hcDeviceCapabilities->SystemWake != PowerSystemUnspecified) {

                    // If we are going to submit a new WW IRP to the HC below,
                    // then clear this flag so that we don't submit one in
                    // USBD_HcWaitWakeIrpCompletion.

                    DeviceExtension->Flags &= ~USBDFLAG_NEED_NEW_HCWAKEIRP;
                }
                KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin, irql);

                if (hcDeviceCapabilities->SystemWake != PowerSystemUnspecified) {
                    USBD_SubmitWaitWakeIrpToHC(DeviceExtension);
                }

                ntStatus = STATUS_PENDING;
                goto USBD_PdoPower_Done;
            }
        }

        USBD_KdPrint(1,
                     (" IRP_MJ_POWER RH pdo(%x) MN_WAIT_WAKE, status = %x complt\n",
                      DeviceObject, ntStatus));
        break;

    default:

        // unknown POWER messages for the PDO created
        // for the root hub
        ntStatus = Irp->IoStatus.Status;

        USBD_KdPrint(1, (" IRP_MJ_POWER RH pdo(%x) MN_[%d], status = %x\n",
                         DeviceObject, irpStack->MinorFunction, ntStatus));

    }

    Irp->IoStatus.Status = ntStatus;
    PoStartNextPowerIrp(Irp);
    USBD_IoCompleteRequest (Irp, IO_NO_INCREMENT);
USBD_PdoPower_Done:

    return ntStatus;
}


NTSTATUS
USBD_PdoPnP(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PUSBD_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Disptach routine for PnP Irps sent to the PDO for the root hub.

    NOTE:
        irps sent to the PDO are always completed by the bus driver

Arguments:

    DeviceObject - Pdo for the root hub

Return Value:

    None

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_CAPABILITIES DeviceCapabilities;
    NTSTATUS ntStatus;
    KIRQL irql;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;

    USBD_KdPrint(3, ("'enter USBD_PdoPnP\n"));

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    // PNP messages for the PDO created for the root hub

    switch (irpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        {
        PUSBD_DEVICE_DATA deviceData;

        USBD_KdPrint(1, (" Starting Root hub PDO %x\n",
            DeviceObject));

        // If there is no RootHubPDO, fail this start.

        if (!DeviceExtension->RootHubPDO) {
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // create the root hub on the bus
        //
        ntStatus = USBD_CreateDeviceX(&deviceData,
                                      DeviceObject,
                                      FALSE, // Not a low speed device
                                      8,     // Roothub max endpoint
                                             // packet size
                                      NULL);

        if (NT_SUCCESS(ntStatus)) {
            ntStatus = USBD_InitializeDeviceX(deviceData,
                                              DeviceObject,
                                              NULL,
                                              0,
                                              NULL,
                                              0);
        }

        //
        // create a symbolic link for the root hub PDO
        //
        if (NT_SUCCESS(ntStatus)) {
            DeviceExtension->RootHubDeviceData = deviceData;
            USBD_SymbolicLink(TRUE, DeviceExtension);
        }
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        USBD_KdPrint(1,
            (" Root Hub PDO (%x) is being removed\n",
                DeviceObject));

        IoAcquireCancelSpinLock(&irql);

        if (DeviceExtension->IdleNotificationIrp) {
            idleIrp = DeviceExtension->IdleNotificationIrp;
            DeviceExtension->IdleNotificationIrp = NULL;

            if (idleIrp->Cancel) {
                idleIrp = NULL;
            }

            if (idleIrp) {
                IoSetCancelRoutine(idleIrp, NULL);
            }
        }

        if (DeviceExtension->PendingWakeIrp) {

            waitWakeIrp = DeviceExtension->PendingWakeIrp;
            DeviceExtension->PendingWakeIrp = NULL;
            DeviceExtension->HcWakeFlags &= ~HC_ENABLED_FOR_WAKEUP;

            // irp can no longer be cancelled
            if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
                waitWakeIrp = NULL;
            }
        }

        IoReleaseCancelSpinLock(irql);

        if (idleIrp) {
            idleIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
        }

        if (waitWakeIrp) {
            waitWakeIrp->IoStatus.Status = STATUS_CANCELLED;
            PoStartNextPowerIrp(waitWakeIrp);
            USBD_IoCompleteRequest(waitWakeIrp, IO_NO_INCREMENT);
        }

        if (DeviceExtension->RootHubDeviceData) {
            USBD_RemoveDeviceX(DeviceExtension->RootHubDeviceData,
                               DeviceObject,
                               0);
            DeviceExtension->RootHubDeviceData = NULL;
            USBD_SymbolicLink(FALSE, DeviceExtension);
        }

        //
        // Ounce the removed flag is set all Irps sent to the
        // PDO will be failed.
        // since the HCD sets the RootHubPDO to NULL when its FDO
        // is removed and this remove should happen first we should
        // never see RootHubPDO == NULL
        //
        DeviceExtension->Flags |= USBDFLAG_PDO_REMOVED;
        USBD_ASSERT(DeviceExtension->RootHubPDO != NULL);

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:

        USBD_KdPrint(1,
            (" Root Hub PDO %x is being stopped\n",
                DeviceObject));

        //
        // Complete the Wait Wake Irp if we are stopping.
        //
        // We take the cancel spinlock here to ensure our cancel routine does
        // not complete the Irp for us.
        //

        IoAcquireCancelSpinLock(&irql);

        if (DeviceExtension->IdleNotificationIrp) {
            idleIrp = DeviceExtension->IdleNotificationIrp;
            DeviceExtension->IdleNotificationIrp = NULL;

            if (idleIrp->Cancel) {
                idleIrp = NULL;
            }

            if (idleIrp) {
                IoSetCancelRoutine(idleIrp, NULL);
            }
        }

        if (DeviceExtension->PendingWakeIrp) {

            waitWakeIrp = DeviceExtension->PendingWakeIrp;
            DeviceExtension->PendingWakeIrp = NULL;
            DeviceExtension->HcWakeFlags &= ~HC_ENABLED_FOR_WAKEUP;

            // irp can no longer be cancelled
            if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
                waitWakeIrp = NULL;
            }
        }

        IoReleaseCancelSpinLock(irql);

        if (idleIrp) {
            idleIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
        }

        if (waitWakeIrp) {
            waitWakeIrp->IoStatus.Status = STATUS_CANCELLED;
            PoStartNextPowerIrp(waitWakeIrp);
            USBD_IoCompleteRequest(waitWakeIrp, IO_NO_INCREMENT);
        }

        //
        // remove the device from the bus,
        // this will allow us to re-open the
        // root hub endpoints (ie HC looks for address 1)

        // if start failed we will have no DeviceData
        if (DeviceExtension->RootHubDeviceData ) {
            USBD_RemoveDeviceX(DeviceExtension->RootHubDeviceData,
                               DeviceObject,
                               0);
            DeviceExtension->RootHubDeviceData = NULL;
            USBD_SymbolicLink(FALSE, DeviceExtension);
        }

        USBD_ASSERT(DeviceExtension->AddressList[0] == 1);
        USBD_ASSERT(DeviceExtension->AddressList[1] == 0);
        USBD_ASSERT(DeviceExtension->AddressList[2] == 0);
        USBD_ASSERT(DeviceExtension->AddressList[3] == 0);

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_CAPABILITIES:

        //
        // Handle query caps for the root hub PDO
        //

        USBD_KdPrint(3, ("'IRP_MN_QUERY_CAPABILITIES\n"));

        //
        // Get the packet.
        //
        DeviceCapabilities=
            irpStack->Parameters.DeviceCapabilities.Capabilities;

        //
        // The power state capabilities for the root
        // hub should be the same as those of host
        // controller, these were passed to USBD by
        // the HCD when it registered.
        //

        RtlCopyMemory(DeviceCapabilities,
                      &DeviceExtension->RootHubDeviceCapabilities,
                      sizeof(*DeviceCapabilities));

        //
        // override these fields and
        // set the root hub capabilities.
        //
        DeviceCapabilities->Removable=FALSE; // root hub is not removable
        DeviceCapabilities->UniqueID=FALSE;
        DeviceCapabilities->Address = 0;
        DeviceCapabilities->UINumber = 0;

        ntStatus = STATUS_SUCCESS;

        break;

    case IRP_MN_QUERY_ID:

        USBD_KdPrint(3, ("'IOCTL_BUS_QUERY_ID\n"));

        ntStatus = STATUS_SUCCESS;

        switch (irpStack->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            Irp->IoStatus.Information=
                (ULONG_PTR)GetString(L"USB\\ROOT_HUB", FALSE);
            break;

        case BusQueryHardwareIDs:
            Irp->IoStatus.Information=
                (ULONG_PTR)GetString(L"USB\\ROOT_HUB\0USB\\OTHER_ID\0", TRUE);
            break;

         case BusQueryCompatibleIDs:
            Irp->IoStatus.Information=0;
            break;

        case BusQueryInstanceID:
            //
            // The root HUB is instanced solely by the controller's id.
            // Hence the UniqueDeviceId above.
            //
            Irp->IoStatus.Information=0;
            break;

        default:
            ntStatus = Irp->IoStatus.Status;
            break;
        }

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_INTERFACE:
        ntStatus = USBD_GetBusInterface(DeviceExtension->RootHubPDO,
                                        Irp);
        break;

    case IRP_MN_QUERY_BUS_INFORMATION:
        {
        // return the standard USB GUID
        PPNP_BUS_INFORMATION busInfo;

        busInfo = ExAllocatePoolWithTag(PagedPool,
                                        sizeof(PNP_BUS_INFORMATION),
                                        USBD_TAG);

        if (busInfo == NULL) {
           ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            busInfo->BusTypeGuid = GUID_BUS_TYPE_USB;
            busInfo->LegacyBusType = PNPBus;
            busInfo->BusNumber = 0;
            Irp->IoStatus.Information = (ULONG_PTR) busInfo;
            ntStatus = STATUS_SUCCESS;
        }
        }
        break;
    case IRP_MN_QUERY_DEVICE_RELATIONS:

        USBD_KdPrint(1,
            (" IRP_MN_QUERY_DEVICE_RELATIONS (PDO) %x %x\n",
                DeviceObject,
                irpStack->Parameters.QueryDeviceRelations.Type));

        if (irpStack->Parameters.QueryDeviceRelations.Type ==
            TargetDeviceRelation) {

            PDEVICE_RELATIONS deviceRelations = NULL;


            deviceRelations =
                ExAllocatePoolWithTag(PagedPool, sizeof(*deviceRelations),
                    USBD_TAG);

            if (deviceRelations == NULL) {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else if (DeviceExtension->RootHubPDO == NULL) {
                deviceRelations->Count = 0;
                ntStatus = STATUS_SUCCESS;
            } else {
                deviceRelations->Count = 1;
                ObReferenceObject(DeviceExtension->RootHubPDO);
                deviceRelations->Objects[0] =
                    DeviceExtension->RootHubPDO;
                ntStatus = STATUS_SUCCESS;
            }

            Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;

            USBD_KdPrint(1, (" TargetDeviceRelation to Root Hub PDO - complt\n"));

        } else {
            ntStatus = Irp->IoStatus.Status;
        }
        break;

    default:

        USBD_KdPrint(1, (" PnP IOCTL(%d) to root hub PDO not handled\n",
            irpStack->MinorFunction));

        ntStatus = Irp->IoStatus.Status;

    } /* switch, PNP minor function */

    Irp->IoStatus.Status = ntStatus;

    USBD_IoCompleteRequest (Irp,
                            IO_NO_INCREMENT);

    return ntStatus;
}


NTSTATUS
USBD_DeferPoRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    SetState - TRUE for set, FALSE for query.

    DevicePowerState - The Dx that we are in/tagetted.

    Context - Driver defined context, in this case the original power Irp.

    IoStatus - The status of the IRP.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PIRP irp;
    PUSBD_EXTENSION deviceExtension = Context;
    NTSTATUS ntStatus = IoStatus->Status;

    irp = deviceExtension->PowerIrp;

    IoCopyCurrentIrpStackLocationToNext(irp);
    PoStartNextPowerIrp(irp);
    PoCallDriver(deviceExtension->HcdTopOfPdoStackDeviceObject,
                 irp);

    return ntStatus;
}


VOID
USBD_IdleNotificationCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:


Arguments:

    DeviceObject -

    Irp - Power Irp.

Return Value:


--*/
{
    PUSBD_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;

    deviceExtension->IdleNotificationIrp = NULL;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}


NTSTATUS
USBD_IdleNotificationRequest(
    IN PUSBD_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function handles a request by a USB client driver (in this case
  * USBHUB) to tell us that the device wants to idle (selective suspend).
  *
  * Arguments:
  *
  * DeviceExtension - the PDO extension
  * Irp - the request packet
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    NTSTATUS ntStatus = STATUS_PENDING;
    KIRQL irql;
    PIRP idleIrp;

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtension->IdleNotificationIrp != NULL) {

        IoReleaseCancelSpinLock(irql);

        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        ntStatus = STATUS_DEVICE_BUSY;
        goto USBD_IdleNotificationRequestDone;

    } else if (Irp->Cancel) {

        IoReleaseCancelSpinLock(irql);

        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        ntStatus = STATUS_CANCELLED;
        goto USBD_IdleNotificationRequestDone;
    }

    idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
        IoGetCurrentIrpStackLocation(Irp)->\
            Parameters.DeviceIoControl.Type3InputBuffer;

    USBD_ASSERT(idleCallbackInfo && idleCallbackInfo->IdleCallback);

    if (!idleCallbackInfo || !idleCallbackInfo->IdleCallback) {

        IoReleaseCancelSpinLock(irql);

        Irp->IoStatus.Status = STATUS_NO_CALLBACK_ACTIVE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        ntStatus = STATUS_NO_CALLBACK_ACTIVE;
        goto USBD_IdleNotificationRequestDone;
    }

    DeviceExtension->IdleNotificationIrp = Irp;
    IoSetCancelRoutine(Irp, USBD_IdleNotificationCancelRoutine);

    IoReleaseCancelSpinLock(irql);

    //
    // Call the idle function now.
    //

    if (idleCallbackInfo && idleCallbackInfo->IdleCallback) {

        // Here we actually call the driver's callback routine,
        // telling the driver that it is OK to suspend their
        // device now.

        idleCallbackInfo->IdleCallback(idleCallbackInfo->IdleContext);
    }

USBD_IdleNotificationRequestDone:

    return ntStatus;
}


NTSTATUS
USBD_PdoDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PUSBD_EXTENSION DeviceExtension,
    PBOOLEAN IrpNeedsCompletion
    )
/*++

Routine Description:

    Disptach routine for Irps sent to the PDO for the root hub.

    NOTE:
        irps sent to the PDO are always completed by the bus driver

Arguments:

Return Value:

    None

--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;

    USBD_KdPrint(3, ("'enter USBD_PdoDispatch\n"));

    *IrpNeedsCompletion = FALSE;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MajorFunction) {
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        switch(irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_INTERNAL_USB_GET_HUB_COUNT:

            USBD_KdPrint(3, ("'IOCTL_INTERNAL_USB_GET_HUB_COUNT\n"));
            {
            PULONG count;
            //
            // bump the count and complete the Irp
            //
            count = irpStack->Parameters.Others.Argument1;

            ASSERT(count != NULL);
            (*count)++;
            ntStatus = STATUS_SUCCESS;
            }

            break;

        case IOCTL_INTERNAL_USB_GET_BUS_INFO:
            {
            PUSB_BUS_NOTIFICATION busInfo;

            USBD_KdPrint(0,
("'WARNING: Driver using obsolete IOCTL (IOCTL_INTERNAL_USB_GET_BUS_INFO) - get JD\n"));

            busInfo = irpStack->Parameters.Others.Argument1;

            // bw in bit times (bits/ms)
            busInfo->TotalBandwidth = 12000;

            busInfo->ConsumedBandwidth =
                DeviceExtension->HcdGetConsumedBW(
                    DeviceExtension->HcdDeviceObject);

            busInfo->ControllerNameLength =
                DeviceExtension->DeviceLinkUnicodeString.Length;

            }
            ntStatus = STATUS_SUCCESS;
            break;

        case IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME:

            {
            PUSB_HUB_NAME name;
            ULONG length;

            USBD_KdPrint(1, ("'IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME\n"));

            name = (PUSB_HUB_NAME) irpStack->Parameters.Others.Argument1;
            length = PtrToUlong( irpStack->Parameters.Others.Argument2 );

            USBD_KdPrint(1, ("'length = %d %x\n", length, &DeviceExtension->DeviceLinkUnicodeString));
            name->ActualLength = DeviceExtension->DeviceLinkUnicodeString.Length;
            if (length > DeviceExtension->DeviceLinkUnicodeString.Length) {
                length = DeviceExtension->DeviceLinkUnicodeString.Length;
            }
            RtlCopyMemory(&name->HubName[0],
                          &DeviceExtension->DeviceLinkUnicodeString.Buffer[0],
                          length);
            }
            ntStatus = STATUS_SUCCESS;

            break;

        case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:
            USBD_KdPrint(3, ("'IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO\n"));

            {
            PDEVICE_OBJECT *rootHubPdo, *hcdTopOfStackDeviceObject;
            rootHubPdo = irpStack->Parameters.Others.Argument1;
            hcdTopOfStackDeviceObject =
                irpStack->Parameters.Others.Argument2;

            ASSERT(hcdTopOfStackDeviceObject != NULL);
            ASSERT(rootHubPdo != NULL);

            *rootHubPdo = DeviceExtension->RootHubPDO;
            *hcdTopOfStackDeviceObject =
                DeviceExtension->HcdTopOfStackDeviceObject;

            ntStatus = STATUS_SUCCESS;
            }

            break;

       case IOCTL_INTERNAL_USB_GET_HUB_NAME:

            USBD_KdPrint(3, ("'IOCTL_INTERNAL_USB_GET_HUB_NAME\n"));
            ntStatus = USBD_GetHubName(DeviceExtension, Irp);
            break;

        case IOCTL_INTERNAL_USB_SUBMIT_URB:

            USBD_KdPrint(3,
                ("'IOCTL_INTERNAL_USB_SUBMIT_URB to root hub PDO\n"));


            // pass these along to the bus

            IoCopyCurrentIrpStackLocationToNext(Irp);
            ntStatus = IoCallDriver(DeviceExtension->HcdDeviceObject, Irp);

            // this is a special case -- we tell the HCD not to complete it
            // because he will see it agian passed to his FDO
            //
            // the only code to pass thru this case should be urb requests
            // submitted to the root hub.

            goto USBD_PdoDispatch_Done;

            break;

        case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:
            if (DeviceExtension->IsPIIX3or4 && !DeviceExtension->WakeSupported) {
                USBD_KdPrint(1, ("'Idle request, HC can NOT idle, fail.\n"));
                ntStatus = STATUS_NOT_SUPPORTED;
            } else {
                USBD_KdPrint(1, ("'Idle request, HC can idle.\n"));
                ntStatus = USBD_IdleNotificationRequest(DeviceExtension, Irp);
                goto USBD_PdoDispatch_Done;     // Don't complete the IRP.
            }
            break;

        default:

            ntStatus = STATUS_INVALID_PARAMETER;

            USBD_KdPrint(1,
                ("Warning: Invalid IRP_MJ_INTERNAL_DEVICE_CONTROL passed to USBD\n"));

        } // switch, ioControlCode

        break;

    case IRP_MJ_PNP:

        // thie function will complete request if needed

        ntStatus = USBD_PdoPnP(DeviceObject,
                               Irp,
                               DeviceExtension);

        goto USBD_PdoDispatch_Done;

        break;

    case IRP_MJ_POWER:

        // thie function will complete request if needed

        ntStatus = USBD_PdoPower(DeviceObject,
                                 Irp,
                                 DeviceExtension);

        goto USBD_PdoDispatch_Done;

        break;

    case IRP_MJ_SYSTEM_CONTROL:
        USBD_KdPrint(3, ("'HC PDO IRP_MJ_SYSTEM_CONTROL\n"));

    default:

        ntStatus = STATUS_NOT_SUPPORTED;

    } /* switch, irpStack->MajorFunction */


    Irp->IoStatus.Status = ntStatus;

    USBD_IoCompleteRequest (Irp,
                            IO_NO_INCREMENT);

USBD_PdoDispatch_Done:

    USBD_KdPrint(3, ("'exit USBD_PdoDispatch, ntStatus = %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_PnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    NTSTATUS irpStatus;
    PIO_STACK_LOCATION irpStack;
    PUSBD_EXTENSION deviceExtension;

    USBD_KdPrint(3, ("'enter USBD_PnPIrp_Complete\n"));

    deviceExtension = (PUSBD_EXTENSION) Context;

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    irpStatus = Irp->IoStatus.Status;

    USBD_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    USBD_ASSERT(irpStack->MinorFunction == IRP_MN_START_DEVICE);

    USBD_KdPrint(3, ("'IRP_MN_START_DEVICE (fdo), completion routine\n"));

    // signal the start device dispatch to finsh
    KeSetEvent(&deviceExtension->PnpStartEvent,
               1,
               FALSE);

    // defer completion
    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    USBD_KdPrint(3, ("'exit USBD_PnPIrp_Complete %x\n", irpStatus));

    return ntStatus;
}


NTSTATUS
USBD_FdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_EXTENSION DeviceExtension,
    IN PBOOLEAN IrpNeedsCompletion
    )
/*++

Routine Description:

    Process the Power IRPs sent to the FDO for the host controller.

    Power States for the USB host controller
        D0 - On.
        D1/D2 - Suspend.
        D3 - Off.

Arguments:

    DeviceObject - pointer to a hcd device object (FDO)

    Irp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{

    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN hookIt = FALSE;
    BOOLEAN biosHandback = FALSE;
    KIRQL irql;

    USBD_KdPrint(3, ("'HC FDO IRP_MJ_POWER\n"));

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    *IrpNeedsCompletion = FALSE;

    switch (irpStack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        USBD_KdPrint(3, ("'IRP_MN_WAIT_WAKE\n"));

        //
        // someone is enabling us for wakeup
        //

        // pass this on to our PDO
        goto USBD_FdoPowerPassIrp;
        break;

    case IRP_MN_SET_POWER:
        {

        switch (irpStack->Parameters.Power.Type) {
        case SystemPowerState:
            {
            POWER_STATE powerState;

            USBD_KdPrint(1,
(" IRP_MJ_POWER HC fdo(%x) MN_SET_POWER(SystemPowerState S%x)\n",
                DeviceObject, irpStack->Parameters.Power.State.SystemState - 1));

            switch (irpStack->Parameters.Power.State.SystemState) {
            case PowerSystemWorking:
                //
                // go to 'ON'
                //
                powerState.DeviceState = PowerDeviceD0;
                break;

            case PowerSystemShutdown:
                //
                // Shutdown -- if we need to hand contol back to HC
                // then we finish here
                //
                USBD_KdPrint(1, (" Shutdown HC Detected\n"));

                // flag should only be true if we
                // shutdown to DOS (ie Win98)

                ntStatus =
                    DeviceExtension->HcdSetDevicePowerState(
                        DeviceObject,
                        Irp,
                        0);

                biosHandback = TRUE;

                DeviceExtension->Flags |= USBDFLAG_HCD_SHUTDOWN;
                powerState.DeviceState = PowerDeviceD3;
                break;

            case PowerSystemHibernate:

                USBD_KdPrint(1, (" Hibernate HC Detected\n"));
                powerState.DeviceState = PowerDeviceD3;
                break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
                //
                // Let HCD know there is a suspend coming.
                //
                USBD_KdPrint(1, (" Suspend HC Detected\n"));

                ntStatus =
                    DeviceExtension->HcdSetDevicePowerState(
                        DeviceObject,
                        Irp,
                        0);

                // Fall through

            default:
                //
                // our policy is to enter D3 unless we are enabled for
                // remote wakeup
                //

                if (DeviceExtension->HcWakeFlags & HC_ENABLED_FOR_WAKEUP) {

                    SYSTEM_POWER_STATE requestedSystemState;

                    requestedSystemState =
                        irpStack->Parameters.Power.State.SystemState;

                    //
                    // based on the system power state
                    // request a setting to the appropriate
                    // Dx state.
                    //
                    powerState.DeviceState =
                        DeviceExtension->HcDeviceCapabilities.DeviceState[
                            requestedSystemState];

                    USBD_KdPrint(1, (" Requested HC State before fixup is S%x -> D%d\n",
                        requestedSystemState - 1,
                        powerState.DeviceState - 1));
                    //
                    // This table is created by PDO of the PCI driver and
                    // describes what the PCI driver can do for us.
                    // It is entirely possible that when the controller is in
                    // the D3 state that we can wake the system.
                    //
                    // It is also entirely possible that this table might not
                    // support a D state at the current S state.
                    //
                    // All of the usb children support a D state for every S
                    // state.  (We patched it up just that way when we gave
                    // the capablilities to our PDO child.  However, the host
                    // controller might not have one.  So if this is
                    // unsupported, then we need to change it do D3.
                    //
                    if (requestedSystemState > DeviceExtension->HcDeviceCapabilities.SystemWake &&
                        PowerDeviceUnspecified == powerState.DeviceState) {
                        powerState.DeviceState = PowerDeviceD3;
                    } else {
                        USBD_ASSERT(powerState.DeviceState != PowerDeviceUnspecified);
                    }

                } else {
                    //
                    // wakeup not enabled, just go in to the 'OFF' state.
                    //
                    USBD_KdPrint(1, ("HC not enabled for wakeup, goto D3.\n"));
                    powerState.DeviceState = PowerDeviceD3;
                }

            } //irpStack->Parameters.Power.State.SystemState

            USBD_KdPrint(1,
(" Requested HC State after fixup is D%d\n", powerState.DeviceState-1));

            //
            // are we already in this state?
            //

            //
            // Note: if we get a D3 request before we are started
            // we don't need to pass the irp down to turn us off
            // we consider the controller initially off until we
            // get start.
            //

            if (!biosHandback &&
                powerState.DeviceState !=
                DeviceExtension->HcCurrentDevicePowerState) {

                if (powerState.DeviceState == PowerDeviceD0) {

                    KeAcquireSpinLock(&DeviceExtension->WaitWakeSpin,
                                      &irql);

                    // see if we need to cancel a wake irp
                    // in the HC

                    if (DeviceExtension->HcWakeIrp) {
                        PIRP hcwakeirp;

                        hcwakeirp = DeviceExtension->HcWakeIrp;
                        KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                                          irql);

                        USBD_KdPrint(1, ("USBD_FdoPower, Set D0: Canceling Wake Irp (%x) on HC PDO\n", hcwakeirp));
                        IoCancelIrp(hcwakeirp);

                    } else {
                        KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                                          irql);
                    }
                }

                // No,
                // now allocate another irp and use PoCallDriver
                // to send it to ourselves
                IoMarkIrpPending(Irp);
                DeviceExtension->PowerIrp = Irp;

                USBD_KdPrint(1,
(" Requesting HC State is D%d\n", powerState.DeviceState-1));

                ntStatus =
                    PoRequestPowerIrp(DeviceExtension->
                                        HcdPhysicalDeviceObject,
                                      IRP_MN_SET_POWER,
                                      powerState,
                                      USBD_DeferPoRequestCompletion,
                                      DeviceExtension,
                                      NULL);
                USBD_KdPrint(3, ("'PoRequestPowerIrp returned %x\n",
                    ntStatus));

            } else {
                //
                // now complete the original request
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);

                ntStatus =
                    PoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                                 Irp);
            }

            }
            break;

        case DevicePowerState:
            USBD_KdPrint(1,
(" IRP_MJ_POWER HC fdo(%x) MN_SET_POWER(DevicePowerState D%x)\n",
                DeviceObject,
                irpStack->Parameters.Power.State.DeviceState - 1));

            //
            // Copy parameters now in case the HcdSetDevicePowerState
            // function sets a completion routine.
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);

            // If the HC is already in the requested power state
            // then don't call the HcdSetDevicePowerState function.

            // NOTE:
            // if the HC is not started the power state should be D3
            // we will ignore any requests from the OS to put
            // it in any other state

#if DBG
            if (!(DeviceExtension->Flags & USBDFLAG_HCD_STARTED) &&
                irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {
                USBD_KdPrint(1,
                    (" OS requesting to power up a STOPPED device\n"));

            }
#endif

            if (DeviceExtension->HcCurrentDevicePowerState !=
                irpStack->Parameters.Power.State.DeviceState &&
                (DeviceExtension->Flags & USBDFLAG_HCD_STARTED)) {

                ntStatus =
                    DeviceExtension->HcdSetDevicePowerState(
                        DeviceObject,
                        Irp,
                        irpStack->Parameters.Power.State.DeviceState);

                DeviceExtension->HcCurrentDevicePowerState =
                    irpStack->Parameters.Power.State.DeviceState;
            }

            PoStartNextPowerIrp(Irp);

            ntStatus =
                PoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                             Irp);
            break;
        } /* case irpStack->Parameters.Power.Type */

        }
        break; /* IRP_MN_SET_POWER */

    case IRP_MN_QUERY_POWER:

        USBD_KdPrint(1,
(" IRP_MJ_POWER HC fdo(%x) MN_QUERY_POWER\n",
            DeviceObject));

        // IrpAssert: Set IRP status before passing this IRP down.

        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // according to busdd QUERY_POWER messages are not
        // sent down the driver stack
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        ntStatus =
            PoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                         Irp);
        break; /* IRP_MN_QUERY_POWER */

    default:

USBD_FdoPowerPassIrp:

        USBD_KdPrint(1,
(" IRP_MJ_POWER fdo(%x) MN_%d\n",
                DeviceObject, irpStack->MinorFunction));

        //
        // All unhandled PnP messages are passed on to the PDO
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // All PNP_POWER POWER messages get passed to TopOfStackDeviceObject
        // and some are handled in the completion routine
        //

        // pass on to our PDO
        PoStartNextPowerIrp(Irp);
        ntStatus =
            PoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                         Irp);

    } /* irpStack->MinorFunction */

    USBD_KdPrint(3, ("'exit USBD_FdoPower 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_GetHubName(
    PUSBD_EXTENSION DeviceExtension,
    PIRP Irp
    )
{
    PUNICODE_STRING deviceNameUnicodeString;
    NTSTATUS status = STATUS_SUCCESS;
    PUSB_ROOT_HUB_NAME outputBuffer;
    ULONG outputBufferLength;
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    outputBufferLength =
        irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    outputBuffer = Irp->AssociatedIrp.SystemBuffer;

    deviceNameUnicodeString =
        &DeviceExtension->RootHubSymbolicLinkName;

    if (NT_SUCCESS(status)) {
        //
        // make sure there is enough room for the length,
        // string and the NULL
        //
        ULONG length, offset=0;
        WCHAR *pwch;

        // assuming the string is \n\name strip of '\n\' where
        // n is zero or more chars

        pwch = &deviceNameUnicodeString->Buffer[0];

        // Under NT, if the controller is banged out in DeviceManager,
        // this will be NULL.

        if (!pwch) {
            status = STATUS_UNSUCCESSFUL;
            goto USBD_GetHubNameExit;
        }

        USBD_ASSERT(*pwch == '\\');
        if (*pwch == '\\') {
            pwch++;
            while (*pwch != '\\' && *pwch) {
                pwch++;
            }
            USBD_ASSERT(*pwch == '\\');
            if (*pwch == '\\') {
                pwch++;
            }
            offset = (ULONG)((PUCHAR)pwch -
                (PUCHAR)&deviceNameUnicodeString->Buffer[0]);
        }

        length = deviceNameUnicodeString->Length - offset;
        RtlZeroMemory(outputBuffer, outputBufferLength);

        if (outputBufferLength >= length +
            sizeof(USB_ROOT_HUB_NAME)) {
            RtlCopyMemory(&outputBuffer->RootHubName[0],
                          &deviceNameUnicodeString->Buffer[offset/2],
                          length);

            Irp->IoStatus.Information = length+
                                        sizeof(USB_ROOT_HUB_NAME);
            outputBuffer->ActualLength = (ULONG)Irp->IoStatus.Information;
            status = STATUS_SUCCESS;

        } else {
            if (outputBufferLength >= sizeof(USB_ROOT_HUB_NAME)) {
                 outputBuffer->ActualLength =
                     length + sizeof(USB_ROOT_HUB_NAME);
                Irp->IoStatus.Information =
                    sizeof(ULONG);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }

USBD_GetHubNameExit:

    return status;
}


#ifdef DRM_SUPPORT


/*****************************************************************************
 * USBC_FdoSetContentId
 *****************************************************************************
 *
 */
NTSTATUS
USBD_FdoSetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
{
    USBD_PIPE_HANDLE hPipe;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    status = STATUS_SUCCESS;

    hPipe = pKsProperty->Context;
    // ContentId = pvData->ContentId;

    ASSERT(USBD_ValidatePipe(hPipe));

    // If this driver sents content anywhere, then it should advise DRM.  E.g.:
    // status = pKsProperty->DrmForwardContentToDeviceObject(ContentId, DeviceObject, Context);

    return status;
}

#endif


NTSTATUS
USBD_FdoDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PUSBD_EXTENSION DeviceExtension,
    PBOOLEAN IrpNeedsCompletion
    )
/*++

Routine Description:

    Disptach routine for Irps sent to the FDO for the host controller.  some
    Irps re handled by USBD, most are handled by the host controller driver.

Arguments:

Return Value:

    None

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_RELATIONS DeviceRelations = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    KIRQL irql;

    USBD_KdPrint(3, ("'enter USBD_FdoDispatch\n"));

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MajorFunction) {
    case IRP_MJ_DEVICE_CONTROL:

        USBD_KdPrint(3, ("'IRP_MJ_DEVICE_CONTROL\n"));
        switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {


#ifdef DRM_SUPPORT

        case IOCTL_KS_PROPERTY:
            USBD_KdPrint(1, ("'IOCTL_KS_PROPERTY\n"));
            ntStatus = KsPropertyHandleDrmSetContentId(Irp, USBD_FdoSetContentId);
            Irp->IoStatus.Status = ntStatus;
            if (NT_SUCCESS(ntStatus) || (STATUS_PROPSET_NOT_FOUND == ntStatus))  {
                *IrpNeedsCompletion = TRUE;
            } else {
                *IrpNeedsCompletion = FALSE;
                USBD_IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            break;
#endif

        case IOCTL_USB_DIAGNOSTIC_MODE_ON:
            DeviceExtension->DiagnosticMode = TRUE;
            *IrpNeedsCompletion = FALSE;
            USBD_KdPrint(1, ("'IOCTL_USB_DIAGNOSTIC_MODE_ON\n"));
            ntStatus =
                Irp->IoStatus.Status = STATUS_SUCCESS;
            USBD_IoCompleteRequest (Irp,
                                    IO_NO_INCREMENT);
            break;

        case IOCTL_USB_DIAGNOSTIC_MODE_OFF:
            DeviceExtension->DiagnosticMode = FALSE;
            *IrpNeedsCompletion = FALSE;
            USBD_KdPrint(1, ("'IOCTL_USB_DIAGNOSTIC_MODE_OFF\n"));
            ntStatus =
                Irp->IoStatus.Status = STATUS_SUCCESS;
            USBD_IoCompleteRequest (Irp,
                                    IO_NO_INCREMENT);
            break;

        case IOCTL_USB_DIAG_IGNORE_HUBS_ON:
            DeviceExtension->DiagIgnoreHubs = TRUE;
            *IrpNeedsCompletion = FALSE;
            USBD_KdPrint(1, ("'IOCTL_USB_DIAG_IGNORE_HUBS_ON\n"));
            ntStatus =
                Irp->IoStatus.Status = STATUS_SUCCESS;
            USBD_IoCompleteRequest (Irp,
                                    IO_NO_INCREMENT);
            break;
        case IOCTL_USB_DIAG_IGNORE_HUBS_OFF:
            DeviceExtension->DiagIgnoreHubs = FALSE;
            *IrpNeedsCompletion = FALSE;
            USBD_KdPrint(1, ("'IOCTL_USB_DIAG_IGNORE_HUBS_OFF\n"));
            ntStatus =
                Irp->IoStatus.Status = STATUS_SUCCESS;
            USBD_IoCompleteRequest (Irp,
                                    IO_NO_INCREMENT);
            break;

        case IOCTL_GET_HCD_DRIVERKEY_NAME:


            *IrpNeedsCompletion  = FALSE;
            USBD_KdPrint(3, ("'IOCTL_GET_HCD_DRIVERKEY_NAME\n"));
            {
            PIO_STACK_LOCATION ioStack;
            PUSB_HCD_DRIVERKEY_NAME outputBuffer;
            ULONG outputBufferLength, length;
            ULONG adjustedDriverKeyNameSize;

            //
            // Get a pointer to the current location in the Irp. This is where
            // the function codes and parameters are located.
            //

            ioStack = IoGetCurrentIrpStackLocation(Irp);

            //
            // Get the pointer to the input/output buffer and it's length
            //

            outputBufferLength = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
            outputBuffer = (PUSB_HCD_DRIVERKEY_NAME) Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Information = 0x0;

            // find the PDO
            if (outputBufferLength >= sizeof(USB_HCD_DRIVERKEY_NAME)) {

                // we have the PDO, now attempt to
                // get the devnode name and return it

                // the size of the buffer up to, but not including, the
                // DriverKeyName field
                adjustedDriverKeyNameSize =
                    sizeof(USB_HCD_DRIVERKEY_NAME) - 
                    sizeof(outputBuffer->DriverKeyName);

                length = outputBufferLength - adjustedDriverKeyNameSize;

                ntStatus = IoGetDeviceProperty(
                    DeviceExtension->HcdPhysicalDeviceObject,
                    DevicePropertyDriverKeyName,
                    length, 
                    outputBuffer->DriverKeyName,
                    &length);

                outputBuffer->ActualLength =
                    length + adjustedDriverKeyNameSize;

                if (NT_SUCCESS(ntStatus)) {
    
                    // fill in information field with the length actually copied
                    if (outputBuffer->ActualLength > outputBufferLength) {
                        // we just copied as much as we could
                        Irp->IoStatus.Information = outputBufferLength;
                    } else {
                        // user buffer contains the whole thing
                        Irp->IoStatus.Information = outputBuffer->ActualLength;
                    }
                }
                else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                    ntStatus = STATUS_SUCCESS;

                    outputBuffer->DriverKeyName[0] = L'\0';
                    Irp->IoStatus.Information = sizeof(USB_HCD_DRIVERKEY_NAME);  
                }
                else {
                    // propagate the ntStatus value up
                    ;
                }

            } else {
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }

            Irp->IoStatus.Status = ntStatus;
            USBD_IoCompleteRequest (Irp,
                                    IO_NO_INCREMENT);
            }

            break;

        case IOCTL_USB_GET_ROOT_HUB_NAME:

            *IrpNeedsCompletion  = FALSE;
            USBD_KdPrint(3, ("'IOCTL_USB_GET_ROOT_HUB_NAME\n"));

            ntStatus =
                Irp->IoStatus.Status = USBD_GetHubName(DeviceExtension, Irp);
            USBD_IoCompleteRequest (Irp,
                                    IO_NO_INCREMENT);
            break;

        default:

            USBD_KdPrint(3, ("'USBD not handling ioctl\n"));
            ntStatus = Irp->IoStatus.Status;
            *IrpNeedsCompletion = TRUE;

        } // switch (irpStack->Parameters.DeviceIoControl.IoControlCode)

        break; // IRP_MJ_DEVICE_CONTROL

    case IRP_MJ_SYSTEM_CONTROL:
        *IrpNeedsCompletion  = FALSE;
        USBD_KdPrint(3, ("'IRP_MJ_SYSTEM_CONTROL\n"));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        ntStatus = IoCallDriver(
            DeviceExtension->HcdTopOfPdoStackDeviceObject,
            Irp);
        break; // IRP_MJ_DEVICE_CONTROL

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        switch(irpStack->Parameters.DeviceIoControl.IoControlCode) {

        //
        // This is where USBD pre-processes urbs passed to the
        // host controller
        //

        case IOCTL_INTERNAL_USB_SUBMIT_URB:

            USBD_KdPrint(3, ("'IOCTL_INTERNAL_USB_SUBMIT_URB\n"));

            urb = irpStack->Parameters.Others.Argument1;

            // The URB handler will mark the IRP pending if it
            // has to pass it on, otherwise, we complete it here
            // with the appropriate error

            // a quick check of the function code will tell us if
            // the urb if for HCD only
            if ((urb->UrbHeader.Function & HCD_URB_FUNCTION) ||
                (urb->UrbHeader.Function & HCD_NO_USBD_CALL)) {
                // This is an HCD command, clear the renter bit
                urb->UrbHeader.Function &= ~HCD_NO_USBD_CALL;
                *IrpNeedsCompletion = TRUE;
            } else {
                ntStatus = USBD_ProcessURB(DeviceObject,
                                           Irp,
                                           urb,
                                           IrpNeedsCompletion);

                if (*IrpNeedsCompletion && NT_ERROR(ntStatus)) {
                    // the irp is marked pending
                    // but we have an error, reset
                    // the pending flag here so the HCD does
                    // not have to deal with this request
                    USBD_KdBreak(("Failing URB Request\n"));
                    *IrpNeedsCompletion = FALSE;
                }
            }

            if (!*IrpNeedsCompletion) {
                // USBD needs to complete the irp.

                USBD_KdPrint(3, ("'USBD Completeing URB\n"));

                Irp->IoStatus.Status = ntStatus;
                USBD_IoCompleteRequest (Irp,
                                        IO_NO_INCREMENT);
            }

            break;

        case IOCTL_INTERNAL_USB_GET_BUSGUID_INFO:
            {
            // return the standard USB GUID
            PPNP_BUS_INFORMATION busInfo;

            *IrpNeedsCompletion  = FALSE;
            USBD_KdPrint(3, ("'IOCTL_INTERNAL_USB_GET_BUSGUID_INFO\n"));

            busInfo = ExAllocatePoolWithTag(PagedPool,
                                            sizeof(PNP_BUS_INFORMATION),
                                            USBD_TAG);

            if (busInfo == NULL) {
               ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                busInfo->BusTypeGuid = GUID_BUS_TYPE_USB;
                busInfo->LegacyBusType = PNPBus;
                busInfo->BusNumber = 0;
                Irp->IoStatus.Information = (ULONG_PTR) busInfo;
                ntStatus = STATUS_SUCCESS;
            }


            USBD_IoCompleteRequest (Irp,
                                    IO_NO_INCREMENT);
            }
            break;

        default:

            USBD_KdPrint(3, ("'USBD not handling internal ioctl\n"));
            ntStatus = Irp->IoStatus.Status;
            *IrpNeedsCompletion = TRUE;

        } // switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
        break; // IRP_MJ_INTERNAL_DEVICE_CONTROL

    case IRP_MJ_PNP:

        switch (irpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            // pass on to host controllers PDO
            *IrpNeedsCompletion = FALSE;
            IoCopyCurrentIrpStackLocationToNext(Irp);
            ntStatus =
                IoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                             Irp);
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            {
            PDEVICE_OBJECT deviceObject;

            USBD_KdPrint(1,
            (" IRP_MN_QUERY_DEVICE_RELATIONS %x %x\n",
                DeviceObject,
                irpStack->Parameters.QueryDeviceRelations.Type));

            ntStatus = STATUS_SUCCESS;

            switch(irpStack->Parameters.QueryDeviceRelations.Type) {
            case BusRelations:

                // Don't use GETHEAP since OS will free and doesn't know about
                // the trick GETHEAP does.
                DeviceRelations=ExAllocatePoolWithTag(PagedPool,
                                                      sizeof(*DeviceRelations),
                                                      USBD_TAG);
                if (!DeviceRelations) {
                    ntStatus=STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                if (!DeviceExtension->RootHubPDO) {
                    PUSBD_EXTENSION pdoDeviceExtension;
                    ULONG index = 0;
                    UNICODE_STRING rootHubPdoUnicodeString;

                    do {
                        ntStatus =
                            USBD_InternalMakePdoName(&rootHubPdoUnicodeString,
                                                     index);

                        if (NT_SUCCESS(ntStatus)) {
                            ntStatus =
                                IoCreateDevice(DeviceExtension->DriverObject,
                                               sizeof(PVOID),
                                               &rootHubPdoUnicodeString,
                                               FILE_DEVICE_BUS_EXTENDER,
                                               0,
                                               FALSE,
                                               &deviceObject);

                            if (!NT_SUCCESS(ntStatus)) {
                                RtlFreeUnicodeString(&rootHubPdoUnicodeString);
                            }
                            index++;
                        }

                    } while (ntStatus == STATUS_OBJECT_NAME_COLLISION);

                    //
                    // now create the root hub device and symbolic link
                    //

                    if (NT_SUCCESS(ntStatus)) {

                        deviceObject->Flags |= DO_POWER_PAGABLE;
                        pdoDeviceExtension = deviceObject->DeviceExtension;
                        DeviceExtension->RootHubPDO = deviceObject;
                        RtlFreeUnicodeString(&rootHubPdoUnicodeString);

                        USBD_KdPrint(3, ("'Create Root Hub stacksize = %d\n",
                            DeviceObject->StackSize));
                        deviceObject->StackSize = DeviceObject->StackSize;
                        pdoDeviceExtension->TrueDeviceExtension
                                = DeviceExtension;
                        pdoDeviceExtension->Flags = 0;

                        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

                        ntStatus = STATUS_SUCCESS;
                    } else {

                        //
                        // failing to create the root hub
                        //
                        TEST_TRAP();
                        if (DeviceRelations) {
                            RETHEAP(DeviceRelations);
                        }
                        break;
                    }
                }

                //
                // We support only one device (the root hub).
                //
                DeviceRelations->Count=1;
                DeviceRelations->Objects[0]=DeviceExtension->RootHubPDO;
                ObReferenceObject(DeviceExtension->RootHubPDO);
                Irp->IoStatus.Information=(ULONG_PTR)DeviceRelations;

                *IrpNeedsCompletion = FALSE;
                Irp->IoStatus.Status = ntStatus;

                USBD_KdPrint(1,
                (" IRP_MN_QUERY_DEVICE_RELATIONS %x pass on %x\n",
                    DeviceObject,
                    irpStack->Parameters.QueryDeviceRelations.Type));

                // pass it on
                IoCopyCurrentIrpStackLocationToNext(Irp);
                ntStatus =
                    IoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                                 Irp);
                break;

            case TargetDeviceRelation:
                //
                // this one gets passed on
                //

                USBD_KdPrint(1,
(" IRP_MN_QUERY_DEVICE_RELATIONS %x, TargetDeviceRelation\n",
                    DeviceObject));
                // this PnP irp not handled by us
                ntStatus = Irp->IoStatus.Status;
                *IrpNeedsCompletion = TRUE;
                break;

            default:
                //
                // some other kind of relations
                // pass this on
                //
                USBD_KdPrint(1,
(" IRP_MN_QUERY_DEVICE_RELATIONS %x, other relations\n",
                    DeviceObject));

                *IrpNeedsCompletion = FALSE;
                // pass it on
                IoCopyCurrentIrpStackLocationToNext(Irp);
                ntStatus =
                    IoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                                 Irp);

            } /* case irpStack->Parameters.QueryDeviceRelations.Type */

            }
            break;

        case IRP_MN_START_DEVICE:
            {
            USBD_KdPrint(3, ("'IRP_MN_START_DEVICE (fdo)\n"));

            *IrpNeedsCompletion = FALSE;

            KeInitializeEvent(&DeviceExtension->PnpStartEvent,
                              NotificationEvent,
                              FALSE);

            USBD_KdPrint(3, ("'Set PnPIrp Completion Routine\n"));
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   USBD_PnPIrp_Complete,
                                   // always pass FDO to completeion routine
                                   DeviceExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            // pass on to host controllers PDO
            ntStatus =
                IoCallDriver(DeviceExtension->HcdTopOfPdoStackDeviceObject,
                             Irp);


            if (ntStatus == STATUS_PENDING) {

                KeWaitForSingleObject(
                           &DeviceExtension->PnpStartEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           NULL);

                ntStatus = Irp->IoStatus.Status;
            }

            if (NT_SUCCESS(ntStatus)) {
                //
                // irp completed by owner of PDO now start the HC
                //

                ntStatus =
                    DeviceExtension->HcdDeferredStartDevice(
                        DeviceExtension->HcdDeviceObject,
                        Irp);

                // HC is now 'ON'
                if (NT_SUCCESS(ntStatus)) {
                    DeviceExtension->HcCurrentDevicePowerState = PowerDeviceD0;
                    DeviceExtension->Flags |=USBDFLAG_HCD_STARTED;
                }

            }
#if DBG
              else {
               USBD_KdPrint(1,
(" Warning: Controller failed to start %x\n", ntStatus));
            }
#endif

            //
            // we must complete this irp since we defrerred completion
            // with the completion routine.

            USBD_IoCompleteRequest(Irp,
                                   IO_NO_INCREMENT);

            }
            break;

// Ken says take this out
//        case IRP_MN_SURPRISE_REMOVAL:
//            TEST_TRAP();
        case IRP_MN_REMOVE_DEVICE:
            USBD_KdPrint(3,
                ("'IRP_MN_REMOVE_DEVICE (fdo), remove HCD sym link\n"));
            if (DeviceExtension->DeviceLinkUnicodeString.Buffer) {
                IoDeleteSymbolicLink(
                    &DeviceExtension->DeviceLinkUnicodeString);
                RtlFreeUnicodeString(&DeviceExtension->DeviceLinkUnicodeString);
                DeviceExtension->DeviceLinkUnicodeString.Buffer = NULL;
            }

            USBD_KdPrint(1,
                ("'IRP_MN_REMOVE_DEVICE (fdo), remove root hub PDO\n"));

            // note: we may not have a root hub PDO when we
            // get created
            if (DeviceExtension->RootHubPDO != NULL) {
                USBD_KdPrint(1,
                    ("'Deleting root hub PDO now.\n"));
                IoDeleteDevice(DeviceExtension->RootHubPDO);
            }
            DeviceExtension->RootHubPDO = NULL;

            // Fall through

        case IRP_MN_QUERY_CAPABILITIES:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
            //
            // we do the default handling of the in USBD, that is
            // return success.
            // irpAssert expects these to be set to STATUS_SUCCESS
            //
            // note: these may also be handled by HC
            // and HCD will pass the irp down to the PDO
            //
            ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
            *IrpNeedsCompletion = TRUE;
            break;

        case IRP_MN_STOP_DEVICE:

            USBD_KdPrint(1,
                ("'IRP_MN_STOP_DEVICE (fdo)\n"));

            KeAcquireSpinLock(&DeviceExtension->WaitWakeSpin,
                              &irql);

            // see if we need to cancel a wake irp
            // in the HC

            if (DeviceExtension->HcWakeIrp) {
                PIRP hcwakeirp;

                hcwakeirp = DeviceExtension->HcWakeIrp;
                KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                                  irql);

                USBD_KdPrint(1, ("USBD_FdoDispatch, MN_STOP: Canceling Wake Irp (%x) on HC PDO\n", hcwakeirp));
                IoCancelIrp(hcwakeirp);

            } else {
                KeReleaseSpinLock(&DeviceExtension->WaitWakeSpin,
                                  irql);
            }

            // note: HCD will pass the irp down to the PDO
            ntStatus = Irp->IoStatus.Status;
            *IrpNeedsCompletion = TRUE;
            break;

        default:
            // PnP **
            // message not handled, rule is that the
            // status in the irp is not touched

            //
            // note: HCD will pass the irp down to the PDO
            ntStatus = Irp->IoStatus.Status;
            *IrpNeedsCompletion = TRUE;

        } // switch (irpStack->MinorFunction)
        break; // IRP_MJ_PNP

    case IRP_MJ_POWER:

        ntStatus = USBD_FdoPower(DeviceObject,
                                 Irp,
                                 DeviceExtension,
                                 IrpNeedsCompletion);
        break; // IRP_MJ_POWER

    default:
        //
        // HCD irp not handled here
        //
        ntStatus = Irp->IoStatus.Status;
        *IrpNeedsCompletion = TRUE;
    } // switch (irpStack->MajorFunction)

    return ntStatus;
}



VOID
USBD_CompleteRequest(
    PIRP Irp,
    CCHAR PriorityBoost
    )
/*++

Routine Description:

    Entry point called by HCD to complete an Irp.

Arguments:

Return Value:

    NT status code.

--*/
{
    PURB urb;
    NTSTATUS ntStatus;
//    USHORT function;
    PHCD_URB hcdUrb;
    PIO_STACK_LOCATION irpStack;


    USBD_KdPrint(3, ("' enter USBD_CompleteRequest irp = %x\n", Irp));

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    if (irpStack->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL) {
        goto USBD_CompleteRequest_Done;
    }

    urb = URB_FROM_IRP(Irp);
    hcdUrb = (PHCD_URB) urb;

    //
    // Free any resources we allocated to handle this URB
    //

    while (hcdUrb) {

        if (hcdUrb->UrbHeader.UsbdFlags & USBD_REQUEST_MDL_ALLOCATED) {
            USBD_ASSERT(hcdUrb->HcdUrbCommonTransfer.TransferBufferMDL !=
                        NULL);
            IoFreeMdl(hcdUrb->HcdUrbCommonTransfer.TransferBufferMDL);
        }

        if (hcdUrb->UrbHeader.UsbdFlags & USBD_REQUEST_IS_TRANSFER) {
            hcdUrb = hcdUrb->HcdUrbCommonTransfer.UrbLink;
        } else {
            // only have linkage if this is a transfer.
            break;
        }
    }

    //
    // If the irp completed with no error code but the URB has an
    // error, map the error in the urb to an NT error code in the irp
    // before the irp is completed.
    //

    // pass original status to USBD_MapError
    ntStatus = Irp->IoStatus.Status;

    // ntStatus now set to new 'mapped' error code
    ntStatus = Irp->IoStatus.Status =
        USBD_MapError_UrbToNT(urb, ntStatus);

    USBD_KdPrint(3,
    ("' exit USBD_CompleteRequest URB STATUS = (0x%x)  NT STATUS = (0x%x)\n",
            urb->UrbHeader.Status, ntStatus));

USBD_CompleteRequest_Done:

    USBD_IoCompleteRequest (Irp,
                            PriorityBoost);

    return;
}


#if 0
__declspec(dllexport)
PUSBD_INTETRFACE_INFORMATION
USBD_GetInterfaceInformation(
    IN PURB Urb,
    IN UCHAR InterfaceNumber
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSB_INTERFACE_INFORMATION foundInterface = NULL;
    PUCHAR pch;

    pch = &Urb->UrbSelectConfiguration.Interface;

    while (pch - (PUCHAR)urb < Urb->SelectConfiguration.Length) {
        interface = (PUSBD_INTERFACE_INFORMATION) pch;

        if (interface->InterfaceNumber == InterfaceNumber) {
            foundInterface = interface;
        }

        pch += interface->Length;
    }

    return foundInterface;
}
#endif

VOID
USBD_WaitDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    )
/*++

Routine Description:

Arguments:

Return Value:

    interface descriptor or NULL.

--*/
{
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    deviceExtension = GET_DEVICE_EXTENSION(RootHubPDO);

    USBD_WaitForUsbDeviceMutex(deviceExtension);

}


VOID
USBD_FreeDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    )
/*++

Routine Description:

Arguments:

Return Value:

    interface descriptor or NULL.

--*/
{

    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    deviceExtension = GET_DEVICE_EXTENSION(RootHubPDO);

    USBD_ReleaseUsbDeviceMutex(deviceExtension);
}


//
// these apis are used to support the proprietary OEM
// no power suspend mode. (IBM APTIVA)
//

DEVICE_POWER_STATE
USBD_GetSuspendPowerState(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBD_EXTENSION deviceExtension;

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    return deviceExtension->SuspendPowerState;
}


VOID
USBD_SetSuspendPowerState(
    PDEVICE_OBJECT DeviceObject,
    DEVICE_POWER_STATE SuspendPowerState
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBD_EXTENSION deviceExtension;

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    deviceExtension->SuspendPowerState =
        SuspendPowerState;
}


VOID
USBD_RegisterHcFilter(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT FilterDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBD_EXTENSION deviceExtension;

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    deviceExtension->HcdTopOfStackDeviceObject = FilterDeviceObject;
}


VOID
USBD_RegisterHcDeviceCapabilities(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_CAPABILITIES DeviceCapabilities,
    ROOT_HUB_POWER_FUNCTION *RootHubPower
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBD_EXTENSION deviceExtension;
    LONG i;
    PDEVICE_CAPABILITIES rhDeviceCapabilities;
    PDEVICE_CAPABILITIES hcDeviceCapabilities;
    BOOLEAN bWakeSupported = FALSE;

    deviceExtension = GET_DEVICE_EXTENSION(DeviceObject);

    deviceExtension->RootHubPower = RootHubPower;

    //
    // HcDeviceCapabilities are set by the PDO below us and are unchanageable.
    // RootHubDeviceCapabilities are howver set by us to describe the power
    // properties of the root hub, and should therefore be set appropriately,
    // but based on the power properities of our parent.
    //
    deviceExtension->RootHubDeviceCapabilities =
        deviceExtension->HcDeviceCapabilities = *DeviceCapabilities;

    rhDeviceCapabilities = &deviceExtension->RootHubDeviceCapabilities;
    hcDeviceCapabilities = &deviceExtension->HcDeviceCapabilities;

    //
    // We can wake any device in on the USB bus so long as it is of D2 or better.
    //
    rhDeviceCapabilities->DeviceWake = PowerDeviceD2;
    rhDeviceCapabilities->WakeFromD2 = TRUE;
    rhDeviceCapabilities->WakeFromD1 = TRUE;
    rhDeviceCapabilities->WakeFromD0 = TRUE;
    rhDeviceCapabilities->DeviceD2 = TRUE;
    rhDeviceCapabilities->DeviceD1 = TRUE;

    //
    // We cannot wake the system for any system sleeping state deeper than that
    // of RootHubDeviceCapabilites->SystemWake, but if this value is
    // unspecified, then we can set it to Working.
    //
    USBD_ASSERT(rhDeviceCapabilities->SystemWake >= PowerSystemUnspecified &&
                rhDeviceCapabilities->SystemWake <= PowerSystemMaximum);

    rhDeviceCapabilities->SystemWake =
        (PowerSystemUnspecified == rhDeviceCapabilities->SystemWake) ?
        PowerSystemWorking :
        rhDeviceCapabilities->SystemWake;

    rhDeviceCapabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;

    //
    // For all values between PowerSystemSleeping1 and rhDeviceCaps->SystemWake
    // we need to modify the power table.
    //
    // As long as we have power to the host controller we can give power to
    // our children devices.
    //
    for (i=PowerSystemSleeping1; i < PowerSystemMaximum; i++) {

        if (i > rhDeviceCapabilities->SystemWake) {
            //
            // For values above rhDeviceCaps->SystemWake, even our host controller
            // should be set to D3.
            //
            if (PowerDeviceUnspecified == rhDeviceCapabilities->DeviceState[i]) {
                rhDeviceCapabilities->DeviceState[i] = PowerDeviceD3;
            }

            // We know that for the host controller (or more correctly, the USB
            // bus), D3 is not necessarily "OFF".  If DeviceWake for the host
            // controller is greater than or equal to D3, then we know that the
            // USB bus has power at D3.  Since most of the USB stack assumes
            // that D3 == "OFF", we don't want to allow it to go to a lower
            // power level than D2 if the USB bus will still have power at D3.
            // We do this by setting the root hub's device state to D2 in this
            // case.

            if (rhDeviceCapabilities->DeviceState[i] == PowerDeviceD3 &&
                rhDeviceCapabilities->DeviceState[i] <= hcDeviceCapabilities->DeviceWake) {

                rhDeviceCapabilities->DeviceState[i] = PowerDeviceD2;
            }

        } else {
            //
            // We have some power so we can support low power on our bus
            //
            rhDeviceCapabilities->DeviceState[i] = PowerDeviceD2;
        }

    }

#if DBG
    USBD_KdPrint(1, (" >>>>>> RH DeviceCaps\n"));
    USBD_KdPrint(1, (" SystemWake = (%d)\n", rhDeviceCapabilities->SystemWake));
    USBD_KdPrint(1, (" DeviceWake = (D%d)\n",
        rhDeviceCapabilities->DeviceWake-1));

    for (i=PowerSystemUnspecified; i< PowerSystemHibernate; i++) {

        USBD_KdPrint(1, (" Device State Map: sysstate %d = devstate 0x%x\n", i,
             rhDeviceCapabilities->DeviceState[i]));
    }
    USBD_KdBreak(("'>>>>>> RH DeviceCaps\n"));

    USBD_KdPrint(1, (" >>>>>> HC DeviceCaps\n"));
    USBD_KdPrint(1, (" SystemWake = (%d)\n", hcDeviceCapabilities->SystemWake));
    USBD_KdPrint(1, (" DeviceWake = (D%d)\n",
        hcDeviceCapabilities->DeviceWake-1));

    for (i=PowerSystemUnspecified; i< PowerSystemHibernate; i++) {

        USBD_KdPrint(1, ("'Device State Map: sysstate %d = devstate 0x%x\n", i,
             hcDeviceCapabilities->DeviceState[i]));
    }
    USBD_KdBreak((" >>>>>> HC DeviceCaps\n"));

#endif

    // Spit out message on the debugger indicating whether the HC and RH
    // will support wake, according to the mapping tables.

    USBD_KdPrint(1, (" \n\tWake support summary for HC:\n\n"));

    if (hcDeviceCapabilities->SystemWake <= PowerSystemWorking) {
        USBD_KdPrint(1, (" USB controller can't wake machine because SystemWake does not support it.\n"));
    } else {
        for (i = PowerSystemSleeping1, bWakeSupported = FALSE; i <= hcDeviceCapabilities->SystemWake; i++) {
            if (hcDeviceCapabilities->DeviceState[i] != PowerDeviceUnspecified &&
                hcDeviceCapabilities->DeviceState[i] <= hcDeviceCapabilities->DeviceWake) {

                bWakeSupported = TRUE;
                USBD_KdPrint(1, (" USB controller can wake machine from S%x (maps to D%x).\n",
                    i - 1, hcDeviceCapabilities->DeviceState[i] - 1));
            }
        }

        if (!bWakeSupported) {
            USBD_KdPrint(1, (" USB controller can't wake machine because DeviceState table does not support it.\n"));
        }
    }

    deviceExtension->WakeSupported = bWakeSupported;

    USBD_KdPrint(1, (" Low System Power states mapped to USB suspend\n"));

}

NTSTATUS
USBD_InternalMakePdoName(
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    )
/*++

Routine Description:

    This service Creates a name for a PDO created by the HUB

Arguments:

Return Value:


--*/
{
    PWCHAR nameBuffer = NULL;
    WCHAR rootName[] = L"\\Device\\USBPDO-";
    UNICODE_STRING idUnicodeString;
    WCHAR buffer[32];
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT length;

    length = sizeof(buffer)+sizeof(rootName);

    //
    // use ExAllocate because client will free it
    //
    nameBuffer = ExAllocatePoolWithTag(PagedPool, length, USBD_TAG);

    if (nameBuffer) {
        RtlCopyMemory(nameBuffer, rootName, sizeof(rootName));

        RtlInitUnicodeString(PdoNameUnicodeString,
                             nameBuffer);
        PdoNameUnicodeString->MaximumLength =
            length;

        RtlInitUnicodeString(&idUnicodeString,
                             &buffer[0]);
        idUnicodeString.MaximumLength =
            sizeof(buffer);

        ntStatus = RtlIntegerToUnicodeString(
                  Index,
                  10,
                  &idUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
             ntStatus = RtlAppendUnicodeStringToString(PdoNameUnicodeString,
                                                       &idUnicodeString);
        }

        USBD_KdPrint(3, ("'USBD_MakeNodeName string = %x\n",
            PdoNameUnicodeString));

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus) && nameBuffer) {
        ExFreePool(nameBuffer);
    }

    return ntStatus;
}

NTSTATUS
USBD_MakePdoName(
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    return USBD_InternalMakePdoName(PdoNameUnicodeString, Index);
}


NTSTATUS
USBD_SymbolicLink(
    BOOLEAN CreateFlag,
    PUSBD_EXTENSION DeviceExtension
    )
{
    NTSTATUS ntStatus;


    if (CreateFlag){

        if (!DeviceExtension->RootHubPDO) {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        } else{
            /*
             *  Create the symbolic link
             */
            ntStatus = IoRegisterDeviceInterface(
                        DeviceExtension->RootHubPDO,
                        (LPGUID)&GUID_CLASS_USBHUB,
                        NULL,
                        &DeviceExtension->RootHubSymbolicLinkName);
        }

        if (NT_SUCCESS(ntStatus)) {

            /*
             *  Now set the symbolic link for the association and store it..
             */
            //ASSERT(ISPTR(pdoExt->name));

            //
            // (lonnym): Previously, the following call was being
            // made with &DeviceExtension->RootHubPdoName passed as the
            // second parameter.
            // Code review this change, to see whether or not you still need
            // to keep this information around.
            //

            // write the symbolic name to the registry
            {
                WCHAR hubNameKey[] = L"SymbolicName";

                USBD_SetPdoRegistryParameter (
                    DeviceExtension->RootHubPDO,
                    &hubNameKey[0],
                    sizeof(hubNameKey),
                    &DeviceExtension->RootHubSymbolicLinkName.Buffer[0],
                    DeviceExtension->RootHubSymbolicLinkName.Length,
                    REG_SZ,
                    PLUGPLAY_REGKEY_DEVICE);
            }

            ntStatus =
                IoSetDeviceInterfaceState(
                    &DeviceExtension->RootHubSymbolicLinkName, TRUE);
        }
    } else {

        /*
         *  Disable the symbolic link
         */
        ntStatus = IoSetDeviceInterfaceState(
                    &DeviceExtension->RootHubSymbolicLinkName, FALSE);
        ExFreePool(DeviceExtension->RootHubSymbolicLinkName.Buffer);
        DeviceExtension->RootHubSymbolicLinkName.Buffer = NULL;
    }

    return ntStatus;
}


NTSTATUS
USBD_RestoreDeviceX(
    IN OUT PUSBD_DEVICE_DATA OldDeviceData,
    IN OUT PUSBD_DEVICE_DATA NewDeviceData,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Our goal here is to re-create the device and restore the configuration.

Arguments:

Return Value:

    NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_CONFIG configHandle;
    USBD_STATUS usbdStatus;

    USBD_KdPrint(3, ("'enter USBD_RestoreDevice \n"));

    if (OldDeviceData == NULL ||
        NewDeviceData == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    configHandle = OldDeviceData->ConfigurationHandle;

    if (RtlCompareMemory(&NewDeviceData->DeviceDescriptor,
                         &OldDeviceData->DeviceDescriptor,
                         sizeof(OldDeviceData->DeviceDescriptor)) ==
                         sizeof(OldDeviceData->DeviceDescriptor)) {

        NewDeviceData->ConfigurationHandle = configHandle;

        //
        // all the config and interface information is still valid,
        // we just need to restore the pipe handles
        //
        ntStatus =
            USBD_InternalRestoreConfiguration(
                NewDeviceData,
                DeviceObject,
                NewDeviceData->ConfigurationHandle);

    } else {

        //
        // free up the old config
        //

        ntStatus = USBD_InternalCloseConfiguration(OldDeviceData,
                                                   DeviceObject,
                                                   &usbdStatus,
                                                   TRUE,
                                                   FALSE);


        ntStatus = STATUS_UNSUCCESSFUL;

    }

    //
    // free the old data regardless
    //

    RETHEAP(OldDeviceData);

    USBD_KdPrint(3, ("'exit USBD_ReCreateDevice 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_RestoreDevice(
    IN OUT PUSBD_DEVICE_DATA OldDeviceData,
    IN OUT PUSBD_DEVICE_DATA NewDeviceData,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Service exported for use by the hub driver

    Our goal here is to re-create the device and restore the configuration.

Arguments:

Return Value:

    NT status code.

--*/
{

    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_RestoreDevice) - get JD\n"));

    return USBD_RestoreDeviceX(
        OldDeviceData,
        NewDeviceData,
        DeviceObject);
}


NTSTATUS
USBD_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    UNICODE_STRING keyNameUnicodeString;

    PAGED_CODE();

    RtlInitUnicodeString(&keyNameUnicodeString, KeyName);

    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     DevInstKeyType,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);


    if (NT_SUCCESS(ntStatus)) {
/*
        RtlInitUnicodeString(&keyName, L"DeviceFoo");
        ZwSetValueKey(handle,
                      &keyName,
                      0,
                      REG_DWORD,
                      ComplienceFlags,
                      sizeof(*ComplienceFlags));
*/

        USBD_SetRegistryKeyValue(handle,
                                 &keyNameUnicodeString,
                                 Data,
                                 DataLength,
                                 KeyType);

        ZwClose(handle);
    }

    USBD_KdPrint(3, ("' RtlQueryRegistryValues status 0x%x\n"));

    return ntStatus;
}


NTSTATUS
USBD_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    PAGED_CODE();

//    InitializeObjectAttributes( &objectAttributes,
//                                KeyNameString,
//                                OBJ_CASE_INSENSITIVE,
//                                Handle,
//                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //
#if 0
    ntStatus = ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
#endif
    ntStatus = ZwSetValueKey(Handle,
                             KeyNameUnicodeString,
                             0,
                             KeyType,
                             Data,
                             DataLength);

    USBD_KdPrint(3, ("' ZwSetKeyValue = 0x%x\n", ntStatus));

    return ntStatus;
}

NTSTATUS
USBD_QueryBusTime(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PULONG CurrentFrame
    )
/*++

Routine Description:

        get the HCD current frame, callable at any IRQL

Arguments:

Return Value:

--*/
{
    PUSBD_EXTENSION deviceExtension;

    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_QueryBusTime) - get JD\n"));

    deviceExtension = RootHubPdo->DeviceExtension;
    deviceExtension = deviceExtension->TrueDeviceExtension;

    return deviceExtension->HcdGetCurrentFrame(
                deviceExtension->HcdDeviceObject,
                CurrentFrame);
}

#else   // USBD_DRIVER

// Obsolete functions that are still exported are stubbed out here.

ULONG
USBD_AllocateDeviceName(
    PUNICODE_STRING DeviceNameUnicodeString
    )
{
    ULONG i = 0;

    PAGED_CODE();

    ASSERT(FALSE);

    return i;
}


VOID
USBD_CompleteRequest(
    PIRP Irp,
    CCHAR PriorityBoost
    )
{
    ASSERT(FALSE);

    return;
}


NTSTATUS
USBD_CreateDevice(
    IN OUT PUSBD_DEVICE_DATA *DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeviceIsLowSpeed,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags
    )
{

    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service entry point (USBD_CreateDevice) - get JD\n"));

    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


BOOLEAN
USBD_Dispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PDEVICE_OBJECT *HcdDeviceObject,
    NTSTATUS *NtStatus
    )
{
    BOOLEAN irpNeedsCompletion = TRUE;

    ASSERT(FALSE);

    return irpNeedsCompletion;
}


VOID
USBD_FreeDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    )
{
    PAGED_CODE();

    ASSERT(FALSE);

    return;
}


VOID
USBD_FreeDeviceName(
    ULONG DeviceNameHandle
    )
{
    PAGED_CODE();

    ASSERT(FALSE);

    return;
}


NTSTATUS
USBD_GetDeviceInformation(
    IN PUSB_NODE_CONNECTION_INFORMATION DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSBD_DEVICE_DATA DeviceData
    )
{

    USBD_KdPrint(0,
(" WARNING: Driver using obsolete service enrty point (USBD_GetDeviceInformation) - get JD\n"));

    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


DEVICE_POWER_STATE
USBD_GetSuspendPowerState(
    PDEVICE_OBJECT DeviceObject
    )
{
    ASSERT(FALSE);

    return 0;
}


NTSTATUS
USBD_InitializeDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    )
{
    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_InitializeDevice) - get JD\n"));

    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBD_MakePdoName(
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    )
{
    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBD_QueryBusTime(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PULONG CurrentFrame
    )
{
    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_QueryBusTime) - get JD\n"));

    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


VOID
USBD_RegisterHcDeviceCapabilities(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_CAPABILITIES DeviceCapabilities,
    ROOT_HUB_POWER_FUNCTION *RootHubPower
    )
{
    ASSERT(FALSE);

    return;
}


VOID
USBD_RegisterHcFilter(
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT FilterDeviceObject
    )
{
    ASSERT(FALSE);
}


NTSTATUS
USBD_RegisterHostController(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT HcdDeviceObject,
    IN PDEVICE_OBJECT HcdTopOfPdoStackDeviceObject,
    IN PDRIVER_OBJECT HcdDriverObject,
    IN HCD_DEFFERED_START_FUNCTION *HcdDeferredStartDevice,
    IN HCD_SET_DEVICE_POWER_STATE *HcdSetDevicePowerState,
    IN HCD_GET_CURRENT_FRAME *HcdGetCurrentFrame,
    IN HCD_GET_CONSUMED_BW *HcdGetConsumedBW,
    IN HCD_SUBMIT_ISO_URB *HcdSubmitIsoUrb,
// this parameter is only needed until we resolve device naming
// issues with PNP
    IN ULONG HcdDeviceNameHandle
    )
{
    PAGED_CODE();

    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBD_RemoveDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Flags
    )
{
       USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_RemoveDevice) - get JD\n"));

    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
USBD_RestoreDevice(
    IN OUT PUSBD_DEVICE_DATA OldDeviceData,
    IN OUT PUSBD_DEVICE_DATA NewDeviceData,
    IN PDEVICE_OBJECT DeviceObject
    )
{

    USBD_KdPrint(0,
("'WARNING: Driver using obsolete service enrty point (USBD_RestoreDevice) - get JD\n"));

    ASSERT(FALSE);

    return STATUS_NOT_SUPPORTED;
}


VOID
USBD_SetSuspendPowerState(
    PDEVICE_OBJECT DeviceObject,
    DEVICE_POWER_STATE SuspendPowerState
    )
{
    ASSERT(FALSE);

    return;
}


VOID
USBD_WaitDeviceMutex(
    PDEVICE_OBJECT RootHubPDO
    )
{
    ASSERT(FALSE);

    return;
}


#endif  // USBD_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\usbd.h ===
/*++

Copyright (c) 1995    Microsoft Corporation

Module Name:

    USBD.H

Abstract:

    This module contains the PRIVATE (driver-only) definitions for the
    code that implements the usbd driver.

Environment:

    Kernel & user mode

Revision History:

    09-29-95 : created

--*/

#ifndef USBKDEXTS
#include "dbg.h"
#endif

#define NAME_MAX 64

#define USBD_TAG         0x44425355 /* "USBD" */

#if DBG
#define DEBUG_LOG
#endif

//enable pageable code
#ifndef PAGE_CODE
#define PAGE_CODE
#endif

#define _USBD_

//
// Constents used to format USB setup packets
// for the default pipe
//

//
// Values for the bmRequest field
//
                                        
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

#define USBD_TAG          0x44425355        //"USBD"

/* Registry Keys */

// ** 
// The following keys are specific to the instance of the 
// host controller -- the keys are read from the software 
// branch of the registry for the given PDO:
//

/* DWORD keys */

// This key enables a set of global hacks for early or broken USB 
// devices -- the default value is OFF
#define SUPPORT_NON_COMP_KEY    L"SupportNonComp"

// this key forces the stack in to daignotic mode
#define DAIGNOSTIC_MODE_KEY     L"DiagnosticMode"

// enables specif USB device specific hacks to work around
// certain busted devices.
// see #define USBD_DEVHACK_
#define DEVICE_HACK_KEY         L"DeviceHackFlags"

//** 
// The following keys are global to the USB stack 
// ie effect all HC controllers in the system:
//
// they are found in HKLM\System\CCS\Services\USB

// BINARY keys (1 byte)

// turns on hacks for the Toshiba Pseudo Hid device
#define LEGACY_TOSHIBA_USB_KEY  L"LegacyToshibaUSB"

// forces 'fast-iso' on all ISO-out endpoints, this key
// is for test purposes only
#define FORCE_FAST_ISO_KEY  L"ForceFastIso"

// forces double buffering for all bulk-in endpoints
// this key is for testing purposes only
#define FORCE_DOUBLE_BUFFER_KEY  L"ForceDoubleBuffer"

/****/    

//
// USB standard command values
// combines bmRequest and bRequest fields 
// in the setup packet for standard control 
// transfers
//
                                                
#define STANDARD_COMMAND_REQUEST_MASK           0xff00

#define STANDARD_COMMAND_GET_DESCRIPTOR         ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_GET_DESCRIPTOR<<8))
                                                    
#define STANDARD_COMMAND_SET_DESCRIPTOR         ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_SET_DESCRIPTOR<<8))    

#define STANDARD_COMMAND_GET_STATUS_ENDPOINT    ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_ENDPOINT) | \
                                                (USB_REQUEST_GET_STATUS<<8))
                                                    
#define STANDARD_COMMAND_GET_STATUS_INTERFACE   ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_INTERFACE) | \
                                                (USB_REQUEST_GET_STATUS<<8))
                                                
#define STANDARD_COMMAND_GET_STATUS_DEVICE      ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_GET_STATUS<<8))

#define STANDARD_COMMAND_SET_CONFIGURATION      ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_SET_CONFIGURATION<<8))

#define STANDARD_COMMAND_SET_INTERFACE          ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_INTERFACE) | \
                                                (USB_REQUEST_SET_INTERFACE<<8))
                                                    
#define STANDARD_COMMAND_SET_ADDRESS            ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_SET_ADDRESS<<8))

#define STANDARD_COMMAND_CLEAR_FEATURE_ENDPOINT ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_ENDPOINT) | \
                                                (USB_REQUEST_CLEAR_FEATURE<<8))

//
// USB class command macros
//

#define CLASS_COMMAND_GET_DESCRIPTOR            ((USB_CLASS_COMMAND | \
                                                USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_GET_DESCRIPTOR<<8))    

#define CLASS_COMMAND_GET_STATUS_OTHER          ((USB_CLASS_COMMAND | \
                                                USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_OTHER) | \
                                                (USB_REQUEST_GET_STATUS<<8))

#define CLASS_COMMAND_SET_FEATURE_TO_OTHER         ((USB_CLASS_COMMAND | \
                                                USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_OTHER) | \
                                                (USB_REQUEST_SET_FEATURE<<8))                                                    

//
// Macros to set transfer direction flag
//

#define USBD_SET_TRANSFER_DIRECTION_IN(tf)  ((tf) |= USBD_TRANSFER_DIRECTION_IN)  

#define USBD_SET_TRANSFER_DIRECTION_OUT(tf) ((tf) &= ~USBD_TRANSFER_DIRECTION_IN)  

                                        
//
// Flags for the URB header flags field used
// by USBD
//                                  
#define USBD_REQUEST_IS_TRANSFER        0x00000001
#define USBD_REQUEST_MDL_ALLOCATED      0x00000002
#define USBD_REQUEST_USES_DEFAULT_PIPE  0x00000004          
#define USBD_REQUEST_NO_DATA_PHASE      0x00000008    

typedef struct _USB_STANDARD_SETUP_PACKET {
    USHORT RequestCode;
    USHORT wValue;
    USHORT wIndex;
    USHORT wLength;
} USB_STANDARD_SETUP_PACKET, *PUSB_STANDARD_SETUP_PACKET;

//
// information for each active pipe on a device
//

typedef struct _USBD_PIPE {
    ULONG Sig;
    USB_ENDPOINT_DESCRIPTOR    EndpointDescriptor;
    PVOID HcdEndpoint;
    ULONG MaxTransferSize;
    ULONG ScheduleOffset;
    ULONG UsbdPipeFlags;
} USBD_PIPE, *PUSBD_PIPE;


//
// information for each active interface
// for a device
//


typedef struct _USBD_INTERFACE {
    ULONG Sig;
    BOOLEAN HasAlternateSettings;
    UCHAR Pad[3];
    USB_INTERFACE_DESCRIPTOR InterfaceDescriptor;   // copy of interface descriptor
    // copy of interfaceInformation structure, stores user parameters
    // for interface in case of failure during alt-interface selection
    PUSBD_INTERFACE_INFORMATION InterfaceInformation;
    USBD_PIPE PipeHandle[0];                        // array of pipe handle structures
} USBD_INTERFACE, *PUSBD_INTERFACE;


//
// informnation for the active configuration
// on a device
//

typedef struct _USBD_CONFIG {
    ULONG Sig;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;
    PUSBD_INTERFACE InterfaceHandle[1];             // array of pointers to interface
} USBD_CONFIG, *PUSBD_CONFIG;

//
// instance information for a device
//

typedef struct _USBD_DEVICE_DATA {
    ULONG Sig;
    USHORT DeviceAddress;                    // address assigned to the device
    UCHAR Pad[2];
    PUSBD_CONFIG ConfigurationHandle;
//   KTIMER TimeoutTimer;
//    KDPC TimeoutDpc;

    USBD_PIPE DefaultPipe;
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;  // a copy of the USB device descriptor
    USB_CONFIGURATION_DESCRIPTOR ConfigDescriptor;
    BOOLEAN LowSpeed;                        // TRUE if the device is low speed
    BOOLEAN AcceptingRequests;
} USBD_DEVICE_DATA, *PUSBD_DEVICE_DATA;

typedef struct _USBD_RH_DELAYED_SET_POWER_D0_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _USBD_EXTENSION *DeviceExtension;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
} USBD_RH_DELAYED_SET_POWER_D0_WORK_ITEM, *PUSBD_RH_DELAYED_SET_POWER_D0_WORK_ITEM;


#define PIPE_CLOSED(ph) ((ph)->HcdEndpoint == NULL)

#define GET_DEVICE_EXTENSION(DeviceObject)    (((PUSBD_EXTENSION)(DeviceObject->DeviceExtension))->TrueDeviceExtension)
//#define GET_DEVICE_EXTENSION(DeviceObject)    ((PUSBD_EXTENSION)(DeviceObject->DeviceExtension))

#define HCD_DEVICE_OBJECT(DeviceObject)        (DeviceObject)

#define DEVICE_FROM_DEVICEHANDLEROBJECT(UsbdDeviceHandle) (PUSBD_DEVICE_DATA) (UsbdDeviceHandle)

#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)

#define HC_URB(urb) ((PHCD_URB)(urb))

//
// we use a semaphore to serialize access to the configuration functions
// in USBD
//
#define InitializeUsbDeviceMutex(de)  KeInitializeSemaphore(&(de)->UsbDeviceMutex, 1, 1);

#define USBD_WaitForUsbDeviceMutex(de)  { USBD_KdPrint(3, ("'***WAIT dev mutex %x\n", &(de)->UsbDeviceMutex)); \
                                          KeWaitForSingleObject(&(de)->UsbDeviceMutex, \
                                                                Executive,\
                                                                KernelMode, \
                                                                FALSE, \
                                                                NULL); \
                                            }                                                                 

#define USBD_ReleaseUsbDeviceMutex(de)  { USBD_KdPrint(3, ("'***RELEASE dev mutex %x\n", &(de)->UsbDeviceMutex));\
                                          KeReleaseSemaphore(&(de)->UsbDeviceMutex,\
                                                             LOW_REALTIME_PRIORITY,\
                                                             1,\
                                                             FALSE);\
                                        }

//#if DBG
//VOID
//USBD_IoCompleteRequest(
//    IN PIRP Irp,
//    IN CCHAR PriorityBoost
//    );
//#else
#define USBD_IoCompleteRequest(a, b) IoCompleteRequest(a, b)
//#endif

//
//Function Prototypes
//

#if DBG
VOID
USBD_Warning(
    PUSBD_DEVICE_DATA DeviceData,
    PUCHAR Message,
    BOOLEAN DebugBreak
    );
#else
#define USBD_Warning(x, y, z)
#endif    

NTSTATUS
USBD_Internal_Device_Control(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_EXTENSION DeviceExtension,
    IN PBOOLEAN IrpIsPending
    );

NTSTATUS
USBD_SendCommand(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT RequestCode,
    IN USHORT WValue,
    IN USHORT WIndex,
    IN USHORT WLength,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned,
    OUT USBD_STATUS *UsbStatus
    );

NTSTATUS
USBD_CreateDevice(
    IN OUT PUSBD_DEVICE_DATA *DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeviceIsLowSpeed,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG NonCompliantDevice
    );
        
NTSTATUS
USBD_InitializeDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    );    

NTSTATUS
USBD_ProcessURB(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    );

NTSTATUS
USBD_MapError_UrbToNT(
    IN PURB Urb,
    IN NTSTATUS NtStatus
    );

NTSTATUS
USBD_Irp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

USHORT
USBD_AllocateUsbAddress(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBD_OpenEndpoint(
    IN PUSBD_DEVICE_DATA Device,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    OUT USBD_STATUS *UsbStatus,
    BOOLEAN IsDefaultPipe
    );

NTSTATUS
USBD_GetDescriptor(
    IN PUSBD_DEVICE_DATA Device,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUCHAR DescriptorBuffer,
    IN USHORT DescriptorBufferLength,
    IN USHORT DescriptorTypeAndIndex
    );

NTSTATUS
USBD_CloseEndpoint(
    IN PUSBD_DEVICE_DATA Device,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    OUT USBD_STATUS *UsbStatus
    );

NTSTATUS
USBD_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
USBD_LogInit(
    );

NTSTATUS
USBD_SubmitSynchronousURB(
    IN PURB Urb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_DEVICE_DATA DeviceData
    );

NTSTATUS
USBD_EnumerateBUS(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUCHAR DeviceEnumBuffer,
    IN ULONG DeviceEnumBufferLength 
    );

NTSTATUS
USBD_InternalCloseConfiguration(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT USBD_STATUS *UsbdStatus,
    IN BOOLEAN AbortTransfers,
    IN BOOLEAN KeepConfig
    );

PUSB_INTERFACE_DESCRIPTOR
USBD_InternalParseConfigurationDescriptor(
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN UCHAR InterfaceNumber,
    IN UCHAR AlternateSetting,
    PBOOLEAN HasAlternateSettings
    );    

NTSTATUS 
USBD_GetPdoRegistryParameters (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PULONG ComplienceFlags,
    IN OUT PULONG DiagnosticFlags,
    IN OUT PULONG DeviceHackFlags
    );

NTSTATUS 
USBD_GetGlobalRegistryParameters (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PULONG ComplienceFlags,
    IN OUT PULONG DiagnosticFlags,
    IN OUT PULONG DeviceHackFlags
    );    

NTSTATUS
USBD_GetEndpointState(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    OUT USBD_STATUS *UsbStatus,
    OUT PULONG EndpointState
    );    

VOID
USBD_SyncUrbTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );   

VOID
USBD_FreeUsbAddress(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT DeviceAddress
    );    

ULONG
USBD_InternalGetInterfaceLength(
    IN PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor, 
    IN PUCHAR End
    );    

NTSTATUS
USBD_InitializeConfigurationHandle(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor, 
    IN ULONG NumberOfInterfaces,
    IN OUT PUSBD_CONFIG *ConfigHandle
    );    

BOOLEAN
USBD_InternalInterfaceBusy(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_INTERFACE InterfaceHandle
    );    

NTSTATUS
USBD_InternalOpenInterface(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_CONFIG ConfigHandle,
    IN OUT PUSBD_INTERFACE_INFORMATION InterfaceInformation,
    IN OUT PUSBD_INTERFACE *InterfaceHandle,
    IN BOOLEAN SendSetInterfaceCommand,
    IN PBOOLEAN NoBandwidth
    );    

NTSTATUS
USBD_SelectConfiguration(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    );    

NTSTATUS
USBD_SelectInterface(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    );    

NTSTATUS 
USBD_GetRegistryKeyValue(
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    ); 

NTSTATUS
USBD_InternalMakePdoName(
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    ); 

NTSTATUS 
USBD_SymbolicLink(
    BOOLEAN CreateFlag,
    PUSBD_EXTENSION DeviceExtension
    );    

NTSTATUS
USBD_PdoDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PUSBD_EXTENSION DeviceExtension,
    PBOOLEAN IrpNeedsCompletion
    );    

NTSTATUS
USBD_FdoDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PUSBD_EXTENSION DeviceExtension,
    PBOOLEAN IrpNeedsCompletion
    );    

NTSTATUS
USBD_DeferPoRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE DeviceState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );    

NTSTATUS
USBD_InternalRestoreConfiguration(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_CONFIG ConfigHandle
    );    

NTSTATUS
USBD_InternalCloseDefaultPipe(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT USBD_STATUS *UsbdStatus,
    IN BOOLEAN AbortTransfers
    );

NTSTATUS
USBD_GetHubName(
    PUSBD_EXTENSION DeviceExtension,
    PIRP Irp
    );    

NTSTATUS 
USBD_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    );    

NTSTATUS 
USBD_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    );

NTSTATUS
USBD_SubmitWaitWakeIrpToHC(
    IN PUSBD_EXTENSION DeviceExtension
    );

BOOLEAN
USBD_ValidatePipe(
    PUSBD_PIPE PipeHandle
    );

VOID
USBD_CompleteIdleNotification(
    IN PUSBD_EXTENSION DeviceExtension
    );

NTSTATUS
USBD_FdoSetContentId(
    IN PIRP                          irp,
    IN PVOID                         pKsProperty,
    IN PVOID                         pvData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\intread.c ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        INTREAD.C

Abstract:

        Generic USB routines - must be called at PASSIVE_LEVEL

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        01/08/2001 : created

Authors:

        Tom Green


****************************************************************************/

#include "pch.h"

#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <ntstatus.h>

#include "usbutil.h"
#include "usbdbg.h"
#include "intread.h"
#include "usbpriv.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, USBCallSyncEx)
#pragma alloc_text(PAGE, USBVendorRequestEx)
#pragma alloc_text(PAGE, USBClassRequestEx)
#pragma alloc_text(PAGE, USBStartInterruptTransfers)
#pragma alloc_text(PAGE, USBStopInterruptTransfers)
#pragma alloc_text(PAGE, USBStartSelectiveSuspend)
#pragma alloc_text(PAGE, USBStopSelectiveSuspend)

#endif // ALLOC_PRAGMA


/*
 ********************************************************************************
 *  UsbWrapInitializeInterruptReadData
 ********************************************************************************
 *
 *
 */

NTSTATUS UsbWrapInitializeInterruptReadData(
    IN PUSB_WRAPPER_EXTENSION    WrapExtension,
    IN PUSBD_PIPE_INFORMATION    InterruptPipe,
    IN INTERRUPT_CALLBACK        DriverCallback,
    IN PVOID                     DriverContext,
    IN ULONG                     MaxTransferSize,
    IN ULONG                     NotificationTypes,
    IN ULONG                     PingPongCount)
{

    WrapExtension->IntReadWrap.InterruptPipe = InterruptPipe;
    WrapExtension->IntReadWrap.MaxTransferSize = MaxTransferSize;
    WrapExtension->IntReadWrap.ClientCallback = DriverCallback;
    WrapExtension->IntReadWrap.ClientContext = DriverContext;
    WrapExtension->IntReadWrap.NotificationTypes = NotificationTypes;
    WrapExtension->IntReadWrap.NumPingPongs = PingPongCount;
    WrapExtension->IntReadWrap.OutstandingRequests = 0;
    WrapExtension->IntReadWrap.WorkItemRunning = 0;
    WrapExtension->IntReadWrap.TransferCount = 0;

    return STATUS_SUCCESS;

}


/*
 ********************************************************************************
 *  UsbWrapInitializePingPongIrps
 ********************************************************************************
 *
 *
 */

NTSTATUS UsbWrapInitializePingPongIrps(PUSB_WRAPPER_EXTENSION WrapExtension)
{

    NTSTATUS result = STATUS_SUCCESS;
    ULONG i;
    CCHAR numIrpStackLocations;

    PAGED_CODE();

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapInitializePingPongIrps\n"));

    numIrpStackLocations = WrapExtension->LowerDeviceObject->StackSize;

    //
    // Initialize the queues for interrupt read data
    //

    InitializeListHead(&WrapExtension->IntReadWrap.SavedQueue);
    InitializeListHead(&WrapExtension->IntReadWrap.IncomingQueue);
    KeInitializeSpinLock(&WrapExtension->IntReadWrap.QueueLock);

    ASSERT(WrapExtension->IntReadWrap.NumPingPongs > 0);

    WrapExtension->IntReadWrap.PingPongs = ALLOC_MEM(NonPagedPool,
                                                     WrapExtension->IntReadWrap.NumPingPongs*sizeof(USB_WRAPPER_PINGPONG),
                                                     USBWRAP_TAG);

    if (WrapExtension->IntReadWrap.PingPongs){

        ULONG transferBufferSize = WrapExtension->IntReadWrap.MaxTransferSize;

        RtlZeroMemory(WrapExtension->IntReadWrap.PingPongs,
                      WrapExtension->IntReadWrap.NumPingPongs*sizeof(USB_WRAPPER_PINGPONG));

        for (i = 0; i < WrapExtension->IntReadWrap.NumPingPongs; i++) {

            WrapExtension->IntReadWrap.PingPongs[i].myWrapExt = WrapExtension;
            WrapExtension->IntReadWrap.PingPongs[i].weAreCancelling = 0;
            WrapExtension->IntReadWrap.PingPongs[i].sig = PINGPONG_SIG;


            WrapExtension->IntReadWrap.PingPongs[i].irp = IoAllocateIrp(numIrpStackLocations+1, FALSE);

            if (WrapExtension->IntReadWrap.PingPongs[i].irp){

                PURB pUrb;


                KeInitializeEvent(&WrapExtension->IntReadWrap.PingPongs[i].sentEvent,
                                  NotificationEvent,
                                  TRUE);    // Set to signaled
                KeInitializeEvent(&WrapExtension->IntReadWrap.PingPongs[i].pumpDoneEvent,
                                  NotificationEvent,
                                  TRUE);    // Set to signaled

                pUrb = ALLOC_MEM( NonPagedPool, sizeof(URB), USBWRAP_TAG);

                if(pUrb) {

                    USHORT size;
                    PIO_STACK_LOCATION NextStack = NULL;
                    RtlZeroMemory(pUrb, sizeof(URB));


                    WrapExtension->IntReadWrap.PingPongs[i].urb = pUrb;


                } else {

                    result = STATUS_INSUFFICIENT_RESOURCES;
                    FREE_MEM(WrapExtension->IntReadWrap.PingPongs[i].irp);
                    break;

                }


            } else {

                result = STATUS_INSUFFICIENT_RESOURCES;
                break;

            }

        }

    } else {

        result = STATUS_INSUFFICIENT_RESOURCES;

    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapInitializePingPongIrps (0x%x)\n", result));

    return result;

}


/*
 ********************************************************************************
 *  UsbWrapSubmitInterruptRead
 ********************************************************************************
 *
 *
 */
NTSTATUS UsbWrapSubmitInterruptRead(
    IN PUSB_WRAPPER_EXTENSION WrapExtension,
    PUSB_WRAPPER_PINGPONG PingPong,
    BOOLEAN *IrpSent)
{

    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;
    BOOLEAN proceed;
    LONG oldInterlock;
    ULONG transferBufferSize;
    PIRP irp = PingPong->irp;
    PURB urb = PingPong->urb;


    ASSERT(irp);

    *IrpSent = FALSE;

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapSubmitInterruptRead\n"));


    while (1) {

        if (NT_SUCCESS(status)) {

            oldInterlock = InterlockedExchange(&PingPong->ReadInterlock,
                                               PINGPONG_START_READ);
            ASSERT(oldInterlock == PINGPONG_END_READ);

            irp->Cancel = FALSE;
            irp->IoStatus.Status = STATUS_NOT_SUPPORTED;



            /*
             *  Send down the read IRP.
             */
            KeResetEvent(&PingPong->sentEvent);

            if (PingPong->weAreCancelling) {

                InterlockedDecrement(&PingPong->weAreCancelling);
                //
                // Ordering of the next two instructions is crucial, since
                // CancelPingPongs will exit after pumpDoneEvent is set, and the
                // pingPongs could be deleted after that.
                //
                DBGPRINT(DBG_USBUTIL_TRACE, ("Pingpong %x cancelled in submit before sending\n", PingPong))
                KeSetEvent (&PingPong->sentEvent, 0, FALSE);
                KeSetEvent(&PingPong->pumpDoneEvent, 0, FALSE);
                status = STATUS_CANCELLED;
                break;

            } else {

                PIO_STACK_LOCATION NextStack = NULL;

                UsbBuildInterruptOrBulkTransferRequest(PingPong->urb,
                                                       (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                                                       WrapExtension->IntReadWrap.InterruptPipe->PipeHandle,
                                                       NULL,
                                                       NULL,
                                                       WrapExtension->IntReadWrap.MaxTransferSize,
                                                       USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK,
                                                       NULL);

                urb->UrbBulkOrInterruptTransfer.TransferBuffer = UsbWrapGetTransferBuffer(WrapExtension);
                urb->UrbBulkOrInterruptTransfer.TransferBufferLength = WrapExtension->IntReadWrap.MaxTransferSize;

                if (urb->UrbBulkOrInterruptTransfer.TransferBuffer == NULL) {

                    KeSetEvent (&PingPong->sentEvent, 0, FALSE);
                    KeSetEvent(&PingPong->pumpDoneEvent, 0, FALSE);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }

                InterlockedIncrement(&WrapExtension->IntReadWrap.OutstandingRequests);
                DBGPRINT(DBG_USBUTIL_TRACE, ("Sending pingpong %x from Submit\n", PingPong))




                IoSetCompletionRoutine( irp,
                                        UsbWrapInterruptReadComplete,
                                        WrapExtension,    // context
                                        TRUE,
                                        TRUE,
                                        TRUE );



                NextStack = IoGetNextIrpStackLocation(PingPong->irp);

                ASSERT(NextStack);

                NextStack->Parameters.Others.Argument1 = PingPong->urb;
                NextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

                NextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

                NextStack->DeviceObject = WrapExtension->LowerDeviceObject;


                status = IoCallDriver(WrapExtension->LowerDeviceObject, irp);
                KeSetEvent (&PingPong->sentEvent, 0, FALSE);
                *IrpSent = TRUE;

            }

            if (PINGPONG_IMMEDIATE_READ != InterlockedExchange(&PingPong->ReadInterlock,
                                                               PINGPONG_END_READ)) {
                //
                // The read is asynch, will call SubmitInterruptRead from the
                // completion routine
                //
                DBGPRINT(DBG_USBUTIL_TRACE, ("read is pending\n"))
                break;

            } else {

                //
                // The read was synchronous (probably bytes in the buffer).  The
                // completion routine will not call SubmitInterruptRead, so we
                // just loop here.  This is to prevent us from running out of stack
                // space if always call StartRead from the completion routine
                //
                status = irp->IoStatus.Status;
                DBGPRINT(DBG_USBUTIL_TRACE, ("read is looping with status %x\n", status))

            }

        } else {

 //           if (PingPong->weAreCancelling ) {

                // We are stopping the read pump.
                // set this event and stop resending the pingpong IRP.
                DBGPRINT(DBG_USBUTIL_TRACE, ("We are cancelling bit set for pingpong %x\n", PingPong))
 //               InterlockedDecrement(&PingPong->weAreCancelling);
                KeSetEvent(&PingPong->pumpDoneEvent, 0, FALSE);

                break;

 //           }


        }

    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapSubmitInterruptRead (0x%x)\n", status));
    return status;

}


/*
 ********************************************************************************
 *  UsbWrapIsDeviceConnected
 ********************************************************************************
 *
 *
 */
NTSTATUS
UsbWrapIsDeviceConnected (
    IN PUSB_WRAPPER_EXTENSION   WrapExt
    )
{
    PIRP                    irp;
    KEVENT                  event;
    PIO_STACK_LOCATION      nextStack;
    ULONG                   portStatus;
    NTSTATUS                status;
    IO_STATUS_BLOCK         iostatus;


    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapIsDeviceConnected\n"));


    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    // Allocate the Irp
    //
    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                                        WrapExt->LowerDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &event,
                                        &iostatus);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->Parameters.Others.Argument1 = &portStatus;

    // Pass the Irp down the stack
    //
    status = IoCallDriver(WrapExt->LowerDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = iostatus.Status;
    }

    if (NT_SUCCESS(status) && !(portStatus & USBD_PORT_CONNECTED))
    {
        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapIsDeviceConnected (0x%x)\n", status));

    return status;
}


/*
 ********************************************************************************
 *  UsbWrapResetDevice
 ********************************************************************************
 *
 *
 */
NTSTATUS
UsbWrapResetDevice (
    IN PUSB_WRAPPER_EXTENSION WrapExt
    )
{
    NTSTATUS status;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK iostatus;


    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapResetDevice\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_RESET_PORT,
                                        WrapExt->LowerDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &event,
                                        &iostatus);

    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    status = IoCallDriver(WrapExt->LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = iostatus.Status;

    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapResetDevice (0x%x)\n", status));


    return status;


}

/*
 ********************************************************************************
 *  UsbWrapErrorHandlerWorkRoutine
 ********************************************************************************
 *
 *
 */
VOID
UsbWrapErrorHandlerWorkRoutine  (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context)
{

    PUSB_WRAPPER_EXTENSION wrapExt = ((PUSB_WRAPPER_WORKITEM_CONTEXT) Context)->WrapExtension;
    PIO_WORKITEM workItem = ((PUSB_WRAPPER_WORKITEM_CONTEXT) Context)->WorkItem;
    PUSB_WRAPPER_PINGPONG pingPong = ((PUSB_WRAPPER_WORKITEM_CONTEXT) Context)->PingPong;
    NTSTATUS status;

    BOOLEAN errorHandled = FALSE;



    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapErrorHandlerWorkRoutine\n"));

    status = IoAcquireRemoveLockEx(wrapExt->RemoveLock,
                                   DeviceObject,
                                   __FILE__,
                                   __LINE__,
                                   wrapExt->RemLockSize);

    if (!NT_SUCCESS(status)) {

        DBGPRINT(DBG_USBUTIL_ERROR, ("UsbWrapErrorHandlerWorkRoutine: exiting due to removal\n"));
        goto ErrorWorkItemComplete;

    }
    // Lets first stop all ping pongs.
    UsbWrapCancelAllPingPongIrps(wrapExt);

    //
    // Notify Client of the error and give them a chance to handle it
    //
    if (wrapExt->IntReadWrap.NotificationTypes & USBWRAP_NOTIFICATION_READ_ERROR) {

        status = (wrapExt->IntReadWrap.ClientCallback)(wrapExt->IntReadWrap.ClientContext,
                                                       &pingPong->irp->IoStatus.Status,
                                                       sizeof(NTSTATUS),
                                                       USBWRAP_NOTIFICATION_READ_ERROR,
                                                       &errorHandled);


    }

    if(!errorHandled) {

        // The client didn't handle it, lets try to fix it ourselves by resetting the pipe

        ULONG retryCount;

        // Try the reset up to 3 times
        //
        for (retryCount = 0; retryCount < 3; retryCount++)
        {
            //
            // First figure out if the device is still connected.
            //
            status = UsbWrapIsDeviceConnected(wrapExt);

            if (!NT_SUCCESS(status))
            {
                // Give up if the device is no longer connected.
                break;
            }

            //
            // The device is still connected, now reset the device.
            //
            status = UsbWrapResetDevice(wrapExt);

            if (NT_SUCCESS(status)) {
                // reset was successful
                break;

            }

        }


        InterlockedExchange(&wrapExt->IntReadWrap.HandlingError, 0);

        if (NT_SUCCESS(status) && pingPong->irp->IoStatus.Status != STATUS_DEVICE_NOT_CONNECTED) {

            UsbWrapStartAllPingPongs(wrapExt);

        }


    }

    IoReleaseRemoveLockEx(wrapExt->RemoveLock,
                          DeviceObject,
                          wrapExt->RemLockSize);
ErrorWorkItemComplete:

    FREE_MEM(Context);
    IoFreeWorkItem(workItem);

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapErrorHandlerWorkRoutine\n"));


}


/*
 ********************************************************************************
 *  UsbWrapWorkRoutine
 ********************************************************************************
 *
 *
 */
VOID
UsbWrapWorkRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context)
{

    BOOLEAN QueueData = FALSE;
    PVOID buffer;
    ULONG dataLength;
    NTSTATUS status;
    PUSB_WRAPPER_EXTENSION wrapExtension = ((PUSB_WRAPPER_WORKITEM_CONTEXT) Context)->WrapExtension;
    PIO_WORKITEM workItem = ((PUSB_WRAPPER_WORKITEM_CONTEXT) Context)->WorkItem;
    KIRQL irql;

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapWorkRoutine\n"));

        KeAcquireSpinLock(&wrapExtension->IntReadWrap.QueueLock,
                          &irql);

        if(wrapExtension->IntReadWrap.PumpState == PUMP_STOPPED) {

            wrapExtension->IntReadWrap.WorkItemRunning--;
            ASSERT(wrapExtension->IntReadWrap.WorkItemRunning == 0);

            KeReleaseSpinLock(&wrapExtension->IntReadWrap.QueueLock,
                              irql);

            __leave;
        }



        while(!IsListEmpty(&wrapExtension->IntReadWrap.IncomingQueue)) {


            UsbWrapDequeueData(wrapExtension,
                               &buffer,
                               &dataLength,
                               &wrapExtension->IntReadWrap.IncomingQueue);

            if (!buffer) {
                wrapExtension->IntReadWrap.WorkItemRunning--;
                ASSERT(wrapExtension->IntReadWrap.WorkItemRunning == 0);
            }

            KeReleaseSpinLock(&wrapExtension->IntReadWrap.QueueLock,
                              irql);

            DBGPRINT(DBG_USBUTIL_OTHER_ERROR, ("    Dequeued Data buffer: 0x%x\n", buffer));

            if(!buffer) {

                //
                // This data had better be there!!!
                //
                __leave;

            }

            status = (wrapExtension->IntReadWrap.ClientCallback)(wrapExtension->IntReadWrap.ClientContext,
                                                                 buffer,
                                                                 dataLength,
                                                                 USBWRAP_NOTIFICATION_READ_COMPLETE,
                                                                 &QueueData);

            if(QueueData) {


                UsbWrapEnqueueData(wrapExtension,
                                   buffer,
                                   dataLength,
                                   &wrapExtension->IntReadWrap.SavedQueue);



            } else {

                if (!(wrapExtension->IntReadWrap.NotificationTypes & USBWRAP_NOTIFICATION_BUFFER_CLIENT_FREE)) {

                    UsbWrapFreeTransferBuffer(wrapExtension,
                                              buffer);

                }

            }

            KeAcquireSpinLock(&wrapExtension->IntReadWrap.QueueLock,
                              &irql);
        }

        wrapExtension->IntReadWrap.WorkItemRunning--;

        KeReleaseSpinLock(&wrapExtension->IntReadWrap.QueueLock,
                          irql);

    }

    __finally
    {

        if (workItem) {

            IoFreeWorkItem(workItem);

            // only want to free the context if this was actually executed in a
            // Worker thread.  If it was called directly, then this was allocated
            // on the stack.
            FREE_MEM(Context);


        }

        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapWorkRoutine\n"));

    }

}


/*
 ********************************************************************************
 *  GetPingPongFromIrp
 ********************************************************************************
 *
 *
 */
USB_WRAPPER_PINGPONG *GetPingPongFromIrp(
    PUSB_WRAPPER_EXTENSION WrapExt,
    PIRP irp)
{

    USB_WRAPPER_PINGPONG *pingPong = NULL;
    ULONG i;

    for (i = 0; i < WrapExt->IntReadWrap.NumPingPongs; i++){

        if (WrapExt->IntReadWrap.PingPongs[i].irp == irp){

            pingPong = &WrapExt->IntReadWrap.PingPongs[i];
            break;

        }

    }

    ASSERT(pingPong);
    return pingPong;

}


/*
 ********************************************************************************
 *  UsbWrapInterruptReadComplete
 ********************************************************************************
 *
 *
 */
NTSTATUS UsbWrapInterruptReadComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{

    PUSB_WRAPPER_EXTENSION wrapExtension = (PUSB_WRAPPER_EXTENSION)Context;
    PUSB_WRAPPER_PINGPONG pingPong;
    KIRQL oldIrql;
    BOOLEAN startRead;
    BOOLEAN errorHandled = FALSE;
    BOOLEAN startWorkItem = FALSE;
    NTSTATUS status;
    BOOLEAN resend = TRUE;

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapInterruptReadComplete %p\n", Irp));

    //
    // Track the number of outstanding requests to this device.
    //
    ASSERT(wrapExtension->IntReadWrap.OutstandingRequests > 0 );
    InterlockedDecrement(&wrapExtension->IntReadWrap.OutstandingRequests);
    DeviceObject = wrapExtension->DeviceObject;
    pingPong = GetPingPongFromIrp(wrapExtension, Irp);

    ASSERT(DeviceObject);
    if (!pingPong) {

        //
        // Something is terribly wrong, but do nothing. Hopefully
        // just exiting will clear up this pimple.
        //
        DBGPRINT(DBG_USBUTIL_ERROR,("A pingPong structure could not be found!!! Have this looked at!"))
        goto InterruptReadCompleteExit;

    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {


        if (wrapExtension->IntReadWrap.NotificationTypes & (USBWRAP_NOTIFICATION_READ_COMPLETE | USBWRAP_NOTIFICATION_READ_COMPLETE_DIRECT)) {

            PIO_WORKITEM workItem;
            PUSB_WRAPPER_WORKITEM_CONTEXT workItemContext;
            ULONG count;

            UsbWrapEnqueueData(wrapExtension,
                   pingPong->urb->UrbBulkOrInterruptTransfer.TransferBuffer,
                   pingPong->urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
                   &wrapExtension->IntReadWrap.IncomingQueue);

            count = pingPong->urb->UrbBulkOrInterruptTransfer.TransferFlags;

            DBGPRINT(DBG_USBUTIL_OTHER_ERROR,
                     ("UsbWrapEnqueueData, %p buffer: 0x%x\n", pingPong,
                     pingPong->urb->UrbBulkOrInterruptTransfer.TransferBuffer));


            wrapExtension->IntReadWrap.TransferCount = count;

            pingPong->urb->UrbBulkOrInterruptTransfer.TransferBuffer = NULL;

            KeAcquireSpinLock(&wrapExtension->IntReadWrap.QueueLock,
                              &oldIrql);

            if (wrapExtension->IntReadWrap.WorkItemRunning) {

                startWorkItem = FALSE;

            } else {

                startWorkItem = TRUE;
                wrapExtension->IntReadWrap.WorkItemRunning++;

            }

            KeReleaseSpinLock(&wrapExtension->IntReadWrap.QueueLock,
                              oldIrql);

            if (startWorkItem) {

                if (wrapExtension->IntReadWrap.NotificationTypes & USBWRAP_NOTIFICATION_READ_COMPLETE_DIRECT) {

                    USB_WRAPPER_WORKITEM_CONTEXT context;

                    context.WorkItem = NULL;
                    context.WrapExtension = wrapExtension;


                    UsbWrapWorkRoutine(DeviceObject,
                                       &context);

                } else {

                    workItem = IoAllocateWorkItem(DeviceObject);

                    if (!workItem) {

                        //
                        // Insufficient Resources
                        //

                        goto InterruptReadCompleteExit;

                    }

                    workItemContext = ALLOC_MEM(NonPagedPool, sizeof(USB_WRAPPER_WORKITEM_CONTEXT), USBWRAP_TAG);

                    if (!workItemContext) {

                        //
                        // Insufficient Resources;
                        //

                        goto InterruptReadCompleteExit;

                    }

                    workItemContext->WorkItem = workItem;
                    workItemContext->WrapExtension = wrapExtension;

                    //
                    // Queue work item to notify the client
                    //

                    IoQueueWorkItem(workItem,
                                    UsbWrapWorkRoutine,
                                    CriticalWorkQueue,
                                    workItemContext);

                }
            }

        } else {

            //
            // Client doesn't want notification, so queue data in saved queue
            // so it can be read when the client is ready
            //

            UsbWrapEnqueueData(wrapExtension,
                   pingPong->urb->UrbBulkOrInterruptTransfer.TransferBuffer,
                   pingPong->urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
                   &wrapExtension->IntReadWrap.SavedQueue);



        }

    } else {

        DBGPRINT(DBG_USBUTIL_ERROR,("irp failed buffer: 0x%x\n",pingPong->urb->UrbBulkOrInterruptTransfer.TransferBuffer ))

        UsbWrapFreeTransferBuffer(wrapExtension, pingPong->urb->UrbBulkOrInterruptTransfer.TransferBuffer);
        if ((!pingPong->weAreCancelling)) {

            //
            // The Irp failed.
            //

            ULONG i;
            PIO_WORKITEM workItem;
            PUSB_WRAPPER_WORKITEM_CONTEXT workItemContext;


            DBGPRINT(DBG_USBUTIL_ERROR,("A pingpong irp (0x%x) failed : 0x%x\n",pingPong,Irp->IoStatus.Status ))

            //
            // First we must stop all Ping Pongs
            //
            KeSetEvent (&pingPong->sentEvent, 0, FALSE);
            KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);
        //    resend = FALSE;



            if ((Irp->IoStatus.Status != STATUS_DEVICE_NOT_CONNECTED)
                && (!InterlockedCompareExchange(&wrapExtension->IntReadWrap.HandlingError, 1, 0))) {

                // Queue a workitem to actually handle the error

                workItem = IoAllocateWorkItem(DeviceObject);

                if (!workItem) {

                    //
                    // Insufficient Resources
                    //

                    goto InterruptReadCompleteExit;


                }

                workItemContext = ALLOC_MEM(NonPagedPool, sizeof(USB_WRAPPER_WORKITEM_CONTEXT), USBWRAP_TAG);

                if (!workItemContext) {

                    //
                    // Insufficient Resources;
                    //

                    goto InterruptReadCompleteExit;

                }

                workItemContext->WorkItem = workItem;
                workItemContext->WrapExtension = wrapExtension;
                workItemContext->PingPong = pingPong;

                IoQueueWorkItem(workItem,
                                UsbWrapErrorHandlerWorkRoutine,
                                CriticalWorkQueue,
                                workItemContext);
            }

        }

    }

    //
    // If ReadInterlock is == START_READ, this func has been completed
    // synchronously.  Place IMMEDIATE_READ into the interlock to signify this
    // situation; this will notify StartRead to loop when IoCallDriver returns.
    // Otherwise, we have been completed async and it is safe to call StartRead()
    //
    startRead =
       (PINGPONG_START_READ !=
        InterlockedCompareExchange(&pingPong->ReadInterlock,
                                   PINGPONG_IMMEDIATE_READ,
                                   PINGPONG_START_READ));



    //
    // Business as usual.
    //
    if (startRead) {

        if (pingPong->weAreCancelling){

            // We are stopping the read pump.
            // Set this event and stop resending the pingpong IRP.
            DBGPRINT(DBG_USBUTIL_TRACE, ("We are cancelling bit set for pingpong %x\n", pingPong))
//            InterlockedDecrement(&pingPong->weAreCancelling);
            KeSetEvent(&pingPong->pumpDoneEvent, 0, FALSE);

        } else {

            if (Irp->IoStatus.Status == STATUS_SUCCESS) {

                BOOLEAN irpSent;
                DBGPRINT(DBG_USBUTIL_TRACE, ("Submitting pingpong %x from completion routine\n", pingPong))
                UsbWrapSubmitInterruptRead(wrapExtension, pingPong, &irpSent);

            }

        }

    }

InterruptReadCompleteExit:

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapInterruptReadComplete\n"));
    /*
    *  ALWAYS return STATUS_MORE_PROCESSING_REQUIRED;
    *  otherwise, the irp is required to have a thread.
    */
    return STATUS_MORE_PROCESSING_REQUIRED;

}



/*
 ********************************************************************************
 *  UsbWrapStartAllPingPongs
 ********************************************************************************
 *
 *
 */
NTSTATUS UsbWrapStartAllPingPongs(PUSB_WRAPPER_EXTENSION WrapExt)
{

    NTSTATUS status = STATUS_SUCCESS;
    ULONG i;

    PAGED_CODE();

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapStartAllPingPongs\n"));
    ASSERT(WrapExt->IntReadWrap.NumPingPongs > 0);

    InterlockedExchange(&WrapExt->IntReadWrap.PumpState,
                        PUMP_STARTED);
    for (i = 0; i < WrapExt->IntReadWrap.NumPingPongs; i++){

        BOOLEAN irpSent;

        // Different threads may be trying to start this pump at the
        // same time due to idle notification. Must only start once.
        if (WrapExt->IntReadWrap.PingPongs[i].pumpDoneEvent.Header.SignalState) {

            WrapExt->IntReadWrap.PingPongs[i].ReadInterlock = PINGPONG_END_READ;
            KeResetEvent(&WrapExt->IntReadWrap.PingPongs[i].pumpDoneEvent);
            DBGPRINT(DBG_USBUTIL_TRACE, ("Starting pingpong %x from UsbWrapStartAllPingPongs\n", &WrapExt->IntReadWrap.PingPongs[i]))
            status = UsbWrapSubmitInterruptRead(WrapExt, &WrapExt->IntReadWrap.PingPongs[i], &irpSent);


            if (!NT_SUCCESS(status)){

                if (irpSent){

                    DBGPRINT(DBG_USBUTIL_USB_ERROR,("Initial read failed with status %xh.", status))
                    status = STATUS_SUCCESS;

                } else {

                    DBGPRINT(DBG_USBUTIL_USB_ERROR,("Initial read failed, irp not sent, status = %xh.", status))
                    break;

                }

            }

        }

    }

    if (status == STATUS_PENDING){

        status = STATUS_SUCCESS;

    }

    if(!NT_SUCCESS(status)) {

        InterlockedExchange(&WrapExt->IntReadWrap.PumpState,
                            PUMP_STOPPED);

    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapStartAllPingPongs (0x%x)\n", status));
    return status;

}


/*
 ********************************************************************************
 *  UsbWrapCancelAllPingPongIrps
 ********************************************************************************
 *
 *
 */
VOID UsbWrapCancelAllPingPongIrps(PUSB_WRAPPER_EXTENSION WrapExt)
{

    ULONG i;

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapCancelAllPingPongIrpss\n"));

    for (i = 0; i < WrapExt->IntReadWrap.NumPingPongs; i++){

        USB_WRAPPER_PINGPONG *pingPong = &WrapExt->IntReadWrap.PingPongs[i];
        UsbWrapCancelPingPongIrp(pingPong);


    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapCancelAllPingPongIrps\n"));

}

/*
 ********************************************************************************
 *  UsbWrapCancelPingPongIrp
 ********************************************************************************
 *
 *
 */

VOID UsbWrapCancelPingPongIrp(USB_WRAPPER_PINGPONG *PingPong)
{
    DBGPRINT(DBG_USBUTIL_TRACE, ("Cancelling pingpong %x\n", PingPong))
    ASSERT(PingPong->sig == PINGPONG_SIG);

    //
    // The order of the following instructions is crucial. We must set
    // the weAreCancelling bit before waiting on the sentEvent, and the
    // last thing that we should wait on is the pumpDoneEvent, which
    // indicates that the read loop has finished all reads and will never
    // run again.
    //
    InterlockedIncrement(&PingPong->weAreCancelling);

    /*
     *  Synchronize with the irp's completion routine.
     */

    KeWaitForSingleObject(&PingPong->sentEvent,
                          Executive,      // wait reason
                          KernelMode,
                          FALSE,          // not alertable
                          NULL );         // no timeout
    DBGPRINT(DBG_USBUTIL_TRACE, ("Pingpong sent event set for pingpong %x\n", PingPong))
    IoCancelIrp(PingPong->irp);

    /*
     *  Cancelling the IRP causes a lower driver to
     *  complete it (either in a cancel routine or when
     *  the driver checks Irp->Cancel just before queueing it).
     *  Wait for the IRP to actually get cancelled.
     */
    KeWaitForSingleObject(  &PingPong->pumpDoneEvent,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

//    // Now clear the cancelling flag so the pingpong could be resent.
    InterlockedDecrement(&PingPong->weAreCancelling);
    DBGPRINT(DBG_USBUTIL_TRACE, ("Pingpong pump done event set for %x\n", PingPong))
}

/*
 ********************************************************************************
 *  UsbWrapDestroyPingPongs
 ********************************************************************************
 *
 *
 */
VOID UsbWrapDestroyPingPongs(PUSB_WRAPPER_EXTENSION WrapExt)
{

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapDestroyPingPongs\n"));


    if (WrapExt && WrapExt->IntReadWrap.PingPongs){

        ULONG i;

        UsbWrapCancelAllPingPongIrps(WrapExt);

        for (i = 0; i < WrapExt->IntReadWrap.NumPingPongs; i++){

            if (WrapExt->IntReadWrap.PingPongs[i].urb) {
                ExFreePool(WrapExt->IntReadWrap.PingPongs[i].urb);
                WrapExt->IntReadWrap.PingPongs[i].urb = NULL;
            }

            if (WrapExt->IntReadWrap.PingPongs[i].irp) {
                IoFreeIrp(WrapExt->IntReadWrap.PingPongs[i].irp);

            }

        }

        ExFreePool(WrapExt->IntReadWrap.PingPongs);
        WrapExt->IntReadWrap.PingPongs = NULL;

    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapDestroyPingPongs\n"));

}


/*
 ********************************************************************************
 *  UsbWrapEnqueueData
 ********************************************************************************
 *
 *
 */
VOID UsbWrapEnqueueData(
    IN PUSB_WRAPPER_EXTENSION WrapExt,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PLIST_ENTRY Queue
    )
{

    PUSB_WRAPPER_DATA_BLOCK dataBlock;
    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapEnqueueData\n"));
    dataBlock = ALLOC_MEM(NonPagedPool, sizeof(USB_WRAPPER_DATA_BLOCK), USBWRAP_TAG);

    if (!dataBlock) {
        //
        //  D'oh, out of resources
        //
        DBGPRINT(DBG_USBUTIL_ERROR, ("UsbWrapEnqueueData: Failed to allocate dataBlock\n"));

        // Make sure that we don't leak this memory
        if (Data) {
            FREE_MEM(Data);
        }
        return;
    }

    dataBlock->Buffer = Data;
    dataBlock->DataLen = DataLength;
    ExInterlockedInsertTailList(
        Queue,
        (PLIST_ENTRY) dataBlock,
        &WrapExt->IntReadWrap.QueueLock);

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapEnqueueData\n"));

}


/*
 ********************************************************************************
 *  UsbWrapDequeueData
 ********************************************************************************
 *
 *
 */
VOID UsbWrapDequeueData(
    IN  PUSB_WRAPPER_EXTENSION WrapExt,
    OUT PVOID *Data,
    OUT ULONG *DataLength,
    IN  PLIST_ENTRY Queue
    )
{

    PUSB_WRAPPER_DATA_BLOCK dataBlock;


    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapDequeueData\n"));
    dataBlock = (PUSB_WRAPPER_DATA_BLOCK) RemoveHeadList(Queue);

    if(!dataBlock) {

        *Data = NULL;
        *DataLength = 0;

    } else {

        *Data = dataBlock->Buffer;
        *DataLength = dataBlock->DataLen;

    }

    FREE_MEM(dataBlock);

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapDequeueData\n"));

}


/*
 ********************************************************************************
 *  UsbWrapGetTransferBuffer
 ********************************************************************************
 *
 *
 */
PVOID UsbWrapGetTransferBuffer(
    IN PUSB_WRAPPER_EXTENSION WrapExt
    )
{

    PVOID buffer;

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapGetTransferBuffer\n"));
    buffer = ALLOC_MEM(NonPagedPool, WrapExt->IntReadWrap.MaxTransferSize, USBWRAP_TAG);
    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapGetTransferBuffer\n"));
    return buffer;

}


/*
 ********************************************************************************
 *  UsbWrapFreeTransferBuffer
 ********************************************************************************
 *
 *
 */
VOID UsbWrapFreeTransferBuffer(
    IN PUSB_WRAPPER_EXTENSION WrapExt,
    PVOID Buffer
    )
{

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter:  UsbWrapFreeTransferBuffer\n"));

    if (Buffer != NULL) {

        FREE_MEM(Buffer);

    }

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  UsbWrapFreeTransferBuffer\n"));

}


/*
 ********************************************************************************
 *  UsbWrapReadData
 ********************************************************************************
 *
 *
 */
NTSTATUS UsbWrapReadData(
    IN PUSB_WRAPPER_EXTENSION WrapExt,
    IN PVOID Buffer,
    IN ULONG *BufferLength
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PUSB_WRAPPER_DATA_BLOCK dataBlock;
    KIRQL oldIrql;
    ULONG bytesCoppied;


    __try{

        KeAcquireSpinLock(&WrapExt->IntReadWrap.QueueLock,
                          &oldIrql);

        if(IsListEmpty(&WrapExt->IntReadWrap.SavedQueue)) {

            bytesCoppied = 0;
            status = STATUS_SUCCESS;
            __leave;

        }


        dataBlock = (PUSB_WRAPPER_DATA_BLOCK) WrapExt->IntReadWrap.SavedQueue.Flink;


        if(dataBlock->DataLen > *BufferLength) {

            status = STATUS_INVALID_PARAMETER;
            bytesCoppied = dataBlock->DataLen;

            __leave;

        }
        RemoveHeadList(&WrapExt->IntReadWrap.SavedQueue);
        bytesCoppied = 0;
        while(TRUE) {

            RtlCopyMemory(Buffer,
                          dataBlock->Buffer,
                          dataBlock->DataLen);

            bytesCoppied += dataBlock->DataLen;
            *BufferLength -= dataBlock->DataLen;
            (UCHAR*) Buffer += dataBlock->DataLen;

            FREE_MEM(dataBlock->Buffer);

            if(dataBlock->DataLen < WrapExt->IntReadWrap.MaxTransferSize) {
                // Found the end of the data
                FREE_MEM(dataBlock);
                __leave;
            }

            FREE_MEM(dataBlock);

            if(IsListEmpty(&WrapExt->IntReadWrap.SavedQueue)) {
                __leave;
            }


            dataBlock = (PUSB_WRAPPER_DATA_BLOCK) WrapExt->IntReadWrap.SavedQueue.Flink;


            if(dataBlock->DataLen > *BufferLength) {

                // Not enough buffer left for this transfer
                __leave;

            }

            RemoveHeadList(&WrapExt->IntReadWrap.SavedQueue);


        }


    } __finally {

        *BufferLength = bytesCoppied;
        KeReleaseSpinLock(&WrapExt->IntReadWrap.QueueLock,
                          oldIrql);

    }


    return status;

}

VOID
UsbWrapEmptyQueue(PUSB_WRAPPER_EXTENSION WrapExt,
                  PLIST_ENTRY Queue)
{
    __try
    {
        PUSB_WRAPPER_DATA_BLOCK dataBlock;

        if (!WrapExt) {
            __leave;
        }


        while (!IsListEmpty(Queue)) {

            dataBlock =
                (PUSB_WRAPPER_DATA_BLOCK) ExInterlockedRemoveHeadList(Queue,
                                                    &WrapExt->IntReadWrap.QueueLock);
            FREE_MEM(dataBlock->Buffer);
            FREE_MEM(dataBlock);

        }

    }

    __finally
    {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbd\usbd.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    USBD.C

Abstract:



Environment:

    kernel mode only

Notes:


Revision History:

    09-29-95 : created
    07-19-96 : removed device object

--*/

#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"        //public data structures
#include "hcdi.h"
#include "usbd.h"        //private data strutures


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    NT status code

--*/
{
    // This function is never called

    return STATUS_SUCCESS;
}


#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBD_GetRegistryKeyValue)
#endif
#endif


NTSTATUS
USBD_GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    PAGED_CODE();
    RtlInitUnicodeString(&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) +
            KeyNameStringLength + DataLength;

    fullInfo = ExAllocatePoolWithTag(PagedPool, length, USBD_TAG);
    USBD_KdPrint(3, ("' USBD_GetRegistryKeyValue buffer = 0x%x\n", fullInfo));

    if (fullInfo) {
        ntStatus = ZwQueryValueKey(Handle,
                        &keyName,
                        KeyValueFullInformation,
                        fullInfo,
                        length,
                        &length);

        if (NT_SUCCESS(ntStatus)){
            USBD_ASSERT(DataLength == fullInfo->DataLength);
            RtlCopyMemory(Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, DataLength);
        }

        ExFreePool(fullInfo);
    }

    return ntStatus;
}



#ifdef USBD_DRIVER      // USBPORT supercedes most of USBD, so we will remove
                        // the obsolete code by compiling it only if
                        // USBD_DRIVER is set.



#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBD_GetPdoRegistryParameters)
#pragma alloc_text(PAGE, USBD_GetGlobalRegistryParameters)
#endif
#endif


// global flag to force double buffering
// bulk - ins
UCHAR ForceDoubleBuffer = 0;

// global flag to force fast iso
// iso - outs
UCHAR ForceFastIso = 0;


NTSTATUS
USBD_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:
    
    This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
    ValueType - The type of the value
    ValueData - The data for the value.
    ValueLength - The length of ValueData.
    Context - A pointer to the CONFIG structure.
    EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    USBD_KdPrint(2, ("'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));
    
    switch (ValueType) {
    case REG_DWORD: 
        *(PVOID*)EntryContext = *(PVOID*)ValueData;
        break;
    case REG_BINARY:
        // we are only set up to read a byte
        RtlCopyMemory(EntryContext, ValueData, 1);
        break;
    default:
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
} 


NTSTATUS 
USBD_GetGlobalRegistryParameters(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PULONG ComplienceFlags,
    IN OUT PULONG DiagnosticFlags,
    IN OUT PULONG DeviceHackFlags
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UCHAR toshibaLegacyFlags = 0;
    RTL_QUERY_REGISTRY_TABLE QueryTable[4];
    PWCHAR usb  = L"usb";
    
    PAGED_CODE();
    
    //
    // Set up QueryTable to do the following:
    //

    // legacy flag
    QueryTable[0].QueryRoutine = USBD_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = LEGACY_TOSHIBA_USB_KEY;
    QueryTable[0].EntryContext = &toshibaLegacyFlags;
    QueryTable[0].DefaultType = REG_BINARY;
    QueryTable[0].DefaultData = &toshibaLegacyFlags;
    QueryTable[0].DefaultLength = sizeof(toshibaLegacyFlags);

    // double buffer flag
    // this turns on the double buffer flag for all
    // bulk - INs for testing purposes

    QueryTable[1].QueryRoutine = USBD_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = L"ForceDoubleBuffer";
    QueryTable[1].EntryContext = &ForceDoubleBuffer;
    QueryTable[1].DefaultType = REG_BINARY;
    QueryTable[1].DefaultData = &ForceDoubleBuffer;
    QueryTable[1].DefaultLength = sizeof(ForceDoubleBuffer);

    // fast iso flag
    // this turns on the double buffer flag for all
    // iso - OUTs for testing purposes
    
    QueryTable[2].QueryRoutine = USBD_GetConfigValue;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = L"ForceFastIso";
    QueryTable[2].EntryContext = &ForceFastIso;
    QueryTable[2].DefaultType = REG_BINARY;
    QueryTable[2].DefaultData = &ForceFastIso;
    QueryTable[2].DefaultLength = sizeof(ForceFastIso);
    

    //
    // Stop
    //
    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = 0;
    QueryTable[3].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
//                 RTL_REGISTRY_ABSOLUTE,		// RelativeTo
                RTL_REGISTRY_SERVICES,
//                 UnicodeRegistryPath->Buffer,	// Path
                usb,      
                QueryTable,					// QurryTable
                NULL,						// Context
                NULL);						// Environment

    USBD_KdPrint(1, ("<Global Parameters>\n"));
    
    if (NT_SUCCESS(ntStatus)) {
    
        USBD_KdPrint(1, ("LegacyToshibaUSB = 0x%x\n", 
            toshibaLegacyFlags)); 
        if (toshibaLegacyFlags) {            
            *ComplienceFlags |= 1;                    
        }     

        USBD_KdPrint(1, ("ForceDoubleBuffer = 0x%x\n", 
            ForceDoubleBuffer)); 

        USBD_KdPrint(1, ("ForceFastIso = 0x%x\n", 
            ForceFastIso));      
    }        

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }
    
    return ntStatus;
}


NTSTATUS 
USBD_GetPdoRegistryParameters (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PULONG ComplienceFlags,
    IN OUT PULONG DiagnosticFlags,
    IN OUT PULONG DeviceHackFlags
    )
/*++

Routine Description:
    
Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    WCHAR supportNonCompKey[] = SUPPORT_NON_COMP_KEY;
    WCHAR diagnosticModeKey[] = DAIGNOSTIC_MODE_KEY;
    WCHAR deviceHackKey[] = DEVICE_HACK_KEY;

    PAGED_CODE();

    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

                                     
    if (NT_SUCCESS(ntStatus)) {
/*
        RtlInitUnicodeString(&keyName, L"DeviceFoo");
        ZwSetValueKey(handle,
                      &keyName,
                      0,
                      REG_DWORD,
                      ComplienceFlags,
                      sizeof(*ComplienceFlags));
*/

        USBD_GetRegistryKeyValue(handle,
                                 supportNonCompKey,
                                 sizeof(supportNonCompKey),
                                 ComplienceFlags,
                                 sizeof(*ComplienceFlags));

        USBD_GetRegistryKeyValue(handle,
                                 diagnosticModeKey,
                                 sizeof(diagnosticModeKey),
                                 DiagnosticFlags,
                                 sizeof(*DiagnosticFlags));

        USBD_GetRegistryKeyValue(handle,
                                 deviceHackKey,
                                 sizeof(deviceHackKey),
                                 DeviceHackFlags,
                                 sizeof(*DeviceHackFlags));                                 
                                     
        ZwClose(handle);
    }

    USBD_KdPrint(3, ("' RtlQueryRegistryValues status 0x%x,  comp %x diag %x\n", 
        ntStatus, *ComplienceFlags, *DiagnosticFlags));

    return ntStatus;
}


#endif      // USBD_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\intread.h ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        INTREAD.H

Abstract:

        Public interface for generic USB routines - must be called at PASSIVE_LEVEL

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        06/13/2001 : created

Authors:

        Tom Green


****************************************************************************/

#ifndef __INTREAD_H__
#define __INTREAD_H__

//#include "usbutil.h"

#define USBWRAP_BUFFER_GUARD 'draG'
#define USBWRAP_TAG 'prwU'

#define PINGPONG_START_READ     0x01
#define PINGPONG_END_READ       0x02
#define PINGPONG_IMMEDIATE_READ 0x03
#define USBWRAP_INCOMING_QUEUE  0x01
#define USBWRAP_SAVED_QUEUE     0x02

#define PUMP_STATE_RUNNING      0x00
#define PUMP_STATE_STOPPED      0x01
#define PUMP_STATE_ERROR        0x02

typedef NTSTATUS (*INTERRUPT_CALLBACK)(IN PVOID         Context, 
                                       IN PVOID         Buffer,
                                       ULONG            BufferLength,
                                       ULONG            NotificationType,
                                       OUT PBOOLEAN     QueueData);

typedef struct _USB_WRAPPER_EXTENSION *PUSB_WRAPPER_EXTENSION;
typedef struct _USB_WRAPPER_PINGPONG {

    #define PINGPONG_SIG (ULONG)'ppwU'
    ULONG           sig;

    //
    // Read interlock value to protect us from running out of stack space
    //
    ULONG               ReadInterlock;

    PIRP    irp;
    PURB    urb;
    PUCHAR  reportBuffer;
    LONG    weAreCancelling;

    KEVENT sentEvent;       // When a read has been sent.
    KEVENT pumpDoneEvent;   // When the read loop is finally exitting.

    PUSB_WRAPPER_EXTENSION   myWrapExt;

    /*
     *  Timeout context for back-off algorithm applied to broken devices.
     */
    KTIMER          backoffTimer;
    KDPC            backoffTimerDPC;
    LARGE_INTEGER   backoffTimerPeriod; // in negative 100-nsec units

} USB_WRAPPER_PINGPONG, *PUSB_WRAPPER_PINGPONG;
      
typedef struct _USB_WRAPPER_DATA_BLOCK {
    LIST_ENTRY     ListEntry;
    ULONG           DataLen;
    PVOID           Buffer;

} USB_WRAPPER_DATA_BLOCK, *PUSB_WRAPPER_DATA_BLOCK;

typedef struct _INTERRUPT_READ_WRAPPER {

    PUSBD_PIPE_INFORMATION  InterruptPipe;

    INTERRUPT_CALLBACK      ClientCallback;
                            
    PVOID                   ClientContext;
        
    ULONG                   MaxTransferSize;
    
    ULONG                   NotificationTypes;

    PUSB_WRAPPER_PINGPONG   PingPongs;

    ULONG                   NumPingPongs;

    ULONG                   MaxReportSize;

    ULONG                   OutstandingRequests;

    LIST_ENTRY              SavedQueue;

    LIST_ENTRY              IncomingQueue;

    KSPIN_LOCK              QueueLock;

    ULONG                   PumpState;

    ULONG                   HandlingError;

    ULONG                   WorkItemRunning;

    ULONG                   ErrorCount;

    ULONG                   TransferCount;

} INTERRUPT_READ_WRAPPER, *PINTERRUPT_READ_WRAPPER;
            
NTSTATUS UsbWrapInitializeInterruptReadData(
    IN PUSB_WRAPPER_EXTENSION    WrapExtension,
    IN PUSBD_PIPE_INFORMATION    InterruptPipe,
    IN INTERRUPT_CALLBACK        DriverCallback,
    IN PVOID                     DriverContext,
    IN ULONG                     MaxTransferSize,
    IN ULONG                     NotificationTypes,
    IN ULONG                     PingPongCount                    
    );

VOID UsbWrapEnqueueData(
    IN PUSB_WRAPPER_EXTENSION WrapExt, 
    IN PVOID Data,
    IN ULONG DataLength,
    IN PLIST_ENTRY Queue
    );

VOID UsbWrapDequeueData(
    IN  PUSB_WRAPPER_EXTENSION WrapExt,
    OUT PVOID *Data,
    OUT ULONG *DataLength,
    IN  PLIST_ENTRY Queue
    );

PVOID UsbWrapGetTransferBuffer(
    IN PUSB_WRAPPER_EXTENSION WrapExt
    );

VOID UsbWrapFreeTransferBuffer(
    IN PUSB_WRAPPER_EXTENSION WrapExt,
    PVOID Buffer
    );

NTSTATUS UsbWrapInitializePingPongIrps(
    PUSB_WRAPPER_EXTENSION WrapExtension
    );

NTSTATUS UsbWrapSubmitInterruptRead(
    IN PUSB_WRAPPER_EXTENSION WrapExtension, 
    PUSB_WRAPPER_PINGPONG PingPong, 
    BOOLEAN *IrpSent
    );

USB_WRAPPER_PINGPONG *GetPingPongFromIrp(
    PUSB_WRAPPER_EXTENSION WrapExt, 
    PIRP irp
    );

NTSTATUS UsbWrapInterruptReadComplete(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context
    );

NTSTATUS UsbWrapStartAllPingPongs(
    PUSB_WRAPPER_EXTENSION WrapExt
    );

VOID UsbWrapCancelAllPingPongIrps(
    PUSB_WRAPPER_EXTENSION WrapExt
    );

VOID UsbWrapDestroyPingPongs(
    PUSB_WRAPPER_EXTENSION WrapExt
    );

VOID UsbWrapPingpongBackoffTimerDpc(    
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS UsbWrapReadData(
    IN PUSB_WRAPPER_EXTENSION WrapExt, 
    IN PVOID Buffer,
    IN ULONG *BufferLength
    );

VOID UsbWrapCancelPingPongIrp(
    USB_WRAPPER_PINGPONG *PingPong
    );

VOID
UsbWrapEmptyQueue(
    PUSB_WRAPPER_EXTENSION WrapExt, 
    PLIST_ENTRY Queue
    );








          

#endif // __INTREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\t.c ===
#include "pch.h"
VOID bar() { DbgPrint("* this is bar()\n"); }

NTSTATUS DllUnload() { DbgPrint("u-unload\n"); return STATUS_SUCCESS; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\usbdbg.h ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        USBDBG.H

Abstract:

        Debugging aids for USB wrapper

Environment:

        Kernel and User Mode

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        01/08/2001 : created

Authors:

        Tom Green


****************************************************************************/

#ifndef __USBDBG_H__
#define __USBDBG_H__


#if DBG

#define DBGPRINT(level, _x_)                \
{                                           \
    if(level & USBUtil_DebugTraceLevel)  \
    {                                       \
        USBUtil_DbgPrint("USBWrap: ");   \
        USBUtil_DbgPrint _x_ ;           \
    }                                       \
}


#else

#define DBGPRINT(level, _x_)

#endif // DBG

#define ALLOC_MEM(type, amount, tag)    ExAllocatePoolWithTag(type, amount, tag)
#define FREE_MEM(memPtr)                ExFreePool(memPtr)




#endif // __USBDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\pch.h ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        PCH.H

Abstract:

        Precompiled header files
        
Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        01/08/2001 : created

Authors:

        Tom Green


****************************************************************************/

#ifndef __PCH_H__
#define __PCH_H__

// need this to strip warnings on "PAGED_CODE();" macro
#pragma warning( disable : 4127 ) // conditional expression is constant

#pragma warning( push )
#pragma warning( disable : 4115 ) // named type definition in parentheses 
#pragma warning( disable : 4127 ) // conditional expression is constant
#pragma warning( disable : 4200 ) // zero-sized array in struct/union
#pragma warning( disable : 4201 ) // nameless struct/union
#pragma warning( disable : 4214 ) // bit field types other than int
#pragma warning( disable : 4514 ) // unreferenced inline function has been removed
#include <wdm.h>
#pragma warning( pop )

// #pragma warning( disable : 4200 ) // zero-sized array in struct/union - (ntddk.h resets this to default)


#include <stdio.h>
#include <stdlib.h>

#endif // __PCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\usbpriv.h ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        USBPRIV.H

Abstract:

        Private stuff for generic USB routines - must be called at PASSIVE_LEVEL

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        03/28/2001 : created

Authors:

        Tom Green


****************************************************************************/

#ifndef __USBPRIV_H__
#define __USBPRIV_H__

#include "intread.h"



// private macros

#define ONE_MILLISECOND_TIMEOUT         (-10000)

#define SELECTIVE_SUSPEND_HANDLE        0x0001
#define INTERRUPT_READ_HANDLE           0x0002

#define USBLIB_TAG                      'LBSU'

// private data structures

typedef struct _USB_WRAPPER_EXTENSION {

    PDEVICE_OBJECT          LowerDeviceObject;

    PDEVICE_OBJECT          DeviceObject;
   
    PIO_REMOVE_LOCK         RemoveLock;
    
    INTERRUPT_READ_WRAPPER  IntReadWrap;

    ULONG                   RemLockSize;
                             
} USB_WRAPPER_EXTENSION, *PUSB_WRAPPER_EXTENSION;

typedef struct _USB_WRAPPER_WORKITEM_CONTEXT {
    
    PIO_WORKITEM            WorkItem;

    PUSB_WRAPPER_EXTENSION  WrapExtension;

    PUSB_WRAPPER_PINGPONG   PingPong;

} USB_WRAPPER_WORKITEM_CONTEXT, *PUSB_WRAPPER_WORKITEM_CONTEXT;

typedef struct _SELECTIVE_SUSPEND_WRAPPER
{
    ULONG               WrapperType;
    PDEVICE_OBJECT      LowerDevObj;
} SELECTIVE_SUSPEND_WRAPPER, *PSELECTIVE_SUSPEND_WRAPPER;


// private prototypes

NTSTATUS
USBCallSyncCompletionRoutine(IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP           Irp,
                             IN PVOID          Context);


// local data

#if DBG


#endif



#endif // __USBPRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\usbutil.c ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        USBUTIL.C

Abstract:

        Generic USB routines - must be called at PASSIVE_LEVEL

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        01/08/2001 : created

Authors:

        Tom Green


****************************************************************************/


#include "pch.h"

#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>

#include "intread.h"
#include "usbutil.h"
#include "usbpriv.h"
#include "usbdbg.h"

#ifdef ALLOC_PRAGMA

#endif // ALLOC_PRAGMA

#if DBG
ULONG USBUtil_DebugTraceLevel = 0;
PUSB_WRAP_PRINT USBUtil_DbgPrint = DbgPrint;
#endif

/************************************************************************/
/*                          USBCallSync                                 */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Send URB down USB stack. Synchronous call.                      */
/*      Caller is responsible for URB (allocating and freeing)          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj         - pointer to a device object                */
/*      Urb                 - pointer to URB                            */
/*      MillisecondsTimeout - milliseconds to wait for completion       */
/*      RemoveLock          - pointer to remove lock                    */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBCallSyncEx(IN PDEVICE_OBJECT       LowerDevObj,
              IN PURB                 Urb,
              IN LONG                 MillisecondsTimeout,
              IN PIO_REMOVE_LOCK      RemoveLock,
              IN ULONG                RemLockSize)
{
    NTSTATUS            ntStatus        = STATUS_SUCCESS;
    PIRP                irp             = NULL;
    KEVENT              event;
    PIO_STACK_LOCATION  nextStack;
    BOOLEAN             gotRemoveLock   = FALSE;


    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBCallSync\n"));

        ntStatus = IoAcquireRemoveLockEx(RemoveLock,
                                         LowerDevObj,
                                         __FILE__,
                                         __LINE__,
                                         RemLockSize);

        if(NT_SUCCESS(ntStatus))
        {
            gotRemoveLock = TRUE;
        }
        else
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBCallSync: Pending remove on device\n"));
            __leave;
        }


        // do some parameter checking before going too far
        if(LowerDevObj == NULL || Urb == NULL || MillisecondsTimeout < 0)
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBCallSync: Invalid paramemter passed in\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // issue a synchronous request
        KeInitializeEvent(&event, SynchronizationEvent, FALSE);

        irp = IoAllocateIrp(LowerDevObj->StackSize, FALSE);

        // check to see if we allocated an Irp
        if(!irp)
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBCallSync: Couldn't allocate Irp\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        // Set the Irp parameters
        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

        nextStack->Parameters.Others.Argument1 = Urb;

        // Set the completion routine, which will signal the event
        IoSetCompletionRoutine(irp,
                               USBCallSyncCompletionRoutine,
                               &event,
                               TRUE,    // InvokeOnSuccess
                               TRUE,    // InvokeOnError
                               TRUE);   // InvokeOnCancel

        ntStatus = IoCallDriver(LowerDevObj, irp);

        // block on pending request
        if(ntStatus == STATUS_PENDING)
        {
            LARGE_INTEGER   timeout;
            PLARGE_INTEGER  pTimeout = NULL;

            // check and see if they have passed in a number of milliseconds to time out
            if(MillisecondsTimeout)
            {
                // setup timeout
                timeout = RtlEnlargedIntegerMultiply(ONE_MILLISECOND_TIMEOUT, MillisecondsTimeout);
                pTimeout = &timeout;
            }

            ntStatus = KeWaitForSingleObject(&event,
                                             Executive,
                                             KernelMode,
                                             FALSE,
                                             pTimeout);

            // if it timed out, cancel the irp and return appropriate status
            if(ntStatus == STATUS_TIMEOUT)
            {
                ntStatus = STATUS_IO_TIMEOUT;

                // Cancel the Irp we just sent.
                IoCancelIrp(irp);

                // Wait until the cancel completes
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            }
            else
            {
                // didn't timeout, so return current status
                ntStatus = irp->IoStatus.Status;
            }
        }

    }

    __finally
    {
        if(gotRemoveLock)
        {
            IoReleaseRemoveLockEx(RemoveLock, LowerDevObj, RemLockSize);
        }

        if(irp)
        {
            IoFreeIrp(irp);
        }

        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBCallSync\n"));
    }

    return ntStatus;
} // USBCallSync

/************************************************************************/
/*                      USBCallSyncCompletionRoutine                    */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Completion routine for USB sync request.                        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to device object                         */
/*      Irp          - pointer to an I/O Request Packet                 */
/*      Context      - pointer to context of call                       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBCallSyncCompletionRoutine(IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP           Irp,
                             IN PVOID          Context)
{
    PKEVENT kevent;

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBCallSyncCompletionRoutine\n"));

    kevent = (PKEVENT) Context;

    KeSetEvent(kevent, IO_NO_INCREMENT, FALSE);

    DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBCallSyncCompletionRoutine\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
} // USBCallSyncCompletionRoutine



/************************************************************************/
/*                      USBVendorRequest                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Issue USB vendor specific request                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj  - pointer to a device object                       */
/*      Request      - request field of vendor specific command         */
/*      Value        - value field of vendor specific command           */
/*      Index        - index field of vendor specific command           */
/*      Buffer       - pointer to data buffer                           */
/*      BufferSize   - data buffer length                               */
/*      Read         - data direction flag                              */
/*      Timeout      - number of milliseconds to wait for completion    */
/*      RemoveLock   - pointer to remove lock                           */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBVendorRequestEx(IN PDEVICE_OBJECT  LowerDevObj,
                   IN REQUEST_RECIPIENT Recipient,
                   IN UCHAR           Request,
                   IN USHORT          Value,
                   IN USHORT          Index,
                   IN OUT PVOID       Buffer,
                   IN OUT PULONG      BufferSize,
                   IN BOOLEAN         Read,
                   IN LONG            MillisecondsTimeout,
                   IN PIO_REMOVE_LOCK RemoveLock,
                   IN ULONG           RemLockSize)
{
    NTSTATUS            ntStatus    = STATUS_SUCCESS;
    PURB                urb         = NULL;
    ULONG               size;
    ULONG               length;
    USHORT              function;

    PAGED_CODE();

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBVendorRequest\n"));

        // do some parameter checking before going too far
        if(LowerDevObj == NULL || MillisecondsTimeout < 0)
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBClassRequest: Invalid paramemter passed in\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // length of buffer passed in
        length = BufferSize ? *BufferSize : 0;

        // set the buffer length to 0 in case of error
        if(BufferSize)
        {
            *BufferSize = 0;
        }

        size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        // allocate memory for the Urb
        urb = ALLOC_MEM(NonPagedPool, size, USBLIB_TAG);

        // check to see if we allocated a urb
        if(!urb)
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBVendorRequest: Couldn't allocate URB\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        switch (Recipient) {
        case Device:
            function = URB_FUNCTION_VENDOR_DEVICE;
            break;
        case Interface:
            function = URB_FUNCTION_VENDOR_INTERFACE;
            break;
        case Endpoint:
            function = URB_FUNCTION_VENDOR_ENDPOINT;
            break;
        case Other:
            function = URB_FUNCTION_VENDOR_OTHER;
            break;
        }

        UsbBuildVendorRequest(urb, function,
                              (USHORT) size,
                              Read ? USBD_TRANSFER_DIRECTION_IN : USBD_TRANSFER_DIRECTION_OUT,
                              0, Request, Value, Index, Buffer, NULL, length, NULL);

        ntStatus = USBCallSyncEx(LowerDevObj,
                                 urb,
                                 MillisecondsTimeout,
                                 RemoveLock,
                                 RemLockSize);

        // get length of buffer
        if(BufferSize)
        {
            *BufferSize = urb->UrbControlVendorClassRequest.TransferBufferLength;
        }
    }

    __finally
    {
        if(urb)
        {
            FREE_MEM(urb);
        }

        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBVendorRequest\n"));
    }

    return ntStatus;
} // USBVendorRequest


/************************************************************************/
/*                      USBClassRequest                                 */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Issue USB Class specific request                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj  - pointer to a device object                       */
/*      Recipient    - request recipient
/*      Request      - request field of class specific command          */
/*      Value        - value field of class specific command            */
/*      Index        - index field of class specific command            */
/*      Buffer       - pointer to data buffer                           */
/*      BufferSize   - data buffer length                               */
/*      Read         - data direction flag                              */
/*      RemoveLock   - pointer to remove lock                           */
/*      Timeout      - number of milliseconds to wait for completion    */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBClassRequestEx(IN PDEVICE_OBJECT   LowerDevObj,
                  IN REQUEST_RECIPIENT Recipient,
                  IN UCHAR            Request,
                  IN USHORT           Value,
                  IN USHORT           Index,
                  IN OUT PVOID        Buffer,
                  IN OUT PULONG       BufferSize,
                  IN BOOLEAN          Read,
                  IN LONG             MillisecondsTimeout,
                  IN PIO_REMOVE_LOCK  RemoveLock,
                  IN ULONG            RemLockSize)
{
    NTSTATUS            ntStatus    = STATUS_SUCCESS;
    PURB                urb         = NULL;
    ULONG               size;
    ULONG               length;
    USHORT              function;


    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBClassRequest\n"));

        // do some parameter checking before going too far
        if(LowerDevObj == NULL || MillisecondsTimeout < 0)
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBClassRequest: Invalid paramemter passed in\n"));
            ntStatus = STATUS_INVALID_PARAMETER;
            __leave;
        }

        // length of buffer passed in
        length = BufferSize ? *BufferSize : 0;

        // set the buffer length to 0 in case of error
        if(BufferSize)
        {
            *BufferSize = 0;
        }

        size = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);

        // allocate memory for the Urb
        urb = ALLOC_MEM(NonPagedPool, size, USBLIB_TAG);

        // check to see if we allocated a urb
        if(!urb)
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBClassRequest: Couldn't allocate URB\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        switch (Recipient) {
        case Device:
            function = URB_FUNCTION_CLASS_DEVICE;
            break;
        case Interface:
            function = URB_FUNCTION_CLASS_INTERFACE;
            break;
        case Endpoint:
            function = URB_FUNCTION_CLASS_ENDPOINT;
            break;
        case Other:
            function = URB_FUNCTION_CLASS_OTHER;
            break;
        }

        UsbBuildVendorRequest(urb, function,
                              (USHORT) size,
                              Read ? USBD_TRANSFER_DIRECTION_IN : USBD_TRANSFER_DIRECTION_OUT,
                              0, Request, Value, Index, Buffer, NULL, length, NULL);

        ntStatus = USBCallSyncEx(LowerDevObj,
                                 urb,
                                 MillisecondsTimeout,
                                 RemoveLock,
                                 RemLockSize);

        // get length of buffer
        if(BufferSize)
        {
            *BufferSize = urb->UrbControlVendorClassRequest.TransferBufferLength;
        }
    }

    __finally
    {
        if(urb)
        {
            FREE_MEM(urb);
        }

        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBClassRequest\n"));
    }

    return ntStatus;
} // USBClassRequest


/************************************************************************/
/*                    USBInitializeInterruptTransfers                   */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Initialize interrupt read pipe                                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject   - pointer to the device object                   */
/*      LowerDevObj    - pointer to the lower device object             */
/*      Buffer         - pointer to buffer for data from interrupt pipe */
/*      BuffSize       - size of buffer passed in                       */
/*      InterruptPipe  - pipe descriptor                                */
/*      DriverContext  - context passed to driver callback routine      */
/*      DriverCallback - driver routines called on completion           */
/*      RemoveLock     - pointer to remove lock for device              */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      USB_WRAPPER_HANDLE                                              */
/*                                                                      */
/************************************************************************/
USB_WRAPPER_HANDLE
USBInitializeInterruptTransfersEx(IN PDEVICE_OBJECT            DeviceObject,
                                  IN PDEVICE_OBJECT            LowerDevObj,
                                  IN ULONG                     MaxTransferSize,
                                  IN PUSBD_PIPE_INFORMATION    InterruptPipe,
                                  IN PVOID                     DriverContext,
                                  IN INTERRUPT_CALLBACK        DriverCallback,
                                  IN ULONG                     NotificationTypes,
                                  IN ULONG                     PingPongCount,
                                  IN PIO_REMOVE_LOCK           RemoveLock,
                                  IN ULONG                     RemLockSize)
{
    PUSB_WRAPPER_EXTENSION  pUsbWrapperExtension = NULL;
    ULONG                   size;
    NTSTATUS                status;
    BOOLEAN                 error = FALSE;


    PAGED_CODE();

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBInitializeInterruptTransfers\n"));

        //
        // Parameter Checking
        //

        if ((LowerDevObj == NULL) || (InterruptPipe == NULL) || (RemoveLock == NULL)) {

            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBInitializeInterruptTransfers: Invalid paramemter passed in\n"));
            error = TRUE;
            __leave;

        }

        //
        // Allocate UsbWrapperExtension
        //

        pUsbWrapperExtension = ALLOC_MEM(NonPagedPool,
                                         sizeof(USB_WRAPPER_EXTENSION),
                                         USBLIB_TAG);

        if(!pUsbWrapperExtension)
        {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBInitializeInterruptTransfers: Couldn't allocate Wrapper Extension\n"));
            error = TRUE;
            __leave;
        }

        //
        // Initialize UsbWrapperExtension
        //
        pUsbWrapperExtension->DeviceObject      = DeviceObject;
        pUsbWrapperExtension->LowerDeviceObject = LowerDevObj;
        pUsbWrapperExtension->RemoveLock        = RemoveLock;
        pUsbWrapperExtension->RemLockSize       = RemLockSize;

        //
        //Initialize Interrupt Read Wrap
        //
        UsbWrapInitializeInterruptReadData(
            pUsbWrapperExtension,
            InterruptPipe,
            DriverCallback,
            DriverContext,
            MaxTransferSize,
            NotificationTypes,
            PingPongCount);

        InterlockedExchange(&pUsbWrapperExtension->IntReadWrap.HandlingError, 0);


        //
        // Init ping-pong stuff
        //
        status = UsbWrapInitializePingPongIrps(pUsbWrapperExtension);
        if(!NT_SUCCESS(status)) {
            DBGPRINT(DBG_USBUTIL_USB_ERROR, ("USBInitializeInterruptTransfers: Couldn't initialize ping pong irps\n"));
            error = TRUE;
            __leave;
        }

        __leave;
    }

    __finally
    {
        if (error && pUsbWrapperExtension)  {

            if (pUsbWrapperExtension->IntReadWrap.PingPongs) {

                UsbWrapDestroyPingPongs(pUsbWrapperExtension);

            }

            FREE_MEM(pUsbWrapperExtension);
        }

        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBInitializeInterruptTransfers\n"));
    }

    return (USB_WRAPPER_HANDLE) pUsbWrapperExtension;
} // USBInitializeInterruptTransfers


/************************************************************************/
/*                    USBStartInterruptTransfers                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Start transfers on interrupt pipe                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle  - pointer to wrapper handle from Init call       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBStartInterruptTransfers(IN USB_WRAPPER_HANDLE WrapperHandle)
{
    PUSB_WRAPPER_EXTENSION wrapExt = (PUSB_WRAPPER_EXTENSION) WrapperHandle;
    NTSTATUS status;

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBStartInterruptTransfers\n"));

        if (!wrapExt) {
            status = STATUS_INVALID_PARAMETER;
            __leave;
        }

        ASSERT(IsListEmpty(&wrapExt->IntReadWrap.IncomingQueue));

        status = UsbWrapStartAllPingPongs(wrapExt);


    }

    __finally
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBStartInterruptTransfers\n"));

    }

    return status;

}


/************************************************************************/
/*                    USBStopInterruptTransfers                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Stop transfers on interrupt pipe and free resources             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle  - pointer to wrapper handle from Init call       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBStopInterruptTransfers(IN USB_WRAPPER_HANDLE WrapperHandle)
{
    PUSB_WRAPPER_EXTENSION wrapExt = WrapperHandle;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();


    __try
    {

        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBStopInterruptTransfers\n"));

        if (!WrapperHandle) {

            status = STATUS_INVALID_PARAMETER;
            __leave;

        }

        InterlockedExchange(&wrapExt->IntReadWrap.PumpState,
                            PUMP_STOPPED);

        UsbWrapCancelAllPingPongIrps(wrapExt);
        UsbWrapEmptyQueue(wrapExt,
                          &wrapExt->IntReadWrap.IncomingQueue);
    }

    __finally
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBStopInterruptTransfers\n"));
    }


    return STATUS_SUCCESS;
} // USBStopInterruptTransfers


/************************************************************************/
/*                    USBReleaseInterruptTransfers                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Frees all resources allocated in                                */
/*              USBInitializeInterruptTransfers                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle  - pointer to wrapper handle from Init call       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBReleaseInterruptTransfers(IN USB_WRAPPER_HANDLE WrapperHandle)
{
    PUSB_WRAPPER_EXTENSION wrapExt = (PUSB_WRAPPER_EXTENSION) WrapperHandle;
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBReleaseInterruptTransfers\n"));

        if (!wrapExt) {

            status = STATUS_INVALID_PARAMETER;
            __leave;

        }

        UsbWrapDestroyPingPongs(wrapExt);

        UsbWrapEmptyQueue(wrapExt, &wrapExt->IntReadWrap.IncomingQueue);
        UsbWrapEmptyQueue(wrapExt, &wrapExt->IntReadWrap.SavedQueue);

        FREE_MEM(wrapExt);
        wrapExt = NULL;

    }

    __finally
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBReleaseInterruptTransfers\n"));
    }
    return status;
}


/************************************************************************/
/*                    USBStartSelectiveSuspend                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Start selective suspend support for device                      */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj - pointer to device object                          */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      USB_WRAPPER_HANDLE                                              */
/*                                                                      */
/************************************************************************/
USB_WRAPPER_HANDLE
USBStartSelectiveSuspend(IN PDEVICE_OBJECT LowerDevObj)
{
    PAGED_CODE();

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBStartSelectiveSuspend\n"));
    }

    __finally
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBStartSelectiveSuspend\n"));
    }


    return NULL;
} // USBStartSelectiveSuspend

/************************************************************************/
/*                    USBStopSelectiveSuspend                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Stop selective suspend support for device                       */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle - wrapper handle returned by start routine        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBStopSelectiveSuspend(IN USB_WRAPPER_HANDLE WrapperHandle)
{
    PAGED_CODE();

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBStopSelectiveSuspend\n"));
    }

    __finally
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBStopSelectiveSuspend\n"));
    }

    return STATUS_SUCCESS;
} // USBStopSelectiveSuspend

/************************************************************************/
/*                          USBRequestIdle                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Idle request for device                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle - wrapper handle returned by start routine        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBRequestIdle(IN USB_WRAPPER_HANDLE WrapperHandle)
{
    PAGED_CODE();

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBRequestIdle\n"));
    }

    __finally
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBRequestIdle\n"));
    }

    return STATUS_SUCCESS;
} // USBRequestIdle

/************************************************************************/
/*                          USBRequestWake                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Wake request for device                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle - wrapper handle returned by start routine        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBRequestWake(IN USB_WRAPPER_HANDLE WrapperHandle)
{
    PAGED_CODE();

    __try
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Enter: USBRequestWake\n"));
    }

    __finally
    {
        DBGPRINT(DBG_USBUTIL_ENTRY_EXIT, ("Exit:  USBRequestWake\n"));
    }

    return STATUS_SUCCESS;
} // USBRequestWake
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\usb\usbutil\usbutil.h ===
/***************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

        USBUTIL.H

Abstract:

        Public interface for generic USB routines - must be called at PASSIVE_LEVEL

Environment:

        Kernel Mode Only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Revision History:

        01/08/2001 : created

Authors:

        Tom Green


****************************************************************************/


#ifndef __USBUTIL_H__
#define __USBUTIL_H__

//#include "intread.h"

#define USBWRAP_NOTIFICATION_READ_COMPLETE 0x01
#define USBWRAP_NOTIFICATION_READ_ERROR    0x02
#define USBWRAP_NOTIFICATION_READ_COMPLETE_DIRECT 0x04
#define USBWRAP_NOTIFICATION_BUFFER_CLIENT_FREE 0x10
#define PUMP_STOPPED 0x0
#define PUMP_STARTED 0x01

#ifndef PINGPONG_COUNT
#define PINGPONG_COUNT 3
#endif


#define USBInitializeBulkTransfers USBInitializeInterruptTransfers
#define USBStartBulkTransfers USBStartInterruptTransfers
#define USBStopBulkTransfers USBStopInterruptTransfers
#define USBReleaseBulkTransfers USBReleaseInterruptTransfers

#if DBG


#define DBG_USBUTIL_ERROR               0x0001
#define DBG_USBUTIL_ENTRY_EXIT          0x0002
#define DBG_USBUTIL_FATAL_ERROR         0x0004
#define DBG_USBUTIL_USB_ERROR           0x0008
#define DBG_USBUTIL_DEVICE_ERROR        0x0010
#define DBG_USBUTIL_PNP_ERROR           0x0020
#define DBG_USBUTIL_POWER_ERROR         0x0040
#define DBG_USBUTIL_OTHER_ERROR         0x0080
#define DBG_USBUTIL_TRACE               0x0100

extern ULONG USBUtil_DebugTraceLevel;

typedef
ULONG
(__cdecl *PUSB_WRAP_PRINT)(
    PCH Format,
    ...
    );

extern PUSB_WRAP_PRINT USBUtil_DbgPrint;
#endif // DBG

typedef enum _REQUEST_RECIPIENT
{

    Device,
    Interface,
    Endpoint,
    Other

} REQUEST_RECIPIENT;


// prototype for callback into client driver for completion of interrupt requests
typedef NTSTATUS (*INTERRUPT_CALLBACK)(IN PVOID         Context,
                                       IN PVOID         Buffer,
                                       ULONG            BufferLength,
                                       ULONG            NotificationType,
                                       OUT PBOOLEAN     QueueData);

//typedef struct _USB_WRAPPER_PINGPONG *PUSB_WRAPPER_PINGPONG;
//typedef struct _INTERRUPT_READ_WRAPPER INTERRUPT_READ_WRAPPER;

typedef PVOID   USB_WRAPPER_HANDLE;

// prototypes


#define USBCallSync(LowerDevObj,Urb,MillisecondsTimeout,RemoveLock) \
    USBCallSyncEx(LowerDevObj,Urb,MillisecondsTimeout,RemoveLock, sizeof(IO_REMOVE_LOCK))


/************************************************************************/
/*                          USBCallSync                                 */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Send URB down USB stack. Synchronous call.                      */
/*      Caller is responsible for URB (allocating and freeing)          */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj         - pointer to a device object                */
/*      Urb                 - pointer to URB                            */
/*      MillisecondsTimeout - milliseconds to wait for completion       */
/*      RemoveLock          - pointer to remove lock                    */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBCallSyncEx(IN PDEVICE_OBJECT       LowerDevObj,
              IN PURB                 Urb,
              IN LONG                 MillisecondsTimeout,
              IN PIO_REMOVE_LOCK      RemoveLock,
              IN ULONG                RemLockSize);


#define USBVendorRequest(LowerDevObj, \
                         Recipient, \
                         Request, \
                         Value, \
                         Index, \
                         Buffer, \
                         BufferSize, \
                         Read, \
                         MillisecondsTimeout, \
                         RemoveLock) \
        USBVendorRequestEx(LowerDevObj, \
                           Recipient, \
                           Request, \
                           Value, \
                           Index, \
                           Buffer, \
                           BufferSize, \
                           Read, \
                           MillisecondsTimeout, \
                           RemoveLock, \
                           sizeof(IO_REMOVE_LOCK))

/************************************************************************/
/*                      USBVendorRequest                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Issue USB vendor specific request                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj  - pointer to a device object                       */
/*      Request      - request field of vendor specific command         */
/*      Value        - value field of vendor specific command           */
/*      Index        - index field of vendor specific command           */
/*      Buffer       - pointer to data buffer                           */
/*      BufferSize   - data buffer length                               */
/*      Read         - data direction flag                              */
/*      Timeout      - number of milliseconds to wait for completion    */
/*      RemoveLock   - pointer to remove lock                           */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBVendorRequestEx(IN PDEVICE_OBJECT  LowerDevObj,
                   IN REQUEST_RECIPIENT Recipient,
                   IN UCHAR           Request,
                   IN USHORT          Value,
                   IN USHORT          Index,
                   IN OUT PVOID       Buffer,
                   IN OUT PULONG      BufferSize,
                   IN BOOLEAN         Read,
                   IN LONG            MillisecondsTimeout,
                   IN PIO_REMOVE_LOCK RemoveLock,
                   IN ULONG           RemLockSize);



/************************************************************************/
/*                      USBClassRequest                                 */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Issue USB Class specific request                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj  - pointer to a device object                       */
/*      Request      - request field of class specific command          */
/*      Value        - value field of class specific command            */
/*      Index        - index field of class specific command            */
/*      Buffer       - pointer to data buffer                           */
/*      BufferSize   - data buffer length                               */
/*      Read         - data direction flag                              */
/*      RemoveLock   - pointer to remove lock                           */
/*      Timeout      - number of milliseconds to wait for completion    */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
#define USBClassRequest(LowerDevObj, \
                         Recipient, \
                         Request, \
                         Value, \
                         Index, \
                         Buffer, \
                         BufferSize, \
                         Read, \
                         MillisecondsTimeout, \
                         RemoveLock) \
        USBClassRequestEx(LowerDevObj, \
                           Recipient, \
                           Request, \
                           Value, \
                           Index, \
                           Buffer, \
                           BufferSize, \
                           Read, \
                           MillisecondsTimeout, \
                           RemoveLock, \
                           sizeof(IO_REMOVE_LOCK))


NTSTATUS
USBClassRequestEx(IN PDEVICE_OBJECT   LowerDevObj,
                  IN REQUEST_RECIPIENT Recipient,
                  IN UCHAR            Request,
                  IN USHORT           Value,
                  IN USHORT           Index,
                  IN OUT PVOID        Buffer,
                  IN OUT PULONG       BufferSize,
                  IN BOOLEAN          Read,
                  IN LONG             MillisecondsTimeout,
                  IN PIO_REMOVE_LOCK  RemoveLock,
                  IN ULONG            RemLockSize);

/************************************************************************/
/*                    USBInitializeInterruptTransfers                   */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Initialize interrupt read pipe                                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject   - pointer to the device object                   */
/*      LowerDevObj    - pointer to the lower device object             */
/*      Buffer         - pointer to buffer for data from interrupt pipe */
/*      BuffSize       - size of buffer passed in                       */
/*      InterruptPipe  - pipe descriptor                                */
/*      DriverContext  - context passed to driver callback routine      */
/*      DriverCallback - driver routines called on completion           */
/*      RemoveLock     - pointer to remove lock for device              */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      USB_WRAPPER_HANDLE                                              */
/*                                                                      */
/************************************************************************/
#define USBInitializeInterruptTransfers(DeviceObject, \
                                        LowerDevObj, \
                                        MaxTransferSize, \
                                        InterruptPipe, \
                                        DriverContext, \
                                        DriverCallback, \
                                        NotificationTypes, \
                                        RemoveLock) \
        USBInitializeInterruptTransfersEx(DeviceObject, \
                                          LowerDevObj, \
                                          MaxTransferSize, \
                                          InterruptPipe, \
                                          DriverContext, \
                                          DriverCallback, \
                                          NotificationTypes, \
                                          PINGPONG_COUNT, \
                                          RemoveLock, \
                                          sizeof(IO_REMOVE_LOCK))

USB_WRAPPER_HANDLE
USBInitializeInterruptTransfersEx(IN PDEVICE_OBJECT            DeviceObject,
                                  IN PDEVICE_OBJECT            LowerDevObj,
                                  IN ULONG                     MaxTransferSize,
                                  IN PUSBD_PIPE_INFORMATION    InterruptPipe,
                                  IN PVOID                     DriverContext,
                                  IN INTERRUPT_CALLBACK        DriverCallback,
                                  IN ULONG                     NotificationTypes,
                                  IN ULONG                     PingPongCount,
                                  IN PIO_REMOVE_LOCK           RemoveLock,
                                  IN ULONG                     RemLockSize);

/************************************************************************/
/*                    USBStartInterruptTransfers                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Start transfers on interrupt pipe                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle  - pointer to wrapper handle from Init call       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBStartInterruptTransfers(IN USB_WRAPPER_HANDLE WrapperHandle);


/************************************************************************/
/*                    USBStopInterruptTransfers                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Stop transfers on interrupt pipe and free resources             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle  - pointer to wrapper handle from Start call      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBStopInterruptTransfers(IN USB_WRAPPER_HANDLE WrapperHandle);

/************************************************************************/
/*                    USBStopInterruptTransfers                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Frees all resources allocated in                                */
/*              USBInitializeInterruptTransfers                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle  - pointer to wrapper handle from Init call       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBReleaseInterruptTransfers(IN USB_WRAPPER_HANDLE WrapperHandle);


/************************************************************************/
/*                    USBStartSelectiveSuspend                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Start selective suspend support for device                      */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      LowerDevObj - pointer to device object                          */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      USB_WRAPPER_HANDLE                                              */
/*                                                                      */
/************************************************************************/
USB_WRAPPER_HANDLE
USBStartSelectiveSuspend(IN PDEVICE_OBJECT LowerDevObj);

/************************************************************************/
/*                    USBStopSelectiveSuspend                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Stop selective suspend support for device                       */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle - wrapper handle returned by start routine        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBStopSelectiveSuspend(IN USB_WRAPPER_HANDLE WrapperHandle);

/************************************************************************/
/*                          USBRequestIdle                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Idle request for device                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle - wrapper handle returned by start routine        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBRequestIdle(IN USB_WRAPPER_HANDLE WrapperHandle);

/************************************************************************/
/*                          USBRequestWake                              */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Wake request for device                                         */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      WrapperHandle - wrapper handle returned by start routine        */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
USBRequestWake(IN USB_WRAPPER_HANDLE WrapperHandle);

#endif // __USBUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\ccformatcodes.h ===
/* Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved. */

#ifndef __CCFORMATCODES_H
#define __CCFORMATCODES_H

// No-op / NULL
#define CC_NOP                      0x80    // 0x00 with odd parity

// Extended Data Packet Control Codes, First Byte
#define CC_XDS_START_CURRENT                0x01
#define CC_XDS_CONTINUE_CURRENT             0x02
#define CC_XDS_START_FUTURE                 0x03
#define CC_XDS_CONTINUE_FUTURE              0x04
#define CC_XDS_START_CHANNEL                0x05
#define CC_XDS_CONTINUE_CHANNEL             0x06
#define CC_XDS_START_MISC                   0x07
#define CC_XDS_CONTINUE_MISC                0x08
#define CC_XDS_START_PUBLIC_SERVICE         0x09
#define CC_XDS_CONTINUE_PUBLIC_SERVICE      0x0A
#define CC_XDS_START_RESERVED               0x0B
#define CC_XDS_CONTINUE_RESERVED            0x0C
#define CC_XDS_START_UNDEFINED              0x0D
#define CC_XDS_CONTINUE_UNDEFINED           0x0E
#define CC_XDS_END                          0x0F

// Miscellaneous Control Codes, First Byte
#define CC_MCC_FIELD1_DC1                   0x14    // Field 1, Data Channel 1
#define CC_MCC_FIELD1_DC2                   0x1C    // Field 1, Data Channel 2
#define CC_MCC_FIELD2_DC1                   0x15    // Field 2, Data Channel 1
#define CC_MCC_FIELD2_DC2                   0x1D    // Field 2, Data Channel 2

// Miscellaneous Control Codes, Second Byte
#define CC_MCC_RCL                          0x20    // Resume Caption Loading
#define CC_MCC_BS                           0x21    // BackSpace
#define CC_MCC_AOF                          0x22    // reserved (was: Alarm OFf)
#define CC_MCC_AON                          0x23    // reserved (was: Alarm ON)
#define CC_MCC_DER                          0x24    // Delete to End of Row
#define CC_MCC_RU2                          0x25    // Roll-Up captions - 2 rows
#define CC_MCC_RU3                          0x26    // Roll-Up captions - 3 rows
#define CC_MCC_RU4                          0x27    // Roll-Up captions - 4 rows
#define CC_MCC_FON                          0x28    // Flash ON
#define CC_MCC_RDC                          0x29    // Resume Direct Captioning
#define CC_MCC_TR                           0x2A    // Text Restart
#define CC_MCC_RTD                          0x2B    // Resume Text Display
#define CC_MCC_EDM                          0x2C    // Erase Displayed Memory
#define CC_MCC_CR                           0x2D    // Carriage Return
#define CC_MCC_ENM                          0x2E    // Erase Non-displayed Memory
#define CC_MCC_EOC                          0x2F    // End Of Caption (flip memories)

#endif /*__CCFORMATCODES_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\ccdecode.h ===
/* Copyright (c) 1997 Microsoft Corporation. All Rights Reserved. */

#ifndef __CCDECODE_H
#define __CCDECODE_H

typedef struct cc_state_struct CCState;

typedef struct cc_line_stats_struct CCLineStats;

/* Create a new "CC Decoder state".

   A separate CC state should be maintained for each separate
   simultaneous source to the CC filter (i.e., each channel).  (If
   different lines of CC are known to come from different inserters,
   better results may be possible by keeping a separate CC state for
   each line, at the cost of more CPU and memory overhead.  This
   shouldn't be necessary under normal circumstances.)

   CCStartRetrain(fDiscardOld = TRUE) is implicitly called upon
   creation of a new state.

   Returns NULL on error.
   */

CCState *CCStateNew(CCState *mem);

/* Destroys a CC state */

void CCStateDestroy(CCState *pState);

struct cc_state_struct {

    unsigned short magic;     // Magic number; used for validity test
    unsigned short no_free;   // Memory for this was pre-allocated; don't free

    unsigned long  period;    // # of samples per bit at the current sampling rate
    unsigned long  lastFreq;  // The last sampling frequency computed

    int cc_sync_points[16];
};
#define CC_STATE_MAGIC_10   0xCC01
#define MCHECK(pState)   (pState->magic == CC_STATE_MAGIC_10)
#define MASSERT(pState)  ASSERT(pState && MCHECK(pState))


/* The period of the CC samples is CCState.period/CC_MULTIPLE.  (This can
   be thought of as representing the period in fixed-point, with two
   digits after the decimal point.  If we rounded this off to the nearest
   integral number of samples, the inaccuracy would accumulate unacceptably
   as we scanned across the scanline.) */
#define CC_MULTIPLE 8

/* Dereference a block of CC samples, taking CC_MULTIPLE into account. */
#define CC_DATA(x, y) ((x)[(y)/CC_MULTIPLE])


/* Tells the CC decoder to initiate a "fast retrain".  This is useful
   if you suspect that conditions have changed sufficiently to be
   worth a CPU hit.  If the fDiscardOld flag is TRUE, then the old
   trained state is discarded; this would be used on channel changes,
   for instance.  If the fDiscardOld flag is FALSE, then the
   retraining is cumulative on the previous training.  (Is this
   useful?) */

void CCStartRetrain(CCState *pState, BOOL fDiscardOld);

/*
 * Inputs:
 * pbSamples:  pointer to 8-bit raw VBI samples
 * pState:     CCState to use for decoding
 *
 * Outputs:
 * pbDest:     decoded data (2 bytes long)
 *   Note that "standard" CC (as specified in EIA-608) uses 7 data bits
 *   and 1 parity bit.  This function does not check or remove the parity
 *   bits, for increased flexibility with nonstandard CC lines.
 * pLineStats: stats on decoded data
 *
 * Errors:
 *
 * Returns 0 if no error
 * Returns CC_ERROR_ILLEGAL_STATE if state is illegal or uses
 *         unsupported settings
 * Returns CC_ERROR_ILLEGAL_STATS if stats is passed incorrectly
 * Returns CC_ERROR_ILLEGAL_VBIINFOHEADER if vbi info header is invalid
 *
 * Notes:
 * pbDest must point to a buffer at least 2 bytes long
 * pLineStats->nSize must be set to sizeof(*pLineStats) prior to call
 *   (so that the decoder can signal an error if CCLineStats changes
 *   incompatibly)
 */
 
int CCDecodeLine(unsigned char *pbDest, CCLineStats *pLineStats,
		 unsigned char *pbSamples, CCState *pState,
		 PKS_VBIINFOHEADER pVBIINFO);

enum cc_errors {CC_OK, CC_ERROR_ILLEGAL_STATE, CC_ERROR_ILLEGAL_STATS,
                CC_ERROR_ILLEGAL_VBIINFOHEADER};

struct cc_line_stats_struct {
   int nSize;  /* Should be set to the size of this structure.
                  Used to maintain backwards compatibility as we add fields */
   
   int nConfidence; /* Set to 0-100 as a measure of expected reliability.
                       Low numbers are caused either by a noisy signal, or
                       if the line is in fact not CC */
   
   int nFirstBit;  /* The position of the center of
                      the first sync bit sample */
   
   int nDC;        /* the calculated DC offset used to threshold samples.
                      This is dependent on the current way we decode CC
                      and may not be used in the future */
   
   int bCheckBits; /* The CC standard specifies that there are 3 bits whose
		      values are fixed.  This is a 3-bit number which
		      says how those 3 bits were decoded; it should always
		      be equal to 4.  (If this field is not set to 4, then
		      either the line was very noisy, and probably not
		      decoded correctly, or it is not CC data at all.) */

   int nBitVals[19]; /* debugging */
   
};  

#endif /*__CCDECODE_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\coddebug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


//======================================================;
//  Data storage for coddebug.h when DEBUG #defined
//======================================================;

#if DBG

#include <strmini.h>

char _CDebugAssertFail[] = "ASSERT(%s) FAILED in file \":%s\", line %d\n";

enum STREAM_DEBUG_LEVEL _CDebugLevel = /*DebugLevelWarning*/ /*DebugLevelMaximum*/ DebugLevelError;

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\ccdecode.c ===
/* Copyright (c) 1997 Microsoft Corporation. All Rights Reserved. */

/*
  foreach /x/samp/starsight/kctswod1-512-raw0000 : ccfile 4
  open /x/samp/starsight/kctswod1-512-raw0000
  

  1: 39/2/0/0/40   old algorithm

  new:
  
  2: 5/5/5/27/1091   avg zero crossings for level
  3: 6/5/7/26/1069   avg peaks for level

  */
  
#include <stdio.h>
#include <stdlib.h>

#include "host.h"
#include "ccdecode.h"


static inline int iabs(int x) { return x>0?x:-x; }

static void cc_compute_new_samplingrate(CCState *pState, unsigned long newRate)
{
    int i;

    MASSERT(pState);

    pState->lastFreq = newRate;
    pState->period = (newRate * CC_MULTIPLE) / KS_VBIDATARATE_CC;

    for (i = 1; i <= 13; ++i)
        pState->cc_sync_points[i] = (i * pState->period) / (2*CC_MULTIPLE);
    pState->cc_sync_points[14] = (17 * pState->period) / (2*CC_MULTIPLE);
    pState->cc_sync_points[15] = (19 * pState->period) / (2*CC_MULTIPLE);
}

/* The CC decoder previously did not use any persistent state.  However,
   this version does.  These calls are now REQUIRED.
 */

/* Create a new CC state */
CCState *CCStateNew(CCState *mem)
{
    unsigned short     no_free = 0;


    if (NULL == mem)
        mem = malloc(sizeof (CCState));
    else
        no_free = 1;

    if (NULL != mem) {
        mem->no_free = no_free;
        mem->magic = CC_STATE_MAGIC_10;

        cc_compute_new_samplingrate(mem, KS_VBISAMPLINGRATE_5X_NABTS);
    }

    return (mem);
}

/* Destroy the CC state. */
void CCStateDestroy(CCState *state) {
    MASSERT(state);
    if (state->magic != 0) {
        state->magic = 0;
        if (!state->no_free)
            free(state);
    }
}


int cc_find_sync(CCState *pState, unsigned char *data, int max_sync_loc) {
  int i;
  int cur_conv = 0;
  int best_conv;
  int best_conv_loc;

  for (i = 0; i < 15; i++) {
    int sub_conv = 0;
    int j;

    for (j = pState->cc_sync_points[i]; j < pState->cc_sync_points[i+1]; j++) {
      sub_conv += data[j];
    }

    if (i & 1) {
      cur_conv -= sub_conv;
    } else {
      cur_conv += sub_conv;
    }
  }

  best_conv = cur_conv;
  best_conv_loc = 0;

  for (i = 1; i < max_sync_loc; i++) {
    int j;

    for (j = 0; j < 15; j++) {
      if (j & 1) {
        cur_conv += data[(i-1)+pState->cc_sync_points[j]];
        cur_conv -= data[(i-1)+pState->cc_sync_points[j+1]];
      } else {
        cur_conv -= data[(i-1)+pState->cc_sync_points[j]];
        cur_conv += data[(i-1)+pState->cc_sync_points[j+1]];
      }
    }

    if (cur_conv > best_conv) {
      best_conv = cur_conv;
      best_conv_loc = i;
    }
  }

  return best_conv_loc * CC_MULTIPLE;
}  
    

/* Given a CC scanline, and the location of the sync, compute the
   DC offset of the signal.  (We compute this by taking the average
   of the value at the 14 synchronization points found with the
   above routine; except we don't actually divide by 14 at the end.) */

int cc_level(CCState *pState, unsigned char *data, int origin) {
  int i;
  int offset;
  int res = 0;

  for (i = 0, offset = origin; i < 7; i++, offset += pState->period) {
    res += CC_DATA(data, offset) + CC_DATA(data, offset + pState->period/2);
  }

  return res; /* Times 14! */
}

/* Given a CC scanline, the location of the sync, and the DC offset of
   the signal, check the "quality" of the signal (in particular, we
   want to determine whether this really is CC data).  We do this by
   looking at 35 points in the signal and making sure that the values
   at those points agree with our expectations; we look at 26 points
   in the actual sync period (2 points in each "peak" and each "valley")
   and 9 points in the "check bits" (3 in each bit).

   This gives us a quality number between 0 and 35, where we would
   expect random noise to give us about 35/2.  We map the range
   0...35 to -1000...1000 before returning. */

int cc_quality(CCState *pState, unsigned char *data, int origin, int level) {
  int i;
  int conf = 0;
  int offset;

  for (i = 0, offset = origin; i < 7; i++, offset += pState->period) {
    int ind_hi = (offset + pState->period/4)/CC_MULTIPLE;
    /* check 2 points in a "peak" */
    if (data[ind_hi-5] >= level) {
      conf++;
    }
    if (data[ind_hi+5] >= level) {
      conf++;
    }

    /* check 2 points in a "valley" */
    if (i < 6) {
      int ind_lo = (offset + 3*pState->period/4)/CC_MULTIPLE;
      if (data[ind_lo-5] < level) {
	conf++;
      }
      if (data[ind_lo+5] < level) {
	conf++;
      }
    }
  }

  for (i = 0, offset = origin + 7*pState->period; i < 3; i++, offset += pState->period) {
    /* check 3 points in a check bit */

    int ind = offset/CC_MULTIPLE;

    if (i < 2) {
      if (data[ind-10] < level) {
        conf++;
      }
      if (data[ind] < level) {
        conf++;
      }
      if (data[ind+10] < level) {
        conf++;
      }
    } else {
      if (data[ind-10] >= level) {
        conf++;
      }
      if (data[ind] >= level) {
        conf++;
      }
      if (data[ind+10] >= level) {
        conf++;
      }
    }
  }

  /* Now "conf" is a number between 0 and 35.
     If the input were random noise, we would expect "conf" to be about
     35/2.  We want to map 35/2 to 0 and 35 to 1000.  (This actually maps
     0 to -1000, 35/2 to 15, and 35 to 1030.  Close enough.) */
  return (conf*58)-1000;     
}

/* The main entry point for this file.  Decodes a CC scanline into
   the two-byte "dest", and returns stats on the decoding. */

int CCDecodeLine(unsigned char *dest, CCLineStats *stats,
		 unsigned char *samples, CCState *state,
		 KS_VBIINFOHEADER *pVBIINFO) {
  int origin;
  int quality;
  int level;
  int bits;
  int i;
  int offset;

  MASSERT(state);
  if (!state || !MCHECK(state))
	return CC_ERROR_ILLEGAL_STATE;

  if (stats->nSize != sizeof(*stats))
	return CC_ERROR_ILLEGAL_STATS;

  // Now check to see if we need to recompute for a different sampling rate
  if (state->lastFreq != pVBIINFO->SamplingFrequency)
	  cc_compute_new_samplingrate(state, pVBIINFO->SamplingFrequency);

#ifdef OLD_SYNC
  {
      int nOffsetData, nOffsetSamples;
      int offsets_err;

      /* Use the provided KS_VBIINFOHEADER to adjust the data so our
         various hardcoded constants are appropriate. */
      offsets_err = CCComputeOffsets(pVBIINFO, &nOffsetData, &nOffsetSamples);
      if (offsets_err > 0)
        return offsets_err;

      samples += nOffsetSamples;
  }
#endif //OLD_SYNC

  origin = cc_find_sync(state, samples,
                        pVBIINFO->SamplesPerLine
                        - ((25*state->period)/CC_MULTIPLE) - 5);

  /* Find the DC offset of the signal (times 14) */
  level = cc_level(state, samples, origin + state->period/4); /* Times 14! */

  quality = cc_quality(state, samples, origin, level/14);

  /* Accumulate the actual data into "bits". */
  bits = 0;

  /* Start at the right and scan left; read 19 bits into "bits".
     (These are the 16 data bits and 3 check bits.) */
  for (i = 0, offset = origin + 25*state->period; i < 19; i++, offset -= state->period) {
     int ind= offset / CC_MULTIPLE;
     int measured_level;
     bits <<= 1;

     /* Extremely simple low-pass filter averages roughly the middle
        "half" of the CC pulse.  (Times 14) */
     
     measured_level=
        samples[ind-13] + samples[ind-11] + samples[ind-9] +
        samples[ind-7] + samples[ind-5] + samples[ind-3] + samples[ind-1] +
        samples[ind+1] + samples[ind+3] + samples[ind+5] + samples[ind+7] +
        samples[ind+9] + samples[ind+11] + samples[ind+13];

     /* debugging code: */
     stats->nBitVals[18-i]= measured_level / 14;
     
     bits |= (measured_level > level);
  }

  /* Store the value of the 3 check bits; if this is valid CC, then
     bCheckBits should always be 4. */
  stats->bCheckBits = (bits & 7);

  /* Shift off the check bits. */
  bits >>= 3;

  /* Store the two bytes of decoded CC data. */
  dest[0] = bits & 0xff;
  dest[1] = bits >> 8;

  /* Our "quality" indicator runs from -1000...1030; divide this by 10
     to get -100...103 and truncate to get 0...100. */
  stats->nConfidence = quality/10;
  if (stats->nConfidence > 100) stats->nConfidence = 100;
  if (stats->nConfidence < 0) stats->nConfidence = 0;

  /* Record what we've computed about the signal. */
  stats->nFirstBit = (origin + 7*state->period) / CC_MULTIPLE;
  stats->nDC = level;

  /* Success! */
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\codmain.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>
#include "kskludge.h"
#include "codmain.h"
#include "codstrm.h"
#include "codprop.h"
#include "coddebug.h"


//
// Fake VBI Info header.  Infinite Pin Tee Filter can't pass real ones
// one from capture so we rely on this.  MSTee can so this gets
// overwritten.
//
KS_VBIINFOHEADER FakeVBIInfoHeader = {
   10,       /* StartLine;           IGNORED */
   21,       /* EndLine;             IGNORED */
   28636360, /* SamplingFrequency;   Hz. */
   780,      /* MinLineStartTime;    IGNORED */
   780,      /* MaxLineStartTime;    IGNORED */
   780,      /* ActualLineStartTime; microSec * 100 from HSync LE */
   0,        /* ActualLineEndTime;   IGNORED */
   0,        /* VideoStandard;       IGNORED */
   1600,     /* SamplesPerLine;                              */
   1600,     /* StrideInBytes;       May be > SamplesPerLine */
   1600*12   /* BufferSize;          Bytes */
};



/*
** DriverEntry()
**
**   This routine is called when the driver is first loaded by PnP.
**   It in turn, calls upon the stream class to perform registration services.
**
** Arguments:
**
**   DriverObject - 
**          Driver object for this driver 
**
**   RegistryPath - 
**          Registry path string for this driver's key
**
** Returns:
**
**   Results of StreamClassRegisterAdapter()
**
** Side Effects:  none
*/

ULONG 
DriverEntry( IN PDRIVER_OBJECT DriverObject,
			 IN PUNICODE_STRING RegistryPath )
{
    ULONG					status = 0;
    HW_INITIALIZATION_DATA	HwInitData;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->DriverEntry(DriverObject=%x,RegistryPath=%x)\n", 
				DriverObject, RegistryPath));

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    /*CDEBUG_BREAK();*/

    //
    // Set the codec entry points for the driver
    //

    HwInitData.HwInterrupt              = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket          = CodecReceivePacket;
    HwInitData.HwCancelPacket           = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler  = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize      = sizeof(HW_DEVICE_EXTENSION);
    HwInitData.PerRequestExtensionSize  = sizeof(SRB_EXTENSION); 
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX); 
    HwInitData.BusMasterDMA             = FALSE;  
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = 3;
    HwInitData.TurnOffSynchronization   = TRUE;
    HwInitData.DmaBufferSize            = 0;

    CDebugPrint(DebugLevelVerbose,(CODECNAME ": StreamClassRegisterAdapter\n"));

    status = StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData);

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---DriverEntry(DriverObject=%x,RegistryPath=%x)=%d\n",
			    DriverObject, RegistryPath, status));

    return status;     
}

//==========================================================================;
//                   Codec Request Handling Routines
//==========================================================================;

/*
** CodecInitialize()
**
**   This routine is called when an SRB_INITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Initialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN 
CodecInitialize ( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb )
{
    BOOLEAN							bStatus = FALSE;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
    PHW_DEVICE_EXTENSION			pHwDevExt =
        (PHW_DEVICE_EXTENSION)ConfigInfo->HwDeviceExtension;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecInitialize(pSrb=%x)\n",pSrb));
    
    if (ConfigInfo->NumberOfAccessRanges == 0) 
    {
        CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecInitialize\n"));

        ConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

        // These are the driver defaults for scanline filtering.
        // Modify these WHEN you change the codec type to be more correct.
        SETBIT( pHwDevExt->ScanlinesRequested.DwordBitArray, 21 );

        // These are the driver defaults for subtream filtering. 
        // Modify these WHEN you change the codec type 
		
        pHwDevExt->SubstreamsRequested.SubstreamMask = KS_CC_SUBSTREAM_ODD;
		pHwDevExt->Streams = Streams;
        pHwDevExt->fTunerChange = FALSE;

		//
		// Allocate the results array based on the number of scanlines
		//
		pHwDevExt->DSPResultStartLine = pHwDevExt->DSPResultEndLine = 0;
	    pHwDevExt->DSPResult = ( PDSPRESULT )
			ExAllocatePool( NonPagedPool, 
				sizeof( DSPRESULT ) *
				(FakeVBIInfoHeader.EndLine - FakeVBIInfoHeader.StartLine + 1) );
	    if( !pHwDevExt->DSPResult )
	    {
		   CDebugPrint( DebugLevelError,
			   (CODECNAME ": DSP Result array allocation FAILED\n" ));
		   //pSrb->Status = STATUS_INVALID_PARAMETER;
		}
		else {
			pHwDevExt->DSPResultStartLine = FakeVBIInfoHeader.StartLine;
			pHwDevExt->DSPResultEndLine = FakeVBIInfoHeader.EndLine;
		}

        // Zero out the substream state information (no substreams discovered yet)
        RtlZeroMemory( pHwDevExt->SubStreamState, sizeof(pHwDevExt->SubStreamState) );

#ifdef CCINPUTPIN
		// Init LastPictureNumber's FastMutex
		ExInitializeFastMutex(&pHwDevExt->LastPictureMutex);
#endif // CCINPUTPIN        
        
        pSrb->Status = STATUS_SUCCESS;
        bStatus = TRUE;
    }
    else
    {
        CDebugPrint(DebugLevelError,(CODECNAME ": illegal config info\n"));
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
    }

    CDebugPrint(DebugLevelTrace,
                (CODECNAME ":<---CodecInitialize(pSrb=%x)=%d\n", pSrb, bStatus));
    return (bStatus);
}

/*
** CodecUnInitialize()
**
**   This routine is called when an SRB_UNINITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the UnInitialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN 
CodecUnInitialize ( 
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
   PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
   
   CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecUnInitialize(pSrb=%x)\n",pSrb));
   pSrb->Status = STATUS_SUCCESS;
   CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecUnInitialize(pSrb=%x)\n",pSrb));

    //
    // Free up the results buffer
    //
    if (pHwDevExt->DSPResult) {
		ExFreePool( pHwDevExt->DSPResult );
		pHwDevExt->DSPResult = NULL;
		pHwDevExt->DSPResultStartLine = pHwDevExt->DSPResultEndLine = 0;
	}

    return TRUE;
}


/*
** CodecOpenStream()
**
**   This routine is called when an OpenStream SRB request is received.
**   A stream is identified by a stream number, which indexes an array
**   of KSDATARANGE structures.  The particular KSDATAFORMAT format to
**   be used is also passed in, which should be verified for validity.
**   
** Arguments:
**
**   pSrb - pointer to stream request block for the Open command
**
** Returns:
**
** Side Effects:  none
*/

VOID 
CodecOpenStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
    //
    // the stream extension structure is allocated by the stream class driver
    //

    PSTREAMEX               pStrmEx = pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = pSrb->HwDeviceExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;

    PKSDATAFORMAT pKSVBIDataFormat =
		(PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

	CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecOpenStream(pSrb=%x)\n", pSrb));
    CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecOpenStream : StreamNumber=%d\n", StreamNumber));

    RtlZeroMemory(pStrmEx, sizeof (STREAMEX));
    
    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //

    if ( 0 <= StreamNumber && StreamNumber < DRIVER_STREAM_COUNT ) 
	{
        unsigned StreamInstance;
        unsigned maxInstances =
                  Streams[StreamNumber].hwStreamInfo.NumberOfPossibleInstances;

		// Search for next open slot
	    for (StreamInstance=0; StreamInstance < maxInstances; ++StreamInstance)
		{
			if (pHwDevExt->pStrmEx[StreamNumber][StreamInstance] == NULL)
				break;
		}

	    if (StreamInstance < maxInstances)
		{
			if (CodecVerifyFormat(pKSVBIDataFormat, StreamNumber, &pStrmEx->MatchedFormat)) 
			{
				CASSERT (pHwDevExt->pStrmEx[StreamNumber][StreamInstance] == NULL);
               
               InitializeListHead( &pStrmEx->StreamControlQueue );
               InitializeListHead( &pStrmEx->StreamDataQueue );
               KeInitializeSpinLock( &pStrmEx->StreamControlSpinLock );
               KeInitializeSpinLock( &pStrmEx->StreamDataSpinLock );
				// Maintain an array of all the StreamEx structures in the HwDevExt
				// so that we can reference IRPs from any stream

				pHwDevExt->pStrmEx[StreamNumber][StreamInstance] = pStrmEx;
    
                // Save the Stream Format in the Stream Extension as well.
                pStrmEx->OpenedFormat = *pKSVBIDataFormat;

				// Set up pointers to the handlers for the stream data and control handlers

				pSrb->StreamObject->ReceiveDataPacket = 
						(PVOID) Streams[StreamNumber].hwStreamObject.ReceiveDataPacket;
				pSrb->StreamObject->ReceiveControlPacket = 
						(PVOID) Streams[StreamNumber].hwStreamObject.ReceiveControlPacket;
    
				//
				// The DMA flag must be set when the device will be performing DMA directly
				// to the data buffer addresses passed in to the ReceiceDataPacket routines.
				//

				pSrb->StreamObject->Dma = Streams[StreamNumber].hwStreamObject.Dma;

				//
				// The PIO flag must be set when the mini driver will be accessing the data
				// buffers passed in using logical addressing
				//

				pSrb->StreamObject->Pio = Streams[StreamNumber].hwStreamObject.Pio;
               pSrb->StreamObject->Allocator = Streams[StreamNumber].hwStreamObject.Allocator;
				//
				// How many extra bytes will be passed up from the driver for each frame?
				//

				pSrb->StreamObject->StreamHeaderMediaSpecific = 
					Streams[StreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

				pSrb->StreamObject->StreamHeaderWorkspace =
					Streams[StreamNumber].hwStreamObject.StreamHeaderWorkspace;

				//
				// Indicate the clock support available on this stream
				//

				pSrb->StreamObject->HwClockObject = 
					Streams[StreamNumber].hwStreamObject.HwClockObject;

				// 
				// Increment the instance count on this stream
				//
                pStrmEx->StreamInstance = StreamInstance;
				pHwDevExt->ActualInstances[StreamNumber]++;


				// Retain a private copy of the HwDevExt and StreamObject in the stream extension
				// so we can use a timer 

				pStrmEx->pHwDevExt = pHwDevExt;                     // For timer use
				pStrmEx->pStreamObject = pSrb->StreamObject;        // For timer use
               CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Stream Instance %d\n",
               	pStrmEx->StreamInstance ));

                // Copy the default filtering settings
                
                pStrmEx->ScanlinesRequested = pHwDevExt->ScanlinesRequested;
                pStrmEx->SubstreamsRequested = pHwDevExt->SubstreamsRequested;
                //
                // Load up default VBI info header
                RtlCopyMemory( &pStrmEx->CurrentVBIInfoHeader, &FakeVBIInfoHeader,
                	sizeof( KS_VBIINFOHEADER ) );
#ifdef CCINPUTPIN
				// Init VBISrbOnHold's spin lock
				KeInitializeSpinLock(&pStrmEx->VBIOnHoldSpinLock);
#endif // CCINPUTPIN        
				// Init DSP state
                CCStateNew(&pStrmEx->State);
			}
			else
			{
				CDebugPrint(DebugLevelError,
					(CODECNAME ": CodecOpenStream : Invalid Stream Format=%x\n", 
					pKSVBIDataFormat ));
				pSrb->Status = STATUS_INVALID_PARAMETER;
			}
		}
		else
		{
		    CDebugPrint(DebugLevelError,
				(CODECNAME ": CodecOpenStream : Stream %d Too Many Instances=%d\n", 
				StreamNumber, pHwDevExt->ActualInstances[StreamNumber] ));
	        pSrb->Status = STATUS_INVALID_PARAMETER;
		}
	}
	else
	{
	    CDebugPrint(DebugLevelError,
			(CODECNAME ": CodecOpenStream : Invalid StreamNumber=%d\n", 
			StreamNumber ));
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecOpenStream(pSrb=%x)\n",	pSrb));
}

/*
** CodecCloseStream()
**
**   Close the requested data stream
**
** Arguments:
**
**   pSrb the request block requesting to close the stream
**
** Returns:
**
** Side Effects:  none
*/

VOID 
CodecCloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb;
    PKSDATAFORMAT           pKSDataFormat = pSrb->CommandData.OpenFormat;
    ULONG                   StreamNumber = pSrb->StreamObject->StreamNumber;
    ULONG                   StreamInstance = pStrmEx->StreamInstance;
#ifdef CCINPUTPIN           
    KIRQL                   Irql;
#endif // CCINPUTPIN           

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecCloseStream(pSrb=%x)\n", pSrb));

    // CDEBUG_BREAK(); // Uncomment this code to break here.


    CDebugPrint( DebugLevelVerbose, ( CODECNAME "Strm %d StrmInst %d ActualInst %d\n",
    	StreamNumber, StreamInstance, pHwDevExt->ActualInstances[StreamNumber] ));
       
   //
   // Flush the stream data queue
   //
#ifdef CCINPUTPIN           
    // Is there an SRB 'on hold'??
	KeAcquireSpinLock(&pStrmEx->VBIOnHoldSpinLock, &Irql);
	if (pStrmEx->pVBISrbOnHold)
	{
		PHW_STREAM_REQUEST_BLOCK pHoldSrb;

		pHoldSrb = pStrmEx->pVBISrbOnHold;
		pStrmEx->pVBISrbOnHold = NULL;
		KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);

        pHoldSrb->Status = STATUS_CANCELLED;
	    CDebugPrint(DebugLevelVerbose,
	    	(CODECNAME ":StreamClassStreamNotification(pHoldSrb->Status=0x%x)\n", 
	    	pHoldSrb->Status));
           
        StreamClassStreamNotification(
		   StreamRequestComplete, pHoldSrb->StreamObject, pHoldSrb);
		pSrb = NULL;
	}
	else
		KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);
#endif // CCINPUTPIN           
   while( QueueRemove( &pCurrentSrb, &pStrmEx->StreamDataSpinLock,
       &pStrmEx->StreamDataQueue ))
   {
       CDebugPrint( DebugLevelVerbose, 
           ( CODECNAME ": Removing control SRB %x\n", pCurrentSrb ));
       pCurrentSrb->Status = STATUS_CANCELLED;
       StreamClassStreamNotification( StreamRequestComplete,
           pCurrentSrb->StreamObject, pCurrentSrb );
   }
   //
   // Flush the stream control queue
   //
    while( QueueRemove( &pCurrentSrb, &pStrmEx->StreamControlSpinLock,
       &pStrmEx->StreamControlQueue ))
    {
       CDebugPrint( DebugLevelVerbose, 
           ( CODECNAME ": Removing control SRB %x\n", pCurrentSrb ));
       pCurrentSrb->Status = STATUS_CANCELLED;
       StreamClassStreamNotification( StreamRequestComplete,
           pCurrentSrb->StreamObject, pCurrentSrb );
    }

    // Destroy DSP state
    CCStateDestroy(&pStrmEx->State);
           
	pHwDevExt->ActualInstances[StreamNumber]--;  

    CASSERT (pHwDevExt->pStrmEx [StreamNumber][StreamInstance] != 0);

    pHwDevExt->pStrmEx [StreamNumber][StreamInstance] = 0;

    //
    // the minidriver may wish to free any resources that were allocate at
    // open stream time etc.
    //
    pStrmEx->hMasterClock = NULL;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecCloseStream(pSrb=%x)\n", pSrb));
}


/*
** CodecStreamInfo()
**
**   Returns the information of all streams that are supported by the
**   mini-driver
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID 
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{

    int j; 
    
    PHW_DEVICE_EXTENSION pHwDevExt =
        ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //

    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

     //
     // pick up the pointer to the array of stream information data structures
     //

    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


	CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecStreamInfo(pSrb=%x)\n", pSrb));
  
    // 
    // verify that the buffer is large enough to hold our return data
    //

    CASSERT (pSrb->NumberOfBytesToTransfer >= 
            sizeof (HW_STREAM_HEADER) +
            sizeof (HW_STREAM_INFORMATION) * DRIVER_STREAM_COUNT);

     //
     // Set the header
     // 

#define GLOBAL_PROPERTIES
#ifdef GLOBAL_PROPERTIES
     StreamHeader.NumDevPropArrayEntries = NUMBER_OF_CODEC_PROPERTY_SETS;
     StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET) CodecPropertyTable; 
#else // !GLOBAL_PROPERTIES
     StreamHeader.NumDevPropArrayEntries = 0;
     StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET)NULL; 
#endif // GLOBAL_PROPERTIES
     *pstrhdr = StreamHeader;

     // 
     // stuff the contents of each HW_STREAM_INFORMATION struct 
     //

     for (j = 0; j < DRIVER_STREAM_COUNT; j++) {
        *pstrinfo++ = Streams[j].hwStreamInfo;
     }

     CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecStreamInfo(pSrb=%x)\n", pSrb));
}


/*
** CodecReceivePacket()
**
**   Main entry point for receiving codec based request SRBs.  This routine
**   will always be called at High Priority.
**
**   Note: This is an asyncronous entry point.  The request does not complete
**         on return from this function, the request only completes when a
**         StreamClassDeviceNotification on this request block, of type
**         DeviceRequestComplete, is issued.
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pSrb->HwDeviceExtension;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecReceivePacket(pSrb=%x)\n", pSrb));

    //
    // Assume success
    //

    pSrb->Status = STATUS_SUCCESS;
    
    if( !pHwDevExt->bAdapterQueueInitialized )
    {
       InitializeListHead( &pHwDevExt->AdapterSRBQueue );
       KeInitializeSpinLock( &pHwDevExt->AdapterSRBSpinLock );
       pHwDevExt->bAdapterQueueInitialized = TRUE;
    }
 
    //
    // determine the type of packet.
    //
    if( QueueAddIfNotEmpty( pSrb, &pHwDevExt->AdapterSRBSpinLock,
       &pHwDevExt->AdapterSRBQueue ))
       return;
       
    do
    {
       CDebugPrint(DebugLevelVerbose,
		    (CODECNAME ": CodecReceivePacket: pSrb->Command=0x%x\n", 
		    pSrb->Command));

       switch (pSrb->Command)
       {

       case SRB_INITIALIZE_DEVICE:

           // open the device
           
           CodecInitialize(pSrb);

           break;

       case SRB_UNINITIALIZE_DEVICE:

           // close the device.  

           CodecUnInitialize(pSrb);

           break;

       case SRB_OPEN_STREAM:

           // open a stream

           CodecOpenStream(pSrb);

           break;

       case SRB_CLOSE_STREAM:

           // close a stream

           CodecCloseStream(pSrb);

           break;

       case SRB_GET_STREAM_INFO:

           //
           // return a block describing all the streams
           //

           CodecStreamInfo(pSrb);

           break;

       case SRB_GET_DATA_INTERSECTION:

           //
           // Return a format, given a range
           //
           switch( pSrb->CommandData.IntersectInfo->StreamNumber )
           {
           case STREAM_VBI:
           	CodecVBIFormatFromRange( pSrb );
              break;
              
#ifdef CCINPUTPIN           
		   // Both streams can use CodecCCFormatFromRange() because they
		   //  both use KSDATAFORMAT structures.
           case STREAM_CCINPUT:		
#endif // CCINPUTPIN           
           case STREAM_CC:
           	  CodecCCFormatFromRange( pSrb );
              break;
              
           default:  // Unknown stream number?
           	CDebugPrint( DebugLevelError, ( CODECNAME ": Unknown Stream Number\n" ));
              CDEBUG_BREAK();
              pSrb->Status = STATUS_NOT_IMPLEMENTED;
              break;
           }
           break;

           // We should never get the following since this is a single instance
           // device
       case SRB_OPEN_DEVICE_INSTANCE:
       case SRB_CLOSE_DEVICE_INSTANCE:
           CDebugPrint(DebugLevelError,
             (CODECNAME ": CodecReceivePacket : SRB_%s_DEVICE_INSTANCE not supported\n", 
              (pSrb->Command == SRB_OPEN_DEVICE_INSTANCE)? "OPEN":"CLOSE" ));
           CDEBUG_BREAK();
   		   // Fall through to NOT IMPLEMENTED

       case SRB_UNKNOWN_DEVICE_COMMAND:		// But this one we don't care about
       case SRB_INITIALIZATION_COMPLETE:	// This one we don't care about
       case SRB_CHANGE_POWER_STATE:	    	// This one we don't care about
           pSrb->Status = STATUS_NOT_IMPLEMENTED;
           break;

       case SRB_GET_DEVICE_PROPERTY:

           //
           // Get codec wide properties
           //

           CodecGetProperty (pSrb);
           break;        

       case SRB_SET_DEVICE_PROPERTY:

           //
           // Set codec wide properties
           //
           CodecSetProperty (pSrb);
           break;

       case SRB_PAGING_OUT_DRIVER:
       case SRB_SURPRISE_REMOVAL:
           CDebugPrint(DebugLevelVerbose,
                (CODECNAME ": CodecReceivePacket: SRB_%s\n", 
                  (pSrb->Command == SRB_SURPRISE_REMOVAL)?
                    "SURPRISE_REMOVAL" : "PAGING_OUT_DRIVER"));
#if 0
       {
           PSTREAMEX   pStrmEx;
           unsigned StreamNumber, StreamInstance;
           unsigned maxInstances =
                  Streams[StreamNumber].hwStreamInfo.NumberOfPossibleInstances;

           // Do we have any pins connected and paused/running?
           //  Search any used slots...
           for (StreamNumber = 0; StreamNumber < DRIVER_STREAM_COUNT; ++StreamNumber) {
               for (StreamInstance=0; StreamInstance < maxInstances; ++StreamInstance)
               {
                   pStrmEx = pHwDevExt->pStrmEx[StreamNumber][StreamInstance];
                   if (pStrmEx != NULL) {
                       switch (pStrmEx->KSState) {
                           case KSSTATE_RUN:
                           case KSSTATE_PAUSE:
                               CDebugPrint(DebugLevelError,
                                 (CODECNAME ": CodecReceivePacket : PAGING_OUT_DRIVER during RUN or PAUSE; failing request\n"));
                               CDEBUG_BREAK();
                               pSrb->Status = STATUS_UNSUCCESSFUL;
                               goto break3;

                           default:
                               // Shouldn't have to do anything here except return SUCCESS
                               break;
                       }
                   }
               }
           }

    break3:
       }
#endif //0
       break;

       case SRB_UNKNOWN_STREAM_COMMAND:
       default:

           CDebugPrint(DebugLevelError,
             (CODECNAME ": CodecReceivePacket : UNKNOWN srb.Command = 0x%x\n", 
              pSrb->Command));
           CDEBUG_BREAK();

           //
           // this is a request that we do not understand.  Indicate invalid
           // command and complete the request
           //
           pSrb->Status = STATUS_NOT_IMPLEMENTED;
       }
       //
       // NOTE:
       //
       // all of the commands that we do, or do not understand can all be completed
       // syncronously at this point, so we can use a common callback routine here.
       // If any of the above commands require asyncronous processing, this will
       // have to change
       //
	    CDebugPrint(DebugLevelVerbose,
		    (CODECNAME ": CodecReceivePacket : DeviceRequestComplete(pSrb->Status=0x%x)\n", 
		    pSrb->Status));
       StreamClassDeviceNotification( DeviceRequestComplete, 
           pSrb->HwDeviceExtension, pSrb );
    }while( QueueRemove( &pSrb, &pHwDevExt->AdapterSRBSpinLock,
           &pHwDevExt->AdapterSRBQueue ));
    
    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecReceivePacket(pSrb=%x)\n", pSrb));
}

/*
** CodecCancelPacket ()
**
**   Request to cancel a packet that is currently in process in the minidriver
**
** Arguments:
**
**   pSrb - pointer to request packet to cancel
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecCancelPacket(pSrb=%x)\n", pSrb));
    CASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    //
    // Check whether the SRB to cancel is in use by this stream
    //
#ifdef CCINPUTPIN
    // Is SRB to cancel 'on hold'??
	KeAcquireSpinLockAtDpcLevel(&pStrmEx->VBIOnHoldSpinLock);
	if (pStrmEx->pVBISrbOnHold && pSrb == pStrmEx->pVBISrbOnHold)
	{
		pStrmEx->pVBISrbOnHold = NULL;
		KeReleaseSpinLockFromDpcLevel(&pStrmEx->VBIOnHoldSpinLock);

        pSrb->Status = STATUS_CANCELLED;
	    CDebugPrint(DebugLevelVerbose,
	    	(CODECNAME ":StreamClassStreamNotification(pSrb->Status=0x%x)\n", 
	    	pSrb->Status));
           
        StreamClassStreamNotification(
		   StreamRequestComplete, pSrb->StreamObject, pSrb);
		pSrb = NULL;
	}
	else
		KeReleaseSpinLockFromDpcLevel(&pStrmEx->VBIOnHoldSpinLock);

   if (NULL == pSrb)
		; // We're done; we CANCELLED the SRB above
   else
#endif // CCINPUTPIN        
   //
   // Attempt removal from data queue
   //
   if( QueueRemoveSpecific( pSrb, &pStrmEx->StreamDataSpinLock,
       &pStrmEx->StreamDataQueue ))
   {
       pSrb->Status = STATUS_CANCELLED;
	    CDebugPrint(DebugLevelVerbose,
	    	(CODECNAME ":StreamRequestComplete(ReadyForNextStreamDataRequest,pSrb->Status=0x%x)\n", 
	    	pSrb->Status));
           
       StreamClassStreamNotification( StreamRequestComplete,
           pSrb->StreamObject, pSrb );
   }
   else
   //
   // Attempt removal from command queue
   //
   if( QueueRemoveSpecific( pSrb, &pStrmEx->StreamControlSpinLock,
       &pStrmEx->StreamControlQueue ))
   {
       pSrb->Status = STATUS_CANCELLED;
	    CDebugPrint(DebugLevelVerbose,
	        (CODECNAME ":StreamRequestComplete(ReadyForNextStreamControlRequest,pSrb->Status=0x%x)\n", 
	        pSrb->Status));
       StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject,
           pSrb );
   }
   else
   //
   // Attempt removal from adapter queue
   //
   if( QueueRemoveSpecific( pSrb, &pHwDevExt->AdapterSRBSpinLock,
       &pHwDevExt->AdapterSRBQueue ))
   {
       pSrb->Status = STATUS_CANCELLED;
	    CDebugPrint(DebugLevelVerbose,
	        (CODECNAME ":DeviceRequestComplete(pSrb->Status=0x%x)\n", 
	     	pSrb->Status));
       StreamClassDeviceNotification( DeviceRequestComplete, pSrb->StreamObject,
           pSrb );
   }
   else
       CDebugPrint( DebugLevelWarning, ( CODECNAME "SRB %x not found to cancel\n", pSrb ));
   
    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecCancelPacket(pSrb=%x)\n", pSrb));
}


/*
** CodecTimeoutPacket()
**
**   This routine is called when a packet has been in the minidriver for
**   too long.  The codec must decide what to do with the packet
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI  
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecTimeoutPacket(pSrb=%x)\n", pSrb));

    //
    // if we timeout while playing, then we need to consider this
    // condition an error, and reset the hardware, and reset everything
    // as well as cancelling this and all requests
    //

    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything as well as cancelling this and all requests
    //

    //
    // if this is a data request, and the device is paused, we probably have
    // run out of data buffer, and need more time, so just reset the timer,
    // and let the packet continue
    //

//    pSrb->TimeoutCounter = pSrb->TimeoutOriginal;
    pSrb->TimeoutCounter = 0;
    
    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecTimeoutPacket(pSrb=%x)\n", pSrb));
}

#if 0
/*
** CompleteStreamSRB ()
**
**   This routine is called when a packet is being completed.
**   The optional second notification type is used to indicate ReadyForNext
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
**   NotificationType1 - what kind of notification to return
**
**   NotificationType2 - what kind of notification to return (may be 0)
**
**
** Returns:
**
** Side Effects:  none
*/

VOID 
CompleteStreamSRB (
     IN PHW_STREAM_REQUEST_BLOCK pSrb, 
     STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
     BOOL fUseNotification2,
     STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
    )
{
    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":--->CompleteStreamSRB(pSrb=%x)\n", pSrb));

	CDebugPrint(DebugLevelVerbose,
		(CODECNAME ": CompleteStreamSRB : NotificationType1=%d\n", 
		NotificationType1 ));

    StreamClassStreamNotification(
            NotificationType1,
            pSrb->StreamObject,
            pSrb);

    if (fUseNotification2) 
	{            
		// ReadyForNext

		CDebugPrint(DebugLevelVerbose,
			(CODECNAME ": CompleteStreamSRB : NotificationType2=%d\n", 
			NotificationType2 ));

		StreamClassStreamNotification(
			NotificationType2,
			pSrb->StreamObject);
	}

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CompleteStreamSRB(pSrb=%x)\n", pSrb));
}

/*
** CompleteDeviceSRB ()
**
**   This routine is called when a packet is being completed.
**   The optional second notification type is used to indicate ReadyForNext
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
**   NotificationType - what kind of notification to return
**
**   fReadyForNext - Send the "ReadyForNextSRB" 
**
**
** Returns:
**
** Side Effects:  none
*/

VOID
CompleteDeviceSRB (
     IN PHW_STREAM_REQUEST_BLOCK pSrb, 
     IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
     BOOL fReadyForNext
    )
{
    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CompleteDeviceSRB(pSrb=%x)\n", pSrb));

	CDebugPrint(DebugLevelVerbose,
		(CODECNAME ": CompleteDeviceSRB : NotificationType=%d\n", 
		NotificationType ));

    StreamClassDeviceNotification(
            NotificationType,
            pSrb->HwDeviceExtension,
            pSrb);

    if (fReadyForNext) 
	{
		CDebugPrint(DebugLevelVerbose,
			(CODECNAME ": CompleteDeviceSRB : ReadyForNextDeviceRequest\n"));

		StreamClassDeviceNotification( 
			ReadyForNextDeviceRequest,
			pSrb->HwDeviceExtension);
    }

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CompleteDeviceSRB(pSrb=%x)\n", pSrb));
}
#endif //0

/*
** CodecCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**
** Returns:
** 
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL 
CodecCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2,
    BOOLEAN bCheckSize
    )
{
    BOOL	rval = FALSE;
    
    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":--->CodecCompareGUIDsAndFormatSize(DataRange1=%x,DataRange2=%x,bCheckSize=%s)\r\n", 
        DataRange1, DataRange2, bCheckSize ? "TRUE":"FALSE"));

	if ( IsEqualGUID(&DataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)
	  || IsEqualGUID(&DataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)
	  || IsEqualGUID(&DataRange1->MajorFormat, &DataRange2->MajorFormat) )
	{
		if ( !IsEqualGUID(&DataRange1->MajorFormat, &DataRange2->MajorFormat) )
		{
			CDebugPrint(DebugLevelVerbose,
				(CODECNAME ": CodecCompareGUIDsAndFormatSize : Matched MajorFormat Using Wildcard:\n\t[%s] vs. [%s]\n", 
				&DataRange1->MajorFormat, &DataRange2->MajorFormat ));
		}

		if ( IsEqualGUID(&DataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)
		  || IsEqualGUID(&DataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)
	      || IsEqualGUID(&DataRange1->SubFormat, &DataRange2->SubFormat) )
		{
			if ( !IsEqualGUID(&DataRange1->SubFormat, &DataRange2->SubFormat) )
			{
				CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": CodecCompareGUIDsAndFormatSize : Matched SubFormat Using Wildcard:\n\t[%s] vs. [%s]\n", 
					&DataRange1->SubFormat, &DataRange2->SubFormat ));
			}

			if ( IsEqualGUID(&DataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_NONE)
			  || IsEqualGUID(&DataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_NONE)
			  || IsEqualGUID(&DataRange1->Specifier, &DataRange2->Specifier) )
			{
				if ( !IsEqualGUID(&DataRange1->Specifier, &DataRange2->Specifier) )
				{
					CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecCompareGUIDsAndFormatSize : Matched Specifier Using Wildcard:\n\t[%s] vs. [%s]\n", 
						&DataRange1->Specifier, &DataRange2->Specifier ));
				}

				if ( !bCheckSize || DataRange1->FormatSize == DataRange2->FormatSize)
				{
					rval = TRUE;
				}
				else
				{
					CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecCompareGUIDsAndFormatSize : FormatSize mismatch=%d vs. %d\n", 
						DataRange1->FormatSize, DataRange2->FormatSize ));
				}
			}
			else
			{
				CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": CodecCompareGUIDsAndFormatSize : Specifier mismatch:\n\t[%s] vs. [%s]\n", 
					&DataRange1->Specifier, &DataRange2->Specifier ));
			}
		}
		else
		{
			CDebugPrint(DebugLevelVerbose,
				(CODECNAME ": CodecCompareGUIDsAndFormatSize : Subformat mismatch:\n\t[%s] vs. [%s]\n", 
				&DataRange1->SubFormat, &DataRange2->SubFormat ));
		}
	}
    else
	{
		CDebugPrint(DebugLevelVerbose,
			(CODECNAME ": CodecCompareGUIDsAndFormatSize : MajorFormat mismatch:\n\t[%s] vs. [%s]\n", 
			&DataRange1->MajorFormat, &DataRange2->MajorFormat ));
	}

    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":<---CodecCompareGUIDsAndFormatSize(DataRange1=%x,DataRange2=%x,bCheckSize=%s)=%s\n", 
		DataRange1, DataRange2, bCheckSize ? "TRUE":"FALSE", rval? "TRUE":"FALSE"));

    return rval;
}

/*
** CodecVerifyFormat()
**
**   Checks the validity of a format request
**
** Arguments:
**
**   pKSDataFormat - pointer to a KS_DATAFORMAT_VBIINFOHEADER structure.
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL 
CodecVerifyFormat(IN KSDATAFORMAT *pKSDataFormat, UINT StreamNumber, PKSDATARANGE pMatchedFormat )
{
    BOOL	rval = FALSE;
    ULONG     FormatCount;
    PKS_DATARANGE_VIDEO ThisFormat;
    PKS_DATAFORMAT_VBIINFOHEADER    pKSVBIDataFormat = ( PKS_DATAFORMAT_VBIINFOHEADER )pKSDataFormat;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecVerifyFormat(%x)\n", pKSDataFormat));
    
    for( FormatCount = 0; rval == FALSE && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
        FormatCount++ )
    {
        CDebugPrint(DebugLevelTrace,(CODECNAME , "Testing stream %d against format %x\r\n", StreamNumber, FormatCount ));
        
        ThisFormat = ( PKS_DATARANGE_VIDEO )Streams[StreamNumber].hwStreamInfo.StreamFormatsArray[FormatCount];

        if( !CodecCompareGUIDsAndFormatSize( pKSDataFormat, &ThisFormat->DataRange, FALSE ) )
        {
        	CDebugPrint( DebugLevelVerbose, ( CODECNAME ": General format mismatch\n" ));
        	continue;
        }
        if( IsEqualGUID( &ThisFormat->DataRange.Specifier, &KSDATAFORMAT_SPECIFIER_VBI ) )
        {
        	if( pKSVBIDataFormat->VBIInfoHeader.VideoStandard != KS_AnalogVideo_NTSC_M )
        	{
        		CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Incompatible video standard\n" ));
	           continue;
	        }
	        if( pKSVBIDataFormat->VBIInfoHeader.StartLine < MIN_VBI_Y_SAMPLES )
	        {
	        	CDebugPrint( DebugLevelVerbose, ( CODECNAME ": VBIInfoHeader.StartLine too small %u\n",
	           	pKSVBIDataFormat->VBIInfoHeader.StartLine ));
	           continue;
	        }
	        if( pKSVBIDataFormat->VBIInfoHeader.EndLine > MAX_VBI_Y_SAMPLES )
	        {
	        	CDebugPrint( DebugLevelVerbose, ( CODECNAME ": VBIInfoHeader.EndLine too big %u\n",
	           	pKSVBIDataFormat->VBIInfoHeader.EndLine ));
	           continue;
	        }
	        if( pKSVBIDataFormat->VBIInfoHeader.SamplesPerLine < MIN_VBI_X_SAMPLES ||
				pKSVBIDataFormat->VBIInfoHeader.SamplesPerLine > MAX_VBI_X_SAMPLES )
	        {
	        	CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Invalid VBIInfoHeader.SamplesPerLine %u\n",
	           	pKSVBIDataFormat->VBIInfoHeader.SamplesPerLine ));
				continue;
	        }             
	        rval = TRUE;
        }
        else
        if( IsEqualGUID( &ThisFormat->DataRange.Specifier, &KSDATAFORMAT_SPECIFIER_NONE ) )
        	rval = TRUE;
        else
        {
        	CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Incompatible major format\n" ));
        	continue;
        }
        if( rval == TRUE && pMatchedFormat )
           *pMatchedFormat = ThisFormat->DataRange;
    }
    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecVerifyFormat(%x)=%s\n", pKSDataFormat, rval? "TRUE":"FALSE"));
	return rval;
}

/*
** CodecVBIFormatFromRange()
**
**   Returns a DATAFORMAT from a DATARANGE
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb 
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL 
CodecVBIFormatFromRange( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	BOOL						bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange;
    BOOL                        OnlyWantsSize;
    ULONG                       StreamNumber;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecVBIFormatFromRange(pSrb=%x)\n", pSrb));

    IntersectInfo = pSrb->CommandData.IntersectInfo;
    StreamNumber = IntersectInfo->StreamNumber;
    DataRange = IntersectInfo->DataRange;

    pSrb->ActualBytesTransferred = 0;

    //
    // Check that the stream number is valid
    //

//    if (StreamNumber < DRIVER_STREAM_COUNT) 
//	{
		NumberOfFormatArrayEntries = 
				Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

		//
		// Get the pointer to the array of available formats
		//

		pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

		//
		// Is the caller trying to get the format, or the size of the format?
		//

		OnlyWantsSize = (IntersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG));

		//
		// Walk the formats supported by the stream searching for a match
		// of the three GUIDs which together define a DATARANGE
		//
		for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) 
		{
			if ( CodecCompareGUIDsAndFormatSize(DataRange, *pAvailableFormats, TRUE) )
			{
#ifdef KS_DATARANGE_VIDEO_VBI__EQ__KS_DATAFORMAT_VBIINFOHEADER
				ULONG	FormatSize = (*pAvailableFormats)->FormatSize;
#else
                PKS_DATARANGE_VIDEO_VBI pDataRangeVBI = (PKS_DATARANGE_VIDEO_VBI)*pAvailableFormats;
				ULONG	FormatSize = sizeof( KS_DATAFORMAT_VBIINFOHEADER );
#endif

				// Is the caller trying to get the format, or the size of the format?

				if ( IntersectInfo->SizeOfDataFormatBuffer == sizeof(FormatSize) )
				{					
       				CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecVBIFormatFromRange : Format Size=%d\n", 
						FormatSize));
					*(PULONG)IntersectInfo->DataFormatBuffer = FormatSize;
					pSrb->ActualBytesTransferred = sizeof(FormatSize);
					bStatus = TRUE;
				}
				else
				{
					// Verify that there is enough room in the supplied buffer for the whole thing
					if ( IntersectInfo->SizeOfDataFormatBuffer >= FormatSize ) 
					{
#ifdef KS_DATARANGE_VIDEO_VBI__EQ__KS_DATAFORMAT_VBIINFOHEADER
						RtlCopyMemory(IntersectInfo->DataFormatBuffer, *pAvailableFormats, FormatSize);
						pSrb->ActualBytesTransferred = FormatSize;
#else
                        PKS_DATAFORMAT_VBIINFOHEADER InterVBIHdr =
							(PKS_DATAFORMAT_VBIINFOHEADER)IntersectInfo->DataFormatBuffer;

						RtlCopyMemory(&InterVBIHdr->DataFormat, &pDataRangeVBI->DataRange, sizeof(KSDATARANGE));

						((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;

						RtlCopyMemory(&InterVBIHdr->VBIInfoHeader, &pDataRangeVBI->VBIInfoHeader, sizeof(KS_VBIINFOHEADER));
						pSrb->ActualBytesTransferred = FormatSize;
#endif
						bStatus = TRUE;
					}
					else
					{
       					CDebugPrint(DebugLevelVerbose,
							(CODECNAME ": CodecVBIFormatFromRange : Buffer Too Small=%d vs. %d\n", 
							IntersectInfo->SizeOfDataFormatBuffer, FormatSize));
						pSrb->Status = STATUS_BUFFER_TOO_SMALL;
					}
				}
				break;
			}
		}

		if ( j == NumberOfFormatArrayEntries )
		{
			CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecVBIFormatFromRange : Stream Format not found.\n" ));
		}

//	}
//	else
//	{
//		CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecVBIFormatFromRange : StreamNumber too big=%d\n", StreamNumber));
//        pSrb->Status = STATUS_NOT_IMPLEMENTED;
//        bStatus = FALSE;
//        CDEBUG_BREAK();
//    }

    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":<---CodecVBIFormatFromRange(pSrb=%x)=%s\n", 
		pSrb, bStatus ? "TRUE" : "FALSE" ));
    return bStatus;
}


/*
** CodecCCFormatFromRange()
**
**   Returns a DATAFORMAT from a DATARANGE
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb 
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL 
CodecCCFormatFromRange( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
	BOOL						bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange;
    BOOL                        OnlyWantsSize;
    ULONG                       StreamNumber;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecCCFormatFromRange(pSrb=%x)\n", pSrb));

    IntersectInfo = pSrb->CommandData.IntersectInfo;
    StreamNumber = IntersectInfo->StreamNumber;
    DataRange = IntersectInfo->DataRange;

    pSrb->ActualBytesTransferred = 0;

    //
    // Check that the stream number is valid
    //

//    if (StreamNumber < DRIVER_STREAM_COUNT) 
//	{
		NumberOfFormatArrayEntries = 
				Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

		//
		// Get the pointer to the array of available formats
		//

		pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

		//
		// Is the caller trying to get the format, or the size of the format?
		//

		OnlyWantsSize = (IntersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG));

		//
		// Walk the formats supported by the stream searching for a match
		// of the three GUIDs which together define a DATARANGE
		//
		for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) 
		{
			if ( CodecCompareGUIDsAndFormatSize(DataRange, *pAvailableFormats, TRUE) )
			{
                PKSDATARANGE pDataRangeCC = (PKSDATARANGE)*pAvailableFormats;
				ULONG	FormatSize = sizeof( KSDATARANGE );

				// Is the caller trying to get the format, or the size of it?

				if ( IntersectInfo->SizeOfDataFormatBuffer == sizeof(FormatSize) )
				{					
       				CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecCCFormatFromRange : Format Size=%d\n", 
						FormatSize));
					*(PULONG)IntersectInfo->DataFormatBuffer = FormatSize;
					pSrb->ActualBytesTransferred = sizeof(FormatSize);
					bStatus = TRUE;
				}
				else
				{
					// Verify that there is enough room in the supplied buffer
					//  for the whole thing
					if ( IntersectInfo->SizeOfDataFormatBuffer >= FormatSize ) 
					{
						PKSDATAFORMAT InterCCHdr =
							(PKSDATAFORMAT)IntersectInfo->DataFormatBuffer;

                        *InterCCHdr = *pDataRangeCC;

						InterCCHdr->FormatSize = FormatSize;

						pSrb->ActualBytesTransferred = FormatSize;

						bStatus = TRUE;
					}
					else
					{
       					CDebugPrint(DebugLevelVerbose,
							(CODECNAME ": CodecCCFormatFromRange : Buffer Too Small=%d vs. %d\n", 
							IntersectInfo->SizeOfDataFormatBuffer, FormatSize));
						pSrb->Status = STATUS_BUFFER_TOO_SMALL;
					}
				}
				break;
			}
		}

		if ( j == NumberOfFormatArrayEntries )
		{
			CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecCCFormatFromRange : Stream Format not found.\n" ));
		}

//	}
//	else
//	{
//		CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecVBIFormatFromRange : StreamNumber too big=%d\n", StreamNumber));
//        pSrb->Status = STATUS_NOT_IMPLEMENTED;
//        bStatus = FALSE;
//        CDEBUG_BREAK();
//    }

    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":<---CodecCCFormatFromRange(pSrb=%x)=%s\n", 
		pSrb, bStatus ? "TRUE" : "FALSE" ));
    return bStatus;
}

/*
** QueueAddIfNotEmpty
**
**   Adds an SRB to the current queue if it is not empty
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb 
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
** 
** TRUE if SRB was added (queue is not empty)
** FALSE if SRB was not added (queue is empty)
** Side Effects:  none
*/
BOOL STREAMAPI QueueAddIfNotEmpty( IN PHW_STREAM_REQUEST_BLOCK pSrb,
							IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   BOOL            bAddedSRB = FALSE;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueAddIfNotEmpty %x\n", pSrb ));
   CASSERT( pSrb );
   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;
   CASSERT( pSrbExtension );
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   if( !IsListEmpty( pQueue ))
   {
       pSrbExtension->pSrb = pSrb;
       InsertTailList( pQueue, &pSrbExtension->ListEntry );
       bAddedSRB = TRUE;
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ": %s%x\n", bAddedSRB ? 
       "Added SRB to Queue " : ": Queue is empty, not adding ", pSrb ));
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueAddIfNotEmpty %x\n", bAddedSRB ));
   
   return bAddedSRB;
}

/*
** QueueAdd
**
**   Adds an SRB to the current queue unconditionally
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb 
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
** 
** TRUE 
** Side Effects:  none
*/
BOOL STREAMAPI QueueAdd( IN PHW_STREAM_REQUEST_BLOCK pSrb,
							IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueAdd %x\n", pSrb ));
   
   CASSERT( pSrb );
   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;
   CASSERT( pSrbExtension );
   
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   
   pSrbExtension->pSrb = pSrb;
   InsertTailList( pQueue, &pSrbExtension->ListEntry );
   
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Added SRB %x to Queue\n", pSrb ));
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueAdd\n" ));
   
   return TRUE;
}


/*
** QueueRemove
**
**   Removes the next available SRB from the current queue
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK * pSrb 
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
**
** TRUE if SRB was removed
** FALSE if SRB was not removed
** Side Effects:  none
*/
                         
BOOL STREAMAPI QueueRemove( 
                           IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
							IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL                       Irql;
   BOOL                        bRemovedSRB = FALSE;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueRemove\n" ));
   
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   *pSrb = ( PHW_STREAM_REQUEST_BLOCK )NULL;
   CDebugPrint( DebugLevelVerbose,
       ( CODECNAME ": QFlink %x QBlink %x\n", pQueue->Flink, pQueue->Blink ));
   if( !IsListEmpty( pQueue ))
   {
       PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;
       PUCHAR          Ptr = ( PUCHAR )RemoveHeadList( pQueue );
       pCurrentSrb = ( PHW_STREAM_REQUEST_BLOCK * )((( PUCHAR )Ptr ) +
           sizeof( LIST_ENTRY ));
       CASSERT( *pCurrentSrb );
       *pSrb = *pCurrentSrb;
       bRemovedSRB = TRUE;
   }
   else
       CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Queue is empty\n" ));
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueRemove %x %x\n",
       bRemovedSRB, *pSrb ));
   return bRemovedSRB;
}

/*
** QueueRemoveSpecific
**
**   Removes a specific SRB from the queue
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb           
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
**
** TRUE if the SRB was found and removed
** FALSE if the SRB was not found
** 
** Side Effects:  none
*/

BOOL STREAMAPI QueueRemoveSpecific( 
							IN PHW_STREAM_REQUEST_BLOCK pSrb,
                           IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL           Irql;
   PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;
   PLIST_ENTRY     pCurrentEntry;
   BOOL            bRemovedSRB = FALSE;
   
   CASSERT( pSrb );
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueRemoveSpecific %x\n", pSrb ));
   
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   
   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while(( pCurrentEntry != pQueue ) && !bRemovedSRB )
       {
           pCurrentSrb = ( PHW_STREAM_REQUEST_BLOCK * )((( PUCHAR )pCurrentEntry ) + 
               sizeof( LIST_ENTRY ));
           CASSERT( *pCurrentSrb );
           if( *pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   if( IsListEmpty( pQueue ))
       CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Queue is empty\n" ));   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueRemoveSpecific %x\n",
       bRemovedSRB ));
   return bRemovedSRB;
}                                                        
/*
** QueueEmpty
**
**   Indicates whether or not the queue is empty
**
** Arguments:
**
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
**
** TRUE if queue is empty
** FALSE if queue is not empty
** Side Effects:  none
*/
BOOL STREAMAPI QueueEmpty(
                           IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL       Irql;
   BOOL        bEmpty = FALSE;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":---> QueueEmpty\n" ));
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   bEmpty = IsListEmpty( pQueue );  
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<--- QueueEmpty %x\n", bEmpty ));
   return bEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\coddebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __CODDEBUG_H
#define __CODDEBUG_H

#if DBG
#define DEBUG   1
#endif //DBG

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//======================================================;
//  Interfaces provided by this file:
//
//  	All interfaces provided by this file only exist and generate
//  	code when DEBUG is defined.  No code or data are generated when
//  	DEBUG is not defined.
//
//  	CDEBUG_BREAK()
//  		Causes a trap #3, which hopefully will put you
//  		in your debugger.
//
//  	CASSERT(exp)
//  		If <exp> evaluates to false, prints a failure message
//  		and calls CDEBUG_BREAK()
//
//  	CdebugPrint(level, (printf_args));
//  		If <level> is >= _CDebugLevel, then calls
//  		DbgPrint(printf_args)
//
//======================================================;

#ifdef DEBUG

#  if _X86_
#    define CDEBUG_BREAK()  { __asm { int 3 }; }
#  else
#    define CDEBUG_BREAK()  DbgBreakPoint()
#  endif

   extern char _CDebugAssertFail[];
#  define CASSERT(exp) {\
	if ( !(exp) ) {\
	    DbgPrint(_CDebugAssertFail, #exp, __FILE__, __LINE__); \
	    CDEBUG_BREAK(); \
	}\
    }

   extern enum STREAM_DEBUG_LEVEL _CDebugLevel;
#  define CDebugPrint(level, args) { if (level <= _CDebugLevel) DbgPrint args; }

#else /*DEBUG*/

#  define CDEBUG_BREAK()		{}
#  define CASSERT(exp)			{}
#  define CDebugPrint(level, args)	{}

#endif /*DEBUG*/


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // #ifndef __CODDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\codmain.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CODMAIN_H__
#define __CODMAIN_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "ccdecode.h"
#include "defaults.h"


#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

/**************************************************************/
/* Driver Name - Change this to reflect your executable name! */
/**************************************************************/

#define CODECNAME           "CCDecode"

    // ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

typedef enum {
    STREAM_VBI = 0,		// VBI samples in
    STREAM_CC,			// Decoded VBI out (Should be less "generic")
#ifdef CCINPUTPIN
    STREAM_CCINPUT,		// H/W decoded CC in
#endif // CCINPUTPIN        
	MAX_STREAM_COUNT
}; 
// The MAX_STREAM_COUNT value must be equal to DRIVER_STREAM_COUNT
// This particular value must be defined here to avoid circular references

// We manage multiple instances of each pin up to this limit
#define MAX_PIN_INSTANCES   8

#define BIT(n)             (((unsigned long)1)<<(n))
#define BITSIZE(v)         (sizeof(v)*8)
#define SETBIT(array,n)    (array[(n)/BITSIZE(*array)] |= BIT((n)%BITSIZE(*array)))
#define CLEARBIT(array,n)  (array[(n)/BITSIZE(*array)] &= ~BIT((n)%BITSIZE(*array)))
#define TESTBIT(array,n)   (BIT((n)%BITSIZE(*array)) == (array[(n)/BITSIZE(*array)] & BIT(n%BITSIZE(*array))))


/*****************************************************************************
*
* The following structures are samples of information that could be used in
* a device extension structure
*
*****************************************************************************/

//
// Result of DSP operation
//
typedef struct _DSPRESULT
{
	CHAR	Decoded[2];
    int		Confidence;
}DSPRESULT, *PDSPRESULT;
//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//

typedef struct _HW_DEVICE_EXTENSION {
    struct _STREAMEX *   pStrmEx[MAX_STREAM_COUNT][MAX_PIN_INSTANCES];   // Pointers to each stream
    UINT                 ActualInstances[MAX_STREAM_COUNT];              // Counter of instances per stream

    // Clock 
    REFERENCE_TIME       QST_Start;             // KeQuerySystemTime at run
    REFERENCE_TIME       QST_Now;               // KeQuerySystemTime currently
    REFERENCE_TIME       WallTime100ns;         // elapsed time based on KeQueryPerformanceCounter

    // The following VBICODECFILTERING_* fields are defaults for newly created output pins(copied)
    VBICODECFILTERING_SCANLINES         ScanlinesRequested; // Bitmask of requested scanlines
    VBICODECFILTERING_SCANLINES         ScanlinesDiscovered;// Bitmask of discovered scanlines
    VBICODECFILTERING_CC_SUBSTREAMS     SubstreamsRequested;// Bitmask of requested substream IDs 
    VBICODECFILTERING_CC_SUBSTREAMS     SubstreamsDiscovered;// Bitmask of discovered substream IDs

    // This is the global version of the STATISTICS property
    VBICODECFILTERING_STATISTICS_CC     Statistics;

    PDSPRESULT							DSPResult;	// Pointer to result array
    ULONG                               DSPResultStartLine;
    ULONG                               DSPResultEndLine;

    ULONG                               SubStreamState[CC_MAX_HW_DECODE_LINES][2];

    ALL_STREAM_INFO *                   Streams;

    ULONG                               fTunerChange;	// TV Tuner channel change in progress
    
    LIST_ENTRY                          AdapterSRBQueue;
    KSPIN_LOCK                          AdapterSRBSpinLock;
    BOOL                                bAdapterQueueInitialized;

#ifdef CCINPUTPIN
	// Last pictureNumber that decoded VBI data was processed
	// (used for coordination of multiple input pins)
    FAST_MUTEX                          LastPictureMutex;
    LONGLONG                            LastPictureNumber; 
#endif // CCINPUTPIN        
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//
 
typedef struct _STREAMEX
{
    PHW_DEVICE_EXTENSION                	pHwDevExt;	        	// For timer use
    PHW_STREAM_OBJECT                   	pStreamObject;      	// For timer use
    KS_VBI_FRAME_INFO                   	FrameInfo;          	// PictureNumber, etc.
    ULONG                               	fDiscontinuity;     	// Discontinuity since last valid
    ULONG                               	StreamInstance;     	// 0..NumberOfPossibleInstances-1
    LONGLONG 								LastPictureNumber;		// Last received picture number
    KSSTATE                             	KSState;            	// Run, Stop, Pause
    REFERENCE_TIME                      	FrameTime100ns;     	// elapsed time based on frames captured
    HANDLE                              	hMasterClock;
    HANDLE                              	hClock;
    KSDATAFORMAT                        	OpenedFormat;       	// Based on the actual open request.
    KSDATAFORMAT							MatchedFormat;			// Format that matched the open format.
    VBICODECFILTERING_SCANLINES         	ScanlinesRequested; 	// Bitmask of requested scanlines
    VBICODECFILTERING_SCANLINES         	ScanlinesDiscovered;	// Bitmask of discovered scanlines
    VBICODECFILTERING_SCANLINES         	LastOddScanlinesDiscovered; // Bitmask of scanlines last discovered
    VBICODECFILTERING_SCANLINES         	LastEvenScanlinesDiscovered; // Bitmask of scanlines last discovered
    VBICODECFILTERING_CC_SUBSTREAMS  		SubstreamsRequested;	// Bitmask of requested substream IDs 
    VBICODECFILTERING_CC_SUBSTREAMS  		SubstreamsDiscovered;	// Bitmask of discovered substream IDs
    VBICODECFILTERING_STATISTICS_CC_PIN		PinStats;               // CC Pin version of statistics property
    CCState                              	State;					// State variable for DSP
    KS_VBIINFOHEADER                        CurrentVBIInfoHeader;
    KSPIN_LOCK                              StreamControlSpinLock,	// Command queue spin lock
                                            StreamDataSpinLock;    	// Data queue spin lock
    LIST_ENTRY                              StreamDataQueue,		// Stream data queue
                                            StreamControlQueue;		// Stream command queue

#ifdef CCINPUTPIN
	// For when the VBI input pin is waiting for the HWCC input pin to catch up
	PHW_STREAM_REQUEST_BLOCK                pVBISrbOnHold;
    KSPIN_LOCK                              VBIOnHoldSpinLock;
#endif // CCINPUTPIN        
} STREAMEX, *PSTREAMEX;

//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
    LIST_ENTRY					ListEntry;
    PHW_STREAM_REQUEST_BLOCK	pSrb;
}SRB_EXTENSION, *PSRB_EXTENSION;

/*****************************************************************************
*
* the following section defines prototypes for the minidriver initialization
* routines
*
******************************************************************************/

//
// DriverEntry:
//
// This routine is called when the mini driver is first loaded.  The driver
// should then call the StreamClassRegisterAdapter function to register with
// the stream class driver
//

ULONG DriverEntry (PVOID Context1, PVOID Context2);

//
// This routine is called by the stream class driver with configuration
// information for an adapter that the mini driver should load on.  The mini
// driver should still perform a small verification to determine that the
// adapter is present at the specified addresses, but should not attempt to
// find an adapter as it would have with previous NT miniports.
//
// All initialization of the codec should also be performed at this time.
//

BOOLEAN CodecInitialize (IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This routine is called when the system is going to remove or disable the
// device.
//
// The mini-driver should free any system resources that it allocated at this
// time.  Note that system resources allocated for the mini-driver by the
// stream class driver will be free'd by the stream driver, and should not be
// free'd in this routine.  (Such as the HW_DEVICE_EXTENSION)
//

BOOLEAN CodecUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb);


BOOLEAN CodecQueryUnload ( PHW_STREAM_REQUEST_BLOCK pSrb);	// Not implemented currently


//
// This is the prototype for the Hardware Interrupt Handler.  This routine
// will be called if the minidriver registers for and receives an interrupt
//

BOOLEAN HwInterrupt ( IN PHW_DEVICE_EXTENSION pDeviceExtension );

//
// This is the prototype for the stream enumeration function.  This routine
// provides the stream class driver with the information on data stream types
// supported
//

VOID CodecStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream open function
//

VOID CodecOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream close function
//

VOID CodecCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the CodecReceivePacket routine.  This is the
// entry point for command packets that are sent to the codec (not to a
// specific open stream)
//

VOID STREAMAPI CodecReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the protoype for the cancel packet routine.  This routine enables
// the stream class driver to cancel an outstanding packet.
//

VOID STREAMAPI CodecCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the packet timeout function.  The codec may choose to ignore a
// packet timeout, or reset the codec and cancel the requests, as required.
//

VOID STREAMAPI CodecTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

VOID STREAMAPI CodecGetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI CodecSetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);

BOOL 
CodecCompareGUIDsAndFormatSize( IN PKSDATARANGE DataRange1,
                                IN PKSDATARANGE DataRange2,
                                BOOLEAN bCheckSize );

BOOL 
CodecVerifyFormat(IN KSDATAFORMAT *pKSDataFormat, 
                  IN UINT StreamNumber,
                  IN PKSDATARANGE pMatchedFormat );

BOOL
CodecVBIFormatFromRange(
        IN PHW_STREAM_REQUEST_BLOCK pSrb);
        
BOOL
CodecCCFormatFromRange(
		IN PHW_STREAM_REQUEST_BLOCK pSrb );        

void 
CompleteStreamSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb, 
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
         BOOL fUseNotification2,
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
        );
void 
CompleteDeviceSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb, 
         IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
         BOOL fReadyForNext
        );

//
// prototypes for data handling routines
//
void		CompleteStreamIRP (IN PHW_STREAM_REQUEST_BLOCK pSrb, BOOLEAN ReadyForNext);

VOID STREAMAPI VBIReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VBIReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
void		EnableIRQ(PHW_STREAM_OBJECT pstrm);
void		DisableIRQ(PHW_STREAM_OBJECT pstrm);

//
// prototypes for properties and states
//

VOID		VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
//VOID		VideoStreamSetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb); // Not implemented
VOID		VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoStreamSetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoStreamGetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);

// 
// system time functions
//

ULONGLONG	VideoGetSystemTime();

// 
// stream clock functions
//
VOID		VideoIndicateMasterClock(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// SRB Queue Management functions
//
BOOL STREAMAPI QueueAddIfNotEmpty( 
							IN PHW_STREAM_REQUEST_BLOCK,
							IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueAdd( 
							IN PHW_STREAM_REQUEST_BLOCK,
							IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueRemove( 
							IN OUT PHW_STREAM_REQUEST_BLOCK *,
							IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueRemoveSpecific( 
							IN PHW_STREAM_REQUEST_BLOCK,
                           IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );                           
BOOL STREAMAPI QueueEmpty(
                           IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );                         

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__CODMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\codprop.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// This file handles all codec property sets
//
#include <strmini.h>
#include <ksmedia.h>
#include "codmain.h"
#include "coddebug.h"

//#define SETDISCOVERED

// CodecFiltering Property Set functions
// -------------------------------------------------------------------

/*
** CodecSetCodecGlobalProperty ()
**
**    Handles Set operations on the Global Codec property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
CodecSetCodecGlobalProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    LONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY);        // size of data supplied
 
    ASSERT (nBytes >= sizeof (LONG));
    switch (Id) 
    {
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->ScanlinesRequested ) );
            RtlCopyMemory( &pHwDevExt->ScanlinesRequested, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
#ifdef SETDISCOVERED        
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->ScanlinesDiscovered ) );
            RtlCopyMemory( &pHwDevExt->ScanlinesDiscovered, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
#endif // SETDISCOVERED        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->SubstreamsRequested ) );
            RtlCopyMemory( &pHwDevExt->SubstreamsRequested, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
#ifdef SETDISCOVERED        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->SubstreamsDiscovered ) );
            RtlCopyMemory( &pHwDevExt->SubstreamsDiscovered, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
#endif // SETDISCOVERED        
        case KSPROPERTY_VBICODECFILTERING_STATISTICS:
		{
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->Statistics ) );
            RtlCopyMemory( &pHwDevExt->Statistics, &Property->Statistics, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : Unknown Property Id=%d\n", Id));
			CDEBUG_BREAK();
			break;
    }
}

/*
** CodecGetCodecGlobalProperty ()
**
**    Handles Get operations on the Global Codec property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/


VOID
CodecGetCodecGlobalProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    LONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY);        // size of data supplied

    ASSERT (nBytes >= sizeof (LONG));
    switch (Id) 
    {
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));
               
            nBytes = min( nBytes, sizeof(pHwDevExt->ScanlinesRequested ) );
            RtlCopyMemory( &Property->Scanlines, &pHwDevExt->ScanlinesRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->ScanlinesDiscovered ) );
            RtlCopyMemory( &Property->Scanlines, &pHwDevExt->ScanlinesDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pHwDevExt->ScanlinesDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->SubstreamsRequested ) );
            RtlCopyMemory( &Property->Substreams, &pHwDevExt->SubstreamsRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->SubstreamsDiscovered ) );
            RtlCopyMemory( &Property->Substreams, &pHwDevExt->SubstreamsDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pHwDevExt->SubstreamsDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_STATISTICS:
		{
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->Statistics ) );
            RtlCopyMemory( &Property->Statistics, &pHwDevExt->Statistics, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : Unknown Property Id=%d\n", Id));
			CDEBUG_BREAK();
			break;
    }
}

// -------------------------------------------------------------------
// General entry point for all get/set codec properties
// -------------------------------------------------------------------

/*
** CodecSetProperty ()
**
**    Handles Set operations for all codec properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
CodecSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID( &KSPROPSETID_Connection, &pSPD->Property->Set)) 
    {
        // CodecSetConnectionProperty(pSrb);
    }
    else if (IsEqualGUID( &KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
         CodecSetCodecGlobalProperty(pSrb);
    }
    else 
    {
        //
        // We should never get here
        //

        CDEBUG_BREAK();
    }
}

/*
** CodecGetProperty ()
**
**    Handles Get operations for all codec properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
CodecGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID( &KSPROPSETID_Connection, &pSPD->Property->Set)) 
    {
        // CodecGetConnectionProperty(pSrb);
    }
    else if (IsEqualGUID( &KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
        CodecGetCodecGlobalProperty(pSrb);
    }
    else 
    {
        //
        // We should never get here
        //
        CDEBUG_BREAK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\codstrm.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CODSTRM_H__
#define __CODSTRM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "defaults.h"

// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    )
};

DEFINE_KSPROPERTY_TABLE(StreamAllocatorProperties)
{
	DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR
    (
        FALSE,
        TRUE
    )
};

   
// ------------------------------------------------------------------------
// Per pin property set for VBI codec filtering
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VBICodecProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_CC_SUBSTREAMS),// MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty  
        sizeof(VBICODECFILTERING_CC_SUBSTREAMS),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
	 	KSPROPERTY_VBICODECFILTERING_STATISTICS,
 		TRUE,                                   // GetSupported or Handler
 		sizeof(KSPROPERTY),                     // MinProperty
 		sizeof(VBICODECFILTERING_STATISTICS_CC_PIN),// MinData
 		TRUE,                                   // SetSupported or Handler
 		NULL,                                   // Values
 		0,                                      // RelationsCount
 		NULL,                                   // Relations
 		NULL,                                   // SupportHandler
		0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
    	&KSPROPSETID_Stream,			 		 		 // Set
       SIZEOF_ARRAY(StreamAllocatorProperties),		 // PropertiesCount
       StreamAllocatorProperties,						 // PropertyItems
       0,												 // FastIoCount
       NULL											 // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VBICodecFiltering,                 // Set
        SIZEOF_ARRAY(VBICodecProperties),               // PropertiesCount
        VBICodecProperties,                             // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    )
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

KSDATARANGE StreamFormatCC = 
{
    // Definition of the CC stream
    {   
        sizeof (KSDATARANGE),           // FormatSize
        0,                              // Flags
        CCSamples,                      // SampleSize
        0,                              // Reserved
        { STATIC_KSDATAFORMAT_TYPE_AUXLine21Data },
        { STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair },
		 { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
    }
};

#ifdef CCINPUTPIN
# define GUIDKLUDGESTORAGE
# include "guidkludge.h"

KSDATARANGE StreamFormatCCin = 
{
    // Definition of the CC input stream
    {   
        sizeof (KSDATARANGE),           // FormatSize
        0,                              // Flags
        sizeof (CC_HW_FIELD),           // SampleSize
        0,                              // Reserved
        { STATIC_KSDATAFORMAT_TYPE_VBI },
        { STATIC_KSDATAFORMAT_SUBTYPE_CC },
        { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
    }
};
#endif // CCINPUTPIN


// Warning, the following VBI geometry is governed by the capture driver NOT
// the codecs.  Therefore, any specification of a VBI capture format will be
// ignored by most capture drivers.  Look at the KS_VBI_FRAME_INFO data on each
// sample to determine the actual data characteristics of the samples.

#define NORMAL_VBI_START_LINE   10
#define NORMAL_VBI_STOP_LINE    21

#define MIN_VBI_X_SAMPLES (720*2)
#define AVG_VBI_X_SAMPLES (VBISamples)
#define MAX_VBI_X_SAMPLES (1135*2)

#define MIN_VBI_Y_SAMPLES (1)
#define AVG_VBI_Y_SAMPLES (12)  
#define MAX_VBI_Y_SAMPLES (21)

#define MIN_VBI_T_SAMPLES (50)
#define AVG_VBI_T_SAMPLES (59.94)
#define MAX_VBI_T_SAMPLES (60)

#define NTSC_FSC_FREQUENCY  3580000
#define PAL_FSC_FREQUENCY   4430000

#define MIN_SAMPLING_RATE   (min(8*NTSC_FSC_FREQUENCY,8*PAL_FSC_FREQUENCY))
#define AVG_SAMPLING_RATE   (8*NTSC_FSC_FREQUENCY)
#define MAX_SAMPLING_RATE   (max(8*NTSC_FSC_FREQUENCY,8*PAL_FSC_FREQUENCY))

// This format is the "arbitrary one" that was used in early sample capture drivers!

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

KS_DATARANGE_VIDEO_VBI StreamFormatVBI =
{
    // KSDATARANGE
    {
        {
            sizeof( KS_DATARANGE_VIDEO_VBI ),
            0,
            VBISamples * VBILines,         // SampleSize
            0,                             // Reserved
            { STATIC_KSDATAFORMAT_TYPE_VBI },
			 { STATIC_KSDATAFORMAT_SUBTYPE_RAW8 },
            { STATIC_KSDATAFORMAT_SPECIFIER_VBI }
        }
    },
    TRUE,                                // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,                                // BOOL,  bTemporalCompression (all I frames?)
    KS_VIDEOSTREAM_VBI,                  // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
    0,                                   // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

    // _KS_VIDEO_STREAM_CONFIG_CAPS
    {
        { STATIC_KSDATAFORMAT_SPECIFIER_VBI },
        KS_AnalogVideo_NTSC_M,                              // AnalogVideoStandard
        {
            VBISamples, VBILines  // SIZE InputSize
        },
        {
            VBISamples, VBILines  // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
        },
        {
            VBISamples, VBILines  // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
        },
        1,                  // int CropGranularityX;       // granularity of cropping size
        1,                  // int CropGranularityY;
        1,                  // int CropAlignX;             // alignment of cropping rect
        1,                  // int CropAlignY;
        {
            VBISamples, VBILines  // SIZE MinOutputSize;         // smallest bitmap stream can produce
        },
        {
            VBISamples, VBILines  // SIZE MaxOutputSize;         // largest  bitmap stream can produce
        },
        1,                  // int OutputGranularityX;     // granularity of output bitmap size
        2,                  // int OutputGranularityY;
        0,                  // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,                  // StretchTapsY
        0,                  // ShrinkTapsX
        0,                  // ShrinkTapsY
        166834,             // LONGLONG MinFrameInterval;  // 100 nS units
        166834,             // LONGLONG MaxFrameInterval;

        // cool. Bits or Bytes? See other streams as well
        VBISamples * 30 * VBILines * 2, // LONG MinBitsPerSecond;
        VBISamples * 30 * VBILines * 2  // LONG MaxBitsPerSecond;
    },

    // KS_VBIINFOHEADER (default format)
    {
        VBIStart,               // StartLine  -- inclusive
        VBIEnd,                 // EndLine    -- inclusive
        SamplingFrequency,      // SamplingFrequency
        454,                    // MinLineStartTime;    // (uS past HR LE) * 100
        454,                    // MaxLineStartTime;    // (uS past HR LE) * 100
        454,                    // ActualLineStartTime  // (uS past HR LE) * 100
        5902,                   // ActualLineEndTime;   // (uS past HR LE) * 100
        KS_AnalogVideo_NTSC_M,  // VideoStandard;
        VBISamples,             // SamplesPerLine;
        VBISamples,             // StrideInBytes;
        VBISamples * VBILines   // BufferSize;
    }
};


//---------------------------------------------------------------------------
//  STREAM_Capture Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT VBIFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVBI,

    // Add more formats here for to mirror output formats for "passthrough" mode
    // The idea is that upstream capture drivers may have done some decoding
	// already or downstream drivers may wish to have the raw data without any
	// decoding at all.
    // In that case all we need to do is copy the data (if there is a pending
	// SRB) OR forward the SRB to the downstream client.
};
#define NUM_VBI_FORMATS (SIZEOF_ARRAY(VBIFormats))

#ifdef CCINPUTPIN
static PKSDATAFORMAT CCInputFormats[] =
{
	(PKSDATAFORMAT) &StreamFormatCCin
};
# define NUM_CC_INPUT_FORMATS (SIZEOF_ARRAY(CCInputFormats))   
#endif // CCINPUTPIN
  

static PKSDATAFORMAT DecodeFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatCC,
    //(PKSDATAFORMAT) &StreamFormatVBI	// Can't do VBI here since Stream1
	                                    //  does NOT use extended headers

    // Add more formats here for whatever CODEC output formats are supported.
};
#define NUM_DECODE_FORMATS (SIZEOF_ARRAY (DecodeFormats))

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

static ALL_STREAM_INFO Streams [] = 
{
  // -----------------------------------------------------------------
  // STREAM_VBI
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
	1,                                      // NumberOfPossibleInstances
	KSPIN_DATAFLOW_IN,                      // DataFlow
	TRUE,                                   // DataAccessible
	NUM_VBI_FORMATS,                        // NumberOfFormatArrayEntries
	VBIFormats,                             // StreamFormatsArray
	0,                                      // ClassReserved[0]
	0,                                      // ClassReserved[1]
	0,                                      // ClassReserved[2]
	0,                                      // ClassReserved[3]
	NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
	(PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
	0,                                      // NumStreamEventArrayEntries
	0,                                      // StreamEventsArray
	(GUID *)&PINNAME_VIDEO_VBI,             // Category
	(GUID *)&PINNAME_VIDEO_VBI,             // Name
	0,                                      // MediumsCount
	NULL,                                   // Mediums
   FALSE,
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
	sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
	STREAM_VBI,                                      // StreamNumber
	(PVOID)NULL,                            // HwStreamExtension
	VBIReceiveDataPacket,                 // HwReceiveDataPacket
	VBIReceiveCtrlPacket,                 // HwReceiveControlPacket
	{                                       // HW_CLOCK_OBJECT
	    NULL,                                // .HWClockFunction
	    0,                                   // .ClockSupportFlags
	},
	FALSE,                                  // Dma
	TRUE,                                  // Pio
	(PVOID)NULL,                            // HwDeviceExtension
	sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
	0,                                      // StreamHeaderWorkspace 
	TRUE,                                  // Allocator 
	NULL,                                   // HwEventRoutine
    },
  },

  // -----------------------------------------------------------------
  // STREAM_Decode (Closed Caption Output )
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
	MAX_PIN_INSTANCES,                      // NumberOfPossibleInstances
	KSPIN_DATAFLOW_OUT,                     // DataFlow
	TRUE,                                   // DataAccessible
	NUM_DECODE_FORMATS,                     // NumberOfFormatArrayEntries
	DecodeFormats,                          // StreamFormatsArray
	0,                                      // ClassReserved[0]
	0,                                      // ClassReserved[1]
	0,                                      // ClassReserved[2]
	0,                                      // ClassReserved[3]
	NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
	(PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
	0,                                      // NumStreamEventArrayEntries;
	0,                                      // StreamEventsArray;
	(GUID *)&PINNAME_VIDEO_CC,             // Category
	(GUID *)&PINNAME_VIDEO_CC,             // Name
	0,                                      // MediumsCount
	NULL,                                   // Mediums
   FALSE,
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
	sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
	STREAM_CC,                                      // StreamNumber
	(PVOID)NULL,                            // HwStreamExtension
	VBIReceiveDataPacket,                 // HwReceiveDataPacket
	VBIReceiveCtrlPacket,                 // HwReceiveControlPacket
	{                                       // HW_CLOCK_OBJECT
	    NULL,                                // .HWClockFunction
	    0,                                   // .ClockSupportFlags
	},
	FALSE,                                  // Dma
	TRUE,                                   // Pio
	(PVOID)NULL,                            // HwDeviceExtension
	0,             							// StreamHeaderMediaSpecific
	0,                                      // StreamHeaderWorkspace 
	TRUE,                                   // Allocator 
	NULL,                                   // HwEventRoutine
    },
  },

#ifdef CCINPUTPIN
  // -----------------------------------------------------------------
  // STREAM_CCInput (Closed Caption Input )
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
		1,                      		// NumberOfPossibleInstances
		KSPIN_DATAFLOW_IN,              // DataFlow
		TRUE,                           // DataAccessible
		NUM_CC_INPUT_FORMATS,           // NumberOfFormatArrayEntries
		CCInputFormats,                 // StreamFormatsArray
		0,                                      // ClassReserved[0]
		0,                                      // ClassReserved[1]
		0,                                      // ClassReserved[2]
		0,                                      // ClassReserved[3]
		NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
		(PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
		0,                                      // NumStreamEventArrayEntries;
		0,                                      // StreamEventsArray;
		(GUID *)&PINNAME_VIDEO_CC_CAPTURE,      // Category
		(GUID *)&PINNAME_VIDEO_CC_CAPTURE,      // Name
		0,                                      // MediumsCount
		NULL,                                   // Mediums
   	FALSE,
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
		sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
		STREAM_CCINPUT,                         // StreamNumber
		(PVOID)NULL,                            // HwStreamExtension
		VBIReceiveDataPacket,                 	// HwReceiveDataPacket
		VBIReceiveCtrlPacket,                 	// HwReceiveControlPacket
		{                                       // HW_CLOCK_OBJECT
	    	NULL,                               // .HWClockFunction
	    	0,                                  // .ClockSupportFlags
		},
		FALSE,                                  // Dma
		TRUE,                                   // Pio
		(PVOID)NULL,                            // HwDeviceExtension
		0,             							// StreamHeaderMediaSpecific
		0,                                      // StreamHeaderWorkspace 
		TRUE,                                   // Allocator 
		NULL,                                   // HwEventRoutine
    }
  },
#endif // CCINPUTPIN
};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    // {07DAD660-22F1-11d1-A9F4-00C04FBBDE8F}
    STATIC_KSCATEGORY_VBICODEC 
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    NULL,
    0,
    NULL
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader = 
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif // __CODSTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\defaults.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;
#ifndef __DEFAULTS_H
#define __DEFAULTS_H

#define CCSamples 	2
#define VBISamples ( 800 * 2 )
#define VBIStart 10
#define VBIEnd   21
#define VBILines ( VBIEnd - VBIStart + 1 )
#define SamplingFrequency 28636363

typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\codprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CODPROP_H
#define __CODPROP_H

// ------------------------------------------------------------------------
// Property set for 
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(DefaultCodecProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_CC_SUBSTREAMS),// MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_CC_SUBSTREAMS),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
	 	KSPROPERTY_VBICODECFILTERING_STATISTICS,
 		TRUE,                                   // GetSupported or Handler
 		sizeof(KSPROPERTY),                     // MinProperty
 		sizeof(VBICODECFILTERING_STATISTICS_CC),// MinData
 		TRUE,                                   // SetSupported or Handler
 		NULL,                                   // Values
 		0,                                      // RelationsCount
 		NULL,                                   // Relations
 		NULL,                                   // SupportHandler
		0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by the codec
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(CodecPropertyTable)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VBICodecFiltering,
        SIZEOF_ARRAY(DefaultCodecProperties),
        DefaultCodecProperties,
        0, 
        NULL
    ),
};

#define NUMBER_OF_CODEC_PROPERTY_SETS (SIZEOF_ARRAY (CodecPropertyTable))

#endif // __CODPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\host.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

typedef int BOOL;
#include <strmini.h>
#include <ksmedia.h>
#include "kskludge.h"
#include "coddebug.h"
#define malloc(bytes)    ExAllocatePool(NonPagedPool, (bytes))
#define free(ptr)        ExFreePool(ptr)
#define inline            __inline
#undef ASSERT
#ifdef DEBUG
#  define ASSERT(exp)    CASSERT(exp)
#else /*DEBUG*/
#  define ASSERT(exp)
#endif /*DEBUG*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\kskludge.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef CC_MAX_HW_DECODE_LINES

///////////////////////////////////////////////////////////////////
// Hardware decoded CC stream format
///////////////////////////////////////////////////////////////////

#define CC_MAX_HW_DECODE_LINES 12
typedef struct _CC_BYTE_PAIR {
    BYTE        Decoded[2];
	USHORT		Reserved;
} CC_BYTE_PAIR, *PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
    VBICODECFILTERING_SCANLINES  ScanlinesRequested;
	ULONG                        fieldFlags;	// KS_VBI_FLAG_FIELD1,2
    LONGLONG                     PictureNumber;
	CC_BYTE_PAIR                 Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD, *PCC_HW_FIELD;

#endif //!defined(CC_MAX_HW_DECODE_LINES)


#ifndef KS_VBIDATARATE_NABTS

// VBI Sampling Rates 
#define KS_VBIDATARATE_NABTS			(5727272)
#define KS_VBIDATARATE_CC       		( 503493)    // ~= 1/1.986125e-6
#define KS_VBISAMPLINGRATE_4X_NABTS		((int)(4*KS_VBIDATARATE_NABTS))
#define KS_VBISAMPLINGRATE_47X_NABTS	((int)(27000000))
#define KS_VBISAMPLINGRATE_5X_NABTS		((int)(5*KS_VBIDATARATE_NABTS))

#define KS_47NABTS_SCALER				(KS_VBISAMPLINGRATE_47X_NABTS/KS_VBIDATARATE_NABTS)

#endif //!defined(KS_VBIDATARATE_NABTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\codvideo.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include <strmini.h>
#include <ksmedia.h>
#include "kskludge.h"
#include "codmain.h"
#include "coddebug.h"
#include <ntstatus.h>
#include "defaults.h"
#include "ccdecode.h"
#include "ccformatcodes.h"

#ifdef PERFTEST
extern enum STREAM_DEBUG_LEVEL _CDebugLevel;
enum STREAM_DEBUG_LEVEL OldLevel;
ULONGLONG PerfThreshold = 250;
#endif // PERFTEST



//==========================================================================;
// Routines for processing VBI streams
//==========================================================================;

void
CheckResultsArray(
        PHW_DEVICE_EXTENSION  pHwDevExt,
        unsigned int          StartLine,
        unsigned int          EndLine )
{
    PDSPRESULT              new;

    //
    // (Re)size the results array if needed
    //
    if( 0 == pHwDevExt->DSPResult ||
        EndLine > pHwDevExt->DSPResultEndLine ||
        StartLine < pHwDevExt->DSPResultStartLine )
    {
        if (StartLine > pHwDevExt->DSPResultStartLine)
            StartLine = pHwDevExt->DSPResultStartLine;

        if (EndLine < pHwDevExt->DSPResultEndLine)
            EndLine = pHwDevExt->DSPResultEndLine;

        new = ( PDSPRESULT ) ExAllocatePool(
                NonPagedPool,
                sizeof( DSPRESULT ) * ( EndLine - StartLine + 1 ) );

        if( new ) {
            if (pHwDevExt->DSPResult)
                ExFreePool( pHwDevExt->DSPResult );
            pHwDevExt->DSPResult = new;
            pHwDevExt->DSPResultStartLine = StartLine;
            pHwDevExt->DSPResultEndLine = EndLine;

            CDebugPrint( DebugLevelInfo,
                    (CODECNAME ": Resized results array\n" ));
        }
        else {
            CDebugPrint( DebugLevelInfo,
                    (CODECNAME ": Resize results array failed\n" ));
            CASSERT( new );
            pHwDevExt->Statistics.Common.InternalErrors++;
        }
    }
}

/*
** CheckNewVBIInfo
**
** Checks for a new VBIInfoHeader
**
** Here's a little trickery to save having separate builds for the infinite pin
** tee and MSTee filters.  IPT, being Ring3, doesn't pass VBIInfoHeaders, but it
** does pass the flags to show they've changed.  We only make a copy if the
** data is good, otherwise we stick with the default header we started with.
**
** Arguments:
**
**         PHW_DEVICE_EXTENSION pHwDevExt
**         PSTREAMEX            pInStrmEx
**         PKS_VBI_FRAME_INFO   pInVBIFrameInfo
**         PKSSTREAM_HEADER     pInStreamHeader
**
** Returns:       nothing
**
** Side Effects:  none
*/
int CheckNewVBIInfo(
        PHW_DEVICE_EXTENSION   pHwDevExt,
        PSTREAMEX              pInStrmEx,
        PKS_VBI_FRAME_INFO     pInVBIFrameInfo
    )
{
    PKS_VBIINFOHEADER       pVBIInfoHeader = &pInStrmEx->CurrentVBIInfoHeader;
    PVBICODECFILTERING_STATISTICS_CC  Stats = &pHwDevExt->Statistics;

    if( 0 == pInVBIFrameInfo->VBIInfoHeader.StartLine
        || 0 == pInVBIFrameInfo->VBIInfoHeader.EndLine
        || 0 == pInVBIFrameInfo->VBIInfoHeader.ActualLineStartTime )
    {
        return 0;
    }

    CDebugPrint( DebugLevelInfo, (CODECNAME ": VBIInfoHeader Change\n" ));
    Stats->Common.VBIHeaderChanges++;

    //
    // Resize the results array if needed
    //
    CheckResultsArray(pHwDevExt,
            pInVBIFrameInfo->VBIInfoHeader.StartLine,
            pInVBIFrameInfo->VBIInfoHeader.EndLine);

    //
    // Copy new VBI info header over old
    //
    RtlCopyMemory( pVBIInfoHeader,
            &pInVBIFrameInfo->VBIInfoHeader,
            sizeof( KS_VBIINFOHEADER ));
    //pVBIInfoHeader->ActualLineStartTime = 780;
    RtlZeroMemory( &pInStrmEx->ScanlinesDiscovered,
            sizeof( pInStrmEx->ScanlinesDiscovered ));
    RtlZeroMemory( &pInStrmEx->SubstreamsDiscovered,
            sizeof( pInStrmEx->SubstreamsDiscovered ));
    
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->StartLine             %lu\n",
            pVBIInfoHeader->StartLine ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->EndLine               %lu\n",
            pVBIInfoHeader->EndLine ));         
    //CDebugPrint( DebugLevelVerbose,
    //      ( CODECNAME ": VBIInfoHeader->SamplingFrequency     %lu\n",
    //      pVBIInfoHeader->SamplingFrequency ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->MinLineStartTime      %lu\n",
            pVBIInfoHeader->MinLineStartTime ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->MaxLineStartTime      %lu\n",
            pVBIInfoHeader->MaxLineStartTime ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->ActualLineStartTime   %lu\n",
            pVBIInfoHeader->ActualLineStartTime ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->ActualLineEndTime     %lu\n",
            pVBIInfoHeader->ActualLineEndTime ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->VideoStandard         %lu\n",
            pVBIInfoHeader->VideoStandard ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->SamplesPerLine        %lu\n",
            pVBIInfoHeader->SamplesPerLine ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->StrideInBytes         %lu\n",
            pVBIInfoHeader->StrideInBytes ));
    CDebugPrint( DebugLevelVerbose,
            ( CODECNAME ": VBIInfoHeader->BufferSize            %lu\n",
            pVBIInfoHeader->BufferSize ));

   return 1;
}

/*
** ProcessChannelChange
**
** Handles a VBI_FLAG_TVTUNER_CHANGE event
**
** Arguments:
**
**         PHW_DEVICE_EXTENSION pHwDevExt
**         PSTREAMEX            pInStrmEx
**         PKS_VBI_FRAME_INFO   pInVBIFrameInfo
**         PKSSTREAM_HEADER     pInStreamHeader
**
** Returns:       nothing
**
** Side Effects:  none
*/
int ProcessChannelChange(
        PHW_DEVICE_EXTENSION  pHwDevExt,
        PSTREAMEX             pInStrmEx,
        PKS_VBI_FRAME_INFO    pInVBIFrameInfo,
        PKSSTREAM_HEADER      pInStreamHeader
    )
{
    PKS_VBIINFOHEADER       pVBIInfoHeader = &pInStrmEx->CurrentVBIInfoHeader;
    PVBICODECFILTERING_STATISTICS_CC  Stats = &pHwDevExt->Statistics;
    PKS_TVTUNER_CHANGE_INFO pChangeInfo = &pInVBIFrameInfo->TvTunerChangeInfo;
    ULONG   CurrentStrmEx;
    ULONG   i;

    if( pChangeInfo->dwFlags & KS_TVTUNER_CHANGE_BEGIN_TUNE )
    {
        CDebugPrint( DebugLevelInfo, (CODECNAME ": TVTuner Change START\n" ));
        pHwDevExt->fTunerChange = TRUE;
    }
    else if( pChangeInfo->dwFlags & KS_TVTUNER_CHANGE_END_TUNE )
    {
        Stats->Common.TvTunerChanges++;
        pHwDevExt->fTunerChange = FALSE;
        CDebugPrint( DebugLevelInfo, (CODECNAME ": TVTuner Change END\n" ));
        RtlZeroMemory( &pInStrmEx->ScanlinesDiscovered,
                sizeof( pInStrmEx->ScanlinesDiscovered ));
        RtlZeroMemory( &pInStrmEx->SubstreamsDiscovered,
                sizeof( pInStrmEx->SubstreamsDiscovered ));
        CurrentStrmEx = 0;
        //
        // Flag a discontuity.  This is passed to outgoing SRBs and will force
        //  the downstream Line 21 decoder to clear its current CC data off the
        //  screen.
        //
        for( i = 0; i < pHwDevExt->ActualInstances[STREAM_CC]; i++ )
        {
            PSTREAMEX   pOutStrmEx;
            PHW_STREAM_REQUEST_BLOCK pOutSrb;
            PVBICODECFILTERING_STATISTICS_CC_PIN PinStats;
        
            do
            {
               CASSERT( CurrentStrmEx < MAX_PIN_INSTANCES );
               pOutStrmEx = pHwDevExt->pStrmEx[STREAM_CC][CurrentStrmEx++];
            }while( !pOutStrmEx );
        
            PinStats = &pOutStrmEx->PinStats;
        
            //
            // Get the next output stream SRB if it's available.
            //
            if( QueueRemove( &pOutSrb,
                   &pOutStrmEx->StreamDataSpinLock,
                   &pOutStrmEx->StreamDataQueue ) )
            {
                PKSSTREAM_HEADER    pOutStreamHeader = pOutSrb->CommandData.DataBufferArray;
                PKS_VBI_FRAME_INFO  pOutVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pOutStreamHeader+1);
                PUCHAR              pOutData = (PUCHAR)pOutStreamHeader->Data;

               if( pOutStreamHeader->FrameExtent < CCSamples )
               {
                   CDebugPrint( DebugLevelError,
                       ( CODECNAME ": Outgoing Data SRB buffer is too small %u\n",
                       pOutStreamHeader->FrameExtent ));
                   PinStats->Common.InternalErrors++;
                   Stats->Common.OutputFailures++;
                   pOutStreamHeader->DataUsed = 0;
               }
               else
               {
                   PinStats->Common.SRBsProcessed++;
                   Stats->Common.OutputSRBsProcessed++;
                   CDebugPrint( DebugLevelInfo,
                     (CODECNAME ": Propagating data discontinuity, instance %u\n", i ));
                    pOutData[0] = 0;
                    pOutData[1] = 0;
                    pOutStreamHeader->DataUsed = 2;
                    pOutStreamHeader->OptionsFlags =
                        pInStreamHeader->OptionsFlags |
                        KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                    CDebugPrint( DebugLevelInfo,
                     (CODECNAME ": OptionsFlags %x\n", pOutStreamHeader->OptionsFlags ));
                    CDebugPrint( DebugLevelInfo,
                     ("" "Time %x Num %x Denom %x\n",
                       pInStreamHeader->PresentationTime.Time,
                       pInStreamHeader->PresentationTime.Numerator,
                       pInStreamHeader->PresentationTime.Denominator
                     ));
                    RtlCopyMemory( &pOutStreamHeader->PresentationTime,
                            &pInStreamHeader->PresentationTime,
                            sizeof( pOutStreamHeader->PresentationTime ));
                    pOutStreamHeader->Duration = pInStreamHeader->Duration;
               }
               CDebugPrint( DebugLevelVerbose,
                       ( CODECNAME ": Releasing Output SRB %x\n", pOutSrb ));
               // Complete the output SRB
               StreamClassStreamNotification( StreamRequestComplete,
                       pOutSrb->StreamObject, pOutSrb );
               pOutStrmEx->fDiscontinuity = FALSE;
               PinStats->Common.BytesOutput += pOutStreamHeader->DataUsed;
               Stats->Common.BytesOutput += pOutStreamHeader->DataUsed;
           }
           else
           {
               pOutStrmEx->fDiscontinuity = TRUE;
               Stats->Common.OutputSRBsMissing++;
           }
       }

       return 1;
    }

    return 0;
}

void
DebugPrintSubStreamMode( DWORD dwMode )
{
#ifdef DEBUG
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_XDS )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[XDS]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_CC1 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[CC1]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_CC2 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[CC2]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_CC3 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[CC3]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_CC4 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[CC4]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_T1 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[T1]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_T2 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[T2]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_T3 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[T3]" ));
    }
    if ( dwMode & KS_CC_SUBSTREAM_SERVICE_T4 )
    {
        CDebugPrint( DebugLevelWarning, ( "\n[T4]" ));
    }
#endif
}


// Get the substream mode for the current data sample - optionally change the substream mode
// The following "protocol" is loosely defined by FCC 91-119, FCC 92-157 and EIA 608
// Be advised that EIA 608 describes clearly which (few) byte pairs change the substream mode

DWORD
GetSubStreamMode( DWORD dwFrameFlags, LPDWORD pdwCurrentSubStreamMode, PDSPRESULT pDSPResult )
{
    DWORD   dwSubStreamMode = *pdwCurrentSubStreamMode;
    DWORD   dwDataChannel = 0;

    dwFrameFlags &= (KS_VBI_FLAG_FIELD1 | KS_VBI_FLAG_FIELD2);

    if ( pDSPResult->Confidence >= 75 )
    {
        // Inspect the first byte(minus parity) to see what substream this might be
        switch ( pDSPResult->Decoded[0] & 0x7F )
        {
        case    CC_XDS_START_CURRENT:
        case    CC_XDS_CONTINUE_CURRENT:
        case    CC_XDS_START_FUTURE:
        case    CC_XDS_CONTINUE_FUTURE:
        case    CC_XDS_START_CHANNEL:
        case    CC_XDS_CONTINUE_CHANNEL:
        case    CC_XDS_START_MISC:
        case    CC_XDS_CONTINUE_MISC:
        case    CC_XDS_START_PUBLIC_SERVICE:
        case    CC_XDS_CONTINUE_PUBLIC_SERVICE:
        case    CC_XDS_START_RESERVED:
        case    CC_XDS_CONTINUE_RESERVED:
        case    CC_XDS_START_UNDEFINED:
        case    CC_XDS_CONTINUE_UNDEFINED:
        case    CC_XDS_END:
            // Set the substream mode as XDS from here on out
            dwSubStreamMode = ( dwFrameFlags | KS_CC_SUBSTREAM_SERVICE_XDS);
            DebugPrintSubStreamMode( dwSubStreamMode );
            *pdwCurrentSubStreamMode = dwSubStreamMode;
            break;
        case    CC_MCC_FIELD1_DC1:
            dwDataChannel = KS_CC_SUBSTREAM_SERVICE_CC1;
            break;
        case    CC_MCC_FIELD1_DC2:
            dwDataChannel = KS_CC_SUBSTREAM_SERVICE_CC2;
            break;
        case    CC_MCC_FIELD2_DC1:
            dwDataChannel = KS_CC_SUBSTREAM_SERVICE_CC3;
            break;
        case    CC_MCC_FIELD2_DC2:
            dwDataChannel = KS_CC_SUBSTREAM_SERVICE_CC4;
            break;
        }

        // If we found a data channel escape, inspect the second byte(minus parity) to see what substream may be.
        if ( dwDataChannel )
        {
            switch ( pDSPResult->Decoded[1] & 0x7F )
            {
            case    CC_MCC_RCL:
            case    CC_MCC_RU2:
            case    CC_MCC_RU3:
            case    CC_MCC_RU4:
            case    CC_MCC_RDC:
            case    CC_MCC_EOC:
                // The mode is good for this data pair and thereafter
                dwSubStreamMode = (dwFrameFlags | dwDataChannel);
                DebugPrintSubStreamMode( dwSubStreamMode );
                *pdwCurrentSubStreamMode = dwSubStreamMode;
                break;
            case    CC_MCC_TR:
            case    CC_MCC_RTD:
                // The mode is TEXT rather CC, map to the text channel ids
                switch ( dwDataChannel )
                {
                case    KS_CC_SUBSTREAM_SERVICE_CC1:
                    dwDataChannel = KS_CC_SUBSTREAM_SERVICE_T1;
                    break;
                case    KS_CC_SUBSTREAM_SERVICE_CC2:
                    dwDataChannel = KS_CC_SUBSTREAM_SERVICE_T2;
                    break;
                case    KS_CC_SUBSTREAM_SERVICE_CC3:
                    dwDataChannel = KS_CC_SUBSTREAM_SERVICE_T3;
                    break;
                case    KS_CC_SUBSTREAM_SERVICE_CC4:
                    dwDataChannel = KS_CC_SUBSTREAM_SERVICE_T4;
                    break;
                }
                // The mode is good for this data byte pair and thereafter
                dwSubStreamMode = (dwFrameFlags | dwDataChannel);
                DebugPrintSubStreamMode( dwSubStreamMode );
                *pdwCurrentSubStreamMode = dwSubStreamMode;
                break;
            case    CC_MCC_EDM:
            case    CC_MCC_ENM:
                // The mode is only good for this data byte pair. Reverts back thereafter
                dwSubStreamMode = (dwFrameFlags | dwDataChannel);
                DebugPrintSubStreamMode( dwSubStreamMode );
                DebugPrintSubStreamMode( *pdwCurrentSubStreamMode );
                break;
            }
        }
    }
    return dwSubStreamMode;
}

/*
** OutputCC
**
**   Outputs just-decoded/received CC to any interested pins
**
** Arguments:
**
**         PHW_DEVICE_EXTENSION pHwDevExt
**         PSTREAMEX            pInStrmEx
**         PKS_VBI_FRAME_INFO   pInVBIFrameInfo
**         PKSSTREAM_HEADER     pInStreamHeader
**
** Returns:       nothing
**
** Side Effects:  none
*/

void OutputCC(
        PHW_DEVICE_EXTENSION pHwDevExt,
        PSTREAMEX            pInStrmEx,
        DWORD                dwOriginalFrameFlags,
        PKSSTREAM_HEADER     pInStreamHeader )
{
    ULONG                   i,
                            ScanlineCount,
                            CurrentStrmEx = 0;
    PKS_VBIINFOHEADER       pVBIInfoHeader = &pInStrmEx->CurrentVBIInfoHeader;
    PVBICODECFILTERING_STATISTICS_CC Stats = 0;

#ifdef PERFTEST
    ULONGLONG               PerfStartTime = 0,
                            PerfPreDownstreamCompletion = 0,
                            PerfPostDownstreamCompletion = 0;
    LARGE_INTEGER           PerfFrequency;

    PerfStartTime = KeQueryPerformanceCounter( &PerfFrequency ).QuadPart;
    OldLevel = _CDebugLevel;
    _CDebugLevel = DebugLevelFatal;
                                                        
#endif // PERFTEST

    CASSERT(pHwDevExt);
    CASSERT(pInStrmEx);
    Stats = &pHwDevExt->Statistics;
    CDebugPrint( DebugLevelInfo, ( "*" ));
    CDebugPrint( DebugLevelTrace, ( CODECNAME ": --->OutputCC\n" ));

    // If this substream is requested by anybody (field or cc data channel)
    if(( pInStrmEx->SubstreamsRequested.SubstreamMask ))
    {
        // Loop through all pending outbound requests and fill each irp with the requested data then complete the IO
        for( ScanlineCount = pVBIInfoHeader->StartLine; ScanlineCount <= pVBIInfoHeader->EndLine;
        ScanlineCount++ )
        {
            DWORD dwSubStreams = 0;
            DWORD dwFieldIndex = dwOriginalFrameFlags & KS_VBI_FLAG_FIELD1 ? 0 : 1;
            DWORD dwScanLineIndex = ScanlineCount - pHwDevExt->DSPResultStartLine;

            if( !TESTBIT( pInStrmEx->ScanlinesRequested.DwordBitArray, ScanlineCount ))
                continue;

            dwSubStreams = GetSubStreamMode( 
                dwOriginalFrameFlags, 
                &pHwDevExt->SubStreamState[dwScanLineIndex][dwFieldIndex],
                &pHwDevExt->DSPResult[dwScanLineIndex]
                );

            CDebugPrint( DebugLevelWarning, ( "%c%c",
                pHwDevExt->DSPResult[dwScanLineIndex].Decoded[0] & 0x7f,
                pHwDevExt->DSPResult[dwScanLineIndex].Decoded[1] & 0x7f ));

            CDebugPrint( DebugLevelInfo, (CODECNAME ": F%u %luus L%u %u%% %02x %02x\n",
                dwSubStreams & pInStrmEx->SubstreamsRequested.SubstreamMask,
                 pVBIInfoHeader->ActualLineStartTime,
                ScanlineCount,  
                pHwDevExt->DSPResult[dwScanLineIndex].Confidence,
                pHwDevExt->DSPResult[dwScanLineIndex].Decoded[0] & 0xff,
                pHwDevExt->DSPResult[dwScanLineIndex].Decoded[1] & 0xff ));


            CurrentStrmEx = 0;
            for( i = 0; i < pHwDevExt->ActualInstances[STREAM_CC]; i++ )
            {
                PSTREAMEX                   pOutStrmEx;
                PHW_STREAM_REQUEST_BLOCK    pOutSrb;
                PVBICODECFILTERING_STATISTICS_CC_PIN PinStats;

                do
                {
                    CASSERT( CurrentStrmEx < MAX_PIN_INSTANCES );
                    if( CurrentStrmEx == MAX_PIN_INSTANCES )
                        Stats->Common.InternalErrors++;
                    pOutStrmEx = pHwDevExt->pStrmEx[STREAM_CC][CurrentStrmEx++];
                }while( !pOutStrmEx );

                if( !TESTBIT( pOutStrmEx->ScanlinesRequested.DwordBitArray, ScanlineCount ) ||
                    !( pOutStrmEx->SubstreamsRequested.SubstreamMask & dwSubStreams ))
                    continue;

                PinStats = &pOutStrmEx->PinStats;
                //
                // Update the average confidence for this pin
                //
                PinStats->Common.LineConfidenceAvg = ( PinStats->Common.LineConfidenceAvg +
                    pHwDevExt->DSPResult[dwScanLineIndex].Confidence ) / 2;
                if( pHwDevExt->DSPResult[dwScanLineIndex].Confidence >= 75 )
                {
                    SETBIT( pInStrmEx->ScanlinesDiscovered.DwordBitArray, ScanlineCount );
                    SETBIT( pOutStrmEx->ScanlinesDiscovered.DwordBitArray, ScanlineCount );
                    SETBIT( pHwDevExt->ScanlinesDiscovered.DwordBitArray, ScanlineCount );

                    pInStrmEx->SubstreamsDiscovered.SubstreamMask |= dwSubStreams;
                    pOutStrmEx->SubstreamsDiscovered.SubstreamMask |= dwSubStreams;
                    pHwDevExt->SubstreamsDiscovered.SubstreamMask |= dwSubStreams;
                }
                else
                {
                    Stats->Common.DSPFailures++;
                    PinStats->Common.SRBsIgnored++;
                    if(( dwSubStreams & KS_CC_SUBSTREAM_ODD ) &&
                       TESTBIT( pInStrmEx->LastOddScanlinesDiscovered.DwordBitArray, ScanlineCount ))
                        pOutStrmEx->fDiscontinuity = TRUE;
                    if(( dwSubStreams & KS_CC_SUBSTREAM_EVEN ) &&
                       TESTBIT( pInStrmEx->LastEvenScanlinesDiscovered.DwordBitArray, ScanlineCount ))
                        pOutStrmEx->fDiscontinuity = TRUE;
                    if( !pOutStrmEx->fDiscontinuity )
                        continue;
                }

                // Only process the output streams which have an SRB ready
                if( QueueRemove( &pOutSrb,
                    &pOutStrmEx->StreamDataSpinLock,
                    &pOutStrmEx->StreamDataQueue
                    ))
                {
                    PKSSTREAM_HEADER    pOutStreamHeader = pOutSrb->CommandData.DataBufferArray;
                    PKS_VBI_FRAME_INFO  pOutVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pOutStreamHeader+1);
                    PUCHAR              pOutData = (PUCHAR)pOutStreamHeader->Data;

                    PinStats->Common.SRBsProcessed++;
                    Stats->Common.OutputSRBsProcessed++;

                    if( pOutStreamHeader->FrameExtent < pOutStrmEx->MatchedFormat.SampleSize )
                    {
                        CDebugPrint( DebugLevelError,
                            ( CODECNAME ": Outgoing Data SRB buffer is too small %u\n",
                            pOutStreamHeader->FrameExtent ));
                        PinStats->Common.InternalErrors++;
                        Stats->Common.OutputFailures++;
                        pOutStreamHeader->DataUsed = 0;
                    }
                    // Check on inbound & outbound data formats to decide
                    //   whether to copy or decode the inbound data
                    // Figure out how much of the decoded data was requested
                    pOutStreamHeader->Size = pInStreamHeader->Size;
                    pOutStreamHeader->OptionsFlags = pInStreamHeader->OptionsFlags;
                    pOutStreamHeader->Duration = pInStreamHeader->Duration;
                    RtlCopyMemory( &pOutStreamHeader->PresentationTime,
                            &pInStreamHeader->PresentationTime,
                            sizeof( pOutStreamHeader->PresentationTime ));
                    // pOutData is the output location.
                    ASSERT( pOutStreamHeader->FrameExtent >= CCSamples );
                    pOutStreamHeader->DataUsed = 2;
                    //
                    // If we have a discontinity to go out then send it
                    // instead of the data
                    //
                    if( pOutStrmEx->fDiscontinuity )
                    {
                        PinStats->Common.Discontinuities++;
                        pOutData[0] = 0xff;
                        pOutData[1] = 0xff;
                        pOutStreamHeader->OptionsFlags |=
                            KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                        pOutStrmEx->fDiscontinuity = FALSE;
                    }
                    else
                    {
                        pOutData[0] = pHwDevExt->DSPResult[ScanlineCount - pHwDevExt->DSPResultStartLine].Decoded[0];
                        pOutData[1] = pHwDevExt->DSPResult[ScanlineCount - pHwDevExt->DSPResultStartLine].Decoded[1];
                    }
                    CDebugPrint( DebugLevelInfo,
                    (CODECNAME ": OptionsFlags %x\n", pOutStreamHeader->OptionsFlags ));
                    CDebugPrint( DebugLevelInfo,
                        ("" "Time %x Num %x Denom %x\n",
                           pInStreamHeader->PresentationTime.Time,
                           pInStreamHeader->PresentationTime.Numerator,
                           pInStreamHeader->PresentationTime.Denominator
                        ));
                    //CDebugPrint( DebugLevelWarning, ( "" "%d%", i ));
                    Stats->Common.BytesOutput += pOutStreamHeader->DataUsed;
                    PinStats->Common.BytesOutput += pOutStreamHeader->DataUsed;

                    CDebugPrint( DebugLevelVerbose,
                            ( CODECNAME ": Releasing Output SRB %x\n",
                             pOutSrb ));
                    // Complete the output SRB
#ifdef PERFTEST
                    if( i == 0 )
                        PerfPreDownstreamCompletion =
                           KeQueryPerformanceCounter( NULL ).QuadPart;
#endif // PERFTEST
                    StreamClassStreamNotification( StreamRequestComplete,
                        pOutSrb->StreamObject, pOutSrb );
#ifdef PERFTEST
                    if( i == 0 )
                        PerfPostDownstreamCompletion =
                            KeQueryPerformanceCounter( NULL ).QuadPart;
#endif // PERFTEST

                }
                else
                {
                    PinStats->Common.SRBsMissing++;
                    Stats->Common.OutputSRBsMissing++;
                }
            }
        }
    }

    //
    // Remember the streams we discovered so that if they aren't discovered next
    // time we know we have to send a single discontinuity.
    //
    if(( dwOriginalFrameFlags & KS_CC_SUBSTREAM_EVEN ) == KS_CC_SUBSTREAM_EVEN )
        RtlCopyMemory( &pInStrmEx->LastEvenScanlinesDiscovered, &pInStrmEx->ScanlinesDiscovered,
            sizeof( pInStrmEx->LastEvenScanlinesDiscovered ));
    if(( dwOriginalFrameFlags & KS_CC_SUBSTREAM_ODD ) == KS_CC_SUBSTREAM_ODD )
        RtlCopyMemory( &pInStrmEx->LastOddScanlinesDiscovered, &pInStrmEx->ScanlinesDiscovered,
            sizeof( pInStrmEx->LastOddScanlinesDiscovered ));

#ifdef PERFTEST
    PerfFrequency.QuadPart /= 1000000L;             // Convert to ticks/us
    if( PerfPreDownstreamCompletion )
    {
        PerfPreDownstreamCompletion -= PerfStartTime;
        PerfPreDownstreamCompletion /= PerfFrequency.QuadPart;
    }
    if( PerfPostDownstreamCompletion )
    {
        PerfPostDownstreamCompletion -= PerfStartTime;
        PerfPostDownstreamCompletion /= PerfFrequency.QuadPart;
    }

    //
    // Complain if anything takes more than threshold
    //
    if( PerfPreDownstreamCompletion > PerfThreshold )
        CDebugPrint( DebugLevelFatal, ( CODECNAME ": PerfPreDownstreamCompletion %luus\n",
           PerfPreDownstreamCompletion ));
    if( PerfPostDownstreamCompletion > PerfThreshold )
        CDebugPrint( DebugLevelFatal, ( CODECNAME ": PerfPostDownstreamCompletion %luus\n",
            PerfPostDownstreamCompletion ));
    _CDebugLevel = OldLevel;
#endif // PERFTEST

    CDebugPrint( DebugLevelTrace, ( CODECNAME ": <---OutputCC\n" ));
}


/*
** VBIDecode
**
**   Decodes an incoming SRB.  SRB is already removed from queue.
**
** Arguments:
**
**         PHW_DEVICE_EXTENSION pHwDevExt
**         PSTREAMEX pInStrmEx
**         IN PHW_STREAM_REQUEST_BLOCK pInSrb
**
** Returns:
**
** Side Effects:  none
*/

#ifdef DEBUG
short CCskipDecode = 0;
#endif /*DEBUG*/

void VBIDecode(
        PHW_DEVICE_EXTENSION pHwDevExt,
        PSTREAMEX pInStrmEx,
        PHW_STREAM_REQUEST_BLOCK pInSrb,
        BOOL OkToHold )
{
    PKSSTREAM_HEADER            pInStreamHeader = pInSrb->CommandData.DataBufferArray;
    KSSTREAM_HEADER             InStreamHeaderCopy;
    PKS_VBI_FRAME_INFO          pInVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pInStreamHeader+1);
    DWORD                       dwFrameFlags;
    PUCHAR                      pInData = (PUCHAR)pInStreamHeader->Data;
    ULONG                       i, j,
                                ScanlineCount,
                                DSPStatus,
                                CurrentStrmEx = 0;
    CCLineStats                 DSPStatistics;
    PKS_VBIINFOHEADER           pVBIInfoHeader = &pInStrmEx->CurrentVBIInfoHeader;
    PVBICODECFILTERING_STATISTICS_CC Stats = 0;

    CASSERT(KeGetCurrentIrql() <= APC_LEVEL);

#ifdef PERFTEST
     ULONGLONG                  PerfStartTime = 0,
                                PerfPreUpstreamCompletion = 0,
                                PerfPostUpstreamCompletion = 0;
    LARGE_INTEGER               PerfFrequency;

    PerfStartTime = KeQueryPerformanceCounter( &PerfFrequency ).QuadPart;
    OldLevel = _CDebugLevel;
    _CDebugLevel = DebugLevelFatal;
                                                                        
#endif // PERFTEST

    CASSERT(pHwDevExt);
    CASSERT(pInStrmEx);
    Stats = &pHwDevExt->Statistics;

     CDebugPrint( DebugLevelTrace, ( CODECNAME ": --->VBIDecode\n" ));
#ifdef CCINPUTPIN
     if (!OkToHold)
         goto GoodToGo; // We've already processed discontinuties & stuff below
#endif // CCINPUTPIN

    CDebugPrint( DebugLevelInfo, ( "*" ));

    Stats->Common.InputSRBsProcessed++;

   //
   // If DataUsed == 0 then don't bother
   //
   if( pInStreamHeader->DataUsed < 1
#ifdef DEBUG
       || CCskipDecode
#endif /*DEBUG*/
     )
   {
       Stats->Common.SRBsIgnored++;
#ifdef DEBUG
       if (!CCskipDecode)
#endif /*DEBUG*/
         CDebugPrint( DebugLevelError, ( CODECNAME ": DataUsed == 0, abandoning\n" ));
       StreamClassStreamNotification( StreamRequestComplete, pInSrb->StreamObject,
           pInSrb );
       return;
   }

   //
   // Test for dropped fields
   //
   if( pInStrmEx->LastPictureNumber )
    {
        LONGLONG    Dropped = pInVBIFrameInfo->PictureNumber - pInStrmEx->LastPictureNumber - 1;
        if( Dropped > 0 )
        {
            if( Dropped < 60*60*60 )    // One hour worth of video fields
                Stats->Common.InputSRBsMissing += (DWORD)Dropped;
            else
                Stats->Common.InputSRBsMissing++;   // Some improbable number of fields got dropped, indicate a single lost field.
           CDebugPrint( DebugLevelWarning, ( "$" ));
        }
    }
    pInStrmEx->LastPictureNumber = pInVBIFrameInfo->PictureNumber;

     CDebugPrint( DebugLevelVerbose, ( CODECNAME ": pInVBIFrameInfo->ExtendedHeaderSize %d\n",
        pInVBIFrameInfo->ExtendedHeaderSize ));
     CDebugPrint( DebugLevelVerbose, ( CODECNAME ": pInVBIFrameInfo->dwFrameFlags       %x\n",
        pInVBIFrameInfo->dwFrameFlags ));
     CDebugPrint( DebugLevelVerbose, ( CODECNAME ": pInVBIFrameInfo->PictureNumber      %lu\n",
        pInVBIFrameInfo->PictureNumber ));
     CDebugPrint( DebugLevelVerbose, ( CODECNAME ": pInVBIFrameInfo->DropCount          %lu\n",
        pInVBIFrameInfo->DropCount ));
     CDebugPrint( DebugLevelVerbose, ( CODECNAME ": pInVBIFrameInfo->dwSamplingFrequency %lu\n",
        pInVBIFrameInfo->dwSamplingFrequency ));

     CDebugPrint( DebugLevelVerbose, ( CODECNAME ": pInStreamHeader->FrameExtent %d\n",
        pInStreamHeader->FrameExtent ));

    //
    // Update stats
    //
    if( ( pInStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ) ||
        ( pInStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY ) )
       Stats->Common.InputDiscontinuities++;

    //
    // Check for a new VBIINFOHEADER
    //
    if( pInVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_VBIINFOHEADER_CHANGE ) {
       CheckNewVBIInfo( pHwDevExt, pInStrmEx, pInVBIFrameInfo );
    }

    //
    // Check for a channel change
    //
    if( pInVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_TVTUNER_CHANGE )
    {
        if( ProcessChannelChange(
                pHwDevExt, pInStrmEx, pInVBIFrameInfo, pInStreamHeader ))
        {
           StreamClassStreamNotification(
                   StreamRequestComplete,
                   pInSrb->StreamObject,
                   pInSrb );
           return;
        }
    }

   //
   // pHwDevExt->fTunerChange is set while the TV tuner is changing channels.
   // SRBs are junk until the channel change completes so complete.
   //
   if( pHwDevExt->fTunerChange)
   {
       CDebugPrint( DebugLevelVerbose,
                   ( CODECNAME ": Completing, channel change in progress\n" ));

        StreamClassStreamNotification(
               StreamRequestComplete,
               pInSrb->StreamObject,
               pInSrb );
        return;
   }

    // Clear the current scanline & substream request masks
    RtlZeroMemory( &pInStrmEx->ScanlinesRequested, sizeof(pInStrmEx->ScanlinesRequested) );
    RtlZeroMemory( &pInStrmEx->SubstreamsRequested, sizeof(pInStrmEx->SubstreamsRequested) );

   //
   // Calculate the current request from union of the output pins w/pending SRBs that are
   // interested in this substream.
   //
    CurrentStrmEx = 0;
    for( i = 0; i < pHwDevExt->ActualInstances[STREAM_CC]; i++ )
    {
       PSTREAMEX pOutStrmEx;

       do
       {
           CASSERT( CurrentStrmEx < MAX_PIN_INSTANCES );
           pOutStrmEx = pHwDevExt->pStrmEx[STREAM_CC][CurrentStrmEx++];
       }while( !pOutStrmEx );

       if ( pInVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_TVTUNER_CHANGE )
           pOutStrmEx->fDiscontinuity = TRUE;
       //
       // For actual processing, just include the scanlines of the clients who are
       // interested in this particular substream.
       //
       if ( ( ( pInVBIFrameInfo->dwFrameFlags & KS_CC_SUBSTREAM_ODD ) &&
              ( pOutStrmEx->SubstreamsRequested.SubstreamMask & (KS_CC_SUBSTREAM_ODD|KS_CC_SUBSTREAM_FIELD1_MASK) ) ) ||
            ( ( pInVBIFrameInfo->dwFrameFlags & KS_CC_SUBSTREAM_EVEN ) &&
              ( pOutStrmEx->SubstreamsRequested.SubstreamMask & (KS_CC_SUBSTREAM_EVEN|KS_CC_SUBSTREAM_FIELD2_MASK) ) ) )
       {
           for( j = 0; j < SIZEOF_ARRAY( pInStrmEx->ScanlinesRequested.DwordBitArray ); j++ )
            pInStrmEx->ScanlinesRequested.DwordBitArray[j] |=
                   pOutStrmEx->ScanlinesRequested.DwordBitArray[j];

           // Create the union of all the requested substreams
           pInStrmEx->SubstreamsRequested.SubstreamMask |=
               pOutStrmEx->SubstreamsRequested.SubstreamMask;
       }
   }
   // Decode the union of all the pending decode requests into a local decode buffer.

#ifdef CCINPUTPIN
 GoodToGo:
    // Whoever gets there first (VBI pin vs. HW pin) supplies CC data
    ExAcquireFastMutex(&pHwDevExt->LastPictureMutex);
    if (pInStrmEx->LastPictureNumber <= pHwDevExt->LastPictureNumber) {
        // HW pin beat us to it
        ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);
        StreamClassStreamNotification( StreamRequestComplete,
                                        pInSrb->StreamObject,
                                        pInSrb );
        return;
    }

    // Is the HW stream open?
    if (OkToHold && pHwDevExt->ActualInstances[STREAM_CCINPUT] > 0)
    {
        KIRQL Irql;

        // We're going to give the HW pin a chance to catch up
        ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);

        KeAcquireSpinLock(&pInStrmEx->VBIOnHoldSpinLock, &Irql);
        CASSERT(NULL == pInStrmEx->pVBISrbOnHold);
        pInStrmEx->pVBISrbOnHold = pInSrb;
        KeReleaseSpinLock(&pInStrmEx->VBIOnHoldSpinLock, Irql);

        return;
    }

    // HW input pin not open or too late; we'll process this SRB
    pHwDevExt->LastPictureNumber = pInStrmEx->LastPictureNumber;
    ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);
#endif // CCINPUTPIN

    CDebugPrint( DebugLevelTrace,
            ( CODECNAME ": Requested SubstreamMask %x\n",
            pInStrmEx->SubstreamsRequested.SubstreamMask ));
    CDebugPrint( DebugLevelTrace,
            ( CODECNAME ": Requested Scanlines %08x%08x\n",
            pInStrmEx->ScanlinesRequested.DwordBitArray[1],
            pInStrmEx->ScanlinesRequested.DwordBitArray[0] ));

    RtlZeroMemory( pHwDevExt->DSPResult,
                sizeof( DSPRESULT ) *
                ( pHwDevExt->DSPResultEndLine - pHwDevExt->DSPResultStartLine + 1 ));

    // If this substream is requested by anybody, AND there is no discontinuity set
    if ( ( ( ( pInVBIFrameInfo->dwFrameFlags & KS_CC_SUBSTREAM_ODD ) &&
             ( pInStrmEx->SubstreamsRequested.SubstreamMask & (KS_CC_SUBSTREAM_ODD|KS_CC_SUBSTREAM_FIELD1_MASK) ) ||
           ( ( pInVBIFrameInfo->dwFrameFlags & KS_CC_SUBSTREAM_EVEN ) &&
             ( pInStrmEx->SubstreamsRequested.SubstreamMask & (KS_CC_SUBSTREAM_EVEN|KS_CC_SUBSTREAM_FIELD2_MASK) ) ) ) &&
         !pInStrmEx->fDiscontinuity ))
    {
        // Flag this as discovered
//       pInStrmEx->SubstreamsDiscovered.SubstreamMask |= ( pInVBIFrameInfo->dwFrameFlags &
//          pInStrmEx->SubstreamsRequested.SubstreamMask );
//       pHwDevExt->SubstreamsDiscovered.SubstreamMask |= pInStrmEx->SubstreamsDiscovered.SubstreamMask;

        // loop for each requested scanline
       CDebugPrint( DebugLevelVerbose, ( "" "\n" ));
       for( ScanlineCount = pVBIInfoHeader->StartLine; ScanlineCount <= pVBIInfoHeader->EndLine;
        ScanlineCount++ )
       {
        if( !TESTBIT( pInStrmEx->ScanlinesRequested.DwordBitArray, ScanlineCount ))
            continue;
        CDebugPrint( DebugLevelTrace, ( CODECNAME ": Scanning %u\n", ScanlineCount ));
        CASSERT( ( ScanlineCount - pVBIInfoHeader->StartLine) * pVBIInfoHeader->StrideInBytes < pVBIInfoHeader->BufferSize );
            DSPStatistics.nSize = sizeof( DSPStatistics );
           DSPStatus = CCDecodeLine(
            pHwDevExt->DSPResult[ScanlineCount - pHwDevExt->DSPResultStartLine].Decoded,
            &DSPStatistics,
            &pInData[( ScanlineCount - pVBIInfoHeader->StartLine ) * pVBIInfoHeader->StrideInBytes],
               &pInStrmEx->State,
               pVBIInfoHeader
               );
           CASSERT( DSPStatus == CC_OK );
           if( DSPStatus == CC_OK )
           {
                pHwDevExt->DSPResult[ScanlineCount - pHwDevExt->DSPResultStartLine].Confidence = DSPStatistics.nConfidence;
               Stats->Common.LineConfidenceAvg = ( Stats->Common.LineConfidenceAvg +
                   DSPStatistics.nConfidence ) / 2;
           }
           else
               Stats->Common.InternalErrors++;
        }
    }
    else
       Stats->Common.SRBsIgnored++;

    //
    // Copy the input stream header info for later reference
    //
    InStreamHeaderCopy = *pInStreamHeader;
    dwFrameFlags = pInVBIFrameInfo->dwFrameFlags;


#ifdef PERFTEST
     PerfPreUpstreamCompletion = KeQueryPerformanceCounter( NULL ).QuadPart;
#endif // PERFTEST

    //
    // Complete the upstream SRB.
    //
    StreamClassStreamNotification( StreamRequestComplete, pInSrb->StreamObject,
       pInSrb );

#ifdef PERFTEST
     PerfPostUpstreamCompletion = KeQueryPerformanceCounter( NULL ).QuadPart;
#endif // PERFTEST

    //
    // Lose all references to the just completed SRB
    //
    pInSrb = 0;
    pInStreamHeader = 0;
    pInVBIFrameInfo = 0;
    pInData = 0;

#ifdef PERFTEST
   PerfFrequency.QuadPart /= 1000000L;             // Convert to ticks/us
   PerfPreUpstreamCompletion -= PerfStartTime;
   PerfPreUpstreamCompletion /= PerfFrequency.QuadPart;
   PerfPostUpstreamCompletion -= PerfStartTime;
   PerfPostUpstreamCompletion /= PerfFrequency.QuadPart;

   //
   // Complain if anything takes more than threshold
   //
   if( PerfPreUpstreamCompletion > PerfThreshold )
       CDebugPrint( DebugLevelFatal, ( CODECNAME ": PerfPreUpstreamCompletion %luus\n",
           PerfPreUpstreamCompletion ));
   if( PerfPostUpstreamCompletion > PerfThreshold )
       CDebugPrint( DebugLevelFatal, ( CODECNAME ": PerfPostUpstreamCompletion %luus\n",
           PerfPostUpstreamCompletion ));
   _CDebugLevel = OldLevel;
#endif // PERFTEST

    //
    // Now output to anyone interested
    //
    OutputCC(pHwDevExt, pInStrmEx, dwFrameFlags, &InStreamHeaderCopy);

    CDebugPrint( DebugLevelTrace, ( CODECNAME ": <---VBIDecode\n" ));
}


/*
** VBIhwDecode
**
**   Handles an incoming CCINPUT SRB.  SRB is already removed from queue.
**
** Arguments:
**
**         PHW_DEVICE_EXTENSION pHwDevExt
**         PSTREAMEX pInStrmEx
**         IN PHW_STREAM_REQUEST_BLOCK pInSrb
**
** Returns:
**
** Side Effects:  none
*/

#ifdef CCINPUTPIN

#ifdef DEBUG
short CCskipHwDecode = 0;
#endif /*DEBUG*/

#ifdef NEWCCINPUTFORMAT

void VBIhwDecode(
        PHW_DEVICE_EXTENSION pHwDevExt,
        PSTREAMEX pInStrmEx,
        PHW_STREAM_REQUEST_BLOCK pInSrb )
{
    PKSSTREAM_HEADER      pInStreamHeader = pInSrb->CommandData.DataBufferArray;
    KSSTREAM_HEADER       InStreamHeaderCopy;
    PCC_HW_FIELD          pCCin = (PCC_HW_FIELD)pInStreamHeader->Data;
    ULONG                 CurrentStrmEx = 0;
    PVBICODECFILTERING_STATISTICS_CC Stats = 0;
    int                   line, start, end;
    int                   hidx;
    int                   didx;
    DWORD                 fields;

    CASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    CASSERT(pHwDevExt);
    CASSERT(pInStrmEx);
    Stats = &pHwDevExt->Statistics;
    CDebugPrint( DebugLevelInfo, ( "*" ));
    CDebugPrint( DebugLevelTrace, ( CODECNAME ": --->VBIhwDecode\n" ));

    Stats->Common.InputSRBsProcessed++;

   //
   // If DataUsed == 0 then don't bother
   //
   if( pInStreamHeader->DataUsed < sizeof (CC_HW_FIELD)
#ifdef DEBUG
       || CCskipHwDecode
#endif /*DEBUG*/
     )
   {
#ifdef DEBUG
       if (!CCskipHwDecode)
#endif /*DEBUG*/
       {
           Stats->Common.SRBsIgnored++;
           CDebugPrint( DebugLevelError,
                   ( CODECNAME ": DataUsed is too small, abandoning\n" ));
       }
       StreamClassStreamNotification(
               StreamRequestComplete, pInSrb->StreamObject, pInSrb );
       return;
   }
   pInStrmEx->LastPictureNumber = pCCin->PictureNumber;

    //
    // Update stats
    //
    if( ( pInStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ) ||
        ( pInStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY ) )
       Stats->Common.InputDiscontinuities++;

   //
   // pHwDevExt->fTunerChange is set while the TV tuner is changing channels.
   // SRBs are junk until the channel change completes so complete.
   //

   if( pHwDevExt->fTunerChange )
   {
       CDebugPrint( DebugLevelVerbose,
               ( CODECNAME ": Completing, channel change in progress\n" ));
       StreamClassStreamNotification(
               StreamRequestComplete, pInSrb->StreamObject, pInSrb );
       return;
   }

#ifdef CCINPUTPIN
    // Check to see if this field has been decoded already (are we too late?)
    ExAcquireFastMutex(&pHwDevExt->LastPictureMutex);
    if (pInStrmEx->LastPictureNumber <= pHwDevExt->LastPictureNumber) {
        ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);
      StreamClassStreamNotification(
               StreamRequestComplete, pInSrb->StreamObject, pInSrb );
      return;
    }

    // Nope, we're not too late.  Stow the data.
    pHwDevExt->LastPictureNumber = pInStrmEx->LastPictureNumber;
    ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);
#endif // CCINPUTPIN

    // figure out where hardware decoding starts and ends
    for( start = 1; start < 1024; ++start ) {
        if( TESTBIT( pCCin->ScanlinesRequested.DwordBitArray, start ))
            break;
    }
    for( end = 1023; end > start; --end ) {
        if( TESTBIT( pCCin->ScanlinesRequested.DwordBitArray, end ))
            break;
    }
    if (1024 == start) {
        StreamClassStreamNotification( StreamRequestComplete,
                pInSrb->StreamObject,
                pInSrb );
        return;
    }
    CASSERT(start <= end);

    // Resize Result array if needed
    CheckResultsArray(pHwDevExt, start, end);

    // loop for each scanline
    CDebugPrint( DebugLevelVerbose, ( "" "\n" ));

    hidx = 0;
    for( line = start; line <= end && hidx < CC_MAX_HW_DECODE_LINES; ++line )
    {
        if( !TESTBIT( pCCin->ScanlinesRequested.DwordBitArray, line ))
            continue;
        CDebugPrint( DebugLevelTrace,
                ( CODECNAME ": Scanning %u\n", line ));

        didx = line - pHwDevExt->DSPResultStartLine;
        pHwDevExt->DSPResult[didx].Decoded[0] = pCCin->Lines[hidx].Decoded[0];
        pHwDevExt->DSPResult[didx].Decoded[1] = pCCin->Lines[hidx].Decoded[1];
        ++hidx;

        pHwDevExt->DSPResult[didx].Confidence = 99;     // HW decoded
        Stats->Common.LineConfidenceAvg =
            (Stats->Common.LineConfidenceAvg + 99) / 2;
    }

    //
    // Copy the input stream header & other info for later reference
    //
    InStreamHeaderCopy = *pInStreamHeader;
    fields = pCCin->fieldFlags & (KS_VBI_FLAG_FIELD1|KS_VBI_FLAG_FIELD2);

    //
    // Complete the upstream SRB.
    //
    StreamClassStreamNotification( StreamRequestComplete,
            pInSrb->StreamObject,
            pInSrb );

    //
    // Lose all references to the just completed SRB
    //
    pInSrb = 0;
    pInStreamHeader = 0;
    pCCin = 0;

    OutputCC(pHwDevExt, pInStrmEx, fields, &InStreamHeaderCopy);

    CDebugPrint( DebugLevelTrace, ( CODECNAME ": <---VBIhwDecode\n" ));
}

#else //NEWCCINPUTFORMAT

void VBIhwDecode(
        PHW_DEVICE_EXTENSION pHwDevExt,
        PSTREAMEX pInStrmEx,
        PHW_STREAM_REQUEST_BLOCK pInSrb )
{
    PKSSTREAM_HEADER      pInStreamHeader = pInSrb->CommandData.DataBufferArray;
    KSSTREAM_HEADER       InStreamHeaderCopy;
    PUCHAR                pInData = (PUCHAR)pInStreamHeader->Data;
    ULONG                 CurrentStrmEx = 0;
    PVBICODECFILTERING_STATISTICS_CC Stats = 0;

    CASSERT((ULONG)pHwDevExt);
    CASSERT((ULONG)pInStrmEx);
    Stats = &pHwDevExt->Statistics;
    CDebugPrint( DebugLevelInfo, ( "*" ));
    CDebugPrint( DebugLevelTrace, ( CODECNAME ": --->VBIhwDecode\n" ));

    Stats->Common.InputSRBsProcessed++;

   //
   // If DataUsed == 0 then don't bother
   //
   if( pInStreamHeader->DataUsed < 2
#ifdef DEBUG
       || CCskipHwDecode
#endif /*DEBUG*/
     )
   {
#ifdef DEBUG
       if (!CCskipDecode)
#endif /*DEBUG*/
           Stats->Common.SRBsIgnored++;
       CDebugPrint( DebugLevelError, ( CODECNAME ": DataUsed is too small, abandoning\n" ));
       StreamClassStreamNotification(
               StreamRequestComplete, pInSrb->StreamObject, pInSrb );
       return;
   }

    //
    // Update stats
    //
    if( ( pInStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY ) ||
        ( pInStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY ) )
       Stats->Common.InputDiscontinuities++;

   //
   // pHwDevExt->fTunerChange is set while the TV tuner is changing channels.
   // SRBs are junk until the channel change completes so complete.
   //

   if( pHwDevExt->fTunerChange )
   {
       CDebugPrint( DebugLevelVerbose,
               ( CODECNAME ": Completing, channel change in progress\n" ));
       StreamClassStreamNotification(
               StreamRequestComplete, pInSrb->StreamObject, pInSrb );
       return;
   }

    // loop for each requested scanline
    CDebugPrint( DebugLevelVerbose, ( "" "\n" ));

    pHwDevExt->DSPResult[21-10].Decoded[0] = pInData[0];
    pHwDevExt->DSPResult[21-10].Decoded[1] = pInData[1];
    pHwDevExt->DSPResult[21-10].Confidence = 95;
    Stats->Common.LineConfidenceAvg =
        ( Stats->Common.LineConfidenceAvg +
          pHwDevExt->DSPResult[21-10].Confidence ) / 2;

    //
    // Copy the input stream header for later reference
    //
    InStreamHeaderCopy = *pInStreamHeader;

    //
    // Complete the upstream SRB.
    //
    StreamClassStreamNotification( StreamRequestComplete,
            pInSrb->StreamObject,
            pInSrb );

    //
    // Lose all references to the just completed SRB
    //
    pInSrb = 0;
    pInStreamHeader = 0;
    pInData = 0;

    //
    // Now output to anyone interested
    //
    OutputCC(pHwDevExt, pInStrmEx, KS_VBI_FLAG_FIELD1, &InStreamHeaderCopy);

    CDebugPrint( DebugLevelTrace, ( CODECNAME ": <---VBIhwDecode\n" ));
}

#endif //NEWCCINPUTFORMAT

#endif //CCINPUTPIN


/*
** VBIReceiveDataPacket()
**
**   Receives Video data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VBIReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION  pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
    PSTREAMEX             pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                   ThisStreamNr = (int)pSrb->StreamObject->StreamNumber;
#ifdef DEBUG
    static int            QdepthReportFreq = 0;
    static unsigned int   QDRCount = 0;
#endif // DEBUG

    //
    // make sure we have a device extension
    //

    CASSERT(pHwDevExt);

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VBIReceiveDataPacket(pSrb=%x)\n", pSrb));

    //
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;
    //
    // Disable timeout
    //
    pSrb->TimeoutCounter = 0;

       //
       // determine the type of packet.
       //

       // Rule:
       // Only accept read requests when in either the Pause or Run
       // States.  If Stopped, immediately return the SRB.

       if (pStrmEx->KSState == KSSTATE_STOP) {
           StreamClassStreamNotification( StreamRequestComplete,
               pSrb->StreamObject, pSrb );

           return;
       }

    switch (pSrb->Command)
    {
#ifdef DRIVER_DEBUGGING_TEST
        case SRB_READ_DATA:
       case SRB_WRITE_DATA:
        // When initially bringing up a driver, it is useful to just
        // try immediately completing the SRB, thus verifying
        // the streaming process independent of really accessing
        // your hardware.

       StreamClassStreamNotification( StreamRequestComplete,
           pSrb->StreamObject, pSrb );

        break;
#else // DRIVER_DEBUGGING_TEST

    case SRB_READ_DATA:
        if( ThisStreamNr != STREAM_CC )
       {
        CDebugPrint( DebugLevelError, ( CODECNAME ": Read Stream # Bad\n" ));
           CDEBUG_BREAK();
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
       }
       else
       {
        CDebugPrint( DebugLevelTrace, ( CODECNAME ": Stream %u Instance %u\n", ThisStreamNr,
               pStrmEx->StreamInstance ));
           if( pStrmEx->StreamInstance != 0 )
            CDebugPrint( DebugLevelTrace, ( CODECNAME ": Stream %u Instance %u\n", ThisStreamNr,
                   pStrmEx->StreamInstance ));
           QueueAdd( pSrb, &pStrmEx->StreamDataSpinLock, &pStrmEx->StreamDataQueue );

            // Since another thread COULD HAVE MODIFIED THE STREAM STATE
            // in the midst of adding it to the queue, check the stream
            // state again, and cancel the SRB if necessary.
            // Note that this race condition was NOT handled in the
            // original DDK release of testcap!

            if (pStrmEx->KSState == KSSTATE_STOP)
                CodecCancelPacket(pSrb);
       }
       break;

    case SRB_WRITE_DATA:
       if( STREAM_VBI == ThisStreamNr)
       {
#ifdef DEBUG
           static int    MaxVBIqDepth = 0;
           static int    AvgVBIqDepth = 1000;   // 1.000
           int           qDepth = 0;
#endif // DEBUG
           CDebugPrint( DebugLevelTrace, ( CODECNAME ": Stream VBI Writing\n"));
           if( QueueAddIfNotEmpty( pSrb,  &pStrmEx->StreamDataSpinLock,
               &pStrmEx->StreamDataQueue ))
               break;

           do
           {
#ifdef CCINPUTPIN
               KIRQL Irql;
#endif // CCINPUTPIN
#ifdef DEBUG
               ++qDepth;
               ++QDRCount;
#endif // DEBUG

#ifdef CCINPUTPIN
                KeAcquireSpinLock(&pStrmEx->VBIOnHoldSpinLock, &Irql);
                if (NULL != pStrmEx->pVBISrbOnHold)
                {
                    PHW_STREAM_REQUEST_BLOCK pTempSrb;

                    pTempSrb = pStrmEx->pVBISrbOnHold;
                    pStrmEx->pVBISrbOnHold = NULL;
                    KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);

                    VBIDecode( pHwDevExt, pStrmEx, pTempSrb, 0 );
                }
                else
                    KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);
#endif // CCINPUTPIN

               VBIDecode( pHwDevExt, pStrmEx, pSrb, 1 );
           }while( QueueRemove( &pSrb, &pStrmEx->StreamDataSpinLock,
                   &pStrmEx->StreamDataQueue ));
#ifdef DEBUG
            if (qDepth > MaxVBIqDepth)
                MaxVBIqDepth = qDepth;
            AvgVBIqDepth = (AvgVBIqDepth * 7 / 8) + (qDepth * 1000 / 8);
            if (QdepthReportFreq > 0 && 0 == QDRCount % QdepthReportFreq) {
                CDebugPrint( 0,
                    (CODECNAME ": Max VBI Q depth = %3d, Avg VBI Q depth = %3d.%03d\n",
                     MaxVBIqDepth,
                     AvgVBIqDepth / 1000,
                     AvgVBIqDepth % 1000));
            }
#endif // DEBUG

       }
#ifdef CCINPUTPIN
       else if (STREAM_CCINPUT == ThisStreamNr)
       {
#ifdef DEBUG
           static int    MaxCCINqDepth = 0;
           static int    AvgCCINqDepth = 1000;   // 1.000
           int           qDepth = 0;
#endif // DEBUG
           CDebugPrint( DebugLevelTrace, (CODECNAME ": Stream CCINPUT Writing\n"));
           if( QueueAddIfNotEmpty( pSrb,  &pStrmEx->StreamDataSpinLock,
               &pStrmEx->StreamDataQueue ))
               break;

           do
           {
#ifdef DEBUG
               ++qDepth;
               ++QDRCount;
#endif // DEBUG
               VBIhwDecode( pHwDevExt, pStrmEx, pSrb );
           }while( QueueRemove( &pSrb, &pStrmEx->StreamDataSpinLock,
                   &pStrmEx->StreamDataQueue ));

#ifdef DEBUG
            if (qDepth > MaxCCINqDepth)
                MaxCCINqDepth = qDepth;
            AvgCCINqDepth = (AvgCCINqDepth * 7 / 8) + (qDepth * 1000 / 8);
            if (QdepthReportFreq > 0 && 0 == QDRCount % QdepthReportFreq) {
                CDebugPrint( 0,
                    (CODECNAME ": Max CCIN Q depth = %3d, Avg CCIN Q depth = %3d.%03d\n",
                     MaxCCINqDepth,
                     AvgCCINqDepth / 1000,
                     AvgCCINqDepth % 1000));
            }
#endif // DEBUG
       }
#endif // CCINPUTPIN
       else
       {
        CDebugPrint( DebugLevelError, ( CODECNAME, ": Write Stream # Bad (%u)\n", ThisStreamNr ));
           CDEBUG_BREAK();
           pSrb->Status = STATUS_NOT_IMPLEMENTED;
       }
       break;
#endif // DRIVER_DEBUGGING_TEST

       break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        CDEBUG_BREAK();

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
       StreamClassStreamNotification( StreamRequestComplete,
           pSrb->StreamObject, pSrb );

    }  // switch (pSrb->Command)
    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VBIReceiveDataPacket(pSrb=%x)\n", pSrb));
}


/*
** VBIReceiveCtrlPacket()
**
**   Receives packet commands that control the Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID
STREAMAPI
VBIReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VBIReceiveCtrlPacket(pSrb=%x)\n", pSrb));

    CASSERT(pHwDevExt);

    //
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;

   if( QueueAddIfNotEmpty( pSrb,
       &pStrmEx->StreamControlSpinLock,
       &pStrmEx->StreamControlQueue
       ))
       return;

   do
   {
    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
    case SRB_PROPOSE_DATA_FORMAT:
        if ( !CodecVerifyFormat( pSrb->CommandData.OpenFormat,
                                 pSrb->StreamObject->StreamNumber,
                                 NULL ) )
        {
            pSrb->Status = STATUS_NO_MATCH;
        }
        break;
    case SRB_SET_STREAM_STATE:

        VideoSetState(pSrb);
        break;

    case SRB_GET_STREAM_STATE:

        VideoGetState(pSrb);
        break;

    case SRB_GET_STREAM_PROPERTY:

        VideoGetProperty(pSrb);
        break;

    case SRB_SET_STREAM_PROPERTY:

        VideoSetProperty(pSrb);
        break;

    case SRB_INDICATE_MASTER_CLOCK:

        //
        // Assigns a clock to a stream
        //

        VideoIndicateMasterClock(pSrb);

        break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        CDEBUG_BREAK();

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject,
       pSrb );
    }while( QueueRemove( &pSrb, &pStrmEx->StreamControlSpinLock,
           &pStrmEx->StreamControlQueue ));
    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VBIReceiveCtrlPacket(pSrb=%x)\n", pSrb));
}

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    int StreamNumber = (int)pSrb->StreamObject->StreamNumber;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoGetProperty(pSrb=%x)\n", pSrb));

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set))
    {
         VideoStreamGetConnectionProperty( pSrb );
    }
    else if (IsEqualGUID (&KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
        VideoStreamGetVBIFilteringProperty (pSrb);
    }
    else
    {
        CDebugPrint( DebugLevelTrace, ( CODECNAME ": Unsupported Property Set\n" ));
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoGetProperty(pSrb=%x)\n", pSrb));
}

/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoSetProperty(pSrb=%x)\n", pSrb));

    if (IsEqualGUID (&KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
        VideoStreamSetVBIFilteringProperty (pSrb);
    }
    else
    if( IsEqualGUID( &KSPROPSETID_Stream, &pSPD->Property->Set ))
    {
        pSrb->Status = STATUS_SUCCESS;
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoSetProperty(pSrb=%x)\n", pSrb));
}

/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION    pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX               pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb;
    int                      StreamNumber = (int)pSrb->StreamObject->StreamNumber;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoSetState(pSrb=%x)\n", pSrb));

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    switch (pSrb->CommandData.StreamState)

    {
    case KSSTATE_STOP:

       //
       // If transitioning to the stopped state, then complete any outstanding IRPs
       //
       while( QueueRemove( &pCurrentSrb, &pStrmEx->StreamDataSpinLock,
               &pStrmEx->StreamDataQueue ))
       {
           CDebugPrint(DebugLevelVerbose,( CODECNAME ": Cancelling %X\n",
               pCurrentSrb ));
           pCurrentSrb->Status = STATUS_CANCELLED;
           pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

           StreamClassStreamNotification( StreamRequestComplete,
               pCurrentSrb->StreamObject, pCurrentSrb );
       }
       CDebugPrint( DebugLevelTrace, ( CODECNAME ": KSSTATE_STOP %u\n", StreamNumber ));
       break;

    case KSSTATE_ACQUIRE:

        //
        // This is a KS only state, that has no correspondence in DirectShow
        //
        CDebugPrint( DebugLevelTrace, ( CODECNAME ": KSSTATE_ACQUIRE %u\n", StreamNumber ));
        break;

    case KSSTATE_PAUSE:

        //
        // On a transition to pause from acquire, start our timer running.
        //

        if (pStrmEx->KSState == KSSTATE_ACQUIRE || pStrmEx->KSState == KSSTATE_STOP) {

            // Remember the time at which the clock was started

            pHwDevExt->QST_Start = VideoGetSystemTime();

            // And initialize the last frame timestamp

            pHwDevExt->QST_Now = pHwDevExt->QST_Start;

            // Fireup the codec HERE in preparation for receiving data & requests.

            // INSERT CODE HERE

        }
        CDebugPrint( DebugLevelTrace, ( CODECNAME ": KSSTATE_PAUSE %u\n", StreamNumber ));
        break;

    case KSSTATE_RUN:

        //
        // Begin Streaming.
        //

        // Remember the time at which the clock was started

        pHwDevExt->QST_Start = VideoGetSystemTime();

        // Zero the frame info, it should be reset when the first sample arrives.

        RtlZeroMemory (&pStrmEx->FrameInfo, sizeof (pStrmEx->FrameInfo));

        // Zero the last known picture numbers

        pStrmEx->LastPictureNumber = 0;
        pHwDevExt->LastPictureNumber = 0;

        // Reset the discontinuity flag

        pStrmEx->fDiscontinuity = FALSE;
        CDebugPrint( DebugLevelTrace, ( CODECNAME ": KSSTATE_RUN %u\n", StreamNumber ));

        break;

    default:
        CDebugPrint( DebugLevelError, ( CODECNAME ": UNKNOWN STATE %u\n", StreamNumber ));
       CDEBUG_BREAK();
       break;

    } // end switch (pSrb->CommandData.StreamState)

    //
    // Remember the state of this stream
    //

    pStrmEx->KSState = pSrb->CommandData.StreamState;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoSetState(pSrb=%x)\n", pSrb));
}

/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX     pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->VideoGetState(pSrb=%x)\n", pSrb));

    pSrb->CommandData.StreamState = pStrmEx->KSState;
    pSrb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return ERROR_NO_DATA_DETECTED

    if (pStrmEx->KSState == KSSTATE_PAUSE) {
       pSrb->Status = STATUS_NO_DATA_DETECTED;
    }

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---VideoGetState(pSrb=%x)=%d\n", pSrb, pStrmEx->KSState));
}


/*
** VideoStreamGetConnectionProperty()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION pHwDevExt = pStrmEx->pHwDevExt;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    int StreamNumber = ( int )pSrb->StreamObject->StreamNumber;

    CDebugPrint(DebugLevelTrace,
        ( CODECNAME ":--->VideoStreamGetConnectionProperty(pSrb=%x)\n",
        pSrb));

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
     {
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing =
                (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;
//            PKS_DATARANGE_VIDEO_VBI pVBIFormat;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamGetConnectionProperty : KSPROPERTY_CONNECTION_ALLOCATORFRAMING %u\n",
                   StreamNumber));

             Framing->RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY |
                KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER;
            Framing->PoolType = NonPagedPool;
            Framing->FileAlignment = 0;         // None OR FILE_QUAD_ALIGNMENT OR PAGE_SIZE - 1;
            Framing->Reserved = 0;

            switch( StreamNumber )
            {
            case STREAM_VBI:
                Framing->Frames = 8;
                Framing->FrameSize = pStrmEx->OpenedFormat.SampleSize;
               break;

            case STREAM_CC:
                if( CodecCompareGUIDsAndFormatSize( &pStrmEx->OpenedFormat,
                    pHwDevExt->Streams[STREAM_CC].hwStreamInfo.StreamFormatsArray[0], FALSE ))
               {
                    Framing->Frames = 60;
                Framing->FrameSize = CCSamples;
               }
                else if( CodecCompareGUIDsAndFormatSize( &pStrmEx->OpenedFormat,
                    pHwDevExt->Streams[STREAM_CC].hwStreamInfo.StreamFormatsArray[1], FALSE ))
                {
                    Framing->Frames = 8;
                    Framing->FrameSize = pStrmEx->OpenedFormat.SampleSize;
                }
               else
               {
                    CDebugPrint( DebugLevelError, ( CODECNAME ": VideoStreamGetConnectionProperty: Invalid Format\n" ));
                   CDEBUG_BREAK();
               }
               break;
#ifdef CCINPUTPIN
            case STREAM_CCINPUT:
               Framing->Frames = 60;
               Framing->FrameSize = CCSamples;
               break;
#endif // CCINPUTPIN
            default:
                CDebugPrint( DebugLevelError, ( CODECNAME ": VideoStreamGetConnectionProperty: Invalid Stream #\n" ));
               CDEBUG_BREAK();

            }
            CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Negotiated sample size is %d\n",
                Framing->FrameSize ));
            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
            break;
        }

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamGetConnectionProperty : Unknown Property Id=%d\n", Id));
            CDEBUG_BREAK();
            break;
    }

    CDebugPrint(DebugLevelTrace,
        ( CODECNAME ":<---VideoStreamGetConnectionProperty(pSrb=%x)\n",
        pSrb));
}

/*
** VideoStreamGetVBIFilteringProperty()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamGetVBIFilteringProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX                   pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    LONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY);        // size of data supplied

    CDebugPrint(DebugLevelTrace,
        ( CODECNAME ":--->VideoStreamGetVBIFilteringProperty(pSrb=%x)\n",
        pSrb));

    ASSERT (nBytes >= sizeof (LONG));

    pSrb->ActualBytesTransferred = 0;
    switch (Id)
    {
        case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            nBytes = min( nBytes, sizeof( pStrmEx->ScanlinesRequested ) );
            RtlCopyMemory( &Property->Scanlines, &pStrmEx->ScanlinesRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));

            break;
        }

        case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->ScanlinesDiscovered ) );
            RtlCopyMemory( &Property->Scanlines, &pStrmEx->ScanlinesDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pStrmEx->ScanlinesDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            break;
        }

        case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            nBytes = min( nBytes, sizeof( pStrmEx->SubstreamsRequested ) );
            RtlCopyMemory( &Property->Substreams, &pStrmEx->SubstreamsRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            CDebugPrint(DebugLevelInfo,
                ( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY %08x\n",
                Property->Substreams ));
            break;
        }

        case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->SubstreamsDiscovered ) );
            RtlCopyMemory( &Property->Substreams, &pStrmEx->SubstreamsDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pStrmEx->SubstreamsDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            break;
        }

        case KSPROPERTY_VBICODECFILTERING_STATISTICS:
        {
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->PinStats ) );
            RtlCopyMemory( &Property->Statistics, &pStrmEx->PinStats, nBytes );
            pSrb->ActualBytesTransferred = nBytes  + sizeof(KSPROPERTY);
            break;
        }

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamGetVBIFilteringProperty : Unknown Property Id=%d\n", Id));
            CDEBUG_BREAK();
            break;
    }
    CDebugPrint(DebugLevelTrace,
        ( CODECNAME ":<---VideoStreamGetVBIFilteringProperty(pSrb=%x)\n",
        pSrb));
}

/*
** VideoStreamSetVBIFilteringProperty()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamSetVBIFilteringProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    ULONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY);        // size of data supplied

    ASSERT (nBytes >= sizeof (LONG));

    CDebugPrint(DebugLevelTrace,
        ( CODECNAME ":--->VideoStreamSetVBIFilteringProperty(pSrb=%x)\n",
        pSrb));

    pSrb->ActualBytesTransferred = 0;
    switch (Id)
    {
        case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->ScanlinesRequested ) );
            RtlCopyMemory( &pStrmEx->ScanlinesRequested, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            break;
        }
#ifdef SETDISCOVERED
        case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pStrmEx->ScanlinesDiscovered ) );
            RtlCopyMemory( &pStrmEx->ScanlinesDiscovered, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            break;
        }
#endif // SETDISCOVERED
        case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            nBytes = min( nBytes, sizeof(pStrmEx->SubstreamsRequested ) );
            RtlCopyMemory( &pStrmEx->SubstreamsRequested, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            CDebugPrint(DebugLevelInfo,
                ( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY %08x\n",
                pStrmEx->SubstreamsRequested.SubstreamMask));

            break;
        }
#ifdef SETDISCOVERED
        case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
        {
            PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pStrmEx->SubstreamsDiscovered ) );
            RtlCopyMemory( &pStrmEx->SubstreamsDiscovered, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            break;
        }
#endif // SETDISCOVERED
        case KSPROPERTY_VBICODECFILTERING_STATISTICS:
        {
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->PinStats ) );
            RtlCopyMemory( &pStrmEx->PinStats, &Property->Statistics, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
            break;
        }

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
                ( CODECNAME ": VideoStreamSetVBIFilteringProperty : Unknown Property Id=%d\n", Id));
            CDEBUG_BREAK();
            break;
    }
    CDebugPrint(DebugLevelTrace,
        ( CODECNAME ":<---VideoStreamSetVBIFilteringProperty(pSrb=%x)\n",
        pSrb));
}


/*
** GetSystemTime ()
**
**    Returns the system time in 100 nS units
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

ULONGLONG
VideoGetSystemTime()
{
    ULONGLONG ticks;
    ULONGLONG rate;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoGetSystemTime()\n"));

    ticks = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;

    //
    // convert from ticks to 100ns clock
    //

    ticks = (ticks & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ticks & 0x00000000FFFFFFFF) * 10000000 / rate;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoGetSystemTime()\n"));

    return(ticks);
}



//==========================================================================;
//                   Clock Handling Routines
//==========================================================================;


/*
** VideoIndicateMasterClock ()
**
**    This function is used to provide us with a handle to the clock to use.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoIndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoIndicateMasterClock(pSrb=%x)\n", pSrb));

    pStrmEx->hClock = pSrb->CommandData.MasterClockHandle;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoIndicateMasterClock(pSrb=%x)\n", pSrb));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\icodec\ccdecode.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              22-Aug-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#include <ccdecode.h>
#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// Closed captioning KSDATAFORMAT definitions
//////////////////////////////////////////////////////////////

#define CCSamples 	2
#define CC_FORMAT_PIN_NUMBER	1

KSDATARANGE StreamFormatCC = 
{
    // Definition of the CC stream (MUST match the output pin of the decoder)
    {   
        sizeof (KSDATARANGE),           // FormatSize
        0,                              // Flags
        CCSamples,                      // SampleSize
        0,                              // Reserved
        { STATIC_KSDATAFORMAT_TYPE_AUXLine21Data },         // MajorFormat
        { STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair },    // Subtype
        { STATIC_KSDATAFORMAT_SPECIFIER_NONE },
    }
};

//////////////////////////////////////////////////////////////
// ICCOutputPin
//////////////////////////////////////////////////////////////

ICCOutputPin::~ICCOutputPin() 
    {
    }

//////////////////////////////////////////////////////////////
// ICCDecode:: ctors & dtors
//////////////////////////////////////////////////////////////

ICCDecode::ICCDecode() : 
        IVBICodec("Closed Caption Decoder", sizeof(VBICODECFILTERING_CC_SUBSTREAMS) ),
        m_Statistics(*this, KSPROPERTY_VBICODECFILTERING_STATISTICS, sizeof(VBICODECFILTERING_STATISTICS_CC)),
        m_OutputPin(*this, CC_FORMAT_PIN_NUMBER, &StreamFormatCC ) 
    {
    }


ICCDecode::~ICCDecode() 
    {
    }

//////////////////////////////////////////////////////////////
// ICCDecode Scanline routines
//////////////////////////////////////////////////////////////

int 
ICCDecode::AddRequestedScanline(int nScanline)
    {
    int nStatus = -1;
    VBICODECFILTERING_SCANLINES ScanlineBitArray;

    if ( m_OutputPin.m_ScanlinesRequested.GetValue(&ScanlineBitArray) )
        {
        DWORD   nBitsPerElement = sizeof(*ScanlineBitArray.DwordBitArray)*8;
        ScanlineBitArray.DwordBitArray[ nScanline / nBitsPerElement ] 
            |= 1L << (nScanline % nBitsPerElement);
        if ( m_OutputPin.m_ScanlinesRequested.SetValue(&ScanlineBitArray) )
            nStatus = 0;
        }

    return nStatus;
    }

int 
ICCDecode::ClearRequestedScanlines()
    {
    int nStatus = -1;
    VBICODECFILTERING_SCANLINES ScanlineBitArray;

    ZeroMemory(&ScanlineBitArray,sizeof(ScanlineBitArray));
    if ( m_OutputPin.m_ScanlinesRequested.SetValue(&ScanlineBitArray) )
        nStatus = 0;

    return nStatus;
    }

int 
ICCDecode::GetDiscoveredScanlines(VBICODECFILTERING_SCANLINES &ScanlineBitArray )
    {
    int nStatus = -1;

    if ( m_OutputPin.m_ScanlinesDiscovered.GetValue(&ScanlineBitArray) )
        {
        nStatus = 0;
        }

    return nStatus;
    }

//////////////////////////////////////////////////////////////
// ICCDecode VideoField routines
//////////////////////////////////////////////////////////////

int 
ICCDecode::AddRequestedVideoField(int nField)
    {
    int nStatus = -1;
    VBICODECFILTERING_CC_SUBSTREAMS FieldBitArray;

    if ( m_OutputPin.m_SubstreamsRequested.GetValue(&FieldBitArray) )
        {
        DWORD   nBitsPerElement = sizeof(FieldBitArray.SubstreamMask)*8;
        // Note, fields numbers start with number 1, this is mapped to bit number 0.
        FieldBitArray.SubstreamMask |= 1L << ((nField-1) % nBitsPerElement);
        if ( m_OutputPin.m_SubstreamsRequested.SetValue(&FieldBitArray) )
            nStatus = 0;
        }

    return nStatus;
    }

int
ICCDecode::ClearRequestedVideoFields()
    {
    int nStatus = -1;
    VBICODECFILTERING_CC_SUBSTREAMS FieldBitArray;

    ZeroMemory(&FieldBitArray,sizeof(FieldBitArray));
    if ( m_OutputPin.m_SubstreamsRequested.SetValue(&FieldBitArray) )
        nStatus = 0;

    return nStatus;
    }

int 
ICCDecode::GetDiscoveredVideoFields(VBICODECFILTERING_CC_SUBSTREAMS &bitArray)
    {
    int nStatus = -1;

    if ( m_OutputPin.m_SubstreamsDiscovered.GetValue(&bitArray) )
        {
        nStatus = 0;
        }

    return nStatus;
    }

//////////////////////////////////////////////////////////////
// Global Statistics Property Control
//////////////////////////////////////////////////////////////

int 
ICCDecode::GetCodecStatistics(VBICODECFILTERING_STATISTICS_CC &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.GetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
ICCDecode::SetCodecStatistics(VBICODECFILTERING_STATISTICS_CC &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.SetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
ICCDecode::GetPinStatistics(VBICODECFILTERING_STATISTICS_CC_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.GetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
ICCDecode::SetPinStatistics(VBICODECFILTERING_STATISTICS_CC_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.SetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

//////////////////////////////////////////////////////////////
// Embedded class tests
//////////////////////////////////////////////////////////////

#if defined(_CLASSTESTS)

ICCDecode	CCDecode();

#endif

#pragma warning(default:4355)

/*EOF*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\cc\guidkludge.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef _GUIDKLUDGE_H_
#define _GUIDKLUDGE_H_

#ifndef STATIC_KSDATAFORMAT_SUBTYPE_CC
  // {33214CC1-011F-11D2-B4B1-00A0D102CFBE}
# define STATIC_KSDATAFORMAT_SUBTYPE_CC \
    0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
# ifdef GUIDKLUDGESTORAGE
   GUID KSDATAFORMAT_SUBTYPE_CC = { STATIC_KSDATAFORMAT_SUBTYPE_CC };
# else
   extern GUID  KSDATAFORMAT_SUBTYPE_CC;
# endif
#endif !defined(STATIC_KSDATAFORMAT_SUBTYPE_CC)

#ifndef STATIC_PINNAME_VIDEO_CC_CAPTURE
  // {1AAD8061-012D-11d2-B4B1-00A0D102CFBE}
# define STATIC_PINNAME_VIDEO_CC_CAPTURE \
    0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
# ifdef GUIDKLUDGESTORAGE
  GUID PINNAME_VIDEO_CC_CAPTURE = { STATIC_PINNAME_VIDEO_CC_CAPTURE };
# else
   extern GUID  PINNAME_VIDEO_CC_CAPTURE;
# endif
#endif !defined(STATIC_PINNAME_VIDEO_CC_CAPTURE)

#endif //_GUIDKLUDGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\icodec\icodec.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              22-Aug-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include <icodec.h>

//////////////////////////////////////////////////////////////
// IBitmaskProperty::
//////////////////////////////////////////////////////////////

IBitmaskProperty::~IBitmaskProperty() 
    {
    }

//////////////////////////////////////////////////////////////
// IScanlinesProperty::
//////////////////////////////////////////////////////////////

IScanlinesProperty::~IScanlinesProperty() 
    {
    }

//////////////////////////////////////////////////////////////
// ISubstreamsProperty::
//////////////////////////////////////////////////////////////

ISubstreamsProperty::~ISubstreamsProperty() 
    {
    }

//////////////////////////////////////////////////////////////
// IStatisticsProperty::
//////////////////////////////////////////////////////////////

IStatisticsProperty::~IStatisticsProperty() 
    {
    }

//////////////////////////////////////////////////////////////
// IVBIOutputPin
//////////////////////////////////////////////////////////////

IVBIOutputPin::~IVBIOutputPin() 
    {
    }

//////////////////////////////////////////////////////////////
// IVBICodec::
//////////////////////////////////////////////////////////////

IVBICodec::~IVBICodec() 
    {
    }

//////////////////////////////////////////////////////////////
// Embedded class tests
//////////////////////////////////////////////////////////////

#if defined(_CLASSTESTS)

IVBICodec	TestCodec("Closed Caption Decoder");

#endif


/*EOF*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\icodec\iks.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              22-Aug-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <setupapi.h>
#include <spapip.h>
#include <string.h>

#include <devioctl.h>
#include <ks.h>

#include <iks.h>

//////////////////////////////////////////////////////////////
// IKSDriver::
//////////////////////////////////////////////////////////////

IKSDriver::IKSDriver(LPCGUID lpCategory, LPCSTR lpszFriendlyName) 
    {
    if ( lpszFriendlyName && *lpszFriendlyName )
        {
		if ( m_lpszDriver = GetSymbolicName( lpCategory, lpszFriendlyName ) )
			{
			if ( OpenDriver( GENERIC_READ | GENERIC_WRITE, FILE_FLAG_OVERLAPPED ) )
				{
				}
			else
				{
				// Throw a open failure exception
				}
			}
        }
    else
        {
        // Throw a bad parameter exception.
        }
    }

IKSDriver::~IKSDriver() 
    {
    if ( m_lpszDriver )
        {
        delete m_lpszDriver;
        m_lpszDriver = NULL;

        if ( m_hKSDriver )
            {
            if ( CloseDriver() )
                {
                }
            else
                {
                // Throw a close failure exception
                }
            }
        }
    }

BOOL        
IKSDriver::Ioctl(ULONG dwControlCode, LPBYTE pIn, ULONG nIn, 
                 LPBYTE pOut, ULONG nOut, ULONG *nReturned, LPOVERLAPPED lpOS )
    {
    BOOL    bStatus = FALSE;

    if ( IsValid() )
        {
        bStatus = DeviceIoControl( m_hKSDriver, dwControlCode, pIn, nIn, 
                                   pOut, nOut, nReturned, lpOS );
        }
    else
        {
		// Throw an invalid object exception
        }

    return bStatus;
    }

#if DBG && 0
#define TRACE	printf
#else
#define TRACE	
#endif

LPWSTR		
IKSDriver::GetSymbolicName(LPCGUID lpCategory, LPCSTR szRequestedDevice )
	{
    int         index = 0;
	LPWSTR	    lpszSymbolicName = NULL;
    HDEVINFO    hDevInfo = SetupDiGetClassDevs( const_cast<GUID*>(lpCategory), NULL, NULL,
										   DIGCF_PRESENT | DIGCF_DEVICEINTERFACE );
    if (hDevInfo != INVALID_HANDLE_VALUE) 
	    {
        PSP_DEVICE_INTERFACE_DETAIL_DATA_W  pDeviceDetails;
        SP_DEVICE_INTERFACE_DATA            DeviceData = {sizeof(DeviceData)};
        BYTE                                Storage[sizeof(*pDeviceDetails) + MAX_PATH * sizeof(WCHAR)];
        SP_DEVINFO_DATA                     DeviceInfoData = {sizeof(DeviceInfoData)};
        CHAR                                szDeviceDesc[MAX_PATH];
        WCHAR                               wszSymbolicPath[MAX_PATH];


        pDeviceDetails = reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA_W>(Storage);
        pDeviceDetails->cbSize = sizeof(*pDeviceDetails);

	    TRACE("Begin SetupDiEnumDeviceInterfaces\n");
        while ( SetupDiEnumDeviceInterfaces(hDevInfo, NULL, const_cast<GUID*>(lpCategory), index++, &DeviceData ) )
            {
		    TRACE("A) SetupDiGetDeviceInterfaceDetail\n");
            if ( SetupDiGetDeviceInterfaceDetailW(hDevInfo, &DeviceData, pDeviceDetails, sizeof(Storage), NULL, &DeviceInfoData) )
                {
                SP_INTERFACE_TO_DEVICE_PARAMS_W Translate;

                // Save off the original device path so it can be returned if we match the name
                wcscpy( wszSymbolicPath, pDeviceDetails->DevicePath);

                ZeroMemory(&Translate,sizeof(Translate));
                Translate.ClassInstallHeader.cbSize = sizeof(Translate.ClassInstallHeader);
                Translate.ClassInstallHeader.InstallFunction = DIF_INTERFACE_TO_DEVICE;
                Translate.Interface = pDeviceDetails->DevicePath;

		        TRACE("B) SetupDiSetClassInstallParams\n");
                if ( SetupDiSetClassInstallParamsW( hDevInfo,
                                                    &DeviceInfoData,
                                                    (PSP_CLASSINSTALL_HEADER)&Translate,
                                                    sizeof(Translate)) )
                    {
		            TRACE("C) SetupDiCallClassInstaller\n");
                    if ( SetupDiCallClassInstaller(DIF_INTERFACE_TO_DEVICE,
                                                   hDevInfo,
                                                   &DeviceInfoData) ) 
                        {
                        // it was translated find out what to
		                TRACE("D) SetupDiGetClassInstallParams\n");
                        if( SetupDiGetClassInstallParamsW(hDevInfo,
                                                          &DeviceInfoData,
                                                          (PSP_CLASSINSTALL_HEADER)&Translate,
                                                          sizeof(Translate),
                                                          NULL)) 
                            {
		                    TRACE("E) SetupDiOpenDeviceInfo\n");
                            if( SetupDiOpenDeviceInfoW(hDevInfo,
                                                       Translate.DeviceId,
                                                       NULL,
                                                       0,
                                                       &DeviceInfoData)) 
                                {
		                        TRACE("F) SetupDiGetDeviceRegistryProperty\n");
                                if ( SetupDiGetDeviceRegistryProperty(hDevInfo, &DeviceInfoData, SPDRP_DEVICEDESC, NULL, (LPBYTE)&szDeviceDesc, 
                                                                      sizeof(szDeviceDesc), NULL ) )
                                    {
                                    TRACE("G) Name=%s\n",szDeviceDesc);
                                    if ( *szRequestedDevice && *szDeviceDesc
                                      && strncmp( szRequestedDevice, szDeviceDesc, 
                                                  min( strlen(szRequestedDevice), strlen(szDeviceDesc) ) ) == 0 )
                                        {
                                        TRACE("H) Matched Sympath=%S\n", wszSymbolicPath);
                                        lpszSymbolicName = wcscpy( new WCHAR[wcslen(wszSymbolicPath)+1],
                                                                   wszSymbolicPath );
                                        break;
                                        }
                                    }
                                else
                                    {
                                    TRACE("SetupDiGetDeviceRegistryProperty()=0x%lx\n", GetLastError());
                                    }   
                                }
                            else
                                {
                                TRACE("SetupDiOpenDeviceInfo()=0x%lx\n", GetLastError());
                                }   
                            }
                        else
                            {
                            TRACE("SetupDiGetClassInstallParams()=0x%lx\n", GetLastError());
                            }   
                        }
                    else
                        {
                        TRACE("SetupDiCallClassInstaller()=0x%lx\n", GetLastError());
                        }   
                    }
                else 
		            {
                    TRACE("I) SetupDiGetDeviceRegistryProperty\n");
			        if ( SetupDiGetDeviceRegistryProperty(hDevInfo, &DeviceInfoData, SPDRP_DEVICEDESC, NULL, (LPBYTE)&szDeviceDesc, 
                                                           sizeof(szDeviceDesc), NULL ) )
                        {
                        TRACE("J) Name=%s\n",szDeviceDesc);
                        if ( *szRequestedDevice && *szDeviceDesc
                          && strncmp( szRequestedDevice, szDeviceDesc, 
                                        min( strlen(szRequestedDevice), strlen(szDeviceDesc) ) ) == 0 )
                            {
                            TRACE("K) Matched Sympath=%S\n",wszSymbolicPath);
                            lpszSymbolicName = wcscpy( new WCHAR[wcslen(wszSymbolicPath)+1], wszSymbolicPath );
                            break;
                            }
                        }
                    else
                        {
                        TRACE("SetupDiCallClassInstaller()=0x%lx\n", GetLastError());
                        }   

                    }
                }
            }
        }
	TRACE("End SetupDiEnumDeviceInterfaces\n");

	return lpszSymbolicName;
	}

BOOL        
IKSDriver::OpenDriver(DWORD dwAccess, DWORD dwFlags) 
    {
    BOOL    bStatus = FALSE;

	SECURITY_ATTRIBUTES SecurityAttributes;
	SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	SecurityAttributes.bInheritHandle = TRUE;
	SecurityAttributes.lpSecurityDescriptor = NULL;

	m_hKSDriver = CreateFileW( 
            m_lpszDriver, 
			dwAccess, 
			FILE_SHARE_READ | FILE_SHARE_WRITE, 
			&SecurityAttributes, 
			OPEN_EXISTING,     
			dwFlags,
			NULL 
            );

    if ( m_hKSDriver != (HANDLE)-1 )
        {
        bStatus = TRUE;
        }
    else
        {
        m_hKSDriver = NULL;
        }

    return bStatus;
    }

BOOL
IKSDriver::CloseDriver() 
    {
    BOOL    bStatus = CloseHandle(m_hKSDriver);

    m_hKSDriver = NULL;

    return bStatus;
    }

//////////////////////////////////////////////////////////////
// IKSPin::
//////////////////////////////////////////////////////////////

IKSPin::IKSPin(IKSDriver &driver,
			   int nPin, 
               PKSDATARANGE pKSDataRange )
    {
    m_bRunning = FALSE;
    m_IKSDriver = &driver;
	m_nPin = nPin;
    if ( pKSDataRange )
        {
        if ( OpenPin( pKSDataRange ) )
            {
            if ( Run() )
                {
                // We are good to go!
                }
            else
                {
                // Throw an run failure exception
                }
            }
        else
            {
            // Throw an open failure exception
            }
        }
    else
        {
        // Throw a bad parameter exception.
        }
    }

IKSPin::~IKSPin() 
    {
    if ( m_nPin )
        {
        m_nPin = -1;
        if ( m_hKSPin )
            {
            if ( m_bRunning )
                {
                if ( Stop() )
                    {
                    }
                else
                    {
        		    // Throw a stop failure exception
                    }
                }
			if ( ClosePin() )
				{
				// We are all destructed.
				}
			else
				{
        		// Throw a close failure exception
				}
            }
        }
    }

BOOL        
IKSPin::Ioctl(ULONG dwControlCode, void *pInput, ULONG nInput, 
              void *pOutput, ULONG nOutput, 
              ULONG *nReturned, LPOVERLAPPED lpOS  )
    {
    BOOL    bStatus = FALSE;

    if ( IsValid() )
        {
        bStatus = DeviceIoControl( m_hKSPin, dwControlCode, pInput, nInput, 
                                   pOutput, nOutput, nReturned, lpOS );
		if ( !bStatus )
            {
            int     nError = GetLastError();
            if ( nError == ERROR_IO_PENDING )
			    bStatus = TRUE;
            }
        }
    else
        {
        }

    return bStatus;
    }

int 
IKSPin::ReadData( LPBYTE lpBuffer, int nBytes, DWORD *lpcbReturned, LPOVERLAPPED lpOS )
    {
    int			nStatus = -1;
    static int  counter = 0;

    if ( lpBuffer && IsValid() )
        {
		if ( lpOS )
			{
			DWORD				dwReturnedHeaderSize; // Ignored in this case.
			KSSTREAM_HEADER		*lpStreamHeader = 
				(KSSTREAM_HEADER *)GlobalAlloc(GMEM_FIXED, sizeof(KSSTREAM_HEADER) );
				
			if ( lpStreamHeader )
				{
				// Cache away the stream header structure so that we can get the "DataUsed" member later
				lpOS->Offset = (DWORD)lpStreamHeader;

				RtlZeroMemory(lpStreamHeader, sizeof(*lpStreamHeader) );
				lpStreamHeader->PresentationTime.Numerator = 1;
				lpStreamHeader->PresentationTime.Denominator = 1;
				lpStreamHeader->Size = sizeof(*lpStreamHeader);
				lpStreamHeader->Data = lpBuffer;
				lpStreamHeader->FrameExtent = nBytes;

				if ( Ioctl( IOCTL_KS_READ_STREAM, 
							NULL, 0,
							(LPBYTE)lpStreamHeader, sizeof(*lpStreamHeader),
							&dwReturnedHeaderSize, lpOS ) )
					{
					nStatus = 0;
					}
				}
			*lpcbReturned = 0;
			}
		else
			{
#ifdef SUPPORT_NON_OVERLAPPED_READS
			DWORD				dwReturnedHeaderSize;
			KSSTREAM_HEADER		StreamHeader;
			RtlZeroMemory(&StreamHeader, sizeof(StreamHeader) );
			StreamHeader.PresentationTime.Numerator = 1;
			StreamHeader.PresentationTime.Denominator = 1;
			StreamHeader.Size = sizeof(StreamHeader);
			StreamHeader.Data = lpBuffer;
			StreamHeader.FrameExtent = nBytes;

			if ( Ioctl( IOCTL_KS_READ_STREAM, 
						NULL, 0,
						(LPBYTE)&StreamHeader, sizeof(StreamHeader),
						&dwReturnedHeaderSize, lpOS ) 
			  && dwReturnedHeaderSize == sizeof(StreamHeader) )
				{
				*lpcbReturned = StreamHeader.DataUsed;
				nStatus = 0;
				}
#endif
			}
        }

    return nStatus;
    }

int 
IKSPin::GetOverlappedResult( LPOVERLAPPED lpOS, LPDWORD lpdwTransferred , BOOL bWait )
    {
    int nStatus = -1;
    if ( IsValid() && lpOS && lpOS->hEvent )
        {
	    // Get the cached STREAM_HEADER memory so we can get the actual data transferred.
		KSSTREAM_HEADER		*lpStreamHeader = (KSSTREAM_HEADER *)lpOS->Offset;

		if ( lpdwTransferred )
			*lpdwTransferred = 0;

        if ( lpStreamHeader && WaitForSingleObject( lpOS->hEvent, 0 ) == WAIT_OBJECT_0 )
            {
        	DWORD	dwKSBuffer = 0;
		    if ( ::GetOverlappedResult( m_hKSPin, lpOS, &dwKSBuffer, bWait ) 
		      && dwKSBuffer == sizeof(KSSTREAM_HEADER) && lpOS->InternalHigh == sizeof(KSSTREAM_HEADER) )
			    {

                if ( lpdwTransferred )
  				    *lpdwTransferred = lpStreamHeader->DataUsed;

		        // Delete the KSSTREAM_HEADER we allocated
    	        GlobalFree( (HGLOBAL)lpStreamHeader );
                lpOS->Offset = 0;
			    nStatus = 0;
			    }
		    else
			    {
			    nStatus = GetLastError();
			    }
            }
        else
            nStatus = ERROR_IO_PENDING;
        }

    return nStatus;
    }

BOOL        
IKSPin::Run() 
    {
    BOOL    bCompleted = FALSE;
    if ( !m_bRunning )
        {
        if ( SetRunState( KSSTATE_RUN ) )
	        {
            // We are now running
            m_bRunning = TRUE;
            bCompleted = TRUE;
	        }
        else
            {
            // Throw a run failure exception
            }
        }
    else
        {
        // Throw an invalid state exception
        }
    return bCompleted;
    }

BOOL        
IKSPin::Stop() 
    {
    BOOL    bCompleted = FALSE;
   	if ( m_bRunning )
        {
        if ( SetRunState(KSSTATE_STOP) )
            {
            // We are now stopped.
            m_bRunning = FALSE;
            bCompleted = TRUE;
            }
        else
            {
		    // Log the stop failure
            }
        }
    else
        {
        // Throw an invalid state exception
        }
    return bCompleted;
    }

BOOL		
IKSPin::GetRunState( PKSSTATE pKSState )
	{
	KSPROPERTY	KSProp={0};
	KSProp.Set = KSPROPSETID_Connection;
	KSProp.Id = KSPROPERTY_CONNECTION_STATE;
	KSProp.Flags = KSPROPERTY_TYPE_GET;
	DWORD		dwReturned = 0;
	BOOL		bStatus = Ioctl( IOCTL_KS_PROPERTY, 
								 &KSProp, sizeof(KSProp), 
								 pKSState, sizeof(*pKSState), 
								 &dwReturned);

	return bStatus && dwReturned == sizeof(pKSState);
	}

BOOL		
IKSPin::SetRunState( KSSTATE KSState )
	{
	KSPROPERTY	KSProp={0};
	KSProp.Set = KSPROPSETID_Connection;
	KSProp.Id = KSPROPERTY_CONNECTION_STATE;
	KSProp.Flags = KSPROPERTY_TYPE_SET;
	DWORD		dwReturned = 0;
	BOOL		bStatus = Ioctl( IOCTL_KS_PROPERTY, 
								 &KSProp, sizeof(KSProp), 
								 &KSState, sizeof(KSState), 
								 &dwReturned);

	return bStatus && dwReturned == sizeof(KSState);
	}
    

BOOL        
IKSPin::OpenPin(PKSDATARANGE pKSDataRange ) 
    {
    BOOL    bStatus = FALSE;
    struct tagPIN_CONNECT_DATARANGE
        {
    	KSPIN_CONNECT   PinConnect;
        KSDATARANGE     DataRange;
        BYTE            reserved[1024]; // Large enough for any reasonable specifier structure.
        } PinGlob;

    RtlZeroMemory(&PinGlob, sizeof(PinGlob));

    if ( pKSDataRange->FormatSize <= sizeof(KSDATARANGE)+sizeof(PinGlob.reserved) )
        {
	    PinGlob.PinConnect.Interface.Set			= KSINTERFACESETID_Standard;
	    PinGlob.PinConnect.Interface.Id			    = KSINTERFACE_STANDARD_STREAMING; // STREAMING
	    PinGlob.PinConnect.Medium.Set				= KSMEDIUMSETID_Standard;
	    PinGlob.PinConnect.Medium.Id				= KSMEDIUM_STANDARD_DEVIO;
	    PinGlob.PinConnect.PinId					= m_nPin;
	    PinGlob.PinConnect.PinToHandle				= NULL; // no "connect to"
	    PinGlob.PinConnect.Priority.PriorityClass	= KSPRIORITY_NORMAL;
	    PinGlob.PinConnect.Priority.PrioritySubClass = 1;
        RtlCopyMemory( &PinGlob.DataRange, pKSDataRange, pKSDataRange->FormatSize );
    
        if ( KsCreatePin( m_IKSDriver->m_hKSDriver, &PinGlob.PinConnect, GENERIC_READ | GENERIC_WRITE, &m_hKSPin ) == 0
          && m_hKSPin > 0 )
            bStatus = TRUE;
		else
			m_hKSPin = 0;
        }
    else
        {
        // Throw a bad parameter exception.
        }

    return bStatus;
    }

BOOL        
IKSPin::ClosePin() 
    {
    BOOL    bStatus = TRUE;

    bStatus = CloseHandle(m_hKSPin);
    m_hKSPin = NULL;

    return bStatus;
    }

//////////////////////////////////////////////////////////////
// IKSProperty::
//////////////////////////////////////////////////////////////

IKSProperty::IKSProperty(IKSDriver &driver, LPCGUID Set, ULONG Id, ULONG Size) 
    : m_Set(*Set), m_Id(Id), m_Size(Size), m_IKSPin(NULL), m_IKSDriver(NULL)
    {
    if ( m_Size > 0 )
        {
        if ( OpenProperty() )
            {
            m_IKSDriver = &driver;
            }
        else
            {
            // Throw an open failure exception
            }
        }
    else
        {
        // Throw a bad parameter exception.
        }
    }

IKSProperty::IKSProperty(IKSPin &pin, LPCGUID Set, ULONG Id, ULONG Size) 
    : m_Set(*Set), m_Id(Id), m_Size(Size), m_IKSPin(NULL), m_IKSDriver(NULL)
    {
    if ( m_Size > 0 )        
    {
        if ( OpenProperty() )
            {
            m_IKSPin = &pin;
            }
        else
            {
            // Throw an open failure exception
            }
        }
    else
        {
        // Throw a bad parameter exception.
        }
    }

IKSProperty::~IKSProperty() 
    {
    if ( m_hKSProperty )
        {
        if ( CloseProperty() )
            {
            }
        else
            {
            // Throw a close failure exception
            }
        }
    }

BOOL
IKSProperty::SetValue(void *nValue) 
    {
    BOOL            bStatus = FALSE;
    PKSPROPERTY     pKSProperty = (PKSPROPERTY)m_hKSProperty;
    LPBYTE          pProperty = (LPBYTE)(pKSProperty+1);
    DWORD           nReturned = 0;
    
    if ( IsValid() )
        {
        ZeroMemory(pKSProperty, sizeof(KSPROPERTY)+m_Size);
	    pKSProperty->Flags = KSPROPERTY_TYPE_SET;
        pKSProperty->Set = m_Set;
	    pKSProperty->Id = m_Id;

        CopyMemory( pProperty, nValue, m_Size );

        if ( m_IKSDriver )
            {
            bStatus = m_IKSDriver->Ioctl( IOCTL_KS_PROPERTY,
			                              (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
                                          (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
			                              &nReturned,
			                              NULL);
            }
        else if ( m_IKSPin )
            {
            bStatus = m_IKSPin->Ioctl( IOCTL_KS_PROPERTY,
			                           (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
                                       (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
			                           &nReturned,
			                           NULL);
            }
        }
    else
        {
        }

    return bStatus;
    }

BOOL
IKSProperty::GetValue(void *nValue) 
    {
    BOOL            bStatus = FALSE;
    PKSPROPERTY     pKSProperty = (PKSPROPERTY)m_hKSProperty;
    LPBYTE          pProperty = (LPBYTE)(pKSProperty+1);
    DWORD           nReturned = 0;

    if ( IsValid() )
        {
        ZeroMemory(pKSProperty, sizeof(KSPROPERTY)+m_Size);
	    pKSProperty->Flags = KSPROPERTY_TYPE_GET;
        pKSProperty->Set = m_Set;
	    pKSProperty->Id = m_Id;

        if ( m_IKSDriver )
            {
            bStatus = m_IKSDriver->Ioctl( IOCTL_KS_PROPERTY,
			                              (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
                                          (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
			                              &nReturned,
			                              NULL);
            }
        else if ( m_IKSPin )
            {
            bStatus = m_IKSPin->Ioctl( IOCTL_KS_PROPERTY,
			                           (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
                                       (LPBYTE)pKSProperty, sizeof(KSPROPERTY)+m_Size,
			                           &nReturned,
			                           NULL);
            }

        if ( bStatus )
            CopyMemory( nValue, pProperty, m_Size );
        }
    else
        {
        }

    return bStatus;
    }

// Prob: the buffer is overrun during the Ioctl w/CCDECODE substreams.
#define BUFFER_SLOP 4

BOOL        
IKSProperty::OpenProperty() 
    {
    BOOL    bStatus = TRUE;
    LONG    nTotalSize = sizeof(KSPROPERTY)+m_Size+BUFFER_SLOP;
    m_hKSProperty = (HANDLE)new BYTE[nTotalSize];
    return bStatus;
    }

BOOL        
IKSProperty::CloseProperty() 
    {
    BOOL    bStatus = TRUE;

    delete (void *)m_hKSProperty;
    m_hKSProperty = NULL;

    return bStatus;
    }

//////////////////////////////////////////////////////////////
// Embedded class tests
//////////////////////////////////////////////////////////////

#if defined(_CLASSTESTS)

IKSDriver	TestDriver(&KSCATEGORY_VBICODEC,"Closed Caption Decoder");
IKSPin		TestPin(TestDriver, &GUID_NULL, &GUID_NULL, &GUID_NULL);
IKSProperty	TestProperty1(TestDriver, 0);
IKSProperty	TestProperty2(TestPin, 0);

#endif

/*EOF*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\icodec\igemstar.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997-1998  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              20-Feb-98   TKB     Initial Interface Version
//
//==========================================================================;

#include <igemstar.h>
#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// Gemstar KSDATAFORMAT definitions
//////////////////////////////////////////////////////////////

#define GEMSTAR_FORMAT_PIN_NUMBER	1

KSDATARANGE StreamFormatGEMSTAR = 
{
    // Definition of the GEMSTAR stream (MUST match the output pin of the decoder)
    {   
        sizeof (KSDATARANGE),           // FormatSize
        0,                              // Flags
        sizeof(GEMSTAR_BUFFER),         // SampleSize
        0,                              // Reserved
        { STATIC_KSDATAFORMAT_TYPE_AUXLine21Data },         // MajorFormat
        { STATIC_KSDATAFORMAT_SUBTYPE_Gemstar },    // Subtype
        { STATIC_KSDATAFORMAT_SPECIFIER_NONE },
    }
};

//////////////////////////////////////////////////////////////
// IGemstarOutputPin
//////////////////////////////////////////////////////////////

IGemstarOutputPin::~IGemstarOutputPin() 
    {
    }

//////////////////////////////////////////////////////////////
// IGemstarDecode:: ctors & dtors
//////////////////////////////////////////////////////////////

IGemstarDecode::IGemstarDecode() : 
        IVBICodec("Gemstar Decoder", sizeof(VBICODECFILTERING_GEMSTAR_SUBSTREAMS) ),
        m_Statistics(*this, KSPROPERTY_VBICODECFILTERING_STATISTICS, sizeof(VBICODECFILTERING_STATISTICS_GEMSTAR)),
        m_OutputPin(*this, GEMSTAR_FORMAT_PIN_NUMBER, &StreamFormatGEMSTAR ) 
    {
    }


IGemstarDecode::~IGemstarDecode() 
    {
    }

//////////////////////////////////////////////////////////////
// IGemstarDecode Scanline routines
//////////////////////////////////////////////////////////////

int 
IGemstarDecode::AddRequestedScanline(int nScanline)
    {
    int nStatus = -1;
    VBICODECFILTERING_SCANLINES ScanlineBitArray;

    if ( m_OutputPin.m_ScanlinesRequested.GetValue(&ScanlineBitArray) )
        {
        DWORD   nBitsPerElement = sizeof(*ScanlineBitArray.DwordBitArray)*8;
        ScanlineBitArray.DwordBitArray[ nScanline / nBitsPerElement ] 
            |= 1L << (nScanline % nBitsPerElement);
        if ( m_OutputPin.m_ScanlinesRequested.SetValue(&ScanlineBitArray) )
            nStatus = 0;
        }

    return nStatus;
    }

int 
IGemstarDecode::ClearRequestedScanlines()
    {
    int nStatus = -1;
    VBICODECFILTERING_SCANLINES ScanlineBitArray;

    ZeroMemory(&ScanlineBitArray,sizeof(ScanlineBitArray));
    if ( m_OutputPin.m_ScanlinesRequested.SetValue(&ScanlineBitArray) )
        nStatus = 0;

    return nStatus;
    }

int 
IGemstarDecode::GetDiscoveredScanlines(VBICODECFILTERING_SCANLINES &ScanlineBitArray )
    {
    int nStatus = -1;

    if ( m_OutputPin.m_ScanlinesDiscovered.GetValue(&ScanlineBitArray) )
        {
        nStatus = 0;
        }

    return nStatus;
    }

//////////////////////////////////////////////////////////////
// IGemstarDecode VideoField routines
//////////////////////////////////////////////////////////////

int 
IGemstarDecode::AddRequestedVideoField(int nField)
    {
    int nStatus = -1;
    VBICODECFILTERING_GEMSTAR_SUBSTREAMS FieldBitArray;

    if ( m_OutputPin.m_SubstreamsRequested.GetValue(&FieldBitArray) )
        {
        DWORD   nBitsPerElement = sizeof(FieldBitArray.SubstreamMask)*8;
        // Note, fields numbers start with number 1, this is mapped to bit number 0.
        FieldBitArray.SubstreamMask |= 1L << ((nField-1) % nBitsPerElement);
        if ( m_OutputPin.m_SubstreamsRequested.SetValue(&FieldBitArray) )
            nStatus = 0;
        }

    return nStatus;
    }

int
IGemstarDecode::ClearRequestedVideoFields()
    {
    int nStatus = -1;
    VBICODECFILTERING_GEMSTAR_SUBSTREAMS FieldBitArray;

    ZeroMemory(&FieldBitArray,sizeof(FieldBitArray));
    if ( m_OutputPin.m_SubstreamsRequested.SetValue(&FieldBitArray) )
        nStatus = 0;

    return nStatus;
    }

int 
IGemstarDecode::GetDiscoveredVideoFields(VBICODECFILTERING_GEMSTAR_SUBSTREAMS &bitArray)
    {
    int nStatus = -1;

    if ( m_OutputPin.m_SubstreamsDiscovered.GetValue(&bitArray) )
        {
        nStatus = 0;
        }

    return nStatus;
    }

//////////////////////////////////////////////////////////////
// Global Statistics Property Control
//////////////////////////////////////////////////////////////

int 
IGemstarDecode::GetCodecStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.GetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
IGemstarDecode::SetCodecStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.SetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
IGemstarDecode::GetPinStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.GetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
IGemstarDecode::SetPinStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.SetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

//////////////////////////////////////////////////////////////
// Embedded class tests
//////////////////////////////////////////////////////////////

#if defined(_CLASSTESTS)

IGemstarDecode	GemstarDecode();

#endif

#pragma warning(default:4355)

/*EOF*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\icodec\nabtsfec.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              17-Nov-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#include <nabtsfec.h>
#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// Stream Format FEC-corrected NABTS bundles
//////////////////////////////////////////////////////////////

#define NABTS_OUTPUT_PIN	    1

KSDATARANGE StreamFormatNabtsFEC = 
{
    // Definition of the stream (MUST match the output pin of the decoder)
    {   
        sizeof (KSDATARANGE),           // FormatSize
        0,                              // Flags
	    sizeof (NABTSFEC_BUFFER),		// SampleSize
        0,                              // Reserved
		{ STATIC_KSDATAFORMAT_TYPE_NABTS },
		{ STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC },
		{ STATIC_KSDATAFORMAT_SPECIFIER_NONE }
    }
};

//////////////////////////////////////////////////////////////
// INabtsFECOutputPin
//////////////////////////////////////////////////////////////

INabtsFECOutputPin::~INabtsFECOutputPin() 
    {
    }

//////////////////////////////////////////////////////////////
// INabtsFEC:: ctors & dtors
//////////////////////////////////////////////////////////////

INabtsFEC::INabtsFEC() : 
        IVBICodec("NABTS/FEC VBI Codec", sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS) ),
        m_Statistics(*this, KSPROPERTY_VBICODECFILTERING_STATISTICS, sizeof(VBICODECFILTERING_STATISTICS_NABTS)),
        m_OutputPin(*this, NABTS_OUTPUT_PIN, &StreamFormatNabtsFEC)
    {
    }


INabtsFEC::~INabtsFEC() 
    {
    }

//////////////////////////////////////////////////////////////
// INabtsFEC Group routines
//////////////////////////////////////////////////////////////

int 
INabtsFEC::AddRequestedGroup(int nGroup)
    {
    int nStatus = -1;
    VBICODECFILTERING_NABTS_SUBSTREAMS GroupBitArray;

    if ( m_OutputPin.m_SubstreamsRequested.GetValue(&GroupBitArray) )
        {
        DWORD   nBitsPerElement = sizeof(GroupBitArray.SubstreamMask[0])*8;
        // Note, fields numbers start with number 1, this is mapped to bit number 0.
        GroupBitArray.SubstreamMask[nGroup/nBitsPerElement] |= 1L << (nGroup % nBitsPerElement);
        if ( m_OutputPin.m_SubstreamsRequested.SetValue(&GroupBitArray) )
            nStatus = 0;
        }

    return nStatus;
    }

int
INabtsFEC::ClearRequestedGroups()
    {
    int nStatus = -1;
    VBICODECFILTERING_NABTS_SUBSTREAMS GroupBitArray;

    ZeroMemory(&GroupBitArray,sizeof(GroupBitArray));
    if ( m_OutputPin.m_SubstreamsRequested.SetValue(&GroupBitArray) )
        nStatus = 0;

    return nStatus;
    }

int 
INabtsFEC::GetDiscoveredGroups(VBICODECFILTERING_NABTS_SUBSTREAMS &GroupBitArray)
    {
    int nStatus = -1;

    if ( m_OutputPin.m_SubstreamsDiscovered.GetValue(&GroupBitArray) )
        {
        nStatus = 0;
        }

    return nStatus;
    }

//////////////////////////////////////////////////////////////
// Global Statistics Property Control
//////////////////////////////////////////////////////////////

int 
INabtsFEC::GetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.GetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
INabtsFEC::SetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.SetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
INabtsFEC::GetPinStatistics(VBICODECFILTERING_STATISTICS_NABTS_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.GetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
INabtsFEC::SetPinStatistics(VBICODECFILTERING_STATISTICS_NABTS_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.SetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

//////////////////////////////////////////////////////////////
// Embedded class tests
//////////////////////////////////////////////////////////////

#if defined(_CLASSTESTS)

INabtsFEC	NabtsFEC();

#endif

#pragma warning(default:4355)

/*EOF*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\icodec\nabts.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              17-Nov-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#include <nabts.h>
#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// Stream Format Raw NABTS bundles
//////////////////////////////////////////////////////////////

#define NABTS_OUTPUT_PIN	    1

KSDATARANGE StreamFormatNabts = 
{
    // Definition of the stream (MUST match the output pin of the decoder)
    {   
        sizeof (KSDATARANGE),           // FormatSize
        0,                              // Flags
	    sizeof (NABTS_BUFFER),          // SampleSize
        0,                              // Reserved
		{ STATIC_KSDATAFORMAT_TYPE_NABTS },
		{ STATIC_KSDATAFORMAT_SUBTYPE_NABTS },
		{ STATIC_KSDATAFORMAT_SPECIFIER_NONE }
    }
};

//////////////////////////////////////////////////////////////
// INabtsOutputPin
// INabtsOutputPin
//////////////////////////////////////////////////////////////

INabtsOutputPin::~INabtsOutputPin() 
    {
    }

//////////////////////////////////////////////////////////////
// INabts:: ctors & dtors
//////////////////////////////////////////////////////////////

INabts::INabts() : 
        IVBICodec("NABTS/FEC VBI Codec", sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS) ),
        m_Statistics(*this, KSPROPERTY_VBICODECFILTERING_STATISTICS, sizeof(VBICODECFILTERING_STATISTICS_NABTS)),
        m_OutputPin(*this, NABTS_OUTPUT_PIN, &StreamFormatNabts)
    {
    }


INabts::~INabts() 
    {
    }

//////////////////////////////////////////////////////////////
// INabts Scanline routines
//////////////////////////////////////////////////////////////

int 
INabts::AddRequestedScanline(int nScanline)
    {
    int nStatus = -1;
    VBICODECFILTERING_SCANLINES ScanlineBitArray;

    if ( m_OutputPin.m_ScanlinesRequested.GetValue(&ScanlineBitArray) )
        {
        DWORD   nBitsPerElement = sizeof(*ScanlineBitArray.DwordBitArray)*8;
        ScanlineBitArray.DwordBitArray[ nScanline / nBitsPerElement ] 
            |= 1L << (nScanline % nBitsPerElement);
        if ( m_OutputPin.m_ScanlinesRequested.SetValue(&ScanlineBitArray) )
            nStatus = 0;
        }

    return nStatus;
    }

int 
INabts::ClearRequestedScanlines()
    {
    int nStatus = -1;
    VBICODECFILTERING_SCANLINES ScanlineBitArray;

    ZeroMemory(&ScanlineBitArray,sizeof(ScanlineBitArray));
    if ( m_OutputPin.m_ScanlinesRequested.SetValue(&ScanlineBitArray) )
        nStatus = 0;

    return nStatus;
    }

int 
INabts::GetDiscoveredScanlines(VBICODECFILTERING_SCANLINES &ScanlineBitArray)
    {
    int nStatus = -1;

    if ( m_OutputPin.m_ScanlinesDiscovered.GetValue(&ScanlineBitArray) )
        {
        nStatus = 0;
        }

    return nStatus;
    }

//////////////////////////////////////////////////////////////
// Global Statistics Property Control
//////////////////////////////////////////////////////////////

int 
INabts::GetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.GetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
INabts::SetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics)
	{
    int nStatus = -1;

    if ( m_Statistics.SetValue( &CodecStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
INabts::GetPinStatistics(VBICODECFILTERING_STATISTICS_COMMON_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.GetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

int 
INabts::SetPinStatistics(VBICODECFILTERING_STATISTICS_COMMON_PIN &PinStatistics)
	{
    int nStatus = -1;

    if ( m_OutputPin.m_Statistics.SetValue( &PinStatistics ) )
        {
        nStatus = 0;
        }

    return nStatus;
	}

//////////////////////////////////////////////////////////////
// Embedded class tests
//////////////////////////////////////////////////////////////

#if defined(_CLASSTESTS)

INabts	Nabts();

#endif

#pragma warning(default:4355)

/*EOF*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\inc\icodec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              22-Aug-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#ifndef __ICODEC_H
#define __ICODEC_H

#include <iks.h>

#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// IBitmaskProperty
//////////////////////////////////////////////////////////////

class IBitmaskProperty : public IKSProperty
    {
    // Usable public interfaces
public:
    IBitmaskProperty(IKSDriver &Driver, LPCGUID Set, ULONG Id, ULONG Size) : 
        IKSProperty(Driver, Set, Id, Size) {}
    IBitmaskProperty(IKSPin &Pin, LPCGUID Set, ULONG Id, ULONG Size) : 
        IKSProperty(Pin, Set, Id, Size) {}

    // Bitmask Manipulation Routines.

    ~IBitmaskProperty();

    // Helper functions and internal data
protected:
    };

//////////////////////////////////////////////////////////////
// IScanlinesProperty
//////////////////////////////////////////////////////////////

class IScanlinesProperty : public IBitmaskProperty
    {
    // Usable public interfaces
public:
    IScanlinesProperty(IKSDriver &Driver, ULONG Id, ULONG Size) : 
        IBitmaskProperty(Driver, &KSPROPSETID_VBICodecFiltering, Id, Size) {}
    IScanlinesProperty(IKSPin &Pin, ULONG Id, ULONG Size) : 
        IBitmaskProperty(Pin, &KSPROPSETID_VBICodecFiltering, Id, Size) {}

    // Scanline Manipulation Routines.

    ~IScanlinesProperty();

    // Helper functions and internal data
protected:
    };

//////////////////////////////////////////////////////////////
// ISubstreamsProperty
//////////////////////////////////////////////////////////////

class ISubstreamsProperty : public IBitmaskProperty
    {
    // Usable public interfaces
public:
    ISubstreamsProperty(IKSDriver &Driver, ULONG Id, ULONG Size ) : 
        IBitmaskProperty(Driver,&KSPROPSETID_VBICodecFiltering,Id,Size) {}
    ISubstreamsProperty(IKSPin &Pin, ULONG Id, ULONG Size) : 
        IBitmaskProperty(Pin,&KSPROPSETID_VBICodecFiltering,Id,Size) {}

    // Substream Manipulation Routines.

    ~ISubstreamsProperty();

    // Helper functions and internal data
protected:

    };

//////////////////////////////////////////////////////////////
// IStatisticsProperty
//////////////////////////////////////////////////////////////

class IStatisticsProperty : public IKSProperty
    {
    // Usable public interfaces
public:
    IStatisticsProperty(IKSDriver &Driver, ULONG Id, ULONG Size ) : 
        IKSProperty(Driver,&KSPROPSETID_VBICodecFiltering,Id,Size) {}
    IStatisticsProperty(IKSPin &Pin, ULONG Id, ULONG Size) : 
        IKSProperty(Pin,&KSPROPSETID_VBICodecFiltering,Id,Size) {}

    // Statistics Manipulation Routines.

    ~IStatisticsProperty();

    // Helper functions and internal data
protected:

    };

//////////////////////////////////////////////////////////////
// IVBIOutputPin
//////////////////////////////////////////////////////////////

class IVBIOutputPin : public IKSPin
    {
    // Usable public interfaces
public:
    IVBIOutputPin(IKSDriver &driver, int nPin, PKSDATARANGE pKSDataRange, DWORD nSubstreamBitmaskSize ) :
        IKSPin( driver, nPin, pKSDataRange ),
	    m_ScanlinesRequested(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
                             sizeof(VBICODECFILTERING_SCANLINES)),
	    m_ScanlinesDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_SCANLINES)),
	    m_SubstreamsRequested(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
                              nSubstreamBitmaskSize),
	    m_SubstreamsDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
                               nSubstreamBitmaskSize)
        {}
    ~IVBIOutputPin();

    // Pin specific properties (does not affect other pins)
    IScanlinesProperty	m_ScanlinesRequested;
	IScanlinesProperty	m_ScanlinesDiscovered;

	ISubstreamsProperty	m_SubstreamsRequested;
	ISubstreamsProperty	m_SubstreamsDiscovered;

    // Helper functions and internal data
protected:
    
    };

//////////////////////////////////////////////////////////////
// IVBICodec::      VBI Codec Interface
//////////////////////////////////////////////////////////////

class IVBICodec : public IKSDriver
    {
    // Usable public interfaces
public:
    IVBICodec(LPCSTR lpszDriver, DWORD nSubstreamBitmaskSize ) :
        IKSDriver(&KSCATEGORY_VBICODEC,lpszDriver),
   	    m_ScanlinesRequested(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
                             sizeof(VBICODECFILTERING_SCANLINES)),
	    m_ScanlinesDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_SCANLINES)),
	    m_SubstreamsRequested(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
                              nSubstreamBitmaskSize),
	    m_SubstreamsDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
                               nSubstreamBitmaskSize)
        {}
    ~IVBICodec();

    // Driver global properties (set new pin defaults & overall driver status)
    IScanlinesProperty	m_ScanlinesRequested;
	IScanlinesProperty	m_ScanlinesDiscovered;

	ISubstreamsProperty	m_SubstreamsRequested;
	ISubstreamsProperty	m_SubstreamsDiscovered;

    // Override the IsValid() implementation to included tests on properties
    BOOL IsValid() { return IKSDriver::IsValid()
                         && m_ScanlinesRequested.IsValid()
                         && m_ScanlinesDiscovered.IsValid()
                         && m_SubstreamsRequested.IsValid()
                         && m_SubstreamsDiscovered.IsValid(); }


    // Helper functions and internal data
protected:

    };

#pragma warning(default:4355)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\inc\gemstar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;
#ifndef __GEMSTAR_H
#define __GEMSTAR_H

#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif
//
// Gemstar subtype
//
#define STATIC_KSDATAFORMAT_SUBTYPE_Gemstar \
    0xb7657a60L, 0xa305, 0x11d1, 0x8d, 0x0a, 0x00, 0x20, 0xaf, 0xf8, 0xd9, 0x6b
DEFINE_GUIDSTRUCT("b7657a60-a305-11d1-8d0a-0020aff8d96b", KSDATAFORMAT_SUBTYPE_Gemstar);
#define KSDATAFORMAT_SUBTYPE_Gemstar DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Gemstar)
//
// Gemstar output pin GUID
//
#define STATIC_PINNAME_VIDEO_GEMSTAR \
    0xb68cc640, 0xa308, 0x11d1, 0x8d, 0x0a, 0x00, 0x20, 0xaf, 0xf8, 0xd9, 0x6b
DEFINE_GUIDSTRUCT("b68cc640-a308-11d1-8d0a-0020aff8d96b", PINNAME_VIDEO_GEMSTAR);
#define PINNAME_VIDEO_GEMSTAR DEFINE_GUIDNAMED(PINNAME_VIDEO_GEMSTAR)
//
// Substreams Bitmap
//
typedef struct _VBICODECFILTERING_GEMSTAR_SUBSTREAMS {
    DWORD   SubstreamMask;                                  // An array of 32 bits 
} VBICODECFILTERING_GEMSTAR_SUBSTREAMS, *PVBICODECFILTERING_GEMSTAR_SUBSTREAMS;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_GEMSTAR_SUBSTREAMS         Substreams;
} KSPROPERTY_VBICODECFILTERING_GEMSTAR_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_GEMSTAR_SUBSTREAMS_S;

//
// Statistics
//
typedef struct _VBICODECFILTERING_STATISTICS_GEMSTAR {
    VBICODECFILTERING_STATISTICS_COMMON Common;              // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_GEMSTAR, *PVBICODECFILTERING_STATISTICS_GEMSTAR;

typedef struct _VBICODECFILTERING_STATISTICS_GEMSTAR_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_GEMSTAR_PIN, *PVBICODECFILTERING_STATISTICS_GEMSTAR_PIN;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_GEMSTAR         Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_GEMSTAR_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_GEMSTAR_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_GEMSTAR_PIN     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_GEMSTAR_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_GEMSTAR_PIN_S;

#include <pshpack1.h>
//
// Structure passed to clients
//
typedef struct _GEMSTAR_BUFFER{
    USHORT      Scanline;           // As in the scanline number, not a mask
    USHORT      Substream;          // See KS_GEMSTAR_SUBSTREAM...
    USHORT      DataLength[2];      // Number of decoded bytes array
    UCHAR       Data[2][4];         // Payload array
    
} GEMSTAR_BUFFER, *PGEMSTAR_BUFFER;
#include <poppack.h>

#define KS_GEMSTAR_SUBSTREAM_ODD            0x0001L
#define KS_GEMSTAR_SUBSTREAM_EVEN           0x0002L
#define KS_GEMSTAR_SUBSTREAM_BOTH           0x0003L
    
#endif // __GEMSTAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\inc\ccdecode.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              22-Aug-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#ifndef __CCDECODE_H
#define __CCDECODE_H

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include <icodec.h>

#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// ICCOutputPin::   Closed Captioning Output Pin Interface
//////////////////////////////////////////////////////////////

class ICCOutputPin : public IVBIOutputPin
	{
    // Usable public interfaces
public:
    ICCOutputPin(IKSDriver &driver, int nPin, PKSDATARANGE pKSDataRange ) :
        IVBIOutputPin( driver, nPin, pKSDataRange, sizeof(VBICODECFILTERING_CC_SUBSTREAMS)  ),
	    m_ScanlinesRequested(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
                             sizeof(VBICODECFILTERING_SCANLINES)),
	    m_ScanlinesDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_SCANLINES)),
	    m_SubstreamsRequested(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_CC_SUBSTREAMS) ),
	    m_SubstreamsDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
                               sizeof(VBICODECFILTERING_CC_SUBSTREAMS) ),
	    m_Statistics(*this,KSPROPERTY_VBICODECFILTERING_STATISTICS,
                     sizeof(VBICODECFILTERING_STATISTICS_CC_PIN))
        {}
    ~ICCOutputPin();

    // Pin specific properties (does not affect other pins)
    IScanlinesProperty	m_ScanlinesRequested;
	IScanlinesProperty	m_ScanlinesDiscovered;

	ISubstreamsProperty	m_SubstreamsRequested;
	ISubstreamsProperty	m_SubstreamsDiscovered;

    IStatisticsProperty m_Statistics;

    // Helper functions and internal data
protected:
    
    };



//////////////////////////////////////////////////////////////
// ICCDecode::      Closed Captioning Codec Interface
//////////////////////////////////////////////////////////////

class ICCDecode : public IVBICodec
    {
    // Usable public interfaces
public:
    ICCDecode();
    ~ICCDecode();

    // Call to make sure construction was successful
    BOOL IsValid() { return IVBICodec::IsValid() && m_OutputPin.IsValid(); }
        
    // Typically line 21 for actual closed captioning data (default)
    int AddRequestedScanline(int nScanline);    // Adds _another_ scanline to the request list.
    int ClearRequestedScanlines();              // Use this to reset requested scanlines to none.
    int GetDiscoveredScanlines(VBICODECFILTERING_SCANLINES &ScanlineBitArray);

    // One of KS_CC_SUBSTREAM_ODD(default), KS_CC_SUBSTREAM_EVEN
    // Readible closed captioning data is usually on the ODD field.
    int AddRequestedVideoField(int nField);     // Adds _another_ field to the request list.
    int ClearRequestedVideoFields();            // Use this to reset requested fields to none.
    int GetDiscoveredVideoFields(VBICODECFILTERING_CC_SUBSTREAMS &bitArray);

	// Statistics Property Control
	int GetCodecStatistics(VBICODECFILTERING_STATISTICS_CC &CodecStatistics);
	int SetCodecStatistics(VBICODECFILTERING_STATISTICS_CC &CodecStatistics);
  	int GetPinStatistics(VBICODECFILTERING_STATISTICS_CC_PIN &PinStatistics);
	int SetPinStatistics(VBICODECFILTERING_STATISTICS_CC_PIN &PinStatistics);

    // Read function (call "overlapped" at THREAD_PRIORITY_ABOVE_NORMAL to avoid data loss)
    int ReadData( LPBYTE lpBuffer, int nBytes, DWORD *lpcbReturned, LPOVERLAPPED lpOS )
        { return m_OutputPin.ReadData( lpBuffer, nBytes, lpcbReturned, lpOS ); }
    int GetOverlappedResult( LPOVERLAPPED lpOS, LPDWORD lpdwTransferred = NULL, BOOL bWait=TRUE )
        { return m_OutputPin.GetOverlappedResult(lpOS, lpdwTransferred, bWait ); }

    // Helper functions and internal data
    // Actual Pin instance [w/properties] (set by above to control filtering & to get discovered)
    ICCOutputPin       m_OutputPin;

    // Additional driver global properties
    IStatisticsProperty m_Statistics;
protected:
};

#pragma warning(default:4355)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\inc\iks.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              22-Aug-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#ifndef __IKS_H
#define __IKS_H

#include <ks.h>
#include <ksmedia.h>
#include <windows.h>
#include <winioctl.h>
#include <tchar.h>

#if !defined(FILE_DEVICE_KS)
// This comes from <wdm.h> but is not easily included(Been there, done that)
#define FILE_DEVICE_KS  0x000002F
#endif

//////////////////////////////////////////////////////////////
// Force the correct library to be included.
//////////////////////////////////////////////////////////////

#ifdef _DEBUG
	#pragma comment(lib, "icodecd.lib")
#else
	#pragma comment(lib, "icodec.lib")
#endif

//////////////////////////////////////////////////////////////
// Global Types
//////////////////////////////////////////////////////////////

typedef GUID *		LPGUID;
typedef const GUID	*LPCGUID;

//////////////////////////////////////////////////////////////
// IKSDriver::      Kernel Mode Streaming Driver Interface
//////////////////////////////////////////////////////////////

class IKSDriver
    {
    // Usable public interfaces
public:
    IKSDriver(LPCGUID lpCategory, LPCSTR lpszFriendlyName);
    ~IKSDriver();

    BOOL        Ioctl(ULONG dwControlCode, LPBYTE pInput, ULONG nInput, 
                      LPBYTE pOutput, ULONG nOutput, 
                      DWORD *nReturned, LPOVERLAPPED lpOS=NULL );

    BOOL        IsValid() { return m_lpszDriver && m_hKSDriver; }

    HANDLE      m_hKSDriver;

    // Helper functions and internal data
protected:
    LPWSTR      GetSymbolicName(LPCGUID lpCategory, LPCSTR lpszFriendlyName);
    BOOL        OpenDriver(DWORD dwAccess, DWORD dwFlags);
    BOOL        CloseDriver();

    LPWSTR      m_lpszDriver;
    };

//////////////////////////////////////////////////////////////
// IKSPin::         Kernel Mode Streaming Pin Interface
//////////////////////////////////////////////////////////////

class IKSPin
    {
    // Usable public interfaces
public:
    IKSPin(IKSDriver &driver, int nPin, PKSDATARANGE pKSDataRange );
    ~IKSPin();

    BOOL        Ioctl(ULONG dwControlCode, void *pInput, ULONG nInput, 
                      void *pOutput, ULONG nOutput, 
                      ULONG *nReturned, LPOVERLAPPED lpOS=NULL );

    BOOL        Run(); // Automatically called by the constructors
    BOOL        Stop(); // Automatically called by the destructors
    BOOL        IsRunning() { return m_bRunning; }

    int         ReadData( LPBYTE lpBuffer, int nBytes, DWORD *lpcbReturned, LPOVERLAPPED lpOS );
    int         GetOverlappedResult( LPOVERLAPPED lpOS, LPDWORD lpdwTransferred = NULL, BOOL bWait=TRUE );

    BOOL        IsValid() { return m_IKSDriver && m_nPin>=0 && m_hKSPin /*&& m_bRunning*/; }

    HANDLE      m_hKSPin;

    // Helper functions and internal data
protected:
    BOOL        OpenPin(PKSDATARANGE pKSDataRange);
    BOOL        ClosePin();
    BOOL        GetRunState( PKSSTATE pKSState );
    BOOL        SetRunState( KSSTATE KSState );
    

    IKSDriver   *m_IKSDriver;
    LONG        m_nPin;
    BOOL        m_bRunning;
    };

//////////////////////////////////////////////////////////////
// IKSProperty::    Kernel Mode Streaming Property Interface
//////////////////////////////////////////////////////////////

class IKSProperty
    {
    // Usable public interfaces
public:
    IKSProperty(IKSDriver &pin, LPCGUID Set, ULONG Id, ULONG Size);
    IKSProperty(IKSPin &pin, LPCGUID Set, ULONG Id, ULONG Size);
    ~IKSProperty();

    BOOL        SetValue(void *nValue);
    BOOL        GetValue(void *nValue);

    BOOL        IsValid() { return (m_IKSPin  || m_IKSDriver) && m_Id && m_hKSProperty; }

    HANDLE      m_hKSProperty;

    // Helper functions and internal data
protected:
    BOOL        OpenProperty();
    BOOL        CloseProperty();

    IKSDriver	*m_IKSDriver;
    IKSPin      *m_IKSPin;
    GUID        m_Set;
    ULONG       m_Id;
    ULONG       m_Size;
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\coeffs.c ===
#include "tables.h"

/* These are the coefficients in Norpak's FEC algorithm.  In my
   document describing this algorithm, I refer to
   norpak_coeffs[j][i] as

         c
	  i,j
   */

unsigned char norpak_coeffs[2][26] = {
  { 0x9d, 0x37, 0xe4, 0xcb, 0x7f, 0xab, 0x8d, 0xbb, 0xb1, 0x6a,
    0xde, 0x8a, 0x4a, 0x20, 0x98, 0x9d, 0xbb, 0x94, 0x3d, 0x38,
    0xa6, 0xe9, 0x42, 0xa0, 0xe2, 0x64, },
  { 0x92, 0x97, 0xdd, 0xa0, 0x9a, 0x91, 0x0a, 0x50, 0x1d, 0x60,
    0xae, 0x20, 0x3d, 0x2c, 0x01, 0x0a, 0x40, 0xc8, 0xe5, 0xff,
    0xf2, 0x68, 0xc9, 0xa1, 0x63, 0x8d, },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\inc\nabtsfec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              17-Nov-97   TKB     Created Initial Interface Version
//
//==========================================================================;

#ifndef __NABTSFEC_H
#define __NABTSFEC_H

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include <icodec.h>

#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// INabtsFEC OutputPin::   Corrected Nabts Output Pin Interface
//////////////////////////////////////////////////////////////

class INabtsFECOutputPin : public IVBIOutputPin
	{
    // Usable public interfaces
public:
    INabtsFECOutputPin(IKSDriver &driver, int nPin, PKSDATARANGE pKSDataRange ) :
        IVBIOutputPin( driver, nPin, pKSDataRange, sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS)  ),
	    m_SubstreamsRequested(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS) ),
	    m_SubstreamsDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
                               sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS) ),
	    m_Statistics(*this,KSPROPERTY_VBICODECFILTERING_STATISTICS,
                     sizeof(VBICODECFILTERING_STATISTICS_NABTS_PIN))
        {}

    // Pin specific properties (does not affect other pins)
	ISubstreamsProperty	m_SubstreamsRequested;
	ISubstreamsProperty	m_SubstreamsDiscovered;

    IStatisticsProperty m_Statistics;

    ~INabtsFECOutputPin();

    // Helper functions and internal data
protected:
    
    };

//////////////////////////////////////////////////////////////
// INabtsFEC::      NABTS/FEC Codec Interface
//////////////////////////////////////////////////////////////

class INabtsFEC : public IVBICodec
    {
    // Usable public interfaces
public:
    INabtsFEC();
    ~INabtsFEC();

    // Call to make sure construction was successful
    BOOL IsValid() { return IVBICodec::IsValid() && m_OutputPin.IsValid(); }

    int AddRequestedGroup(int nField);     // Adds _another_ NABTS group to the request list.
    int ClearRequestedGroups();            // Use this to reset requested groups to none.
    int GetDiscoveredGroups(VBICODECFILTERING_NABTS_SUBSTREAMS &GroupBitArray);

    // Read functions (call "overlapped" at THREAD_PRIORITY_ABOVE_NORMAL to avoid data loss)
    int ReadData( PNABTSFEC_BUFFER lpBuffer, int nBytes, DWORD *lpcbReturned, LPOVERLAPPED lpOS )
        { return m_OutputPin.ReadData( (LPBYTE)lpBuffer, nBytes, lpcbReturned, lpOS ); }
    int GetOverlappedResult( LPOVERLAPPED lpOS, LPDWORD lpdwTransferred = NULL, BOOL bWait=TRUE )
        { return m_OutputPin.GetOverlappedResult(lpOS, lpdwTransferred, bWait ); }

	// Statistics Property Control
  	int GetPinStatistics(VBICODECFILTERING_STATISTICS_NABTS_PIN &PinStatistics);
	int SetPinStatistics(VBICODECFILTERING_STATISTICS_NABTS_PIN &PinStatistics);

	// Statistics Property Control
	int GetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics);
	int SetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics);

    // Additional driver global properties
    IStatisticsProperty m_Statistics;

    // Actual Pin instance [w/properties] (set by above to control filtering & to get discovered)
    INabtsFECOutputPin  m_OutputPin;

protected:
    };

#pragma warning(default:4355)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\inc\igemstar.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997-1998  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              20-Feb-98   TKB     Initial Interface Version
//
//==========================================================================;

#ifndef __IGEMSTAR_H
#define __IGEMSTAR_H

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include <icodec.h>
#include <gemstar.h>
#pragma warning(disable:4355)


//////////////////////////////////////////////////////////////
// IGemstarOutputPin::   Closed Captioning Output Pin Interface
//////////////////////////////////////////////////////////////

class IGemstarOutputPin : public IVBIOutputPin
	{
    // Usable public interfaces
public:
    IGemstarOutputPin(IKSDriver &driver, int nPin, PKSDATARANGE pKSDataRange ) :
        IVBIOutputPin( driver, nPin, pKSDataRange, sizeof(VBICODECFILTERING_GEMSTAR_SUBSTREAMS)  ),
	    m_ScanlinesRequested(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
                             sizeof(VBICODECFILTERING_SCANLINES)),
	    m_ScanlinesDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_SCANLINES)),
	    m_SubstreamsRequested(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_GEMSTAR_SUBSTREAMS) ),
	    m_SubstreamsDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
                               sizeof(VBICODECFILTERING_GEMSTAR_SUBSTREAMS) ),
	    m_Statistics(*this,KSPROPERTY_VBICODECFILTERING_STATISTICS,
                     sizeof(VBICODECFILTERING_STATISTICS_GEMSTAR_PIN))
        {}
    ~IGemstarOutputPin();

    // Pin specific properties (does not affect other pins)
    IScanlinesProperty	m_ScanlinesRequested;
	IScanlinesProperty	m_ScanlinesDiscovered;

	ISubstreamsProperty	m_SubstreamsRequested;
	ISubstreamsProperty	m_SubstreamsDiscovered;

    IStatisticsProperty m_Statistics;

    // Helper functions and internal data
protected:
    
    };



//////////////////////////////////////////////////////////////
// IGemstarDecode::      Closed Captioning Codec Interface
//////////////////////////////////////////////////////////////

class IGemstarDecode : public IVBICodec
    {
    // Usable public interfaces
public:
    IGemstarDecode();
    ~IGemstarDecode();

    // Call to make sure construction was successful
    BOOL IsValid() { return IVBICodec::IsValid() && m_OutputPin.IsValid(); }
        
    // Typically line 21 for actual closed captioning data (default)
    int AddRequestedScanline(int nScanline);    // Adds _another_ scanline to the request list.
    int ClearRequestedScanlines();              // Use this to reset requested scanlines to none.
    int GetDiscoveredScanlines(VBICODECFILTERING_SCANLINES &ScanlineBitArray);

    // One of KS_GEMSTAR_SUBSTREAM_ODD(default), KS_GEMSTAR_SUBSTREAM_EVEN
    // Readible closed captioning data is usually on the ODD field.
    int AddRequestedVideoField(int nField);     // Adds _another_ field to the request list.
    int ClearRequestedVideoFields();            // Use this to reset requested fields to none.
    int GetDiscoveredVideoFields(VBICODECFILTERING_GEMSTAR_SUBSTREAMS &bitArray);

	// Statistics Property Control
	int GetCodecStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR &CodecStatistics);
	int SetCodecStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR &CodecStatistics);
  	int GetPinStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR_PIN &PinStatistics);
	int SetPinStatistics(VBICODECFILTERING_STATISTICS_GEMSTAR_PIN &PinStatistics);

    // Read function (call "overlapped" at THREAD_PRIORITY_ABOVE_NORMAL to avoid data loss)
    int ReadData( PGEMSTAR_BUFFER lpBuffer, int nBytes, DWORD *lpcbReturned, LPOVERLAPPED lpOS )
        { return m_OutputPin.ReadData( (LPBYTE)lpBuffer, nBytes, lpcbReturned, lpOS ); }
    int GetOverlappedResult( LPOVERLAPPED lpOS, LPDWORD lpdwTransferred = NULL, BOOL bWait=TRUE )
        { return m_OutputPin.GetOverlappedResult(lpOS, lpdwTransferred, bWait ); }

    // Helper functions and internal data
    // Actual Pin instance [w/properties] (set by above to control filtering & to get discovered)
    IGemstarOutputPin       m_OutputPin;

    // Additional driver global properties
    IStatisticsProperty m_Statistics;
protected:

};

#pragma warning(default:4355)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\gentabs.c ===
/* This program generates several tables used in the FEC algorithms
   (this saves a little code space and time over generating them at
   runtime)
   */

#include <stdio.h>
#include <stdlib.h>

#define EXTERN
#include "tabdecls.h"

/* Generate a table of 2^i for 0<=i<=511 (where multiplications are
   done in the Galois field) */
void generate_galois_exp() {
  int i;
  int current = 1;

  for (i = 0; i < 512; i++) {
    galois_exp[i] = current;

    current <<= 1;

    if (current & 0x100) {
      current ^= 0x11d;
    }
  }

  for (i = 512; i <= 1024; i++) {
    galois_exp[i] = 0;
  }
}

/* Generate a table of log_2(i) for 1<=i<=255

   for 1<=i<=255: galois_exp[galois_log[i]] = i
   for 0<=i<=254: galois_log[galois_exp[i]] = i

   for 1<=a,b<=255: galois_exp[galois_log[a]+galois_log[b]]
      is the galois field product of a and b
   */
void generate_galois_log() {
  int i;

  /* We can't take the log of 0; let's give it a value which is not legal
     in this log table.  (This out-of-range value will push galois_exp
     into the region of the table containing 0's.) */
  galois_log[0] = 512;

  for (i = 0; i <= 254; i++) {
    galois_log[galois_exp[i]] = i;
  }
}

/* We can save an array lookup in some inner loops by keeping
   the logarithm of the Norpak coefficients */
void generate_lcoeffs() {
  int i, j;

  for (i = 0; i < 2; i++) {
    for (j = 0; j < 26; j++) {
      log_norpak_coeffs[i][j] = galois_log[norpak_coeffs[i][j]];
    }
  }
}

/* This is computing the function P() from my FEC document; it is
   used for locating single-byte FEC errors */
void generate_norpak_delta_inv() {
  int i;

  for (i = 0; i < 256; i++) {
    norpak_delta_inv[i] = 255;
  }

  for (i = 0; i < 26; i++) {
    norpak_delta_inv[(log_norpak_coeffs[0][i] + 255 - log_norpak_coeffs[1][i])%255] = i;
  }
}

/* For each byte, figure out what hamming value this byte should decode
   to (if multiple values are equally close, use an error value of 0xff) */
void generate_decode_hamming() {
  int val;

  for (val = 0; val < 256; val++) {
    int b1 = !!(val&1);
    int b2 = !!(val&2);
    int b3 = !!(val&4);
    int b4 = !!(val&8);
    int b5 = !!(val&16);
    int b6 = !!(val&32);
    int b7 = !!(val&64);
    int b8 = !!(val&128);

    int a = b8^b6^b2^b1;
    int b = b8^b4^b3^b2;
    int c = b6^b5^b4^b2;
    int d = b8^b7^b6^b5^b4^b3^b2^b1;

    if (a == 1 && b == 1 && c == 1 && d == 1) {
      decode_hamming_tab[val] = (b8<<3 | b6<<2 | b4<<1 | b2);
    } else if (d == 1) {
      /* multiple errors */
      decode_hamming_tab[val] = 0xff;
    } else {
      switch (a << 2 | b << 1 | c) {
      case 1:
	b8 ^= 1;
	break;

      case 7:
	b7 ^= 1;
	break;

      case 2:
	b6 ^= 1;
	break;

      case 6:
	b5 ^= 1;
	break;

      case 4:
	b4 ^= 1;
	break;

      case 5:
	b3 ^= 1;
	break;

      case 0:
	b2 ^= 1;
	break;

      case 3:
	b1 ^= 1;
	break;
      }

      decode_hamming_tab[val] = (b8<<3 | b6<<2 | b4<<1 | b2);
    }
  }
}

void print_char_table_body(FILE *out, unsigned char *table, int len) {
  int i;

  fprintf(out, "{\n");
  for (i = 0; i < len; i++) {
    fprintf(out, "  0x%02x,\n", table[i]);
  }
  fprintf(out, "}");
}

void print_char_table(FILE *out, const char *name,
		      unsigned char *table, int len) {

  fprintf(out, "unsigned char %s[%d] = ", name, len);
  print_char_table_body(out, table, len);
  fprintf(out, ";\n\n");
}

void print_short_table_body(FILE *out, unsigned short *table, int len) {
  int i;

  fprintf(out, "{\n");
  for (i = 0; i < len; i++) {
    fprintf(out, "  0x%04x,\n", table[i]);
  }
  fprintf(out, "}");
}

void print_short_table(FILE *out, const char *name,
		       unsigned short *table, int len) {

  fprintf(out, "unsigned short %s[%d] = ", name, len);
  print_short_table_body(out, table, len);
  fprintf(out, ";\n\n");
}

void print_tables() {
  FILE *out;
  int i;

  out = fopen("tables.c", "w");
  if (!out) {
    fprintf(stderr, "Failed to open 'tables.c'\n");
    exit(1);
  }

  fprintf(out, "\
/* Warning: This code was automatically generated (by gentabs.c).\n\
   DO NOT EDIT! */\n\
#include \"tabdecls.h\"\n\
\n");

  print_char_table(out, "galois_exp", galois_exp, 1025);
  print_short_table(out, "galois_log", galois_log, 256);
  print_char_table(out, "norpak_delta_inv", norpak_delta_inv, 256);
  print_char_table(out, "decode_hamming_tab", decode_hamming_tab, 256);

  fprintf(out, "\
unsigned char log_norpak_coeffs[2][26] = {\n");
  for (i = 0; i < 2; i++) {
    print_char_table_body(out, log_norpak_coeffs[i], 26);
    fprintf(out, ",\n");
  }
  fprintf(out, "};\n\n");
}

int main(int argc, char **argv) {
  generate_galois_exp();
  generate_galois_log();
  generate_lcoeffs();
  generate_norpak_delta_inv();
  generate_decode_hamming();

  print_tables();

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\hvchecks.c ===
/* Since the Norpak bundle FEC uses the same FEC for vertical and
   horizontal lines, we need to do several of the same operations
   on vertical and horizontal lines.  However, it's difficult
   to share the code, because operations which work on horizontal
   lines want to assume that the bytes in the line are consecutive,
   and operations which work on vertical lines want to assume that
   the bytes in the line are separated by sizeof(Packet).

   We could just pass in a "stride" (1 for horizontal, sizeof(Packet)
   for vertical); but this would involve a multiplication in both
   the horizontal and vertical inner loops.  Instead, we write the
   code once, and rely on various preprocessor shenanigans to
   create two different versions; in the horizontal version, any
   decent compiler will optimize away the multiplications by 1.
   (Basically, we just #include this file into nabtslib.c twice
   with different preprocessor #define's in effect; once for the
   horizontal and once for the vertical operations.) */


/* STRIDE is #define'd in nabtslib.c to be either 1 or sizeof(Packet) */
#define VALS(x) (vals[STRIDE*(x)])


/* This code generates compute_csum_vert and compute_csum_horiz.
   Given a (horizontal or vertical) line (actually all but the
   last two bytes of the line), it computes the correct checksum
   for the line (the correct last two bytes). */
int STRIDENAM(compute_csum)(unsigned char *vals, int len) {
  int check = 0;
  int i;

  for (i = 0; i < len; i++) {
    /* If VALS(i) is zero, then the byte has no effect on the checksum. */
    if (VALS(i)) {
      int bcheck = galois_log[VALS(i)];
      int offs0 = log_norpak_coeffs[0][i];
      int offs1 = log_norpak_coeffs[1][i];

      check ^= galois_exp[bcheck+offs0]<<8 | galois_exp[bcheck+offs1];
    }
  }

  return check;
}

/* This code generates check_checksum_vert and check_checksum_horiz.
   Given a (horizontal or vertical) line, it computes the error for
   the line (the XOR of the given checksum and the computed checksum).
   It then calls update_fec_inf() to determine whether the line is OK
   (no error), whether the error can be explained as a single-byte error,
   or whether the error must be at least two-byte. */
fec_stat STRIDENAM(check_checksum)(unsigned char *vals, int len, fec_info *inf) {
  int check = STRIDENAM(compute_csum)(vals, len);
  inf->err = check ^ (VALS(len)<<8 | VALS(len+1));
  inf->errl[0] = galois_log[inf->err>>8];
  inf->errl[1] = galois_log[inf->err&0xff];
  /* The following line makes inf->status no longer be fec_status_missing
     (update_fec_inf does nothing for missing lines) */
  inf->status = fec_status_ok;
  return update_fec_inf(inf, len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\host.h ===
#ifndef _HOST_H_
#define _HOST_H_

#ifdef linux
# include <math.h>
  typedef int BOOL;
# define alloc_mem malloc
# define free_mem free
#endif

#ifdef MSC
# include <strmini.h>
# include <ksmedia.h>
   __inline abort_execution()  { }
# ifdef DEBUG
#   define debug_printf(x)     DbgPrint x
#   define debug_breakpoint()  DbgBreakPoint()
# else /*DEBUG*/
#   define debug_printf(x)  /* nothing */
#   define debug_breakpoint()  /* nothing */
    //__inline debug_printf(char *fmt, ...)  { }
    //__inline char *flPrintf(double num, int prec)  { }
    //__inline printf(const char *fmt, ...)  { }
# endif /*DEBUG*/
# define alloc_mem(bytes)    ExAllocatePool(NonPagedPool, (bytes))
# define free_mem(ptr)       ExFreePool(ptr)
# define inline              __inline
#endif /*MSC*/

#endif //_HOST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\inc\nabts.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
//
//  History:
//              17-Jan-98   TKB     Created Initial Interface Version
//
//==========================================================================;

#ifndef __NABTS_H
#define __NABTS_H

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include <icodec.h>

#pragma warning(disable:4355)

//////////////////////////////////////////////////////////////
// INabtsOutputPin::   Raw Nabts Output Pin Interface
//////////////////////////////////////////////////////////////

class INabtsOutputPin : public IVBIOutputPin
	{
    // Usable public interfaces
public:
    INabtsOutputPin(IKSDriver &driver, int nPin, PKSDATARANGE pKSDataRange ) :
        IVBIOutputPin( driver, nPin, pKSDataRange, sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS)  ),
	    m_ScanlinesRequested(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
                             sizeof(VBICODECFILTERING_SCANLINES)),
	    m_ScanlinesDiscovered(*this,KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
                              sizeof(VBICODECFILTERING_SCANLINES)),
	    m_Statistics(*this,KSPROPERTY_VBICODECFILTERING_STATISTICS,
                     sizeof(VBICODECFILTERING_STATISTICS_COMMON_PIN))
        {}

    // Pin specific properties (does not affect other pins)
    IScanlinesProperty	m_ScanlinesRequested;
	IScanlinesProperty	m_ScanlinesDiscovered;

    IStatisticsProperty m_Statistics;

    ~INabtsOutputPin();

    // Helper functions and internal data
protected:
    
    };

//////////////////////////////////////////////////////////////
// INabts::      Raw NABTS Codec Interface
//////////////////////////////////////////////////////////////

class INabts : public IVBICodec
    {
    // Usable public interfaces
public:
    INabts();
    ~INabts();

    // Call to make sure construction was successful
    BOOL IsValid() { return IVBICodec::IsValid() && m_OutputPin.IsValid(); }

    int AddRequestedScanline(int nScanline);    // Adds _another_ scanline to the request list.
    int ClearRequestedScanlines();              // Use this to reset requested scanlines to none.
    int GetDiscoveredScanlines(VBICODECFILTERING_SCANLINES &ScanlineBitArray);

    // Read functions (call "overlapped" at THREAD_PRIORITY_ABOVE_NORMAL to avoid data loss)
    int ReadData( PNABTS_BUFFER lpBuffer, int nBytes, DWORD *lpcbReturned, LPOVERLAPPED lpOS )
        { return m_OutputPin.ReadData( (LPBYTE)lpBuffer, nBytes, lpcbReturned, lpOS ); }
    int GetOverlappedResult( LPOVERLAPPED lpOS, LPDWORD lpdwTransferred = NULL, BOOL bWait=TRUE )
        { return m_OutputPin.GetOverlappedResult(lpOS, lpdwTransferred, bWait ); }

	// Statistics Property Control
  	int GetPinStatistics(VBICODECFILTERING_STATISTICS_COMMON_PIN &PinStatistics);
	int SetPinStatistics(VBICODECFILTERING_STATISTICS_COMMON_PIN &PinStatistics);

	// Statistics Property Control
	int GetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics);
	int SetCodecStatistics(VBICODECFILTERING_STATISTICS_NABTS &CodecStatistics);

    // Additional driver global properties
    IStatisticsProperty m_Statistics;

    // Actual Pin instance [w/properties] (set by above to control filtering & to get discovered)
    INabtsOutputPin  m_OutputPin;

protected:
    };

#pragma warning(default:4355)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\nabtsapi.h ===
#ifndef NABTSAPI_H
#define NABTSAPI_H

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

/* Useful constants */

#define NABTS_BYTES_PER_LINE 36
//#define NABTS_SAMPLES_PER_LINE (pState->SamplesPerLine) /* no longer constant */
#define MAX_SAMPLE_RATE 6.0
#define MAX_NABTS_SAMPLES_PER_LINE ((int)(1536.0*MAX_SAMPLE_RATE/5.0))
 /* +++++++ make sure that sampling
  rates >6 give errors, or increase
  this number */

/* "Double" is the internally used floating-point representation
   (currently typedef'd to "float" below).
   All floating point numbers exposed to the outside through the API
   are actual "double" values (rather than the internal "Double") */

typedef float Double;


#define NDSP_SIGS_TO_ACQUIRE 1

enum {
   NDSP_ERROR_ILLEGAL_NDSP_STATE= 1,
   NDSP_ERROR_ILLEGAL_STATS= 2,
   NDSP_ERROR_ILLEGAL_FILTER= 3,
   NDSP_ERROR_NO_GCR= 4,
   NDSP_ERROR_UNSUPPORTED_SAMPLING_RATE= 5,
   NDSP_ERROR_ILLEGAL_VBIINFOHEADER= 6
};
   
enum {
 NDSP_NO_FEC= 1,
 NDSP_BUNDLE_FEC_1= 2,
 NDSP_BUNDLE_FEC_2= 3
};


// FP helper routines
extern long   __cdecl float2long(float);
extern unsigned short   __cdecl floatSetup();
extern void   __cdecl floatRestore(unsigned short);


/* Globals */
extern int g_nNabtsRetrainDuration; /* in frames */
extern int g_nNabtsRetrainDelay; /* in frames */
extern BOOL g_bUseGCR; /* enable use of the GCR signal */

extern Double g_pdSync[];
extern int g_nNabtsSyncSize;
extern Double g_pdGCRSignal1[];
extern Double g_pdGCRSignal2[];
extern int g_nNabtsGcrSize;

/* extern Double g_pdSync5[], g_pdGCRSignal1_5[], g_pdSignal2_5[]; */

/* Forward declarations of types. */
typedef struct ndsp_decoder_str NDSPState;
typedef struct nfec_state_str NFECState;
typedef struct ndsp_line_stats_str NDSPLineStats;
typedef struct ndsp_gcr_stats_str NDSPGCRStats;
typedef struct nfec_line_stats_str NFECLineStats;
typedef struct nfec_bundle_str NFECBundle;
typedef void (NFECCallback)(void *pContext, NFECBundle *pBundle, int groupAddr,
                             int nGoodLines);
typedef struct ndsp_gcr_str NDSPSigMatch;

/* Create a new "DSP state".
   
   A separate DSP state should be maintained for each separate
   simultaneous source to the DSP.
   
   NDSPStartRetrain() is implicitly called upon creation of a new state.

   The argument must be NULL or a pointer to sizeof(NDSPState) bytes
   of memory.  In the latter case, NDSPStateDestroy will not free this
   memory.
   */

NDSPState *NDSPStateNew(void *mem);

/* Destroys the DSP state.
   Automatically disconnects from any FEC state.

   Returns 0 on success.
   Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if illegal state.
   */

int NDSPStateDestroy(NDSPState *pState);
   
/*

  Connect the given NFECState and NDSPState
  
  For cases where the NDSP and NFEC modules are connected,
  giving pointers to the connected state may result in increased
  robustness and efficiency.

  Note that only one of
  NDSPStateConnectToFEC or
  NFECStateConnectToDSP
  need be called to connect the two states.  (Calling both is OK).

   Returns 0 on success.
   Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if illegal DSP state.
   
  */

int NDSPStateConnectToFEC(NDSPState *pDSPState, NFECState *pFECState);

int NFECStateConnectToDSP(NFECState *pFECState, NDSPState *pDSPState);
   
/*

  Tells the DSP to initiate a "fast retrain".  This is useful if you
  suspect that conditions have changed sufficiently to be worth spending
  significant CPU to quickly train on a signal.
  
  This should be called when the source of video changes.

   Returns 0 on success.
   Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if illegal DSP state.
   
  */

int NDSPStartRetrain(NDSPState *pState);

/*
 * Inputs:
 * pbSamples:  pointer to 8-bit raw NABTS samples
 * pState:     NDSPState to use for decoding
 * nFECType:   Can be set to:
 *              NDSP_NO_FEC (don't use FEC information)
 *              NDSP_BUNDLE_FEC_1 (use Norpak-style bundle FEC info)
 *              NDSP_BUNDLE_FEC_2 (use Wavephore-style bundle FEC info)
 * nFieldNumber:
 *             A number that increments by one for each successive field.
 *             "Odd" fields (as defined by NTSC) must be odd numbers
 *             "Even" fields must be even numbers.
 * nLineNumber:
 *             The NTSC line (starting from the top of the field)
 *             from which this sample was taken.
 *
 * Outputs:
 * pbDest:     decoded data ("NABTS_BYTES_PER_LINE" (36) bytes long)
 * pLineStats: stats on decoded data
 *
 * Errors:
 *
 * Returns 0 if no error
 * Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if state is illegal or uses
 *         unsupported settings
 * Returns NDSP_ERROR_ILLEGAL_STATS if stats is passed incorrectly
 *
 * Notes:
 * pbDest must point to a buffer at least 36 bytes long
 * pLineStats->nSize must be set to sizeof(*pLineStats) prior to call
 *   (to maintain backwards compatibility should we add fields in the future)
 * pLineStats->nSize will be set to the size actually filled in by
 *   the call (the number will stay the same or get smaller)
 * Currently the routine only supports a pState with an FIR filter
 *   that has 5 taps
 * nFECType is currently unused, but would potentially be used to give
 *  FEC feedback to the DSP decode, for possible tuning and/or retry
 */
 
int NDSPDecodeLine(unsigned char *pbDest, NDSPLineStats *pLineStats,
                   unsigned char *pbSamples, NDSPState *pState,
                   int nFECType,
                   int nFieldNumber, int nLineNumber,
                   KS_VBIINFOHEADER *pVBIINFO);

/* typedef'd as NDSPLineStats above */
struct ndsp_line_stats_str {
   int nSize;  /* Should be set to the size of this structure.
                  Used to maintain backwards compatibility as we add fields */
   
   int nConfidence; /* Set to 0-100 as a measure of expected reliability.
                       Low numbers are caused either by a noisy signal, or
                       if the line is in fact not NABTS */
   
   int nFirstBit;  /* The position of the center of
                      the first sync bit sample */
   
   double dDC;        /* the calculated DC offset used to threshold samples.
                         This is dependent on the current way we decode NABTS
                         and may not be used in the future */
   
};

/* typedef'd as NDSPGCRStats above */
struct ndsp_gcr_stats_str {
   int nSize;  /* Should be set to the size of this structure.
                  Used to maintain backwards compatibility as we add fields */

   BOOL bUsed;      /* Was this line used by calculations?
                       If FALSE, none of the values below are valid. */
   
   int nConfidence; /* Set to 0-100 as a measure of expected reliability.
                       Low numbers are typically caused by a noisy signal.
                       A confidence less than 50 means the algorithm
                       decided that this line was far enough from being a
                       GCR line that it wasn't used as such */
};

/* Like NDSPDecodeLine, but only decode only from nStart to nEnd bytes.
   By decoding the first 3 bytes (sync), a confidence measure can be made.
   By decoding the next 3 bytes, the group ID can be had.
   */
   
int NDSPPartialDecodeLine(unsigned char *pbDest, NDSPLineStats *pLineStats,
                          unsigned char *pbSamples, NDSPState *pState,
                          int nFECType,
                          int nFieldNumber, int nLineNumber,
                          int nStart, int nEnd,
                          KS_VBIINFOHEADER *pVBIINFO);

/* Hamming-decode a single byte.
   Useful for decoding group addresses in NABTS data

   Hamming decoding can fix a one-bit error and detect (but not
   correct) a two-bit error.

   *nBitErrors is set to the number of detected bit errors in the byte.
   if *nBitErrors is 0 or 1, the hamming-decoded value (from 0 to 15)
   is returned.
   
   if *nBitErrors is 2, -1 is returned.
   
   */

int NFECHammingDecode(unsigned char bByte, int *nBitErrors);

/* Get NABTS group address from NABTS decoded line.
   
   *nBitErrors is set to the total number of errors detected in the three
   group address bytes.
   
   If address is correctable, *bCorrectable is set to TRUE, and an address
   between 0 and 4095 is returned.

   If address is not correctable, -1 is returned.

   This only works for standard, fully NABTS-compliant packets
   */

int NFECGetGroupAddress(NFECState *nState, unsigned char *bData, int *nBitErrors);


/*
 * Conditionally process raw samples from a GCR line and modify
 * the NDSP state accordingly.
 *
 * This routine should be called with the GCR line from each incoming field.
 * (NTSC line 19)
 *
 * Even if the GCR line is known to not be present in the signal, you
 * should call this function once per frame anyway.  If no GCR is found,
 * this function will cause an equalization based on the NABTS sync bytes.
 *
 * This routine will not process all lines passed to it.  The frequency
 * with which is processes lines depends on the current NDSP state,
 * including whether a fast retrain is currently being performed.
 *
 * Inputs:
 * pbSamples:  pointer to 8-bit raw samples
 * pState:     NDSPState to use for decoding
 * nFieldNumber:
 *             A number that increments by one for each successive field.
 *             "Odd" fields (as defined by NTSC) must be odd numbers
 *             "Even" fields must be even numbers.
 * nLineNumber:
 *             The NTSC line (starting from the top of the field)
 *             from which this sample was taken.
 *
 * Outputs:
 * pbDest:     
 * pLineStats: stats on decoded data
 * Errors:
 *
 * Returns 0 if no error
 * Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if state is illegal or uses
 *         unsupported settings
 * Returns NDSP_ERROR_ILLEGAL_STATS if stats is passed incorrectly
 *
 * Notes:
 * pbDest must point to a buffer at least 36 bytes long
 * pLineStats->nSize must be set to sizeof(*pLineStats) prior to call
 *   (to maintain backwards compatibility should we add fields in the future)
 * pLineStats->nSize will be set to the size actually filled in by
 *   the call (the number will stay the same or get smaller)
 */

int NDSPProcessGCRLine(NDSPGCRStats *pLineStats,
                       unsigned char *pbSamples, NDSPState *pState,
                       int nFieldNumber, int nLineNumber,
                       KS_VBIINFOHEADER *pVBIINFO);

#define NDSP_MAX_FIR_COEFFS 50
#define NDSP_MAX_FIR_TAIL MAX_NABTS_SAMPLES_PER_LINE

struct variable_tap_str {
   int nTapLoc;
   Double dTap;
};

typedef struct fir_filter_str {
   BOOL bVariableTaps;
   int		nTaps; /* must be of form 2n+1 if bVariableTaps is zero */
   Double	dTapSpacing;    /* Only for bVariableTaps = FALSE */
   int		nMinTap;        /* Only for bVariableTaps = TRUE */
   int		nMaxTap;        /* Only for bVariableTaps = TRUE */
   Double	pdTaps[NDSP_MAX_FIR_COEFFS];
   int		pnTapLocs[NDSP_MAX_FIR_COEFFS];
} FIRFilter;

/* typedef'd as NDSPSigMatch above */
struct ndsp_gcr_str {
   Double dMaxval;
   int nOffset;
   unsigned char pbSamples[MAX_NABTS_SAMPLES_PER_LINE];
};
   
/* typedef'd as NDSPState above */
struct ndsp_decoder_str {
   unsigned int uMagic;  /* must be set to NDSP_STATE_MAGIC */
   int nRetrainState;
   int nUsingGCR;   /* 0 for no GCR, > 0 means using GCR */
   FIRFilter filter;
   /*
   unsigned char pbBestGCRLine[MAX_NABTS_SAMPLES_PER_LINE];
   Double dBestGCRLineVal;
   */
   
   NDSPSigMatch psmPosGCRs[NDSP_SIGS_TO_ACQUIRE];
   NDSPSigMatch psmNegGCRs[NDSP_SIGS_TO_ACQUIRE];
   NDSPSigMatch psmSyncs[NDSP_SIGS_TO_ACQUIRE];
   
   BOOL bFreeStateMem;

   BOOL bUsingScratch1;
   Double pdScratch1[MAX_NABTS_SAMPLES_PER_LINE+NDSP_MAX_FIR_TAIL*2];
   BOOL bUsingScratch2;
   Double pdScratch2[MAX_NABTS_SAMPLES_PER_LINE+NDSP_MAX_FIR_TAIL*2];
   FIRFilter filterScratch3;
   FIRFilter filterGCREqualizeTemplate;
   FIRFilter filterNabsyncEqualizeTemplate;
   BOOL bUsingScratch3;
   Double pdScratch3[NDSP_MAX_FIR_COEFFS*NDSP_MAX_FIR_COEFFS];
   BOOL bUsingScratch4;
   Double pdScratch4[NDSP_MAX_FIR_COEFFS];
   BOOL bUsingScratch5;
   Double pdScratch5[MAX_NABTS_SAMPLES_PER_LINE+NDSP_MAX_FIR_TAIL*2];
   BOOL bUsingScratch6;
   Double pdScratch6[MAX_NABTS_SAMPLES_PER_LINE+NDSP_MAX_FIR_TAIL*2];
   BOOL bUsingScratch7;
   Double pdScratch7[MAX_NABTS_SAMPLES_PER_LINE+NDSP_MAX_FIR_TAIL*2];
   BOOL bUsingScratch8;
   Double pdScratch8[MAX_NABTS_SAMPLES_PER_LINE+NDSP_MAX_FIR_TAIL*2];

  Double dSampleRate;
  Double dSampleFreq;

  long  SamplesPerLine;
};

/* Create a new "FEC state".
   
   A separate FEC state should be maintained for each separate
   simultaneous source to the FEC.
   
   Returns NULL on failure (i.e., out of memory).
   */

NFECState *NFECStateNew();


/* Set the sampling rate of a state to a new value */
int NDSPStateSetSampleRate(NDSPState* pState, unsigned long samp_rate);


/* Destroys the FEC state.
   Automatically disconnects from any DSP state. */

void NFECStateDestroy(NFECState *nState);

/* Set a list of group addresses to listen to.  If pGroupAddrs is NULL,
   then listen to all group addresses.  Returns nonzero on success, zero
   on failure.  (On failure, the state is not changed.)
   */

int NFECStateSetGroupAddrs(NFECState *pState, int *pGroupAddrs,
               int nGroupAddrs);

/* You pass in a line (36 bytes, as received from the DSP), a pointer
   to a NFECLineStats structure, and a callback function (to say what to
   do with the data).  The prototype for the callback function is given
   above.  The callback is responsible for freeing its pBundle argument. */

void NFECDecodeLine(unsigned char *line,
                    int confidence,
                    NFECState *pState,
                    NFECLineStats *pLineStats,
                    NFECCallback *cb,
                    void *pContext);

typedef enum {NFEC_OK, NFEC_GUESS, NFEC_BAD} NFECPacketStatus;

typedef enum {NFEC_LINE_OK, NFEC_LINE_CHECKSUM_ERR, NFEC_LINE_CORRUPT} NFECLineStatus;

struct nfec_line_stats_str {
   int nSize;  /* Should be set to the size of this structure.
                  Used to maintain backwards compatibility as we add fields */
   
   NFECLineStatus status; /* This will be filled in with the status of
                             the passed-in line.  The possible values are:
                             NFEC_LINE_OK: The line passed all tests; it is
                             almost certainly a valid, FEC'd NABTS line.
                             NFEC_LINE_CHECKSUM_ERR: We were able to
                             munge the line until it looked valid; we're going
                             to attempt to make use of this line.
                             NFEC_LINE_CORRUPT: We were unable to guess
                             how to change this line to make it valid; it
                             will be discarded.
                             (The statistics here are subject to change.) */
};

typedef struct nfec_packet_str {
  unsigned char data[28];   /* The actual data in this packet. */
  int len;          /* The amount of useful data in this packet
                       (excluding FEC and filler).  Will usually
                       be either 0 or 26, but may vary in
                       the presence of filler. */
  NFECPacketStatus status;  /* The status of this packet; some indication
                               of whether the packet is valid.  (This
                               is subject to change.) */
#ifdef DEBUG_FEC
  unsigned char line;
  unsigned long frame;
#endif //DEBUG_FEC
} NFECPacket;

/* typedef'd as NFECBundle above */
struct nfec_bundle_str {
    NFECPacket packets[16];
    int nBitErrors;     /* The number of bits changed by the FEC
                           in this bundle (not counting bits
                           corrected in missing lines). */
    int lineConfAvg;    /* Average of all line confidences presented */
};

/* Flushes any remaining data from the FEC state (i.e. unfinished
   bundles).  Calls "cb" with any data returned */

void NFECStateFlush(NFECState *pState, NFECCallback *cb, void *pContext);

/* Garbage collect streams.  If you want to time out bundles,
 * call NFECGarbageCollect() every field.
 */
void NFECGarbageCollect(NFECState *pState, NFECCallback *cb, void *pContext);

#ifdef __cplusplus
} // end - extern "C"
#endif /*__cplusplus*/

#endif /*NABTSAPI_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\nabtsdsp.c ===
/********************************************************/
/* nabtsdsp.c                                           */
/*                                                      */
/* Perform DSP required for NABTS decoding              */
/*                                                      */
/* Copyright Microsoft, Inc. 1997. All rights reserved. */
/********************************************************/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <memory.h>
#include <assert.h>

#ifdef NTOOL
# include <math.h>
# include "winsys.h"
#else //NTOOL
# include <strmini.h>
# include <ksmedia.h>
# include <kskludge.h>
#endif //!NTOOL
#include "host.h"

#include "nabtsapi.h"
#include "nabtsprv.h"
#include "nabtsdsp.h"

#pragma warning(disable:4244 4305)

inline int fltCmp(Double a, Double b)  { return (a == b); }

#define NDSP_STATE_MAGIC 0x648a0a59


/***************/
/*** Globals ***/
/***************/

/* Have the global GCR signals been initialized?
   0 if no, 1 if yes.
   See NDSPInitGlobals */

int g_bNDSPGlobalsInitted= 0;


/* How many fields to check during retrain operation */

int g_nNabtsRetrainDuration= 16; /* in fields */


/* How many fields between automatic retrains.
   (Note that immediate retrain can be caused also by
   NDSPStartRetrain) */

int g_nNabtsRetrainDelay= 600;   /* in fields */


/* How many "far ghost" equalization taps should we add?
   Note that this only occurs when we are using the GCR for
   equalization/ghost cancellation.  The NABTS sync is not long
   enough to be able to detect and cancel far ghosts. */

int g_nNabtsAdditionalTapsGCR= 2;   /* # of additional taps to add while equalizing */


/* The following is extraneous and should be removed at earliest
   convenience: */

Double g_dGCRDetectionThreshold= 100000.0; /* extraneous */


/* Minimum and maximum limits to the sample # at which the first NABTS
   sync sample occurs.
   
   These are used by NDSPDecodeFindSync.

   Be careful changing these numbers, as you want to make sure that
   there are enough samples left at the beginning and end of the lines
   to do adequate filtering.
   
   As of the time of writing these comments, the range is 20 to 85.
   This means that VBI signal should be adjusted such that the
   GCR begins roughly at (20+85)/2, or around sample 52.

   To verify adjustment of the VBI signal, enable the
   "Sync found at %d with conv ..." debugging line in NDSPDecodeLine
   and plot a histogram of the found sync positions.

   Maladjustment of the VBI signal probably means incorrect values in the
   VBIINFOHEADER structure passed with the signal.

   */

/* replace these w/ time-based values... */   
//int g_nNabtsDecodeBeginMin= 20;
/* BeginMax should be less than 
   DecodeSamples - (36*8*5) - 10 */
//int g_nNabtsDecodeBeginMax= 85;
int g_nNabtsDecodeBeginStart;
int g_nNabtsDecodeBeginEnd;

/* What's the longest post-ghost which we can correct without requiring
   samples we don't have? */

int g_nNabtsMaxPostGhost= 170; /* in samples */

/* What's the longest pre-ghost which we can correct without requiring
   samples we don't have? */

int g_nNabtsMaxPreGhost= 40; /* in samples */


/* This is the default filter used for signals if both GCR-based and
   NABTS sync-based equalization/ghost cancellation algorithms fail */
   
FIRFilter g_filterDefault5= {
   FALSE, /* bVariableTaps */
   5, /* nTaps */
   5, /* dTapSpacing */
   0, /* nMinTap */
   0, /* nMaxTap */
   { 0.0549969,
     -0.115282,
     0.946446,
     -0.260854,
     0.0476174},  /* pdTaps */
   //{}             /* pnTapLocs */
};

FIRFilter g_filterDefault47 = {
   FALSE,				/* bVariableTaps */
   5,					/* nTaps */
   KS_47NABTS_SCALER,	/* dTapSpacing */		//FIXME (maybe)
   0,					/* nMinTap */
   0,					/* nMaxTap */
   { 0.0549969,
     -0.115282,
     0.946446,
     -0.260854,
     0.0476174},		/* pdTaps */
   //{}					/* pnTapLocs */
};

FIRFilter g_filterDefault4= {
   FALSE, /* bVariableTaps */
   5, /* nTaps */
   4, /* dTapSpacing */
   0, /* nMinTap */
   0, /* nMaxTap */
   { 0.0549969,
     -0.115282,
     0.946446,
     -0.260854,
     0.0476174},  /* pdTaps */
   //{}             /* pnTapLocs */
};

FIRFilter* g_filterDefault = &g_filterDefault5;


/* If DEBUG_VERBOSE, do we show information about NABTS sync? */

int g_bDebugSyncBytes= FALSE;


/* This is a set of samples representing a typical NABTS sync taken at
   NABTS bit rate * 5.

   It is used for NABTS sync equalization, which is a fallback from the
   GCR equalization/ghost cancellation
   */
   
Double g_pdSync5[NABSYNC_SIZE]={
   72.7816,
   98.7424,
   128.392,
   152.351,
   161.749,
   153.177,
   127.707,
   94.7642,
   67.3989,
   57.3863,
   68.85,
   97.1427,
   131.288,
   156.581,
   164.365,
   151.438,
   123.222,
   90.791,
   66.191,
   57.8995,
   70.1041,
   98.0289,
   129.88,
   154.471,
   161.947,
   149.796,
   123.056,
   90.4673,
   64.7314,
   55.3073,
   67.6522,
   96.0781,
   129.079,
   154.704,
   162.274,
   148.879,
   120.957,
   88.971,
   64.2987,
   57.3871,
   69.9341,
   97.2937,
   130.365,
   154.517,
   161.46,
   149.066,
   122.341,
   89.6801,
   64.8201,
   56.3087,
   67.9328,
   95.4871,
   127.708,
   152.344,
   160.203,
   147.785,
   120.972,
   89.2391,
   64.8204,
   55.4777,
   67.4764,
   95.4465,
   128.277,
   153.469,
   161.047,
   149.581,
   123.23,
   90.3241,
   65.0892,
   57.5301,
   69.3996,
   97.4484,
   130.064,
   154.063,
   161.211,
   147.833,
   119.759,
   89.3406,
   67.3504,
   60.1918,
   70.7763,
   93.4328,
   120.709,
   145.109,
   160.585,
   166.873,
   166.863,
   163.397,
   159.525,
   158.707,
   160.963,
   165.351,
   167.585,
   165.082,
   154.448,
   135.721,
   112.454,
   88.9855,
   68.8211,
   55.3262,
   47.8155,
   45.8446,
   47.352,
   51.1301,
   59.5515,
   74.6295,
   96.5327,
   121.793,
   144.703,
   160.891,
   167.617,
   164.946,
   159.698,
   156.271,
   157.871
};

Double g_pdSync47[NABSYNC_SIZE] = {
    72.7816,
    96.9455,
    125.488,
    150.642,
    163.827,
    160.895,
    139.686,
    106.374,
    72.2535,
    51.1334,
    51.7029,
    74.3792,
    112.893,
    150.448,
    175.333,
    177.089,
    154.67,
    66.4422,
    56.79,
    65.8731,
    91.2727,
    123.173,
    151.979,
    166.734,
    161.95,
    139.844,
    105.285,
    70.7285,
    46.7033,
    46.1175,
    69.0775,
    106.56,
    147.593,
    175.669,
    122.895,
    91.9615,
    65.5553,
    54.3455,
    61.6435,
    85.2679,
    120.119,
    151.151,
    168.22,
    165.263,
    144.115,
    107.76,
    71.526,
    46.4459,
    42.8836,
    64.2428,
    152.106,
    161.332,
    151.847,
    127.703,
    95.8986,
    67.9346,
    50.751,
    54.7629,
    78.5341,
    113.773,
    148.647,
    169.038,
    169.544,
    150.153,
    112.5,
    72.1901,
    45.6607,
    95.472,
    127.155,
    152.763,
    164.454,
    156.34,
    130.82,
    98.6696,
    70.8212,
    54.4185,
    57.0453,
    75.2489,
    102.964,
    132.916,
    155.25,
    166.882,
    170.224,
    159.55,
    158.502,
    160.298,
    164.877,
    168.268,
    168.627,
    161.825,
    146.297,
    124.544,
    100.595,
    77.4086,
    60.5608,
    49.3086,
    44.6113,
    44.0319,
    43.2192,
    44.4737,
    95.0021,
    119.016,
    141.76,
    159.261,
    168.426,
    166.854,
    161.152,
    155.495,
};

Double g_pdSync4[NABSYNC_SIZE] = {
  -39.1488,
  -12.0978,
  33.5648,
  46.2761,
  39.4813,
  9.29926,
  -35.5121,
  -54.1576,
  -43.0804,
  -8.89138,
  34.4705,
  51.1527,
  37.7423,
  3.70292,
  -37.0844,
  -54.5635,
  -41.8263,
  -8.01077,
  31.8198,
  49.2458,
  36.1003,
  3.28592,
  -37.4172,
  -57.2909,
  -44.2782,
  -9.47973,
  31.2838,
  49.8912,
  35.1833,
  1.00765,
  -38.2074,
  -56.0426,
  -41.9963,
  -8.0181,
  31.6699,
  49.2505,
  35.3703,
  2.16505,
  -37.3994,
  -56.7359,
  -43.9976,
  -9.86633,
  28.8379,
  47.9894,
  34.0893,
  0.793831,
  -37.1945,
  -57.5387,
  -44.454,
  -9.71416,
  29.6742,
  48.954,
  35.8853,
  2.77469,
  -36.6699,
  -56.0604,
  -42.5308,
  -7.411,
  30.524,
  49.4549,
  34.1373,
  -0.682732,
  -35.4269,
  -53.5466,
  -41.1541,
  -12.8922,
  20.253,
  45.9943,
  53.1773,
  53.4395,
  49.3341,
  44.4674,
  49.0326,
  53.631,
  53.0627,
  46.721,
  22.0253,
  -6.8225,
  -32.9031,
  -56.6665,
  -64.1149,
  -65.8565,
  -66.4073,
  -53.3933,
  -39.0662,
  -11.9141,
  25.1485,
  40.7185,
  55.6866,
  56.0335,
  31.9488,
  64.5845,
  -112.813
};
int g_nNabtsSyncSize = NABSYNC_SIZE;
Double g_pdSync[MAX_NABTS_SAMPLES_PER_LINE]; /* used for resampling */

/* This is a set of samples representing a typical GCR waveform taken
   at NABTS bit rate * 2.5.

   It is used for GCR-based equalization and ghost cancellation, which
   is the primary and most desirable strategy
   */
   
Double g_pdGCRSignal1_5[GCR_SIZE]={
0.00000000000000E+0000, 1.02260999999970E-0003, 1.05892999999924E-0003,
1.09718000000036E-0003, 1.13701999999982E-0003, 1.17906999999917E-0003,
1.22286999999943E-0003, 1.26910000000002E-0003, 1.31748000000087E-0003,
1.36846999999918E-0003, 1.42190000000042E-0003, 1.47821000000015E-0003,
1.53740000000013E-0003, 1.59988999999960E-0003, 1.66547000000072E-0003,
1.73485999999912E-0003, 1.80787000000038E-0003, 1.88510000000086E-0003,
1.96657000000044E-0003, 2.05283000000023E-0003, 2.14390000000009E-0003,
2.24045999999944E-0003, 2.34250000000102E-0003, 2.45085999999972E-0003,
2.56557000000157E-0003, 2.68752999999933E-0003, 2.81685999999937E-0003,
2.95447999999965E-0003, 3.10071999999906E-0003, 3.25656000000052E-0003,
3.42231000000126E-0003, 3.59925000000061E-0003, 3.78781999999944E-0003,
3.98931000000147E-0003, 4.20439999999900E-0003, 4.43461999999784E-0003,
4.68077000000022E-0003, 4.94463999999795E-0003, 5.22724000000352E-0003,
5.53064000000347E-0003, 5.85610000000258E-0003, 6.20609999999999E-0003,
6.58219999999687E-0003, 6.98715000000050E-0003, 7.42307000000153E-0003,
7.89319000000432E-0003, 8.40024000000028E-0003, 8.94780000000139E-0003,
9.53912999999318E-0003, 1.01788000000056E-0002, 1.08706000000041E-0002,
1.16199999999935E-0002, 1.24318000000017E-0002, 1.33122999999955E-0002,
1.42673999999943E-0002, 1.53047000000015E-0002, 1.64313999999877E-0002,
1.76562000000047E-0002, 1.89881000000014E-0002, 2.04373999999916E-0002,
2.20148999999878E-0002, 2.37329999999929E-0002, 2.56043999999918E-0002,
2.76438999999868E-0002, 2.98664999999971E-0002, 3.22896999999784E-0002,
3.49309999999718E-0002, 3.78107999999884E-0002, 4.09500000000094E-0002,
4.43718999999874E-0002, 4.81004000000098E-0002, 5.21621999999979E-0002,
5.65846999999735E-0002, 6.13976000000207E-0002, 6.66313000000400E-0002,
7.23186999999825E-0002, 7.84923999999592E-0002, 8.51879000000508E-0002,
9.24387000000024E-0002, 1.00280999999995E-0001, 1.08748999999989E-0001,
1.17876000000024E-0001, 1.27694000000020E-0001, 1.38230999999905E-0001,
1.49511000000075E-0001, 1.61552999999913E-0001, 1.74367999999959E-0001,
1.87959000000092E-0001, 2.02316999999994E-0001, 2.17419999999947E-0001,
2.33228000000054E-0001, 2.49684999999999E-0001, 2.66712000000098E-0001,
2.84204999999929E-0001, 3.02032999999938E-0001, 3.20032000000083E-0001,
3.38005000000067E-0001, 3.55717999999797E-0001, 3.72897000000194E-0001,
3.89230000000225E-0001, 4.04360999999881E-0001, 4.17892999999822E-0001,
4.29389999999785E-0001, 4.38381999999820E-0001, 4.44367000000057E-0001,
4.46823000000222E-0001, 4.45215000000189E-0001, 4.39011999999821E-0001,
4.27705000000060E-0001, 4.10821999999825E-0001, 3.87955000000147E-0001,
3.58785999999782E-0001, 3.23113999999805E-0001, 2.80886000000010E-0001,
2.32228000000077E-0001, 1.77474000000075E-0001, 1.17197000000033E-0001,
5.22252000000094E-0002, -1.63339000000065E-0002, -8.70900999999549E-0002,
-1.58376000000089E-0001, -2.28262000000086E-0001, -2.94597000000067E-0001,
-3.55059999999867E-0001, -4.07236000000012E-0001, -4.48710000000119E-0001,
-4.77181000000201E-0001, -4.90596000000096E-0001, -4.87282999999934E-0001,
-4.66113999999834E-0001, -4.26633000000038E-0001, -3.69197999999869E-0001,
-2.95083999999861E-0001, -2.06552999999985E-0001, -1.06861999999978E-0001,
-2.26569000000065E-0004, 1.08304999999973E-0001, 2.13048999999955E-0001,
3.07967000000190E-0001, 3.87016000000131E-0001, 4.44562000000133E-0001,
4.75829999999860E-0001, 4.77361000000201E-0001, 4.47440999999799E-0001,
3.86449999999968E-0001, 2.97098000000005E-0001, 1.84488000000101E-0001,
5.59898000000203E-0002, -7.91186000000152E-0002, -2.10235999999895E-0001,
-3.26232999999775E-0001, -4.16419000000133E-0001, -4.71591999999873E-0001,
-4.85105000000203E-0001, -4.53794000000016E-0001, -3.78679999999804E-0001,
-2.65297999999802E-0001, -1.23576999999955E-0001, 3.28038999999762E-0002,
1.87584000000015E-0001, 3.23534999999993E-0001, 4.24414000000070E-0001,
4.77027999999791E-0001, 4.73159000000123E-0001, 4.11086000000068E-0001,
2.96408000000156E-0001, 1.41969000000017E-0001, -3.32369999999855E-0002,
-2.06171999999924E-0001, -3.52687000000060E-0001, -4.50949999999921E-0001,
-4.84910000000127E-0001, -4.47235999999975E-0001, -3.41190000000097E-0001,
-1.80984000000080E-0001, 9.63199000000259E-0003, 2.00563999999986E-0001,
3.59968000000208E-0001, 4.59641999999803E-0001, 4.80308000000150E-0001,
4.15771999999833E-0001, 2.75076999999783E-0001, 8.19416000000501E-0002,
-1.28693999999996E-0001, -3.16683999999896E-0001, -4.44307000000208E-0001,
-4.84112000000096E-0001, -4.25353000000086E-0001, -2.77427999999873E-0001,
-6.92708000000266E-0002, 1.55655000000024E-0001, 3.48071999999775E-0001,
4.63710999999876E-0001, 4.73907999999938E-0001, 3.73398000000179E-0001,
1.83113999999932E-0001, -5.32258000000070E-0002, -2.78533000000152E-0001,
-4.35938999999962E-0001, -4.83456999999817E-0001, -4.05898999999863E-0001,
-2.20585999999912E-0001, 2.53643000000068E-0002, 2.66195000000153E-0001,
4.34799999999996E-0001, 4.81733999999960E-0001, 3.90551999999843E-0001,
1.84567999999899E-0001, -7.78073999999833E-0002, -3.18760000000111E-0001,
-4.63948000000073E-0001, -4.65948999999910E-0001, -3.20834999999988E-0001,
-7.18414000000394E-0002, 2.02201999999943E-0001, 4.11149000000023E-0001,
4.83345000000099E-0001, 3.91160000000127E-0001, 1.62923000000092E-0001,
-1.24134000000026E-0001, -3.68950000000041E-0001, -4.82100000000173E-0001,
-4.19299000000137E-0001, -2.00237999999899E-0001, 9.56523999999490E-0002,
3.56715999999778E-0001, 4.80940999999802E-0001, 4.16690999999901E-0001,
1.85821000000033E-0001, -1.21634999999969E-0001, -3.81190000000061E-0001,
-4.84109999999873E-0001, -3.84040999999797E-0001, -1.19752999999946E-0001,
1.97697999999946E-0001, 4.30369000000155E-0001, 4.73501999999826E-0001,
3.04200000000037E-0001, -4.45780999999812E-0003, -3.12843000000157E-0001,
-4.77105999999822E-0001, -4.17065000000093E-0001, -1.57408999999916E-0001,
1.79722999999967E-0001, 4.30503999999928E-0001, 4.69046000000162E-0001,
2.72319000000152E-0001, -6.37966000000461E-0002, -3.68903000000046E-0001,
-4.83776999999918E-0001, -3.44759999999951E-0001, -2.16183999999942E-0002,
3.14663999999993E-0001, 4.81103000000076E-0001, 3.83209000000079E-0001,
7.12525999999798E-0002, -2.82396000000062E-0001, -4.76846999999907E-0001,
-3.97513999999774E-0001, -8.63047999999935E-0002, 2.77078999999958E-0001,
4.77041000000099E-0001, 3.90680999999859E-0001, 6.61678999999822E-0002,
-3.00528000000213E-0001, -4.82100000000173E-0001, -3.61706000000140E-0001,
-1.12785000000031E-0002, 3.47796000000017E-0001, 4.82912999999826E-0001,
3.02329000000100E-0001, -7.90537999999970E-0002, -4.09227999999985E-0001,
-4.64552999999796E-0001, -2.03408999999965E-0001, 1.98789999999917E-0001,
4.64230000000043E-0001, 4.04536999999891E-0001, 5.75837999999749E-0002,
-3.32002000000102E-0001, -4.82986999999866E-0001, -2.81882000000223E-0001,
1.27741000000015E-0001, 4.43717999999990E-0001, 4.27357000000029E-0001,
8.67075999999543E-0002, -3.21608000000197E-0001, -4.82884000000013E-0001,
-2.68137000000024E-0001, 1.58376000000089E-0001, 4.60480000000189E-0001,
3.94394999999804E-0001, 8.97358999999653E-0003, -3.85126000000128E-0001,
-4.63401999999860E-0001, -1.56926999999996E-0001, 2.82047000000148E-0001,
4.83843999999863E-0001, 2.73432999999841E-0001, -1.73019000000068E-0001,
-4.70732000000226E-0001, -3.57265000000098E-0001, 7.19904999999699E-0002,
4.38375000000178E-0001, 4.12060999999994E-0001, 1.23822000000047E-0002,
-3.99836000000050E-0001, -4.45055000000139E-0001, -7.71581999999853E-0002,
3.63976000000093E-0001, 4.62701999999808E-0001, 1.21280999999954E-0001,
-3.37500999999975E-0001, -4.71152000000075E-0001, -1.45841000000019E-0001,
3.23628000000099E-0001, 4.73699000000124E-0001, 1.51135999999951E-0001,
-3.24419000000034E-0001, -4.72220000000107E-0001, -1.37774000000036E-0001,
3.39390999999978E-0001, 4.65411000000131E-0001, 1.04878999999983E-0001,
-3.67131999999856E-0001, -4.50452000000041E-0001, -5.20331000000169E-0002,
4.03378999999859E-0001, 4.21691999999894E-0001, -2.14152000000070E-0002,
-4.41976000000068E-0001, -3.72757999999976E-0001, 1.13511000000017E-0001,
4.72905000000083E-0001, 2.96350999999959E-0001, -2.19368000000031E-0001,
-4.83674999999948E-0001, -1.87777999999980E-0001, 3.27948999999990E-0001,
4.59028000000217E-0001, 4.67350000000124E-0002, -4.22157999999854E-0001,
-3.85088999999880E-0001, 1.17635999999948E-0001, 4.78071999999884E-0001,
2.53111999999874E-0001, -2.84720999999990E-0001, -4.69815999999810E-0001,
-6.75424999999450E-0002, 4.20501000000058E-0001, 3.76236999999946E-0001,
-1.48369000000002E-0001, -4.83322999999928E-0001, -1.93813000000091E-0001,
3.48465000000033E-0001, 4.35011999999915E-0001, -5.20594999999844E-0002,
-4.70860999999786E-0001, -2.61331000000155E-0001, 2.99838999999793E-0001,
4.56122000000050E-0001, -8.47457000000418E-0003, -4.62175000000116E-0001,
-2.79306999999790E-0001, 2.91294999999991E-0001, 4.55973999999969E-0001,
-1.96689999999933E-0002, -4.68189000000166E-0001, -2.51569000000018E-0001,
3.25217999999950E-0001, 4.34597999999824E-0001, -8.52701999999681E-0002,
-4.81628999999884E-0001, -1.72663999999941E-0001, 3.91235999999935E-0001,
3.75564999999824E-0001, -2.00489999999945E-0001, -4.76438000000144E-0001,
-3.35570999999959E-0002, 4.60794000000078E-0001, 2.51975000000130E-0001,
-3.44184000000041E-0001, -4.09337999999934E-0001, 1.61409999999933E-0001,
4.80509999999867E-0001, 4.47993000000224E-0002, -4.62160999999924E-0001,
-2.35175999999910E-0001, 3.67765999999847E-0001, 3.80204000000049E-0001,
-2.21663999999919E-0001, -4.63874000000033E-0001, 5.13983000000167E-0002,
4.82525999999780E-0001, 1.17171999999982E-0001, -4.42914000000201E-0001,
-2.64184000000114E-0001, 3.57844999999998E-0001, 3.76622000000225E-0001,
-2.43244999999888E-0001, -4.48910999999953E-0001, 1.14519999999970E-0001,
4.81073999999808E-0001, 1.47939000000008E-0002, -4.77703000000020E-0001,
-1.34743000000071E-0001, 4.45565999999872E-0001, 2.38581000000067E-0001,
-3.92727999999806E-0001, -3.23120999999901E-0001, 3.26771999999892E-0001,
3.87517000000116E-0001, -2.54672999999912E-0001, -4.33148000000074E-0001,
1.81812000000036E-0001, 4.62328000000070E-0001, -1.12458999999944E-0001,
-4.78289000000132E-0001, 4.92869999999925E-0002, 4.84148000000005E-0001,
5.86423000000025E-0003, -4.83146999999917E-0001, -5.22940999999832E-0002,
4.77914999999939E-0001, 8.96437999999762E-0002, -4.70905000000130E-0001,
-1.18200000000002E-0001, 4.63843999999881E-0001, 1.38171000000057E-0001,
-4.58263999999872E-0001, -1.50045999999975E-0001, 4.55015999999887E-0001,
1.53954999999996E-0001, -4.54807999999957E-0001, -1.50088000000096E-0001,
4.57700999999815E-0001, 1.38134999999920E-0001, -4.63569999999891E-0001,
-1.17764999999963E-0001, 4.71551999999974E-0001, 8.81894999999986E-0002,
-4.80403000000024E-0001, -4.87550000000283E-0002, 4.87923000000137E-0001,
-1.28841999999985E-0003, -4.91308000000117E-0001, 6.19993000000250E-0002,
4.86694000000170E-0001, -1.32732999999917E-0001, -4.69751999999971E-0001,
2.11195000000089E-0001, 4.35657999999876E-0001, -2.93380999999954E-0001,
-3.80208000000039E-0001, 3.72847999999976E-0001, 3.00403000000188E-0001,
-4.41198999999870E-0001, -1.96052999999893E-0001, 4.88281999999799E-0001,
7.05491999999595E-0002, -5.03888000000188E-0001, 6.79192000000057E-0002,
4.79287999999997E-0001, -2.06691999999975E-0001, -4.09948999999870E-0001,
3.29295000000002E-0001, 2.97392999999829E-0001, -4.18125000000146E-0001,
-1.51035000000093E-0001, 4.57456999999977E-0001, -1.21829999999932E-0002,
-4.37680000000000E-0001, 1.69366000000082E-0001, 3.58297000000221E-0001,
-2.95907000000170E-0001, -2.30043000000023E-0001, 3.70323999999982E-0001,
7.37844000000223E-0002, -3.79878000000190E-0001, 8.26819999999771E-0002,
3.24047000000064E-0001, -2.10759999999937E-0001, -2.15877000000091E-0001,
2.87343999999848E-0001, 7.92186999999558E-0002, -3.00759000000198E-0001,
5.63948000000210E-0002, 2.53298000000086E-0001, -1.63127999999915E-0001,
-1.60753000000113E-0001, 2.21193999999969E-0001, 4.78082000000200E-0002,
-2.23539999999957E-0001, 5.81391000000053E-0002, 1.76492000000053E-0001,
-1.34119999999939E-0001, -9.74677000000383E-0002, 1.66602999999895E-0001,
9.46428999999682E-0003, -1.54275999999982E-0001, 6.49469999999610E-0002,
1.06955999999968E-0001, -1.09595000000013E-0001, -4.21787000000222E-0002,
1.18017000000009E-0001, -2.05329000000063E-0002, -9.43591999999853E-0002,
6.49757999999565E-0002, 5.07000999999718E-0002, -8.26296000000184E-0002,
-2.79875000000018E-0003, 7.37881000000016E-0002, -3.52417999999943E-0002,
-4.63371999999822E-0002, 5.46148000000244E-0002, 1.19423999999952E-0002,
-5.37128000000280E-0002, 1.78473999999937E-0002, 3.70907000000216E-0002,
-3.52100999999720E-0002, -1.32136000000003E-0002, 3.75063999999838E-0002,
-8.99504000000206E-0003, -2.73909000000003E-0002, 2.27873000000045E-0002,
1.08742000000035E-0002, -2.56093000000135E-0002, 5.03203000000241E-0003,
1.90342999999871E-0002, -1.51086999999990E-0002, -7.63514999999870E-0003,
1.72402000000034E-0002, -3.46168000000091E-0003, -1.26917999999989E-0002,
1.03507000000036E-0002, 4.70225000000113E-0003, -1.16266999999937E-0002,
2.92620999999826E-0003, 8.12958999999580E-0003, -7.45025999999882E-0003,
-2.37827999999851E-0003, 7.79329000000217E-0003, -2.83968999999828E-0003,
-4.85918999999768E-0003, 5.45333000000170E-0003, 6.50574999999876E-0004,
-5.05228000000102E-0003, 2.66608000000090E-0003, 2.55376999999868E-0003,
-3.93425000000036E-0003, 3.76394999999974E-0004, 3.09312999999989E-0003,
-2.39051000000146E-0003, -1.06363999999992E-0003, 2.75651000000110E-0003,
-9.89122000000009E-0004, -1.69909999999973E-0003, 2.01841000000158E-0003,
2.12075999999894E-0005, -1.75568000000048E-0003, 1.21378999999955E-0003,
6.16308999999760E-0004, -1.49133999999940E-0003, 5.30142999999761E-0004,
8.80323999999710E-0004, -1.11185999999996E-0003, 0.00000000000000E+0000
};

Double g_pdGCRSignal1_47[GCR_SIZE] = { 0.0,		//TODO - Fix this if we re-enable GCR usage
};

Double g_pdGCRSignal1_4[GCR_SIZE] = {
  -0.00347677,   -0.00322337,   -0.00325605, 
  -0.00322112,   -0.00321719,   -0.00320921, 
  -0.00318706,   -0.0031813,   -0.00316357, 
  -0.0031458,   -0.0031343,   -0.00311177, 
  -0.00309477,   -0.00307598,   -0.00305072, 
  -0.00303091,   -0.00300454,   -0.00297671, 
  -0.00295068,   -0.00291709,   -0.00288493, 
  -0.00284988,   -0.00280893,   -0.00276923, 
  -0.00272296,   -0.00267316,   -0.00262177, 
  -0.00256212,   -0.00250011,   -0.00243231, 
  -0.00235619,   -0.00227647,   -0.00218688, 
  -0.00208914,   -0.00198407,   -0.00186586, 
  -0.00173831,   -0.00159776,   -0.00144136, 
  -0.00127163,   -0.00108236,   -0.000873557, 
  -0.000644226,   -0.000387946,   -0.000105821, 
  0.00020736,   0.000556413,   0.000941966, 
  0.00137233,   0.00185082,   0.00238212, 
  0.00297575,   0.00363537,   0.00437036, 
  0.00519034,   0.00610175,   0.00711803, 
  0.00824878,   0.00950516,   0.0109028, 
  0.0124523,   0.0141696,   0.0160703, 
  0.0181666,   0.0204768,   0.0230134, 
  0.0257895,   0.0288187,   0.0321075, 
  0.0356624,   0.0394846,   0.0435661, 
  0.047895,   0.0524468,   0.0571852, 
  0.0620638,   0.0670147,   0.0719563, 
  0.0767863,   0.0813785,   0.0855895, 
  0.0892493,   0.0921681,   0.0941404, 
  0.0949423,   0.0943457,   0.0921242, 
  0.0880623,   0.0819759,   0.0737222, 
  0.0632224,   0.050484,   0.0356143, 
  0.018848,   0.000557361,   -0.0187374, 
  -0.0383613,   -0.0575002,   -0.07522, 
  -0.0905034,   -0.102312,   -0.109649, 
  -0.111652,   -0.107688,   -0.0974488, 
  -0.0810454,   -0.0590807,   -0.0326872, 
  -0.00352681,   0.026276,   0.0542588, 
  0.0778138,   0.0944444,   0.102052, 
  0.0992456,   0.0856211,   0.0619632, 
  0.0303378,   -0.0059827,   -0.0427809, 
  -0.0753343,   -0.0990286,   -0.110051, 
  -0.106085,   -0.0868866,   -0.0545886, 
  -0.013663,   0.0295587,   0.0677864, 
  0.0939929,   0.102784,   0.0916517, 
  0.0618112,   0.0183872,   -0.030241, 
  -0.0739181,   -0.102805,   -0.109703, 
  -0.0920499,   -0.0530257,   -0.00135532, 
  0.0503947,   0.0887573,   0.102941, 
  0.088103,   0.0472938,   -0.00868865, 
  -0.0638268,   -0.101342,   -0.108907, 
  -0.0830246,   -0.0309566,   0.0308085, 
  0.081466,   0.102895,   0.0864348, 
  0.0368566,   -0.0283508,   -0.0847231, 
  -0.10992,   -0.0928818,   -0.0392512, 
  0.0297409,   0.0852003,   0.102632, 
  0.0731864,   0.00880831,   -0.0618224, 
  -0.105668,   -0.100953,   -0.0486301, 
  0.0265581,   0.0870846,   0.101275, 
  0.060433,   -0.0149953,   -0.0847433, 
  -0.109925,   -0.0751765,   0.00101709, 
  0.0750949,   0.102915,   0.0665191, 
  -0.0132255,   -0.0874393,   -0.108785, 
  -0.062238,   0.0231743,   0.091318, 
  0.0955987,   0.0316556,   -0.0572763, 
  -0.108566,   -0.0844189,   -0.000913411, 
  0.0811435,   0.0998372,   0.0395636, 
  -0.0544801,   -0.108895,   -0.0794151, 
  0.0117194,   0.0908163,   0.0917383, 
  0.0122175,   -0.0811607,   -0.107599, 
  -0.0426033,   0.0575538,   0.103033, 
  0.0512332,   -0.051541,   -0.109666, 
  -0.0670796,   0.0369271,   0.101949, 
  0.0631155,   -0.0424742,   -0.109048, 
  -0.0677645,   0.0403094,   0.102837, 
  0.0527074,   -0.057985,   -0.109862, 
  -0.0449822,   0.0662633,   0.0994283, 
  0.0156217,   -0.0904555,   -0.0957237, 
  0.00746482,   0.0979505,   0.0667789, 
  -0.0498718,   -0.109913,   -0.0380423, 
  0.0773721,   0.090618,   -0.0166247, 
  -0.107162,   -0.0624203,   0.0602526, 
  0.0982112,   -0.000749544,   -0.103676, 
  -0.0691827,   0.0565363,   0.09844, 
  -0.00374564,   -0.105781,   -0.0605572, 
  0.0678068,   0.0916978,   -0.0254848, 
  -0.109974,   -0.0338235,   0.0886854, 
  0.0696882,   -0.0628569,   -0.102695, 
  0.0140484,   0.103037,   0.0210051, 
  -0.100828,   -0.0637215,   0.072721, 
  0.0826481,   -0.0517958,   -0.104731, 
  0.014821,   0.103036,   0.00681728, 
  -0.107478,   -0.0388149,   0.0925919, 
  0.0522746,   -0.0885787,   -0.0749478, 
  0.0695205,   0.0793948,   -0.0647939, 
  -0.0942172,   0.047579,   0.0923407, 
  -0.0464317,   -0.102366,   0.033887, 
  0.0969906,   -0.0380317,   -0.104437, 
  0.031087,   0.0969579,   -0.040917, 
  -0.102302,   0.0395639,   0.0922497, 
  -0.0546754,   -0.0940965,   0.0579833, 
  0.0792467,   -0.0766651,   -0.074754, 
  0.0818012,   0.0520243,   -0.0997399, 
  -0.0384754,   0.100644,   0.00639079, 
  -0.110028,   0.0153267,   0.0976144, 
  -0.0523014,   -0.0892546,   0.0731407, 
  0.0561963,   -0.101035,   -0.0273019, 
  0.10298,   -0.0216741,   -0.102356, 
  0.0564077,   0.0691551,   -0.0959579, 
  -0.033156,   0.103057,   -0.0261942, 
  -0.0984214,   0.0684994,   0.0529683, 
  -0.106231,   -0.00223094,   0.0983575, 
  -0.0646024,   -0.0682985,   0.097313, 
  -0.00218509,   -0.104729,   0.0614701, 
  0.0539863,   -0.1072,   0.0111803, 
  0.0893852,   -0.084751,   -0.0365265, 
  0.102008,   -0.0503339,   -0.0726031, 
  0.0973383,   -0.0146527,   -0.0952283, 
  0.0831772,   0.0159482,   -0.106912, 
  0.0664624,   0.0389454,   -0.111695, 
  0.0521044,   0.0540878,   -0.113279, 
  0.043042,   0.0618967,   -0.114071, 
  0.0406873,   0.0626912,   -0.114795, 
  0.0452189,   0.0562661,   -0.114465, 
  0.0555428,   0.0422166,   -0.110703, 
  0.069055,   0.0207763,   -0.100524, 
  0.0816043,   -0.00616025,   -0.0816649, 
  0.0881263,   -0.0344248,   -0.0541472, 
  0.0841699,   -0.0580354,   -0.0212963, 
  0.0678992,   -0.0709826,   0.0106367, 
  0.0415202,   -0.0697234,   0.0345279, 
  0.0110249,   -0.0550094,   0.0452444, 
  -0.0159388,   -0.0318536,   0.0417614, 
  -0.0330188,   -0.00759705,   0.0274425, 
  -0.0374128,   0.0108287,   0.0085779, 
  -0.0305831,   0.0192502,   -0.00799957, 
  -0.0174139,   0.0175002,   -0.0174261, 
  -0.00409323,   0.00907835,   -0.0184854, 
  0.0045466,   -0.000846416,   -0.0134708, 
  0.00677922,   -0.00796784,   -0.00638725, 
  0.00390153,   -0.0103627,   -0.0008869, 
  -0.0010817,   -0.00865121,   0.00113132, 
  -0.00511521,   -0.00515852,   1.14208e-05, 
  -0.00659004,   -0.00231654,   -0.00244116, 
  -0.00577361,   -0.00133297,   -0.00441284, 
  -0.00400062,   -0.00202788,   -0.00497207, 
  -0.00267527,   -0.0033336,   -0.00432329, 
  -0.00246436,   -0.00415329,   -0.00339386, 
  -0.00304039,   -0.00414497,   -0.00292314, 
  -0.00369477,   -0.00363559,   -0.00308028, 
  -0.00390425,   -0.00320941,   -0.00350326, 
  -0.00366609,   -0.00319138,   -0.0037218, 
  -0.00347683
};

Double g_pdGCRSignal1[MAX_NABTS_SAMPLES_PER_LINE]; /* used for resampling */
int g_nNabtsGcrSize = GCR_SIZE;

/* This array is filled with the inverted GCR waveform. (in FillGCRSignals()) */
Double g_pdGCRSignal2[MAX_NABTS_SAMPLES_PER_LINE];


/* The EqualizeMatch structures for positive GCR, negative GCR, and
   NABTS sync.

   Each structure contains the appropriate waveform for matching, its size,
   its sample rate (actually, individual sample period in units of the
   5*NABTS bit rate), and the minimum and maximum samples among which the
   signal may be matched in the VBI samples.

   */

EqualizeMatch eqmatchGCR1 = {
   GCR_SIZE,
   GCR_SAMPLE_RATE,
   GCR_START_DETECT,
   GCR_END_DETECT,
   g_pdGCRSignal1
};

EqualizeMatch eqmatchGCR2 = {
 GCR_SIZE,
   GCR_SAMPLE_RATE,
   GCR_START_DETECT,
   GCR_END_DETECT,
   g_pdGCRSignal2
};

EqualizeMatch eqmatchNabtsSync = {
   NABSYNC_SIZE,        /* changes */
   NABSYNC_SAMPLE_RATE,     /* doesn't change */
   NABSYNC_START_DETECT,    /* changes */
   NABSYNC_END_DETECT,      /* changes */
   g_pdSync5            /* changes */
};


int pnGCRPositiveIndices0[]= {
   192, 194, 196, 198, 200,
   202, 204, 206, 208, 210,
   212, 214, 216, 218, 220,
   222, 278, 280, 282, 284,
   286, 288, 322, 324, 326,
   328
};

/* Some sample locations at which a "positive" GCR signal should be
   quite negative */

int pnGCRNegativeIndices0[]= {
   246, 248, 250, 252, 254,
   256, 258, 260, 262, 302,
   304, 306, 308, 310, 338,
   340, 342, 344, 346
};

int pnGCRPositiveIndices[26];
int pnGCRNegativeIndices[19];

/*******************/
/*** End Globals ***/
/*******************/

/*************************************/
/*** Begin inline helper functions ***/
/*************************************/

/* Inline helper functions for computing min, max, absolute value */

inline Double dmin(Double x, Double y) { return x<y?x:y; }
inline Double dmin3(Double x, Double y, Double z) { return dmin(x,dmin(y,z)); }
inline int imin(int x, int y) { return x<y?x:y; }
inline int imin3(int x, int y, int z) { return imin(x,imin(y,z)); }

inline Double dmax(Double x, Double y) { return x>y?x:y; }
inline Double dmax3(Double x, Double y, Double z) { return dmax(x,dmax(y,z)); }
inline int imax(int x, int y) { return x>y?x:y; }
inline int imax3(int x, int y, int z) { return imax(x,imax(y,z)); }
inline int iabs(int x) { return x>0?x:-x; }

/* idivceil returns a/b, rouding towards positive infinity */
/* idivfloor returns a/b, rounding towards negative infinity */

/* idivceil and idivfloor are somewhat disgusting because
   C does not specify rounding behavior with division using negative
   numbers (!). */

inline int idivceil(int a, int b)
{
   int sgn= 0;
   if (a<0) { a= (-a); sgn ^= 1; }
   if (b<0) { b= (-b); sgn ^= 1; }
   
   if (!sgn) {
      /* Answer will be positive so round away from zero */
      return (a+b-1)/b;
   } else {
      /* Answer will be negative so round towards zero */
      return -(a/b);
   }
}

inline int idivfloor(int a, int b)
{
   int sgn= 0;
   if (a<0) { a= (-a); sgn ^= 1; }
   if (b<0) { b= (-b); sgn ^= 1; }
   
   if (!sgn) {
      /* Answer will be positive so round towards zero */
      return a/b;
   } else {
      /* Answer will be negative so round away from zero */
      return -((a+b-1)/b);
   }
}

/***********************************/
/*** End inline helper functions ***/
/***********************************/


/* Our own ASSERT macro */

#ifdef DEBUG
// Raises X to the Yth power
static long power(long x, long y)
{
    long    rval;
    long    i;

    rval = x;
    for (i = 2; i <= y; ++i)
        rval *= x;

    return (rval);
}

static char *flPrintf(Double dNum, int nPrec)
{
    static char rbufs[4][50];
    static short rbuf = 0;

    long    lFix, lNum, lFrac;
    char    *rval = rbufs[rbuf++];
    char    *ep;

    lFix = float2long(dNum * power(10, nPrec));
    lNum = lFix / power(10, nPrec);
    lFrac = lFix % power(10, nPrec);
    if (lFrac < 0)
        lFrac = -lFrac;

    sprintf(rval, "%ld.%0*ld", lNum, nPrec, lFrac);
    for (ep = rval; *ep; ++ep) ;
    for ( ; ep > rval && ep[-1] != '.'; --ep) {
        if (*ep == '0')
            *ep = '\0';
    }

    return (rval);
}
#endif //DEBUG


/* Fill the negative GCR signal, and normalize the various
   EqualizeMatch signals */

void NDSPInitGlobals()
{
  if (g_bNDSPGlobalsInitted) return;
  memcpy(g_pdGCRSignal1, g_pdGCRSignal1_5, GCR_SIZE*sizeof(Double));

  FillGCRSignals();

  memcpy(g_pdSync, g_pdSync5, NABSYNC_SIZE*sizeof(Double));
  NormalizeSyncSignal();

  memcpy(pnGCRPositiveIndices, pnGCRPositiveIndices0, 26*sizeof(int));
  memcpy(pnGCRNegativeIndices, pnGCRNegativeIndices0, 19*sizeof(int));

  g_bNDSPGlobalsInitted= 1;
}


int NDSPStateSetSampleRate(NDSPState* pState, unsigned long newRate)
{
  double  newMultiple;
  unsigned long oldRate;

  debug_printf(("NDSPStateSetSampleRate(0x%p, %lu) entered\n", pState, newRate));

  newMultiple = (double)newRate / KS_VBIDATARATE_NABTS; // (28636360 / 5727272.0) = 5.0
  switch (newRate) {
      case KS_VBISAMPLINGRATE_4X_NABTS:     // 4X NABTS
        g_filterDefault = &g_filterDefault4;
        break;
      case KS_VBISAMPLINGRATE_47X_NABTS:     // 4.7X NABTS
        g_filterDefault = &g_filterDefault47;
        break;
      case KS_VBISAMPLINGRATE_5X_NABTS:     // 5X NABTS
        g_filterDefault = &g_filterDefault5;
        break;
      /* ===== add cases here as necessary  ===== */
      default:
        debug_printf(("Unsupported sample rate: %luhz\n", newRate));
        return NDSP_ERROR_UNSUPPORTED_SAMPLING_RATE;
  }

  NDSPStateSetFilter(pState, g_filterDefault, sizeof(*g_filterDefault));
  pState->dSampleRate = newMultiple;
  oldRate = float2long(pState->dSampleFreq);
  pState->dSampleFreq = newRate;

  switch (newRate) {
	case	KS_VBISAMPLINGRATE_4X_NABTS:
		ClearVariableFIRFilter(&pState->filterGCREqualizeTemplate);
		AddToVariableFIRFilter(&pState->filterGCREqualizeTemplate,
				   0, 11, 9, 2);
		break;
	case	KS_VBISAMPLINGRATE_47X_NABTS:
		ClearVariableFIRFilter(&pState->filterGCREqualizeTemplate);
		AddToVariableFIRFilter(&pState->filterGCREqualizeTemplate,
				   0, 11, 9, 2);	//FIXME
		break;

	case	KS_VBISAMPLINGRATE_5X_NABTS:
		break;
    /* ===== add cases here as necessary  ===== */
	default:
		// Unknown sample rate
		EASSERT(0);
		break;
  }

  /* Last but not least, recompute for the new rate */
  NDSPComputeNewSampleRate(newRate, oldRate);

  return 0;
}


/* Create a new "DSP state".
   
   A separate DSP state should be maintained for each separate
   simultaneous source to the DSP.
   
   NDSPStartRetrain() is implicitly called upon creation of a new state.

   Public function: also see nabtsapi.h.

   If memory is passed, use it for storing the state rather than mallocing
   a new state */

NDSPState *NDSPStateNew(void *memory)
{

   NDSPState *pState;

   /* Be sure that the globals are initialized */
   NDSPInitGlobals();
   
   pState= memory ? ((NDSPState *)memory) : alloc_mem(sizeof(NDSPState));
   if (!pState) return NULL;
   memset(pState, 0, sizeof(NDSPState));

   /* Magic number to help identify an NDSPState object */
   pState->uMagic= NDSP_STATE_MAGIC;
   

   pState->nRetrainState= 0;
   pState->nUsingGCR= 0;
   pState->bUsingScratch1= FALSE;
   pState->bUsingScratch2= FALSE;
   pState->bUsingScratch3= FALSE;
   pState->bUsingScratch4= FALSE;
   pState->bUsingScratch5= FALSE;
   pState->bFreeStateMem = (memory == NULL);
   pState->SamplesPerLine= 1600;    // Default from Bt829 driver

   /* Reset the filter to be the "fallback" filter */
   NDSPResetFilter(pState);
   
   /* Set the equalization "template" filters.
      (These filters have the correct tap locations, but the tap
      values are ignored) */
   
   ClearVariableFIRFilter(&pState->filterGCREqualizeTemplate);
   AddToVariableFIRFilter(&pState->filterGCREqualizeTemplate,
                          0, 11, 9, 3);
   
   ClearVariableFIRFilter(&pState->filterNabsyncEqualizeTemplate);
   AddToVariableFIRFilter(&pState->filterNabsyncEqualizeTemplate,
                          0, 2, 2, 5);

   NDSPStateSetSampleRate(pState, KS_VBISAMPLINGRATE_5X_NABTS);
   return pState;
}

/* Destroys the DSP state.
   Automatically disconnects from any FEC state.

   Returns 0 on success.
   Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if illegal state.

   Public function: also see nabtsapi.h */

int NDSPStateDestroy(NDSPState *pState)
{
   if (!pState || pState->uMagic != NDSP_STATE_MAGIC)
      return NDSP_ERROR_ILLEGAL_NDSP_STATE;

   if (pState->bFreeStateMem)
      free_mem(pState);
   return 0;
}

/*

  Connect the given NFECState and NDSPState
  
  For cases where the NDSP and NFEC modules are connected,
  giving pointers to the connected state may result in increased
  robustness and efficiency.

  Note that only one of
  NDSPStateConnectToFEC or
  NFECStateConnectToDSP
  need be called to connect the two states.  (Calling both is OK).

  Returns 0 on success.
  Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if illegal DSP state.
   
  Public function: also see nabtsapi.h

   This function currently does nothing, but the API is in place
   for future algorithms that could potentially make use of combined
   DSP and FEC knowledge */

int NDSPStateConnectToFEC(NDSPState *pDSPState, NFECState *pFECState)
{
   if (!pDSPState || pDSPState->uMagic != NDSP_STATE_MAGIC)
      return NDSP_ERROR_ILLEGAL_NDSP_STATE;

   return 0;
}

/*

  Tells the DSP to initiate a "fast retrain".  This is useful if you
  suspect that conditions have changed sufficiently to be worth spending
  significant CPU to quickly train on a signal.
  
  This should be called when the source of video changes.

   Returns 0 on success.
   Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if illegal DSP state.
   
  Public function: also see nabtsapi.h

  */

int NDSPStartRetrain(NDSPState *pState)
{
   if (!pState || pState->uMagic != NDSP_STATE_MAGIC)
      return NDSP_ERROR_ILLEGAL_NDSP_STATE;

   /* Reset nRetrainState to zero.
      This initiates a retrain.
      See NDSPProcessGCRLine for more information */
   
   pState->nRetrainState= 0;
   return 0;
}

/*

  Resets the DSP filter back to the "fallback" fixed filter.
  This normally doesn't need to be called, but might be useful for
  performance analysis.

  */

int NDSPResetFilter(NDSPState *pState)
{
   if (!pState || pState->uMagic != NDSP_STATE_MAGIC)
      return NDSP_ERROR_ILLEGAL_NDSP_STATE;

   NDSPStateSetFilter(pState, g_filterDefault, sizeof(*g_filterDefault));
   pState->nRetrainState= 0;
   return 0;
}

/* Assign an array of Double from an array of unsigned char */

void Copy_d_8(Double *pfOutput, unsigned char *pbInput, int nLen)
{
   int i;
   for (i= 0; i< nLen; i++) pfOutput[i]= pbInput[i];
}

/*
  The general strategy for convolution is to "slide" one array across
  another and multiple the overlapping portions like so:

  Convolve A and B by sliding B across A.
  
         -- j
         \ 
dest[i]= /   a[j*a_step+i]*b[j*b_step]
         --
         
  For Convolve_d_d_filt_var, we are convolving and array of Double
  with a variable-tap filter.  A variable-tap filter is simply a sparse
  representation for an array */

int debug_convolve= 0;

void Convolve_d_d_filt_var(NDSPState *pState,
               Double *dest, int dest_begin, int dest_end,
               Double *a, int a_begin, int a_end,
               FIRFilter *pFilt,
               BOOL bSubtractMean) {
  int maxTap = pFilt->nMaxTap;  /* positive value */
  int minTap = pFilt->nMinTap;  /* negative value */

  int b_len = maxTap-minTap+1;

  Double *b;
  int i;

  /* Set b to a scratch buffer from the NDSPState.
     Mark the scratch buffer as used.

     Offset b by "minTap" (which is negative), so that array references
     as low as "minTap" can be handled.
     */
  
  SASSERT(!pState->bUsingScratch7);
  SASSERT(sizeof(pState->pdScratch7)/sizeof(Double) >= b_len);
  b = pState->pdScratch7 - minTap;
  pState->bUsingScratch7 = __LINE__;


  /* The strategy here is to generate a non-sparse representation for the
     filter, and call the standard convolution routine with it. */

  for (i = minTap; i <= maxTap; i++) {
    b[i] = 0;
  }

  for (i = 0; i < pFilt->nTaps; i++) {
    b[pFilt->pnTapLocs[i]] = pFilt->pdTaps[i];
  }    

  Convolve_d_d_d(dest, dest_begin, dest_end,
         a, a_begin, a_end, 1,
         b, minTap, maxTap, 1,
         bSubtractMean);

  /* Mark Scratch7 as free */
  
  pState->bUsingScratch7 = 0;
}

/* Like Convolve_d_d_filt_var above, but is implemented to work
   only for fixed-tap filters.  This improves performance. */

void Convolve_d_d_filt(Double *dest, int dest_begin, int dest_end,
                       Double *a, int a_begin, int a_end,
                       FIRFilter *pFilt,
                       BOOL bSubtractMean)
{
   Double *b= pFilt->pdTaps+(pFilt->nTaps-1)/2;
   Double b_begin= -(pFilt->nTaps-1)/2;
   Double b_end= (pFilt->nTaps-1)/2;
   Double a_step= pFilt->dTapSpacing;
   Double b_step= 1.0;
   SASSERT(pFilt->nTaps > 0 && (pFilt->nTaps % 2) == 1);

   /* Simply call the standard convolution routine, taking into account
      the fixed spacing of the filter */
   
   Convolve_d_d_d(dest, dest_begin, dest_end,
                  a, a_begin, a_end, a_step,
                  b, b_begin, b_end, b_step,
                  bSubtractMean);
}

/*
  Convolve_d_d_d convolves two input arrays and places the result in
  a single output array.

  The general strategy for convolution is to "slide" one array across
  another and multiple the overlapping portions like so:

  Convolve A and B by sliding B across A.
  
         -- j
         \ 
dest[i]= /   a[j*a_step+i]*b[j*b_step]
         --
         
  Convolve_d_d_d complicates matters somewhat by allowing:
  1) Arbitrary begin and end indices for the destination array.
  2) Arbitrary begin and end indices for A and B
     (Any elements required by the convolution that fall outside these
      ranges are taken to be zero)
  3) Arbitrary spacing between the array elements of A and B, allowing
     for a fixed-spacing sparse array to be convolved efficiently.
  4) The ability to subtract the mean from one of the arguments prior
     to convolution.

  Note that the arbitrary begin and end indices can be negative if
  appropriate.
  
  */

void Convolve_d_d_d(Double *dest, int dest_begin, int dest_end,
                    Double *a, Double a_begin, Double a_end, Double a_step,
                    Double *b, Double b_begin, Double b_end, Double b_step,
                    BOOL bSubtractMean)
{
   Double dSum;
   int i;
   Double	j;

   ASSERT( a_step > 0.0 && b_step > 0.0 );  // This should never happen!

   if ( a_step > 0 && b_step > 0 )			// To fix a PREFIX tool divide-by-zero whine
   {
	   for (i= dest_begin; i <= dest_end; i++) {
		  Double j_begin, j_end;
		  Double a_index, b_index;
		  Double a_interpolated, b_interpolated;

		  /* a_begin <= j*a_step+i <= a_end */
		  /* b_begin <= j*b_step <= b_end */
		  /* or */
		  /* ceil((a_begin-i)/a_step) <= j <= floor((a_end-i)/a_step) */
		  /* ceil(b_begin/b_step) <= j <= floor(b_end/b_step) */

		  j_begin= max( (a_begin-i) / a_step, (b_begin) / b_step );

		  SASSERT((a_begin <= j_begin*a_step+i &&
				   b_begin <= j_begin*b_step));
		  SASSERT(!(a_begin <= (j_begin-1)*a_step+i &&
					b_begin <= (j_begin-1)*b_step));

		  j_end = min( (a_end-i) / a_step, (b_end) / b_step );

		  SASSERT((j_end*a_step+i <= a_end &&
				   j_end*b_step <= b_end));

		  if (debug_convolve) {
			  debug_printf(("(%d,%s-%s) ",
							i,
							flPrintf(j_begin,6),
							flPrintf(j_end,6)));
		  }
      
		  dSum= 0.0;
      
		  if (j_end >= j_begin) {
			 Double dMean;
         
			 a_index= j_begin*a_step+i;
			 b_index= j_begin*b_step;
         
			 dMean= 0.0;

			 if (bSubtractMean) {
				for(j= j_begin; j <= j_end; j++) {
				   SASSERT(b_begin <= b_index && b_index <= b_end);
				   b_interpolated = _InterpDoubleArr(b, b_index);
				   dMean += b_interpolated;
				   b_index += b_step;
				}
            
				dMean /= (j_end - j_begin + 1);
			 }
      
			 a_index= j_begin*a_step+i;
			 b_index= j_begin*b_step;
         
			 for(j= j_begin; j <= j_end; j++) {
				SASSERT(a_begin <= a_index && a_index <= a_end);
				SASSERT(b_begin <= b_index && b_index <= b_end);
				a_interpolated = _InterpDoubleArr(a,a_index);
				b_interpolated = _InterpDoubleArr(b,b_index);
				dSum += a_interpolated*(b_interpolated-dMean); 
				a_index += a_step;
				b_index += b_step;
			 }
		  }
		  dest[i]= dSum;
	   }
   }
}

/* Determine the minimum and maximum tap locations for a variable-tap
   filter */

void RecalcVariableFIRFilterBounds(FIRFilter *pFilter)
{
   int i;
   int nMinTap= +NDSP_MAX_FIR_TAIL;
   int nMaxTap= -NDSP_MAX_FIR_TAIL;

   SASSERT(pFilter->bVariableTaps);
   
   for (i= 0; i< pFilter->nTaps; i++) {
      nMinTap= imin(nMinTap, pFilter->pnTapLocs[i]);
      nMaxTap= imax(nMaxTap, pFilter->pnTapLocs[i]);
   }
   if (pFilter->nTaps) {
      pFilter->nMinTap= nMinTap;
      pFilter->nMaxTap= nMaxTap;
   } else {
      pFilter->nMinTap= 0;
      pFilter->nMaxTap= 0;
   }
}

/* Adds one or more taps to a variable FIR filter.

   One tap is added at nCenterPos.

   Additional taps are added before or after nCenterPos depending on the
   number of left taps and right taps requested.

   To be more precise, taps are added at all:

   nCenterPos + i * nTapSpacing

   where i is an integer in the range from (-nLeftTaps) to
   nRightTaps, inclusive.

   Will call RecalcVariableFIRFilterBounds to recalculate filter
   bounds in case the tap was added outside previous bounds */

void AddToVariableFIRFilter(FIRFilter *pFilter,
                            int nCenterPos,
                            int nLeftTaps, int nRightTaps, int nTapSpacing)
{
   int i;
   int nCurrentTap= pFilter->nTaps;
   pFilter->bVariableTaps= TRUE;

   /*
   debug_printf(("\nADD %lx [+%d] l=%d r=%d spacing=%d\n",
          (long)pFilter, nCenterPos, nLeftTaps, nRightTaps, nTapSpacing));
          */

   for (i= -nLeftTaps; i <= nRightTaps; i++) {
      int nCurrentTapLoc= nCenterPos + i*nTapSpacing;
      SASSERT(nCurrentTap < NDSP_MAX_FIR_COEFFS);
      SASSERT(iabs(nCurrentTapLoc) <= NDSP_MAX_FIR_TAIL);
      pFilter->pnTapLocs[nCurrentTap]= nCurrentTapLoc;
      pFilter->pdTaps[nCurrentTap]= 0.0;
      nCurrentTap++;
   }
   pFilter->nTaps= nCurrentTap;
   RecalcVariableFIRFilterBounds(pFilter);
}


/* Removes all taps from a variable FIR filter */

void ClearVariableFIRFilter(FIRFilter *pFilter)
{
   /*debug_printf(("\nCLEAR %lx\n", (long)pFilter));*/
   pFilter->bVariableTaps= TRUE;
   pFilter->nTaps= 0;
   RecalcVariableFIRFilterBounds(pFilter);
}


/* Copies a FIRFilter */

void CopyFIRFilter(FIRFilter *pfilterDest, FIRFilter *pfilterSrc)
{
   memcpy(pfilterDest, pfilterSrc, sizeof(FIRFilter));
}


/* Attempt to perform equalization and long ghost cancellation from
   GCR in the state "pState".

   Assumes that pState->psmPosGCRs[0] has been filled during by
   NDSPProcessGCRLine during retrain states (-g_nNabtsRetrainDuration) to 0.
   (see NDSPProcessGCRLine for more information).

   Return 0 if success.  Return error status if failure.

   */

int DoEqualizeFromGCRs(NDSPState *pState)
{
   /* If the signal doesn't look enough like a GCR signal, fail
      and say we didn't detect the GCR */
   if (NDSPDetectGCRConfidence(pState->psmPosGCRs[0].pbSamples+
                   pState->psmPosGCRs[0].nOffset) < 50) {
      return NDSP_ERROR_NO_GCR;
   }
   
   return DoGCREqualFromSignal(
      pState,
      &pState->psmPosGCRs[0],
      &eqmatchGCR1,
      &pState->filterGCREqualizeTemplate,
      g_nNabtsAdditionalTapsGCR);
}


/* Attempt to perform equalization (WITHOUT long ghost cancellation)
   from GCR in the state "pState".

   Assumes that pState->psmSyncs[0] has been filled during by
   NDSPDecodeLine during retrain states (-g_nNabtsRetrainDuration) to 0.
   (see NDSPProcessGCRLine for more information).

   Return 0 if success.  Return error status if failure.

   */

int DoEqualizeFromNabsync(NDSPState *pState)
{
   return DoGCREqualFromSignal(
      pState,
      &pState->psmSyncs[0],
      &eqmatchNabtsSync,
      &pState->filterNabsyncEqualizeTemplate,
      0 /* don't add additional taps for equalizing from nabsync */);
}   

/* Attempt to perform equalization (WITHOUT long ghost cancellation)
   from given signal and given NDSPSigMatch.

   After equalization, attempt to add nAddTaps taps to handle long ghosts.
   This is only appropriate if the sigmatch signal is long enough.

   Return 0 if success.  Return error status if failure.

   */
   
int DoGCREqualFromSignal(NDSPState *pState,
                         NDSPSigMatch *sigmatch,
                         EqualizeMatch *eqm,
                         FIRFilter *pfilterTemplate,
             int nAddTaps)
{
   int i;
   Double dConv;
   Double *GCRsignal= eqm->pdSignal;
   int nMatchSize= eqm->nSignalSize;
   int nMatchSampleRate= eqm->nSignalSampleRate;
   Double *pdSamples;
   int nMaxindex= 0;
   int nStatus= 0;
   
   if (!pState || pState->uMagic != NDSP_STATE_MAGIC)
      return NDSP_ERROR_ILLEGAL_NDSP_STATE;

#ifdef DEBUG
   debug_printf(("GCRs: "));
   for (i= 0; i< NDSP_SIGS_TO_ACQUIRE; i++) {
      debug_printf(("%s@%d -%s@%d ",
             flPrintf(pState->psmPosGCRs[i].dMaxval,4),
             pState->psmPosGCRs[i].nOffset,
             flPrintf(pState->psmNegGCRs[i].dMaxval,4),
             pState->psmNegGCRs[i].nOffset));
   }
   debug_printf(("\n"));
# if 0
   {
      FILE *out= fopen("foo+", "w");
      NDSPAvgGCRs(buf, pState->psmPosGCRs);
      for (i= 0; i< pState->SamplesPerLine; i++) fprintf(out, "%g\n", buf[i]);
      fclose(out);
   }
   {
      FILE *out= fopen("foo-", "w");
      NDSPAvgGCRs(buf, pState->psmNegGCRs);
      for (i= 0; i< pState->SamplesPerLine; i++) fprintf(out, "%g\n", buf[i]);
      fclose(out);
   }
# endif //0
#endif //DEBUG
   
   SASSERT(!pState->bUsingScratch1);
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >= pState->SamplesPerLine);
   pdSamples= pState->pdScratch1;
   pState->bUsingScratch1= __LINE__;
   
   SASSERT(!pState->bUsingScratch2);
   SASSERT(sizeof(pState->pdScratch2)/sizeof(Double) >= pState->SamplesPerLine);
   if (NDSPAvgSigs(pState, pdSamples, sigmatch, &dConv)) {
      pState->bUsingScratch1= FALSE;
      return NDSP_ERROR_NO_GCR;
   } else {
      debug_printf(("[Conv=%s] ", flPrintf(dConv,4)));
   }
   
   nMaxindex= 20;
   
   {
      int nFirstTap;
      int nLastTap;
      Double *pdInput;
      BOOL bRet;
      int nTaps;
      FIRFilter *pfilterGcr= &pState->filterScratch3;
      Double dSyncVal;

      CopyFIRFilter(pfilterGcr, pfilterTemplate);
      SASSERT(pfilterGcr->nTaps > 0);

      nTaps= pfilterGcr->nTaps;

      nFirstTap= pfilterGcr->nMinTap;
      nLastTap= pfilterGcr->nMaxTap;
      
      SASSERT(!pState->bUsingScratch2);
      pdInput= pState->pdScratch2 - nFirstTap;
      SASSERT(sizeof(pState->pdScratch2)/sizeof(Double) >=
              nMatchSize*nMatchSampleRate-nFirstTap+nLastTap);
      pState->bUsingScratch2= TRUE;
      
      dSyncVal= Mean_d(pdSamples, 5);
      
      for (i= nFirstTap;
           i< nMatchSize*nMatchSampleRate+nLastTap;
           i++) {
         if (i+nMaxindex >= 0 && i+nMaxindex < pState->SamplesPerLine) {
            pdInput[i]= pdSamples[i+nMaxindex];
         } else {
            /*debug_printf(("zf %d %s ", i, flPrintf(dSyncVal,4)));*/
            pdInput[i]= dSyncVal;
         }
      }

      SubtractMean_d(pdInput+nFirstTap,
                     pdInput+nFirstTap,
                     nMatchSize*nMatchSampleRate-nFirstTap+nLastTap);

      /* Perform equalization step */
         
      bRet= EqualizeVar(pState,
                        pdInput, nFirstTap, nMatchSize*nMatchSampleRate+nLastTap,
                        GCRsignal, nMatchSize, nMatchSampleRate,
                        pfilterGcr);
      
      {
    int minTap = pfilterGcr->nMinTap;
    int maxTap = pfilterGcr->nMaxTap;

        /* Attempt to add additional taps (if requested) to handle
           long ghosts */
        
    while (nAddTaps > 0) {
      nAddTaps--;

      if (bRet) {
        Double *pdFilt;
        Double *pdConv;
        int bestTap = -9999;

        SASSERT(!pState->bUsingScratch8);
        SASSERT(sizeof(pState->pdScratch8)/sizeof(Double) >=
            g_nNabtsMaxPreGhost + g_nNabtsMaxPostGhost + 1);
        pdConv = pState->pdScratch8;
        pState->bUsingScratch8 = __LINE__;

        SASSERT(!pState->bUsingScratch6);
        SASSERT(sizeof(pState->pdScratch6)/sizeof(Double) >= pState->SamplesPerLine);
        pdFilt = pState->pdScratch6;
        pState->bUsingScratch6 = __LINE__;

            /* Filter the input line given the best filter so far */
            
        Convolve_d_d_filt_var(pState,
                  pdFilt, 0, pState->SamplesPerLine-1,
                  pdInput, 0, pState->SamplesPerLine-1,
                  pfilterGcr, TRUE);

            /* Now convolve the filtered output with the target signal
               to see if we can see any echos */
            
        Convolve_d_d_d(pdConv + g_nNabtsMaxPreGhost,
               -g_nNabtsMaxPreGhost, g_nNabtsMaxPostGhost,
               pdFilt, 0,
               pState->SamplesPerLine-1, GCR_SAMPLE_RATE,
               GCRsignal, 0, g_nNabtsGcrSize, 1,
               TRUE);

        {
          Double bestTapVal = -1;

              /* Look for the strongest echo */
              
          for (i = 0;
           i < g_nNabtsMaxPreGhost + g_nNabtsMaxPostGhost + 1;
           i++) {
        if (fabs(pdConv[i]) > bestTapVal &&
            (i-g_nNabtsMaxPreGhost < minTap ||
             i-g_nNabtsMaxPreGhost > maxTap)) {
          int j;
          int tap_ok = 1;

          for (j = 0; j < pfilterGcr->nTaps; j++) {
            if (i-g_nNabtsMaxPreGhost == -pfilterGcr->pnTapLocs[j]) {
              tap_ok = 0;
              break;
            }
          }

          if (tap_ok) {
            bestTapVal = fabs(pdConv[i]);
            bestTap = i-g_nNabtsMaxPreGhost;
          }
        }
          }
        }

        debug_printf(("Adding %d to current %d-tap filter\n",
             -bestTap, pfilterGcr->nTaps));

            /* Add a tap to the filter to handle the strongest echo location */

        AddToVariableFIRFilter(pfilterGcr,
                   -bestTap,
                   0, 0, 0);

            /* Now re-run the equalization given the new tap locations as
               the prototype */

        bRet= EqualizeVar(pState,
                  pdInput, pfilterGcr->nMinTap,
                  nMatchSize*nMatchSampleRate+pfilterGcr->nMaxTap,
                  GCRsignal, nMatchSize, nMatchSampleRate,
                  pfilterGcr);

        pState->bUsingScratch8 = 0;
        pState->bUsingScratch6 = 0;
      }
    }
      }

      if (!bRet) {
         /* Equalization failed */
         nStatus= NDSP_ERROR_NO_GCR;
         NDSPStateSetFilter(pState, g_filterDefault, sizeof(*g_filterDefault));
         pState->nUsingGCR= FALSE;
      } else {
         nStatus= 0;
         NDSPStateSetFilter(pState, pfilterGcr, sizeof(*pfilterGcr));
         pState->nUsingGCR= TRUE;
      }
      
      pdInput= NULL;
      pState->bUsingScratch2= FALSE;
   }
   pdSamples= NULL;
   pState->bUsingScratch1= FALSE;
   return nStatus;
}

/* Do we want to use the actual GCR signal for equalization?
   If FALSE, fall back to only use NABTS sync equalization */

BOOL g_bUseGCR= FALSE;  // Can't use GCR for EQ right now due to IP concerns

int DoEqualize(NDSPState *pState)
{
   /* Do equalization based on either GCR acquisition,
      or Nabsync acquisition */

   /* Preference is given to GCR, but only if
      g_bUseGCR is TRUE */

   if (g_bUseGCR) {
      if (0 == DoEqualizeFromGCRs(pState)) {
#ifdef DEBUG
         debug_printf(("GCR equalize "));
         print_filter(&pState->filter);
         debug_printf(("\n"));
#endif //DEBUG
         return 0;
      } else {
         debug_printf(("GCR equ failed\n"));
      }
   }

   /* GCR failed or was disabled.  Try NABTS sync */
   
   /* toggle default filtering */
   if (0 == DoEqualizeFromNabsync(pState)) {
#ifdef DEBUG
      debug_printf(("Nabsync equalize "));
      print_filter(&pState->filter);
      debug_printf(("\n"));
#endif //DEBUG
      return 0;
   } else {
      debug_printf(("Nabsync equ failed\n"));
   }

   /* All adaptive equalization failed;
      use default fixed filter */
   
   debug_printf(("Using default filter\n"));
   NDSPStateSetFilter(pState, g_filterDefault, sizeof(*g_filterDefault));
#ifdef DEBUG
   print_filter(&(pState->filter));
#endif //DEBUG
   
   return 1;
}

#define NABTS_RATE						KS_VBIDATARATE_NABTS
#define NABTS_SAMPLE_RATE				(NABTS_RATE * 5)
#define NABTS_US_PER_CLOCK_TIMES_100000 (1000000000 / (NABTS_SAMPLE_RATE/100))

/*
  
  ComputeOffsets takes a VBIINFOHEADER and determines the correct offset
  into the samples for the DSP code.

  The sample offset is returned in both pnOffsetData and
  pnOffsetSamples.  Only one is now required; we should remove one of
  the two arguments at earliest convenience.

  Our goal is to have the nabts sync start around sample 52,
  or 1.82 us into the block.

  NABTS sync is specified to be inserted at 10.48 +- .34 us after
  leading edge of HSYNC.

  Therefore, our desired sample start time is 10.48 - 1.82 = 8.66 us
  after leading edge of HSYNC

  */

  
#define DESIRED_START_TIME_US100 866

#if 0
int ComputeOffsets(KS_VBIINFOHEADER *pVBIINFO,
                   int *pnOffsetData,
                   int *pnOffsetSamples)
{
   int nOffsetUS100;
   int nOffsetData;
   int nSamples;

   if (!pVBIINFO) {
      return NDSP_ERROR_ILLEGAL_VBIINFOHEADER;
   }
   
   nSamples= pVBIINFO->SamplesPerLine;

   /* Actual start time must be less than or equal to desired start time */
   /* This results in a positive offset into the input data */
   nOffsetUS100= (DESIRED_START_TIME_US100 - pVBIINFO->ActualLineStartTime);
   nOffsetData= nOffsetUS100*1000/NABTS_US_PER_CLOCK_TIMES_100000;
   
   if (nOffsetData < 0) nOffsetData= 0;
   if (nOffsetData + 1536 > nSamples) {
      nOffsetData= nSamples-1536;
   }

   nSamples -= nOffsetData;
   SASSERT(nSamples >= 1536);
   
   *pnOffsetData= nOffsetData;
   *pnOffsetSamples= nOffsetData;
   
   return 0;
}
#endif

/*
   Public function: also see nabtsapi.h.

   This function is the key to the automatic equalization code.

   Although its name suggests that it only does GCR-based equalization,
   this function in fact coordinates all dynamic equalization, including
   that done on the basis of the NABTS sync pattern.  Therefore, be certain
   to call this once per field even if you set g_bUseGCR to FALSE,
   disabling GCR-based equalization and ghost cancellation.

   If this function is never called, the DSP will simply use the
   default fixed filter.

   This function maintains the pState->nRetrainState value.  This value
   counts down each field, and determines the current state of the
   equalization:

   From g_nNabtsRetrainDelay down to 0:  Idle, waiting to start retrain.

   From 0 down to -g_nNabtsRetrainDuration:  Acquire appropriate
                                             GCR and NABTS sync signals

   -g_nNabtsRetrainDuration: Perform equalization and ghost cancellation
                             based on acquired signal.
                             Go back to state g_nNabtsRetrainDelay afterwards.

   Note that NDSPStartRetrain resets nRetrainState to zero, causing
   immediate signal acquisition and retrain after g_nNabtsRetrainDuration
   fields.
   
   */
  
int NDSPProcessGCRLine(NDSPGCRStats *pLineStats,
                       unsigned char *pbSamples, NDSPState *pState,
                       int nFieldNumber, int nLineNumber,
                       KS_VBIINFOHEADER *pVBIINFO)
{
   NDSPGCRStats gcrStats;
   gcrStats.nSize= sizeof(gcrStats);

   if (!pState || pState->uMagic != NDSP_STATE_MAGIC)
      return NDSP_ERROR_ILLEGAL_NDSP_STATE;

   pState->nRetrainState--;
   
   gcrStats.bUsed= FALSE;
   
   if (pState->nRetrainState < -g_nNabtsRetrainDuration) {
      /* Signal acquired;  perform equalization/ghost cancellation */
      gcrStats.bUsed= TRUE;

      DoEqualize(pState);
      pState->nRetrainState= g_nNabtsRetrainDelay;
   } else if (pState->nRetrainState < 0) {
      /* Try to find best GCR line for later equalization */
      /* NABTS sync is acquired by NDSPDecodeLine */
      
      if (pState->nRetrainState == -1) {
         /* Starting the search for a GCR line */
         NDSPResetGCRAcquisition(pState);
         NDSPResetNabsyncAcquisition(pState);
      }
      NDSPAcquireGCR(pState, pbSamples);
   }
      
   if (pLineStats) {
      if (pLineStats->nSize < sizeof(NDSPGCRStats))
         return NDSP_ERROR_ILLEGAL_STATS;
      memcpy((void*)pLineStats, (void*)&gcrStats, sizeof(NDSPGCRStats));
   }
   return 0;
}

void NDSPResetGCRAcquisition(NDSPState *pState)
{
   int i;
   for (i= 0; i< NDSP_SIGS_TO_ACQUIRE; i++) {
      pState->psmPosGCRs[i].dMaxval= 0.0;
      pState->psmNegGCRs[i].dMaxval= 0.0;
   }
}

void NDSPResetNabsyncAcquisition(NDSPState *pState)
{
   int i;
   for (i= 0; i< NDSP_SIGS_TO_ACQUIRE; i++) {
      pState->psmSyncs[i].dMaxval= 0.0;
   }
}

/* Average together multiple signals.
   Use offsets computed by earlier convolution with target signal so
   that we correctly align the signals before averaging */

/* 1 if error */
/* 0 if OK */

int NDSPAvgSigs(
    NDSPState *pState, Double *pdDest, NDSPSigMatch *psm, Double *dConvRet)
{
   int i,j;
   Double dConv= 0.0;;
   for (i= 0; i< pState->SamplesPerLine; i++) pdDest[i]= 0.0;
   if (psm[NDSP_SIGS_TO_ACQUIRE-1].dMaxval == 0.0) return 1;
   for (i= 0; i< pState->SamplesPerLine; i++) {
      int nSum= 0;
      for (j= 0; j< NDSP_SIGS_TO_ACQUIRE; j++) {
         int from_index= i + psm[j].nOffset-20;;
         if (from_index < 0) from_index= 0;
         if (from_index > (pState->SamplesPerLine-1)) from_index= (pState->SamplesPerLine-1);
         nSum += psm[j].pbSamples[from_index];
      }
      pdDest[i]= ((Double)nSum) / NDSP_SIGS_TO_ACQUIRE;
   }
   for (j= 0; j< NDSP_SIGS_TO_ACQUIRE; j++) {
      dConv += psm[j].dMaxval;
   }
   dConv /= NDSP_SIGS_TO_ACQUIRE;
   if (dConvRet) *dConvRet= dConv;
   return 0;
}

/* We're trying to find the best representative matching signal during
   the "Acquire appropriate GCR and NABTS sync signals" stage (see
   NDSPProcessGCRLine).

   Maintain an array of the N best signals see so far */
   
void NDSPTryToInsertSig(NDSPState *pState, NDSPSigMatch *psm, Double dMaxval,
                        unsigned char *pbSamples, int nOffset)
{
   int i;
   double dMaxvalToReplace= dMaxval;
   int nIndexToReplace= -1;
   for (i= 0; i< NDSP_SIGS_TO_ACQUIRE; i++) {
      if (psm[i].dMaxval < dMaxvalToReplace) {
         nIndexToReplace= i;
         dMaxvalToReplace= psm[i].dMaxval;
      }
   }
   if (nIndexToReplace >= 0) {
      psm[nIndexToReplace].dMaxval= dMaxval;
      psm[nIndexToReplace].nOffset= nOffset;
      memcpy(psm[nIndexToReplace].pbSamples, pbSamples, pState->SamplesPerLine);
   }
}

void NDSPAcquireNabsync(NDSPState *pState, unsigned char *pbSamples)
{
   Double dMaxval = 0.0;
   int nOffset = 0;
   
   MatchWithEqualizeSignal(pState,
                           pbSamples,
                           &eqmatchNabtsSync,
                           &nOffset,
                           &dMaxval,
                           FALSE);
   
   NDSPTryToInsertSig(pState, pState->psmSyncs, dMaxval, pbSamples, nOffset);
}

void NDSPAcquireGCR(NDSPState *pState, unsigned char *pbSamples)
{
   Double dMaxval = 0.0;
   int nOffset = 0;

   MatchWithEqualizeSignal(pState,
                           pbSamples,
                           &eqmatchGCR1,
                           &nOffset,
                           &dMaxval,
                           TRUE);
   
   if (dMaxval > 0.0) {
      NDSPTryToInsertSig(pState, pState->psmPosGCRs, dMaxval, pbSamples, nOffset);
   } else {
      NDSPTryToInsertSig(pState, pState->psmNegGCRs, -dMaxval, pbSamples, nOffset);
   }
}


/* This table is approximately given by:
   100 - (Chance of false positive / 3.2%) * 49.
   However, we encode what would otherwise be all 100% with numbers close
   to 100% to preserve some quality information, and what would otherwise
   be off the scale in the negative direction, we encode with numbers close
   to zero for the same reason */
   
int nConfidenceTable[25]= {
   100, /* 0 */
   99,  /* 1 */
   95,  /* 2 */
   90,  /* 3 */
   75,  /* 4 */
   49,  /* 5 */
   45,  /* 6 */
   40,  /* 7 */
   16,  /* 8 */
   15,  /* 9 */
   14,  /* 10 */
   13,  /* 11 */
   12,  /* 12 */
   11,  /* 13 */
   10,  /* 14 */
   9,  /* 15 */
   8,  /* 16 */
   7,  /* 17 */
   6,  /* 18 */
   5,  /* 19 */
   4,  /* 20 */
   3,  /* 21 */
   2,  /* 22 */
   1, /* 23 */
   0, /* 24 */
};

int NDSPSyncBytesToConfidence(unsigned char *pbSyncBytes)
{
   int nReal=
      (pbSyncBytes[0]<<16) +
      (pbSyncBytes[1]<<8) +
      (pbSyncBytes[2]<<0);
   int nIdeal= 0x5555e7;
   int nError= nReal ^ nIdeal;
   int nErrors= 0;

   /* Calculate the number of bit errors */
   while (nError) {
      nError &= (nError-1); /* Remove the least significant bit of nError */
      nErrors++;
   }

   /* What are the chances that random data would match the sync bytes?
      (2^24 / (24 choose nErrors))
      #err     % chance from random data
      ----     -------------------------
      0        0.00001%
      1        0.00014%
      2        0.00165%
      3        0.01206%
      4        0.06334%
      5        0.25334%
      6        0.80225%
      7        2.06294%
      8        4.38375%
      9        7.79333%
      10       11.69000%

      (These numbers aren't completely correct, since we found a spot
      in the input line that convolves most closely with what we're expecting;
      so the actual numbers depend a lot of the types of noise we get when
      receiving non-NABTS lines.)

      This code uses a cutoff of 4 bit errors.  This was determined
      empirically, because, in practice, the convolution finds a fair
      number "reasonable" bits sometimes in random noise.

      */

   SASSERT(nErrors >= 0 && nErrors <= 24);
   return nConfidenceTable[nErrors];
}

/* Some sample locations at which a "positive" GCR signal should be
   quite positive */
/* ++++ Do these need to change on different sample rates? */


/* Compute confidence that we're looking at a GCR signal */
/* Do we think that pbSamples points at a GCR?  Similar implementation
   to NDSPSyncBytesToConfidence, above */

int NDSPDetectGCRConfidence(unsigned char *pbSamples)
{
   int i;
   int nTotalBits= 0;
   int nGoodBits= 0;
   int nCutoff= 30;
   int nConfidence;
   int nDC= float2long(Mean_8(pbSamples, g_nNabtsGcrSize * GCR_SAMPLE_RATE));

   for (i= 0; i< sizeof(pnGCRPositiveIndices)/sizeof(int); i++) {
      nTotalBits++;
      nGoodBits += pbSamples[pnGCRPositiveIndices[i]] > nDC;
   }
   
   for (i= 0; i< sizeof(pnGCRNegativeIndices)/sizeof(int); i++) {
      nTotalBits++;
      nGoodBits += pbSamples[pnGCRNegativeIndices[i]] < nDC;
   }

   /* Cutoff is at 30 bits, based on statistics taken from samples. */
   
   /* The actual confidence number here doesn't mean much except as
      a diagnostic */

   if (nGoodBits >= nCutoff) {
      /* Good */
      nConfidence= 51 + (nGoodBits - nCutoff) * 49 / (nTotalBits - nCutoff);
   }
   else {
      /* Bad */
      nConfidence= nGoodBits * 49 / nCutoff;
   }
   debug_printf(("GCR: %d good bits, %d total bits, conf %d\n",
          nGoodBits, nTotalBits, nConfidence));
   return nConfidence;

}

/*  API for a possibly more efficient partial decode line.
    This might be useful for determining group addresses before decoding
    the rest of the line.
    Currently, this API is no more efficient than the full
    NDSPDecodeLine
    
    Public function: also see nabtsapi.h */


int NDSPPartialDecodeLine(unsigned char *pbDest, NDSPLineStats *pLineStats,
                          unsigned char *pbSamples, NDSPState *pState,
                          int nFECType,
                          int nFieldNumber, int nLineNumber,
                          int nStart, int nEnd,
                          KS_VBIINFOHEADER *pVBIINFO)
{
   debug_printf(("Warning: NDSPPartialDecodeLine uses slow implementation\n"));
   return NDSPDecodeLine(pbDest, pLineStats,
                         pbSamples, pState,
                         nFECType,
                         nFieldNumber, nLineNumber,
                         pVBIINFO);
}


/*  Main API for decoding a NABTS line.
 *
 * Inputs:
 * pbSamples:  pointer to 8-bit raw NABTS samples
 * pState:     NDSPState to use for decoding
 * nFECType:   Can be set to:
 *              NDSP_NO_FEC (don't use FEC information)
 *              NDSP_BUNDLE_FEC_1 (use Norpak-style bundle FEC info)
 *              NDSP_BUNDLE_FEC_2 (use Wavephore-style bundle FEC info)
 * nFieldNumber:
 *             A number that increments by one for each successive field.
 *             "Odd" fields (as defined by NTSC) must be odd numbers
 *             "Even" fields must be even numbers.
 * nLineNumber:
 *             The NTSC line (starting from the top of the field)
 *             from which this sample was taken.
 *
 * Outputs:
 * pbDest:     decoded data ("NABTS_BYTES_PER_LINE" (36) bytes long)
 * pLineStats: stats on decoded data
 *
 * Errors:
 *
 * Returns 0 if no error
 * Returns NDSP_ERROR_ILLEGAL_NDSP_STATE if state is illegal or uses
 *         unsupported settings
 * Returns NDSP_ERROR_ILLEGAL_STATS if stats is passed incorrectly
 *
 * Notes:
 * pbDest must point to a buffer at least 36 bytes long
 * pLineStats->nSize must be set to sizeof(*pLineStats) prior to call
 *   (to maintain backwards compatibility should we add fields in the future)
 * pLineStats->nSize will be set to the size actually filled in by
 *   the call (the number will stay the same or get smaller)
 * Currently the routine only supports a pState with an FIR filter
 *   that has 5 taps
 * nFECType is currently unused, but would potentially be used to give
 *  FEC feedback to the DSP decode, for possible tuning and/or retry

    Public function: also see nabtsapi.h

    */

#ifdef DEBUG
extern void BPCplot(unsigned char *buf, unsigned long offs, unsigned long len);
extern void BPCplotInd(unsigned char *buf, unsigned long offs, unsigned long len, long index);
unsigned short NDSPplotSync = 0;
unsigned short NDSPplotBreak = 0;
unsigned short NDSPplotLen = 75;
unsigned short NDSPplotBits = 0;
unsigned short NDSPplotBitsSkip = 0;
#endif //DEBUG

int NDSPDecodeLine(unsigned char *pbDest, NDSPLineStats *pLineStats,
                   unsigned char *pbSamples, NDSPState *pState,
                   int nFECType,
                   int nFieldNumber, int nLineNumber,
                   KS_VBIINFOHEADER *pVBIINFO)
{
   Double dSyncStart;
   Double dConvConfidence;
   int nConfidence;
   Double dDC, dAC;
   int ret;

   if (!pState) return NDSP_ERROR_ILLEGAL_NDSP_STATE;

   /* These args aren't yet used */
   (void)nFieldNumber;
   (void)nLineNumber;

   /* Save number of samples */
   pState->SamplesPerLine = pVBIINFO->SamplesPerLine;

   /* Locate the NABTS sync so that we know the correct
      offset from which to decode the signal */
   
   NDSPDecodeFindSync(pbSamples, &dConvConfidence,
                      &dSyncStart, &dDC, &dAC, pState, pVBIINFO);
#ifdef DEBUG
   if (NDSPplotSync)
   {
       unsigned long  lSyncStart;
       long   index;

       lSyncStart = float2long(dSyncStart);
       DbgPrint("NDSPDecodeLine: SyncStart at %s\n", flPrintf(dSyncStart, 4));

       index = lSyncStart - NDSPplotLen / 2;
       if (index < 0)
           index = 0;
       BPCplotInd(pbSamples, index, NDSPplotLen, lSyncStart - index);
       if (NDSPplotBreak)
           debug_breakpoint();
   }
#endif //DEBUG

   /* Perform the DSP decode */
   
   ret= NDSPGetBits(pbDest, pbSamples, dSyncStart, dDC, pState, nFECType);

   /* Do the sync bytes look reasonable? */
   
   nConfidence= NDSPSyncBytesToConfidence(pbDest);

   if (nConfidence >= 50 &&
       pState->nRetrainState < 0) {
      /* If the sync bytes look reasonable, and we're in the middle
         of the retrain stage, possibly store this signal away for
         later equalization.
         (See NDSPProcessGCRLine for more information) */
      NDSPAcquireNabsync(pState, pbSamples);
   }
   
#ifdef DEBUG_VERBOSE
   if (g_bDebugSyncBytes) {
      debug_printf(("Sync found at %s with conv=%s, conf= %d, DC=%s, AC=%s\n",
                   flPrintf(dSyncStart, 2),
                   flPrintf(dConvConfidence, 6),
                   nConfidence,
                   flPrintf(dDC, 6),
                   flPrintf(dAC, 6)));
   }
#endif

   if (ret != 0) return ret;
   
#ifdef DEBUG_VERBOSE
   if (g_bDebugSyncBytes) {
      debug_printf(("Sync bytes %x %x %x\n", pbDest[0], pbDest[1], pbDest[2]));
   }
#endif

   /* Fill in the line stats structure */
   if (pLineStats) {
      /* FUTURE: If we add fields, we'll need to change this logic */
      if (pLineStats->nSize < sizeof(NDSPLineStats))
         return NDSP_ERROR_ILLEGAL_STATS;
      pLineStats->nSize= sizeof(pLineStats);
      pLineStats->nConfidence= nConfidence;
      pLineStats->nFirstBit= float2long(dSyncStart);
      pLineStats->dDC= (double) dDC;
   }
   return 0;
}

/*********************/
/* PRIVATE FUNCTIONS */
/*********************/

/* Set the filter for the given DSP state */
int NDSPStateSetFilter(NDSPState *pState, FIRFilter *filter, int nFilterSize)
{
   if (nFilterSize != sizeof(FIRFilter) ||
       filter->nTaps < 1 ||
       filter->nTaps > NDSP_MAX_FIR_COEFFS) {
      return NDSP_ERROR_ILLEGAL_FILTER;
   }

   if (!filter->bVariableTaps) {
	   if ( !(filter->nTaps == 21 && filter->dTapSpacing == 2)
		 && !(filter->nTaps == 5 && filter->dTapSpacing == 5)
		 && !(filter->nTaps == 5 && filter->dTapSpacing == 4)
		 && !(filter->nTaps == 5 && fltCmp(filter->dTapSpacing, KS_47NABTS_SCALER)) )
          /* ===== add cases as needed ===== */
             return NDSP_ERROR_ILLEGAL_FILTER;
   }
   //   NormalizeFilter(&g_filterDefault);
   NormalizeFilter(filter);
   memcpy((void*) &pState->filter, (void*) filter, sizeof(FIRFilter));
   return 0;
}

/* Verify that the "DC" content of the filter is 1.
   That is, the taps of the filter should add to 1.
   This way, when we convolve the filter with a signal, we don't
   change the DC content of the signal */

void NormalizeFilter(FIRFilter *pFilter)
{
   Double dFactor= 1.0 / Sum_d(pFilter->pdTaps, pFilter->nTaps);
   Mult_d(pFilter->pdTaps, pFilter->pdTaps, pFilter->nTaps, dFactor);
}

/* Find the NABTS sync signal.

   Algorithm:
   
   Convolve a window around where the sync is expected with the actual
   transmitted sync waveform.  This will give a very robust location
   for the sync (including the exact phase for best sampling).

   The typical disadvantage to convolution is that it is slow, but,
   for this particular waveform, it was possible to hardcode an
   algorithm that takes approximately 11 additive operations per
   location tested, rather than a more typical 24 multiplies and 72
   additions per location tested.

   # of additive operations ~=
     (11 * (g_nNabtsDecodeBeginMax - g_nNabtsDecodeBeginMin))

   The smaller the window between g_nNabtsDecodeBeginMin and
   g_nNabtsDecodeBeginMax, the faster this routine will run.
   
   */
#ifdef DEBUG
int DSPsyncShowFineTune = 0;
#endif //DEBUG
   
void NDSPDecodeFindSync(unsigned char *pbSamples,
                        Double *pdSyncConfidence,
                        Double *pdSyncStart, Double *pdDC, Double *pdAC,
						NDSPState* pState, KS_VBIINFOHEADER *pVBIINFO)
{
   Double dBestMatch= -1000000;
   Double dBestPos= 0;
   Double dStart;

   /* compute byte-based offsets from time-based offsets: */
#define NABTS_BITS_SEC (1.0/(double)NABTS_RATE)
#define BEGIN_MIN_TIME (9.36e-6 - (pVBIINFO->ActualLineStartTime/1e8))
#define BEGIN_MAX_TIME (11.63e-6 - (pVBIINFO->ActualLineStartTime/1e8))

   /* some shorthand... */
#define ITR_AR(arr, idx) _InterpUCharArr(arr, idx)

   Double dBegin_min_offset = BEGIN_MIN_TIME * (NABTS_RATE * pState->dSampleRate);
   Double dBegin_max_offset = BEGIN_MAX_TIME * (NABTS_RATE * pState->dSampleRate);

   /* +++++++ check that dBegin_min_offset >= 0, and
      dBegin_max_offset is not so high that decoding will go off the end
      of the array */

   Double dSamp = pState->dSampleRate;
   for (dStart= dBegin_min_offset;
        dStart< dBegin_min_offset+dSamp;
        dStart += 1) {
      Double d= dStart;
      Double dMatch;
      Double dMatch1=
         ITR_AR(pbSamples,d+ 0*dSamp) - ITR_AR(pbSamples,d+ 1*dSamp) /* 0-1 */
       + ITR_AR(pbSamples,d+ 2*dSamp) - ITR_AR(pbSamples,d+ 3*dSamp) /* 2-3 */
       + ITR_AR(pbSamples,d+ 4*dSamp) - ITR_AR(pbSamples,d+ 5*dSamp) /* 4-5 */
       + ITR_AR(pbSamples,d+ 6*dSamp) - ITR_AR(pbSamples,d+ 7*dSamp) /* 6-7 */
       + ITR_AR(pbSamples,d+ 8*dSamp) - ITR_AR(pbSamples,d+ 9*dSamp) /* 8-9 */
       + ITR_AR(pbSamples,d+10*dSamp) - ITR_AR(pbSamples,d+11*dSamp) /* 10-11 */
       + ITR_AR(pbSamples,d+12*dSamp) - ITR_AR(pbSamples,d+13*dSamp) /* 12-13 */
       + ITR_AR(pbSamples,d+14*dSamp) - ITR_AR(pbSamples,d+15*dSamp);/* 14-15 */
      
      Double dMatch2=
           ITR_AR(pbSamples,d+16*dSamp)
           + ITR_AR(pbSamples,d+17*dSamp)
           + ITR_AR(pbSamples,d+18*dSamp)   /* 0-2 */
           - ITR_AR(pbSamples,d+19*dSamp)
           - ITR_AR(pbSamples,d+20*dSamp);  /* 3-4 */
      
      /* Note that we skip bits 5-7 of the third byte because they're not
         necessary for locating the sync, and this speeds us up a bit */

      while (d < dBegin_max_offset) {
         dMatch= dMatch1 + dMatch2;
         if (dMatch > dBestMatch) {
            dBestMatch= dMatch;
            dBestPos= d;
         }
         
         /* Move dMatch1 forward by dSamp */
         dMatch1 -= _InterpUCharArr(pbSamples,d+0*dSamp);
         dMatch1 += _InterpUCharArr(pbSamples,d+16*dSamp);
         dMatch1 = (-dMatch1);
         
         /* Move dMatch2 forward by dSamp */
         dMatch2 -= _InterpUCharArr(pbSamples,d+21*dSamp);
         dMatch2 += (2 * _InterpUCharArr(pbSamples,d+19*dSamp));
         dMatch2 -= _InterpUCharArr(pbSamples,d+16*dSamp);
         
         d += dSamp;
      }
   }

#ifdef FINETUNE
	// Now try to fine-tune dBestPos by choosing the offset with the maximum
	//  five-bit amplitude sum
   {
	   Double	d, dNewBest, dPeakSum, dNewSum;

	   // Start by choosing dBestPos as the 'best'
	   dNewBest = 
		   d = dBestPos;
	   dPeakSum = 
			  /*ITR_AR(pbSamples,d+ 0*dSamp) - ITR_AR(pbSamples,d+ 1*dSamp) /* 0-1 */
			+ ITR_AR(pbSamples,d+ 2*dSamp) - ITR_AR(pbSamples,d+ 3*dSamp) /* 2-3 */
			+ ITR_AR(pbSamples,d+ 4*dSamp) - ITR_AR(pbSamples,d+ 5*dSamp) /* 4-5 */
			+ ITR_AR(pbSamples,d+ 6*dSamp) - ITR_AR(pbSamples,d+ 7*dSamp) /* 6-7 */
			+ ITR_AR(pbSamples,d+ 8*dSamp) - ITR_AR(pbSamples,d+ 9*dSamp) /* 8-9 */
			+ ITR_AR(pbSamples,d+10*dSamp) - ITR_AR(pbSamples,d+11*dSamp) /* 10-11 */
			+ ITR_AR(pbSamples,d+12*dSamp) - ITR_AR(pbSamples,d+13*dSamp) /* 12-13 */
			+ ITR_AR(pbSamples,d+14*dSamp) - ITR_AR(pbSamples,d+15*dSamp) /* 14-15 */
#if 0
			+ ITR_AR(pbSamples,d+16*dSamp)
			+ ITR_AR(pbSamples,d+17*dSamp)
			+ ITR_AR(pbSamples,d+18*dSamp)   /* 0-2 */
			- ITR_AR(pbSamples,d+19*dSamp)
			- ITR_AR(pbSamples,d+20*dSamp)  /* 3-4 */
#endif
			;
	   for (d = dBestPos - 1; d < dBestPos + 2; d += 0.1) {
		   dNewSum = 
				  /*ITR_AR(pbSamples,d+ 0*dSamp) - ITR_AR(pbSamples,d+ 1*dSamp); /* 0-1 */
				+ ITR_AR(pbSamples,d+ 2*dSamp) - ITR_AR(pbSamples,d+ 3*dSamp) /* 2-3 */
				+ ITR_AR(pbSamples,d+ 4*dSamp) - ITR_AR(pbSamples,d+ 5*dSamp) /* 4-5 */
				+ ITR_AR(pbSamples,d+ 6*dSamp) - ITR_AR(pbSamples,d+ 7*dSamp) /* 6-7 */
				+ ITR_AR(pbSamples,d+ 8*dSamp) - ITR_AR(pbSamples,d+ 9*dSamp) /* 8-9 */
				+ ITR_AR(pbSamples,d+10*dSamp) - ITR_AR(pbSamples,d+11*dSamp) /* 10-11 */
				+ ITR_AR(pbSamples,d+12*dSamp) - ITR_AR(pbSamples,d+13*dSamp) /* 12-13 */
				+ ITR_AR(pbSamples,d+14*dSamp) - ITR_AR(pbSamples,d+15*dSamp) /* 14-15 */
#if 0
				+ ITR_AR(pbSamples,d+16*dSamp)
				+ ITR_AR(pbSamples,d+17*dSamp)
				+ ITR_AR(pbSamples,d+18*dSamp)   /* 0-2 */
				- ITR_AR(pbSamples,d+19*dSamp)
				- ITR_AR(pbSamples,d+20*dSamp)   /* 3-4 */
#endif
				;
		   if (dNewSum > dPeakSum) {
			   dPeakSum = dNewSum;
			   dNewBest = d;
		   }
	   }

	   if (dNewBest != dBestPos) {
		   if (DSPsyncShowFineTune)
			   debug_printf(("NDSPDecodeFindSync: fine-tuned dBestPos from %s to %s\n", flPrintf(dBestPos,6), flPrintf(dNewBest,6)));
		   dBestPos = dNewBest;
	   }
   }
#endif //FINETUNE

   *pdSyncStart= dBestPos;
   
   {
      /* Calculate DC offset */
      Double dDC= 0, dAC= 0;
      Double d;
      for (d= dBestPos; d < dBestPos + (16*dSamp); d += dSamp) {
         dDC += _InterpUCharArr(pbSamples,d);
      }
      dDC /= 16.0;

      /* Calculate AC amplitude */
      for (d= dBestPos; d < dBestPos + (16*dSamp); d += dSamp) {
         Double tmp = _InterpUCharArr(pbSamples,d)-dDC;
         dAC += (tmp < 0)? -tmp : tmp;
      }
      dAC /= 16.0;
      if (dAC < 1.0) dAC= 1.0; /* Prevent divide by 0 later */
      *pdDC= dDC;
      *pdAC= dAC;

      /* Confidence is from 0 to approximately 96 (4 * 24) */
      /* Subtract out 1*nDC since we had one more high bit than low
         in our convolution */

      *pdSyncConfidence= 2 * (dBestMatch - dDC) / dAC;
      /* If dAC < 20, reduce the confidence */
      *pdSyncConfidence = (*pdSyncConfidence * dAC / 20);
   }
}

/* Perform the DSP to get the NABTS bits from the raw sample line.

   The basic algorithm is to convolve the input signal with the current
   filter, and detect for each bit whether the bit is above or below the
   DC level as determined by looking at the NABTS sync, which is a known
   signal.

   This is where we spend most of our cycles, so there are lots of
   specially-cased hard-coded routines to handle the different filter
   configurations we currently use.

   */
   
int NDSPGetBits(unsigned char *pbDest, unsigned char *pbSamples,
                Double dSyncStart, double dDC, NDSPState *pState,
                int nFECType)
{
   int ret= 0;

   if (pState->filter.bVariableTaps) {
      /* Variable-tap filter */
      ret= NDSPGetBits_var(pbDest, pbSamples, float2long(dSyncStart), dDC,
                            pState, nFECType);
   } else {
     /* change to multiple else if's */
	   if ( pState->filter.nTaps == 21 && pState->filter.dTapSpacing == 2) {
         /* Fixed taps {-20, -18, ... 18, 20} */
         ret= NDSPGetBits_21_2(pbDest, pbSamples, float2long(dSyncStart),
                               dDC, pState, nFECType);
	   }
	   else if ( pState->filter.nTaps == 5 && fltCmp(pState->filter.dTapSpacing, 5)) {
         /* Fixed taps {-10, -5, 0, 5, 10} */
         ret= NDSPGetBits_5_5(pbDest, pbSamples, float2long(dSyncStart), dDC, pState, nFECType);
	   }
	   else if ( pState->filter.nTaps == 5 && fltCmp(pState->filter.dTapSpacing, 4)) {
         ret= NDSPGetBits_5_4(pbDest, pbSamples, float2long(dSyncStart), dDC, pState, nFECType);
	   }
	   else if ( pState->filter.nTaps == 5 && fltCmp(pState->filter.dTapSpacing,KS_47NABTS_SCALER) ) {
         ret= NDSPGetBits_5_47(pbDest, pbSamples, dSyncStart, dDC, pState, nFECType);
	   }
	   else {
		 ret= NDSP_ERROR_ILLEGAL_NDSP_STATE;
	   }
   }
   return ret;
}

/* Get bits for fixed taps {-10, -5, 0, 5, 10}
   See NDSPGetBits for more information */

int NDSPGetBits_5_5(unsigned char *pbDest, unsigned char *pbSamples,
                    int nSyncStart, double dDC, NDSPState *pState,
                    int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double a,b,c,d,e;
#ifdef UseDoubleCoeffs
   Double dCoeffA= pState->filter.pdTaps[0];
   Double dCoeffB= pState->filter.pdTaps[1];
   Double dCoeffC= pState->filter.pdTaps[2];
   Double dCoeffD= pState->filter.pdTaps[3];
   Double dCoeffE= pState->filter.pdTaps[4];

   dDC *= (dCoeffA + dCoeffB + dCoeffC + dCoeffD + dCoeffE);
#else //UseDoubleCoeffs
   Double *pdTaps = pState->filter.pdTaps;
   int dCoeffA= float2long(pdTaps[0]);
   int dCoeffB= float2long(pdTaps[1]);
   int dCoeffC= float2long(pdTaps[2]);
   int dCoeffD= float2long(pdTaps[3]);
   int dCoeffE= float2long(pdTaps[4]);

   dDC *= (dCoeffA + dCoeffB + dCoeffC + dCoeffD + dCoeffE);
   //dDC *= (pdTaps[0] + pdTaps[1] + pdTaps[2] + pdTaps[3] + pdTaps[4]);
#endif //UseDoubleCoeffs

   (void)nFECType;
   SASSERT(pState);
   SASSERT(pState->filter.nTaps == 5);
   SASSERT(pState->filter.dTapSpacing == 5);
   
   dDC *= (dCoeffA + dCoeffB + dCoeffC + dCoeffD + dCoeffE);

   if (nSamplePos-10 >= 0) {
      a= (Double) pbSamples[nSamplePos-10];
   } else {
      a= 0.0;
   }

   if (nSamplePos-5 >= 0) {
      b= (Double) pbSamples[nSamplePos- 5];
   } else {
      b= 0.0;
   }
   
   c= (Double) pbSamples[nSamplePos+ 0];
   d= (Double) pbSamples[nSamplePos+ 5];
   e= (Double) pbSamples[nSamplePos+10];

#ifdef DEBUG
   NDSPplotBitsSkip = 0;
#endif //DEBUG
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
#ifdef DEBUG
         int  bit = 0;
#endif //DEBUG
         nByte >>= 1;
         if (a*dCoeffA + b*dCoeffB + c*dCoeffC + d*dCoeffD + e*dCoeffE > dDC) {
             nByte |= 128;
#ifdef DEBUG
             bit = 1;
#endif //DEBUG
         }
#ifdef DEBUG
         if (NDSPplotBits && !NDSPplotBitsSkip)
         {
             long   index;

             DbgPrint("NDSPGetBits_5_5: nSamplePos = %d, dDC = %s, bit = %d\n",
                             nSamplePos, flPrintf(dDC, 4), bit);

             index = nSamplePos - NDSPplotLen / 2;
             if (index < 0)
                 index = 0;
             if (index + NDSPplotLen > pState->SamplesPerLine)
                 index = pState->SamplesPerLine - NDSPplotLen;
             BPCplotInd(pbSamples, index, NDSPplotLen, nSamplePos - index);
             if (NDSPplotBreak)
                 debug_breakpoint();
         }
#endif //DEBUG
         a=b;
         b=c;
         c=d;
         d=e;
         nSamplePos += 5;
         if (nSamplePos+10 < pState->SamplesPerLine ) {
            e= (Double) pbSamples[nSamplePos+10];
         } else {
            e= 0.0;
         }
      }
      pbDest[i]= nByte;
   }
   return 0;
}

/* Get bits for fixed taps {-9.428, -4.714, 0, 4.714, 9.428}			//FIXME
   See NDSPGetBits for more information */

int NDSPGetBits_5_47(unsigned char *pbDest, unsigned char *pbSamples,
                    Double dSyncStart, double dDC, NDSPState *pState,
                    int nFECType)
{
   double dSamplePos= dSyncStart;
   int i;
   Double dSpacing;
#ifdef UseMultiTaps
   Double a,b,c,d,e;
# ifdef UseDoubleCoeffs
   Double dCoeffA= pState->filter.pdTaps[0];
   Double dCoeffB= pState->filter.pdTaps[1];
   Double dCoeffC= pState->filter.pdTaps[2];
   Double dCoeffD= pState->filter.pdTaps[3];
   Double dCoeffE= pState->filter.pdTaps[4];

   dDC *= (dCoeffA + dCoeffB + dCoeffC + dCoeffD + dCoeffE);
# else //UseDoubleCoeffs
   Double *pdTaps = pState->filter.pdTaps;
   int dCoeffA= float2long(pdTaps[0]);
   int dCoeffB= float2long(pdTaps[1]);
   int dCoeffC= float2long(pdTaps[2]);
   int dCoeffD= float2long(pdTaps[3]);
   int dCoeffE= float2long(pdTaps[4]);

   dDC *= (dCoeffA + dCoeffB + dCoeffC + dCoeffD + dCoeffE);
   //dDC *= (pdTaps[0] + pdTaps[1] + pdTaps[2] + pdTaps[3] + pdTaps[4]);
# endif //UseDoubleCoeffs
#else //UseMultiTaps
#endif //UseMultiTaps

   (void)nFECType;
   SASSERT(pState);
   SASSERT(pState->filter.nTaps == 5);
   SASSERT(fltCmp(pState->filter.dTapSpacing, KS_47NABTS_SCALER));
   dSpacing = pState->filter.dTapSpacing;
   
#ifdef UseMultiTaps
   if (dSamplePos-(2*KS_47NABTS_SCALER) >= 0) {
      a= (Double) _InterpUCharArr(pbSamples, dSamplePos-2*dSpacing);
   } else {
      a= 0.0;
   }

   if (dSamplePos-KS_47NABTS_SCALER >= 0) {
      b= (Double) _InterpUCharArr(pbSamples, dSamplePos-dSpacing);
   } else {
      b= 0.0;
   }
   
   c= (Double) _InterpUCharArr(pbSamples, dSamplePos + 0 );
   d= (Double) _InterpUCharArr(pbSamples, dSamplePos + dSpacing );
   e= (Double) _InterpUCharArr(pbSamples, dSamplePos + 2*dSpacing );
#endif //UseMultiTaps

#ifdef DEBUG
   NDSPplotBitsSkip = 0;
#endif //DEBUG
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
#ifdef DEBUG
         int  bit = 0;
#endif //DEBUG
         nByte >>= 1;
#ifdef UseMultiTaps
         if (a*dCoeffA + b*dCoeffB + c*dCoeffC + d*dCoeffD + e*dCoeffE > dDC)
#else //UseMultiTaps
         if (_InterpUCharArr(pbSamples, dSamplePos) > dDC)
#endif //UseMultiTaps
         {
             nByte |= 128;
#ifdef DEBUG
             bit = 1;
#endif //DEBUG
         }
#ifdef DEBUG
         if (NDSPplotBits && !NDSPplotBitsSkip)
         {
             unsigned long  lSPint;
             long   index;

             lSPint = float2long(dSamplePos);
             DbgPrint("NDSPGetBits_5_47: dSamplePos = %s, dDC = %s, bit = %d\n",
                             flPrintf(dSamplePos, 4), flPrintf(dDC, 4), bit);

             index -= lSPint - NDSPplotLen / 2;
             if (index < 0)
                 index = 0;
             BPCplotInd(pbSamples, index, NDSPplotLen, lSPint - index);
             if (NDSPplotBreak)
                 debug_breakpoint();
         }
#endif //DEBUG

         dSamplePos += dSpacing;
#ifdef UseMultiTaps
         a=b;
         b=c;
         c=d;
         d=e;
         if ( dSamplePos+(2*dSpacing) < pState->SamplesPerLine ) {
            e= _InterpUCharArr(pbSamples, dSamplePos+2*dSpacing);
         } else {
            e= 0.0;
         }
#endif //UseMultiTaps
      }
      pbDest[i]= nByte;
   }
   return 0;
}


/* Get bits for fixed taps {-8, -4, 0, 4, 8}
   See NDSPGetBits for more information */

int NDSPGetBits_5_4(unsigned char *pbDest, unsigned char *pbSamples,
                    int nSyncStart, double dDC, NDSPState *pState,
                    int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double a,b,c,d,e;
#ifdef UseDoubleCoeffs
   Double dCoeffA= pState->filter.pdTaps[0];
   Double dCoeffB= pState->filter.pdTaps[1];
   Double dCoeffC= pState->filter.pdTaps[2];
   Double dCoeffD= pState->filter.pdTaps[3];
   Double dCoeffE= pState->filter.pdTaps[4];

   dDC *= (dCoeffA + dCoeffB + dCoeffC + dCoeffD + dCoeffE);
#else //UseDoubleCoeffs
   Double *pdTaps = pState->filter.pdTaps;
   int dCoeffA= float2long(pdTaps[0]);
   int dCoeffB= float2long(pdTaps[1]);
   int dCoeffC= float2long(pdTaps[2]);
   int dCoeffD= float2long(pdTaps[3]);
   int dCoeffE= float2long(pdTaps[4]);

   dDC *= (dCoeffA + dCoeffB + dCoeffC + dCoeffD + dCoeffE);
   //dDC *= (pdTaps[0] + pdTaps[1] + pdTaps[2] + pdTaps[3] + pdTaps[4]);
#endif //UseDoubleCoeffs

   (void)nFECType;
   SASSERT(pState);
   SASSERT(pState->filter.nTaps == 5);
   SASSERT(pState->filter.dTapSpacing == 4);
   
   if (nSamplePos-8 >= 0) {
      a= (Double) pbSamples[nSamplePos-8];
   } else {
      a= 0.0;
   }

   if (nSamplePos-4 >= 0) {
      b= (Double) pbSamples[nSamplePos- 4];
   } else {
      b= 0.0;
   }
   
   c= (Double) pbSamples[nSamplePos+ 0];
   d= (Double) pbSamples[nSamplePos+ 4];
   e= (Double) pbSamples[nSamplePos+8];
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
         nByte >>= 1;
         if (a*dCoeffA + b*dCoeffB + c*dCoeffC + d*dCoeffD + e*dCoeffE
             > dDC) nByte |= 128;
         a=b;
         b=c;
         c=d;
         d=e;
         nSamplePos += 4;
         if (nSamplePos+8 < pState->SamplesPerLine ) {
            e= (Double) pbSamples[nSamplePos+8];
         } else {
            e= 0.0;
         }
      }
      pbDest[i]= nByte;
   }
   return 0;
}

#if 0
int NDSPGetBits_no_filter(unsigned char *pbDest, unsigned char *pbSamples,
                    int nSyncStart, double dDC, NDSPState *pState,
                    int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;

   (void)nFECType;
   SASSERT(pState);
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
         nByte >>= 1;
         if (pbSamples[nSamplePos] > dDC) nByte |= 128;

         nSamplePos += float2long(pState->dSampleRate); // dSR should be made non-floating point.
      }
      pbDest[i]= nByte;
   }
   return 0;
}
#endif //0

Double Sum_d(Double *a, int a_size)
{
   Double sum= 0.0;
   int i;
   
   SASSERT(a_size>=0);
   for (i= 0; i< a_size; i++) sum += a[i];
   return sum;
}

/* Get bits for fixed taps {-20, -18, ... 18, 20}
   See NDSPGetBits for more information */

int NDSPGetBits_21_2(unsigned char *pbDest, unsigned char *pbSamples,
                     int nSyncStart, double dDC, NDSPState *pState,
                     int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double *pdLine;
   Double *pdTaps;
   Double dDCa, dDCb;
   int nTaps;
   int nTapSpacing;
   int nTail;
   int index;
   unsigned char pbBuf[NABTS_BYTES_PER_LINE];
   /*unsigned char pbBufa[NABTS_BYTES_PER_LINE];*/
   /*unsigned char pbBufb[NABTS_BYTES_PER_LINE];*/

   SASSERT(pState);
   SASSERT(pState->filter.nTaps == 21);
   SASSERT(pState->filter.dTapSpacing == 2);

   SASSERT(!pState->bUsingScratch1);
   pState->bUsingScratch1= __LINE__;
   pdLine= pState->pdScratch1;
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >=
           pState->SamplesPerLine+(21-1)*2);
      
   pdTaps= pState->filter.pdTaps;
   nTaps= pState->filter.nTaps;
   nTapSpacing= float2long(pState->filter.dTapSpacing);
   nTail= (nTaps-1)/2;

   dDCa= dDC-1.0;
   dDCb= dDC+1.0;
   dDC *= Sum_d(pdTaps, nTaps);
   dDCa *= Sum_d(pdTaps, nTaps);
   dDCb *= Sum_d(pdTaps, nTaps);
   
   for (i= 0; i< pState->SamplesPerLine; i++) {
      index= float2long(i+nTail*nTapSpacing);
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= (Double) pbSamples[i];
   }

   for (i= 0; i< nTail*nTapSpacing; i++) {
      index= i;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
      index= float2long(i + pState->SamplesPerLine + nTail * nTapSpacing);
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }

   nSamplePos += 20;
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      /*int nBytea= 0;*/
      /*int nByteb= 0;*/
      for (j= 0; j< 8; j++) {
         Double dSum;
         nByte >>= 1;
#if 0         
         nBytea >>= 1;
         nByteb >>= 1;
#endif         
         SASSERT(nSamplePos-20 >= 0);
         SASSERT(nSamplePos+20 < sizeof(pState->pdScratch1)/sizeof(Double));
         dSum=
            pdTaps[ 0] * pdLine[nSamplePos-20] +
            pdTaps[ 1] * pdLine[nSamplePos-18] +
            pdTaps[ 2] * pdLine[nSamplePos-16] +
            pdTaps[ 3] * pdLine[nSamplePos-14] +
            pdTaps[ 4] * pdLine[nSamplePos-12] +
            pdTaps[ 5] * pdLine[nSamplePos-10] +
            pdTaps[ 6] * pdLine[nSamplePos- 8] +
            pdTaps[ 7] * pdLine[nSamplePos- 6] +
            pdTaps[ 8] * pdLine[nSamplePos- 4] +
            pdTaps[ 9] * pdLine[nSamplePos- 2] +
            pdTaps[10] * pdLine[nSamplePos+ 0] +
            pdTaps[11] * pdLine[nSamplePos+ 2] +
            pdTaps[12] * pdLine[nSamplePos+ 4] +
            pdTaps[13] * pdLine[nSamplePos+ 6] +
            pdTaps[14] * pdLine[nSamplePos+ 8] +
            pdTaps[15] * pdLine[nSamplePos+10] +
            pdTaps[16] * pdLine[nSamplePos+12] +
            pdTaps[17] * pdLine[nSamplePos+14] +
            pdTaps[18] * pdLine[nSamplePos+16] +
            pdTaps[19] * pdLine[nSamplePos+18] +
            pdTaps[20] * pdLine[nSamplePos+20];
         
         if (dSum > dDC) nByte |= 128;
#if 0         
         if (dSum > dDCa) nBytea |= 128;
         if (dSum > dDCb) nByteb |= 128;
#endif         
         nSamplePos += 5;
      }
      pbBuf[i]= nByte;
#if 0      
      pbBufa[i]= nBytea;
      pbBufb[i]= nByteb;
#endif      
   }
   {
      /*fec_error_class std, a, b;*/
      unsigned char *pbWinner;
#if 0      
      if (nFECType == NDSP_BUNDLE_FEC_1) {
         std= check_fec(pbBuf);
         a= check_fec(pbBufa);
         b= check_fec(pbBufb);
         if (std <= a && std <= b) {
            pbWinner= pbBuf;
         }
         else if (a<b) {
            pbWinner= pbBufa;
         } else {
            pbWinner= pbBufb;
         }
      }
      else
#endif         
      {
         pbWinner= pbBuf;
      }
      for (i= 0; i< pState->SamplesPerLine; i++) {
         pbDest[i]= pbWinner[i];
      }
   }
   pdLine= NULL;
   pState->bUsingScratch1= FALSE;
   return 0;
}

/* Get bits for variable fixed taps.
   Since in the general case this is inefficient, we check
   for the various variable-tap filter configurations we use.
   See NDSPGetBits for more information */

int NDSPGetBits_var(unsigned char *pbDest, unsigned char *pbSamples,
                    int nSyncStart, double dDC, NDSPState *pState,
                    int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double *pdLine;
   Double *pdTaps;
   int *pnTapLocs;
   int nTaps;
   int nFirstTap;
   int nLastTap;
   int index;
   int iSampRate = float2long(pState->dSampleRate);

   SASSERT(pState);

   if (FilterIsVar(&pState->filter, 3, 11, 9, 0)) {
      /* Taps are -33, -30 ... 24, 27 */
      return NDSPGetBits_var_3_11_9_0(pbDest, pbSamples, nSyncStart, dDC,
                                      pState, nFECType);
   }

   if (FilterIsVar(&pState->filter, 3, 11, 9, 2)) {
      /* Taps are -33, -30 ... 24, 27, X, Y
         where X and Y are any number */
      return NDSPGetBits_var_3_11_9_2(pbDest, pbSamples, nSyncStart, dDC,
                                      pState, nFECType);
   }

   if (FilterIsVar(&pState->filter, 2, 11, 9, 2)) {
      return NDSPGetBits_var_2_11_9_2(pbDest, pbSamples, nSyncStart, dDC,
                                      pState, nFECType);
   }

   if (FilterIsVar(&pState->filter, 5, 2, 2, 0)) {
      /* Taps are -10, -5, 0, 5, 10 */
      return NDSPGetBits_var_5_2_2_0(pbDest, pbSamples, nSyncStart, dDC,
                                     pState, nFECType);
   }

   /* ===== add another "case" for speedy filter for 4x here ===== */

   /* If we get this far in the field, we're probably doing the wrong
      thing!

      See NDSPGetBits for the general algorithm followed */

	// TODO - BOTH 4x and 4.7x


#ifdef DEBUG
   {
      static int nWarning= 0;
      nWarning++;
      if ((nWarning % 1024) == 0) {
         debug_printf(("Warning: doing slow convolution\n"));
      }
   }
#endif //DEBUG
   
   nFirstTap= pState->filter.nMinTap;
   nLastTap= pState->filter.nMaxTap;

   SASSERT(!pState->bUsingScratch1);
   pState->bUsingScratch1= __LINE__;
   pdLine= pState->pdScratch1;
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >=
           pState->SamplesPerLine-nFirstTap+nLastTap);
   
   pdTaps= pState->filter.pdTaps;
   pnTapLocs= pState->filter.pnTapLocs;
   nTaps= pState->filter.nTaps;

   dDC *= Sum_d(pdTaps, nTaps);
   
   for (i= 0; i< pState->SamplesPerLine; i++) {
      index= i-nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= (Double) pbSamples[i];
   }

   for (i= 0; i< -nFirstTap; i++) {
      index= i;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }

   for (i= 0; i< nLastTap; i++) {
      index= i + pState->SamplesPerLine -nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }
   
   nSamplePos += (-nFirstTap);
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j,k;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
         Double dSum= 0.0;
         nByte >>= 1;
         SASSERT(nSamplePos+nFirstTap >= 0);
         SASSERT(nSamplePos+nLastTap < sizeof(pState->pdScratch1)/sizeof(Double));
         for (k= 0; k< nTaps; k++) {
            dSum += pdTaps[k] * pdLine[nSamplePos + pnTapLocs[k]];
         }
         if (dSum > dDC) nByte |= 128;
         nSamplePos += iSampRate;
      }
      pbDest[i]= nByte;
   }
   pdLine= NULL;
   pState->bUsingScratch1= FALSE;
   return 0;
}

/* Check to see if the variable-tap filter matches the configuration
   we're looking for.

   nSpacing is the spacing between the "main" taps.
   nLeft is the number of "main" taps less than zero.
   nRight is the number of "main" taps greater than zero.
   
   nExtra is the number of "extra" variable taps at the end which don't
   necessarily fit in with nSpacing spacing.

   We want to match taps looking like:

   -nLeft * nSpacing, -(nLeft-1) * nSpacing, ... 0, ... (nRight-1) * nSpacing,
   nRight * nSpacing, X-sub-1, X-sub-2, ... X-sub-nExtra

   Where X-sub-N can be any number */
   
BOOL FilterIsVar(FIRFilter *pFilter, int nSpacing, int nLeft, int nRight,
                 int nExtra)
{
   int i;
   if (!pFilter->bVariableTaps) return FALSE;
   if (nLeft + nRight + 1 + nExtra != pFilter->nTaps) return FALSE;
   for (i= 0; i< nLeft + nRight + 1; i++) {
      if (pFilter->pnTapLocs[i] != (i-nLeft)*nSpacing) return FALSE;
   }
   return TRUE;
}

/* Special case DSP for variable-tap filter having taps
   -10, -5, 0, 5, 10.

   See NDSPGetBits for information on the algorithm, and
   NDSPGetBits_var for more details */
   
int NDSPGetBits_var_5_2_2_0(unsigned char *pbDest, unsigned char *pbSamples,
                             int nSyncStart, double dDC, NDSPState *pState,
                             int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double *pdLine;
   Double *pdTaps;
   int *pnTapLocs;
   int nTaps;
   int nFirstTap;
   int nLastTap;
   int index;
   int nSampleInc = float2long(pState->dSampleRate);

   SASSERT(pState);

   SASSERT(FilterIsVar(&pState->filter,5,2,2,0));
   nFirstTap= pState->filter.nMinTap;
   nLastTap= pState->filter.nMaxTap;
   
   SASSERT(!pState->bUsingScratch1);
   pState->bUsingScratch1= __LINE__;
   pdLine= pState->pdScratch1;
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >=
           pState->SamplesPerLine-nFirstTap+nLastTap);
   
   pdTaps= pState->filter.pdTaps;
   pnTapLocs= pState->filter.pnTapLocs;
   nTaps= pState->filter.nTaps;

   dDC *= Sum_d(pdTaps, nTaps);
   
   for (i= 0; i< pState->SamplesPerLine; i++) {
      index= i-nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= (Double) pbSamples[i];
   }

   for (i= 0; i< -nFirstTap; i++) {
      index= i;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }

   for (i= 0; i< nLastTap; i++) {
      index= i + pState->SamplesPerLine -nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }
   
   nSamplePos += (-nFirstTap);
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
         Double dSum= 0.0;
         nByte >>= 1;
         SASSERT(nSamplePos+nFirstTap >= 0);
         SASSERT(nSamplePos+nLastTap < sizeof(pState->pdScratch1)/sizeof(Double));
         dSum=
            pdTaps[0] * pdLine[nSamplePos - 10] +
            pdTaps[1] * pdLine[nSamplePos - 5] +
            pdTaps[2] * pdLine[nSamplePos + 0] +
            pdTaps[3] * pdLine[nSamplePos + 5] +
            pdTaps[4] * pdLine[nSamplePos + 10];
         
         if (dSum > dDC) nByte |= 128;
         nSamplePos += nSampleInc;
      }
      pbDest[i]= nByte;
   }
   pdLine= NULL;
   pState->bUsingScratch1= FALSE;
   return 0;
}


/* Special case DSP for variable-tap filter having taps
   -33, -30 ... 24, 27

   See NDSPGetBits for information on the algorithm, and
   NDSPGetBits_var for more details */

int NDSPGetBits_var_3_11_9_0(unsigned char *pbDest, unsigned char *pbSamples,
                             int nSyncStart, double dDC, NDSPState *pState,
                             int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double *pdLine;
   Double *pdTaps;
   int *pnTapLocs;
   int nTaps;
   int nFirstTap;
   int nLastTap;
   int index;
   int nSampleInc = float2long(pState->dSampleRate);

   SASSERT(pState);

   SASSERT(FilterIsVar(&pState->filter,3,11,9,0));
   nFirstTap= pState->filter.nMinTap;
   nLastTap= pState->filter.nMaxTap;
   
   SASSERT(!pState->bUsingScratch1);
   pState->bUsingScratch1= __LINE__;
   pdLine= pState->pdScratch1;
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >=
           pState->SamplesPerLine-nFirstTap+nLastTap);
   
   pdTaps= pState->filter.pdTaps;
   pnTapLocs= pState->filter.pnTapLocs;
   nTaps= pState->filter.nTaps;

   dDC *= Sum_d(pdTaps, nTaps);
   
   for (i= 0; i< pState->SamplesPerLine; i++) {
      index= i-nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= (Double) pbSamples[i];
   }

   for (i= 0; i< -nFirstTap; i++) {
      index= i;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }

   for (i= 0; i< nLastTap; i++) {
      index= i + pState->SamplesPerLine -nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }
   
   nSamplePos += (-nFirstTap);
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
         Double dSum= 0.0;
         nByte >>= 1;
         SASSERT(nSamplePos+nFirstTap >= 0);
         SASSERT(nSamplePos+nLastTap < sizeof(pState->pdScratch1)/sizeof(Double));
         dSum=
            pdTaps[0] * pdLine[nSamplePos - 33] +
            pdTaps[1] * pdLine[nSamplePos - 30] +
            pdTaps[2] * pdLine[nSamplePos - 27] +
            pdTaps[3] * pdLine[nSamplePos - 24] +
            pdTaps[4] * pdLine[nSamplePos - 21] +
            pdTaps[5] * pdLine[nSamplePos - 18] +
            pdTaps[6] * pdLine[nSamplePos - 15] +
            pdTaps[7] * pdLine[nSamplePos - 12] +
            pdTaps[8] * pdLine[nSamplePos - 9] +
            pdTaps[9] * pdLine[nSamplePos - 6] +
            pdTaps[10] * pdLine[nSamplePos - 3] +
            pdTaps[11] * pdLine[nSamplePos + 0] +
            pdTaps[12] * pdLine[nSamplePos + 3] +
            pdTaps[13] * pdLine[nSamplePos + 6] +
            pdTaps[14] * pdLine[nSamplePos + 9] +
            pdTaps[15] * pdLine[nSamplePos + 12] +
            pdTaps[16] * pdLine[nSamplePos + 15] +
            pdTaps[17] * pdLine[nSamplePos + 18] +
            pdTaps[18] * pdLine[nSamplePos + 21] +
            pdTaps[19] * pdLine[nSamplePos + 24] +
            pdTaps[20] * pdLine[nSamplePos + 27];

         if (dSum > dDC) nByte |= 128;
         nSamplePos += nSampleInc;
      }
      pbDest[i]= nByte;
   }
   pdLine= NULL;
   pState->bUsingScratch1= FALSE;
   return 0;
}

/* Special case DSP for variable-tap filter having taps
   -33, -30 ... 24, 27, X, Y

   where X and Y are any number

   See NDSPGetBits for information on the algorithm, and
   NDSPGetBits_var for more details */

int NDSPGetBits_var_3_11_9_2(unsigned char *pbDest, unsigned char *pbSamples,
                             int nSyncStart, double dDC, NDSPState *pState,
                             int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double *pdLine;
   Double *pdTaps;
   int *pnTapLocs;
   int nTaps;
   int nFirstTap;
   int nLastTap;
   int index;
   int nSampleInc = float2long(pState->dSampleRate);

   SASSERT(pState);

   SASSERT(FilterIsVar(&pState->filter,3,11,9,2));
   nFirstTap= pState->filter.nMinTap;
   nLastTap= pState->filter.nMaxTap;
   
   SASSERT(!pState->bUsingScratch1);
   pState->bUsingScratch1= __LINE__;
   pdLine= pState->pdScratch1;
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >=
           pState->SamplesPerLine-nFirstTap+nLastTap);
   
   pdTaps= pState->filter.pdTaps;
   pnTapLocs= pState->filter.pnTapLocs;
   nTaps= pState->filter.nTaps;

   dDC *= Sum_d(pdTaps, nTaps);
   
   for (i= 0; i< pState->SamplesPerLine; i++) {
      index= i-nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= (Double) pbSamples[i];
   }

   for (i= 0; i< -nFirstTap; i++) {
      index= i;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }

   for (i= 0; i< nLastTap; i++) {
      index= i + pState->SamplesPerLine -nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }
   
   nSamplePos += (-nFirstTap);
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
         Double dSum= 0.0;
         nByte >>= 1;
         SASSERT(nSamplePos+nFirstTap >= 0);
         SASSERT(nSamplePos+nLastTap < sizeof(pState->pdScratch1)/sizeof(Double));
         dSum=
            pdTaps[0] * pdLine[nSamplePos - 33] +
            pdTaps[1] * pdLine[nSamplePos - 30] +
            pdTaps[2] * pdLine[nSamplePos - 27] +
            pdTaps[3] * pdLine[nSamplePos - 24] +
            pdTaps[4] * pdLine[nSamplePos - 21] +
            pdTaps[5] * pdLine[nSamplePos - 18] +
            pdTaps[6] * pdLine[nSamplePos - 15] +
            pdTaps[7] * pdLine[nSamplePos - 12] +
            pdTaps[8] * pdLine[nSamplePos - 9] +
            pdTaps[9] * pdLine[nSamplePos - 6] +
            pdTaps[10] * pdLine[nSamplePos - 3] +
            pdTaps[11] * pdLine[nSamplePos + 0] +
            pdTaps[12] * pdLine[nSamplePos + 3] +
            pdTaps[13] * pdLine[nSamplePos + 6] +
            pdTaps[14] * pdLine[nSamplePos + 9] +
            pdTaps[15] * pdLine[nSamplePos + 12] +
            pdTaps[16] * pdLine[nSamplePos + 15] +
            pdTaps[17] * pdLine[nSamplePos + 18] +
            pdTaps[18] * pdLine[nSamplePos + 21] +
            pdTaps[19] * pdLine[nSamplePos + 24] +
            pdTaps[20] * pdLine[nSamplePos + 27] +
            pdTaps[21] * pdLine[nSamplePos + pnTapLocs[21]] +
            pdTaps[22] * pdLine[nSamplePos + pnTapLocs[22]];

         if (dSum > dDC) nByte |= 128;
         nSamplePos += nSampleInc;
      }
      pbDest[i]= nByte;
   }
   pdLine= NULL;
   pState->bUsingScratch1= FALSE;
   return 0;
}

int NDSPGetBits_var_2_11_9_2(unsigned char *pbDest, unsigned char *pbSamples,
                             int nSyncStart, double dDC, NDSPState *pState,
                             int nFECType)
{
   int nSamplePos= nSyncStart;
   int i;
   Double *pdLine;
   Double *pdTaps;
   int *pnTapLocs;
   int nTaps;
   int nFirstTap;
   int nLastTap;
   int index;
   int nSampleInc = float2long(pState->dSampleRate);

   SASSERT(pState);

   SASSERT(FilterIsVar(&pState->filter,2,11,9,2));
   nFirstTap= pState->filter.nMinTap;
   nLastTap= pState->filter.nMaxTap;
   
   SASSERT(!pState->bUsingScratch1);
   pState->bUsingScratch1= __LINE__;
   pdLine= pState->pdScratch1;
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >=
           pState->SamplesPerLine-nFirstTap+nLastTap);
   
   pdTaps= pState->filter.pdTaps;
   pnTapLocs= pState->filter.pnTapLocs;
   nTaps= pState->filter.nTaps;

   dDC *= Sum_d(pdTaps, nTaps);
   
   for (i= 0; i< pState->SamplesPerLine; i++) {
      index= i-nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= (Double) pbSamples[i];
   }

   for (i= 0; i< -nFirstTap; i++) {
      index= i;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }

   for (i= 0; i< nLastTap; i++) {
      index= i + pState->SamplesPerLine -nFirstTap;
      SASSERT(index >= 0 && index < sizeof(pState->pdScratch1)/sizeof(Double));
      pdLine[index]= dDC;
   }
   
   nSamplePos += (-nFirstTap);
   
   for (i= 0; i< NABTS_BYTES_PER_LINE; i++) {
      int j;
      int nByte= 0;
      for (j= 0; j< 8; j++) {
         Double dSum= 0.0;
         nByte >>= 1;
         SASSERT(nSamplePos+nFirstTap >= 0);
         SASSERT(nSamplePos+nLastTap < sizeof(pState->pdScratch1)/sizeof(Double));
         dSum=
            pdTaps[0] * pdLine[nSamplePos - 22] +
            pdTaps[1] * pdLine[nSamplePos - 20] +
            pdTaps[2] * pdLine[nSamplePos - 18] +
            pdTaps[3] * pdLine[nSamplePos - 16] +
            pdTaps[4] * pdLine[nSamplePos - 14] +
            pdTaps[5] * pdLine[nSamplePos - 12] +
            pdTaps[6] * pdLine[nSamplePos - 10] +
            pdTaps[7] * pdLine[nSamplePos - 8] +
            pdTaps[8] * pdLine[nSamplePos - 6] +
            pdTaps[9] * pdLine[nSamplePos - 4] +
            pdTaps[10] * pdLine[nSamplePos - 2] +
            pdTaps[11] * pdLine[nSamplePos + 0] +
            pdTaps[12] * pdLine[nSamplePos + 2] +
            pdTaps[13] * pdLine[nSamplePos + 4] +
            pdTaps[14] * pdLine[nSamplePos + 6] +
            pdTaps[15] * pdLine[nSamplePos + 8] +
            pdTaps[16] * pdLine[nSamplePos + 10] +
            pdTaps[17] * pdLine[nSamplePos + 12] +
            pdTaps[18] * pdLine[nSamplePos + 14] +
            pdTaps[19] * pdLine[nSamplePos + 16] +
            pdTaps[20] * pdLine[nSamplePos + 18] +
            pdTaps[21] * pdLine[nSamplePos + pnTapLocs[21]] +
            pdTaps[22] * pdLine[nSamplePos + pnTapLocs[22]];

         if (dSum > dDC) nByte |= 128;
         nSamplePos += nSampleInc;
      }
      pbDest[i]= nByte;
   }
   pdLine= NULL;
   pState->bUsingScratch1= FALSE;
   return 0;
}

#ifdef DEBUG
int debug_equalize= 0;

void print_filter(FIRFilter *pFilt)
{
   if (pFilt->bVariableTaps) {
      int i;
      debug_printf(("[FIR %dV [", pFilt->nTaps));
      for (i= 0; i< pFilt->nTaps; i++) {
         if (i) debug_printf((" "));
         debug_printf(("%d:%s", pFilt->pnTapLocs[i], flPrintf(pFilt->pdTaps[i],4)));
      }
      debug_printf(("]]"));
   } else {
      debug_printf(("[FIR %dx%s ", pFilt->nTaps, flPrintf(pFilt->dTapSpacing,3)));
      printarray_d1(pFilt->pdTaps, pFilt->nTaps);
      debug_printf(("]"));
   }
}

void printarray_d1(Double *arr, int n)
{
   int i;

   debug_printf(("["));
   for (i= 0; i< n; i++) {
      if (i) debug_printf((" "));
      debug_printf(("%s", flPrintf(arr[i], 2)));
   }
   debug_printf(("]"));
}

void printarray_ed1(Double *arr, int n)
{
   int i;
   debug_printf(("["));
   for (i= 0; i< n; i++) {
      if (i) debug_printf((" "));
      debug_printf(("%s", flPrintf(arr[i], 4)));
   }
   debug_printf(("]"));
}

void printarray_d2(Double *arr, int a_size, int b_size)
{
   int a,b;
   for (a= 0; a< a_size; a++) {
      debug_printf(("|"));
      for (b= 0; b< b_size; b++) {
         if (b) debug_printf((" "));
         debug_printf(("%s", flPrintf(arr[a*b_size+b], 4)));
      }
      debug_printf(("|\n"));
   }
   debug_printf(("\n"));
}

void printarray_ed2(Double *arr, int a_size, int b_size)
{
   int a,b;
   for (a= 0; a< a_size; a++) {
      debug_printf(("|"));
      for (b= 0; b< b_size; b++) {
         if (b) debug_printf((" "));
         debug_printf(("%s", flPrintf(arr[a*b_size+b], 4)));
      }
      debug_printf(("|\n"));
   }
   debug_printf(("\n"));
}
#endif //DEBUG


#ifdef DEBUG_AREF
#define a2d(arr,a,b,abound,bbound) (EASSERT(0<=(a)&&(a)<(abound)), \
                                    EASSERT(0<=(b)&&(b)<(bbound)), \
                                    (arr)[(a)*(bbound)+(b)])
#else
#define a2d(arr,a,b,abound,bbound) ((arr)[(a)*(bbound)+(b)])
#endif

#ifdef DEBUG_AREF
#define a1d(arr,a,abound) (EASSERT(0<=(a)&&(a)<(abound)), \
                           (arr)[a])
#else
#define a1d(arr,a,abound) ((arr)[a])
#endif
   
#define aI(a,b) a2d(I,a,b,nFilterLength,nDesiredOutputLength)

#define aItI(a,b) a2d(ItI,a,b,nFilterLength,nFilterLength)

#define aIto(a) a1d(Ito,a,nFilterLength)

#define ao(a) a1d(o,a,nDesiredOutputLength)   

#ifdef DEBUG_AREF
#define aInput(a) (EASSERT(nMinInputIndex<=(a)&&(a)<=nMaxInputIndex), \
                   pfInput[a])
#else
#define aInput(a) (pfInput[a])
#endif   

#define EQ_TOL .000001

void SubtractMean_d(Double *pfOutput, Double *pfInput, int nLen)
{
   int i;
   Double dMean;
   if (!nLen) return;
   dMean= Mean_d(pfInput, nLen);
   for (i= 0; i< nLen; i++) pfOutput[i]= pfInput[i] - dMean;
}

/* Modification of above:
   Filter now has a variable number of taps */

void FillGCRSignals()
{
   int i;

   SubtractMean_d(g_pdGCRSignal1, g_pdGCRSignal1, g_nNabtsGcrSize);
   
   for (i= 0; i< g_nNabtsGcrSize; i++) g_pdGCRSignal1[i] *= 100;
   for (i= 0; i< g_nNabtsGcrSize; i++) g_pdGCRSignal2[i]= -g_pdGCRSignal1[i];
}

void NormalizeSyncSignal()
{
   SubtractMean_d(g_pdSync, g_pdSync, g_nNabtsSyncSize);
}







Double Mean_d(Double *a, int a_size)
{
   Double sum= 0.0;
   int i;
   
   SASSERT(a_size>0);
   for (i= 0; i< a_size; i++) sum += a[i];
   return sum / a_size;
}

Double Mean_8(unsigned char *a, int a_size)
{
   int sum= 0.0;
   int i;
   
   SASSERT(a_size>0);
   for (i= 0; i< a_size; i++) sum += a[i];
   return ((Double) sum) / a_size;
}

void Mult_d(Double *dest, Double *src, int size, Double factor)
{
   int i;
   for (i= 0; i< size; i++) dest[i]= src[i]*factor;
}

int Sum_16(short *a, int a_size)
{
   int ret= 0;
   int i;
   
   for (i= 0; i< a_size; i++) ret += a[i];
   return ret;
}

/* Try to match the input signal with a given EqualizeMatch desired
   signal template.

   If there is an apparent match, return offset at which match is found. */
   
int MatchWithEqualizeSignal(NDSPState *pState,
                            unsigned char *pbSamples,
                            EqualizeMatch *eqm,
                            int *pnOffset,
                            Double *pdMaxval,
                            BOOL bNegativeOK)
{
   Double dMaxval= 0.0;
   Double dMinval= 0.0;
   Double *pdSamples;
   Double *pdConv;
   int nMaxindex= 0;
   int nMinindex= 0;
   int i;
   int nStatus= 0;
   
   if (!pState || pState->uMagic != NDSP_STATE_MAGIC)
      return NDSP_ERROR_ILLEGAL_NDSP_STATE;

   SASSERT(!pState->bUsingScratch1);
   SASSERT(sizeof(pState->pdScratch1)/sizeof(Double) >= pState->SamplesPerLine);
   pdSamples= pState->pdScratch1;
   pState->bUsingScratch1= __LINE__;
   
   SASSERT(!pState->bUsingScratch2);
   SASSERT(sizeof(pState->pdScratch2)/sizeof(Double) >= pState->SamplesPerLine);
   pdConv= pState->pdScratch2;
   pState->bUsingScratch2= __LINE__;
   
   Copy_d_8(pdSamples, pbSamples, pState->SamplesPerLine);

   Convolve_d_d_d(pdConv,
                  eqm->nSignalStartConv, eqm->nSignalEndConv,
                  pdSamples, 0, pState->SamplesPerLine-1, eqm->nSignalSampleRate,
                  eqm->pdSignal, 0, eqm->nSignalSize, 1,
                  TRUE);
   
   for (i= eqm->nSignalStartConv; i<= eqm->nSignalEndConv; i++) {
      if (pdConv[i] > dMaxval) {
         dMaxval= pdConv[i];
         nMaxindex= i;
      }
      if (pdConv[i] < dMinval) {
         dMinval= pdConv[i];
         nMinindex= i;
      }
   }

   if ((-dMinval) > dMaxval && bNegativeOK) {
      dMaxval= dMinval;
      nMaxindex= nMinindex;
   }

   pdConv= NULL;
   pState->bUsingScratch2= FALSE;
   
   if (pnOffset) { (*pnOffset)= nMaxindex; }
   if (pdMaxval) { (*pdMaxval)= dMaxval; }

   pdSamples= NULL;
   pState->bUsingScratch1= FALSE;
   return nStatus;
}

/* Adaptive equalizer.

   Set the coefficients on a simple FIR filter such that the input
   waveform matches most closely the output (minimizing the sum of
   the squares of the error terms).

   i= input signal (vector)
   o= desirect output signal (vector)
   c= coefficients of FIR (vector)

   e= error (scalar)

   e= |convolution(i,c) - o|^2

   We construct a matrix, I, such that

   I*c = convolution(i,c)

   Now we attempt to minimize e:

   e= |I*c - o|^2

   This can be solved as the simple system of linear equations:
   
   (transpose(I)*I)*c = (transpose(I)*o)

   */

/* pfDesiredOutput must be defined over 0 ... nDesiredOutputLength-1 */
/* pfInput must be defined over
   -(nFilterLength-1)/2 ... nDesiredOutputLength-1 + (nFilterLength-1)/2
   */


BOOL EqualizeVar(NDSPState *pState,
                 Double *pfInput, int nMinInputIndex, int nMaxInputIndex,
                 Double *pfDesiredOutput, int nDesiredOutputLength,
                 int nOutputSpacing, FIRFilter *pFilter)
{
   int nFilterLength= pFilter->nTaps;
   /* We spend most of our time in the n^3 multiplication of ItI,
      so we choose the following order of indices */

   /* ItI[nFilterLength][nFilterLength] */
   /* (transpose(I) * I) */
   Double *ItI;
   
   /* Ito[nFilterLength] */
   /* (transpose(I) * o) */
   Double *Ito;

   /* o[nDesiredOutputLength] */
   Double *o;
   
   BOOL bRet=FALSE;

   int x,y,i;

   SASSERT(!pState->bUsingScratch3);
   SASSERT(sizeof(pState->pdScratch3) >=
           nFilterLength * nFilterLength * sizeof(Double));
   ItI= pState->pdScratch3;
   pState->bUsingScratch3= __LINE__;
   
   SASSERT(!pState->bUsingScratch4);
   SASSERT(sizeof(pState->pdScratch4) >=
           nFilterLength * sizeof(Double));
   Ito= pState->pdScratch4;
   pState->bUsingScratch4= __LINE__;
   
   SASSERT(!pState->bUsingScratch5);
   SASSERT(sizeof(pState->pdScratch5) >=
           nDesiredOutputLength * sizeof(Double));
   o= pState->pdScratch5;
   pState->bUsingScratch5= __LINE__;
   
   for (i= 0; i< nDesiredOutputLength; i++) {
      o[i]= pfDesiredOutput[i];
   }
   /*memcpy(o, pfDesiredOutput, nDesiredOutputLength * sizeof(Double));*/
   
   SASSERT(nFilterLength >= 1);

   /* Create (It)I */
   /* Since ItI is symmetric, we only have to do a little over
      half the multiplies */
   
   for (x= 0; x< nFilterLength; x++) {
      for (y= 0; y<=x; y++) {
         Double fSum= 0.0;
         for (i= 0; i< nDesiredOutputLength; i++) {
            fSum +=
               aInput(pFilter->pnTapLocs[x]+nOutputSpacing*i) *
               aInput(pFilter->pnTapLocs[y]+nOutputSpacing*i);
         }
         aItI(x,y)= aItI(y,x)= fSum;
      }
   }

   /* Create (It)o */

   for (x= 0; x< nFilterLength; x++) {
      Double fSum= 0.0;
      for (i= 0; i< nDesiredOutputLength; i++) {
         fSum += aInput(pFilter->pnTapLocs[x]+nOutputSpacing*i) *
            ao(i);
      }
      aIto(x)= fSum;
   }

#ifdef DEBUG_VERBOSE         
   if (debug_equalize) {
      debug_printf(("ItI:\n"));
      printarray_ed2(ItI, nFilterLength, nFilterLength);
      
      debug_printf(("Ito:\n"));
      printarray_ed1(Ito, nFilterLength);
      debug_printf(("\n"));
   }
#endif
   
   /* Solve (ItI)c = Ito

      Since Gaussian elimination is the simplest, we've implemented it first.
      
      We can state a priori that no two coefficients are even closely
      dependent in the solution, given that the input and the output
      are related enough to pass the original confidence test.

      Therefore, if we find ItI to be to be close to singular, we can
      just reject it the sample, claiming that the GCR locater didn't do
      it's job.  This should in fact never happen.

      */

   /* We treat ItI as having indices [y][x] to speed the following. */
   
   for (y= 0; y< nFilterLength; y++) {
      Double fMax= 0.0;
      int   nMax= 0;
      
      /* Find the largest magnitude value in this column to swap with */
      for (i= y; i< nFilterLength; i++) {
         Double fVal= aItI(i,y);
     if (fVal < 0) fVal = -fVal;
         if (fVal > fMax) { fMax= fVal; nMax= i; }
      }
      
      /* Swap the rows */
      if (fMax < EQ_TOL) {
#ifdef DEBUG_VERBOSE         
         debug_printf(("Near-singular matrix in Equalize\n"));
         debug_printf(("Sync correlator must be broken\n"));
#endif         
         bRet= FALSE;
         goto exit;
      }
         
      if (nMax != y) {
         Double fTmp;
         for (x= y; x< nFilterLength; x++) {
            fTmp= aItI(y,x);
            aItI(y,x)= aItI(nMax,x);
            aItI(nMax,x)= fTmp;
         }
         fTmp= aIto(y);
         aIto(y)= aIto(nMax);
         aIto(nMax)= fTmp;
      }

      for (i= y+1; i< nFilterLength; i++) {
         Double fDependence= aItI(i,y) / aItI(y,y);
         aItI(i,y)= 0.0;
         for (x= y+1; x< nFilterLength; x++) {
            aItI(i,x) -= aItI(y,x) * fDependence;
         }
         aIto(i) -= aIto(y) * fDependence;
      }
   }

   /* Now ItI is upper diagonal */

   for (y= nFilterLength - 1; y >= 0; y--) {
      for (i= 0; i< y; i++) {
         Double fDependence= aItI(i,y) / aItI(y,y);
         aItI(i,y)= 0.0;
         aIto(i) -= aIto(y) * fDependence;
      }
   }

   /* Now divide Ito by the diagonals */
   for (i= 0; i< nFilterLength; i++) {
      aIto(i) /= aItI(i,i);
   }
   
   /* Ito now contains the answer */
   /*memcpy(pfFilter, Ito, nFilterLength * sizeof(Double));*/
   for (i= 0; i< nFilterLength; i++) {
      pFilter->pdTaps[i]= Ito[i];
   }
   bRet= 1;
  exit:
   pState->bUsingScratch3= FALSE;
   pState->bUsingScratch4= FALSE;
   pState->bUsingScratch5= FALSE;
   return bRet;
}


int get_sync_samples(unsigned long newHZ) 
{
  debug_printf(("get_sync_samples(%lu) entered\n", newHZ));

  memset(g_pdSync, 0, MAX_NABTS_SAMPLES_PER_LINE);
  switch (newHZ) {
      case KS_VBISAMPLINGRATE_4X_NABTS:
          memcpy(g_pdSync, g_pdSync4, NABSYNC_SIZE);
          break;
      case KS_VBISAMPLINGRATE_47X_NABTS:
          memcpy(g_pdSync, g_pdSync47, NABSYNC_SIZE);
          break;
      case KS_VBISAMPLINGRATE_5X_NABTS:
          memcpy(g_pdSync, g_pdSync5, NABSYNC_SIZE);
          break;
	  default:
		  // Unknown sampling rate
         debug_printf(("get_sync_samples: unknown sampling rate %lu\n", newHZ));
         debug_breakpoint();
		 break;
  }

  return g_nNabtsSyncSize;
}

int get_gcr_samples(unsigned long newHZ) 
{
  int   i;

  debug_printf(("get_gcr_samples(%lu) entered\n", newHZ));

  switch (newHZ) {
      case KS_VBISAMPLINGRATE_4X_NABTS:
          for (i=0; i<GCR_SIZE; i++) g_pdGCRSignal1[i] = g_pdGCRSignal1_4[i];
          break;
      case KS_VBISAMPLINGRATE_47X_NABTS:
          for (i=0; i<GCR_SIZE; i++) g_pdGCRSignal1[i] = g_pdGCRSignal1_47[i];
          break;
      case KS_VBISAMPLINGRATE_5X_NABTS:
          for (i=0; i<GCR_SIZE; i++) g_pdGCRSignal1[i] = g_pdGCRSignal1_5[i];
          break;
	  default:
		  // Unknown sampling rate
          debug_printf(("get_gcr_samples: unknown sampling rate %lu\n", newHZ));
          debug_breakpoint();
		  break;
  }

  return g_nNabtsGcrSize;
}


void onResample(double sample_multiple, int syncLen, int gcrLen) 
{
  double ratio;
  int nSize;
  int i;

  debug_printf(("onResample(%s, %d, %d) entered\n",
               flPrintf(sample_multiple, 2), syncLen, gcrLen));

  /* sync */
  eqmatchNabtsSync.nSignalSize = syncLen;
  eqmatchNabtsSync.nSignalStartConv =
    float2long((double)NABSYNC_START_DETECT * sample_multiple/5.0);
  eqmatchNabtsSync.nSignalEndConv = 
     float2long((double)NABSYNC_END_DETECT * sample_multiple/5.0);
  eqmatchNabtsSync.pdSignal = g_pdSync;

  /* gcr */
  eqmatchGCR1.nSignalSize = gcrLen;
  eqmatchGCR1.nSignalStartConv =
    float2long((double)GCR_START_DETECT * sample_multiple/5.0);
  eqmatchGCR1.nSignalEndConv =
    float2long((double)GCR_END_DETECT * sample_multiple/5.0);
  eqmatchGCR1.pdSignal = g_pdGCRSignal1;

  eqmatchGCR2.nSignalSize = gcrLen;
  eqmatchGCR2.nSignalStartConv =
    float2long((double)GCR_START_DETECT * sample_multiple/5.0);
  eqmatchGCR2.nSignalEndConv =
    float2long((double)GCR_END_DETECT * sample_multiple/5.0);
  eqmatchGCR2.pdSignal = g_pdGCRSignal2;

  /* scale index arrays for NDSPDetectConfidence: */
  ratio = sample_multiple/5.0;
  nSize = sizeof(pnGCRPositiveIndices)/sizeof(int);
  for (i=0; i<nSize; i++)
    pnGCRPositiveIndices[i] = float2long((double)pnGCRPositiveIndices[i]*ratio);

  nSize = sizeof(pnGCRNegativeIndices)/sizeof(int);
  for (i=0; i<nSize; i++)
    pnGCRNegativeIndices[i] = float2long((double)pnGCRNegativeIndices[i]*ratio);

}

void NDSPComputeNewSampleRate(unsigned long new_rate, unsigned long old_rate)
{
  int gcrLen, syncLen;
  debug_printf(("NDSPComputeNewSampleRate(%lu, %lu) entered\n", new_rate, old_rate));
  gcrLen = get_gcr_samples(new_rate);
  syncLen = get_sync_samples(new_rate);
  onResample((double)new_rate / KS_VBIDATARATE_NABTS, syncLen, gcrLen);
}


void NDSPReset()
{

  memcpy(pnGCRPositiveIndices, pnGCRPositiveIndices0, 26*sizeof(int));
  memcpy(pnGCRNegativeIndices, pnGCRNegativeIndices0, 19*sizeof(int));
 
  memcpy(g_pdGCRSignal1, g_pdGCRSignal1_5, GCR_SIZE*sizeof(Double));
  memset(g_pdGCRSignal2, 0, GCR_SIZE*sizeof(Double));
  memcpy(g_pdSync, g_pdSync5, NABSYNC_SIZE*sizeof(Double));
  
  eqmatchNabtsSync.nSignalSize = NABSYNC_SIZE;
  eqmatchNabtsSync.nSignalStartConv = NABSYNC_START_DETECT;
  eqmatchNabtsSync.nSignalEndConv = NABSYNC_END_DETECT;
  eqmatchNabtsSync.pdSignal = g_pdSync;

  eqmatchGCR1.nSignalSize = GCR_SIZE;
  eqmatchGCR1.nSignalStartConv = GCR_START_DETECT;
  eqmatchGCR1.nSignalEndConv = GCR_END_DETECT;
  eqmatchGCR1.pdSignal = g_pdGCRSignal1;

  eqmatchGCR2.nSignalSize = GCR_SIZE;
  eqmatchGCR2.nSignalStartConv = GCR_START_DETECT;
  eqmatchGCR2.nSignalEndConv = GCR_END_DETECT;
  eqmatchGCR2.pdSignal = g_pdGCRSignal2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\nabtsdsp.h ===
#ifdef __cplusplus
extern "C" {
#endif

/* nabtsdsp.c */
Double dmin (Double x, Double y);
Double dmin3 (Double x, Double y, Double z);
int imin (int x, int y);
int imin3 (int x, int y, int z);
Double dmax (Double x, Double y);
Double dmax3 (Double x, Double y, Double z);
int imax (int x, int y);
int imax3 (int x, int y, int z);
int iabs (int x);
int idivceil (int a, int b);
int idivfloor (int a, int b);
void NDSPInitGlobals (void);
NDSPState *NDSPStateNew (void *memory);
int NDSPStateSetSampleRate(NDSPState* pState, unsigned long samp_rate);
int NDSPStateDestroy (NDSPState *pState);
int NDSPStateConnectToFEC (NDSPState *pDSPState, NFECState *pFECState);
int NDSPStartRetrain (NDSPState *pState);
int NDSPResetFilter (NDSPState *pState);
void Copy_d_8 (Double *pfOutput, unsigned char *pbInput, int nLen);
void Convolve_d_d_filt_var (NDSPState *pState, Double *dest, int dest_begin, int dest_end, Double *a, int a_begin, int a_end, FIRFilter *pFilt, BOOL bSubtractMean);
void Convolve_d_d_filt (Double *dest, int dest_begin, int dest_end, Double *a, int a_begin, int a_end, FIRFilter *pFilt, BOOL bSubtractMean);
void Convolve_d_d_d (Double *dest, int dest_begin, int dest_end, Double *a, Double a_begin, Double a_end, Double a_step, Double *b, Double b_begin, Double b_end, Double b_step, BOOL bSubtractMean);
void RecalcVariableFIRFilterBounds (FIRFilter *pFilter);
void AddToVariableFIRFilter (FIRFilter *pFilter, int nCenterPos, int nLeftTaps, int nRightTaps, int nTapSpacing);
void ClearVariableFIRFilter (FIRFilter *pFilter);
void CopyFIRFilter (FIRFilter *pfilterDest, FIRFilter *pfilterSrc);
int DoEqualizeFromGCRs (NDSPState *pState);
int DoEqualizeFromNabsync (NDSPState *pState);
int DoGCREqualFromSignal (NDSPState *pState, NDSPSigMatch *sigmatch, EqualizeMatch *eqm, FIRFilter *pfilterTemplate, int nAddTaps);
int DoEqualize (NDSPState *pState);
int ComputeOffsets (KS_VBIINFOHEADER *pVBIINFO, int *pnOffsetData, int *pnOffsetSamples);
int NDSPProcessGCRLine (NDSPGCRStats *pLineStats, unsigned char *pbSamples, NDSPState *pState, int nFieldNumber, int nLineNumber, KS_VBIINFOHEADER *pVBIINFO);
void NDSPResetGCRAcquisition (NDSPState *pState);
void NDSPResetNabsyncAcquisition (NDSPState *pState);
int NDSPAvgSigs (NDSPState *pState, Double *pdDest, NDSPSigMatch *psm, Double *dConvRet);
void NDSPTryToInsertSig(NDSPState *pState, NDSPSigMatch *psm, Double dMaxval,
                        unsigned char *pbSamples, int nOffset);
void NDSPAcquireNabsync (NDSPState *pState, unsigned char *pbSamples);
void NDSPAcquireGCR (NDSPState *pState, unsigned char *pbSamples);
int NDSPSyncBytesToConfidence (unsigned char *pbSyncBytes);
int NDSPDetectGCRConfidence (unsigned char *pbSamples);
int NDSPPartialDecodeLine (unsigned char *pbDest, NDSPLineStats *pLineStats, unsigned char *pbSamples, NDSPState *pState, int nFECType, int nFieldNumber, int nLineNumber, int nStart, int nEnd, KS_VBIINFOHEADER *pVBIINFO);
int NDSPDecodeLine (unsigned char *pbDest, NDSPLineStats *pLineStats, unsigned char *pbSamples, NDSPState *pState, int nFECType, int nFieldNumber, int nLineNumber, KS_VBIINFOHEADER *pVBIINFO);
int NDSPStateSetFilter (NDSPState *pState, FIRFilter *filter, int nFilterSize);
void NormalizeFilter (FIRFilter *pFilter);
void NDSPDecodeFindSync (unsigned char *pbSamples, Double *pdSyncConfidence, Double *pdSyncStart, Double *pdDC, Double *pdAC, NDSPState *pState, KS_VBIINFOHEADER *pVBIINFO);
int NDSPGetBits (unsigned char *pbDest, unsigned char *pbSamples, Double dSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_5_5 (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_5_4 (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_5_47 (unsigned char *pbDest, unsigned char *pbSamples, Double dSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_no_filter (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
Double Sum_d (Double *a, int a_size);
int NDSPGetBits_21_2 (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_var (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
BOOL FilterIsVar (FIRFilter *pFilter, int nSpacing, int nLeft, int nRight, int nExtra);
int NDSPGetBits_var_5_2_2_0 (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_var_3_11_9_0 (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_var_3_11_9_2 (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
int NDSPGetBits_var_2_11_9_2 (unsigned char *pbDest, unsigned char *pbSamples, int nSyncStart, double dDC, NDSPState *pState, int nFECType);
void print_filter (FIRFilter *pFilt);
void printarray_d1 (Double *arr, int n);
void printarray_ed1 (Double *arr, int n);
void printarray_d2 (Double *arr, int a_size, int b_size);
void printarray_ed2 (Double *arr, int a_size, int b_size);
void SubtractMean_d (Double *pfOutput, Double *pfInput, int nLen);
void FillGCRSignals (void);
void NormalizeSyncSignal (void);
Double Mean_d (Double *a, int a_size);
Double Mean_8 (unsigned char *a, int a_size);
void Mult_d (Double *dest, Double *src, int size, Double factor);
int Sum_16 (short *a, int a_size);
int MatchWithEqualizeSignal (NDSPState *pState, unsigned char *pbSamples, EqualizeMatch *eqm, int *pnOffset, Double *pdMaxval, BOOL bNegativeOK);
BOOL EqualizeVar (NDSPState *pState, Double *pfInput, int nMinInputIndex, int nMaxInputIndex, Double *pfDesiredOutput, int nDesiredOutputLength, int nOutputSpacing, FIRFilter *pFilter);
int get_sync_samples(unsigned long newHZ);
int get_gcr_samples(unsigned long newHZ);
void onResample (double sample_rate, int syncLen, int gcrLen);
void NDSPComputeNewSampleRate(unsigned long new_rate, unsigned long old_rate);
void NDSPReset (void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\nabtslib.h ===
/* A private header file used by nabtslib.c; this is not part of the
   public interface. */

#ifndef NABTSLIB_H
#define NABTSLIB_H

/* How many bytes are in a bundle before FEC is added? */
#define BUNDLE_SMALL (26*14)
/* How many bytes are in a bundle after FEC is added? */
#define BUNDLE_LARGE (28*16)

extern void nabtslib_exit();

typedef enum {FEC_OK, FEC_CORRECTABLE, FEC_UNCORRECTABLE, MISSING} fec_stat;

#ifdef linux
int NabtsFecReceiveData(int nField, int nTimeMsec, int scan_line,
			unsigned char *pbData, int nDataLen);
#endif

extern unsigned char hamming_encode[16];

typedef enum {fec_status_ok, fec_status_onebyte, fec_status_multibyte,
	      fec_status_2byte, fec_status_missing} fec_status;

typedef struct {
  fec_status status;		/* status of the current FEC info */
  int err;			/* the current checksum error */
  short errl[2];		/* the galois_log[] of the two bytes of
				   the checksum error */
  int byte[2];			/* the locations of the error bytes
				   (byte[1] is only valid if
				   status == fec_status_2byte) */
  int byte_val[2];		/* the values to XOR into the above bytes
				   to make the checksum error 0 */
  int score;			/* the number of bits changed by this
				   correction */
  int really_onebyte;		/* We can compute the optimal
				   correction (the one which will
				   change the least number of bits).
				   However, we don't do this if we
				   don't have to (it's slow).  If
				   status is fec_status_2byte, we have
				   done so; if status is
				   fec_status_multibyte, we have not.
				   If status is fec_status_onebyte, we
				   need to look at really_onebyte to
				   see if the current correction is
				   optimal. */
} fec_info;

typedef struct {
  int not_full;
  unsigned char vals[28];
} Packet;

typedef struct _stream_struct {
  int stream_addr;
  Packet pack[32];
  fec_info horz[32];
  int last_index;
  struct _stream_struct *next;
  int count;
  int dead_time;
  int confAvgSum;
  int confAvgCount;
} Stream;

extern int decode_hamming(unsigned char Val);
extern int remove_parity(unsigned char *pVal);
extern int find_err_val(int err_byte, int byte_csum_err, int check_ind);
extern int compute_csum_horiz(unsigned char *vals, int len);
extern int compute_csum_vert(unsigned char *vals, int len);
extern fec_stat check_checksum_horiz(unsigned char *vals, int len, fec_info *inf);
extern int process_line(unsigned char *);
extern void init_inv2_coeffs();
extern void erase_packet(Stream *str, int i);
extern void complete_bundle(Stream *str, NFECCallback cb, void *ctx, NFECState *st);

extern void init_nzbits_arr();
extern unsigned char nzbits_arr[256];

typedef struct {
  int missing;
  unsigned char vals[28];
} VBI_Packet;

#define MAX_RECENT_ADDRS 16

/* typedef'd to NFECState in nabtsapi.h */
struct nfec_state_str {
  int *pGroupAddrs;
  int nGroupAddrs;
  Stream *streams;
  /* The following is just some scratch space for
     complete_bundle()... it's too big to put on the stack, if I make
     it a global then my code isn't reentrant, and I don't want to
     bother with allocating and freeing it each time complete_bundle()
     is called (besides, this is probably more efficient) */
  fec_info vert[28];
  struct {
    int addr;
    int count;
  } recent_addrs[MAX_RECENT_ADDRS];
  int n_recent_addrs;
  int field_count;
};

#define PROFILE_VALIDATE

#ifdef PROFILE_VALIDATE
extern int g_nValidate;
#endif

#endif /* NABTSLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\nabtslib.c ===
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <memory.h>
#include <limits.h>

#include "host.h"

#include "tables.h"
#include "tabdecls.h"

#include "nabtsapi.h"

#include "nabtslib.h"
#include "nabtsprv.h"

#if 1
#define DEBUG_PRINT(x) /* nothing */
#else
#define DEBUG_PRINT(x) printf x
#endif

#ifndef DEBUG_FEC
# define DEBUG_FEC_PRINT(x) /* nothing */
#else
# define DEBUG_FEC_PRINT(x) printf x
#endif

#ifdef PROFILE_VALIDATE
int g_nValidate = 0;
#endif

/* A simple routine for computing the number of nonzero bits in an
   int. */
int nzbits(unsigned int x) {
  int nz = 0;

  while (x) {
    nz++;
    x &= x-1;
  }

  return nz;
}

/* This table caches the results of nzbits(). */
unsigned char nzbits_arr[256];

/* Fill in nzbits_arr[] */
void init_nzbits_arr() {
  int i;
  for (i = 0; i < 256; i++) {
    nzbits_arr[i] = nzbits(i);
  }
}

/* This table is straight out of the NABTS spec. */
unsigned char hamming_encode[16] = {
  0x15,
  0x02,
  0x49,
  0x5e,
  0x64,
  0x73,
  0x38,
  0x2f,
  0xd0,
  0xc7,
  0x8c,
  0x9b,
  0xa1,
  0xb6,
  0xfd,
  0xea,
};

/* Hamming decoding simply looks up values in an array (for speed) */
int decode_hamming(unsigned char val) {
  return decode_hamming_tab[val];
}

/* TODO - Dead code...should be removed. */
int nabts_remove_parity(unsigned char *pVal) {
  unsigned char val = *pVal;
  
  int b1 = !!(val&1);
  int b2 = !!(val&2);
  int b3 = !!(val&4);
  int b4 = !!(val&8);
  int b5 = !!(val&16);
  int b6 = !!(val&32);
  int b7 = !!(val&64);
  int b8 = !!(val&128);

  int d = b8^b7^b6^b5^b4^b3^b2^b1;

  if (!d) {
    return 0;
  }

  *pVal = val&0x7f;
  return 1;
}

/* If the error csum_err was caused by a single-byte error, this
   routine will find the error location.  See my external
   documentation for a description of the math; norpak_delta_inv[]
   contains the function P from the document. */

int find_err_byte(int csum_err) {
  int pos0 = galois_log[csum_err>>8];
  int pos1 = galois_log[csum_err&0xff];

  int err_byte;

  if (pos0 == 255 || pos1 == 255) return 0xff;

  err_byte = norpak_delta_inv[(pos0 + 255 - pos1) % 255];

  return err_byte;
}

/* If there is a single-byte error, given the location of that error
   (computed by find_err_byte()), either of the checksum error bytes,
   and an indication of which checksum byte was passed in,
   this routine will compute the error (such that if the error
   is XOR'ed into the passed-in location, the checksum error will
   be 0). */
int find_err_val(int err_byte, int byte_csum_err, int check_ind) {
  int lfsr_pos, offset, base_lfsr_pos;

  if (byte_csum_err == 0) return 0;

  lfsr_pos = galois_log[byte_csum_err];

  offset = log_norpak_coeffs[check_ind][err_byte];

  base_lfsr_pos = (lfsr_pos + 255 - offset) % 255;

  return galois_exp[base_lfsr_pos];
}

#define GALOIS_LOG0 512 /* == galois_log[0] */

/* Null out a packet */
void erase_packet(Stream *str, int i) {
  /* If we haven't seen a packet, it's missing. */
  str->horz[i].status = fec_status_missing;
  /* The algorithms actually work just as well if vals[] is not cleared;
     however, making a consistent initial state aids debugging. */
  memset(str->pack[i].vals, 0, 28);
  /* There is no horizontal checksum error (the checksum for a packet
     of all 0's is 0) */
  str->horz[i].err = 0;
  str->horz[i].errl[0] = GALOIS_LOG0;
  str->horz[i].errl[1] = GALOIS_LOG0;
  str->pack[i].not_full = -1;
}

/* When we see a packet, find the stream it belongs to. */
Stream *lookup_stream(int stream_addr, NFECState *pState) {
  Stream *str = pState->streams;
  int i;

  while (str) {
    if (str->stream_addr == stream_addr) {
      return str;
    }

    str = str->next;
  }

  if ( !(str = (Stream*)alloc_mem(sizeof(Stream)) ) )
  {
      SASSERT(str!=0);
      return NULL;
  }

  /* Clear out the newly allocated Stream structure */
  memset(str, 0, sizeof(Stream));

  /* Claim that the last packet seen was packet index -1 */
  str->last_index = -1;
  str->stream_addr = stream_addr;
  str->next = pState->streams;
  str->count = 0;
  /* How long has it been since a packet was last seen on this stream? */
  str->dead_time = 0;
  for (i = 0; i < 32; i++) {
    erase_packet(str, i);
  }
  pState->streams = str;

  return str;
}

/* Write a packet into an NFECBundle structure, to be passed to the
   callback. */

int packet_write(NFECBundle *pBundle, Stream *str, int line_no, int len) {

  memcpy(pBundle->packets[line_no].data, str->pack[line_no].vals, 28);

  /* How much valid data is there in this line? */
  pBundle->packets[line_no].len = len;

  /* Lines 14 and 15 never have "valid data"...they're always checksums */
  if (line_no == 14 || line_no == 15) {
    pBundle->packets[line_no].len = 0;
  }
#ifdef DEBUG_FEC
  pBundle->packets[line_no].line = str->pack[line_no].line;
  pBundle->packets[line_no].frame = str->pack[line_no].frame;
#endif //DEBUG_FEC

  switch (str->horz[line_no].status) {
      case fec_status_ok:
        pBundle->packets[line_no].status = NFEC_OK;
        return 1;

      case fec_status_missing:
      default:
        pBundle->packets[line_no].status = NFEC_BAD;
        pBundle->packets[line_no].len = 0;
        return 0;
  }

#if 0
#ifndef linux
  if (str->stream_addr == 0x242) {
    for (i = 0; i < len; i++) {
      vbichar_input(str->pack[line_no].vals[i]);
    }
  }

#if 1
  if (str->stream_addr == 0x500) {
    for (i = 0; i < len; i++) {
      addone(str->pack[line_no].vals[i]);
    }
  }
#endif
#endif
#endif
}

/* inf->err has just been changed; adjust the status and the error
   correction status based on it.  len is 26 for horizontal checksums,
   14 for vertical. */
fec_stat update_fec_inf(fec_info *inf, int len) {
  int err = inf->err;
  int byte;

  /* We don't want to change fec_status_missing into another status. */
  if (inf->status == fec_status_missing) {
    return FEC_UNCORRECTABLE;
  }

  /* Yay!  A good row/column! */
  if (err == 0) {
    inf->status = fec_status_ok;
    return FEC_OK;
  }

  /* If this is caused by a single-byte error, it's an error in
     the checksum itself. */
  if (err>>8 == 0) {
    inf->status = fec_status_onebyte;
    inf->byte[0] = len+1;
    inf->byte_val[0] = err;
    inf->score = nzbits_arr[err];
    /* If the score is <= 2, then no 2-byte correction can have a
       better score. */
    inf->really_onebyte = (inf->score <= 2);
    return FEC_CORRECTABLE;
  }

  /* If this is caused by a single-byte error, it's an error in
     the checksum itself. */
  if ((err & 0xff) == 0) {
    inf->status = fec_status_onebyte;
    inf->byte[0] = len;
    inf->byte_val[0] = err>>8;
    inf->score = nzbits_arr[err>>8];
    /* If the score is <= 2, then no 2-byte correction can have a
       better score. */
    inf->really_onebyte = (inf->score <= 2);
    return FEC_CORRECTABLE;
  }

  byte = find_err_byte(err);

  if (byte < len) {
    /* Yes, there is a single-byte error which explains this checksum error. */
    int err_val = find_err_val(byte, err>>8, 0);

    inf->status = fec_status_onebyte;
    inf->byte[0] = byte;
    inf->byte_val[0] = err_val;
    inf->score = nzbits_arr[err_val];
    /* If the score is <= 2, then no 2-byte correction can have a
       better score. */
    inf->really_onebyte = (inf->score <= 2);
    return FEC_CORRECTABLE;
  } else {
    /* No single-byte error can explain this checksum error.  If we
       care, we can compute the optimal 2-byte correction later. */
    inf->status = fec_status_multibyte;
    inf->score = 17;
    return FEC_UNCORRECTABLE;
  }
}

/* Multiply a Galois coefficient (as in the contents of the
   inv2_coeffs struct) by a Galois value. */
#define GALOIS_MULT_COEFF(x, y) (galois_exp[x + galois_log[y]])

typedef struct {
  unsigned short v00, v01, v10, v11;
} inv2_coeffs;

inv2_coeffs coeffs_tab[28][28];

/* Given the byte positions b1 and b2, and the packet length len,
   fill in coeffs with the coefficients.  These coefficients let
   you efficiently compute the values to XOR with the bytes at
   positions b1 and b2 from the checksum error bytes.

   See my external document (the section on "Correcting Double-byte
   Erasures") for a description of the math involved here. */
void orig_compute_inv2_coeffs(int b1, int b2, inv2_coeffs *coeffs, int len) {
  SASSERT(b1 >= 0);
  SASSERT(b1 < len+2);
  SASSERT(b2 >= 0);
  SASSERT(b2 < len+2);
  SASSERT(len == 14 || len == 26);

  SASSERT(b1 < b2);

  if (b1 >= len) {
    /* Both bytes are FEC bytes.  The output bytes will simply be
       the checksum error bytes. */
    coeffs->v00 = 1;
    coeffs->v01 = 0;
    coeffs->v10 = 0;
    coeffs->v11 = 1;
  } else if (b2 >= len) {
    /* b1 is not FEC, but b2 is.  One of the output bytes will be
       a checksum error byte; the other will be computed as by
       find_err_val(). */
    if (b2 == len) {
      coeffs->v00 = 0;
      coeffs->v01 = galois_exp[255 - log_norpak_coeffs[1][b1]];
      coeffs->v10 = 1;
      coeffs->v11 = galois_exp[log_norpak_coeffs[0][b1] +
                       255 - log_norpak_coeffs[1][b1]];
    } else {
      coeffs->v00 = galois_exp[255 - log_norpak_coeffs[0][b1]];
      coeffs->v01 = 0;
      coeffs->v10 = galois_exp[log_norpak_coeffs[1][b1] +
                       255 - log_norpak_coeffs[0][b1]];
      coeffs->v11 = 1;
    }
  } else {
    /* Neither b1 nor b2 is an FEC byte. */

    SASSERT(b2 < len);      

    {
      int err_coeff0_inv;
      int e00, e01;
      int err_coeff1_inv;
      int e10, e11;

      err_coeff0_inv = galois_log[galois_exp[log_norpak_coeffs[0][b1] + 255 -
                                            log_norpak_coeffs[0][b2]] ^
                                 galois_exp[log_norpak_coeffs[1][b1] + 255 -
                                           log_norpak_coeffs[1][b2]]];
      e00 = 255 + 255 - err_coeff0_inv - log_norpak_coeffs[0][b2];
      e01 = 255 + 255 - err_coeff0_inv - log_norpak_coeffs[1][b2];

      err_coeff1_inv = galois_log[galois_exp[log_norpak_coeffs[0][b2] + 255 -
                                            log_norpak_coeffs[0][b1]] ^
                                 galois_exp[log_norpak_coeffs[1][b2] + 255 -
                                           log_norpak_coeffs[1][b1]]];
      e10 = 255 + 255 - err_coeff1_inv - log_norpak_coeffs[0][b1];
      e11 = 255 + 255 - err_coeff1_inv - log_norpak_coeffs[1][b1];

      coeffs->v00 = galois_exp[e00];
      coeffs->v01 = galois_exp[e01];
      coeffs->v10 = galois_exp[e10];
      coeffs->v11 = galois_exp[e11];
    }
  }

  /* Precompute the galois_log for slightly more efficient execution
     later. */
  coeffs->v00 = galois_log[coeffs->v00];
  coeffs->v01 = galois_log[coeffs->v01];
  coeffs->v10 = galois_log[coeffs->v10];
  coeffs->v11 = galois_log[coeffs->v11];
}

/* Cache the result of orig_compute_inv2_coeffs() over all possible
   values. */
void init_inv2_coeffs() {
  int b1;
  int b2;
  for (b1 = 0; b1 < 27; b1++) {
    for (b2 = b1+1; b2 < 28; b2++) {
      orig_compute_inv2_coeffs(b1, b2, &coeffs_tab[b1][b2], 26);
    }
  }
}

inline void compute_inv2_coeffs(int b1, int b2, inv2_coeffs *coeffs, int len) {
  /* comment out ASSERTs for speed */
#if 0
  SASSERT(b1 >= 0);
  SASSERT(b1 < len+2);
  SASSERT(b2 >= 0);
  SASSERT(b2 < len+2);
  SASSERT(len == 14 || len == 26);

  SASSERT(b1 < b2);
#endif

  /* If you're looking at the FEC bytes of a column, find the
     coefficients that were computed for looking at the corresponding
     FEC bytes of a row. */
  if (len == 14) {
    if (b1 >= 14) {
      b1 += 26-14;
    }
    if (b2 >= 14) {
      b2 += 26-14;
    }
  }

  *coeffs = coeffs_tab[b1][b2];
}

/* ANSI C preprocessor magic for creating new names */
#define TOKPASTE(a, b) a##b

#define STRIDE 1
#define STRIDENAM(x) TOKPASTE(x,_horiz)

/* Create "_horiz" versions of checksum functions. */
#include "hvchecks.c"

#undef STRIDE
#undef STRIDENAM

#define STRIDE (sizeof(Packet))
#define STRIDENAM(x) TOKPASTE(x,_vert)

/* Create "_vert" versions of checksum functions. */
#include "hvchecks.c"

#undef STRIDE
#undef STRIDENAM

/* TODO - Dead code...should be removed. */
fec_error_class check_fec(unsigned char data[28]) {
  int check = compute_csum_horiz(data, 26);
  int err = check ^ (data[26] << 8 | data[27]);
  int byte;

  if (err == 0) {
    return fec_errs_0;
  }

  if (err>>8 == 0) {
    return (nzbits_arr[err&0xff] > 1 ? fec_errs_multiple : fec_errs_1);
  }

  if ((err & 0xff) == 0) {
    return (nzbits_arr[err>>8] > 1 ? fec_errs_multiple : fec_errs_1);
  }

  byte = find_err_byte(err);

  if (byte < 26) {
    int err_val = find_err_val(byte, err>>8, 0);
    return (nzbits_arr[err_val] > 1 ? fec_errs_multiple : fec_errs_1);
  }

  return fec_errs_multiple;
}

/* Find the "optimal" corrections for the FEC info, taking into
   account that we don't allow ourselves to change a valid row/column.
   This function is called twice, once to find the optimal corrections
   for the rows and once for the columns; "us" and "them" switch places
   for the two calls.

   This routine can be quite timeconsuming; and it's worse on somewhat
   noisy signals (where it's less likely to be helpful).  However, it
   can't simply be bypassed, because subsequent code assumes that it
   can use the information in the fec_info to correct an arbitrary
   row/column (i.e., the status must be either fec_status_onebyte or
   fec_status_2byte, and the byte[] and byte_val[] values must be set
   correctly).  Thus, if the "really_search" flag is set to 0, all
   searching is bypassed and the routine simply finds any valid
   correction. */
void validate_twobyte_both(fec_info *us, fec_info *them, int us_len, int them_len, int really_search) {
  int active[28];
  int nActive = 0;

  {
    int i;
    
    for (i = 0; i < us_len; i++) {
      if (us[i].status == fec_status_onebyte) {
        if (them[us[i].byte[0]].status == fec_status_ok) {
          /* We can't use this correction; it would invalidate the
             row/column going in the other direction. */
          us[i].status = fec_status_multibyte;
          us[i].score = 17;
          active[nActive++] = i;
        } else {
          if (!us[i].really_onebyte) {
            /* Check to see if the one-byte correction is optimal. */
            active[nActive++] = i;
          }
        }
      } else if (us[i].status == fec_status_multibyte) {
        us[i].score = 17;
        active[nActive++] = i;
      } else if (us[i].status == fec_status_2byte) {
        if (them[us[i].byte[0]].status == fec_status_ok ||
            them[us[i].byte[1]].status == fec_status_ok) {
          /* We can't use this correction; it would invalidate a
             row/column going in the other direction. */
          us[i].status = fec_status_multibyte;
          us[i].score = 17;
          active[nActive++] = i;
        }
      } else if (us[i].status == fec_status_ok) {
        /* do nothing */
      } else {
        SASSERT(us[i].status == fec_status_missing);
      }
    }
  }

  if (nActive == 0) {
    /* Nothing to do... */
    return;
  }

  {
    int b1, b2;
    /* Loop over all pairs of byte positions where the row/column
       in the other direction is not already valid.  Compute
       b1c and b2c; this pulls the check for FEC bytes of a column
       (in compute_inv2_coeffs()) out of the inner loop. */
    for (b1 = 0; b1 < them_len-1; b1++) {
      if (them[b1].status != fec_status_ok) {
        int b1c = (them_len == 16 && b1 >= 14) ? b1+(28-16) : b1;

        for (b2 = b1+1; b2 < them_len; b2++) {
          if (them[b2].status != fec_status_ok) {
            int b2c = (them_len == 16 && b2 >= 14) ? b2+(28-16) : b2;
            int act;
            inv2_coeffs coeffs;
#ifdef MISSING_ZERO_COST
            int one_missing = (them[b1].status == fec_status_missing ||
                               them[b2].status == fec_status_missing);
#endif

            compute_inv2_coeffs(b1c, b2c, &coeffs, 28-2);

            /* Loop through the fec_info's which need to be checked... */
            for (act = 0; act < nActive; act++) {
              int i = active[act];
              /* Compute the two XOR values. */
              int ch1 = 
                galois_exp[coeffs.v00 + us[i].errl[0]] ^
                galois_exp[coeffs.v01 + us[i].errl[1]];
              int ch2 =
                galois_exp[coeffs.v10 + us[i].errl[0]] ^
                galois_exp[coeffs.v11 + us[i].errl[1]];
              int score;
                
#ifdef PROFILE_VALIDATE
              g_nValidate++;
#endif

#ifdef MISSING_ZERO_COST
              /* This code sets the cost of changing a byte in
                 a missing row to 0.  When I tested this, it
                 wasn't a clear win, so I took it back out. */
              if (one_missing) {
                if (them[b1].status == fec_status_missing) {
                  score = nzbits_arr[ch2];
                } else {
                  score = nzbits_arr[ch1];
                }
              } else {
#endif
                /* find the score of the current correction */
                score = nzbits_arr[ch1] + nzbits_arr[ch2];
#ifdef MISSING_ZERO_COST
              }
#endif

              if (score < us[i].score) {
                /* We found a better score; record the data. */
                us[i].status = fec_status_2byte;
                us[i].score = score;
                us[i].byte[0] = b1;
                us[i].byte_val[0] = ch1;
                us[i].byte[1] = b2;
                us[i].byte_val[1] = ch2;
              }
            }

            if (!really_search) {
              /* We found a single correction; the fec_info is now valid.
                 Break out of the search. */
              goto search_done;
            }
          }
        }
      }
    }
  }

search_done:
  {
    int i;

    for (i = 0; i < us_len; i++) {
      /* We'd better have changed all the fec_status_multibyte
         to fec_status_2byte... */
      SASSERT(us[i].status != fec_status_multibyte);
      if (us[i].status == fec_status_onebyte) {
        /* If we didn't find a two-byte correction with a better
           score than this, then this really is the best correction. */
        us[i].really_onebyte = 1;
      } else if (us[i].status == fec_status_2byte) {
        /* If the best two-byte correction actually only changed
           one byte, downgrade it to a one-byte correction.
           (TODO - This should never happen, should it? ) */
        if (us[i].byte_val[0] == 0) {
          us[i].status = fec_status_onebyte;
          us[i].really_onebyte = 1;
          us[i].byte[0] = us[i].byte[1];
          us[i].byte_val[0] = us[i].byte_val[1];
        } else if (us[i].byte_val[1] == 0) {
          us[i].status = fec_status_onebyte;
          us[i].really_onebyte = 1;
        }
      }
    }
  }
}

/* We've got all the packets we're going to get in this bundle;
   run FEC correction on it and pass it back to the callback. */
void complete_bundle(Stream *str, NFECCallback cb, void *ctx, NFECState *st) {
  int i;
  int bits_changed = 0;
  int total_missing;

  {
    /* Update the vertical fec_info's.  (The horizontal fec_info's were
       set as the packets were placed into the bundle.) */
    for (i = 0; i < 28; i++) {
      check_checksum_vert(&(str->pack[0].vals[i]), 14, &(st->vert[i]));
    }
  }

  {
    int n_missing = 0;

    /* Count the missing packets */
    for (i = 0; i < 16; i++) {
      if (str->horz[i].status == fec_status_missing) {
        n_missing++;
      }
    }

    total_missing = n_missing;

    DEBUG_FEC_PRINT(("|| Completing bundle (%d missing)\n", n_missing));

    if (n_missing <= 1) {
      /* There are 0 or 1 missing packets; run the standard FEC processing. */

      /* How many columns are not valid? */
      int vert_nok = 28;

      /* How many rows are not valid? */
      int horz_nok = 16;

      /* Do we need to call validate_twobyte_both()? */
      int twobyte_valid = 0;

      /* Find the actual values of horz_nok and vert_nok */
      for (i = 0; i < 16; i++) {
        if (str->horz[i].status == fec_status_ok) {
          horz_nok--;
        }
      }

      for (i = 0; i < 28; i++) {
        if (st->vert[i].status == fec_status_ok) {
          vert_nok--;
        }
      }
      
      while (vert_nok || horz_nok) {
        /* There are at least some rows or columns which are not OK. */

        /* The following code is almost exactly the same for rows and
           for column.  However, it uses too many of the local
           variables from this function to be conveniently extracted
           out into a separate function.  So, I created a macro for it.
           (I use this technique later, as well.) */
#define CHECK_ALMOST_OK(us, us_nok, us_len)                                \
        if (us_nok == 0) {                                                 \
          /* Panic!  All our packets are OK, but some packets in the       \
             other direction are not.  According to my assumptions,        \
             this is extremely unlikely (although it could happen that     \
             all horizontal packets are OK and vertical packets are        \
             not OK if packets from two different bundles are mixed).      \
             Let's just smash the checksums, so that at least we end       \
             up with a valid bundle. */                                    \
          us[us_len-2].status = fec_status_missing;                        \
          us[us_len-1].status = fec_status_missing;                        \
          us_nok = 2;                                                      \
          continue;                                                        \
        }                                                                  \
                                           \
        if (us_nok == 1) {                                                 \
          /* Again, this is quite unlikely, and I don't handle it well. */ \
          if (us[us_len-2].status == fec_status_ok) {                      \
            us[us_len-2].status = fec_status_missing;                      \
            us_nok++;                                                      \
          } else {                                                         \
            us[us_len-1].status = fec_status_missing;                      \
            us_nok++;                                                      \
          }                                                                \
          continue;                                                        \
        }

        CHECK_ALMOST_OK(st->vert, vert_nok, 28);
        CHECK_ALMOST_OK(str->horz, horz_nok, 16);

        /* OK, now we're back to the realm in which I'm comfortable:
           there are at least two non-OK packets in each direction.
           If there are exactly two non-OK packets in either direction,
           then we're done...we can just finish it off right now. */

#define horz_byte(h, v) (str->pack[v].vals[h])
#define vert_byte(v, h) (str->pack[v].vals[h])
#define horz_hinf(h, v) (str->horz[v])
#define vert_hinf(v, h) (str->horz[v])

#define CHECK_US_2NOK(us, us_nok, us_len, us_nok_label, them, them_nok, them_len, byte_val, hinf) \
        if (us_nok == 2) {                                                \
          /* Yes, there are exactly two missing packets in our            \
             direction.  Locate them and fill them in. */                 \
          int b1, b2;                                                     \
          int i, j;                                                       \
                                          \
          for (i = 0; i < us_len; i++) {                                  \
            if (us[i].status != fec_status_ok) {                          \
              b1 = i;                                                     \
              for (j = i+1; j < us_len; j++) {                            \
            if (us[j].status != fec_status_ok) {                          \
              b2 = j;                                             \
              goto us_nok_label;                                          \
            }                                                     \
              }                                                           \
              SASSERT(0);                                                 \
            }                                                             \
          }                                                               \
          SASSERT(0);                                                     \
                                          \
        us_nok_label:                                                     \
          /* OK, the two missing packets are at byte positions b1 and b2. \
             Let's figure out how to fix these bytes, given the "err"     \
             values. */                                                   \
          {                                                               \
            inv2_coeffs coeffs;                                           \
                                          \
            compute_inv2_coeffs(b1, b2, &coeffs, us_len-2);               \
                                          \
            for (i = 0; i < them_len; i++) {                              \
              int err = them[i].err;                                      \
              int ch1 =                                                   \
            GALOIS_MULT_COEFF(coeffs.v00, err>>8) ^                       \
            GALOIS_MULT_COEFF(coeffs.v01, err&0xff);              \
              int ch2 =                                                   \
            GALOIS_MULT_COEFF(coeffs.v10, err>>8) ^                       \
            GALOIS_MULT_COEFF(coeffs.v11, err&0xff);              \
              byte_val(i, b1) ^= ch1;                                     \
              byte_val(i, b2) ^= ch2;                                     \
              if (them[i].status != fec_status_ok) {                      \
            if (hinf(i, b1).status != fec_status_missing) {               \
              bits_changed += nzbits_arr[ch1];                    \
            }                                                     \
            if (hinf(i, b2).status != fec_status_missing) {               \
              bits_changed += nzbits_arr[ch2];                    \
            }                                                     \
            them[i].status = fec_status_ok;                               \
            them_nok--;                                           \
              }                                                           \
            }                                                             \
          }                                                               \
                                          \
          us[b1].status = fec_status_ok;                                  \
          us_nok--;                                                       \
          us[b2].status = fec_status_ok;                                  \
          us_nok--;                                                       \
          continue;                                                       \
        }

            CHECK_US_2NOK(st->vert, vert_nok, 28, found_vert_nok, str->horz, horz_nok, 16, vert_byte, vert_hinf);
            CHECK_US_2NOK(str->horz, horz_nok, 16, found_horz_nok, st->vert, vert_nok, 28, horz_byte, horz_hinf);


        /* At this point, there are at least three "not OK" vertical
           and horizontal packets. We want to pick one of these and
           make it OK.

           We want to pick changes which we believe are the most likely
           to be correct.  To this end, I've divided the possible
           changes into a few categories.  These are rated from the
           best (most likely to be correct) to the worst.

           1) Single-byte changes which fix both a row and a column.
           2) Single-byte changes which fix a column and occur in a
              "missing" row.
           3) The change to a row or column which fixes it and which
              uses the least numbers of bits.
           */

        {
          int fix_row = 0;
          int fix_col = 0;
          int fix_val = 0;

#if 1
          for (i = 0; i < 16; i++) {
            if (str->horz[i].status == fec_status_onebyte &&
            st->vert[str->horz[i].byte[0]].status == fec_status_onebyte &&
            st->vert[str->horz[i].byte[0]].byte[0] == i &&
            st->vert[str->horz[i].byte[0]].byte_val[0] == str->horz[i].byte_val[0]) {
              /* Both the row and the column involved here want to make
             the same change to the same byte; probably a good idea. */
              fix_row = i;
              fix_col = str->horz[i].byte[0];
              fix_val = str->horz[i].byte_val[0];
              SASSERT(fix_val != 0);
              goto do_fix;
            }
          }
#else
#define STATUS_TO_LIMIT(stat) ((stat == fec_status_2byte) ? 2 : 1)

          /* This heuristic is not a clear win over the one above;
             further experimentation is necessary. */
          {
            int best_score = INT_MAX;
            
            for (i = 0; i < 16; i++) {
              if (str->horz[i].status == fec_status_onebyte ||
              str->horz[i].status == fec_status_2byte) {
            int hpos;
            for (hpos = 0;
                 hpos < STATUS_TO_LIMIT(str->horz[i].status);
                 hpos++) {
              int hbyte = str->horz[i].byte[hpos];
              int hbyte_val = str->horz[i].byte_val[hpos];
              if (st->vert[hbyte].status == fec_status_onebyte ||
                  st->vert[hbyte].status == fec_status_2byte) {
                int vpos;
                for (vpos = 0;
                 vpos < STATUS_TO_LIMIT(st->vert[i].status);
                 vpos++) {
                  if (st->vert[hbyte].byte[vpos] == i &&
                  st->vert[hbyte].byte_val[vpos] == hbyte_val) {
                int score = 16*((str->horz[i].status == fec_status_2byte) +
                        (st->vert[hbyte].status == fec_status_2byte)) +
                  nzbits_arr[hbyte_val];
                if (score < best_score) {
                  fix_row = i;
                  fix_col = hbyte;
                  fix_val = hbyte_val;
                  best_score = score;
                }
                  }
                }
              }
            }
              }
            }

            if (best_score < INT_MAX) {
              SASSERT(fix_val != 0);
              goto do_fix;
            }
          }
#endif

          for (i = 0; i < 28; i++) {
            if (st->vert[i].status == fec_status_onebyte &&
            str->horz[st->vert[i].byte[0]].status == fec_status_missing) {
              /* This column wants to make a change in a "missing" row.
             Let it. */
              fix_row = st->vert[i].byte[0];
              fix_col = i;
              fix_val = st->vert[i].byte_val[0];
              SASSERT(fix_val != 0);
              goto do_fix;
            }
          }

          {
            int prefer_vert;
            int best_score = INT_MAX;

            /* If there are more invalid columns than rows, then
               prefer (slightly) to fix columns.  (This is because
               it's less likely that random noise in the invalid rows
               would make a column with a low-score correction than
               vice versa, so if we find a low-score correction, it's
               somewhat more likely to be what we want. */
            if (vert_nok >= horz_nok) {
              prefer_vert = 1;
            } else {
              prefer_vert = 0;
            }

            /* Find the best score.  As we're searching, determine
               whether we might need to call validate_twobyte_both().

               We simply find the row or column which needs the fewest
               number of bits corrected to become valid; except that
               if there's a tie between a row and a column, we break it
               according to prefer_vert. */
            for (i = 0; i < 16; i++) {
              if (str->horz[i].status == fec_status_onebyte) {
            if (!str->horz[i].really_onebyte) {
              twobyte_valid = 0;
            }
            if (st->vert[str->horz[i].byte[0]].status != fec_status_ok) {
              int score = str->horz[i].score*2 + prefer_vert;
              if (score < best_score) {
                best_score = score;
                fix_row = i;
                fix_col = str->horz[i].byte[0];
                fix_val = str->horz[i].byte_val[0];
              }
            } else {
              twobyte_valid = 0;
            }
              } else if (str->horz[i].status == fec_status_2byte) {
            if (st->vert[str->horz[i].byte[0]].status != fec_status_ok &&
                st->vert[str->horz[i].byte[1]].status != fec_status_ok) {
              int score = str->horz[i].score*2 + prefer_vert;
              if (score < best_score) {
                best_score = score;
                fix_row = i;
                fix_col = str->horz[i].byte[0];
                fix_val = str->horz[i].byte_val[0];
              }
            } else {
              twobyte_valid = 0;
            }
              }
            }

            for (i = 0; i < 28; i++) {
              if (st->vert[i].status == fec_status_onebyte) {
            if (!st->vert[i].really_onebyte) {
              twobyte_valid = 0;
            }
            if (str->horz[st->vert[i].byte[0]].status != fec_status_ok) {
              int score = st->vert[i].score*2 + (1-prefer_vert);
              if (score < best_score) {
                best_score = score;
                fix_row = st->vert[i].byte[0];
                fix_col = i;
                fix_val = st->vert[i].byte_val[0];
              }
            } else {
              twobyte_valid = 0;
            }
              } else if (st->vert[i].status == fec_status_2byte) {
            if (str->horz[st->vert[i].byte[0]].status != fec_status_ok &&
                str->horz[st->vert[i].byte[1]].status != fec_status_ok) {
              int score = st->vert[i].score*2 + (1-prefer_vert);
              if (score < best_score) {
                best_score = score;
                fix_row = st->vert[i].byte[0];
                fix_col = i;
                fix_val = st->vert[i].byte_val[0];
              }
            } else {
              twobyte_valid = 0;
            }
              }
            }

            if (best_score < 6 ||
            (best_score < INT_MAX && twobyte_valid)) {
              /* If we found a fix with a score < 6, then it has
                 either 1 or 2 bit errors; calling
                 validate_twobyte_both() can't find a better
                 correction (lower number of bit errors).
                 (Actually, if we found a fix with a score of 5, we could
                 potentially improve it by finding a 2 error fix in
                 the other direction, which would have a score of 4.) */
              SASSERT(fix_val != 0);
              goto do_fix;
            }

            /* Don't search if there's more than 10 invalid rows/columns
               in the opposite direction (which would mean 55 or more
               pairs of error positions). */
            validate_twobyte_both(str->horz, st->vert, 16, 28, vert_nok<=10);
            validate_twobyte_both(st->vert, str->horz, 28, 16, horz_nok<=10);
            twobyte_valid = 1;
            continue;
          }

          /* At this point, there's really not much we can do...we don't
             have any plausible changes to make.  Let's just change
             something at random. */

          /* TODO - We should never get here... */
          {
            int col;

            for (col = 0; col < 28; col++) {
              if (st->vert[col].status != fec_status_ok) {
            int b1, b2;
            for (b1 = 0; b1 < 16; b1++) {
              if (str->horz[b1].status != fec_status_ok) {
                for (b2 = b1+1; b2 < 16; b2++) {
                  if (str->horz[b2].status != fec_status_ok) {
                inv2_coeffs coeffs;
                int err = st->vert[col].err;

                compute_inv2_coeffs(b1, b2, &coeffs, 14);

                fix_row = b1;
                fix_col = col;
                fix_val = GALOIS_MULT_COEFF(coeffs.v00, err>>8) ^
                  GALOIS_MULT_COEFF(coeffs.v01, err&0xff);
                SASSERT(fix_val != 0);
                goto do_fix;
                  }
                }
                SASSERT(0);
              }
            }
            SASSERT(0);
              }
            }
            SASSERT(0);
          }

        do_fix:
          SASSERT(str->horz[fix_row].status != fec_status_ok);
          SASSERT(st->vert[fix_col].status != fec_status_ok);
          SASSERT(fix_val != 0);

          {
            /* We've decided on a change to make.  Update the fec_inf's
               and actually make the change. */

            int val_log = galois_log[fix_val];

            str->pack[fix_row].vals[fix_col] ^= fix_val;

            if (str->horz[fix_row].status != fec_status_missing) {
              bits_changed += nzbits_arr[fix_val];
            }

            {
              if (fix_col == 26) {
            str->horz[fix_row].err ^= fix_val<<8;
              } else if (fix_col == 27) {
            str->horz[fix_row].err ^= fix_val;
              } else {
            int offs0 = log_norpak_coeffs[0][fix_col];
            int offs1 = log_norpak_coeffs[1][fix_col];
            
            str->horz[fix_row].err ^=
              galois_exp[val_log + offs0]<<8 |
              galois_exp[val_log + offs1];
              }

              str->horz[fix_row].errl[0] = galois_log[str->horz[fix_row].err>>8];
              str->horz[fix_row].errl[1] = galois_log[str->horz[fix_row].err&0xff];

              update_fec_inf(&str->horz[fix_row], 26);
              if (str->horz[fix_row].status == fec_status_ok) {
            horz_nok--;
              }
            }

            {
              if (fix_row == 14) {
            st->vert[fix_col].err ^= fix_val<<8;
              } else if (fix_row == 15) {
            st->vert[fix_col].err ^= fix_val;
              } else {
            int offs0 = log_norpak_coeffs[0][fix_row];
            int offs1 = log_norpak_coeffs[1][fix_row];

            st->vert[fix_col].err ^=
              galois_exp[val_log + offs0]<<8 |
              galois_exp[val_log + offs1];
              }

              st->vert[fix_col].errl[0] = galois_log[st->vert[fix_col].err>>8];
              st->vert[fix_col].errl[1] = galois_log[st->vert[fix_col].err&0xff];

              update_fec_inf(&st->vert[fix_col], 14);
              if (st->vert[fix_col].status == fec_status_ok) {
            vert_nok--;
              }
            }
          }
        }
      }
    } else {
      /* There are 2 or more missing rows.  In this case, we've lost
         most of our error-detecting and error-correcting capability
         (unless we've lost exactly 2 rows and the rest are
         substantially accurate); even so, we go ahead and smash the
         bundle until all the FEC's are valid.

         We don't search for optimal two-byte corrections; since we
         have no information on column validity, we'd have to search
         278 pairs of error positions, which is too slow. */
      int b1 = -1, b2 = -1;

      for (i = 0; i < 16; i++) {
        switch (str->horz[i].status) {
        case fec_status_ok:
          /* do nothing */
          break;

        case fec_status_missing:
          if (b1 == -1) {
            b1 = i;
          } else if (b2 == -1) {
            b2 = i;
          }
          break;

        case fec_status_onebyte:
          /* Fix the one-byte error that was detected. */
          str->pack[i].vals[str->horz[i].byte[0]] ^=
            str->horz[i].byte_val[0];
          str->horz[i].status = fec_status_ok;
          str->horz[i].err = 0;
          str->horz[i].errl[0] = GALOIS_LOG0;
          str->horz[i].errl[1] = GALOIS_LOG0;
          bits_changed += nzbits_arr[str->horz[i].byte_val[0]];
          break;

        case fec_status_multibyte:
          /* Smash the checksum bytes. */
          str->pack[i].vals[26] ^= str->horz[i].err >> 8;
          str->pack[i].vals[27] ^= str->horz[i].err & 0xff;
          bits_changed += nzbits_arr[str->horz[i].err >> 8];
          bits_changed += nzbits_arr[str->horz[i].err & 0xff];
          str->horz[i].status = fec_status_ok;
          str->horz[i].err = 0;
          str->horz[i].errl[0] = GALOIS_LOG0;
          str->horz[i].errl[1] = GALOIS_LOG0;
          break;
        }
      }

      /* We've done the best we can at smashing the horizontal rows...
         now it's time to fix the vertical ones */
      {
        /* TODO duplicate code */
        inv2_coeffs coeffs;
        compute_inv2_coeffs(b1, b2, &coeffs, 14);

        for (i = 0; i < 28; i++) {
          int err = st->vert[i].err;
          str->pack[b1].vals[i] ^=
            GALOIS_MULT_COEFF(coeffs.v00, err>>8) ^
            GALOIS_MULT_COEFF(coeffs.v01, err&0xff);
          str->pack[b2].vals[i] ^=
            GALOIS_MULT_COEFF(coeffs.v10, err>>8) ^
            GALOIS_MULT_COEFF(coeffs.v11, err&0xff);
          if (st->vert[i].status != fec_status_ok) {
            st->vert[i].status = fec_status_ok;
          }
        }

        if (n_missing == 2) {
          str->horz[b1].status = fec_status_ok;
          str->horz[b2].status = fec_status_ok;
        }
      }
    }
  }
      
  {
    /* Now that we've done the FEC processing, actually write out the
       bundle. */

    NFECBundle *pBundle = alloc_mem(sizeof(NFECBundle));

    DEBUG_PRINT((nabtslib_out, "Writing out bundle\n"));

    if (!pBundle) {
      /* TODO - What should I do here? (Note error and up statistics, trap in debug!) */
      DEBUG_PRINT((nabtslib_out, "bundle malloc(%d) failed\n",sizeof(NFECBundle)));
      ASSERT(pBundle);
      return;
    }

    pBundle->lineConfAvg = str->confAvgCount? (str->confAvgSum / str->confAvgCount) : 0;

    for (i = 0; i < 16; i++) {
      if (str->pack[i].not_full == -1) {
        /* We don't know whether this packet is full or not (it was
           reconstructed using the FEC, but this reconstruction doesn't
           include the "not full" flag).  Guess. */
        if ((i > 0 && str->pack[i-1].not_full) ||
            (i < 13 && str->pack[i+1].not_full)) {
          /* Our predecessor was not full, or our successor is not full
             or unknown (it might have been reconstructed as well). */
          str->pack[i].not_full = 2;
        } else {
          str->pack[i].not_full = 0;
        }
      }
        
      if (str->pack[i].not_full) {
        unsigned char *packet_end = &(str->pack[i].vals[25]);
        unsigned char *packet_beg = &(str->pack[i].vals[0]);

        while ((*packet_end > *packet_beg) && *packet_end == 0xea) {
          packet_end--;
        }

        if (*packet_end != 0x15) {
          if (str->pack[i].not_full == 1) {
            /* The packet claimed to be 'not full'. */
            DEBUG_PRINT((nabtslib_out, "Packet %d not in Norpak 'incomplete packet' format\n", i));
          } else {
            /* We guessed that the packet was 'not full'; apparently
               we guessed wrong. */
          }
          packet_write(pBundle, str, i, 26);
        } else {
          packet_write(pBundle, str, i, (packet_end - packet_beg));
        }
      } else {
        packet_write(pBundle, str, i, 26);
      }
    }

    pBundle->nBitErrors = bits_changed;

    cb(ctx, pBundle, str->stream_addr, 16-total_missing);
  }

  /* Move the start of the next bundle down into the current bundle. */
  str->last_index -= 16;
  memcpy(&(str->pack[0]), &(str->pack[16]), 16*sizeof(Packet));
  memcpy(&(str->horz[0]), &(str->horz[16]), 16*sizeof(fec_info));
  for (i = 16; i < 32; i++) {
    erase_packet(str, i);
  }
}

#ifdef DEBUG_FEC
int fec_line;
int fec_frame;
#endif

/* This should probably be called handle_packet().  It takes a packet,
   finds the corresponding stream, and writes the packet into the stream
   structure. */
int handle_bundle(NFECState *pState, NFECCallback cb, void *ctx,
                  int stream_addr, int index, int ps, unsigned char *vals,
                  int confidence) {
  int check_ret;
  Stream *str = NULL;
  int i;

  if ((ps>>2 == 2 && index >= 14)
      || (ps>>2 == 3 && index < 14)
      || ((ps & 2) && ps>>2 == 3)
      || (ps & 1)) {
    DEBUG_PRINT((nabtslib_out, "Unhandled combination of index and flags (%d, %d): not Norpak inserter?\n",
                 index, ps));
    return 2;
  }
  
  DEBUG_PRINT((nabtslib_out, "\n"));

  if (pState->pGroupAddrs) {
    for (i = 0; i < pState->nGroupAddrs; i++) {
      if (stream_addr == pState->pGroupAddrs[i]) {
        str = lookup_stream(stream_addr, pState);
        break;
      }
    }
  } else {
    str = lookup_stream(stream_addr, pState);
  }

  if (!str) {
    DEBUG_PRINT((nabtslib_out, "ERROR: Can't allocate stream for %d (or not requested)\n", stream_addr));
    return 2;
  }

  /* Record that this stream is still alive */
  str->dead_time = 0;

  /* There's some complexity in here to deal with out-of-order packets,
     from the broken BT848 driver we were using to collect data
     at the start of this project.  It's probably not needed any more. */

  if (index <= str->last_index - 8) {
    index += 16;
  }

  if (str->horz[index].status != fec_status_missing) {
    /* There's already something there.  This must be some kind of repeat... */
    DEBUG_PRINT((nabtslib_out, "Ignoring duplicate packet %d\n", (index % 16)));
    return 2;
  }

  if (str->last_index + 1 != index) {
    DEBUG_PRINT((nabtslib_out,
                 "Missing lines in stream %d: last was %d, this is %d\n",
                 str->stream_addr, (str->last_index % 16), (index % 16)));
  }

  /* Update the fec_inf for this packet */
  check_checksum_horiz(vals, 26, &str->horz[index]);

  check_ret = (str->horz[index].status != fec_status_ok);

  str->confAvgSum += confidence;
  str->confAvgCount += 1;

  str->pack[index].not_full = !!(ps & 2);
  for (i = 0; i < 28; i++) {
    str->pack[index].vals[i] = vals[i];
  }
#ifdef DEBUG_FEC
  str->pack[index].line = fec_line;
  str->pack[index].frame = fec_frame;
#endif //DEBUG_FEC

  if (str->last_index < index) {
    str->last_index = index;
  }

  if (index >= 24) {
    complete_bundle(str, cb, ctx, pState);
  }

  return check_ret;
}

#define DECODE_HAMMING(var, val, which) \
    { \
      var = decode_hamming(val); \
      if (var == 0xff) {; \
        DEBUG_FEC_PRINT(("ERROR: Bad hamming %02x (%s)\n", val, which)); \
        hamming_err++; \
      } \
    }
                                     
/* This function is called for every stream on exit; it goes ahead and
   sends whatever we've got to the user. */
void flush_stream(NFECState *pState, Stream *str, NFECCallback cb, void *ctx) {
  int i;

  for (i = str->last_index + 1; i < 16; i++) {
    str->horz[i].status = fec_status_missing;
    memset(str->pack[i].vals, 0, 28);
    str->horz[i].err = 0;
    str->horz[i].errl[0] = GALOIS_LOG0;
    str->horz[i].errl[1] = GALOIS_LOG0;
    str->pack[i].not_full = -1;
  }

  complete_bundle(str, cb, ctx, pState);
}

void nabtslib_exit(NFECState *pState, NFECCallback cb, void *ctx) {
  Stream *str = pState->streams;

  while (str) {
    Stream *next_str = str->next;

    flush_stream(pState, str, cb, ctx);

    free_mem(str);

    str = next_str;
  }

  pState->streams = NULL;
}


/* This is the implementation of the new API found in nabtsapi.h ... */

int NFECStateConnectToDSP(NFECState *pFECState, NDSPState *pDSPState) {
  /* This is a no-op for now */
   return 0;
}

NFECState *NFECStateNew() {
  NFECState *state = alloc_mem(sizeof(NFECState));

  if ( state )
  {
    state->pGroupAddrs = NULL;
    state->nGroupAddrs = 0;

    state->streams = 0;

    state->n_recent_addrs = 0;

    init_nzbits_arr();
    init_inv2_coeffs();
  }
  else
  {
    SASSERT(state);
  }

  return state;
}

void NFECStateDestroy(NFECState *nState) {
  Stream *str = nState->streams;

  while (str) {
    Stream *next_str = str->next;

    free_mem(str);

    str = next_str;
  }

  nState->streams = NULL;

  if (nState->pGroupAddrs) {
    free_mem(nState->pGroupAddrs);
    nState->pGroupAddrs = NULL;
  }

  free_mem(nState);
}

int NFECStateSetGroupAddrs(NFECState *pState, int *pGroupAddrs,
                           int nGroupAddrs) {
  if (pGroupAddrs) {
    int *new_addrs = alloc_mem(nGroupAddrs * sizeof(int));
    if (!new_addrs) {
      return 0;
    }
    if (pState->pGroupAddrs) {
      free_mem(pState->pGroupAddrs);
    }
    pState->pGroupAddrs = new_addrs;
    memcpy(new_addrs, pGroupAddrs, nGroupAddrs * sizeof(int));
    pState->nGroupAddrs = nGroupAddrs;
  } else {
    if (pState->pGroupAddrs) {
      free_mem(pState->pGroupAddrs);
    }
    pState->pGroupAddrs = NULL;
    pState->nGroupAddrs = 0;
  }

  return 1;
}

/* We keep track of the NABTS stream addresses we've seen recently.
   If we find a stream address which we can't correct (due to two-bit
   errors in an address byte), we see if it's close to any of the
   16 most recent addresses we've seen.  If so, we pick the closest
   such address. */
int find_best_addr(NFECState *pState, unsigned char *indec, int *nBitErrs) {
  int i;
  int hamming_err = 0;
  int loc_biterrs;

  if (nBitErrs == NULL) {
    nBitErrs = &loc_biterrs;
  }
  
  *nBitErrs = 0;

  if (pState->n_recent_addrs == 0) {
    return -1;
  }

  {
    int best_addr = 0;
    int best_addr_biterrs = INT_MAX;
    int best_addr_count = -1;
    int p1, p2, p3;

    for (i = 0; i < pState->n_recent_addrs; i++) {
      int biterrs = 0;
      int addr = pState->recent_addrs[i].addr;
      biterrs += nzbits_arr[indec[3] ^ (addr >> 16)];
      biterrs += nzbits_arr[indec[4] ^ ((addr >> 8) & 0xff)];
      biterrs += nzbits_arr[indec[5] ^ (addr & 0xff)];
      if ((biterrs < best_addr_biterrs) ||
          (biterrs == best_addr_biterrs &&
           pState->recent_addrs[i].count > best_addr_count)) {
        best_addr = addr;
        best_addr_biterrs = biterrs;
        best_addr_count = pState->recent_addrs[i].count;
      }
    }

    *nBitErrs = best_addr_biterrs;

    if (best_addr_biterrs > 6) {
      /* We want to keep random noise from being a valid address
         (since adding an extra line will mess up a packet worse than
         dropping a line) */
      DEBUG_FEC_PRINT(("Corrupt hamming in address uncorrectable\n"));
      return -1;
    }

    DECODE_HAMMING(p1, best_addr>>16, "p1_best");
    DECODE_HAMMING(p2, (best_addr>>8)&0xff, "p2_best");
    DECODE_HAMMING(p3, best_addr&0xff, "p3_best");

    return (p1<<8) | (p2<<4) | p3;
  }
}

/* The main entry point for this file. */
void NFECDecodeLine(unsigned char *indec,
                    int confidence,
                    NFECState *pState,
                    NFECLineStats *pLineStats,
                    NFECCallback *cb,
                    void *ctx) {
  int p1, p2, p3, ci, ps;
  int i;
  int stream_addr;
  int encoded_addr;
  int packet_err = 0;
  int hamming_err = 0;

#if 0
  /* In the old ActiveMovie based driver, this set up the hardcoded
     Intercast and multicast behavior. */     
  static int initted = 0;
  if (!initted) {
    initted = 1;
    init_recv();
    init_icast();
  }
#endif

  if (indec[0] != 0x55 || indec[1] != 0x55 || indec[2] != 0xe7) {
    DEBUG_PRINT((nabtslib_out, "ERROR: bad sync "));
    packet_err = 1;
  }

#if 0
  /* This is a hack to allow us to decode some strange broadcast
     (possibly Wavephore?) with a bogus group address. */
  if (indec[3] == 0xe0) {indec[3] = 0xea;}
#endif

  DECODE_HAMMING(p1, indec[3], "p1");
  DECODE_HAMMING(p2, indec[4], "p2");
  DECODE_HAMMING(p3, indec[5], "p3");

  DECODE_HAMMING(ci, indec[6], "ci");
  DECODE_HAMMING(ps, indec[7], "ps");

  if (!hamming_err) {
    stream_addr = p1<<8 | p2<<4 | p3;
    encoded_addr = hamming_encode[p1]<<16 | hamming_encode[p2]<<8 | hamming_encode[p3];

    for (i = 0; i < pState->n_recent_addrs; i++) {
      if (pState->recent_addrs[i].addr == encoded_addr) {
        pState->recent_addrs[i].count++;
        break;
      }
    }

    if (i == pState->n_recent_addrs) {
      /* The address was not found in the list of recent addresses. */
      if (pState->n_recent_addrs < MAX_RECENT_ADDRS) {
        pState->recent_addrs[pState->n_recent_addrs].addr = encoded_addr;
        pState->recent_addrs[pState->n_recent_addrs].count = 1;
        pState->n_recent_addrs++;
      } else {
        /* We've got to retire an existing "recent address". */
        while (1) {
          for (i = 0; i < pState->n_recent_addrs; i++) {
            if (pState->recent_addrs[i].count == 0) {
              pState->recent_addrs[i].addr = encoded_addr;
              pState->recent_addrs[i].count = 1;
              break;
            }
          }
          if (i < pState->n_recent_addrs) {
            break;
          }
          for (i = 0; i < pState->n_recent_addrs; i++) {
            pState->recent_addrs[i].count /= 2;
          }
        }
      }
    }
  } else {
    /* There was a hamming error.  Try some heuristics to see what was
       meant. */

    if (p1 == 255 || p2 == 255 || p3 == 255) {
      /* The stream address was corrupt.  Let's try to create a valid
         stream address. */
      stream_addr = find_best_addr(pState, indec, NULL);
      if (stream_addr == -1) {
        DEBUG_FEC_PRINT(("Corrupt hamming in address uncorrectable\n"));
        goto corrupt;
      }
    } else {
      stream_addr = p1<<8 | p2<<4 | p3;
    }

    if (ci == 255 || ps == 255) {
      int best_indices[16];
      int n_best_indices = 0;
      int best_index_biterr = INT_MAX;

      goto corrupt;

// TODO start dead code
      for (i = 0; i < 16; i++) {
        int biterr = 0;
        biterr += nzbits_arr[hamming_encode[i] ^ indec[6]];
        biterr += nzbits_arr[hamming_encode[(i < 14) ? 8 : 12] ^ indec[7]];

        if (biterr < best_index_biterr) {
          best_indices[0] = i;
          n_best_indices = 1;
          best_index_biterr = biterr;
        } else if (biterr == best_index_biterr) {
          best_indices[n_best_indices] = i;
          n_best_indices++;
        }
      }

      if (n_best_indices == 1) {
        ci = best_indices[0];
        ps = (ci < 14) ? 8 : 12;
      } else {
        /* TODO Be a little smarter here... */
        DEBUG_FEC_PRINT(("Bad Hamming for index or structure uncorrectable\n"));
        goto corrupt;
      }
// TODO End dead code
    }
  }

  DEBUG_PRINT((nabtslib_out, "%04d ", stream_addr));

  DEBUG_PRINT((nabtslib_out, "%01x ", ci));

#if 0
#ifdef DEBUG_FEC
  printf("Stream addr: %04d   Index: %01x   Frame: %4d   Line: %2d\n", stream_addr, ci, fec_frame, fec_line);
#endif
#endif

  if (ps & 1) {
    DEBUG_PRINT((nabtslib_out, "(group start) "));
  }

  if (ps & 2) {
    DEBUG_PRINT((nabtslib_out, "(packet not full) "));
    for (i = 8; i < 34; i++) {
      DEBUG_PRINT((nabtslib_out, "%02x ", indec[i]));
    }
  }

  switch (ps >> 2) {
  case 0:
    DEBUG_PRINT((nabtslib_out, "28 (unknown checksum)\n"));
    goto corrupt;
    break;

  case 1:
    DEBUG_PRINT((nabtslib_out, "27 "));
    goto corrupt;
#if 0
    /* This code can correct single-bit errors in 27-byte packets;
       however, we'll never be sending 27-byte packets, so if
       we see one on our group address it's actually a sign of
       a corrupt header byte. */
    {
      int check = 0;
      int parity_err = 0;
      for (i = 8; i < 36; i++) {
        check ^= indec[i];
        if (!nabts_remove_parity(&indec[i])) {
          parity_err++;
        }
#if 0
        putc(isprint(indec[i]) ? indec[i] : '.', nabtslib_out);
#endif
      }
        
      if (parity_err || check != 0xff) {
        if (parity_err) {
          DEBUG_PRINT((nabtslib_out, "ERROR (%d parity error(s)) ", parity_err));
        }
        if (check != 0xff) {
          DEBUG_PRINT((nabtslib_out, "ERROR (bad checksum) "));
        }
        if (parity_err == 1 && nzbits_arr[check] == 7) {
          DEBUG_PRINT((nabtslib_out, "(correctable) "));
          if (packet_err == 0) {
            packet_err = 1;
          }
        } else {
          packet_err = 2;
        }
      }
    }
#endif
    DEBUG_PRINT((nabtslib_out, "\n"));
    break;

  case 2:
    DEBUG_PRINT((nabtslib_out, "26 "));
#if 0
    {
      for (i = 8; i < 36; i++) {
        putc(isprint(indec[i]) ? indec[i] : '.', nabtslib_out);
      }
    }
#endif
    {
      int handle_ret;
      handle_ret = handle_bundle(pState, cb, ctx, stream_addr, ci, ps, indec+8, confidence);
      if (handle_ret > packet_err) {
        packet_err = handle_ret;
      }
    }
    break;

  case 3:
    DEBUG_PRINT((nabtslib_out, " 0 "));
    {
      int handle_ret;
      handle_ret = handle_bundle(pState, cb, ctx, stream_addr, ci, ps, indec+8, confidence);
      if (handle_ret > packet_err) {
        packet_err = handle_ret;
      }
    }
    break;
  }

  if (packet_err) {
    pLineStats->status = NFEC_LINE_CHECKSUM_ERR;
  } else {
    pLineStats->status = NFEC_LINE_OK;
  }

  return;

 corrupt:
  pLineStats->status = NFEC_LINE_CORRUPT;
  return;
}

/* Garbage collect streams.  Every 50 fields we see, we go through and
   check if any of our streams have been dead (have not received any
   packets) for 300 fields.  If so, go ahead and delete that stream
   (forwarding any current data to the callback).
 */
void NFECGarbageCollect(NFECState *pState, NFECCallback *cb, void *ctx) {
  pState->field_count++;

  if (pState->field_count >= 50) {
    Stream **ppStr = &(pState->streams);
    pState->field_count = 0;
    while (*ppStr != NULL) {
      (*ppStr)->dead_time++;
      if ((*ppStr)->dead_time >= 6) {
                Stream *dying_stream = *ppStr;
                flush_stream(pState, dying_stream, cb, ctx);
                *ppStr = (*ppStr)->next;
                free_mem(dying_stream);
      } else {
                ppStr = &((*ppStr)->next);
      }
    }
  }
}


void NFECStateFlush(NFECState *pState, NFECCallback *cb, void *ctx) {
  nabtslib_exit(pState, cb, ctx);
}

/* Hamming decode a single byte. */
int NFECHammingDecode(unsigned char bByte, int *nBitErrors) {
  int decoded = decode_hamming_tab[bByte];
  int encoded;

  if (decoded == 255) {
    *nBitErrors = 2;
    return -1;
  }

  encoded = hamming_encode[decoded];

  if (encoded == bByte) {
    *nBitErrors = 0;
  } else {
    *nBitErrors = 1;
  }

  return decoded;
}

/* Hamming decode a group address; if there's a Hamming error, call
   find_best_addr() to match against recently-seen addresses. */
int NFECGetGroupAddress(NFECState *pState, unsigned char *bData, int *nBitErrors) {
    int  a1, a2, a3;
    int  myBitErrors;

    *nBitErrors = 0;
    a1 = NFECHammingDecode(bData[3], &myBitErrors);
    *nBitErrors += myBitErrors;
    a2 = NFECHammingDecode(bData[4], &myBitErrors);
    *nBitErrors += myBitErrors;
    a3 = NFECHammingDecode(bData[5], &myBitErrors);
    *nBitErrors += myBitErrors;

    if (a1 != -1 && a2 != -1 && a3 != -1) {
      return a1<<8 | a2<<4 | a3;
    } else {
      return find_best_addr(pState, bData, nBitErrors);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\tabdecls.h ===
extern unsigned char norpak_coeffs[2][26];

#ifndef EXTERN
#define EXTERN extern
#endif

/* When this file is #include'd in gentabs.c, EXTERN is #define'd
   as nothing; so these end up being declarations. */
EXTERN unsigned short galois_log[256];
EXTERN unsigned char galois_exp[1025];
EXTERN unsigned char log_norpak_coeffs[2][26];
EXTERN unsigned char norpak_delta_inv[256];
EXTERN unsigned char decode_hamming_tab[256];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\tables.c ===
/* Warning: This code was automatically generated (by gentabs.c).
   DO NOT EDIT! */
#include "tabdecls.h"

unsigned char galois_exp[1025] = {
  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80,
  0x1d,
  0x3a,
  0x74,
  0xe8,
  0xcd,
  0x87,
  0x13,
  0x26,
  0x4c,
  0x98,
  0x2d,
  0x5a,
  0xb4,
  0x75,
  0xea,
  0xc9,
  0x8f,
  0x03,
  0x06,
  0x0c,
  0x18,
  0x30,
  0x60,
  0xc0,
  0x9d,
  0x27,
  0x4e,
  0x9c,
  0x25,
  0x4a,
  0x94,
  0x35,
  0x6a,
  0xd4,
  0xb5,
  0x77,
  0xee,
  0xc1,
  0x9f,
  0x23,
  0x46,
  0x8c,
  0x05,
  0x0a,
  0x14,
  0x28,
  0x50,
  0xa0,
  0x5d,
  0xba,
  0x69,
  0xd2,
  0xb9,
  0x6f,
  0xde,
  0xa1,
  0x5f,
  0xbe,
  0x61,
  0xc2,
  0x99,
  0x2f,
  0x5e,
  0xbc,
  0x65,
  0xca,
  0x89,
  0x0f,
  0x1e,
  0x3c,
  0x78,
  0xf0,
  0xfd,
  0xe7,
  0xd3,
  0xbb,
  0x6b,
  0xd6,
  0xb1,
  0x7f,
  0xfe,
  0xe1,
  0xdf,
  0xa3,
  0x5b,
  0xb6,
  0x71,
  0xe2,
  0xd9,
  0xaf,
  0x43,
  0x86,
  0x11,
  0x22,
  0x44,
  0x88,
  0x0d,
  0x1a,
  0x34,
  0x68,
  0xd0,
  0xbd,
  0x67,
  0xce,
  0x81,
  0x1f,
  0x3e,
  0x7c,
  0xf8,
  0xed,
  0xc7,
  0x93,
  0x3b,
  0x76,
  0xec,
  0xc5,
  0x97,
  0x33,
  0x66,
  0xcc,
  0x85,
  0x17,
  0x2e,
  0x5c,
  0xb8,
  0x6d,
  0xda,
  0xa9,
  0x4f,
  0x9e,
  0x21,
  0x42,
  0x84,
  0x15,
  0x2a,
  0x54,
  0xa8,
  0x4d,
  0x9a,
  0x29,
  0x52,
  0xa4,
  0x55,
  0xaa,
  0x49,
  0x92,
  0x39,
  0x72,
  0xe4,
  0xd5,
  0xb7,
  0x73,
  0xe6,
  0xd1,
  0xbf,
  0x63,
  0xc6,
  0x91,
  0x3f,
  0x7e,
  0xfc,
  0xe5,
  0xd7,
  0xb3,
  0x7b,
  0xf6,
  0xf1,
  0xff,
  0xe3,
  0xdb,
  0xab,
  0x4b,
  0x96,
  0x31,
  0x62,
  0xc4,
  0x95,
  0x37,
  0x6e,
  0xdc,
  0xa5,
  0x57,
  0xae,
  0x41,
  0x82,
  0x19,
  0x32,
  0x64,
  0xc8,
  0x8d,
  0x07,
  0x0e,
  0x1c,
  0x38,
  0x70,
  0xe0,
  0xdd,
  0xa7,
  0x53,
  0xa6,
  0x51,
  0xa2,
  0x59,
  0xb2,
  0x79,
  0xf2,
  0xf9,
  0xef,
  0xc3,
  0x9b,
  0x2b,
  0x56,
  0xac,
  0x45,
  0x8a,
  0x09,
  0x12,
  0x24,
  0x48,
  0x90,
  0x3d,
  0x7a,
  0xf4,
  0xf5,
  0xf7,
  0xf3,
  0xfb,
  0xeb,
  0xcb,
  0x8b,
  0x0b,
  0x16,
  0x2c,
  0x58,
  0xb0,
  0x7d,
  0xfa,
  0xe9,
  0xcf,
  0x83,
  0x1b,
  0x36,
  0x6c,
  0xd8,
  0xad,
  0x47,
  0x8e,
  0x01,
  0x02,
  0x04,
  0x08,
  0x10,
  0x20,
  0x40,
  0x80,
  0x1d,
  0x3a,
  0x74,
  0xe8,
  0xcd,
  0x87,
  0x13,
  0x26,
  0x4c,
  0x98,
  0x2d,
  0x5a,
  0xb4,
  0x75,
  0xea,
  0xc9,
  0x8f,
  0x03,
  0x06,
  0x0c,
  0x18,
  0x30,
  0x60,
  0xc0,
  0x9d,
  0x27,
  0x4e,
  0x9c,
  0x25,
  0x4a,
  0x94,
  0x35,
  0x6a,
  0xd4,
  0xb5,
  0x77,
  0xee,
  0xc1,
  0x9f,
  0x23,
  0x46,
  0x8c,
  0x05,
  0x0a,
  0x14,
  0x28,
  0x50,
  0xa0,
  0x5d,
  0xba,
  0x69,
  0xd2,
  0xb9,
  0x6f,
  0xde,
  0xa1,
  0x5f,
  0xbe,
  0x61,
  0xc2,
  0x99,
  0x2f,
  0x5e,
  0xbc,
  0x65,
  0xca,
  0x89,
  0x0f,
  0x1e,
  0x3c,
  0x78,
  0xf0,
  0xfd,
  0xe7,
  0xd3,
  0xbb,
  0x6b,
  0xd6,
  0xb1,
  0x7f,
  0xfe,
  0xe1,
  0xdf,
  0xa3,
  0x5b,
  0xb6,
  0x71,
  0xe2,
  0xd9,
  0xaf,
  0x43,
  0x86,
  0x11,
  0x22,
  0x44,
  0x88,
  0x0d,
  0x1a,
  0x34,
  0x68,
  0xd0,
  0xbd,
  0x67,
  0xce,
  0x81,
  0x1f,
  0x3e,
  0x7c,
  0xf8,
  0xed,
  0xc7,
  0x93,
  0x3b,
  0x76,
  0xec,
  0xc5,
  0x97,
  0x33,
  0x66,
  0xcc,
  0x85,
  0x17,
  0x2e,
  0x5c,
  0xb8,
  0x6d,
  0xda,
  0xa9,
  0x4f,
  0x9e,
  0x21,
  0x42,
  0x84,
  0x15,
  0x2a,
  0x54,
  0xa8,
  0x4d,
  0x9a,
  0x29,
  0x52,
  0xa4,
  0x55,
  0xaa,
  0x49,
  0x92,
  0x39,
  0x72,
  0xe4,
  0xd5,
  0xb7,
  0x73,
  0xe6,
  0xd1,
  0xbf,
  0x63,
  0xc6,
  0x91,
  0x3f,
  0x7e,
  0xfc,
  0xe5,
  0xd7,
  0xb3,
  0x7b,
  0xf6,
  0xf1,
  0xff,
  0xe3,
  0xdb,
  0xab,
  0x4b,
  0x96,
  0x31,
  0x62,
  0xc4,
  0x95,
  0x37,
  0x6e,
  0xdc,
  0xa5,
  0x57,
  0xae,
  0x41,
  0x82,
  0x19,
  0x32,
  0x64,
  0xc8,
  0x8d,
  0x07,
  0x0e,
  0x1c,
  0x38,
  0x70,
  0xe0,
  0xdd,
  0xa7,
  0x53,
  0xa6,
  0x51,
  0xa2,
  0x59,
  0xb2,
  0x79,
  0xf2,
  0xf9,
  0xef,
  0xc3,
  0x9b,
  0x2b,
  0x56,
  0xac,
  0x45,
  0x8a,
  0x09,
  0x12,
  0x24,
  0x48,
  0x90,
  0x3d,
  0x7a,
  0xf4,
  0xf5,
  0xf7,
  0xf3,
  0xfb,
  0xeb,
  0xcb,
  0x8b,
  0x0b,
  0x16,
  0x2c,
  0x58,
  0xb0,
  0x7d,
  0xfa,
  0xe9,
  0xcf,
  0x83,
  0x1b,
  0x36,
  0x6c,
  0xd8,
  0xad,
  0x47,
  0x8e,
  0x01,
  0x02,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
};

unsigned short galois_log[256] = {
  0x0200,
  0x0000,
  0x0001,
  0x0019,
  0x0002,
  0x0032,
  0x001a,
  0x00c6,
  0x0003,
  0x00df,
  0x0033,
  0x00ee,
  0x001b,
  0x0068,
  0x00c7,
  0x004b,
  0x0004,
  0x0064,
  0x00e0,
  0x000e,
  0x0034,
  0x008d,
  0x00ef,
  0x0081,
  0x001c,
  0x00c1,
  0x0069,
  0x00f8,
  0x00c8,
  0x0008,
  0x004c,
  0x0071,
  0x0005,
  0x008a,
  0x0065,
  0x002f,
  0x00e1,
  0x0024,
  0x000f,
  0x0021,
  0x0035,
  0x0093,
  0x008e,
  0x00da,
  0x00f0,
  0x0012,
  0x0082,
  0x0045,
  0x001d,
  0x00b5,
  0x00c2,
  0x007d,
  0x006a,
  0x0027,
  0x00f9,
  0x00b9,
  0x00c9,
  0x009a,
  0x0009,
  0x0078,
  0x004d,
  0x00e4,
  0x0072,
  0x00a6,
  0x0006,
  0x00bf,
  0x008b,
  0x0062,
  0x0066,
  0x00dd,
  0x0030,
  0x00fd,
  0x00e2,
  0x0098,
  0x0025,
  0x00b3,
  0x0010,
  0x0091,
  0x0022,
  0x0088,
  0x0036,
  0x00d0,
  0x0094,
  0x00ce,
  0x008f,
  0x0096,
  0x00db,
  0x00bd,
  0x00f1,
  0x00d2,
  0x0013,
  0x005c,
  0x0083,
  0x0038,
  0x0046,
  0x0040,
  0x001e,
  0x0042,
  0x00b6,
  0x00a3,
  0x00c3,
  0x0048,
  0x007e,
  0x006e,
  0x006b,
  0x003a,
  0x0028,
  0x0054,
  0x00fa,
  0x0085,
  0x00ba,
  0x003d,
  0x00ca,
  0x005e,
  0x009b,
  0x009f,
  0x000a,
  0x0015,
  0x0079,
  0x002b,
  0x004e,
  0x00d4,
  0x00e5,
  0x00ac,
  0x0073,
  0x00f3,
  0x00a7,
  0x0057,
  0x0007,
  0x0070,
  0x00c0,
  0x00f7,
  0x008c,
  0x0080,
  0x0063,
  0x000d,
  0x0067,
  0x004a,
  0x00de,
  0x00ed,
  0x0031,
  0x00c5,
  0x00fe,
  0x0018,
  0x00e3,
  0x00a5,
  0x0099,
  0x0077,
  0x0026,
  0x00b8,
  0x00b4,
  0x007c,
  0x0011,
  0x0044,
  0x0092,
  0x00d9,
  0x0023,
  0x0020,
  0x0089,
  0x002e,
  0x0037,
  0x003f,
  0x00d1,
  0x005b,
  0x0095,
  0x00bc,
  0x00cf,
  0x00cd,
  0x0090,
  0x0087,
  0x0097,
  0x00b2,
  0x00dc,
  0x00fc,
  0x00be,
  0x0061,
  0x00f2,
  0x0056,
  0x00d3,
  0x00ab,
  0x0014,
  0x002a,
  0x005d,
  0x009e,
  0x0084,
  0x003c,
  0x0039,
  0x0053,
  0x0047,
  0x006d,
  0x0041,
  0x00a2,
  0x001f,
  0x002d,
  0x0043,
  0x00d8,
  0x00b7,
  0x007b,
  0x00a4,
  0x0076,
  0x00c4,
  0x0017,
  0x0049,
  0x00ec,
  0x007f,
  0x000c,
  0x006f,
  0x00f6,
  0x006c,
  0x00a1,
  0x003b,
  0x0052,
  0x0029,
  0x009d,
  0x0055,
  0x00aa,
  0x00fb,
  0x0060,
  0x0086,
  0x00b1,
  0x00bb,
  0x00cc,
  0x003e,
  0x005a,
  0x00cb,
  0x0059,
  0x005f,
  0x00b0,
  0x009c,
  0x00a9,
  0x00a0,
  0x0051,
  0x000b,
  0x00f5,
  0x0016,
  0x00eb,
  0x007a,
  0x0075,
  0x002c,
  0x00d7,
  0x004f,
  0x00ae,
  0x00d5,
  0x00e9,
  0x00e6,
  0x00e7,
  0x00ad,
  0x00e8,
  0x0074,
  0x00d6,
  0x00f4,
  0x00ea,
  0x00a8,
  0x0050,
  0x0058,
  0x00af,
};

unsigned char norpak_delta_inv[256] = {
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x09,
  0xff,
  0xff,
  0x05,
  0xff,
  0xff,
  0xff,
  0x0e,
  0xff,
  0xff,
  0x0d,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x13,
  0xff,
  0xff,
  0x07,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x12,
  0xff,
  0x01,
  0xff,
  0xff,
  0x0c,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x10,
  0x08,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x11,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x16,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x0a,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x00,
  0xff,
  0xff,
  0xff,
  0x15,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x06,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x03,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x18,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x04,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x02,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x0b,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x0f,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0xff,
  0x17,
  0xff,
  0x14,
  0xff,
  0xff,
  0xff,
  0x19,
  0xff,
  0xff,
};

unsigned char decode_hamming_tab[256] = {
  0x01,
  0xff,
  0x01,
  0x01,
  0xff,
  0x00,
  0x01,
  0xff,
  0xff,
  0x02,
  0x01,
  0xff,
  0x0a,
  0xff,
  0xff,
  0x07,
  0xff,
  0x00,
  0x01,
  0xff,
  0x00,
  0x00,
  0xff,
  0x00,
  0x06,
  0xff,
  0xff,
  0x0b,
  0xff,
  0x00,
  0x03,
  0xff,
  0xff,
  0x0c,
  0x01,
  0xff,
  0x04,
  0xff,
  0xff,
  0x07,
  0x06,
  0xff,
  0xff,
  0x07,
  0xff,
  0x07,
  0x07,
  0x07,
  0x06,
  0xff,
  0xff,
  0x05,
  0xff,
  0x00,
  0x0d,
  0xff,
  0x06,
  0x06,
  0x06,
  0xff,
  0x06,
  0xff,
  0xff,
  0x07,
  0xff,
  0x02,
  0x01,
  0xff,
  0x04,
  0xff,
  0xff,
  0x09,
  0x02,
  0x02,
  0xff,
  0x02,
  0xff,
  0x02,
  0x03,
  0xff,
  0x08,
  0xff,
  0xff,
  0x05,
  0xff,
  0x00,
  0x03,
  0xff,
  0xff,
  0x02,
  0x03,
  0xff,
  0x03,
  0xff,
  0x03,
  0x03,
  0x04,
  0xff,
  0xff,
  0x05,
  0x04,
  0x04,
  0x04,
  0xff,
  0xff,
  0x02,
  0x0f,
  0xff,
  0x04,
  0xff,
  0xff,
  0x07,
  0xff,
  0x05,
  0x05,
  0x05,
  0x04,
  0xff,
  0xff,
  0x05,
  0x06,
  0xff,
  0xff,
  0x05,
  0xff,
  0x0e,
  0x03,
  0xff,
  0xff,
  0x0c,
  0x01,
  0xff,
  0x0a,
  0xff,
  0xff,
  0x09,
  0x0a,
  0xff,
  0xff,
  0x0b,
  0x0a,
  0x0a,
  0x0a,
  0xff,
  0x08,
  0xff,
  0xff,
  0x0b,
  0xff,
  0x00,
  0x0d,
  0xff,
  0xff,
  0x0b,
  0x0b,
  0x0b,
  0x0a,
  0xff,
  0xff,
  0x0b,
  0x0c,
  0x0c,
  0xff,
  0x0c,
  0xff,
  0x0c,
  0x0d,
  0xff,
  0xff,
  0x0c,
  0x0f,
  0xff,
  0x0a,
  0xff,
  0xff,
  0x07,
  0xff,
  0x0c,
  0x0d,
  0xff,
  0x0d,
  0xff,
  0x0d,
  0x0d,
  0x06,
  0xff,
  0xff,
  0x0b,
  0xff,
  0x0e,
  0x0d,
  0xff,
  0x08,
  0xff,
  0xff,
  0x09,
  0xff,
  0x09,
  0x09,
  0x09,
  0xff,
  0x02,
  0x0f,
  0xff,
  0x0a,
  0xff,
  0xff,
  0x09,
  0x08,
  0x08,
  0x08,
  0xff,
  0x08,
  0xff,
  0xff,
  0x09,
  0x08,
  0xff,
  0xff,
  0x0b,
  0xff,
  0x0e,
  0x03,
  0xff,
  0xff,
  0x0c,
  0x0f,
  0xff,
  0x04,
  0xff,
  0xff,
  0x09,
  0x0f,
  0xff,
  0x0f,
  0x0f,
  0xff,
  0x0e,
  0x0f,
  0xff,
  0x08,
  0xff,
  0xff,
  0x05,
  0xff,
  0x0e,
  0x0d,
  0xff,
  0xff,
  0x0e,
  0x0f,
  0xff,
  0x0e,
  0x0e,
  0xff,
  0x0e,
};

unsigned char log_norpak_coeffs[2][26] = {
{
  0x20,
  0xb9,
  0x9c,
  0xec,
  0x57,
  0xb2,
  0xc5,
  0x53,
  0x56,
  0x28,
  0x3e,
  0xde,
  0x25,
  0x05,
  0x11,
  0x20,
  0x53,
  0x26,
  0xe4,
  0xc9,
  0xcf,
  0xf5,
  0x8b,
  0x37,
  0x5f,
  0xc3,
},
{
  0x99,
  0x7c,
  0xcc,
  0x37,
  0x92,
  0xa5,
  0x33,
  0x36,
  0x08,
  0x1e,
  0xbe,
  0x05,
  0xe4,
  0xf0,
  0x00,
  0x33,
  0x06,
  0xc4,
  0xa9,
  0xaf,
  0xd5,
  0x6b,
  0x17,
  0x3f,
  0xa3,
  0xc5,
},
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\nabtsprv.h ===
#ifndef NABTSPRV_H
#define NABTSPRV_H

#include "nabtsapi.h"

/* Nabts private */

//#define INTERPOLATE_ARRAY(a,f)	((a)[float2long(f)]+((f)-float2long(f))*((a)[float2long(f)+1]))
inline Double _InterpDoubleArr(Double dArray[], Double dIndex)
{
    unsigned long   nIndex = float2long(dIndex);
    return (dArray[nIndex] + (dIndex-nIndex)*(dArray[nIndex+1]-dArray[nIndex]));
}
inline Double _InterpUCharArr(unsigned char cArray[], Double dIndex)
{
    unsigned long   nIndex = float2long(dIndex);
    return (cArray[nIndex] + (dIndex-nIndex)*(cArray[nIndex+1]-cArray[nIndex]));
}


#ifdef DEBUG
#define EASSERT(exp) ((exp) || \
                      (debug_printf(("\n%s(%d): EASSERT(%s) failed\n", \
                                     __FILE__, __LINE__, #exp)), \
                                     abort_execution(), \
                                     0))
#else //DEBUG
#define EASSERT(exp) 0
#endif //DEBUG
   
#define SASSERT(exp)   (void)(EASSERT(exp))

/*
extern Double* g_pdGCRSignal1;
extern Double* g_pdGCRSignal2;
*/

extern int g_nNabtsAdditionalTapsGCR;

/* Equalization constants */

#define GCR_SIZE 567
#define GCR_SAMPLE_RATE 2

#define NABSYNC_SIZE 115
#define NABSYNC_SAMPLE_RATE 1

#define GCR_START_DETECT 0
#define GCR_END_DETECT 50

#define NABSYNC_START_DETECT 15
#define NABSYNC_END_DETECT 80

/**************************/

/* lower numbers must be better */
typedef enum {fec_errs_0, fec_errs_1, fec_errs_multiple} fec_error_class;

fec_error_class check_fec(unsigned char data[28]);

typedef struct equalize_match_str {
   int nSignalSize;
   int nSignalSampleRate;
   int nSignalStartConv;
   int nSignalEndConv;
   Double *pdSignal;
} EqualizeMatch;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\tables.h ===
/* This file includes the prototypes for the arrays declared in the
   automatically-generated file tables.c */

extern int base_check[];
extern int base_check_inv[];
extern int offset0[];
extern int offset1[];
extern int offset_delta_inv[];
extern int lfsr[];
extern int lfsr_inv[];
extern int hcheck[];

extern struct offsets_corr2_t {
  int offset0[2], offset1[2];
} offsets_corr2[26][26];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\dsp\r0float.c ===
#ifdef _X86_
unsigned char _fltused;

long __cdecl
float2long(float arg)
{
    long  rval;

    __asm {
        fld     arg                 ; Put <arg> into FPU
        fistp   rval                ; Write out the long version
    }

    return rval;
}

unsigned short
__cdecl
floatSetup(void)
{
    unsigned short  oldCWord;
    unsigned short  newCWord;

    __asm {
        wait                           ; Let any pending FPU operations finish
        fnstcw word ptr oldCWord       ; w/o blocking, store FPU Control word
        wait                           ; Wait for the store to complete
        mov    ax,word ptr oldCWord    ; Load the CW into AX
        or     ah,0Ch                  ; Ensure the rounding bits are correct
        mov    word ptr newCWord,ax    ; Save the modified CW from AX
        fldcw  word ptr newCWord       ; Reset the control word with new value
    }

    return oldCWord;
}

void __cdecl
floatRestore(unsigned short ctlWord)
{
    __asm {
        wait                            ; Let any pending FPU operations finish
        fldcw   word ptr ctlWord        ; Restore the CW from the original
    }
}

#endif //_X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\testing\nabtsdump\nabtsdump.c ===
#include <stdio.h>

#define BIT(n)             (((unsigned long)1)<<(n))
#define BITSIZE(v)         (sizeof(v)*8)
#define SETBIT(array,n)    (array[(n)/BITSIZE(*array)] |= BIT((n)%BITSIZE(*array)))
#define CLEARBIT(array,n)  (array[(n)/BITSIZE(*array)] &= ~BIT((n)%BITSIZE(*array)))
#define TESTBIT(array,n)   (BIT((n)%BITSIZE(*array)) == (array[(n)/BITSIZE(*array)] & BIT(n%BITSIZE(*array))))

__cdecl
main(int argc, char *argv[])
{
	unsigned long bitArr[32];
	unsigned long pictureNumber[2];
	int		c, b, i;
	int     lines;
	size_t  bytes;
	FILE	*fp;
	char	*me;

	me = *argv++; --argc;

	while (argc-- > 0) {
		fp = fopen(*argv, "rb");
		if (fp == NULL) {
			fprintf(stderr, "%s: Can't open \"%s\"; ", me, *argv);
			perror("");
			continue;
		}
		b = 0;
		for ( ; ; ) {
			bytes = fread((void *)bitArr, 1, 128, fp);
			if (128 != bytes) {
				if (0 != bytes) {
					fprintf(stderr, "%s: Error reading bitmap; ", me);
					perror("");
				}
				break;
			}

			bytes = fread((void *)pictureNumber, 1, 8, fp);
			if (8 != bytes) {
				if (0 != bytes) {
					fprintf(stderr, "%s: Error reading pictureNumber; ", me);
					perror("");
				}
				break;
			}

			printf("pic# 0x%08x%08x.\n", pictureNumber[1], pictureNumber[0]);

			lines = 0;
#if 0
			if (TESTBIT(bitArr, 0))
				printf("Odd ");
			else
				printf("Even ");
#endif /*0*/
			printf("Lines: ");
			for (i = 1; i < 1024; ++i) {
				if (TESTBIT(bitArr, i-1)) {
					printf("%d, ", i);
					++lines;
				}
			}
			printf("Total = %d.\n", lines);

			while (lines > 0 && (c = getc(fp)) != EOF) {
				++b;
				if (b % 37 == 1)
					printf("%3d%% ", (unsigned char)(c & 0xff));
				else
					printf("%02x", (unsigned char)(c & 0xff));
				if (b % 37 == 4)
					putchar(' ');
				if (b % 37 == 7)
					putchar(' ');
				if (b %	37 == 0) {
					putchar('\n');
					--lines;
				}
			}
			if (c == EOF)
				break;
		}
		putchar('\n');
		fclose(fp);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\bpcdebug.h ===
//
/// "bpcdebug.h"
//

//// Debugging stuff
#ifndef _BPC_DEBUG_
#define _BPC_DEBUG_
#ifdef DEBUG

# pragma message( "*** DEBUG compile" )

# ifdef DEBUG_STORE
   char dtBar[] = "================================================**";
   char dID[] = "NABTSFEC: ";
   short dtLev = 0;
   short dbgLvl = 1;
   short dbgTrace = 0;
   short dbgQuiet = 0;
   char _DAssertFail[] = "ASSERT(%s) FAILED in file \":%s\", line %d\n";

#  include <stdarg.h>
   void _dP(char *fmt, ...)
   {
	   static UCHAR buf[256];
	   va_list args;
	   UCHAR *bp = buf;

	   va_start(args, fmt);
	   if (dbgQuiet)
		   *bp++ = '\'';
	   vsprintf(bp, fmt, args);
	   va_end(args);
	   DbgPrint(buf);
   }
# else /*DEBUG_STORE*/
   extern char dtBar[];
   extern char dID[];
   extern short dtLev;
   extern short dbgLvl;
   extern short dbgTrace;
   extern short dbgQuiet;
   extern char _DAssertFail[];
   extern void _dP(char *fmt, ...);
# endif /*DEBUG_STORE*/

# if _X86_
#   define DBREAK()  do { __asm { int 3 }; } while (0)
# else
#   define DBREAK()  DbgBreakPoint()
# endif
# define _DOK(lvl) (dbgLvl >= (lvl))
# define _DEQ(lvl) (dbgLvl == (lvl))
# define _DID      _dP(dID)
# define DASSERT(exp) do {\
	if ( !(exp) ) {\
	    DbgPrint(_DAssertFail, #exp, __FILE__, __LINE__); \
	    DBREAK(); \
	}\
    } while (0)
# define _DQprintf(lvl,args) do { if (_DEQ(lvl)) { _dP##args; } } while (0)
# define DQprintf(lvl,args) do { if (_DEQ(lvl)) { _DID; _dP##args; } } while (0)
# define _Dprintf(lvl,args) do { if (_DOK(lvl)) { _dP##args; } } while (0)
# define Dprintf(lvl,args) do { if (_DOK(lvl)) { _DID; _dP##args; } } while (0)
# define Dprintx(args) do { if (_DOK(0)) { _DID; DbgPrint##args; DBREAK(); } } while (0)
# define _Dtrace(args) do { if (dbgTrace) { if (dbgTrace > 1) { DbgPrint##args; DBREAK(); } else _dP##args; } } while (0)
# define Dtrace(args) do { if (dbgTrace) _DID; _Dtrace(args); } while (0)
# define DtENTER(name) do { ++dtLev; Dtrace(("%.*s> %s()\n", dtLev*2, dtBar, (name))); } while (0)
# define _DtRETURN() do { Dtrace(("%.*s<\n", dtLev*2, dtBar)); --dtLev; } while (0)
# define DtRETURN do { _DtRETURN(); return; } while (0)
# define _DtRETURNd(rval) do { Dtrace(("%.*s< (%d)\n", dtLev*2, dtBar, (rval))); --dtLev; } while (0)
# define DtRETURNd(rval) do { _DtRETURNd(rval); return (rval); } while (0)


#else /*DEBUG*/


# define DBREAK()
# define DASSERT(exp)
# define _Dprintf(lvl,args)
# define Dprintf(lvl,args)
# define _DQprintf(lvl,args)
# define DQprintf(lvl,args)
# define Dprintx(args)
# define _Dtrace(args)
# define Dtrace(args)
# define DtENTER(args)
# define _DtRETURN()
# define DtRETURN         return
# define _DtRETURNd(rval)
# define DtRETURNd(rval)    return (rval)
#endif /*DEBUG*/
#endif /*_BPC_DEBUG_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\bt829.h ===
/// "Bt829.h" - Sole purpose is to contain the #define below
#define BT829  1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\bpc_vbi.c ===
/* File: bpc_vbi.c
 * Purpose: Contains DecodeVBI()
 * Function:  Decodes VBI lines looking for NABTS
 * Author: John Elliott IV <jelliott@microsoft.COM>
 */

#include "wdm.h"
#include "strmini.h"
#include "ksmedia.h"
#include "kskludge.h"

#include "codmain.h"

#include "bt829.h"
#include "bpcstore.h"

#include "bpc_vbi.h"

#include "nabtsapi.h"
#include "WDMIoctl.h"

#define DEBUG_STORE
#include "bpcdebug.h"
#include "coddebug.h"

#ifdef BT829
KS_VBIINFOHEADER DefaultVBIInfoHeader =
{
    10,             /* StartLine;                   */
    21,             /* EndLine;                     */
    28636360,       /* SamplingFrequency;   Hz. */
    732,            /* MinLineStartTime;    IGNORED */
    732,            /* MaxLineStartTime;    IGNORED */
    732,            /* ActualLineStartTime; microSec * 100 from HSync LE */
    0,              /* ActualLineEndTime;   IGNORED */
    KS_AnalogVideo_NTSC_M, /* VideoStandard;       IGNORED */
    VBISamples,     /* SamplesPerLine;              */
    VBISamples,     /* StrideInBytes;       May be > SamplesPerLine */
    VBISamples*12   /* BufferSize;          Bytes */
};
#else // BT829
KS_VBIINFOHEADER DefaultVBIInfoHeader = 
{
    10,             /* StartLine;                   */
    21,             /* EndLine;                     */
    28636360,       /* SamplingFrequency;   Hz. */
    866,            /* MinLineStartTime;    IGNORED */
    866,            /* MaxLineStartTime;    IGNORED */
    866,            /* ActualLineStartTime; microSec * 100 from HSync LE */
    0,              /* ActualLineEndTime;   IGNORED */
    KS_AnalogVideo_NTSC_M, /* VideoStandard;       IGNORED */
    VBISamples,     /* SamplesPerLine;              */
    VBISamples,     /* StrideInBytes;       May be > SamplesPerLine */
    VBISamples*12   /* BufferSize;          Bytes */
};
#endif // BT829

void
BPCcomputeAverage(DWORD *average, DWORD newSample)
{
    // Compute rolling cumulative average[ A' = (A * .75) + (D * .25) ]
    *average = ((*average * 3) + newSample) / 4;
}


#ifdef NDIS_PRIVATE_IFC
void
BPCaddIPrequested(PHW_DEVICE_EXTENSION pHwDevExt, PSTREAMEX pStrmEx)
{
    PBPC_VBI_STORAGE   storage = &pHwDevExt->VBIstorage;
    int                i;

    DtENTER("BPCaddIPrequested");

    // Is the NABTSIP device status OK?
    if (0 != (storage->flags & BPC_STORAGE_FLAG_NDIS_ERROR))
        return;    // If not, we don't need any lines/substreams for IP

    for (i = 0; i < ENTRIES(pStrmEx->ScanlinesRequested.DwordBitArray); ++i) {
        pStrmEx->ScanlinesRequested.DwordBitArray[i] |= 
            storage->IPScanlinesRequested.DwordBitArray[i];
    }
    for (i = 0; i < ENTRIES(pStrmEx->SubstreamsRequested.SubstreamMask); ++i) {
        pStrmEx->SubstreamsRequested.SubstreamMask[i] |= 
            storage->IPSubstreamsRequested.SubstreamMask[i];
    }

    // BUGBUG - Many stations are sending on 0x242; so for now we'll include it
    SETBIT(pStrmEx->SubstreamsRequested.SubstreamMask, 0x242);  // BUGBUG

    DtRETURN;
}

void
BPC_NDIS_Close(PBPC_VBI_STORAGE storage)
{
    if (0 != storage->pNDISdevObject) {
        ObDereferenceObject(storage->pNDISdevObject);
        storage->pNDISdevObject = 0;

        ObDereferenceObject(storage->pNDISfileObject);
        storage->pNDISfileObject = 0;
    }
}
#endif //NDIS_PRIVATE_IFC

int
BPCoutputNABTSlines(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PSTREAMEX pStrmEx,
    PNABTS_BUFFER pOutData
  )
{
    PBPC_VBI_STORAGE                         storage;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN  pPinStats;
    PVBICODECFILTERING_SCANLINES             pBits;
    PUCHAR                                   DSPbuffer;
    int                                      line;
    int                                      sum, cnt;
    int                                      rval;

    DtENTER("BPCoutputNABTSlines");

    storage = &pHwDevExt->VBIstorage;
    pPinStats = &pStrmEx->PinStats;

    sum = 0;
    cnt = 0;
    rval = 0;

    // First, set the PictureNumber
    pOutData->PictureNumber = pHwDevExt->LastPictureNumber;
    rval += sizeof (pOutData->PictureNumber);

    // Next, zero the output bit array
    pBits = &pOutData->ScanlinesRequested;
    RtlZeroMemory((PVOID)pBits->DwordBitArray, sizeof (pBits->DwordBitArray));
    rval += sizeof (*pBits);

    // Finally, output the acutal decoded lines
    // BUGBUG - note that we're not filtering for groupID
    for (line = 10; line <= 20; ++line) {
        if (TESTBIT(pStrmEx->ScanlinesRequested.DwordBitArray, line)) {
            SETBIT(pBits->DwordBitArray, line);
            DSPbuffer = storage->DSPbuffers[line-10];
            sum += DSPbuffer[0];
            ++cnt;
            RtlCopyMemory((PVOID)&pOutData->NabtsLines[line-10],
                          (PVOID)DSPbuffer,
                          NABTS_BYTES_PER_LINE+1);
            rval += NABTS_BYTES_PER_LINE+1;
        }
    }

    // Do stats
    BPCcomputeAverage(&pPinStats->Common.LineConfidenceAvg, cnt? (sum/cnt):0);

    DtRETURNd(rval);
}

#ifdef DEBUG
USHORT NABoutputHex = 0;

static void
_dumpNABTS(PUCHAR pBuffer, int bytes)
{
    int        i;

    if (NABoutputHex) {
        for (i = 0; i < bytes; ++i)
            DbgPrint("%02x", pBuffer[i]);
    }
    else {
        for (i = 0; i < bytes; ++i) {
            UCHAR  c = pBuffer[i];
        if (c < ' ' || c > '~')
            c = '.';
        DbgPrint(" %c", c);
        }
    }
    DbgPrint("\n");
    if (dbgLvl >= 7)
        DBREAK();
}

static char   plotDashes[] = "------------------------------------------------------------------------------------------------------------------------";
static char   plotSync[16][120];
void
BPCplotInd(unsigned char *buf, unsigned long offset, unsigned long len, long ind)
{
    int i, j, start, end;
    unsigned char   *pS;

    if (len >= sizeof (plotSync[0]))
        len = sizeof (plotSync[0]) - 1;

    for (i = 0, pS = buf + offset; i < len; ++i, ++pS)
    {
        for (j = 0; j < 16; ++j)
            if (i == ind)
                plotSync[j][i] = '|';
            else
                plotSync[j][i] = ' ';
        j = *pS >> 4;
        plotSync[j][i] = '*';
    }
    for (j = 0; j < 16; ++j)
        plotSync[j][len] = '\0';

    DbgPrint("--+%.*s+\n", len, plotDashes);
    for (i = 15; i >= 0; --i)
        DbgPrint("%c0+%s-\n", "0123456789ABCDEF"[i], plotSync[i]);
    DbgPrint("--+%.*s+\n", len, plotDashes);

    start = offset;
    end = len + offset;
    offset = end;
    DbgPrint("  |");
    if (offset / 1000 > 0) {
        for (i = start; i < end; ++i)
            DbgPrint("%d", i / 1000);
        DbgPrint("\n  |");
    }
    if (offset / 100 > 0) {
        for (i = start; i < end; ++i)
            DbgPrint("%d", (i % 1000) / 100);
        DbgPrint("\n  |");
    }
    for (i = start; i < end; ++i)
        DbgPrint("%d", (i % 100) / 10);
    DbgPrint("\n  |");
    for (i = start; i < end; ++i)
        DbgPrint("%d", i % 10);
    DbgPrint("\n");
}

void
BPCplot(unsigned char *buf, unsigned long offset, unsigned long len)
{
    BPCplotInd(buf, offset, len, -1);
}
#endif /*DEBUG*/

void
DecodeFECcallback(void *context, NFECBundle *pBundle, int groupAddr, int nGoodLines)
{
    PHW_DEVICE_EXTENSION   pHwDevExt;
    PSTREAMEX              pStrmEx;
    PBPC_VBI_STORAGE       storage;
    PNABTSFEC_ITEM         pNab;
    PUCHAR                 pOutput;
    ULONG                  outputLen;
    int                    i;
    PIRP                   pIrp;
    IO_STATUS_BLOCK        IoStatusBlock;
    NAB_DATA               data_line;
    NTSTATUS               callDriverStatus;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;
#ifdef DEBUG
    USHORT          FECoutputLine = 1;
    USHORT          FECsendIRP = 1;
#endif /*DEBUG*/

    DtENTER("DecodeFECcallback");

    pStrmEx = (PSTREAMEX)context;
    pHwDevExt = pStrmEx->pHwDevExt;
    DASSERT(pHwDevExt);  // make sure we have a device extension
    storage = &pHwDevExt->VBIstorage;
    pStats = &pHwDevExt->Stats;
    pPinStats = &pStrmEx->PinStats;

    ++pStats->BundlesProcessed;

    pNab = ExAllocatePool(NonPagedPool, sizeof (*pNab));
    if (NULL == pNab) {
        ++pStats->Common.ExternalErrors;
        ++pPinStats->Common.ExternalErrors;
        ++pStats->Common.OutputFailures;
        Dprintx(("DecodeFECcallback: ExAllocatePool Failed\n"));
        ExFreePool(pBundle);
        DtRETURN;
    }

    pOutput = pNab->bundle.data;
    outputLen = 0;
    for (i = 0; i < NABTS_LINES_PER_BUNDLE; ++i)
    {
        NFECPacket*pp = &pBundle->packets[i];
#ifdef DEBUG
        char  status;

        if (FECoutputLine && _DOK(3)) {
            switch (pp->status) {
                case NFEC_OK:     status = 'K';  break;
                case NFEC_GUESS:  status = 'G';  break;
                case NFEC_BAD:    status = 'B';
                                  ++pStats->FECBundleBadLines;
                                  break;
                default:          status = '?';  break;
            }
            DbgPrint("%02x%c%02d:", groupAddr, status, pp->len);
            _dumpNABTS(pp->data, pp->len);
        }
        else if (_DEQ(2)) {
            switch (pp->status) {
                case NFEC_OK:  status = '@';  break;
                case NFEC_GUESS:  status = '`';  break;
                case NFEC_BAD:  status = '#';  break;
                default:  status = '?';  break;
            }
            if (status == '@' || status == '`')
                status += (pp->len <= 30)? pp->len : 30;  // Don't want DEL
            DbgPrint("%c", status);
        }
#else /*DEBUG*/
        switch (pp->status) {
            case NFEC_OK:     break;
            case NFEC_GUESS:  break;
            case NFEC_BAD:    ++pStats->FECBundleBadLines;
                              break;
        }
#endif /*DEBUG*/
        if (pp->status != NFEC_BAD && pp->len > 0) {
            RtlCopyBytes(pOutput, pp->data, pp->len);
            pOutput += pp->len;
            outputLen += pp->len;
        }
    }

    // Was there anything in the bundle?  If so, add the bundle to the Q's rear
    if (outputLen > 0) {
        KIRQL           Irql;
        pNab->bundle.groupID = groupAddr;
        pNab->bundle.Reserved = 0;
        pNab->bundle.dataSize = outputLen;
        pNab->confidence = pBundle->lineConfAvg;

        KeAcquireSpinLock(&storage->q_SpinLock, &Irql);
        if (storage->q_length < NF_Q_MAX_BUNDLES) {
            // Add this bundle to the rear of the queue
            pNab->prev = NULL;
            pNab->next = storage->q_rear;
            if (NULL != storage->q_rear) {
                DASSERT(NULL == storage->q_rear->prev);
                storage->q_rear->prev = pNab;
            }
            if (storage->q_front == NULL) {
                DASSERT(storage->q_rear == NULL);
                storage->q_front = pNab;
                DASSERT(storage->q_length == 0);
            }
            storage->q_rear = pNab;
            storage->q_length += 1;
            KeReleaseSpinLock( &storage->q_SpinLock, Irql );
#ifdef DEBUG
            if (storage->q_length > storage->q_max)
                storage->q_max = storage->q_length;
            if (storage->q_length == NF_Q_MAX_BUNDLES/4)
                Dprintf(1,("FEC: WARNING - Queue at 25%%\n"));
            else if (storage->q_length == NF_Q_MAX_BUNDLES/2)
                Dprintf(1,("FEC: WARNING - Queue at 50%%\n"));
            else if (storage->q_length == (NF_Q_MAX_BUNDLES/4)*3)
                Dprintf(1,("FEC: WARNING - Queue at 75%%\n"));
            else if (storage->q_length > (NF_Q_MAX_BUNDLES/4)*3
                     && (storage->q_length & 3) == 0)
            {
                Dprintf(1,("FEC: WARNING - Queue at %d%%\n",
                    (storage->q_length*100) / NF_Q_MAX_BUNDLES));
            }
#endif /*DEBUG*/
        }
        else {
            KeReleaseSpinLock( &storage->q_SpinLock, Irql );
            ++pStats->FECQueueOverflows;
            ++pStats->Common.OutputFailures;
            Dprintf(1,("FEC: QUEUE FULL; dropping bundle\n"));
        }
    }

#ifdef NDIS_PRIVATE_IFC
    if (NULL == storage->pNDISdevObject
        && 0 != outputLen
        && 0 == pHwDevExt->ActualInstances[STREAM_Decode]
        && 0 == (storage->flags & BPC_STORAGE_FLAG_NDIS_ERROR))
    {
        NTSTATUS              status;
        UNICODE_STRING        driverName;

        // Open NDIS mini-driver (to which we toss NABTS data as it comes in)
        RtlInitUnicodeString(&driverName, BPC_NABTSIP_DRIVER_NAME);
        status = IoGetDeviceObjectPointer(
                    &driverName,
                    FILE_WRITE_DATA,
                    &storage->pNDISfileObject,
                    &storage->pNDISdevObject);
        if (STATUS_SUCCESS != status) {
            Dprintf(3,("IoGetDeviceObjectPointer failed, status=0x%x\n", status));
            storage->pNDISdevObject = 0;
            storage->pNDISfileObject = 0;
            storage->flags |= BPC_STORAGE_FLAG_NDIS_ERROR;  // Don't try again
        }
    }
#endif //NDIS_PRIVATE_IFC

    if (outputLen == 0)
    {
        Dprintf(3,("FEC: zero-length bundle; ignoring\n"));
    }
#ifdef NDIS_PRIVATE_IFC
    else if ( pHwDevExt->ActualInstances[STREAM_Decode] )
    {
        Dprintf(3,("Skipping private call to NDIS adapter.  NABTS Output is Pin Open!\n"));
    }
    else if (NULL == storage->pNDISdevObject)
    {
        Dprintf(3,("FEC: Can't output to NDIS, driver not open\n"));
    }
    else
#ifdef DEBUG
    if (FECsendIRP)
#endif /*DEBUG*/
    {
        // Now, create the IRP
        Dprintf(3,("Entering IRP code\n"));

        // Set up IOCTL structure
        data_line.ulStreamId = groupAddr;
        data_line.pvIn = pNab->bundle.data;
        data_line.ulIn = outputLen;

        Dprintf(4,("..Calling IoBuildDeviceIoControlRequest\n"));
        pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_NAB_RECEIVE_DATA,// From WDMIoctl.h
                storage->pNDISdevObject,
                &data_line,
                sizeof (data_line),
                0,// Optional output buffer
                0,// Optional output buffer length
                TRUE,// InternalDeviceIoControl == TRUE
                NULL,// Optional Event
                &IoStatusBlock
            );
        Dprintf(4,("..return from IoBuildDeviceIoControlRequest; pIrp = 0x%x\n", pIrp));
        if (pIrp != 0)
        {
            PIO_STACK_LOCATION   pIrpSl;

            pIrpSl = IoGetNextIrpStackLocation(pIrp);
            if (pIrpSl)
                pIrpSl->FileObject = storage->pNDISfileObject;
            else
                Dprintx(("IoGetNextIrpStackLocation() returned NULL\n"));

            IoStatusBlock.Status = STATUS_SUCCESS;
            callDriverStatus = STATUS_SUCCESS;

            // Feed the NDIS mini-driver
            Dprintf(4,("..Calling IoCallDriver\n"));
            callDriverStatus = IoCallDriver(storage->pNDISdevObject, pIrp);
            Dprintf(4,("..returned from IoCallDriver, status = 0x%x\n", callDriverStatus));

            if (STATUS_SUCCESS != callDriverStatus
                || STATUS_SUCCESS != IoStatusBlock.Status)
            {
#ifdef DEBUG
                char       *what;
                NTSTATUS   status;

                if (STATUS_SUCCESS == callDriverStatus) {
                    what = "IOCTL_NAB_RECEIVE_DATA";
                    status = IoStatusBlock.Status;
                }
                else {
                    what = "IoCallDriver()";
                    status = callDriverStatus;
                }

                Dprintx(("%s failed; status = 0x%x\n", what, status));
#endif /*DEBUG*/

                // Any failure here is likely severe; so we close the driver.
                storage->flags |= BPC_STORAGE_FLAG_NDIS_ERROR;
                BPC_NDIS_Close(storage);
            }
            else
                ++pStats->BundlesSent2IP;
        }
        else {
            ++pStats->Common.ExternalErrors;
            Dprintx(("IoBuildDeviceIoControlRequest FAILED\n"));
        }

        Dprintf(3,("Leaving IRP code\n"));
    }
#endif //NDIS_PRIVATE_IFC

    if (outputLen == 0 || storage->q_length >= NF_Q_MAX_BUNDLES)
        ExFreePool(pNab);
    ExFreePool(pBundle);

    DtRETURN;
}

#ifdef DEBUG
void
SimulateFECcallback(PHW_DEVICE_EXTENSION  pHwDevExt)
{
    PBPC_VBI_STORAGE  storage = &pHwDevExt->VBIstorage;
    NFECBundle        *pBundle;
    int               i;
    static int        field = 0;

    DtENTER("SimulateFECcallback");

    if (0 != (++field & 0xF))
        DtRETURN;

    pBundle = ExAllocatePool(NonPagedPool, sizeof (NFECBundle));
    if (NULL == pBundle) {
        Dprintx(("SimulateFECcallback: ExAllocatePool Failed\n"));
        DtRETURN;
    }

    for (i = 0; i < 14; ++i)
    {
        NFECPacket*pp = &pBundle->packets[i];
        pp->len = 26;
        pp->status = NFEC_OK;
    }
    for (i = 14; i < 16; ++i)
    {
        NFECPacket*pp = &pBundle->packets[i];
        pp->len = 0;
        pp->status = NFEC_OK;
    }

    DecodeFECcallback((void *)pHwDevExt, pBundle, 0x8F0, 14);

    DtRETURN;
}
#endif /*DEBUG*/

void
BPCdoFEC(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PSTREAMEX            pStrmEx,
    PUCHAR               pDSPbuffer
    )
{
    PBPC_VBI_STORAGE                  storage;
    NFECLineStats                     FEClineStats;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = &pHwDevExt->Stats;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = &pStrmEx->PinStats;

    DASSERT(pHwDevExt);  // make sure we have a device extension
    DASSERT(pStrmEx);  // make sure we have a stream extension

    DtENTER("BPCdoFEC");

    storage = &pHwDevExt->VBIstorage;

    if (!storage->pFECstate) {
        ++pStats->Common.InternalErrors;
        ++pPinStats->Common.InternalErrors;
        DtRETURN;    // Unsuccessful FEC initialization.
    }

    FEClineStats.nSize = sizeof (FEClineStats);

#ifdef DEBUG
    if (pDSPbuffer[0] < 50)
        DtRETURN;// Line not scanned or DSP unhappy; ignore line

    if (dbgLvl >= 6) {
        DbgPrint("FEC:  ");
        _dumpNABTS(pDSPbuffer+1, 36);
    }
#endif /*DEBUG*/
    NFECDecodeLine(pDSPbuffer+1, pDSPbuffer[0], storage->pFECstate,
                    &FEClineStats, DecodeFECcallback, (PVOID)pStrmEx);

    switch (FEClineStats.status) {
        case NFEC_LINE_OK:
            _DQprintf(2,("+"));
            Dprintf(5,("FEC: addr %02x%02x%02x:%02x%02x OK\n",
                    pDSPbuffer[4],
                    pDSPbuffer[5],
                    pDSPbuffer[6],
                    pDSPbuffer[7],
                    pDSPbuffer[8]));
            break;
        case NFEC_LINE_CHECKSUM_ERR:
            ++pStats->FECCorrectedLines;
            _DQprintf(2,("-"));
            Dprintf(4,("FEC: addr %02x%02x%02x:%02x%02x CSUM corrected\n",
                    pDSPbuffer[4],
                    pDSPbuffer[5],
                    pDSPbuffer[6],
                    pDSPbuffer[7],
                    pDSPbuffer[8]));
            break;
        case NFEC_LINE_CORRUPT:
            ++pStats->FECUncorrectableLines;
            _DQprintf(2,("x"));
            Dprintf(4,("FEC: addr %02x%02x%02x:%02x%02x CORRUPT\n",
                    pDSPbuffer[4],
                    pDSPbuffer[5],
                    pDSPbuffer[6],
                    pDSPbuffer[7],
                    pDSPbuffer[8]));
            break;
        default:
            Dprintx(("FEC: addr %02x%02x%02x:%02x%02x undefined return code %d\n",
                    pDSPbuffer[4],
                    pDSPbuffer[5],
                    pDSPbuffer[6],
                    pDSPbuffer[7],
                    pDSPbuffer[8]));
            break;
    }

    DtRETURN;
}

void
BPC_Initialize(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION  pHwDevExt = pSrb->HwDeviceExtension;
    PBPC_VBI_STORAGE      storage = &pHwDevExt->VBIstorage;

    DtENTER("VBI_Initialize");

#ifdef NDIS_PRIVATE_IFC
    storage->pNDISdevObject = 0;
    storage->pNDISfileObject = 0;
#endif //NDIS_PRIVATE_IFC
    storage->pFECstate = 0;
    storage->pDSPstate = 0;

    storage->IPScanlinesRequested = pHwDevExt->ScanlinesRequested;
    storage->IPSubstreamsRequested = pHwDevExt->SubstreamsRequested;

    KeInitializeSpinLock(&storage->q_SpinLock);
    storage->q_front = NULL;
    storage->q_rear = NULL;
    storage->q_length = 0;

    DtRETURN;
}

void
BPC_UnInitialize(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PHW_DEVICE_EXTENSION  pHwDevExt = pSrb->HwDeviceExtension;
    PBPC_VBI_STORAGE      storage = &pHwDevExt->VBIstorage;

    DtENTER("VBI_UnInitialize");
    
#ifdef NDIS_PRIVATE_IFC
    // Close NDIS mini-driver
    BPC_NDIS_Close(storage);
    storage->flags &= ~BPC_STORAGE_FLAG_NDIS_ERROR;
#endif //NDIS_PRIVATE_IFC

    // Destroy our DSP and FEC states
    if (0 != storage->pDSPstate) {
        NDSPStateDestroy(storage->pDSPstate);
        storage->pDSPstate = 0;
    }
    if (0 != storage->pFECstate) {
        NFECStateDestroy(storage->pFECstate);
        storage->pFECstate = 0;
    }

    DtRETURN;
}

void
BPC_OpenStream(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAMEX             pStrmEx = pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION  pHwDevExt = pSrb->HwDeviceExtension;
    PBPC_VBI_STORAGE      storage = &pHwDevExt->VBIstorage;

    DtENTER("VBI_OpenStream");

    // Set up a default VBI Info header (in case we don't get any others)
    pStrmEx->CurrentVBIInfoHeader = DefaultVBIInfoHeader;

    // Initialize our DSP and FEC states
    if (0 == storage->pDSPstate) {
        storage->pDSPstate = NDSPStateNew(&storage->DSPstate);
        if (0 == storage->pDSPstate)
            Dprintx(("NDSPStateNew(open) failed!\n"));
    }
    if (0 == storage->pFECstate) {
        storage->pFECstate = NFECStateNew();
        if (0 == storage->pFECstate)
            Dprintx(("NFECStateNew() failed!\n"));
        else if (0 != storage->pDSPstate)
            NFECStateConnectToDSP(storage->pFECstate, storage->pDSPstate);
    }

    DtRETURN;
}

void
BPC_SignalStop(PHW_DEVICE_EXTENSION pHwDevExt)
{
    PBPC_VBI_STORAGE      storage = &pHwDevExt->VBIstorage;

    DtENTER("VBI_SignalStop");

#ifdef NDIS_PRIVATE_IFC
    // The graph is stopping; so clear the ERROR flag so we'll try to reopen
    storage->flags &= ~BPC_STORAGE_FLAG_NDIS_ERROR;
#endif //NDIS_PRIVATE_IFC

    DtRETURN;
}

void
BPCsourceChangeNotify(PHW_DEVICE_EXTENSION pHwDevExt)
{
    PBPC_VBI_STORAGE      storage;

    DtENTER("BPCsourceChangeNotify");

    storage = &pHwDevExt->VBIstorage;
    if (storage->pDSPstate)
        (void)NDSPStartRetrain(storage->pDSPstate);

    DtRETURN;
}


#ifdef DEBUG
USHORT DSPskipDecode = 0;
USHORT DSPskipDecodeSimulate = 0;
USHORT DSPskipFEC = 0;
USHORT DSPskipFECSimulate = 0;
USHORT DSPoutputLine = 0;
USHORT DSPwatchLine = 0;
USHORT DSPperfMeter = 0;
USHORT DSPshowUnderscore = 0;
USHORT DSPscanAll = 0;
USHORT DSPlogLostFields = 0;
#ifdef DSP_USE_EQ
USHORT DSPskipEQ = 0;
#endif //DSP_USE_EQ

USHORT DSPplotSync = 0;
USHORT DSPplotSyncStart = 0;
USHORT DSPplotSyncLen = 80;

USHORT DSPverifyStart = 10;
USHORT DSPverifyEnd = 20;
USHORT DSPverifyShowFail = 0;
USHORT DSPverifyShowOK = 0;
USHORT DSPverifyPayload = 0;
UCHAR  DSPverifyPayloadByte = 0;
USHORT DSPverifyPayloadGroup = 0xFFFF;  // 0xFFFF means ALL groups
USHORT DSPverifyStream = 0;
UCHAR  DSPverifyStreamByte = 0;
#endif /*DEBUG*/

void
BPCdecodeVBI(PHW_STREAM_REQUEST_BLOCK pSrb, PSTREAMEX pStrmEx)
{
    PKSSTREAM_HEADER                  pDataPacket;
    PUCHAR                            pSamples;
    PHW_DEVICE_EXTENSION              pHwDevExt;
    PKSSTREAM_HEADER                  pStrmHdr;
    PKS_VBI_FRAME_INFO                pVBIFrameInfo;
    PBPC_VBI_STORAGE                  storage;
    PKS_VBIINFOHEADER                 pVBIinfo;
    unsigned int                      line;
    unsigned int                      startLine;
    unsigned int                      stopLine;
    NDSPLineStats                     DSPlineStats;
    PUCHAR                            pDSPbuffer;
    int                               status;
    int                               field;
    KFLOATING_SAVE                    FPstate;
    unsigned short                    FPctrlWord;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;

    DtENTER("BPCdecodeVBI");

    DASSERT(pSrb);
    DASSERT(pStrmEx);
    pHwDevExt = pSrb->HwDeviceExtension;
    DASSERT(pHwDevExt);

    pDataPacket = pSrb->CommandData.DataBufferArray;
    pSamples =  (PUCHAR)pDataPacket->Data;
    pStrmHdr = pSrb->CommandData.DataBufferArray;
    pVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pStrmHdr+1);
    storage = &pHwDevExt->VBIstorage;

    pStats = &pHwDevExt->Stats;
    pPinStats = &pStrmEx->PinStats;

    field = (int)(pStrmEx->LastPictureNumber & 0x3FFFFFFF) << 1;
    if (pVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_FIELD1) {
        field |= 1;
        storage->flags |= BPC_STORAGE_FLAG_FIELD_ODD;
    }
    else
        storage->flags &= ~BPC_STORAGE_FLAG_FIELD_ODD;


    // Clear what's been recently discovered
    // (the input pin only holds what was discovered in the current field)
    RtlZeroMemory(&pStrmEx->ScanlinesDiscovered,
                  sizeof (pStrmEx->ScanlinesDiscovered));
    RtlZeroMemory(&pStrmEx->SubstreamsDiscovered,
                  sizeof (pStrmEx->SubstreamsDiscovered));

#ifdef DEBUG
    if (pStrmHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY) {
        // Don't increment stats here; just show the user
        //  [VBIdiscontinuity() takes care of the stats]
        if (DSPlogLostFields)
            Dprintf(1,("DSP: field(s) lost at %010d\n", field));
        else {
            Dprintf(3,("DSP: field(s) lost\n"));
        }
    }

    if (DSPperfMeter) {
        if ((pStrmEx->LastPictureNumber % DSPperfMeter) == 0)
            DbgPrint("*");
    }

    if (DSPskipDecode) {
        if (DSPskipDecodeSimulate)
            SimulateFECcallback(pHwDevExt);
        DtRETURN;
    }
#endif /*DEBUG*/

    pVBIinfo = &pStrmEx->CurrentVBIInfoHeader;

    if (storage->pDSPstate == NULL) {
        ++pStats->Common.InternalErrors;
        ++pPinStats->Common.InternalErrors;
        DtRETURN;
    }

    // Clear all the DSP buffers
    for (line = 10; line <= 20; ++line) {
        pDSPbuffer = storage->DSPbuffers[line-10];
        pDSPbuffer[0] = pDSPbuffer[1] = 0;
    }

    // Figure out where the part of the universe we care about starts and ends
    startLine = 10;
    if (pVBIinfo->StartLine > startLine)
        startLine = pVBIinfo->StartLine;
    stopLine = 20;
    if (pVBIinfo->EndLine < stopLine)
        stopLine = pVBIinfo->EndLine;

    // Now figure out if we have something to do, and if so, where
#ifdef DEBUG
    if (!DSPscanAll)
#endif /*DEBUG*/
    {
        for ( ; startLine <= stopLine; ++startLine) {
            if (TESTBIT(pStrmEx->ScanlinesRequested.DwordBitArray, startLine))
                break;
        }
        if (startLine > stopLine) {
            ++pStats->Common.SRBsIgnored;
            ++pPinStats->Common.SRBsIgnored;
            Dprintf(6,("DSP: No lines requested; returning...\n"));
            DtRETURN;// No lines requested, nothing to do
        }
        for ( ; stopLine >= startLine; --stopLine) {
            if (TESTBIT(pStrmEx->ScanlinesRequested.DwordBitArray, stopLine))
                break;
        }
    }

    if (pVBIinfo->StartLine < startLine)
        pSamples +=
            (startLine - pVBIinfo->StartLine) * pVBIinfo->StrideInBytes;

    // Save FP state
    {
        NTSTATUS   sts;

        sts = KeSaveFloatingPointState(&FPstate);
        if (STATUS_SUCCESS != sts) {
            ++pStats->Common.ExternalErrors;
            ++pPinStats->Common.ExternalErrors;
            Dprintx(("KeSaveFloatingPointState FAILED! status = 0x%x\n", sts));
            DtRETURN;
        }
        FPctrlWord = floatSetup();
    }

#ifdef DSP_USE_EQ
    // Call GCR/Equalization code for this field so the DSP can
    //  figure its EQ settings
    // (we MUST make this call even if we're not using GCR for EQ)
    if (startLine <= 19 && 19 <= stopLine
#ifdef DEBUG
        && !DSPskipEQ
#endif //DEBUG
        )
    {
        PUCHAR          pGCRsamples;
        NDSPGCRStats    GCRstats;

        pGCRsamples = pSamples + ((19-startLine) * pVBIinfo->StrideInBytes);
        NDSPProcessGCRLine(&GCRstats, pGCRsamples, storage->pDSPstate,
                           field, 19, pVBIinfo);
    }
#endif //DSP_USE_EQ

    // Next, call the DSP on each requested line to see what it thinks
#ifdef DEBUG
    if (DSPoutputLine >= 3)
        DbgPrint("\n");
#endif /*DEBUG*/
    for (line = startLine; line <= stopLine; ++line, pSamples += pVBIinfo->StrideInBytes)
    {
        if (!TESTBIT(pStrmEx->ScanlinesRequested.DwordBitArray, line)
#ifdef DEBUG
            && !DSPscanAll
#endif /*DEBUG*/
            )
        {
#ifdef DEBUG
            if (DSPshowUnderscore)
                _DQprintf(2,("~"));
#endif /*DEBUG*/
            continue;
        }

#ifdef DEBUG
    if (DSPplotSync)
        BPCplot(pSamples, DSPplotSyncStart, DSPplotSyncLen);
#endif /*DEBUG*/

        pDSPbuffer = storage->DSPbuffers[line-10];
        pDSPbuffer[0] = 0;// Confidence

        // Initialize DSPlineStats
        DSPlineStats.nSize = sizeof (DSPlineStats);

        // Call NABTS DSP code
        DtENTER("NDSPDecodeLine");
        status = NDSPDecodeLine(pDSPbuffer+1, &DSPlineStats,
                                pSamples,
                                storage->pDSPstate,
                                NDSP_NO_FEC,
                                field, line, pVBIinfo);
        _DtRETURNd(status);

        if (status == 0) {
            if (DSPlineStats.nConfidence >= 100)
                pDSPbuffer[0] = 100;// Confidence
            else if (DSPlineStats.nConfidence > 0)
                pDSPbuffer[0] = (UCHAR)DSPlineStats.nConfidence;

            // Use truncated [0-100] confidence for stats
            BPCcomputeAverage(&pStats->Common.LineConfidenceAvg, pDSPbuffer[0]);
            BPCcomputeAverage(&pPinStats->Common.LineConfidenceAvg, pDSPbuffer[0]);
#ifdef DEBUG
            if ((DSPverifyPayload || DSPverifyStream)
                && line >= DSPverifyStart 
                && line <= DSPverifyEnd)
            {
                static int  cols = 0;
                int         field;

                field = (int)(pStrmEx->LastPictureNumber % 100);

                if (DSPlineStats.nConfidence < 50) {
                    if (DSPverifyShowFail)
                    {
                        char    *str;
                        UCHAR   *pSam;

                        str = "ZZZ:ZZ";
                        for (pSam = pSamples;
                             pSam < pSamples + pVBIinfo->StrideInBytes;
                             ++pSam)
                        {
                            if (0 != *pSam) {
                                str = "XXX:XX";
                                break;
                            }
                        }
                        _DQprintf(1,("%02d%1x:%s", field, line-10, str));
                        if (DSPverifyStream)
                            _DQprintf(1,("=XX/XX"));
                        _DQprintf(1,(";"));
                        if (++cols >= (DSPverifyPayload? 7 : 5)) {
                            cols = 0;
                            _DQprintf(1,("\n"));
                        }
                    }
                }
                else
                {
                    int     odd;
                    int     groupID;
                    int     nBitErrors;
                    int     ECmode;
                    int     i, cnt;

                    odd = (pVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_FIELD1);
                    groupID = NFECGetGroupAddress(storage->pFECstate,
                                                pDSPbuffer+1, &nBitErrors);
                    ECmode = NFECHammingDecode(pDSPbuffer[8], &nBitErrors);
                    if (-1 == ECmode)
                        ECmode = 8;     // use something != 0x0C

                    if (DSPverifyShowOK) {
                        if (-1 == groupID)
                            _DQprintf(1,("%02d%c:---:OK",
                                    field,
                                    (odd?"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                        :"abcdefghijklmnopqrstuvwxyz")
                                     [line]));
                        else
                            _DQprintf(1,("%02d%c:%03x:OK",
                                field,
                                (odd?"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                    :"abcdefghijklmnopqrstuvwxyz")
                                 [line],
                                groupID));
                        if (DSPverifyStream)
                            _DQprintf(1,("=OK/OK"));
                        _DQprintf(1,(";"));
                        if (++cols >= (DSPverifyPayload? 7 : 5)) {
                            cols = 0;
                            _DQprintf(1,("\n"));
                        }
                    }

                    // Ignore BERT && FEC lines
                    if ((0xFFFF == DSPverifyPayloadGroup
                          || groupID == DSPverifyPayloadGroup)
                        && 0xF00 != groupID && (ECmode & 0xC) != 0xC)
                    {
                        if (DSPverifyPayload) {
                            cnt = 0;
                            for (i = 9; i < 9+26; ++i) {
                                if (DSPverifyPayloadByte != pDSPbuffer[i])
                                    ++cnt;
                            }
                            if (cnt > 0) {
                                //23a:8F0:26;
                                if (-1 == groupID)
                                    _DQprintf(1,("%02d%c:---:%02d;",
                                            field,
                                            (odd?"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                                :"abcdefghijklmnopqrstuvwxyz")
                                             [line],
                                            cnt));
                                else
                                    _DQprintf(1,("%02d%c:%03x:%02d;",
                                        field,
                                        (odd?"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                            :"abcdefghijklmnopqrstuvwxyz")
                                         [line],
                                        groupID,
                                        cnt));
                                if (++cols >= 7) {
                                    cols = 0;
                                    _DQprintf(1,("\n"));
                                }
                            }
                        }
                        else if (DSPverifyStream) {
                            for (i = 9; i < 9+26; ++i) {
                                if (DSPverifyStreamByte != pDSPbuffer[i]) {
                                    //23M:8F0:25=ww/gg;
                                    if (-1 == groupID)
                                        _DQprintf(1,("%02d%c:---:%02d=%02x/%02x;",
                                            field,
                                            (odd?"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                                :"abcdefghijklmnopqrstuvwxyz")
                                             [line],
                                            i - 9,
                                            DSPverifyStreamByte,
                                            pDSPbuffer[i]));
                                    else
                                        _DQprintf(1,("%02d%c:%03x:%02d=%02x/%02x;",
                                            field,
                                            (odd?"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                                :"abcdefghijklmnopqrstuvwxyz")
                                             [line],
                                            groupID,
                                            i - 9,
                                            DSPverifyStreamByte,
                                            pDSPbuffer[i]));
                                    if (++cols >= 5) {
                                        cols = 0;
                                        _DQprintf(1,("\n"));
                                    }
                                    DSPverifyStreamByte = pDSPbuffer[i];
                                }
                                ++DSPverifyStreamByte;
                            }
                        }
                    }
                }
            }
#endif /*DEBUG*/

            if (DSPlineStats.nConfidence >= 50
#ifdef DEBUG
                || DSPoutputLine >= 3
#endif /*DEBUG*/
            )
            {
                short   groupID;
                int     nBitErrors;

                groupID = NFECGetGroupAddress(storage->pFECstate,
                                            pDSPbuffer+1, &nBitErrors);
#ifdef DEBUG
                if (DSPlineStats.nConfidence >= 50)
#endif /*DEBUG*/
                {
                    SETBIT(pStrmEx->ScanlinesDiscovered.DwordBitArray, line);
                    SETBIT(pHwDevExt->ScanlinesDiscovered.DwordBitArray,line);
                    if (groupID != -1) {
                        SETBIT(pStrmEx->SubstreamsDiscovered.SubstreamMask,
                                groupID);
                        SETBIT(pHwDevExt->SubstreamsDiscovered.SubstreamMask,
                                groupID);
                    }
                }
#ifdef DEBUG
                if (DSPoutputLine >= 1
                    && (DSPwatchLine == 0 || DSPwatchLine == line))
                {
                    int confidence = DSPlineStats.nConfidence;

                    if (confidence < -9)
                        confidence = -9;
                    else if (confidence > 99)
                        confidence = 99;
                    DbgPrint("%1x%02d %02d:", (field & 0xF), line, confidence);
                    _dumpNABTS(pDSPbuffer+1, 36);
                }

                if (DSPskipFEC) {
                    if (DSPskipFECSimulate)
                        SimulateFECcallback(pHwDevExt);
                }
                else
#endif /*DEBUG*/

                if (groupID == -1
                    || TESTBIT(pStrmEx->SubstreamsRequested.SubstreamMask, groupID)
#ifdef DEBUG
                    || DSPscanAll
#endif /*DEBUG*/
                   )
                {
                    BPCdoFEC(pHwDevExt, pStrmEx, pDSPbuffer);
                }
                else
                    ++pStats->FilteredLines;
            }
            else {
                ++pStats->Common.DSPFailures;
#ifdef DEBUG
                if (DSPshowUnderscore)
                    _DQprintf(2,("_"));
#endif /*DEBUG*/
            }
        }
        else {
            ++pStats->Common.DSPFailures;
                Dprintx(("NDSPDecodeLine FAILED, error=%d\n", status));
        }
    }

    // Restore FP state
    {
        NTSTATUS   sts;

        floatRestore(FPctrlWord);
        sts = KeRestoreFloatingPointState(&FPstate);
        if (STATUS_SUCCESS != sts)
           Dprintx(("KeRestoreFloatingPointState FAILED! status = 0x%x\n",sts));
    }

    _DQprintf(2,(";"));

    DtRETURN;
}

#ifdef HW_INPUT
void
BPCcopyVBI(PHW_STREAM_REQUEST_BLOCK pSrb, PSTREAMEX pStrmEx)
{
    PKSSTREAM_HEADER                  pDataPacket;
    PNABTS_BUFFER                     pData;
    PHW_DEVICE_EXTENSION              pHwDevExt;
    PKSSTREAM_HEADER                  pStrmHdr;
    PBPC_VBI_STORAGE                  storage;
    PVBICODECFILTERING_SCANLINES      pSRBlines;
    PUCHAR                            pNABTSlines;
    PKS_VBIINFOHEADER                 pVBIinfo;
    unsigned int                      line;
    unsigned int                      startLine;
    unsigned int                      stopLine;
    PUCHAR                            pDSPbuffer;
    KFLOATING_SAVE                    FPstate;
    unsigned short                    FPctrlWord;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;

    DtENTER("BPCcopyVBI");

    pDataPacket = pSrb->CommandData.DataBufferArray;
    pData =  (PNABTS_BUFFER)pDataPacket->Data;
    pHwDevExt = pSrb->HwDeviceExtension;
    pStrmHdr = pSrb->CommandData.DataBufferArray;
    storage = &pHwDevExt->VBIstorage;
    pSRBlines = &pData->ScanlinesRequested;
    pNABTSlines = (PUCHAR)pData->NabtsLines;

    pStats = &pHwDevExt->Stats;
    pPinStats = &pStrmEx->PinStats;

    // Clear what's been recently discovered
    // (the input pin only holds what was discovered in the current field)
    RtlZeroMemory(&pStrmEx->ScanlinesDiscovered,
                  sizeof (pStrmEx->ScanlinesDiscovered));
    RtlZeroMemory(&pStrmEx->SubstreamsDiscovered,
                  sizeof (pStrmEx->SubstreamsDiscovered));

#ifdef DEBUG
    if (pStrmHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY) {
        if (DSPlogLostFields)
            Dprintf(1,("HWINP: field(s) lost at %010u\n", (ULONG)pStrmEx->LastPictureNumber));
        else {
            _DQprintf(2,("!"));
            Dprintf(3,("HWINP: field(s) lost\n"));
        }
    }

    if (DSPperfMeter) {
        if ((pStrmEx->LastPictureNumber % DSPperfMeter) == 0)
            DbgPrint("*");
    }

    if (DSPskipDecode) {
        if (DSPskipDecodeSimulate)
            SimulateFECcallback(pHwDevExt);
        DtRETURN;
    }
#endif /*DEBUG*/

    pVBIinfo = &pStrmEx->CurrentVBIInfoHeader;

    // Clear all the NABTS buffers
    for (line = 10; line <= 20; ++line) {
        pDSPbuffer = storage->DSPbuffers[line-10];
        pDSPbuffer[0] = pDSPbuffer[1] = 0;
    }

    // Figure out where the part of the universe we care about starts and ends
    startLine = 10;
    if (pVBIinfo->StartLine > startLine)
        startLine = pVBIinfo->StartLine;
    stopLine = 20;
    if (pVBIinfo->EndLine < stopLine)
        stopLine = pVBIinfo->EndLine;

    // Now figure out if we have something to do, and if so, where
#ifdef DEBUG
    if (!DSPscanAll)
#endif /*DEBUG*/
    {
        for ( ; startLine <= stopLine; ++startLine) {
            if (TESTBIT(pStrmEx->ScanlinesRequested.DwordBitArray, startLine))
                break;
        }
        if (startLine > stopLine) {
            Dprintf(6,("HWINP: No lines requested; returning...\n"));
            DtRETURN;// Nothing to do
        }
        for ( ; stopLine >= startLine; --stopLine) {
            if (TESTBIT(pStrmEx->ScanlinesRequested.DwordBitArray, stopLine))
            break;
        }
    }

    // Save FP state
    {
        NTSTATUS   sts;

        sts = KeSaveFloatingPointState(&FPstate);
        if (STATUS_SUCCESS != sts) {
            ++pStats->Common.ExternalErrors;
            ++pPinStats->Common.ExternalErrors;
            Dprintx(("KeSaveFloatingPointState FAILED! status = 0x%x\n", sts));
            DtRETURN;
        }
        FPctrlWord = floatSetup();
    }

    // Next, copy in each H/W decoded line, and maybe feed it to the FEC
#ifdef DEBUG
    if (DSPoutputLine >= 3)
        DbgPrint("\n");
#endif /*DEBUG*/

    for (line = startLine; line <= stopLine; ++line)
    {
        pDSPbuffer = storage->DSPbuffers[line-10];

        // Copy in H/W decoded NABTS, if it's there
        if (TESTBIT(pSRBlines->DwordBitArray, line)) {
            RtlCopyMemory(pDSPbuffer, pNABTSlines, NABTS_BYTES_PER_LINE+1);
            pNABTSlines += NABTS_BYTES_PER_LINE+1;  // +1 for Confidence byte

        if (pDSPbuffer[0] >= 100)
            pDSPbuffer[0] = 100;// Confidence
        }
        else
            RtlZeroMemory(pDSPbuffer, NABTS_BYTES_PER_LINE+1);


        if (pDSPbuffer[0] >= 50
#ifdef DEBUG
            || DSPoutputLine >= 3
#endif /*DEBUG*/
           )
        {
            short   groupID;
            int     nBitErrors;

            groupID = NFECGetGroupAddress(storage->pFECstate,
                        pDSPbuffer+1, &nBitErrors);
#ifdef DEBUG
            if (pDSPbuffer[0] >= 50)
#endif /*DEBUG*/
            {
                SETBIT(pStrmEx->ScanlinesDiscovered.DwordBitArray, line);
                if (groupID != -1)
                   SETBIT(pStrmEx->SubstreamsDiscovered.SubstreamMask,groupID);
            }
#ifdef DEBUG
            if (DSPoutputLine >= 2
                && (DSPwatchLine == 0 || DSPwatchLine == line))
            {
                int confidence = pDSPbuffer[0];

                if (confidence < -9)
                    confidence = -9;
                else if (confidence > 99)
                    confidence = 99;
                DbgPrint("%1x%02d %02d:",
                             (int)(pStrmEx->LastPictureNumber & 0xF),
                             line,
                             confidence);
                _dumpNABTS(pDSPbuffer+1, 36);
            }

            if (DSPskipFEC) {
                if (DSPskipFECSimulate)
                    SimulateFECcallback(pHwDevExt);
            }
            else
#endif /*DEBUG*/

            if (groupID == -1
                || TESTBIT(pStrmEx->SubstreamsRequested.SubstreamMask, groupID)
#ifdef DEBUG
                || DSPscanAll
#endif /*DEBUG*/
               )
            {
                BPCdoFEC(pHwDevExt, pStrmEx, pDSPbuffer);
            }
            else
                ++pStats->FilteredLines;
        }
        else {
            ++pStats->Common.DSPFailures;
#ifdef DEBUG
            if (DSPshowUnderscore)
                _DQprintf(2,("_"));
#endif /*DEBUG*/
        }
    }

    // Restore FP state
    {
        NTSTATUS   sts;

        floatRestore(FPctrlWord);
        sts = KeRestoreFloatingPointState(&FPstate);
        if (STATUS_SUCCESS != sts)
           Dprintx(("KeRestoreFloatingPointState FAILED! status = 0x%x\n",sts));
    }

    _DQprintf(2,(";"));

    DtRETURN;
}
#endif /*HW_INPUT*/

void
BPCnewSamplingFrequency(PSTREAMEX pInStrmEx, DWORD newHZ)
{
    PBPC_VBI_STORAGE      storage;
    DWORD newHZdivTen;
#ifdef DEBUG
    int  status;
#endif /*DEBUG*/

    storage = &pInStrmEx->pHwDevExt->VBIstorage;

    // Now, correct for minor 'inaccuracies' in newHZ
    newHZdivTen = newHZ / 10;
    if (newHZdivTen == KS_VBISAMPLINGRATE_5X_NABTS / 10)
        newHZ = KS_VBISAMPLINGRATE_5X_NABTS;
    else if (newHZdivTen == KS_VBISAMPLINGRATE_4X_NABTS / 10)
        newHZ = KS_VBISAMPLINGRATE_4X_NABTS;

    // Finally, make the DSP change
#ifdef DEBUG
    status =
#endif /*DEBUG*/
        NDSPStateSetSampleRate(storage->pDSPstate, newHZ);

#ifdef DEBUG
    if (0 != status)
        Dprintx(("NDSPStateSetSampleRate() failed with err %d!\n", status));
#endif /*DEBUG*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\bpcstore.h ===
//
/// "bpcstore.h"
//
#ifndef _BPCSTORE_H
#define _BPCSTORE_H 1

#include "nabtsapi.h"

//// NABTSFEC output store
typedef struct _NABTSFEC_ITEM {
    NABTSFEC_BUFFER       bundle;
	int                   confidence;
    struct _NABTSFEC_ITEM *next;
    struct _NABTSFEC_ITEM *prev;
} NABTSFEC_ITEM, *PNABTSFEC_ITEM;
#define NF_BUFFER_SIZE(nbp) \
	(sizeof (*(nbp)) - (sizeof ((nbp)->data) - ((nbp)->dataSize)))
#define NF_Q_MAX_BUNDLES  256

//// Storage for VBI streams
typedef struct _bpc_vbi_storage {
#ifdef NDIS_PRIVATE_IFC
    PDEVICE_OBJECT                     pNDISdevObject;
    PFILE_OBJECT                       pNDISfileObject;
    VBICODECFILTERING_SCANLINES        IPScanlinesRequested;
    VBICODECFILTERING_NABTS_SUBSTREAMS IPSubstreamsRequested;
#endif //NDIS_PRIVATE_IFC
    NDSPState                          DSPstate;
    NDSPState                          *pDSPstate;
    NFECState                          *pFECstate;
    PNABTSFEC_ITEM                     q_front;
    PNABTSFEC_ITEM                     q_rear;
    ULONG                              q_length;
#ifdef DEBUG
    ULONG                              q_max;
#endif /*DEBUG*/
    KSPIN_LOCK                         q_SpinLock;
    USHORT                             flags;
    USHORT                             Reserved;
    UCHAR                              DSPbuffers[11][NABTS_BYTES_PER_LINE+1];
} BPC_VBI_STORAGE, *PBPC_VBI_STORAGE;
// Bits for "flags"
#define BPC_STORAGE_FLAG_FIELD_MASK     0x0001
#define BPC_STORAGE_FLAG_FIELD_EVEN     0x0000
#define BPC_STORAGE_FLAG_FIELD_ODD      0x0001
#define BPC_STORAGE_FLAG_NDIS_ERROR     0x0002

#endif /*_BPCSTORE_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\coddebug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "coddebug.h"

//======================================================;
//  Data storage for coddebug.h when DEBUG #defined
//======================================================;

#ifdef DEBUG

#include "strmini.h"

char _CDebugAssertFail[] = "ASSERT(%s) FAILED in file \"%s\", line %d\n";

enum STREAM_DEBUG_LEVEL _CDebugLevel = DebugLevelWarning /*DebugLevelMaximum*/;

#endif /*DEBUG*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\bpc_vbi.h ===
//
/// "bpc_vbi.h"
//
#ifndef _BPC_VBI_H
#define _BPC_VBI_H 1

# ifdef BT829
#   pragma message( "*** Compiling for Bt829" )
#   define VBISamples (800*2)
# else /*BT829*/
#   pragma message( "*** Compiling for Bt848" )
#   define VBISamples (768*2)
# endif /*BT829*/

//// General defines
#define BPC_NABTSIP_DRIVER_NAME	L"\\Device\\NABTSIP"

//// Prototypes
void BPCdecodeVBI(PHW_STREAM_REQUEST_BLOCK pSrb, PSTREAMEX pStrmEx);
#ifdef HW_INPUT
void BPCcopyVBI(PHW_STREAM_REQUEST_BLOCK pSrb, PSTREAMEX pStrmEx);
#endif /*HW_INPUT*/
void BPC_Initialize(PHW_STREAM_REQUEST_BLOCK pSrb);
void BPC_UnInitialize(PHW_STREAM_REQUEST_BLOCK pSrb);
void BPC_OpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);
int  BPCoutputNABTSlines(PHW_DEVICE_EXTENSION pHwDevExt, PSTREAMEX pOutStrmEx, PNABTS_BUFFER pOutData);
void BPCsourceChangeNotify(PHW_DEVICE_EXTENSION pHwDevExt);
void BPC_SignalStop(PHW_DEVICE_EXTENSION pHwDevExt);
void BPCcomputeAverage(DWORD *average, DWORD newSample);
void BPCnewSamplingFrequency(PSTREAMEX pInStrmEx, DWORD newHZ);
#ifdef NDIS_PRIVATE_IFC
 void BPCaddIPrequested(PHW_DEVICE_EXTENSION pHwDevExt, PSTREAMEX pStrmEx);
 void BPC_NDIS_Close(PBPC_VBI_STORAGE storage);
#endif //NDIS_PRIVATE_IFC

#endif /*_BPC_VBI_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\coddebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#ifndef __CODDEBUG_H
#define __CODDEBUG_H

#include "bpcdebug.h"

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//======================================================;
//  Interfaces provided by this file:
//
//  	All interfaces provided by this file only exist and generate
//  	code when DEBUG is defined.  No code or data are generated when
//  	DEBUG is not defined.
//
//  	CDEBUG_BREAK()
//  		Causes a trap #3, which hopefully will put you
//  		in your debugger.
//
//  	CASSERT(exp)
//  		If <exp> evaluates to false, prints a failure message
//  		and calls CDEBUG_BREAK()
//
//  	CdebugPrint(level, (printf_args));
//  		If <level> is >= _CDebugLevel, then calls
//  		DbgPrint(printf_args)
//
//======================================================;

#if DBG
#ifndef DEBUG
#define DEBUG
#endif
#ifndef _DEBUG
#define _DEBUG
#endif
#endif


#ifdef DEBUG

#  define CDEBUG_BREAK()            DBREAK()
#  define CASSERT(exp)              DASSERT(exp)
#  define CDebugPrint(level, args) \
     do { if ((level) == DebugLevelTrace) _Dtrace(args); \
	  else if ((level) == DebugLevelError \
               || (level) == DebugLevelWarning) _Dprintf(1, args); \
	  else _Dprintf(level+16, args); \
     } while (0)

#else /*DEBUG*/

#  define CDEBUG_BREAK()		{}
#  define CASSERT(exp)			{}
#  define CDebugPrint(level, args)	{}

#endif /*DEBUG*/


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // #ifndef __CODDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\codmain.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "kskludge.h"
#include "codmain.h"
#include "bt829.h"
#include "bpc_vbi.h"
#include "codstrm.h"
#include "codprop.h"
#include "coddebug.h"

/*
** DriverEntry()
**
**   This routine is called when the driver is first loaded by PnP.
**   It in turn, calls upon the stream class to perform registration services.
**
** Arguments:
**
**   DriverObject - 
**          Driver object for this driver 
**
**   RegistryPath - 
**          Registry path string for this driver's key
**
** Returns:
**
**   Results of StreamClassRegisterAdapter()
**
** Side Effects:  none
*/

ULONG 
DriverEntry( IN PDRIVER_OBJECT DriverObject,
			 IN PUNICODE_STRING RegistryPath )
{
    ULONG					status = 0;
    HW_INITIALIZATION_DATA	HwInitData;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->DriverEntry(DriverObject=%x,RegistryPath=%x)\n", 
				DriverObject, RegistryPath));

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));

    HwInitData.HwInitializationDataSize = sizeof(HwInitData);

    /*CDEBUG_BREAK();*/

    //
    // Set the codec entry points for the driver
    //

    HwInitData.HwInterrupt              = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket          = CodecReceivePacket;
    HwInitData.HwCancelPacket           = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler  = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize      = sizeof(HW_DEVICE_EXTENSION);
    HwInitData.PerRequestExtensionSize  = sizeof(SRB_EXTENSION); 
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize   = sizeof(STREAMEX); 
    HwInitData.BusMasterDMA             = FALSE;  
    HwInitData.Dma24BitAddresses        = FALSE;
    HwInitData.BufferAlignment          = 3;
    HwInitData.TurnOffSynchronization   = TRUE;
    HwInitData.DmaBufferSize            = 0;

    CDebugPrint(DebugLevelVerbose,(CODECNAME ": StreamClassRegisterAdapter\n"));

    status = StreamClassRegisterAdapter(DriverObject, RegistryPath, &HwInitData);

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---DriverEntry(DriverObject=%x,RegistryPath=%x)=%d\n",
			    DriverObject, RegistryPath, status));

    return status;     
}

//==========================================================================;
//                   Codec Request Handling Routines
//==========================================================================;

/*
** CodecInitialize()
**
**   This routine is called when an SRB_INITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the Initialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN 
CodecInitialize ( IN OUT PHW_STREAM_REQUEST_BLOCK pSrb )
{
    BOOLEAN                         bStatus = FALSE;
    PPORT_CONFIGURATION_INFORMATION ConfigInfo = pSrb->CommandData.ConfigInfo;
    PHW_DEVICE_EXTENSION            pHwDevExt = ConfigInfo->HwDeviceExtension;
    int                             scanline, substream;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecInitialize(pSrb=%x)\n",pSrb));
    //CDEBUG_BREAK(); // Uncomment this code to break here.

    if (ConfigInfo->NumberOfAccessRanges == 0) 
    {
        CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecInitialize\n"));

        ConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

        for (scanline = 10; scanline <= 20; ++scanline)
            SETBIT(pHwDevExt->ScanlinesRequested.DwordBitArray, scanline);

        // These are the driver defaults for subtream filtering. 
        // (These are MS IP/NABTS GROUP ID specific)

        // ATVEF range
        for (substream = 0x4B0; substream <= 0x4BF; ++substream)
            SETBIT(pHwDevExt->SubstreamsRequested.SubstreamMask, substream);
        // MS range
        for (substream = 0x800; substream <= 0x8FF; ++substream)
            SETBIT(pHwDevExt->SubstreamsRequested.SubstreamMask, substream);

		// Zero the stats
		RtlZeroMemory(&pHwDevExt->Stats, sizeof (pHwDevExt->Stats));

#ifdef HW_INPUT
		// Zero LastPictureNumber
		pHwDevExt->LastPictureNumber = 0;

		// Init LastPictureNumber's FastMutex
		ExInitializeFastMutex(&pHwDevExt->LastPictureMutex);
#endif /*HW_INPUT*/

		// Setup BPC data
		BPC_Initialize(pSrb);
        
        pSrb->Status = STATUS_SUCCESS;
        bStatus = TRUE;
    }
    else
    {
        CDebugPrint(DebugLevelError,(CODECNAME ": illegal config info\n"));
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
    }

    CDebugPrint(DebugLevelTrace,
                (CODECNAME ":<---CodecInitialize(pSrb=%x)=%d\n", pSrb, bStatus));
    return (bStatus);
}

/*
** CodecUnInitialize()
**
**   This routine is called when an SRB_UNINITIALIZE_DEVICE request is received
**
** Arguments:
**
**   pSrb - pointer to stream request block for the UnInitialize command
**
** Returns:
**
** Side Effects:  none
*/

BOOLEAN 
CodecUnInitialize ( 
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecUnInitialize(pSrb=%x)\n",pSrb));

    BPC_UnInitialize(pSrb);

    pSrb->Status = STATUS_SUCCESS;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecUnInitialize(pSrb=%x)\n",pSrb));

    return TRUE;
}


/*
** CodecOpenStream()
**
**   This routine is called when an OpenStream SRB request is received.
**   A stream is identified by a stream number, which indexes an array
**   of KSDATARANGE structures.  The particular KSDATAFORMAT format to
**   be used is also passed in, which should be verified for validity.
**   
** Arguments:
**
**   pSrb - pointer to stream request block for the Open command
**
** Returns:
**
** Side Effects:  none
*/

VOID 
CodecOpenStream( PHW_STREAM_REQUEST_BLOCK pSrb )
{
    //
    // the stream extension structure is allocated by the stream class driver
    //

    PSTREAMEX               pStrmEx = pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = pSrb->HwDeviceExtension;
    int                     StreamNumber = pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT           pKSDataFormat =
                                 (PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecOpenStream(pSrb=%x)\n", pSrb));
    CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecOpenStream : StreamNumber=%d\n", StreamNumber));

    CASSERT(pStrmEx);
    CASSERT(pHwDevExt);

    RtlZeroMemory(pStrmEx, sizeof (STREAMEX));
    
    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //

    if ( 0 <= StreamNumber && StreamNumber < DRIVER_STREAM_COUNT ) 
	{
        unsigned StreamInstance;
        unsigned maxInstances =
                  Streams[StreamNumber].hwStreamInfo.NumberOfPossibleInstances;

		// Search for next open slot
	    for (StreamInstance=0; StreamInstance < maxInstances; ++StreamInstance)
		{
			if (pHwDevExt->pStrmEx[StreamNumber][StreamInstance] == NULL)
				break;
		}

	    if (StreamInstance < maxInstances)
		{
			if (CodecVerifyFormat(pKSDataFormat, StreamNumber, &pStrmEx->MatchedFormat)) 
			{
				CASSERT (pHwDevExt->pStrmEx[StreamNumber][StreamInstance] == NULL);

				// Increment the instance count on this stream
				pStrmEx->StreamInstance = StreamInstance;
				++pHwDevExt->ActualInstances[StreamNumber];

				// Initialize lists and locks for this stream
				InitializeListHead(&pStrmEx->StreamControlQueue);
				InitializeListHead(&pStrmEx->StreamDataQueue);
				KeInitializeSpinLock(&pStrmEx->StreamControlSpinLock);
				KeInitializeSpinLock(&pStrmEx->StreamDataSpinLock);

				// Maintain an array of all the StreamEx structures in the
				//  HwDevExt so that we can reference IRPs from any stream
				pHwDevExt->pStrmEx[StreamNumber][StreamInstance] = pStrmEx;

				// Save the Stream Format in the Stream Extension as well.
				pStrmEx->OpenedFormat = *pKSDataFormat;
				CDebugPrint(DebugLevelError,(CODECNAME ":Saved KSDATAFORMAT @0x%x\n", &pStrmEx->OpenedFormat));

				// Set up pointers to the stream data and control handlers
				pSrb->StreamObject->ReceiveDataPacket = 
					(PVOID) Streams[StreamNumber].hwStreamObject.ReceiveDataPacket;
				pSrb->StreamObject->ReceiveControlPacket = 
					(PVOID) Streams[StreamNumber].hwStreamObject.ReceiveControlPacket;

				//
				// The DMA flag must be set when the device will be performing DMA
				//  directly to the data buffer addresses passed in to the
				//  ReceiceDataPacket routines.
				//
				pSrb->StreamObject->Dma = Streams[StreamNumber].hwStreamObject.Dma;

				//
				// The PIO flag must be set when the mini driver will be accessing
				// the data buffers passed in using logical addressing
				//
				pSrb->StreamObject->Pio = Streams[StreamNumber].hwStreamObject.Pio;

				pSrb->StreamObject->Allocator = Streams[StreamNumber].hwStreamObject.Allocator;

				//
				// Number of extra bytes passed up from the driver for each frame
				//
				pSrb->StreamObject->StreamHeaderMediaSpecific = 
					Streams[StreamNumber].hwStreamObject.StreamHeaderMediaSpecific;
				pSrb->StreamObject->StreamHeaderWorkspace =
					Streams[StreamNumber].hwStreamObject.StreamHeaderWorkspace;

				//
				// Indicate the clock support available on this stream
				//
				pSrb->StreamObject->HwClockObject = 
					Streams[StreamNumber].hwStreamObject.HwClockObject;

				// Retain a private copy of the HwDevExt and StreamObject
				//  in the stream extension
				pStrmEx->pHwDevExt = pHwDevExt;
				pStrmEx->pStreamObject = pSrb->StreamObject;  // For timer use

				// Copy the default filtering settings
				pStrmEx->ScanlinesRequested = pHwDevExt->ScanlinesRequested;
				pStrmEx->SubstreamsRequested = pHwDevExt->SubstreamsRequested;

				// Zero the stats
				RtlZeroMemory(&pStrmEx->PinStats, sizeof (pStrmEx->PinStats));

#ifdef HW_INPUT
				// Init VBISrbOnHold's spin lock
				KeInitializeSpinLock(&pStrmEx->VBIOnHoldSpinLock);
#endif /*HW_INPUT*/

				// Initialize BPC
				BPC_OpenStream(pSrb);
			}
			else
			{
				CDebugPrint(DebugLevelError,
					(CODECNAME ": CodecOpenStream : Invalid Stream Format=%x\n", 
					pKSDataFormat ));
				pSrb->Status = STATUS_INVALID_PARAMETER;
			}
		}
		else
		{
		    CDebugPrint(DebugLevelError,
				(CODECNAME ": CodecOpenStream : Too Many Instances=%d\n", 
				pHwDevExt->ActualInstances[StreamNumber] ));
	        pSrb->Status = STATUS_INVALID_PARAMETER;
		}
	}
	else
	{
	    CDebugPrint(DebugLevelError,
			(CODECNAME ": CodecOpenStream : Invalid StreamNumber=%d\n", 
			StreamNumber ));
	    pSrb->Status = STATUS_INVALID_PARAMETER;
	}

	CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecOpenStream(pSrb=%x)\n", pSrb));
}

/*
** CodecCloseStream()
**
**   Close the requested data stream
**
** Arguments:
**
**   pSrb the request block requesting to close the stream
**
** Returns:
**
** Side Effects:  none
*/

VOID 
CodecCloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX                pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION     pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb;
    PKSDATAFORMAT            pKSDataFormat = pSrb->CommandData.OpenFormat;
    ULONG                    StreamNumber = pSrb->StreamObject->StreamNumber;
    ULONG                    StreamInstance = pStrmEx->StreamInstance;
#ifdef HW_INPUT
    KIRQL                    Irql;
#endif /*HW_INPUT*/

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecCloseStream(pSrb=%x)\n", pSrb));

    // CDEBUG_BREAK(); // Uncomment this code to break here.


	//
	// Flush the stream data queue
	//
#ifdef HW_INPUT
    // Is there an SRB 'on hold'??
	KeAcquireSpinLock(&pStrmEx->VBIOnHoldSpinLock, &Irql);
	if (pStrmEx->pVBISrbOnHold)
	{
		PHW_STREAM_REQUEST_BLOCK pHoldSrb;

		pHoldSrb = pStrmEx->pVBISrbOnHold;
		pStrmEx->pVBISrbOnHold = NULL;
		KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);

        pHoldSrb->Status = STATUS_CANCELLED;
	    CDebugPrint(DebugLevelVerbose,
	    	(CODECNAME ":StreamClassStreamNotification(pHoldSrb->Status=0x%x)\n", 
	    	pHoldSrb->Status));
           
        StreamClassStreamNotification(
		   StreamRequestComplete, pHoldSrb->StreamObject, pHoldSrb);
		pSrb = NULL;
	}
	else
		KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);
#endif /*HW_INPUT*/

	while( QueueRemove( &pCurrentSrb, &pStrmEx->StreamDataSpinLock,
			&pStrmEx->StreamDataQueue ))
	{
		CDebugPrint(DebugLevelVerbose, 
				    (CODECNAME ": Removing control SRB %x\n", pCurrentSrb));
		pCurrentSrb->Status = STATUS_CANCELLED;
		StreamClassStreamNotification(StreamRequestComplete,
		   pCurrentSrb->StreamObject, pCurrentSrb);
	}

	//
	// Flush the stream control queue
	//
	while (QueueRemove(&pCurrentSrb, &pStrmEx->StreamControlSpinLock,
			&pStrmEx->StreamControlQueue))
	{
		CDebugPrint(DebugLevelVerbose, 
				    (CODECNAME ": Removing control SRB %x\n", pCurrentSrb));
		pCurrentSrb->Status = STATUS_CANCELLED;
		StreamClassStreamNotification(StreamRequestComplete,
		   pCurrentSrb->StreamObject, pCurrentSrb);
	}

    // Decrement count on this stream (the actual number of infinite pins)
    pHwDevExt->ActualInstances[StreamNumber] -= 1;

    CASSERT (pHwDevExt->pStrmEx [StreamNumber][StreamInstance] != 0);

    pHwDevExt->pStrmEx [StreamNumber][StreamInstance] = 0;

    //
    // the minidriver may wish to free any resources that were allocate at
    // open stream time etc.
    //
    pStrmEx->hMasterClock = NULL;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecCloseStream(pSrb=%x)\n", pSrb));
}


/*
** CodecStreamInfo()
**
**   Returns the information of all streams that are supported by the
**   mini-driver
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID 
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{

    int j; 
    
    PHW_DEVICE_EXTENSION pHwDevExt =
        ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //

    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

     //
     // pick up the pointer to the array of stream information data structures
     //

    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


	CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecStreamInfo(pSrb=%x)\n", pSrb));
  
    // 
    // verify that the buffer is large enough to hold our return data
    //

    CASSERT (pSrb->NumberOfBytesToTransfer >= 
            sizeof (HW_STREAM_HEADER) +
            sizeof (HW_STREAM_INFORMATION) * DRIVER_STREAM_COUNT);

     //
     // Set the header
     // 

     StreamHeader.NumDevPropArrayEntries = NUMBER_OF_CODEC_PROPERTY_SETS;
     StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET) CodecPropertyTable; 
     *pstrhdr = StreamHeader;

     // 
     // stuff the contents of each HW_STREAM_INFORMATION struct 
     //

     for (j = 0; j < DRIVER_STREAM_COUNT; j++) {
        *pstrinfo++ = Streams[j].hwStreamInfo;
     }

     CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecStreamInfo(pSrb=%x)\n", pSrb));
}


/*
** CodecReceivePacket()
**
**   Main entry point for receiving codec based request SRBs.  This routine
**   will always be called at High Priority.
**
**   Note: This is an asyncronous entry point.  The request does not complete
**         on return from this function, the request only completes when a
**         StreamClassDeviceNotification on this request block, of type
**         DeviceRequestComplete, is issued.
**
** Arguments:
**
**   pSrb - Pointer to the STREAM_REQUEST_BLOCK
**        pSrb->HwDeviceExtension - will be the hardware device extension for
**                                  as initialised in HwInitialise
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pSrb->HwDeviceExtension;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecReceivePacket(pSrb=%x)\n", pSrb));

	//
	// Make sure queue & SL initted
	//
	if (!pHwDevExt->bAdapterQueueInitialized) {
		InitializeListHead(&pHwDevExt->AdapterSRBQueue);
		KeInitializeSpinLock(&pHwDevExt->AdapterSRBSpinLock);
		pHwDevExt->bAdapterQueueInitialized = TRUE;
	}

    //
    // Assume success
    //

    pSrb->Status = STATUS_SUCCESS;

	//
	// Loop for each packet on the queue
	//
    if (QueueAddIfNotEmpty(pSrb, &pHwDevExt->AdapterSRBSpinLock,
                           &pHwDevExt->AdapterSRBQueue))
       return;
       
    do
	{
		//
		// determine the type of packet.
		//

		CDebugPrint(DebugLevelVerbose,
			(CODECNAME ": CodecReceivePacket: pSrb->Command=0x%x\n", 
			pSrb->Command));

		switch (pSrb->Command)
		{

		case SRB_INITIALIZE_DEVICE:

			// open the device
			
			CodecInitialize(pSrb);

			break;

		case SRB_UNINITIALIZE_DEVICE:

			// close the device.  

			CodecUnInitialize(pSrb);

			break;

		case SRB_OPEN_STREAM:

			// open a stream

			CodecOpenStream(pSrb);

			break;

		case SRB_CLOSE_STREAM:

			// close a stream

			CodecCloseStream(pSrb);

			break;

		case SRB_GET_STREAM_INFO:

			//
			// return a block describing all the streams
			//

			CodecStreamInfo(pSrb);

			break;

		case SRB_GET_DATA_INTERSECTION:

			//
			// Return a format, given a range
			//

			CodecFormatFromRange(pSrb);

			break;

			// We should never get the following since this is a single instance
			// device
		case SRB_OPEN_DEVICE_INSTANCE:
		case SRB_CLOSE_DEVICE_INSTANCE:
			CDEBUG_BREAK();
			// Fall through to not implemented

		case SRB_CHANGE_POWER_STATE:	    // this one we don't care about
		case SRB_INITIALIZATION_COMPLETE:	// this one we don't care about
		case SRB_UNKNOWN_DEVICE_COMMAND:	// this one we don't care about
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			break;

		case SRB_GET_DEVICE_PROPERTY:

			//
			// Get codec-wide properties
			//
			CodecGetProperty (pSrb);
			break;        

		case SRB_SET_DEVICE_PROPERTY:

			//
			// Set codec-wide properties
			//
			CodecSetProperty (pSrb);
			break;

        case SRB_PAGING_OUT_DRIVER:
            CDebugPrint(DebugLevelError,
                (CODECNAME ": CodecReceivePacket: SRB_PAGING_OUT_DRIVER\n"));
			break;

        case SRB_SURPRISE_REMOVAL:
            CDebugPrint(DebugLevelError,
                (CODECNAME ": CodecReceivePacket: SRB_SURPRISE_REMOVAL\n"));
#ifdef NDIS_PRIVATE_IFC
            // Close our ref to NDIS IP driver; we'll re-open next FEC bundle
            BPC_NDIS_Close(&pHwDevExt->VBIstorage);
#endif //NDIS_PRIVATE_IFC
			break;

		case SRB_UNKNOWN_STREAM_COMMAND:

			CDebugPrint(DebugLevelError,
						(CODECNAME ": received SRB_UNKNOWN_STREAM_COMMAND\n"));
			pSrb->Status = STATUS_NOT_IMPLEMENTED;

			break;

		default:
			CDebugPrint(DebugLevelError,
						(CODECNAME ": Received _unknown_ pSrb->Command=0x%x\n", 
						pSrb->Command));

			CDEBUG_BREAK();

			//
			// this is a request that we do not understand.  Indicate invalid
			// command and complete the request
			//

			pSrb->Status = STATUS_NOT_IMPLEMENTED;

		}

		//
		// NOTE:
		//
		// all of the commands that we do, or do not understand can all be completed
		// syncronously at this point, so we can use a common callback routine here.
		// If any of the above commands require asyncronous processing, this will
		// have to change
		//

		CDebugPrint(DebugLevelVerbose,
			(CODECNAME ": CodecReceivePacket : DeviceRequestComplete(pSrb->Status=0x%x)\n", 
			pSrb->Status));

       StreamClassDeviceNotification(
			   DeviceRequestComplete, 
			   pSrb->HwDeviceExtension,
			   pSrb);
	} while (QueueRemove(&pSrb, &pHwDevExt->AdapterSRBSpinLock,
						 &pHwDevExt->AdapterSRBQueue));
    
    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecReceivePacket(pSrb=%x)\n", pSrb));
}

/*
** CodecCancelPacket ()
**
**   Request to cancel a packet that is currently in process in the minidriver
**
** Arguments:
**
**   pSrb - pointer to request packet to cancel
**
** Returns:
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
CodecCancelPacket(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAMEX               pStrmEx = pSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION    pHwDevExt = pSrb->HwDeviceExtension;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecCancelPacket(pSrb=%x)\n", pSrb));
    CASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (pSrb->StreamObject)
        pStrmEx = pSrb->StreamObject->HwStreamExtension;
    else
        CDebugPrint(DebugLevelWarning,
                (CODECNAME "::CodecCancelPacket - StreamObject is NULL!\n"));

    //
    // Check whether the SRB to cancel is in use by this stream
    //

#ifdef HW_INPUT
    if (pStrmEx)
    {
        // Is SRB to cancel 'on hold'??
        KeAcquireSpinLockAtDpcLevel(&pStrmEx->VBIOnHoldSpinLock);
        if (pStrmEx->pVBISrbOnHold && pSrb == pStrmEx->pVBISrbOnHold)
        {
            pStrmEx->pVBISrbOnHold = NULL;
            KeReleaseSpinLockFromDpcLevel(&pStrmEx->VBIOnHoldSpinLock);

            pSrb->Status = STATUS_CANCELLED;
            CDebugPrint(DebugLevelVerbose,
	        (CODECNAME ":StreamClassStreamNotification(pSrb->Status=0x%x)\n", 
	        pSrb->Status));

        StreamClassStreamNotification(
		   StreamRequestComplete, pSrb->StreamObject, pSrb);
		pSrb = NULL;
	}
	else
		KeReleaseSpinLockFromDpcLevel(&pStrmEx->VBIOnHoldSpinLock);
   }

   if (NULL == pSrb)
   {
		; // We're done; we CANCELLED the SRB above
   }
   else
#endif /*HW_INPUT*/

   // Attempt removal from data queue
   if (pStrmEx && QueueRemoveSpecific(pSrb, &pStrmEx->StreamDataSpinLock,
       &pStrmEx->StreamDataQueue))
   {
       pSrb->Status = STATUS_CANCELLED;
	   CDebugPrint(DebugLevelVerbose,
	    	(CODECNAME ":StreamClassStreamNotification(pSrb->Status=0x%x)\n", 
	    	pSrb->Status));
           
       StreamClassStreamNotification(
		   StreamRequestComplete, pSrb->StreamObject, pSrb);
   }
   // Attempt removal from command queue
   else if (pStrmEx && QueueRemoveSpecific(pSrb, &pStrmEx->StreamControlSpinLock,
		    &pStrmEx->StreamControlQueue))
   {
       pSrb->Status = STATUS_CANCELLED;
	   CDebugPrint(DebugLevelVerbose,
	    	(CODECNAME ":StreamClassStreamNotification(pSrb->Status=0x%x)\n", 
	        pSrb->Status));
       StreamClassStreamNotification(
			StreamRequestComplete, pSrb->StreamObject, pSrb);
   }
   // Attempt removal from adapter queue
   else if (QueueRemoveSpecific(pSrb, &pHwDevExt->AdapterSRBSpinLock,
		    &pHwDevExt->AdapterSRBQueue))
   {
       pSrb->Status = STATUS_CANCELLED;
	   CDebugPrint(DebugLevelVerbose,
	        (CODECNAME ":DeviceRequestComplete(pSrb->Status=0x%x)\n", 
	     	pSrb->Status));
       StreamClassDeviceNotification(
			DeviceRequestComplete, pSrb->StreamObject, pSrb);
   }
   else
       CDebugPrint(DebugLevelError,
				   (CODECNAME "SRB %x not found to cancel\n", pSrb));
   
    CDebugPrint(DebugLevelTrace,
				(CODECNAME ":<---CodecCancelPacket(pSrb=%x)\n", pSrb));
}

/*
** CodecTimeoutPacket()
**
**   This routine is called when a packet has been in the minidriver for
**   too long.  The codec must decide what to do with the packet
**
** Arguments:
**
**   pSrb - pointer to the request packet that timed out
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI  
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecTimeoutPacket(pSrb=%x)\n", pSrb));

    pSrb->TimeoutCounter = 0;
    
    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecTimeoutPacket(pSrb=%x)\n", pSrb));
}

/*
** CodecCompareGUIDsAndFormatSize()
**
**   Checks for a match on the three GUIDs and FormatSize
**
** Arguments:
**
**         IN DataRange1
**         IN DataRange2
**
** Returns:
** 
**   TRUE if all elements match
**   FALSE if any are different
**
** Side Effects:  none
*/

BOOL 
CodecCompareGUIDsAndFormatSize(
    IN PKSDATARANGE DataRange1,
    IN PKSDATARANGE DataRange2,
    BOOLEAN bCheckSize
    )
{
    BOOL	rval = FALSE;

    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":--->CodecCompareGUIDsAndFormatSize(DataRange1=%x,DataRange2=%x,bCheckSize=%s)\n", 
        DataRange1, DataRange2, bCheckSize ? "TRUE":"FALSE"));

	if ( IsEqualGUID(&DataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)
	  || IsEqualGUID(&DataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)
	  || IsEqualGUID(&DataRange1->MajorFormat, &DataRange2->MajorFormat) )
	{
		if ( !IsEqualGUID(&DataRange1->MajorFormat, &DataRange2->MajorFormat) )
		{
			CDebugPrint(DebugLevelVerbose,
				(CODECNAME ": CodecCompareGUIDsAndFormatSize : Matched MajorFormat Using Wildcard:\n\t[%s] vs. [%s]\n", 
				&DataRange1->MajorFormat, &DataRange2->MajorFormat ));
		}

		if ( IsEqualGUID(&DataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)
		  || IsEqualGUID(&DataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)
	      || IsEqualGUID(&DataRange1->SubFormat, &DataRange2->SubFormat) )
		{
			if ( !IsEqualGUID(&DataRange1->SubFormat, &DataRange2->SubFormat) )
			{
				CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": CodecCompareGUIDsAndFormatSize : Matched SubFormat Using Wildcard:\n\t[%s] vs. [%s]\n", 
					&DataRange1->SubFormat, &DataRange2->SubFormat ));
			}

			if ( IsEqualGUID(&DataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD)
			  || IsEqualGUID(&DataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD)
			  || IsEqualGUID(&DataRange1->Specifier, &DataRange2->Specifier) )
			{
				if ( !IsEqualGUID(&DataRange1->Specifier, &DataRange2->Specifier) )
				{
					CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecCompareGUIDsAndFormatSize : Matched Specifier Using Wildcard:\n\t[%s] vs. [%s]\n", 
						&DataRange1->Specifier, &DataRange2->Specifier ));
				}

				if ( !bCheckSize || DataRange1->FormatSize == DataRange2->FormatSize)
				{
					rval = TRUE;
				}
				else
				{
					CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecCompareGUIDsAndFormatSize : FormatSize mismatch=%d vs. %d\n", 
						DataRange1->FormatSize, DataRange2->FormatSize ));
				}
			}
			else
			{
				CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": CodecCompareGUIDsAndFormatSize : Specifier mismatch:\n\t[%s] vs. [%s]\n", 
					&DataRange1->Specifier, &DataRange2->Specifier ));
			}
		}
		else
		{
			CDebugPrint(DebugLevelVerbose,
				(CODECNAME ": CodecCompareGUIDsAndFormatSize : Subformat mismatch:\n\t[%s] vs. [%s]\n", 
				&DataRange1->SubFormat, &DataRange2->SubFormat ));
		}
	}
    else
	{
		CDebugPrint(DebugLevelVerbose,
			(CODECNAME ": CodecCompareGUIDsAndFormatSize : MajorFormat mismatch:\n\t[%s] vs. [%s]\n", 
			&DataRange1->MajorFormat, &DataRange2->MajorFormat ));
	}

    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":<---CodecCompareGUIDsAndFormatSize(DataRange1=%x,DataRange2=%x,bCheckSize=%s)=%s\n", 
		DataRange1, DataRange2, bCheckSize ? "TRUE":"FALSE", rval? "TRUE":"FALSE"));

    return rval;
}

/*
** CodecVerifyFormat()
**
**   Checks the validity of a format request
**
** Arguments:
**
**   pKSDataFormat  - pointer to a KS_DATAFORMAT_VBIINFOHEADER structure.
**   StreamNumber   - Streams[] index
**   pMatchedFormat - optional, pointer to format that was matched (if any)
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL 
CodecVerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat)
{
    BOOL	rval = FALSE;
    ULONG     FormatCount;
    PKS_DATARANGE_VIDEO ThisFormat = NULL;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecVerifyFormat(%x)\n", pKSDataFormat));
    
    for( FormatCount = 0; !rval && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
        FormatCount++ )
    {
        CDebugPrint(DebugLevelTrace,(CODECNAME , "Testing stream %d against format %x\n", StreamNumber, FormatCount ));
        
        ThisFormat = ( PKS_DATARANGE_VIDEO )Streams[StreamNumber].hwStreamInfo.StreamFormatsArray[FormatCount];
        if (!ThisFormat)
        {
	        CDebugPrint(DebugLevelError, ( CODECNAME, "Unexpected NULL Format\n" ));
            continue;
        }

        if ( CodecCompareGUIDsAndFormatSize( pKSDataFormat, &ThisFormat->DataRange, FALSE ) )
        { // Okay, we have a format match.  Now do format-specific checks.
			// This test works only because no other format uses SPECIFIER_VBI
            if (IsEqualGUID(&ThisFormat->DataRange.Specifier, &KSDATAFORMAT_SPECIFIER_VBI))
            {
                //
                // Do some VBI-specific tests, generalize this for different capture sources
                // And if you use the VBIINFOHEADER on any other pins (input or output)
                //
                PKS_DATAFORMAT_VBIINFOHEADER    pKSVBIDataFormat = ( PKS_DATAFORMAT_VBIINFOHEADER )pKSDataFormat;

                CDebugPrint(DebugLevelTrace,(CODECNAME , "This is a VBIINFOHEADER format pin.\n" ));

				//
				// Check VideoStandard, we only support NTSC_M
				//
				if (pKSVBIDataFormat->VBIInfoHeader.VideoStandard != KS_AnalogVideo_NTSC_M)
				{
					CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": CodecOpenStream : VideoStandard(%d) != NTSC_M\n", 
					 pKSVBIDataFormat->VBIInfoHeader.VideoStandard));
				}

				else if ( pKSVBIDataFormat->VBIInfoHeader.StartLine >= MIN_VBI_Y_SAMPLES )
			    {
        			if ( pKSVBIDataFormat->VBIInfoHeader.EndLine <= MAX_VBI_Y_SAMPLES )
        			{
        				if ( pKSVBIDataFormat->VBIInfoHeader.SamplesPerLine >= MIN_VBI_X_SAMPLES )
        				{
        				    if ( pKSVBIDataFormat->VBIInfoHeader.SamplesPerLine <= MAX_VBI_X_SAMPLES )
                            {
        					    rval = TRUE;
                            }
        				    else
        				    {
        					    CDebugPrint(DebugLevelVerbose,
        						    (CODECNAME ": CodecVerifyFormat : SamplesPerLine Too Large=%d vs. %d\n", 
        						    pKSVBIDataFormat->VBIInfoHeader.SamplesPerLine, MAX_VBI_X_SAMPLES ));
        				    }
        				}
        				else
        				{
        					CDebugPrint(DebugLevelVerbose,
        						(CODECNAME ": CodecVerifyFormat : SamplesPerLine Too Small=%d vs. %d\n", 
        						pKSVBIDataFormat->VBIInfoHeader.SamplesPerLine, MIN_VBI_X_SAMPLES ));
        				}
        			}
        			else
        			{
        				CDebugPrint(DebugLevelVerbose,
        					(CODECNAME ": CodecVerifyFormat : EndLine Too Large=%d vs. %d\n", 
        					pKSVBIDataFormat->VBIInfoHeader.EndLine, MAX_VBI_Y_SAMPLES ));
        			}
        		}
        		else
        		{
        			CDebugPrint(DebugLevelVerbose,
        				(CODECNAME ": CodecVerifyFormat : StartLine Too Small=%d vs. %d\n", 
        				pKSVBIDataFormat->VBIInfoHeader.StartLine, MIN_VBI_Y_SAMPLES ));
        		}
            }
			else if( IsEqualGUID( &ThisFormat->DataRange.MajorFormat, &KSDATAFORMAT_TYPE_NABTS ) )
			{
				// A NABTS format.  Just check the buffer size.
				if (pKSDataFormat->SampleSize >= ThisFormat->DataRange.SampleSize)
					rval = TRUE;
				else {
        			CDebugPrint(DebugLevelVerbose,
        				(CODECNAME ": CodecVerifyFormat : SampleSize Too Small=%d vs. %d\n", 
        				pKSDataFormat->SampleSize,
						ThisFormat->DataRange.SampleSize ));
				}
			}
			else if( IsEqualGUID( &ThisFormat->DataRange.SubFormat, &KSDATAFORMAT_SUBTYPE_NABTS ) )
			{
				// A NABTS format.  Just check the buffer size.
				if (pKSDataFormat->SampleSize >= ThisFormat->DataRange.SampleSize)
					rval = TRUE;
				else {
        			CDebugPrint(DebugLevelVerbose,
        				(CODECNAME ": CodecVerifyFormat : SampleSize Too Small=%d vs. %d\n", 
        				pKSDataFormat->SampleSize,
						ThisFormat->DataRange.SampleSize ));
				}
			}
            // Add tests for other formats here
			//  OR just rubber stamp/ignore the SPECIFIER.
            else
            {
                CDebugPrint(DebugLevelTrace,(CODECNAME , "Unrecognized format requested\n" ));
            }

        }
        else
        {
	        CDebugPrint(DebugLevelTrace, ( CODECNAME, "General Format Mismatch\n" ));
        }
    }
	if (ThisFormat && rval == TRUE && pMatchedFormat)
	   *pMatchedFormat = ThisFormat->DataRange;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---CodecVerifyFormat(%x)=%s\n", pKSDataFormat, rval? "TRUE":"FALSE"));
	return rval;
}

/*
** CodecFormatFromRange()
**
**   Returns a DATAFORMAT from a DATARANGE
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb 
**
** Returns:
** 
**   TRUE if the format is supported
**   FALSE if the format cannot be suppored
**
** Side Effects:  none
*/

BOOL 
CodecFormatFromRange( IN PHW_STREAM_REQUEST_BLOCK pSrb )
{
    BOOL			            bStatus = FALSE;
    BOOL			            bMatchFound = FALSE;
    PSTREAM_DATA_INTERSECT_INFO IntersectInfo;
    PKSDATARANGE                DataRange;
    BOOL                        OnlyWantsSize;
    ULONG                       StreamNumber;
    ULONG                       j;
    ULONG                       NumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->CodecFormatFromRange(pSrb=%x)\n", pSrb));

    IntersectInfo = pSrb->CommandData.IntersectInfo;
    StreamNumber = IntersectInfo->StreamNumber;
    DataRange = IntersectInfo->DataRange;

    pSrb->ActualBytesTransferred = 0;

    //
    // Check that the stream number is valid
    //
    if (StreamNumber >= DRIVER_STREAM_COUNT) 
    {
		CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecFormatFromRange : StreamNumber too big=%d\n", StreamNumber));
		pSrb->Status = STATUS_NOT_IMPLEMENTED;

		CDEBUG_BREAK();

		CDebugPrint(DebugLevelTrace,
			(CODECNAME ":<---CodecFormatFromRange(pSrb=%x)=%s\n", 
			pSrb, bStatus ? "TRUE" : "FALSE" ));
		return FALSE;
    }

	NumberOfFormatArrayEntries = 
		Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

	//
	// Get the pointer to the array of available formats
	//
	pAvailableFormats = Streams[StreamNumber].hwStreamInfo.StreamFormatsArray;

	//
	// Is the caller trying to get the format, or the size of the format?
	//
	OnlyWantsSize = (IntersectInfo->SizeOfDataFormatBuffer == sizeof(ULONG));

	//
	// Walk the formats supported by the stream searching for a match
	// of the three GUIDs which together define a DATARANGE
	//
	for (j = 0; j < NumberOfFormatArrayEntries; j++, pAvailableFormats++) 
	{
		if (!CodecCompareGUIDsAndFormatSize(DataRange, *pAvailableFormats, TRUE))
			continue;

		// We have a match, Houston!  Now figure out which format to copy out.
		if (IsEqualGUID(&DataRange->Specifier, &KSDATAFORMAT_SPECIFIER_VBI))
		{
			PKS_DATARANGE_VIDEO_VBI pDataRangeVBI =
				(PKS_DATARANGE_VIDEO_VBI)*pAvailableFormats;
			ULONG	FormatSize = sizeof( KS_DATAFORMAT_VBIINFOHEADER );

			bMatchFound = TRUE;

			// Is the caller trying to get the format, or the size of it?
			if ( IntersectInfo->SizeOfDataFormatBuffer == sizeof(FormatSize) )
			{					
				CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": CodecFormatFromRange : Format Size=%d\n", 
					FormatSize));
				*(PULONG)IntersectInfo->DataFormatBuffer = FormatSize;
				pSrb->ActualBytesTransferred = sizeof(FormatSize);
				bStatus = TRUE;
			}
			else
			{
				// Verify that there is enough room in the supplied buffer
				//   for the whole thing
				if ( IntersectInfo->SizeOfDataFormatBuffer >= FormatSize ) 
				{
					PKS_DATAFORMAT_VBIINFOHEADER InterVBIHdr =
					(PKS_DATAFORMAT_VBIINFOHEADER)
						IntersectInfo->DataFormatBuffer;

					RtlCopyMemory(&InterVBIHdr->DataFormat,
							  &pDataRangeVBI->DataRange,
							  sizeof(KSDATARANGE));

					InterVBIHdr->DataFormat.FormatSize = FormatSize;

					RtlCopyMemory(&InterVBIHdr->VBIInfoHeader,
							&pDataRangeVBI->VBIInfoHeader,
							sizeof(KS_VBIINFOHEADER));
					pSrb->ActualBytesTransferred = FormatSize;

					bStatus = TRUE;
				}
				else
				{
					CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecFormatFromRange : Buffer Too Small=%d vs. %d\n", 
						 IntersectInfo->SizeOfDataFormatBuffer,
						 FormatSize));
					pSrb->Status = STATUS_BUFFER_TOO_SMALL;
				}
			}
			break;
		} // End KSDATAFORMAT_SPECIFIER_VBI

		else if (IsEqualGUID(&DataRange->MajorFormat, &KSDATAFORMAT_TYPE_NABTS))
		{
			PKSDATARANGE pDataRange = (PKSDATARANGE)*pAvailableFormats;
			ULONG	FormatSize = sizeof (KSDATAFORMAT);

            bMatchFound = TRUE;            

			// Is the caller trying to get the format, or the size of it?
			if (IntersectInfo->SizeOfDataFormatBuffer == sizeof (FormatSize))
			{					
				CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": CodecFormatFromRange : Format Size=%d\n", 
					FormatSize));
				*(PULONG)IntersectInfo->DataFormatBuffer = FormatSize;
				pSrb->ActualBytesTransferred = sizeof(FormatSize);
				bStatus = TRUE;
			}
			else
			{
				// Verify that there is enough room in the supplied buffer
				//   for the whole thing
				if (IntersectInfo->SizeOfDataFormatBuffer >= FormatSize) 
				{
					RtlCopyMemory(IntersectInfo->DataFormatBuffer,
								  pDataRange,
								  FormatSize);
					pSrb->ActualBytesTransferred = FormatSize;

					((PKSDATAFORMAT)IntersectInfo->DataFormatBuffer)->FormatSize = FormatSize;
					bStatus = TRUE;
				}
				else
				{
					CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": CodecFormatFromRange : Buffer Too Small=%d vs. %d\n", 
						 IntersectInfo->SizeOfDataFormatBuffer,
						 FormatSize));
					pSrb->Status = STATUS_BUFFER_TOO_SMALL;
				}
			}
            break;
		} // End KSDATAFORMAT_TYPE_NABTS

		else
			break;
	}

	if (!bMatchFound)
	{
		CDebugPrint(DebugLevelVerbose,(CODECNAME ": CodecFormatFromRange : Stream Format not found.\n" ));
		pSrb->Status = STATUS_NO_MATCH;
		bStatus = FALSE;
	}


    CDebugPrint(DebugLevelTrace,
		(CODECNAME ":<---CodecFormatFromRange(pSrb=%x)=%s\n", 
		pSrb, bStatus ? "TRUE" : "FALSE" ));

    return bStatus;
}

/*
** QueueAddIfNotEmpty
**
**   Adds an SRB to the current queue if it is not empty
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb 
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
** 
** TRUE if SRB was added (queue is not empty)
** FALSE if SRB was not added (queue is empty)
** Side Effects:  none
*/
BOOL STREAMAPI QueueAddIfNotEmpty( IN PHW_STREAM_REQUEST_BLOCK pSrb,
							IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   BOOL            bAddedSRB = FALSE;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueAddIfNotEmpty %x\n", pSrb ));
   CASSERT( pSrb );
   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;
   CASSERT( pSrbExtension );
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   if( !IsListEmpty( pQueue ))
   {
       pSrbExtension->pSrb = pSrb;
       InsertTailList( pQueue, &pSrbExtension->ListEntry );
       bAddedSRB = TRUE;
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ": %s%x\n", bAddedSRB ? 
       "Added SRB to Queue " : ": Queue is empty, not adding ", pSrb ));
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueAddIfNotEmpty %x\n", bAddedSRB ));
   
   return bAddedSRB;
}

/*
** QueueAdd
**
**   Adds an SRB to the current queue unconditionally
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb 
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
** 
** TRUE 
** Side Effects:  none
*/
BOOL STREAMAPI QueueAdd( IN PHW_STREAM_REQUEST_BLOCK pSrb,
							IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueAdd %x\n", pSrb ));
   
   CASSERT( pSrb );
   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;
   CASSERT( pSrbExtension );
   
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   
   pSrbExtension->pSrb = pSrb;
   InsertTailList( pQueue, &pSrbExtension->ListEntry );
   
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Added SRB %x to Queue\n", pSrb ));
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueAdd\n" ));
   
   return TRUE;
}


/*
** QueueRemove
**
**   Removes the next available SRB from the current queue
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK * pSrb 
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
**
** TRUE if SRB was removed
** FALSE if SRB was not removed
** Side Effects:  none
*/
                         
BOOL STREAMAPI QueueRemove( 
                           IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
							IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL                       Irql;
   BOOL                        bRemovedSRB = FALSE;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueRemove\n" ));
   
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   *pSrb = ( PHW_STREAM_REQUEST_BLOCK )NULL;
   CDebugPrint( DebugLevelVerbose,
       ( CODECNAME ": QFlink %x QBlink %x\n", pQueue->Flink, pQueue->Blink ));
   if( !IsListEmpty( pQueue ))
   {
       PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;
       PUCHAR          Ptr = ( PUCHAR )RemoveHeadList( pQueue );
       pCurrentSrb = ( PHW_STREAM_REQUEST_BLOCK * )((( PUCHAR )Ptr ) +
           sizeof( LIST_ENTRY ));
       CASSERT( *pCurrentSrb );
       *pSrb = *pCurrentSrb;
       bRemovedSRB = TRUE;
   }
   else
       CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Queue is empty\n" ));
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueRemove %x %x\n",
       bRemovedSRB, *pSrb ));
   return bRemovedSRB;
}

/*
** QueueRemoveSpecific
**
**   Removes a specific SRB from the queue
**
** Arguments:
**
**         IN PHW_STREAM_REQUEST_BLOCK pSrb           
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
**
** TRUE if the SRB was found and removed
** FALSE if the SRB was not found
** 
** Side Effects:  none
*/

BOOL STREAMAPI QueueRemoveSpecific( 
							IN PHW_STREAM_REQUEST_BLOCK pSrb,
                           IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL           Irql;
   PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;
   PLIST_ENTRY     pCurrentEntry;
   BOOL            bRemovedSRB = FALSE;
   
   CASSERT( pSrb );
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":--->QueueRemoveSpecific %x\n", pSrb ));
   
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   
   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while(( pCurrentEntry != pQueue ) && !bRemovedSRB )
       {
           pCurrentSrb = ( PHW_STREAM_REQUEST_BLOCK * )((( PUCHAR )pCurrentEntry ) + 
               sizeof( LIST_ENTRY ));
           CASSERT( *pCurrentSrb );
           if( *pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   if( IsListEmpty( pQueue ))
       CDebugPrint( DebugLevelVerbose, ( CODECNAME ": Queue is empty\n" ));   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<---QueueRemoveSpecific %x\n",
       bRemovedSRB ));
   return bRemovedSRB;
}                                                        
/*
** QueueEmpty
**
**   Indicates whether or not the queue is empty
**
** Arguments:
**
**         IN PKSPIN_LOCK              pQueueSpinLock
**         IN PLIST_ENTRY              pQueue
**
** Returns:
**
** TRUE if queue is empty
** FALSE if queue is not empty
** Side Effects:  none
*/
BOOL STREAMAPI QueueEmpty(
                           IN PKSPIN_LOCK pQueueSpinLock,
                           IN PLIST_ENTRY pQueue
                           )
{
   KIRQL       Irql;
   BOOL        bEmpty = FALSE;
   
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":---> QueueEmpty\n" ));
   KeAcquireSpinLock( pQueueSpinLock, &Irql );
   bEmpty = IsListEmpty( pQueue );  
   KeReleaseSpinLock( pQueueSpinLock, Irql );
   CDebugPrint( DebugLevelVerbose, ( CODECNAME ":<--- QueueEmpty %x\n", bEmpty ));
   return bEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\codprop.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

//
// This file handles all codec property sets
//

#include <strmini.h>
#include <ksmedia.h>
#include "codmain.h"
#include "coddebug.h"

// CodecFiltering Property Set functions
// -------------------------------------------------------------------

/*
** CodecSetCodecGlobalProperty ()
**
**    Handles Set operations on the Global Codec property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
CodecSetCodecGlobalProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    LONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY); // size of data supplied

    ASSERT (nBytes >= sizeof (LONG));
    pSrb->ActualBytesTransferred = 0;

    switch (Id) 
    {
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pHwDevExt->ScanlinesRequested ) );
            RtlCopyMemory( &pHwDevExt->ScanlinesRequested, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->ScanlinesDiscovered ) );
            RtlCopyMemory( &pHwDevExt->ScanlinesDiscovered, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->SubstreamsRequested ) );
            RtlCopyMemory( &pHwDevExt->SubstreamsRequested, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pHwDevExt->SubstreamsDiscovered ) );
            RtlCopyMemory( &pHwDevExt->SubstreamsDiscovered, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_STATISTICS:
		{
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS\n"));
            nBytes = min( nBytes, sizeof( pHwDevExt->Stats ) );
            RtlCopyMemory( &pHwDevExt->Stats, &Property->Statistics, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecSetCodecGlobalProperty : Unknown Property Id=%d\n", Id));
			CDEBUG_BREAK();
			break;
    }
}


/*
** CodecGetCodecGlobalProperty ()
**
**    Handles Get operations on the Global Codec property set.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK
**
** Returns:
**
** Side Effects:  none
*/

VOID
CodecGetCodecGlobalProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    LONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY);        // size of data supplied

    ASSERT (nBytes >= sizeof (LONG));
    pSrb->ActualBytesTransferred = 0;

    switch (Id) 
    {
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pHwDevExt->ScanlinesRequested ) );
            RtlCopyMemory( &Property->Scanlines, &pHwDevExt->ScanlinesRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pHwDevExt->ScanlinesDiscovered ) );
            RtlCopyMemory( &Property->Scanlines, &pHwDevExt->ScanlinesDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pHwDevExt->ScanlinesDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pHwDevExt->SubstreamsRequested ) );
            RtlCopyMemory( &Property->Substreams, &pHwDevExt->SubstreamsRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pHwDevExt->SubstreamsDiscovered ) );
            RtlCopyMemory( &Property->Substreams, &pHwDevExt->SubstreamsDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pHwDevExt->SubstreamsDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_STATISTICS:
		{
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S\n"));
            nBytes = min( nBytes, sizeof( pHwDevExt->Stats ) );
            RtlCopyMemory( &Property->Statistics, &pHwDevExt->Stats, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": CodecGetCodecGlobalProperty : Unknown Property Id=%d\n", Id));
			CDEBUG_BREAK();
			break;
    }
}


// -------------------------------------------------------------------
// General entry point for all get/set codec properties
// -------------------------------------------------------------------

/*
** CodecSetProperty ()
**
**    Handles Set operations for all codec properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
CodecSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(&KSPROPSETID_Connection, &pSPD->Property->Set)) 
    {
        // CodecSetConnectionProperty(pSrb);
    }
    else if (IsEqualGUID(&KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
         CodecSetCodecGlobalProperty(pSrb);
    }
    else 
    {
        //
        // We should never get here
        //

        CDEBUG_BREAK();
    }
}

/*
** CodecGetProperty ()
**
**    Handles Get operations for all codec properties.
**
** Arguments:
**
**      pSRB -
**          Pointer to the HW_STREAM_REQUEST_BLOCK 
**
** Returns:
**
** Side Effects:  none
*/

VOID
STREAMAPI 
CodecGetProperty( PHW_STREAM_REQUEST_BLOCK pSrb )

{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    if (IsEqualGUID(&KSPROPSETID_Connection, &pSPD->Property->Set)) 
    {
        // CodecGetConnectionProperty(pSrb);
    }
    else if (IsEqualGUID(&KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
        CodecGetCodecGlobalProperty(pSrb);
    }
    else 
    {
        //
        // We should never get here
        //
        CDEBUG_BREAK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\codprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

// ------------------------------------------------------------------------
// Property sets for VBI Codecs
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(DefaultCodecProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS),// MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS),// MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
	0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_VBICODECFILTERING_STATISTICS,
		TRUE,                                   // GetSupported or Handler
		sizeof(KSPROPERTY),                     // MinProperty
		sizeof(VBICODECFILTERING_STATISTICS_NABTS),// MinData
		TRUE,                                   // SetSupported or Handler
		NULL,                                   // Values
		0,                                      // RelationsCount
		NULL,                                   // Relations
		NULL,                                   // SupportHandler
		0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by the codec
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(CodecPropertyTable)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VBICodecFiltering,
        SIZEOF_ARRAY(DefaultCodecProperties),
        DefaultCodecProperties,
        0, 
        NULL
    ),
};

#define NUMBER_OF_CODEC_PROPERTY_SETS (SIZEOF_ARRAY (CodecPropertyTable))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\codstrm.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CODSTRM_H__
#define __CODSTRM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    
// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VideoStreamConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    )
};

DEFINE_KSPROPERTY_TABLE(StreamAllocatorProperties)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR
    (
        FALSE,
        FALSE
    )
};


// ------------------------------------------------------------------------
// Per pin property set for VBI codec filtering
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(VBICodecProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_SCANLINES),    // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS),// MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(VBICODECFILTERING_NABTS_SUBSTREAMS),// MinData
        TRUE,                                   // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        0                                       // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
		KSPROPERTY_VBICODECFILTERING_STATISTICS,
		TRUE,                                   // GetSupported or Handler
		sizeof(KSPROPERTY),                     // MinProperty
		sizeof(VBICODECFILTERING_STATISTICS_NABTS_PIN),// MinData
		TRUE,                                   // SetSupported or Handler
		NULL,                                   // Values
		0,                                      // RelationsCount
		NULL,                                   // Relations
		NULL,                                   // SupportHandler
		0                                       // SerializedSize
    ),
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(VideoStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(VideoStreamConnectionProperties),  // PropertiesCount
        VideoStreamConnectionProperties,                // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    ( 
        &KSPROPSETID_VBICodecFiltering,                 // Set
        SIZEOF_ARRAY(VBICodecProperties),               // PropertiesCount
        VBICodecProperties,                             // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET
    (
	&KSPROPSETID_Stream,			         // Set
       	SIZEOF_ARRAY(StreamAllocatorProperties),	 // PropertiesCount
       	StreamAllocatorProperties,			 // PropertyItems
       	0,						 // FastIoCount
       	NULL						 // FastIoTable
    ),
};

#define NUMBER_VIDEO_STREAM_PROPERTIES (SIZEOF_ARRAY(VideoStreamProperties))

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

// Warning, the following VBI geometry is governed by the capture driver NOT
// the codecs.  Therefore, any specification of a VBI capture format will be
// ignored by most capture drivers.  Look at the KS_VBI_FRAME_INFO data on each
// sample to determine the actual data characteristics of the samples.

#define NORMAL_VBI_START_LINE   10
#define NORMAL_VBI_STOP_LINE    21

#define MIN_VBI_X_SAMPLES (720*2)
#define AVG_VBI_X_SAMPLES (768*2)
#define MAX_VBI_X_SAMPLES (1135*2)

#define MIN_VBI_Y_SAMPLES (1)
#define AVG_VBI_Y_SAMPLES (12)  
#define MAX_VBI_Y_SAMPLES (21)

#define MIN_VBI_T_SAMPLES (50)
#define AVG_VBI_T_SAMPLES (59.94)
#define MAX_VBI_T_SAMPLES (60)

#define NTSC_FSC_FREQUENCY  3580000
#define PAL_FSC_FREQUENCY   4430000

#define MIN_SAMPLING_RATE   (min(8*NTSC_FSC_FREQUENCY,8*PAL_FSC_FREQUENCY))
#define AVG_SAMPLING_RATE   (8*NTSC_FSC_FREQUENCY)
#define MAX_SAMPLING_RATE   (max(8*NTSC_FSC_FREQUENCY,8*PAL_FSC_FREQUENCY))

// This format is the "arbitrary one" that was used in early capture drivers!

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------
//#define VBISamples (768*2)
#define VBIStart   10
#define VBIEnd     21
KS_DATARANGE_VIDEO_VBI StreamFormatVBI =
{
   // KSDATARANGE
   {
      {
         sizeof( KS_DATARANGE_VIDEO_VBI ),
         0,
         VBISamples * 12,            // SampleSize
         0,                          // Reserved
         { STATIC_KSDATAFORMAT_TYPE_VBI },
		 { STATIC_KSDATAFORMAT_SUBTYPE_RAW8 },
         { STATIC_KSDATAFORMAT_SPECIFIER_VBI }
      }
   },
   TRUE,    // BOOL,  bFixedSizeSamples (all samples same size?)
   TRUE,    // BOOL,  bTemporalCompression (all I frames?)

   KS_VIDEOSTREAM_VBI, // StreamDescriptionFlags  (KS_VIDEO_DESC_*)
   0,       // MemoryAllocationFlags   (KS_VIDEO_ALLOC_*)

   // _KS_VIDEO_STREAM_CONFIG_CAPS
   {
      { STATIC_KSDATAFORMAT_SPECIFIER_VBI },
      KS_AnalogVideo_NTSC_M,                       // AnalogVideoStandard
      {
         VBISamples, 480  // SIZE InputSize
      },
      {
         VBISamples, 12   // SIZE MinCroppingSize;       smallest rcSrc cropping rect allowed
      },
      {
         VBISamples, 12   // SIZE MaxCroppingSize;       largest rcSrc cropping rect allowed
      },
      1,           // int CropGranularityX;       // granularity of cropping size
      1,           // int CropGranularityY;
      1,           // int CropAlignX;             // alignment of cropping rect
      1,           // int CropAlignY;
      {
         VBISamples, 12   // SIZE MinOutputSize;         // smallest bitmap stream can produce
      },
      {
         VBISamples, 12   // SIZE MaxOutputSize;         // largest  bitmap stream can produce
      },
      1,          // int OutputGranularityX;     // granularity of output bitmap size
      2,          // int OutputGranularityY;
      0,          // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
      0,          // StretchTapsY
      0,          // ShrinkTapsX
      0,          // ShrinkTapsY
      333667,     // LONGLONG MinFrameInterval;  // 100 nS units
      333667,     // LONGLONG MaxFrameInterval;
      VBISamples * 30 * 12, // LONG MinBitsPerSecond;
      VBISamples * 30 * 12 //LONG MaxBitsPerSecond;
   },

   // KS_VBIINFOHEADER (default format)
   {
      VBIStart,      // StartLine  -- inclusive
      VBIEnd,        // EndLine    -- inclusive
      28636360,      // SamplingFrequency;   Hz.
      732,           // MinLineStartTime;
      732,           // MaxLineStartTime;
      732,           // ActualLineStartTime
      0,             // ActualLineEndTime;
      KS_AnalogVideo_NTSC_M,      // VideoStandard;
      VBISamples,           // SamplesPerLine;
      VBISamples,       // StrideInBytes;
      VBISamples * 12   // BufferSize;
   }
};

#ifdef HW_INPUT
# define GUIDKLUDGESTORAGE 1
# include "guidkludge.h"
// input is H/W sliced NABTS
KSDATARANGE StreamFormatHWNABTS =
{
    sizeof (KSDATARANGE),
    0,
    sizeof (NABTS_BUFFER),
    0,                  // Reserved
# ifdef OLD_INPUT_FORMAT                 // Note, we use VBI because of the stream header data (KSWDMCAP imposed) requirements
    { STATIC_KSDATAFORMAT_TYPE_NABTS },  // TODO - Investigate adding other "data handlers" to KSWDMCAP to allow non-VBI data
# else //OLD_INPUT_FORMAT                
	{ STATIC_KSDATAFORMAT_TYPE_VBI },
# endif //OLD_INPUT_FORMAT               
    { STATIC_KSDATAFORMAT_SUBTYPE_NABTS },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};
#endif //HW_INPUT 

// output is NABTS records
KSDATARANGE StreamFormatNABTS =
{
    sizeof (KSDATARANGE),
    0,
    sizeof (NABTS_BUFFER),
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_NABTS },
    { STATIC_KSDATAFORMAT_SUBTYPE_NABTS },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};


// output is FEC-corrected NABTS bundles
KSDATARANGE StreamFormatNABTSFEC =
{
    sizeof (KSDATARANGE),
    0,
    sizeof (NABTSFEC_BUFFER),
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_NABTS },
    { STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};

//---------------------------------------------------------------------------
//  STREAM_VBI Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT StreamVBIFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatVBI,
};
#define NUM_STREAM_VBI_FORMATS (SIZEOF_ARRAY(StreamVBIFormats))

#ifdef HW_INPUT
//---------------------------------------------------------------------------
//  STREAM_NABTS Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT StreamNABTSFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatHWNABTS,
};
#define NUM_STREAM_NABTS_FORMATS (SIZEOF_ARRAY(StreamNABTSFormats))
#endif /*HW_INPUT*/


//---------------------------------------------------------------------------
//  STREAM_Decode Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT StreamDecodeFormats[] = 
{
    (PKSDATAFORMAT) &StreamFormatNABTSFEC,
    (PKSDATAFORMAT) &StreamFormatNABTS,

    // Add more formats here for whatever NABTS output formats are supported.
};
#define NUM_STREAM_DECODE_FORMATS (SIZEOF_ARRAY (StreamDecodeFormats))

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO {
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;
} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] = 
{
  // -----------------------------------------------------------------
  // STREAM_VBI
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
	1,                                      // NumberOfPossibleInstances
	KSPIN_DATAFLOW_IN,                      // DataFlow
	TRUE,                                   // DataAccessible
	NUM_STREAM_VBI_FORMATS,                 // NumberOfFormatArrayEntries
	StreamVBIFormats,                       // StreamFormatsArray
	0,                                      // ClassReserved[0]
	0,                                      // ClassReserved[1]
	0,                                      // ClassReserved[2]
	0,                                      // ClassReserved[3]
	NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
	(PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
	0,                                      // NumStreamEventArrayEntries
	0,                                      // StreamEventsArray
	(GUID *)&PINNAME_VIDEO_VBI,             // Category
	(GUID *)&PINNAME_VIDEO_VBI,             // Name
	0,                                      // MediumsCount
	NULL,                                   // Mediums
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
	sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
	STREAM_VBI,                             // StreamNumber
	(PVOID)NULL,                            // HwStreamExtension
	VideoReceiveDataPacket,                 // HwReceiveDataPacket
	VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
	{                                       // HW_CLOCK_OBJECT
	    NULL,                                // .HWClockFunction
	    0,                                   // .ClockSupportFlags
	},
	FALSE,                                  // Dma
	TRUE,                                   // Pio
	(PVOID)NULL,                            // HwDeviceExtension
	sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
	0,                                      // StreamHeaderWorkspace 
	TRUE,                                   // Allocator 
	NULL,                                   // HwEventRoutine
    },
  },


  // -----------------------------------------------------------------
  // STREAM_Decode
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
	MAX_PIN_INSTANCES,                      // NumberOfPossibleInstances
	KSPIN_DATAFLOW_OUT,                     // DataFlow
	TRUE,                                   // DataAccessible
	NUM_STREAM_DECODE_FORMATS,              // NumberOfFormatArrayEntries
	StreamDecodeFormats,                    // StreamFormatsArray
	0,                                      // ClassReserved[0]
	0,                                      // ClassReserved[1]
	0,                                      // ClassReserved[2]
	0,                                      // ClassReserved[3]
	NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
	(PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
	0,                                      // NumStreamEventArrayEntries;
	0,                                      // StreamEventsArray;
	(GUID *)&PINNAME_VIDEO_NABTS,           // Category
	(GUID *)&PINNAME_VIDEO_NABTS,           // Name
	0,                                      // MediumsCount
	NULL,                                   // Mediums
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
	sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
	STREAM_Decode,                          // StreamNumber
	(PVOID)NULL,                            // HwStreamExtension
	VideoReceiveDataPacket,                 // HwReceiveDataPacket
	VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
	{                                       // HW_CLOCK_OBJECT
	    NULL,                                // .HWClockFunction
	    0,                                   // .ClockSupportFlags
	},
	FALSE,                                  // Dma
	TRUE,                                   // Pio
	(PVOID)NULL,                            // HwDeviceExtension
	0,                                      // StreamHeaderMediaSpecific
	0,                                      // StreamHeaderWorkspace 
	TRUE,                                   // Allocator 
	NULL,                                   // HwEventRoutine
    },
  },

#ifdef HW_INPUT
  // -----------------------------------------------------------------
  // STREAM_NABTS
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
	1,                                      // NumberOfPossibleInstances
	KSPIN_DATAFLOW_IN,                      // DataFlow
	TRUE,                                   // DataAccessible
	NUM_STREAM_NABTS_FORMATS,               // NumberOfFormatArrayEntries
	StreamNABTSFormats,                     // StreamFormatsArray
	0,                                      // ClassReserved[0]
	0,                                      // ClassReserved[1]
	0,                                      // ClassReserved[2]
	0,                                      // ClassReserved[3]
	NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
	(PKSPROPERTY_SET)VideoStreamProperties, // StreamPropertiesArray
	0,                                      // NumStreamEventArrayEntries
	0,                                      // StreamEventsArray
	(GUID *)&PINNAME_VIDEO_NABTS_CAPTURE,   // Category
	(GUID *)&PINNAME_VIDEO_NABTS_CAPTURE,   // Name
	0,                                      // MediumsCount
	NULL,                                   // Mediums
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
	sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
	STREAM_NABTS,                           // StreamNumber
	(PVOID)NULL,                            // HwStreamExtension
	NABTSReceiveDataPacket,                 // HwReceiveDataPacket
	VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
	{                                       // HW_CLOCK_OBJECT
	    NULL,                                // .HWClockFunction
	    0,                                   // .ClockSupportFlags
	},
	FALSE,                                  // Dma
	TRUE,                                   // Pio
	(PVOID)NULL,                            // HwDeviceExtension
	0,                                      // StreamHeaderMediaSpecific
	0,                                      // StreamHeaderWorkspace 
	TRUE,                                   // Allocator 
	NULL,                                   // HwEventRoutine
    },
  },
#endif /*HW_INPUT*/

#ifdef VBI_OUT
  // -----------------------------------------------------------------
  // STREAM_VBI_OUT
  // -----------------------------------------------------------------
  {
    // HW_STREAM_INFORMATION -------------------------------------------
    {
	MAX_PIN_INSTANCES,                      // NumberOfPossibleInstances
	KSPIN_DATAFLOW_OUT,                     // DataFlow
	TRUE,                                   // DataAccessible
	NUM_STREAM_VBI_FORMATS,                 // NumberOfFormatArrayEntries
	StreamVBIFormats,                       // StreamFormatsArray
	0,                                      // ClassReserved[0]
	0,                                      // ClassReserved[1]
	0,                                      // ClassReserved[2]
	0,                                      // ClassReserved[3]
	NUMBER_VIDEO_STREAM_PROPERTIES,         // NumStreamPropArrayEntries
	VideoStreamProperties,                  // StreamPropertiesArray
	0,                                      // NumStreamEventArrayEntries;
	0,                                      // StreamEventsArray;
	(GUID *)&PINNAME_VIDEO_VBI,             // Category
	(GUID *)&PINNAME_VIDEO_VBI,             // Name
	0,                                      // MediumsCount
	NULL,                                   // Mediums
    },
           
    // HW_STREAM_OBJECT ------------------------------------------------
    {
	sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
	STREAM_VBI_OUT,                         // StreamNumber
	(PVOID)NULL,                            // HwStreamExtension
	VideoReceiveDataPacket,                 // HwReceiveDataPacket
	VideoReceiveCtrlPacket,                 // HwReceiveControlPacket
	{                                       // HW_CLOCK_OBJECT
	    NULL,                                // .HWClockFunction
	    0,                                   // .ClockSupportFlags
	},
	FALSE,                                  // Dma
	TRUE,                                   // Pio
	(PVOID)NULL,                            // HwDeviceExtension
	sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
	0,                                      // StreamHeaderWorkspace 
	TRUE,                                   // Allocator 
	NULL,                                   // HwEventRoutine
    },
  },
#endif /*VBI_OUT*/
};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Categories define what the device does.

static GUID Categories[] = {
    // {07DAD660-22F1-11d1-A9F4-00C04FBBDE8F}
    STATIC_KSCATEGORY_VBICODEC 
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    NULL,
    0,
    NULL
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader = 
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif // __CAPSTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\guidkludge.h ===
#ifndef _GUIDKLUDGE_H_
#define _GUIDKLUDGE_H_

#ifndef STATIC_PINNAME_VIDEO_NABTS_CAPTURE
// {29703660-498A-11d2-B4B1-00A0D102CFBE}
#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE \
    0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#ifdef GUIDKLUDGESTORAGE
 GUID PINNAME_VIDEO_NABTS_CAPTURE = { STATIC_PINNAME_VIDEO_NABTS_CAPTURE };
#else
 extern GUID  PINNAME_VIDEO_NABTS_CAPTURE;
#endif
#endif //!defined(STATIC_PINNAME_VIDEO_NABTS_CAPTURE)

#endif //_GUIDKLUDGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\codmain.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __CODMAIN_H__
#define __CODMAIN_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if DBG
#ifndef DEBUG
#define DEBUG
#endif
#ifndef _DEBUG
#define _DEBUG
#endif
#endif

#include "bpcstore.h"

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

/**************************************************************/
/* Driver Name - Change this to reflect your executable name! */
/**************************************************************/

#define CODECNAME           "NABTSFEC"

// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

typedef enum {
    STREAM_VBI = 0,	// VBI samples in
    STREAM_Decode,	// Decoded NABTS out
#ifdef HW_INPUT
    STREAM_NABTS,	// H/W decoded NABTS in
#endif /*HW_INPUT*/
#ifdef VBI_OUT
    STREAM_VBI_OUT,	// VBI samples out
#endif /*VBI_OUT*/
						/// MAX_STREAM_COUNT *must*be*last*
    MAX_STREAM_COUNT	/// Unused as an index, this is used as the number of
						///  streams and must be equal to DRIVER_STREAM_COUNT.
						///  It is defined here to avoid circular references.
}; 

// Stream structure declarations
extern KS_DATARANGE_VIDEO_VBI StreamFormatVBI;
extern KSDATAFORMAT StreamFormatNABTS, StreamFormatNABTSFEC;

// We manage multiple instances of each pin up to this limit
#define MAX_PIN_INSTANCES   8

#define BIT(n)             (((unsigned long)1)<<(n))
#define BITSIZE(v)         (sizeof(v)*8)
#define SETBIT(array,n)    (array[(n)/BITSIZE(*array)] |= BIT((n)%BITSIZE(*array)))
#define CLEARBIT(array,n)  (array[(n)/BITSIZE(*array)] &= ~BIT((n)%BITSIZE(*array)))
#define TESTBIT(array,n)   (BIT((n)%BITSIZE(*array)) == (array[(n)/BITSIZE(*array)] & BIT((n)%BITSIZE(*array))))


//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//

typedef struct _HW_DEVICE_EXTENSION {
    struct _STREAMEX *   pStrmEx[MAX_STREAM_COUNT][MAX_PIN_INSTANCES];   // Pointers to each stream
    UINT                 ActualInstances[MAX_STREAM_COUNT];              // Counter of instances per stream

    // Clock 
    REFERENCE_TIME       QST_Start;             // KeQuerySystemTime at run
    REFERENCE_TIME       QST_Now;               // KeQuerySystemTime currently
    REFERENCE_TIME       WallTime100ns;         // elapsed time based on KeQueryPerformanceCounter

    // The following VBICODECFILTERING_* fields are defaults for
    //  newly created output pins(copied)
    VBICODECFILTERING_SCANLINES         ScanlinesRequested; // Bitmask of requested scanlines
    VBICODECFILTERING_SCANLINES         ScanlinesDiscovered;// Bitmask of discovered scanlines

    VBICODECFILTERING_NABTS_SUBSTREAMS  SubstreamsRequested;// Bitmask of requested substream IDs 
    VBICODECFILTERING_NABTS_SUBSTREAMS  SubstreamsDiscovered;// Bitmask of discovered substream IDs

    VBICODECFILTERING_STATISTICS_NABTS  Stats;

    BPC_VBI_STORAGE                     VBIstorage;

    ULONG				                fTunerChange;	// Channel change in progress
    
	LIST_ENTRY							AdapterSRBQueue;
    KSPIN_LOCK							AdapterSRBSpinLock;
    BOOL                                bAdapterQueueInitialized;

#ifdef HW_INPUT
	// Last pictureNumber that decoded VBI data was processed
	// (used for coordination of multiple input pins)
    FAST_MUTEX 				            LastPictureMutex;
#endif /*HW_INPUT*/
    LONGLONG 				            LastPictureNumber; 

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//
 
typedef struct _STREAMEX {
    PHW_DEVICE_EXTENSION                pHwDevExt;          // For timer use
    PHW_STREAM_OBJECT                   pStreamObject;      // For timer use
    KS_VBI_FRAME_INFO                   FrameInfo;          // PictureNumber, etc.
    ULONG                               fDiscontinuity;     // Discontinuity since last valid
    KSSTATE                             KSState;            // Run, Stop, Pause
    REFERENCE_TIME                      FrameTime100ns;     // elapsed time based on frames captured
    HANDLE                              hMasterClock;
    HANDLE                              hClock;
    ULONG                               StreamInstance;     // 0..NumberOfPossibleInstances-1
    LONGLONG 				            LastPictureNumber;  // Last received picture number
    KSDATAFORMAT                        OpenedFormat;       // Based on the actual open request.

    VBICODECFILTERING_SCANLINES         ScanlinesRequested; // Bitmask of requested scanlines
    VBICODECFILTERING_SCANLINES         ScanlinesDiscovered;// Bitmask of discovered scanlines

    VBICODECFILTERING_NABTS_SUBSTREAMS  SubstreamsRequested;// Bitmask of requested substream IDs 
    VBICODECFILTERING_NABTS_SUBSTREAMS  SubstreamsDiscovered;// Bitmask of discovered substream IDs

    VBICODECFILTERING_STATISTICS_NABTS_PIN PinStats;

    KS_VBIINFOHEADER			CurrentVBIInfoHeader;

    KSDATARANGE                 MatchedFormat;

#ifdef HW_INPUT
	// For when the VBI input pin is waiting for the NABTS input pin to catch up
	PHW_STREAM_REQUEST_BLOCK    pVBISrbOnHold;
    KSPIN_LOCK                  VBIOnHoldSpinLock;
#endif /*HW_INPUT*/

	KSPIN_LOCK				StreamControlSpinLock;	// Command queue spin lock
    KSPIN_LOCK				StreamDataSpinLock;    	// Data queue spin lock
    LIST_ENTRY				StreamDataQueue;		// Stream data queue
	LIST_ENTRY				StreamControlQueue;		// Stream command queue

} STREAMEX, *PSTREAMEX;

//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
	LIST_ENTRY					ListEntry;
	PHW_STREAM_REQUEST_BLOCK	pSrb;
} SRB_EXTENSION, *PSRB_EXTENSION;

/*****************************************************************************
*
* the following section defines prototypes for the minidriver initialization
* routines
*
******************************************************************************/

//
// DriverEntry:
//
// This routine is called when the mini driver is first loaded.  The driver
// should then call the StreamClassRegisterAdapter function to register with
// the stream class driver
//

ULONG DriverEntry (PVOID Context1, PVOID Context2);

//
// This routine is called by the stream class driver with configuration
// information for an adapter that the mini driver should load on.  The mini
// driver should still perform a small verification to determine that the
// adapter is present at the specified addresses, but should not attempt to
// find an adapter as it would have with previous NT miniports.
//
// All initialization of the codec should also be performed at this time.
//

BOOLEAN CodecInitialize (IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This routine is called when the system is going to remove or disable the
// device.
//
// The mini-driver should free any system resources that it allocated at this
// time.  Note that system resources allocated for the mini-driver by the
// stream class driver will be free'd by the stream driver, and should not be
// free'd in this routine.  (Such as the HW_DEVICE_EXTENSION)
//

BOOLEAN CodecUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb);


BOOLEAN CodecQueryUnload ( PHW_STREAM_REQUEST_BLOCK pSrb);	// Not implemented currently


//
// This is the prototype for the Hardware Interrupt Handler.  This routine
// will be called if the minidriver registers for and receives an interrupt
//

BOOLEAN HwInterrupt ( IN PHW_DEVICE_EXTENSION pDeviceExtension );

//
// This is the prototype for the stream enumeration function.  This routine
// provides the stream class driver with the information on data stream types
// supported
//

VOID CodecStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream open function
//

VOID CodecOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream close function
//

VOID CodecCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the CodecReceivePacket routine.  This is the
// entry point for command packets that are sent to the codec (not to a
// specific open stream)
//

VOID STREAMAPI CodecReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the protoype for the cancel packet routine.  This routine enables
// the stream class driver to cancel an outstanding packet.
//

VOID STREAMAPI CodecCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the packet timeout function.  The codec may choose to ignore a
// packet timeout, or reset the codec and cancel the requests, as required.
//

VOID STREAMAPI CodecTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

VOID STREAMAPI CodecGetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI CodecSetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);

BOOL 
CodecCompareGUIDsAndFormatSize( IN PKSDATARANGE DataRange1,
                                IN PKSDATARANGE DataRange2,
                                BOOLEAN bCheckSize );

BOOL 
CodecVerifyFormat(IN KSDATAFORMAT *pKSDataFormat, 
                  IN UINT StreamNumber,
                  PKSDATARANGE pMatchedFormat);

BOOL
CodecFormatFromRange(
        IN PHW_STREAM_REQUEST_BLOCK pSrb);

void 
CompleteStreamSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb, 
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
         BOOL fUseNotification2,
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
        );
void 
CompleteDeviceSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb, 
         IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
         BOOL fReadyForNext
        );

//
// prototypes for data handling routines
//
void		CompleteStreamIRP (IN PHW_STREAM_REQUEST_BLOCK pSrb, BOOLEAN ReadyForNext);

VOID STREAMAPI  VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI  VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
#ifdef HW_INPUT
VOID STREAMAPI  NABTSReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
#endif /*HW_INPUT*/
void		EnableIRQ(PHW_STREAM_OBJECT pstrm);
void		DisableIRQ(PHW_STREAM_OBJECT pstrm);
void            VBIOutputNABTSFEC(PHW_DEVICE_EXTENSION pHwDevExt, PSTREAMEX pInStrmEx);
void            VBIOutputNABTS(PHW_DEVICE_EXTENSION pHwDevExt, PSTREAMEX pInStrmEx);

//
// prototypes for properties and states
//

VOID		VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
//VOID		VideoStreamSetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb); // Not implemented
VOID		VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoStreamSetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID		VideoStreamGetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);

// 
// system time functions
//

ULONGLONG	VideoGetSystemTime();

// 
// stream clock functions
//
VOID		VideoIndicateMasterClock(PHW_STREAM_REQUEST_BLOCK pSrb);


//
// SRB Queue Management functions
//
BOOL STREAMAPI QueueAddIfNotEmpty( 
						IN PHW_STREAM_REQUEST_BLOCK,
						IN PKSPIN_LOCK,
                        IN PLIST_ENTRY);
BOOL STREAMAPI QueueAdd( 
						IN PHW_STREAM_REQUEST_BLOCK,
						IN PKSPIN_LOCK,
                        IN PLIST_ENTRY);
BOOL STREAMAPI QueueRemove( 
						IN OUT PHW_STREAM_REQUEST_BLOCK *,
						IN PKSPIN_LOCK,
                        IN PLIST_ENTRY);
BOOL STREAMAPI QueueRemoveSpecific( 
						IN PHW_STREAM_REQUEST_BLOCK,
                        IN PKSPIN_LOCK,
                        IN PLIST_ENTRY);                           
BOOL STREAMAPI QueueEmpty(
                        IN PKSPIN_LOCK,
                        IN PLIST_ENTRY);                         


#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__CODMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\codvideo.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#include "strmini.h"
#include "ksmedia.h"
#include "kskludge.h"
#include "codmain.h"
#include "bt829.h"
#include "bpc_vbi.h"
#include "coddebug.h"
#include "ntstatus.h"



//==========================================================================
// DEBUG variables
//==========================================================================

#ifdef _DEBUG
USHORT	NABscanDiscon = 0;
USHORT  NABhushZero   = 0;
#endif //_DEBUG


//==========================================================================
// Shared routines for processing streams
//==========================================================================

/*
** VBIdiscontinuity()
**
**	Handle a KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag.
**
** Arguments:
**
**	pInStrmEx       - The input Stream Extension
**	pInStreamHeader - The input SRB stream header 
**
** Returns: nothing
**
** Side-effects:
**	Sends zero-length SRBs on all output pins which have SRBs available.
*/
void
VBIdiscontinuity(PSTREAMEX pInStrmEx, PKSSTREAM_HEADER pInStreamHeader)
{
    PHW_DEVICE_EXTENSION              pHwDevExt;
    PKS_VBI_FRAME_INFO                pInVBIFrameInfo;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;

    DtENTER("VBIdiscontinuity");

    CASSERT(pInStrmEx);  // make sure we have a stream extension
    pHwDevExt = pInStrmEx->pHwDevExt;
    CASSERT(pHwDevExt);  // make sure we have a device extension
    pInVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pInStreamHeader+1);

    pStats = &pHwDevExt->Stats;
    pPinStats = &pInStrmEx->PinStats;

    ++pStats->Common.InputDiscontinuities;
    ++pPinStats->Common.Discontinuities;

    //
    // Test for dropped fields
    //
	if (pInStrmEx->LastPictureNumber)
	{
		LONGLONG	Dropped;
	   
		Dropped =
		   	pInVBIFrameInfo->PictureNumber - pInStrmEx->LastPictureNumber - 1;

		if (Dropped) {
			// One hour worth of video fields
			if (0 < Dropped && Dropped < 60*60*60)
				pStats->Common.InputSRBsMissing += (DWORD)Dropped;
			else {
				// Some improbable number of fields got dropped, so just
				//  increment InputSRBsMissing to show _something_ got
				//  dropped.
				++pStats->Common.InputSRBsMissing;
			}
		}
	}

    //
    // Output empty SRBs with KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY set
    //
    {
		PBPC_VBI_STORAGE                         storage;
		ULONG                                    i, j, iCnt, iMax;

		storage = &pHwDevExt->VBIstorage;

		// Loop through all pending outbound requests
		iMax = pHwDevExt->ActualInstances[STREAM_Decode];
		for (i = 0, iCnt = 0; i < MAX_PIN_INSTANCES && iCnt < iMax; ++i)
		{
			PSTREAMEX                   pOutStrmEx;
			PHW_STREAM_REQUEST_BLOCK    pOutSrb;

			pOutStrmEx = pHwDevExt->pStrmEx[STREAM_Decode][i];
			if (NULL == pOutStrmEx)
				continue;

			++iCnt;

			// Even if we can't TELL them (ie, no SRB), keep track
			pPinStats = &pOutStrmEx->PinStats;
			++pPinStats->Common.Discontinuities;

			// pOutStrmEx->ScanlinesDiscovered needs to be OR'ed with:
			// (the request) AND (what was found)
			for (j = 0;
				 j < ENTRIES(pInStrmEx->ScanlinesRequested.DwordBitArray);
				 ++j)
			{
				pOutStrmEx->ScanlinesDiscovered.DwordBitArray[j] |= 
					pInStrmEx->ScanlinesDiscovered.DwordBitArray[j]
					& pOutStrmEx->ScanlinesRequested.DwordBitArray[j];
			}

			// pOutStrmEx->SubstreamsDiscovered needs to be OR'ed with:
			// (the request) AND (what was found)
			for (j = 0;
				 j < ENTRIES(pInStrmEx->SubstreamsRequested.SubstreamMask);
				 ++j)
			{
				pOutStrmEx->SubstreamsDiscovered.SubstreamMask[j] |= 
					pInStrmEx->SubstreamsDiscovered.SubstreamMask[j]
					& pOutStrmEx->SubstreamsRequested.SubstreamMask[j];
			}

			// Process ALL streams with available SRBs
		    if (QueueRemove(&pOutSrb,
				   &pOutStrmEx->StreamDataSpinLock,
				   &pOutStrmEx->StreamDataQueue))
			{
				PKSSTREAM_HEADER    pOutStreamHeader;
				PKS_VBI_FRAME_INFO  pOutVBIFrameInfo;
				PUCHAR              pOutData;

				pOutStreamHeader = pOutSrb->CommandData.DataBufferArray;
				pOutVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pOutStreamHeader+1);
				pOutData =  (PUCHAR)pOutStreamHeader->Data;

				// Copy data that was decoded and requested
				pOutStreamHeader->Size = sizeof (KSSTREAM_HEADER);
				pOutStreamHeader->DataUsed = 0;
				pOutStreamHeader->OptionsFlags |=
					KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;

				// Complete the output SRB so we can get another one.
				++pStats->Common.OutputSRBsProcessed;
				++pPinStats->Common.SRBsProcessed;
			    StreamClassStreamNotification(
						StreamRequestComplete,
						pOutSrb->StreamObject,
						pOutSrb);
			}
			else {
				++pStats->Common.OutputSRBsMissing;
				++pPinStats->Common.SRBsMissing;
				CDebugPrint(DebugLevelWarning,
				  (CODECNAME ": VBIdiscontinuity: output pin %d starving\n",i));
			}
		}
    }

    DtRETURN;
}

/*
** VBI_TVtunerChange()
**
**	Process a TVTUNER_CHANGE event.
**
** Arguments:
**
**	pInStrmEx       - Pointer to current Input StrmEx
**	pInVBIFrameInfo - Pointer to VBIInfoHeader for incoming stream
**
** Returns: nothing
**
** Side-effects:
**	May zero ScanlinesDiscovered and SubstreamsDiscovered
**	in InStrmEx and HwDevExt.
*/
void
VBI_TVtunerChange(PSTREAMEX pInStrmEx, PKS_VBI_FRAME_INFO pInVBIFrameInfo)
{
    PKS_TVTUNER_CHANGE_INFO           pChangeInfo;
    PHW_DEVICE_EXTENSION              pHwDevExt;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;

    DtENTER("VBI_TVtunerChange");

    pChangeInfo = &pInVBIFrameInfo->TvTunerChangeInfo;
    pHwDevExt = pInStrmEx->pHwDevExt;
    CASSERT(pHwDevExt);  // make sure we have a device extension
    CASSERT(pInStrmEx);  // make sure we have a stream extension

    pStats = &pHwDevExt->Stats;
    pPinStats = &pInStrmEx->PinStats;

    CDebugPrint(DebugLevelVerbose, (CODECNAME ": TVTuner Change %x\n",
		pChangeInfo->dwFlags ));

    if (pChangeInfo->dwFlags & KS_TVTUNER_CHANGE_BEGIN_TUNE) {
		RtlZeroMemory(&pInStrmEx->ScanlinesDiscovered,
				  sizeof (pInStrmEx->ScanlinesDiscovered));
		RtlZeroMemory(&pInStrmEx->SubstreamsDiscovered,
				  sizeof (pInStrmEx->SubstreamsDiscovered));
		RtlZeroMemory(&pHwDevExt->ScanlinesDiscovered,
				  sizeof (pHwDevExt->ScanlinesDiscovered));
		RtlZeroMemory(&pHwDevExt->SubstreamsDiscovered,
				  sizeof (pHwDevExt->SubstreamsDiscovered));
		pHwDevExt->fTunerChange = TRUE;
    }
    else if (pChangeInfo->dwFlags & KS_TVTUNER_CHANGE_END_TUNE) {
		pHwDevExt->fTunerChange = FALSE;
        ++pStats->Common.TvTunerChanges;
        BPCsourceChangeNotify(pHwDevExt);
    }
    else {
		CDebugPrint(DebugLevelWarning,
		    (CODECNAME ": TvTuner Change; not BEGIN, not END?\n"));
    }

    DtRETURN;
}

/*
** VBInewHeader()
**
**	Check an incoming VBIInfoHeader for validity && copy the new one
**
** Arguments:
**
**	pVBIFrameInfo - Pointer to current StrmEx VBIInfoHeader
**	pInVBIFrameInfo - Pointer to VBIInfoHeader for incoming stream
**
** Returns: nothing
**
** Side-effects:
**	Updates *pVBIInfoHeader with new VBIInfoHeader.
*/
void
VBInewHeader(PSTREAMEX pInStrmEx, PKS_VBI_FRAME_INFO pInVBIFrameInfo)
{
    PKS_VBIINFOHEADER	              pVBIInfoHeader;
    PHW_DEVICE_EXTENSION              pHwDevExt;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;
    DWORD                             oldHZ, newHZ;

    DtENTER("VBInewHeader");

    CASSERT(pInStrmEx);  // make sure we have a stream extension
    pVBIInfoHeader = &pInStrmEx->CurrentVBIInfoHeader;
    pHwDevExt = pInStrmEx->pHwDevExt;
    CASSERT(pHwDevExt);  // make sure we have a device extension

    pStats = &pHwDevExt->Stats;
    pPinStats = &pInStrmEx->PinStats;

    newHZ = pInVBIFrameInfo->VBIInfoHeader.SamplingFrequency;
    oldHZ = pVBIInfoHeader->SamplingFrequency;
    if (oldHZ != newHZ)
        BPCnewSamplingFrequency(pInStrmEx, newHZ);

    if (pInVBIFrameInfo->VBIInfoHeader.StartLine != 0
		&& pInVBIFrameInfo->VBIInfoHeader.StartLine != 0)
    {
		RtlCopyMemory(pVBIInfoHeader,
				  &pInVBIFrameInfo->VBIInfoHeader,
				  sizeof (KS_VBIINFOHEADER));
    }

    ++pStats->Common.VBIHeaderChanges;

    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->StartLine				%lu\n",
	    pVBIInfoHeader->StartLine ));
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->EndLine				%lu\n",
	    pVBIInfoHeader->EndLine ));       	
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->SamplingFrequency		%lu\n",
	    pVBIInfoHeader->SamplingFrequency ));
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->MinLineStartTime		%lu\n",
	    pVBIInfoHeader->MinLineStartTime ));
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->MaxLineStartTime		%lu\n",
	    pVBIInfoHeader->MaxLineStartTime ));
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->ActualLineStartTime	%lu\n",
	    pVBIInfoHeader->ActualLineStartTime ));       
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->ActualLineEndTime		%lu\n",
	    pVBIInfoHeader->ActualLineEndTime ));       
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->VideoStandard			%lu\n",
	    pVBIInfoHeader->VideoStandard ));       
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->SamplesPerLine		%lu\n",
	    pVBIInfoHeader->SamplesPerLine ));
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->StrideInBytes			%lu\n",
	    pVBIInfoHeader->StrideInBytes ));
    CDebugPrint(DebugLevelVerbose, ( CODECNAME 
	    ": VBIInfoHeader->BufferSize			%lu\n",
	    pVBIInfoHeader->BufferSize ));

    DtRETURN;
}


/*
** VBIDecodeFinish()
**
**	Complete the input SRB and send output to anyone interested
**
** Arguments:
**
**	pStrmEx - Pointer to Stream Extension for the incoming SRB.
**
** Returns: nothing
**
** Side-effects:
**	Completes pending SRB on input pin.
*/

void
VBIDecodeFinish(PHW_STREAM_REQUEST_BLOCK pInSrb)
{
    PSTREAMEX              pInStrmEx = pInSrb->StreamObject->HwStreamExtension;
    PHW_DEVICE_EXTENSION   pHwDevExt = pInSrb->HwDeviceExtension;

    // Complete the input SRB (we're done decoding)
    StreamClassStreamNotification(
			StreamRequestComplete,
			pInSrb->StreamObject,
		    pInSrb);

    // Output NABTS lines to anyone interested
    VBIOutputNABTS(pHwDevExt, pInStrmEx);

    // Output FEC'd NABTS data to anyone interested
    VBIOutputNABTSFEC(pHwDevExt, pInStrmEx);
}


//==========================================================================
// Routines for processing VBI streams
//==========================================================================

/*
** VBIDecode()
**
**	Decode the VBI stream
**
** Arguments:
**
**	pHwDevExt - Pointer to the main Hardware Device Extension
**	pStrmEx - Pointer to Stream Extension for the incoming SRB.
**
** Returns: nothing
**
** Side-effects:
**	Completes pending SRBs on input and output pins.
*/

#ifdef HW_INPUT
_VBIjustDecode(
	PHW_DEVICE_EXTENSION      pHwDevExt,
	PSTREAMEX                 pInStrmEx,
	PHW_STREAM_REQUEST_BLOCK  pInSrb)
{
    CASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	ExAcquireFastMutex(&pHwDevExt->LastPictureMutex);
	// Whoever gets there first (VBI pin vs. HW pin) supplies NABTS data
	if (pInStrmEx->LastPictureNumber > pHwDevExt->LastPictureNumber)
    {
		pHwDevExt->LastPictureNumber = pInStrmEx->LastPictureNumber;
		ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);

		// Call DSP/FEC routines
		BPCdecodeVBI(pInSrb, pInStrmEx);

		// Done with input SRB
		VBIDecodeFinish(pInSrb);
    }
	else {
		ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);

		// Just complete the input SRB
		StreamClassStreamNotification(
				StreamRequestComplete,
				pInSrb->StreamObject,
				pInSrb);
	}
}
#endif /*HW_INPUT*/

void
VBIDecode(
	PHW_DEVICE_EXTENSION      pHwDevExt,
	PSTREAMEX                 pInStrmEx,
	PHW_STREAM_REQUEST_BLOCK  pInSrb)
{
    PKSSTREAM_HEADER       pInStreamHeader;
    PKS_VBI_FRAME_INFO     pInVBIFrameInfo;
    PUCHAR                 pInData;
    ULONG                  i, j, iCnt, iMax;
    PVBICODECFILTERING_STATISTICS_NABTS pStats;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats;

    DtENTER("VBIDecode");

    CASSERT(KeGetCurrentIrql() <= APC_LEVEL);
    CASSERT(pInSrb);
    CASSERT(pHwDevExt);
    CASSERT(pInStrmEx);

    pInStreamHeader = pInSrb->CommandData.DataBufferArray;
    pInVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pInStreamHeader+1);
    pInData = (PUCHAR)pInStreamHeader->Data;
    pStats = &pHwDevExt->Stats;
    pPinStats = &pInStrmEx->PinStats;

    //
    // Check for a new VBIINFOHEADER
    //
    if (pInVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_VBIINFOHEADER_CHANGE)
		VBInewHeader(pInStrmEx, pInVBIFrameInfo);

    //
    // Check for a channel change
    //
    if (pInVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_TVTUNER_CHANGE)
		VBI_TVtunerChange(pInStrmEx, pInVBIFrameInfo);

    //
    // Check for Discontinuity
    //
    if (pInStreamHeader->OptionsFlags
		& KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY)
    {
		_DQprintf(2,("!"));
		VBIdiscontinuity(pInStrmEx, pInStreamHeader);
    }
#ifdef DEBUG
	if (NABscanDiscon) 
	{
		static KSTIME  LastTime = { 0, 1, 1};

		if (pInStrmEx->LastPictureNumber + 1
				!= pInVBIFrameInfo->PictureNumber)
		{
			_DQprintf(1,("{%u-%u/dT0x%x}",
						(unsigned long)pInVBIFrameInfo->PictureNumber,
					 	(unsigned long)pInStrmEx->LastPictureNumber,
						(long)(pInStreamHeader->PresentationTime.Time
								- LastTime.Time) ));
		}
		LastTime = pInStreamHeader->PresentationTime;
	}
#endif //DEBUG
    pInStrmEx->LastPictureNumber = pInVBIFrameInfo->PictureNumber;

    //
    // On with the show
    //
    // CASSERT((((ULONG)pInData) & 0xF0000000) != 0); // Hack to ensure PIO is TRUE

	if (TRUE == pHwDevExt->fTunerChange                  /* Tune in progress */
		|| pInStreamHeader->DataUsed == 0)               /* SRB is empty */
	{

#ifdef DEBUG
		if (0 == pInStreamHeader->DataUsed) {
			CDebugPrint(DebugLevelWarning,
						(CODECNAME ": Zero-length VBI srb WRITE; ignoring\n"));
		}
#endif
		// Complete the input SRB
		StreamClassStreamNotification(
				StreamRequestComplete,
				pInSrb->StreamObject,
				pInSrb);
		DtRETURN;
    }

    // Clear the current scanline & substream request masks
    RtlZeroMemory( &pInStrmEx->ScanlinesRequested, sizeof(pInStrmEx->ScanlinesRequested) );
    RtlZeroMemory( &pInStrmEx->SubstreamsRequested, sizeof(pInStrmEx->SubstreamsRequested) );

    // OR-in the lines/groups IP dvr wants
    BPCaddIPrequested(pHwDevExt, pInStrmEx);

    // Calculate the current request from union of the output pins w/pending SRBs
    iMax = pHwDevExt->ActualInstances[STREAM_Decode];
    for (i = 0, iCnt = 0; i < MAX_PIN_INSTANCES && iCnt < iMax; ++i)
    {
        PSTREAMEX                   pOutStrmEx;

        pOutStrmEx = pHwDevExt->pStrmEx[STREAM_Decode][i];
		if (NULL == pOutStrmEx)
			continue;

		++iCnt;

        // Save the updated frame info for whenever we need to send out an SRB.
        if ( pInVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_VBIINFOHEADER_CHANGE )
            pInStrmEx->FrameInfo.VBIInfoHeader = pInVBIFrameInfo->VBIInfoHeader;
            
        // Save the discontinuity flag for whenever we need to send out an SRB.
        if ( pInVBIFrameInfo->dwFrameFlags & KS_VBI_FLAG_TVTUNER_CHANGE )
            pOutStrmEx->fDiscontinuity = TRUE;

        // Is there a pending output SRB?
		if (!QueueEmpty(
			   &pOutStrmEx->StreamDataSpinLock,
			   &pOutStrmEx->StreamDataQueue))
        {
            // Create the union of all the requested scanlines
            for( j = 0; j < ENTRIES(pInStrmEx->ScanlinesRequested.DwordBitArray); j++ )
            {
                pInStrmEx->ScanlinesRequested.DwordBitArray[j] |= 
                    pOutStrmEx->ScanlinesRequested.DwordBitArray[j];
            }

            // Create the union of all the requested substreams
            for( j = 0; j < ENTRIES(pInStrmEx->SubstreamsRequested.SubstreamMask); j++ )
            {
                pInStrmEx->SubstreamsRequested.SubstreamMask[j] |= 
                    pOutStrmEx->SubstreamsRequested.SubstreamMask[j];
            }
        }
    }

    // pInStrmEx->ScanlinesRequested contains ALL currently req. scanlines
    // pInStrmEx->SubstreamsRequested contains ALL currently req. substreams

    // Loop through all pending outbound VBI requests and fill each irp
    //  with VBI samples
    iMax = pHwDevExt->ActualInstances[STREAM_Decode];
    for (i = 0, iCnt = 0; i < MAX_PIN_INSTANCES && iCnt < iMax; ++i)
    {
        PSTREAMEX                   pOutStrmEx;
        PHW_STREAM_REQUEST_BLOCK    pOutSrb;

        pOutStrmEx = pHwDevExt->pStrmEx[STREAM_Decode][i];
 
		if (NULL == pOutStrmEx)
			continue;

        ASSERT(pOutStrmEx);
        ASSERT(pOutStrmEx->OpenedFormat.FormatSize);
        ASSERT(pOutStrmEx->OpenedFormat.Specifier.Data1);
		++iCnt;

		if (!CodecCompareGUIDsAndFormatSize((PKSDATARANGE)&StreamFormatVBI, &pOutStrmEx->OpenedFormat, FALSE))
		{
			// We only do FormatVBI -- different routines handle the others
			continue;
		}

		// pOutStrmEx->ScanlinesDiscovered needs to be OR'ed with (the request AND what was found)
		for( j = 0; j < ENTRIES(pInStrmEx->ScanlinesRequested.DwordBitArray); j++ )
		{
			pOutStrmEx->ScanlinesDiscovered.DwordBitArray[j] |= 
				pInStrmEx->ScanlinesDiscovered.DwordBitArray[j] &
				pOutStrmEx->ScanlinesRequested.DwordBitArray[j];
		}

		// pOutStrmEx->SubstreamsDiscovered needs to be OR'ed with (the request AND what was found)
		for( j = 0; j < ENTRIES(pInStrmEx->SubstreamsRequested.SubstreamMask); j++ )
		{
			pOutStrmEx->SubstreamsDiscovered.SubstreamMask[j] |= 
				pInStrmEx->SubstreamsDiscovered.SubstreamMask[j] &
				pOutStrmEx->SubstreamsRequested.SubstreamMask[j];
		}

        // Only process the output streams which have an SRB ready.
		if (QueueRemove(&pOutSrb,
			   &pOutStrmEx->StreamDataSpinLock,
			   &pOutStrmEx->StreamDataQueue))
        {
            PKSSTREAM_HEADER    pOutStreamHeader = pOutSrb->CommandData.DataBufferArray;
            PKS_VBI_FRAME_INFO  pOutVBIFrameInfo = (PKS_VBI_FRAME_INFO)(pOutStreamHeader+1);
            PUCHAR              pOutData =  (PUCHAR)pOutStreamHeader->Data;


            // Setup the basic outbound VBI_FRAME_INFO, needs further modification
            *pOutVBIFrameInfo = *pInVBIFrameInfo;

            if (CodecCompareGUIDsAndFormatSize(&pInStrmEx->OpenedFormat, &pOutStrmEx->OpenedFormat, FALSE))
            {
                // Just copy the data into the output buffer if the formats match.

				CASSERT(pOutStreamHeader->FrameExtent >= pInStreamHeader->FrameExtent);
                RtlCopyMemory((PVOID)pOutData, (PVOID)pInData, pInStreamHeader->DataUsed);
                pOutStreamHeader->DataUsed = pInStreamHeader->DataUsed;
				CASSERT(pOutStreamHeader->DataUsed <= pOutStreamHeader->FrameExtent);
            }
			else {
                pOutStreamHeader->DataUsed = 0;
				CDebugPrint(DebugLevelTrace,
						(CODECNAME ": Unknown srb format in output loop!\n"));
				CDEBUG_BREAK();
			}

            // Complete the output SRB so we get another one.
			++pStats->Common.OutputSRBsProcessed;
			++pPinStats->Common.SRBsProcessed;
			pStats->Common.BytesOutput += pOutStreamHeader->DataUsed;
			pPinStats->Common.BytesOutput += pOutStreamHeader->DataUsed;
			StreamClassStreamNotification(
					StreamRequestComplete,
					pOutSrb->StreamObject,
					pOutSrb);
        }
		else {
			++pStats->Common.OutputSRBsMissing;
			++pPinStats->Common.SRBsMissing;
			CDebugPrint(DebugLevelWarning,
					(CODECNAME ": VBI output pin %d starving\n", i));
		}
    }

    // Decode the union of all the pending decode requests into a local buffer.

#ifdef HW_INPUT
	ExAcquireFastMutex(&pHwDevExt->LastPictureMutex);
	// Whoever gets there first (VBI pin vs. HW pin) supplies NABTS data
	if (0 == pHwDevExt->ActualInstances[STREAM_NABTS]
        || pInStrmEx->LastPictureNumber > pHwDevExt->LastPictureNumber)
    {
		// If the stream is not open, just process the SRB
		if (0 == pHwDevExt->ActualInstances[STREAM_NABTS])
		{
#endif /*HW_INPUT*/
			pHwDevExt->LastPictureNumber = pInStrmEx->LastPictureNumber;
#ifdef HW_INPUT
			ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);
#endif /*HW_INPUT*/

			// Call DSP/FEC routines
			BPCdecodeVBI(pInSrb, pInStrmEx);

			// Done with input SRB
			VBIDecodeFinish(pInSrb);
#ifdef HW_INPUT
		}
		else {
            KIRQL Irql;

			// We're going to give the HW pin a chance to catch up
			ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);

			KeAcquireSpinLock(&pInStrmEx->VBIOnHoldSpinLock, &Irql);
			DASSERT(NULL == pInStrmEx->pVBISrbOnHold);
			pInStrmEx->pVBISrbOnHold = pInSrb;
			KeReleaseSpinLock(&pInStrmEx->VBIOnHoldSpinLock, Irql);
		}
    }
	else {
		ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);

		// Just complete the input SRB
		StreamClassStreamNotification(
				StreamRequestComplete,
				pInSrb->StreamObject,
				pInSrb);
	}
#endif /*HW_INPUT*/

    DtRETURN;
}


#ifdef HW_INPUT
//==========================================================================
// Routines for processing NABTS streams
//==========================================================================


/*
** VBIhwDecode()
**
**	Copy in the HW-decoded NABTS stream
**
** Arguments:
**
**	pHwDevExt - Pointer to the main Hardware Device Extension
**	pStrmEx - Pointer to Stream Extension for the incoming SRB.
**
** Returns: nothing
**
** Side-effects:
**	Completes pending SRBs on input and output pins.
*/

void
VBIhwDecode(
	PHW_DEVICE_EXTENSION      pHwDevExt,
	PSTREAMEX                 pInStrmEx,
	PHW_STREAM_REQUEST_BLOCK  pInSrb)
{
    PKSSTREAM_HEADER       pInStreamHeader;
    PNABTS_BUFFER          pInData;
    ULONG                  i, j, iCnt, iMax;
    PVBICODECFILTERING_STATISTICS_NABTS pStats;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats;

    DtENTER("VBIhwDecode");

    CASSERT(KeGetCurrentIrql() <= APC_LEVEL);
    CASSERT(pInSrb);
    CASSERT(pHwDevExt);
    CASSERT(pInStrmEx);

    pInStreamHeader = pInSrb->CommandData.DataBufferArray;
    pInData = (PNABTS_BUFFER)pInStreamHeader->Data;
    pStats = &pHwDevExt->Stats;
    pPinStats = &pInStrmEx->PinStats;

    pInStrmEx->LastPictureNumber = pInData->PictureNumber;

    //
    // On with the show
    //
//    CASSERT((((ULONG)pInData) & 0xF0000000) != 0); // Hack to ensure PIO is TRUE

	if (TRUE == pHwDevExt->fTunerChange || pInStreamHeader->DataUsed == 0) {
		if (0 == pInStreamHeader->DataUsed) {
			CDebugPrint(DebugLevelWarning,
						(CODECNAME ": Zero-length srb WRITE; ignoring\n"));
		}
		// Complete the input SRB
		StreamClassStreamNotification(
				StreamRequestComplete,
				pInSrb->StreamObject,
				pInSrb);
		DtRETURN;
    }

    // Clear the current scanline & substream request masks
    RtlZeroMemory( &pInStrmEx->ScanlinesRequested, sizeof(pInStrmEx->ScanlinesRequested) );
    RtlZeroMemory( &pInStrmEx->SubstreamsRequested, sizeof(pInStrmEx->SubstreamsRequested) );

    // OR-in the lines/groups IP dvr wants
    BPCaddIPrequested(pHwDevExt, pInStrmEx);

    // Calculate the current request from union of the output pins w/pending SRBs
    iMax = pHwDevExt->ActualInstances[STREAM_Decode];
    for (i = 0, iCnt = 0; i < MAX_PIN_INSTANCES && iCnt < iMax; ++i)
    {
        PSTREAMEX                   pOutStrmEx;

        pOutStrmEx = pHwDevExt->pStrmEx[STREAM_Decode][i];
		if (NULL == pOutStrmEx)
			continue;

		++iCnt;

        // Is there a pending output SRB?
		if (!QueueEmpty(
			   &pOutStrmEx->StreamDataSpinLock,
			   &pOutStrmEx->StreamDataQueue))
        {
            // Create the union of all the requested scanlines
            for( j = 0; j < ENTRIES(pInStrmEx->ScanlinesRequested.DwordBitArray); j++ )
            {
                pInStrmEx->ScanlinesRequested.DwordBitArray[j] |= 
                    pOutStrmEx->ScanlinesRequested.DwordBitArray[j];
            }

            // Create the union of all the requested substreams
            for( j = 0; j < ENTRIES(pInStrmEx->SubstreamsRequested.SubstreamMask); j++ )
            {
                pInStrmEx->SubstreamsRequested.SubstreamMask[j] |= 
                    pOutStrmEx->SubstreamsRequested.SubstreamMask[j];
            }
        }
    }

    // Decode the union of all the pending decode requests into a local decode buffer.

    // pInStrmEx->ScanlinesRequested contains ALL currently requested scanlines
    // pInStrmEx->SubstreamsRequested contains ALL currently requested substreams

	ExAcquireFastMutex(&pHwDevExt->LastPictureMutex);
	if (pInStrmEx->LastPictureNumber > pHwDevExt->LastPictureNumber)
    {
		pHwDevExt->LastPictureNumber = pInStrmEx->LastPictureNumber;
		ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);

		// Call FEC routines
		BPCcopyVBI(pInSrb, pInStrmEx);

		// Done with input SRB
		VBIDecodeFinish(pInSrb);
	}
	else {
		ExReleaseFastMutex(&pHwDevExt->LastPictureMutex);

		// Just complete the input SRB
		StreamClassStreamNotification(
				StreamRequestComplete,
				pInSrb->StreamObject,
				pInSrb);
	}

    DtRETURN;
}
#endif /*HW_INPUT*/


//==========================================================================
// Routines for processing output streams
//==========================================================================

void
VBIOutputNABTS(PHW_DEVICE_EXTENSION pHwDevExt, PSTREAMEX pInStrmEx)
{

    PBPC_VBI_STORAGE                  storage;
    ULONG                             i, j, iCnt, iMax;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = &pHwDevExt->Stats;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL; // Search later

    DtENTER("VBIOutputNABTS");

    CASSERT(pHwDevExt);
    CASSERT(pInStrmEx);

    storage = &pHwDevExt->VBIstorage;

    // Loop through all pending outbound requests, fill each irp with the
	//  requested data, then complete the IO
    iMax = pHwDevExt->ActualInstances[STREAM_Decode];
    for (i = 0, iCnt = 0; i < MAX_PIN_INSTANCES && iCnt < iMax; ++i)
    {
        PSTREAMEX                   pOutStrmEx;
        PHW_STREAM_REQUEST_BLOCK    pOutSrb;

        pOutStrmEx = pHwDevExt->pStrmEx[STREAM_Decode][i];
        if (NULL == pOutStrmEx)
            continue;
        CASSERT(pOutStrmEx->OpenedFormat.FormatSize);
        CASSERT(pOutStrmEx->OpenedFormat.Specifier.Data1);
		pPinStats = &pOutStrmEx->PinStats;

		++iCnt;

        // Only process NABTS output streams
        if (!CodecCompareGUIDsAndFormatSize(&StreamFormatNABTS,
		    			      &pOutStrmEx->OpenedFormat, FALSE))
        {
			continue;
		}

		// pOutStrmEx->ScanlinesDiscovered needs to be OR'ed with:
		// (the request) AND (what was found)
		for (j = 0;
			 j < ENTRIES(pInStrmEx->ScanlinesRequested.DwordBitArray);
			 ++j)
		{
			pOutStrmEx->ScanlinesDiscovered.DwordBitArray[j] |= 
				pInStrmEx->ScanlinesDiscovered.DwordBitArray[j]
				& pOutStrmEx->ScanlinesRequested.DwordBitArray[j];
		}

		// pOutStrmEx->SubstreamsDiscovered needs to be OR'ed with:
		// (the request) AND (what was found)
		for (j = 0;
			 j < ENTRIES(pInStrmEx->SubstreamsRequested.SubstreamMask);
			 ++j)
		{
			pOutStrmEx->SubstreamsDiscovered.SubstreamMask[j] |= 
				pInStrmEx->SubstreamsDiscovered.SubstreamMask[j]
				& pOutStrmEx->SubstreamsRequested.SubstreamMask[j];
		}

		if (QueueRemove(&pOutSrb,
			   &pOutStrmEx->StreamDataSpinLock,
			   &pOutStrmEx->StreamDataQueue))
        {
            PKSSTREAM_HEADER    pOutStreamHeader;
            PUCHAR              pOutData;

            pOutStreamHeader = pOutSrb->CommandData.DataBufferArray;
            pOutData =  (PUCHAR)pOutStreamHeader->Data;

			// Copy data that was decoded and requested
			CASSERT(pOutStreamHeader->FrameExtent >= sizeof (NABTS_BUFFER));
			pOutStreamHeader->DataUsed = 
				BPCoutputNABTSlines(pHwDevExt, pOutStrmEx, (PNABTS_BUFFER)pOutData);
			CASSERT(pOutStreamHeader->DataUsed <= pOutStreamHeader->FrameExtent);

            // Complete the output SRB so we can get another one.
			++pStats->Common.OutputSRBsProcessed;
			++pPinStats->Common.SRBsProcessed;
			pStats->Common.BytesOutput += pOutStreamHeader->DataUsed;
			pPinStats->Common.BytesOutput += pOutStreamHeader->DataUsed;
			StreamClassStreamNotification(
					StreamRequestComplete,
					pOutSrb->StreamObject,
					pOutSrb);
        }
		else {
			++pStats->Common.OutputSRBsMissing;
			++pPinStats->Common.SRBsMissing;
			CDebugPrint(DebugLevelWarning,
		        (CODECNAME ": NABTS output pin %d starving\n", i));
		}
    }

    DtRETURN;
}

void
VBIOutputNABTSFEC(PHW_DEVICE_EXTENSION pHwDevExt, PSTREAMEX pInStrmEx)
{
    PBPC_VBI_STORAGE                  storage;
    PNABTSFEC_ITEM                    pNab;
    KIRQL                             Irql;
    ULONG                             i, j, iCnt, iMax;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = &pHwDevExt->Stats;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL; // Search later
#ifdef DEBUG
    int                               bundle_count = 0;
#endif /*DEBUG*/

    DtENTER("VBIOutputNABTSFEC");

    CASSERT(pHwDevExt);
    CASSERT(pInStrmEx);

    storage = &pHwDevExt->VBIstorage;

	// Loop through all NABTSFEC pins and update their discovered bitmaps
	iMax = pHwDevExt->ActualInstances[STREAM_Decode];
	for (i = 0, iCnt = 0; i < MAX_PIN_INSTANCES && iCnt < iMax; ++i)
	{
		PSTREAMEX                   pOutStrmEx;

		pOutStrmEx = pHwDevExt->pStrmEx[STREAM_Decode][i];
		if (NULL == pOutStrmEx)
			continue;

	        CASSERT(pOutStrmEx->OpenedFormat.FormatSize);
	        CASSERT(pOutStrmEx->OpenedFormat.Specifier.Data1);

		++iCnt;

		// Only process the NABTSFEC output streams
		if (CodecCompareGUIDsAndFormatSize(&StreamFormatNABTSFEC,
						  &pOutStrmEx->OpenedFormat, FALSE))
		{
			// pOutStrmEx->ScanlinesDiscovered needs to be OR'ed with:
			// (what was requested) AND (what was found)
			for (j = 0;
				 j < ENTRIES(pInStrmEx->ScanlinesDiscovered.DwordBitArray);
				 ++j)
			{
				pOutStrmEx->ScanlinesDiscovered.DwordBitArray[j] |= 
					pInStrmEx->ScanlinesDiscovered.DwordBitArray[j]
					& pOutStrmEx->ScanlinesRequested.DwordBitArray[j];
			}

			// pOutStrmEx->SubstreamsDiscovered needs to be OR'ed with:
			// (what was requested) AND (what was found)
			for (j = 0;
				 j < ENTRIES(pInStrmEx->SubstreamsDiscovered.SubstreamMask);
				 ++j)
			{
				pOutStrmEx->SubstreamsDiscovered.SubstreamMask[j] |= 
					pInStrmEx->SubstreamsDiscovered.SubstreamMask[j]
					& pOutStrmEx->SubstreamsRequested.SubstreamMask[j];
			}
		}
	}

    KeAcquireSpinLock( &storage->q_SpinLock, &Irql );
    // For each bundle not yet output, copy to all interested streams
    while (storage->q_front) {
		// Pull this bundle off the queue
		pNab = storage->q_front;
		storage->q_front = pNab->prev;
		storage->q_length -= 1;
		pNab->prev = NULL;
		CASSERT(NULL == pNab->next);
		if (NULL == storage->q_front) {
			storage->q_rear = NULL;
			CASSERT(storage->q_length == 0);
		}
		else
			storage->q_front->next = NULL;
		KeReleaseSpinLock( &storage->q_SpinLock, Irql );
#ifdef DEBUG
		bundle_count += 1;
#endif /*DEBUG*/

		// Loop through all pending outbound requests and fill each irp with
		//  the requested data, then complete the I/O
		iMax = pHwDevExt->ActualInstances[STREAM_Decode];
		for (i = 0, iCnt = 0; i < MAX_PIN_INSTANCES && iCnt < iMax; ++i)
		{
			PSTREAMEX                   pOutStrmEx;
			PHW_STREAM_REQUEST_BLOCK    pOutSrb;

			pOutStrmEx = pHwDevExt->pStrmEx[STREAM_Decode][i];
			if (NULL == pOutStrmEx)
				continue;
			pPinStats = &pOutStrmEx->PinStats;

			++iCnt;

			// Only process the NABTSFEC output streams
			//  which have requested the groupID in question.
			if (!CodecCompareGUIDsAndFormatSize(&StreamFormatNABTSFEC,
							  &pOutStrmEx->OpenedFormat,
							  FALSE)
				|| !TESTBIT(pOutStrmEx->SubstreamsRequested.SubstreamMask,
					   pNab->bundle.groupID))
			{
				continue;
			}

			if (QueueRemove(&pOutSrb,
				   &pOutStrmEx->StreamDataSpinLock,
				   &pOutStrmEx->StreamDataQueue))
			{
				PKSSTREAM_HEADER    pOutStreamHeader;
				PUCHAR              pOutData;

				pOutStreamHeader = pOutSrb->CommandData.DataBufferArray;
				pOutData =  (PUCHAR)pOutStreamHeader->Data;

				// Copy data here that was decoded and requested
				pOutStreamHeader->Size = sizeof (KSSTREAM_HEADER);

				// pOutData is the srb output location.  Copy the bundle.
				CASSERT(pOutStreamHeader->FrameExtent >= sizeof (NABTSFEC_BUFFER));
				pOutStreamHeader->DataUsed = NF_BUFFER_SIZE(&pNab->bundle);
				CASSERT(pOutStreamHeader->DataUsed <= pOutStreamHeader->FrameExtent);
				RtlCopyMemory((PVOID)pOutData,
						  (PVOID)&pNab->bundle,
						  pOutStreamHeader->DataUsed);

				// Complete the output SRB so we can get another one.
				++pStats->Common.OutputSRBsProcessed;
				++pPinStats->Common.SRBsProcessed;
				BPCcomputeAverage(&pPinStats->Common.LineConfidenceAvg,
								pNab->confidence);
				pStats->Common.BytesOutput += pOutStreamHeader->DataUsed;
				pPinStats->Common.BytesOutput += pOutStreamHeader->DataUsed;
				StreamClassStreamNotification(
						StreamRequestComplete,
						pOutSrb->StreamObject,
						pOutSrb);
			}
			else {
				++pStats->Common.OutputSRBsMissing;
				++pPinStats->Common.SRBsMissing;
				CDebugPrint(DebugLevelWarning,
				  (CODECNAME ": NABTSFEC output pin %d starving at bundle %d\n",
					 i, bundle_count));
			}
		}

		// Now free the bundle
		ExFreePool(pNab);
        KeAcquireSpinLock( &storage->q_SpinLock, &Irql );
    }
    KeReleaseSpinLock( &storage->q_SpinLock, Irql );

    DtRETURN;
}


//==========================================================================
// Routines for processing SRBs
//==========================================================================

/*
** VideoReceiveDataPacket()
**
**   Receives Video data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
VideoReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION              pHwDevExt;
    PSTREAMEX                         pStrmEx;
    int                               ThisStreamNr;
    PKSDATAFORMAT                     pKSDataFormat;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;
#ifdef DEBUG
    static int            QdepthReportFreq = 0;
    static unsigned int   QDRCount = 0;
#endif // DEBUG

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoReceiveDataPacket(pSrb=%x)\n", pSrb));

    // CASSERT(pSrb->SizeOfThisPacket == sizeof(*pSrb));

    pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
    CASSERT(pHwDevExt);  // make sure we have a device extension
    pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    CASSERT(pStrmEx);  // make sure we have a stream extension
    ThisStreamNr = (int)pSrb->StreamObject->StreamNumber;
    pKSDataFormat = &pStrmEx->MatchedFormat;

    pStats = &pHwDevExt->Stats;
    pPinStats = &pStrmEx->PinStats;

    // 
    // Default to success and no timeouts
    //

    pSrb->Status = STATUS_SUCCESS;
    pSrb->TimeoutCounter = 0;

    //
    // Some sanity checking...
    //
    switch (pSrb->Command)
    {
		case SRB_READ_DATA:
		case SRB_WRITE_DATA:

	    // Rule: 
	    // Only accept read requests when in either the Pause or Run
	    // States.  If Stopped, immediately return the SRB.

	    if (pStrmEx->KSState == KSSTATE_STOP) {
		    StreamClassStreamNotification(
				   StreamRequestComplete, 
			       pSrb->StreamObject,
				   pSrb);
			return;

	    } 
	    
#ifdef DRIVER_DEBUGGING_TEST
	    // When initially bringing up a driver, it is useful to just
	    // try immediately completing the SRB, thus verifying
	    // the streaming process independent of really accessing
	    // your hardware.  

		StreamClassStreamNotification(
			   StreamRequestComplete, 
			   pSrb->StreamObject,
			   pSrb);

	    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---VideoReceiveDataPacket(pSrb=%x)\n", pSrb));
	    return;
#endif // DRIVER_DEBUGGING_TEST

	    break;
    }  // switch (pSrb->Command)

    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
	case SRB_READ_DATA:
		// First, check to make sure that the supplied buffer is large enough
		if (pSrb->CommandData.DataBufferArray->FrameExtent < pKSDataFormat->SampleSize) {
			CDebugPrint(DebugLevelError,
		        (CODECNAME ": output pin handed buffer size %d, need %d\n",
				 pSrb->CommandData.DataBufferArray->FrameExtent,
				 pKSDataFormat->SampleSize));
			CDEBUG_BREAK();

			pSrb->Status = STATUS_BUFFER_TOO_SMALL;
			StreamClassStreamNotification(
				   StreamRequestComplete, 
				   pSrb->StreamObject,
				   pSrb);
		}
		else {
			// For outgoing data requests, save it up so the next incoming
			//  request will complete it.
            QueueAdd(pSrb, &pStrmEx->StreamDataSpinLock, &pStrmEx->StreamDataQueue);

            // Since another thread COULD HAVE MODIFIED THE STREAM STATE
            // in the midst of adding it to the queue, check the stream
            // state again, and cancel the SRB if necessary.
            // Note that this race condition was NOT handled in the
            // original DDK release of testcap!

            if (pStrmEx->KSState == KSSTATE_STOP)
                CodecCancelPacket(pSrb);
		}
	    break;

	case SRB_WRITE_DATA:
		{
#ifdef DEBUG
		   static int    MaxVBIqDepth = 0;
		   static int    AvgVBIqDepth = 1000;   // 1.000
		   int           qDepth = 0;
#endif // DEBUG
       	   CDebugPrint(DebugLevelTrace, (CODECNAME ": Stream VBI Writing\n"));
            if (QueueAddIfNotEmpty(pSrb, &pStrmEx->StreamDataSpinLock,
                &pStrmEx->StreamDataQueue))
			{
               break;
			}
           
            do
            {       
#ifdef HW_INPUT
                KIRQL Irql;
#endif /*HW_INPUT*/
#ifdef DEBUG
                            // CASSERT(pSrb->SizeOfThisPacket == sizeof(*pSrb));
			    ++qDepth;
			    ++QDRCount;
#endif // DEBUG
#ifdef HW_INPUT
				KeAcquireSpinLock(&pStrmEx->VBIOnHoldSpinLock, &Irql);
				if (pStrmEx->pVBISrbOnHold)
				{
					PHW_STREAM_REQUEST_BLOCK pHoldSrb;

					pHoldSrb = pStrmEx->pVBISrbOnHold;
					pStrmEx->pVBISrbOnHold = NULL;
					KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);

					_VBIjustDecode(pHwDevExt, pStrmEx, pHoldSrb);
				}
				else
					KeReleaseSpinLock(&pStrmEx->VBIOnHoldSpinLock, Irql);
#endif /*HW_INPUT*/

			    VBIDecode(pHwDevExt, pStrmEx, pSrb);

				++pStats->Common.InputSRBsProcessed;
				++pPinStats->Common.SRBsProcessed;
            } while (QueueRemove(&pSrb,
					 &pStrmEx->StreamDataSpinLock,
                     &pStrmEx->StreamDataQueue));
#ifdef DEBUG
	   		if (qDepth > MaxVBIqDepth)
				MaxVBIqDepth = qDepth;
			AvgVBIqDepth = (AvgVBIqDepth * 7 / 8) + (qDepth * 1000 / 8);
			if (QdepthReportFreq > 0 && 0 == QDRCount % QdepthReportFreq) {
				CDebugPrint( 1,
					(CODECNAME ": Max VBI Q depth = %3d, Avg VBI Q depth = %3d.%03d\n",
					 MaxVBIqDepth,
					 AvgVBIqDepth / 1000,
					 AvgVBIqDepth % 1000));
			}
#endif // DEBUG
           
        }
	    break;

	default:
	    //
	    // invalid / unsupported command. Fail it as such
	    //

	    CDEBUG_BREAK();

	    pSrb->Status = STATUS_NOT_IMPLEMENTED;

        StreamClassStreamNotification(
				StreamRequestComplete, 
			    pSrb->StreamObject,
				pSrb);
    }  // switch (pSrb->Command)

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoReceiveDataPacket(pSrb=%x)\n", pSrb));
}


/*
** VideoReceiveCtrlPacket()
**
**   Receives packet commands that control the Video stream
**
** Arguments:
**
**   pSrb - The stream request block for the Video stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
VideoReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    // CASSERT(pSrb->SizeOfThisPacket == sizeof(*pSrb)); // Bogus test.

    CASSERT(pHwDevExt);
    CASSERT(pStrmEx);

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoReceiveCtrlPacket(pSrb=%x)\n", pSrb));

    // 
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;

    if (QueueAddIfNotEmpty(pSrb,
         &pStrmEx->StreamControlSpinLock,
         &pStrmEx->StreamControlQueue))
	{
       return;
	}

	do {
    //
    // determine the type of packet.
    //

    switch (pSrb->Command)
    {
    case SRB_PROPOSE_DATA_FORMAT:
        if (!CodecVerifyFormat(pSrb->CommandData.OpenFormat, 
                               pSrb->StreamObject->StreamNumber,
							   NULL))
        {
            pSrb->Status = STATUS_NO_MATCH;
        }
        break; 
    case SRB_SET_STREAM_STATE:

        VideoSetState(pSrb);
        break;

    case SRB_GET_STREAM_STATE:

        VideoGetState(pSrb);
        break;

    case SRB_GET_STREAM_PROPERTY:

        VideoGetProperty(pSrb);
        break;

    case SRB_SET_STREAM_PROPERTY:

        VideoSetProperty(pSrb);
        break;

    case SRB_INDICATE_MASTER_CLOCK:

        //
        // Assigns a clock to a stream
        //

        VideoIndicateMasterClock(pSrb);

        break;

    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        CDEBUG_BREAK();

        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
    } while (QueueRemove(&pSrb,
			 &pStrmEx->StreamControlSpinLock,
             &pStrmEx->StreamControlQueue));

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoReceiveCtrlPacket(pSrb=%x)\n", pSrb));
}

#ifdef HW_INPUT
/*
** NABTSReceiveDataPacket()
**
**   Receives NABTS data packet commands
**
** Arguments:
**
**   pSrb - Stream request block for the NABTS stream
**
** Returns: nothing
**
** Side Effects:  none
*/

VOID 
STREAMAPI 
NABTSReceiveDataPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION              pHwDevExt;
    PSTREAMEX                         pStrmEx;
    int                               ThisStreamNr;
    PVBICODECFILTERING_STATISTICS_NABTS pStats = NULL;
    PVBICODECFILTERING_STATISTICS_NABTS_PIN pPinStats = NULL;
#ifdef DEBUG
    static int            NAB_QdepthReportFreq = 0;
    static unsigned int   NAB_QDRCount = 0;
#endif // DEBUG

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->NABTSReceiveCtrlPacket(pSrb=%x)\n", pSrb));

    // CASSERT(pSrb->SizeOfThisPacket == sizeof(*pSrb));

    pHwDevExt = (PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension;
    CASSERT(pHwDevExt);  // make sure we have a device extension
    pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    CASSERT(pStrmEx);  // make sure we have a stream extension
    ThisStreamNr = (int)pSrb->StreamObject->StreamNumber;

    pStats = &pHwDevExt->Stats;
    pPinStats = &pStrmEx->PinStats;

    // 
    // Default to success
    //

    pSrb->Status = STATUS_SUCCESS;
    pSrb->TimeoutCounter = 0;

    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
    case SRB_WRITE_DATA:

        // Rule: 
        // Only accept read requests when in either the Pause or Run
        // States.  If Stopped, immediately return the SRB.

        if (pStrmEx->KSState == KSSTATE_STOP) {
		    StreamClassStreamNotification(
				   StreamRequestComplete, 
			       pSrb->StreamObject,
				   pSrb);
			break;
        } 
        
#ifdef DRIVER_DEBUGGING_TEST
        // When initially bringing up a driver, it is useful to just
        // try immediately completing the SRB, thus verifying
        // the streaming process independent of really accessing
        // your hardware.  

		StreamClassStreamNotification(
			   StreamRequestComplete, 
			   pSrb->StreamObject,
			   pSrb);

		break;
#endif // DRIVER_DEBUGGING_TEST

	// 
	// Now the rubber meets the road.  Copy in HW decoded lines.
	{
#ifdef DEBUG
	   static int    MaxNABqDepth = 0;
	   static int    AvgNABqDepth = 1000;   // 1.000
	   int           qDepth = 0;
#endif // DEBUG

	    CDebugPrint(DebugLevelTrace, (CODECNAME ": Stream NABTS Writing\n"));
		if (QueueAddIfNotEmpty(pSrb, &pStrmEx->StreamDataSpinLock,
			&pStrmEx->StreamDataQueue))
		{
		   break;
		}
	   
		do
		{       
#ifdef DEBUG
			++qDepth;
			++NAB_QDRCount;
#endif // DEBUG
			VBIhwDecode(pHwDevExt, pStrmEx, pSrb);

			++pStats->Common.InputSRBsProcessed;
			++pPinStats->Common.SRBsProcessed;
		} while (QueueRemove(&pSrb,
				 &pStrmEx->StreamDataSpinLock,
				 &pStrmEx->StreamDataQueue));
#ifdef DEBUG
		if (qDepth > MaxNABqDepth)
			MaxNABqDepth = qDepth;
		AvgNABqDepth = (AvgNABqDepth * 7 / 8) + (qDepth * 1000 / 8);
		if (NAB_QdepthReportFreq > 0 && 0 == NAB_QDRCount % NAB_QdepthReportFreq) {
			CDebugPrint( 1,
				(CODECNAME ": Max NABTS Q depth = %3d, Avg NABTS Q depth = %3d.%03d\n",
				 MaxNABqDepth,
				 AvgNABqDepth / 1000,
				 AvgNABqDepth % 1000));
		}
#endif // DEBUG
	   
	}//
	break;

    case SRB_READ_DATA:
    default:

        //
        // invalid / unsupported command. Fail it as such
        //

        CDEBUG_BREAK();

        pSrb->Status = STATUS_NOT_IMPLEMENTED;

        StreamClassStreamNotification(
				StreamRequestComplete, 
			    pSrb->StreamObject,
				pSrb);

    }  // switch (pSrb->Command)

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---NABTSReceiveDataPacket(pSrb=%x)\n", pSrb));
}
#endif /*HW_INPUT*/

/*
** VideoGetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoGetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoGetProperty(pSrb=%x)\n", pSrb));

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set)) 
    {
        VideoStreamGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (&KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
        VideoStreamGetVBIFilteringProperty (pSrb);
    }
    else 
    {
       pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoGetProperty(pSrb=%x)\n", pSrb));
}

/*
** VideoSetProperty()
**
**    Routine to process video property requests
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoSetProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoSetProperty(pSrb=%x)\n", pSrb));

    // VideoStreamSetConnectionProperty() is not required/implemented! Read only property set.
    // Currently only VideoStreamSetVBIFilteringProperty() has any writeable properties.
    if (IsEqualGUID (&KSPROPSETID_VBICodecFiltering, &pSPD->Property->Set))
    {
        VideoStreamSetVBIFilteringProperty (pSrb);
    }
    else if (IsEqualGUID(&KSPROPSETID_Stream, &pSPD->Property->Set))
    {
    	pSrb->Status = STATUS_SUCCESS;
    }

    else 
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoSetProperty(pSrb=%x)\n", pSrb));
}

/*
** VideoSetState()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PHW_DEVICE_EXTENSION     pHwDevExt = ((PHW_DEVICE_EXTENSION)pSrb->HwDeviceExtension);
    PSTREAMEX                pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    int                   	 StreamNumber = (int)pSrb->StreamObject->StreamNumber;
	PHW_STREAM_REQUEST_BLOCK pCurrentSrb;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoSetState(pSrb=%x)\n", pSrb));

    CASSERT(pHwDevExt);
    CASSERT(pStrmEx);

    //
    // For each stream, the following states are used:
    // 
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that 
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class 
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming. 
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //

    switch (pSrb->CommandData.StreamState)  

    {
    case KSSTATE_STOP:

        //
        // If transitioning to STOP state, then complete any outstanding IRPs
        //
		while (QueueRemove(&pCurrentSrb, &pStrmEx->StreamDataSpinLock,
			   &pStrmEx->StreamDataQueue))
		{
			CDebugPrint(DebugLevelVerbose,
						(CODECNAME ": Cancelling %X\n", pCurrentSrb));
			pCurrentSrb->Status = STATUS_CANCELLED;
			pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

			StreamClassStreamNotification(StreamRequestComplete,
				   pCurrentSrb->StreamObject, pCurrentSrb);
		}


		BPC_SignalStop(pHwDevExt);

        CDebugPrint(DebugLevelTrace,
					(CODECNAME ": KSSTATE_STOP %u\n", StreamNumber));
        break;

    case KSSTATE_ACQUIRE:

        //
        // This is a KS only state, that has no correspondence in DirectShow
        // 
        CDebugPrint(DebugLevelTrace,
					(CODECNAME ": KSSTATE_ACQUIRE %u\n", StreamNumber));
        break;

    case KSSTATE_PAUSE:

        //
        // On a transition to pause from acquire, start our timer running.
        //

        if (pStrmEx->KSState == KSSTATE_ACQUIRE || pStrmEx->KSState == KSSTATE_STOP) {  
            
            // Remember the time at which the clock was started

            pHwDevExt->QST_Start = VideoGetSystemTime();

            // And initialize the last frame timestamp

            pHwDevExt->QST_Now = pHwDevExt->QST_Start;

		}
        CDebugPrint(DebugLevelTrace,
					(CODECNAME ": KSSTATE_PAUSE %u\n", StreamNumber));
        break;

    case KSSTATE_RUN:

        // 
        // Begin Streaming.
        //

        // Remember the time at which the clock was started

        pHwDevExt->QST_Start = VideoGetSystemTime();

        // Zero the frameinfo, it should be reset when the first sample arrives.

        RtlZeroMemory(&pStrmEx->FrameInfo, sizeof (pStrmEx->FrameInfo));

        // Reset the discontinuity flag

        pStrmEx->fDiscontinuity = FALSE;


        CDebugPrint(DebugLevelTrace,
					(CODECNAME ": KSSTATE_RUN %u\n", StreamNumber));

        break;

    } // end switch (pSrb->CommandData.StreamState)  
    
    //
    // Remember the state of this stream
    //

    pStrmEx->KSState = pSrb->CommandData.StreamState;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoSetState(pSrb=%x)\n", pSrb));
}

/*
** VideoGetState()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX     pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    CASSERT(pStrmEx);

    CDebugPrint(DebugLevelTrace,(CODECNAME ":--->VideoGetState(pSrb=%x)\n", pSrb));

    pSrb->CommandData.StreamState = pStrmEx->KSState;
    pSrb->ActualBytesTransferred = sizeof (KSSTATE);

    // A very odd rule:
    // When transitioning from stop to pause, DShow tries to preroll
    // the graph.  Capture sources can't preroll, and indicate this
    // by returning VFW_S_CANT_CUE in user mode.  To indicate this
    // condition from drivers, they must return STATUS_NO_DATA_DETECTED

    if (pStrmEx->KSState == KSSTATE_PAUSE) {
       pSrb->Status = STATUS_NO_DATA_DETECTED;
    }

    CDebugPrint(DebugLevelTrace,(CODECNAME ":<---VideoGetState(pSrb=%x)=%d\n", pSrb, pStrmEx->KSState));
}


/*
** VideoStreamGetConnectionProperty()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamGetConnectionProperty(PHW_STREAM_REQUEST_BLOCK pSrb)
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    int  StreamNumber = (int)pSrb->StreamObject->StreamNumber;
    ULONG Id = pSPD->Property->Id;              // index of the property

    CDebugPrint(DebugLevelTrace,
		( CODECNAME ":--->VideoStreamGetConnectionProperty(pSrb=%x)\n", 
		pSrb));

    CASSERT(pStrmEx);

    pSrb->ActualBytesTransferred = 0;

    switch (Id) 
	{
	    case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
	    {
		PKSALLOCATOR_FRAMING Framing = 
		    (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

		CDebugPrint(DebugLevelVerbose, ( CODECNAME ": VideoStreamGetConnectionProperty : KSPROPERTY_CONNECTION_ALLOCATORFRAMING\n"));

		Framing->RequirementsFlags =
		    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
		    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
		    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
		Framing->PoolType = NonPagedPool;
		Framing->FileAlignment = 0;
		Framing->Reserved = 0;
		pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);

		Framing->FrameSize = pStrmEx->OpenedFormat.SampleSize;
		if (StreamNumber == STREAM_Decode
		    && !CodecCompareGUIDsAndFormatSize(
					(PKSDATARANGE)&StreamFormatVBI,
					&pStrmEx->OpenedFormat,
					FALSE))
		{
		    // Only want many buffers if NOT VBI samples; they're BIG!
		    Framing->Frames = 16;
		}
		else
		{
		    Framing->Frames = 8;
		}

			CDebugPrint(DebugLevelVerbose,
					(CODECNAME ": Negotiated sample size is %d\n", 
					 Framing->FrameSize));
			break;
	    }
        
	    default:
			pSrb->Status = STATUS_NOT_IMPLEMENTED;
			CDebugPrint(DebugLevelVerbose,
				(CODECNAME ": VideoStreamGetConnectionProperty : Unknown Property Id=%d\n", Id));
			CDEBUG_BREAK();
			break;
    }

    CDebugPrint(DebugLevelTrace,
				(CODECNAME ":<---VideoStreamGetConnectionProperty(pSrb=%x)\n", 
				pSrb));
}

/*
** VideoStreamGetVBIFilteringProperty()
**
**    Gets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamGetVBIFilteringProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX                   pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    LONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY);    // Size of the app buffer  

    CDebugPrint(DebugLevelTrace,
		( CODECNAME ":--->VideoStreamGetVBIFilteringProperty(pSrb=%x)\n", 
		pSrb));

    ASSERT (nBytes >= sizeof (LONG));
  
    pSrb->ActualBytesTransferred = 0;
    switch (Id) 
	{
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->ScanlinesRequested ) );
            RtlCopyMemory( &Property->Scanlines, &pStrmEx->ScanlinesRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->ScanlinesDiscovered ) );
            RtlCopyMemory( &Property->Scanlines, &pStrmEx->ScanlinesDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pStrmEx->ScanlinesDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->SubstreamsRequested ) );
            RtlCopyMemory( &Property->Substreams, &pStrmEx->SubstreamsRequested, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->SubstreamsDiscovered ) );
            RtlCopyMemory( &Property->Substreams, &pStrmEx->SubstreamsDiscovered, nBytes );
            // Clear the data after the read so that it's always "fresh"
            RtlZeroMemory( &pStrmEx->SubstreamsDiscovered, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_STATISTICS:
		{
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamGetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->PinStats ) );
            RtlCopyMemory( &Property->Statistics, &pStrmEx->PinStats, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamGetVBIFilteringProperty : Unknown Property Id=%d\n", Id));
			CDEBUG_BREAK();
			break;
    }

    CDebugPrint(DebugLevelTrace,
		( CODECNAME ":<---VideoStreamGetVBIFilteringProperty(pSrb=%x)\n", 
		pSrb));
}

/*
** VideoStreamSetVBIFilteringProperty()
**
**    Sets the current state of the requested stream
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID
VideoStreamSetVBIFilteringProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;
    ULONG Id = pSPD->Property->Id;              // index of the property
    LONG nBytes = pSPD->PropertyOutputSize - sizeof(KSPROPERTY);        // size of data supplied

    CDebugPrint(DebugLevelTrace,
		( CODECNAME ":--->VideoStreamSetVBIFilteringProperty(pSrb=%x)\n", 
		pSrb));
    CASSERT(pStrmEx);

    ASSERT (nBytes >= sizeof (LONG));
    pSrb->ActualBytesTransferred = 0;

    switch (Id) 
	{
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->ScanlinesRequested ) );
            RtlCopyMemory( &pStrmEx->ScanlinesRequested, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_SCANLINES_S Property =
                (PKSPROPERTY_VBICODECFILTERING_SCANLINES_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pStrmEx->ScanlinesDiscovered ) );
            RtlCopyMemory( &pStrmEx->ScanlinesDiscovered, &Property->Scanlines, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pStrmEx->SubstreamsRequested ) );
            RtlCopyMemory( &pStrmEx->SubstreamsRequested, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY:
		{
            PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S Property =
                (PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY\n"));
            nBytes = min( nBytes, sizeof(pStrmEx->SubstreamsDiscovered ) );
            RtlCopyMemory( &pStrmEx->SubstreamsDiscovered, &Property->Substreams, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		case KSPROPERTY_VBICODECFILTERING_STATISTICS:
		{
            PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S Property =
                (PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S) pSPD->PropertyInfo;

            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamSetVBIFilteringProperty : KSPROPERTY_VBICODECFILTERING_STATISTICS\n"));
            nBytes = min( nBytes, sizeof( pStrmEx->PinStats ) );
            RtlCopyMemory( &pStrmEx->PinStats, &Property->Statistics, nBytes );
            pSrb->ActualBytesTransferred = nBytes + sizeof(KSPROPERTY);
	        break;
        }
        
		default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            CDebugPrint(DebugLevelVerbose,
				( CODECNAME ": VideoStreamSetVBIFilteringProperty : Unknown Property Id=%d\n", Id));
			CDEBUG_BREAK();
			break;
    }

    CDebugPrint(DebugLevelTrace,
		( CODECNAME ":<---VideoStreamSetVBIFilteringProperty(pSrb=%x)\n", 
		pSrb));
}

/*
** GetSystemTime ()
**
**    Returns the system time in 100 nS units
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

ULONGLONG 
VideoGetSystemTime()
{
    ULONGLONG ticks;
    ULONGLONG rate;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoGetSystemTime()\n"));

    ticks = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;

    //
    // convert from ticks to 100ns clock
    //

    ticks = (ticks & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ticks & 0x00000000FFFFFFFF) * 10000000 / rate;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoGetSystemTime()\n"));

    return(ticks);
}



//==========================================================================;
//                   Clock Handling Routines
//==========================================================================;


/*
** VideoIndicateMasterClock ()
**
**    This function is used to provide us with a handle to the clock to use.
**
** Arguments:
**
**    pSrb - pointer to the stream request block for properties
**
** Returns:
**
** Side Effects:  none
*/

VOID 
VideoIndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
{
    PSTREAMEX pStrmEx = (PSTREAMEX)pSrb->StreamObject->HwStreamExtension;

    CASSERT(pStrmEx);

    CDebugPrint(DebugLevelTrace,( CODECNAME ":--->VideoIndicateMasterClock(pSrb=%x)\n", pSrb));

    pStrmEx->hClock = pSrb->CommandData.MasterClockHandle;

    CDebugPrint(DebugLevelTrace,( CODECNAME ":<---VideoIndicateMasterClock(pSrb=%x)\n", pSrb));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\kskludge.h ===
///////////////////////////////////////////////////////////////////
// Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
///////////////////////////////////////////////////////////////////
#ifndef NABTS_BUFFER_PICTURENUMBER_SUPPORT
#define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1

// These low-level structures are byte packed( -Zp1 )
# include <pshpack1.h>
typedef struct _NABTS_BUFFER_new {
    VBICODECFILTERING_SCANLINES     ScanlinesRequested;
    LONGLONG                        PictureNumber;
    NABTS_BUFFER_LINE               NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER_new, *PNABTS_BUFFER_new;
# include <poppack.h>
# define NABTS_BUFFER NABTS_BUFFER_new
# define PNABTS_BUFFER PNABTS_BUFFER_new

#endif //!defined(NABTS_BUFFER_PICTURENUMBER_SUPPORT)


///////////////////////////////////////////////////////////////////
// VBI frequencies and scalars for them
///////////////////////////////////////////////////////////////////
#ifndef KS_VBIDATARATE_NABTS

// VBI Sampling Rates 
#define KS_VBIDATARATE_NABTS			(5727272)
#define KS_VBISAMPLINGRATE_4X_NABTS		((int)(4*KS_VBIDATARATE_NABTS))
#define KS_VBISAMPLINGRATE_47X_NABTS	((int)(27000000))
#define KS_VBISAMPLINGRATE_5X_NABTS		((int)(5*KS_VBIDATARATE_NABTS))

#define KS_47NABTS_SCALER				(KS_VBISAMPLINGRATE_47X_NABTS/(double)KS_VBIDATARATE_NABTS)

#endif //!defined(KS_VBIDATARATE_NABTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\tests\testnab\testnab.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <windows.h>
#include <wincon.h>

#include <nabts.h>

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

#define CONCURRENT_READS    180 
#define READ_BUFFER_SIZE    sizeof(NABTSFEC_BUFFER)

/* Update statistics every n milliseconds (16ms is generally too fast) */
#define UPDATE_PERIOD       100

void
PrintStatistics( INabts &Driver, int row, int column, BOOL bSavePosition)
{
HANDLE                                  hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
COORD                                   Pos = {(short)row, (short)column};
CONSOLE_SCREEN_BUFFER_INFO              SavedPos;
VBICODECFILTERING_STATISTICS_NABTS      Statistics;
VBICODECFILTERING_STATISTICS_COMMON_PIN PinStatistics;

if ( Driver.GetCodecStatistics( Statistics ) == 0         
  && Driver.GetPinStatistics( PinStatistics ) == 0 )
    {
    char    szBuffer[13][80] = { 0 };
    if ( bSavePosition )
        GetConsoleScreenBufferInfo( hStdout, &SavedPos );

    SetConsoleCursorPosition( hStdout, Pos );
    
    sprintf(szBuffer[0], "-------------------------- NABTS Codec Statistics -----------------------------");
    sprintf(szBuffer[1], "InputSRBsProcessed: %u, OutputSRBsProcessed: %u, SRBsIgnored: %u",
            Statistics.Common.InputSRBsProcessed, Statistics.Common.OutputSRBsProcessed, Statistics.Common.SRBsIgnored );
    sprintf(szBuffer[2], "InputSRBsMissing: %u, OutputSRBsMissing: %u, OutputFailures: %u", 
            Statistics.Common.InputSRBsMissing, Statistics.Common.OutputSRBsMissing, Statistics.Common.OutputFailures );
    sprintf(szBuffer[3], "InternalErrors: %u, ExternalErrors: %u, InputDiscontinuities: %u",
            Statistics.Common.InternalErrors, Statistics.Common.ExternalErrors, Statistics.Common.InputDiscontinuities );
    sprintf(szBuffer[4], "DSPFailures: %u, TvTunerChanges: %u, VBIHeaderChanges: %u",
            Statistics.Common.DSPFailures, Statistics.Common.TvTunerChanges, Statistics.Common.VBIHeaderChanges );
    sprintf(szBuffer[5], "LineConfidenceAvg: %u, BytesOutput: %u, FECBundleBadLines: %u",
            Statistics.Common.LineConfidenceAvg, Statistics.Common.BytesOutput, Statistics.FECBundleBadLines );
    sprintf(szBuffer[6], "FECQueueOverflows: %u, FECCorrectedLines: %u, FECUncorrectableLines: %u",
            Statistics.FECQueueOverflows, Statistics.FECCorrectedLines, Statistics.FECUncorrectableLines );
    sprintf(szBuffer[7], "BundlesProcessed: %u, BundlesSent2IP: %u, FilteredLines: %u",
            Statistics.BundlesProcessed, Statistics.BundlesSent2IP, Statistics.FilteredLines );
    sprintf(szBuffer[8], "---------------------------- Raw Pin Statistics -------------------------------");
    sprintf(szBuffer[9], "SRBsProcessed: %u, SRBsMissing: %u, SRBsIgnored: %u",
            PinStatistics.SRBsProcessed, PinStatistics.SRBsMissing, PinStatistics.SRBsIgnored );
    sprintf(szBuffer[10], "InternalErrors: %u, ExternalErrors: %u, Discontinuities: %u",
            PinStatistics.InternalErrors, PinStatistics.ExternalErrors, PinStatistics.Discontinuities );
    sprintf(szBuffer[11], "LineConfidenceAvg: %u, BytesOutput: %u", 
            PinStatistics.LineConfidenceAvg, PinStatistics.BytesOutput );
    sprintf(szBuffer[12], "===============================================================================");

    printf("%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n",
            szBuffer[0], szBuffer[1], szBuffer[2], szBuffer[3], szBuffer[4], 
            szBuffer[5], szBuffer[6], szBuffer[7], szBuffer[8], szBuffer[9],
            szBuffer[10], szBuffer[11], szBuffer[12] );

    if ( bSavePosition )
        SetConsoleCursorPosition( hStdout, SavedPos.dwCursorPosition );
    }
}

int __cdecl
main( int argc, char *argv[] )
{
int	        nStatus = 0;
int         arg = 1; // Next unparsed command line parameter
const int   bStatistics = arg < argc && strcmp(argv[arg],"-s") == 0 ? arg++ : 0;
long        nLastUpdate = 0;
int         nScanline = 13;     // Scanlines can vary by station(This one is arbitrary)

if ( nScanline )
    {
    try {
        INabts	Driver;
        if ( Driver.IsValid() )
            {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );

            if ( bStatistics )
                PrintStatistics( Driver, 0, 0, FALSE );

            if ( ( nStatus = Driver.ClearRequestedScanlines() ) == 0 )
                {
                do
                    {
                    if ( arg < argc )
                        if ( !(nScanline = atoi( argv[arg] ) ) )
                            printf( "Invalid scanline: '%s'\n", argv[arg] );
                    printf( "Scanline:%d ", nScanline );
                    if ( ( nStatus = Driver.AddRequestedScanline(nScanline) ) != 0 )
                        {
                        fprintf( stderr, "\nFailed to AddRequestedScanline(%d)=%d\n", nScanline, nStatus );
                        return nStatus;
                        }
                    }
                while ( ++arg < argc );
                }
            else
                {
                fprintf( stderr, "\nFailed to ClearRequestedScanlines()=%d\n", nStatus );
                return nStatus;
                }

            printf("\n");

            int                 nNextRead = 0;
            DWORD               nBytes = 0;
            OVERLAPPED          Overlapped[CONCURRENT_READS] = {0};
            NABTS_BUFFER		NabtsBuffer[CONCURRENT_READS];

            for( nNextRead = 0; !nStatus && nNextRead < CONCURRENT_READS; nNextRead++ )
	            {
	            if ( !( Overlapped[nNextRead].hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
                    {
                    nStatus = GetLastError();
                    break;
                    }
                nStatus = Driver.ReadData( NabtsBuffer+nNextRead, READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );

                if ( !nStatus || nStatus == ERROR_IO_PENDING )
                    nStatus = 0;
                else
                    break;
                }
            nNextRead = 0;

            while ( !nStatus && !_kbhit() )
                {
                if ( !(nStatus = Driver.GetOverlappedResult(Overlapped+nNextRead, &nBytes, FALSE ) ) )
                    {
		            nBytes = min(nBytes, READ_BUFFER_SIZE);

                    printf("[%06X]", NabtsBuffer[nNextRead].ScanlinesRequested.DwordBitArray[0] );
                    nStatus = Driver.ReadData( NabtsBuffer+nNextRead, READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
        
                    if ( !nStatus  || nStatus == ERROR_IO_PENDING )
                        {
                        nNextRead = ++nNextRead % CONCURRENT_READS;
                        nStatus = 0;
                        }
                    }
                else if ( nStatus == ERROR_IO_INCOMPLETE || nStatus == ERROR_IO_PENDING )
                    {
                    Sleep(10); // Chill out a few milliseconds so we don't run full tilt.
                    nStatus = 0;
                    }

                if ( bStatistics && GetTickCount()-nLastUpdate > UPDATE_PERIOD )
                    {
                    PrintStatistics( Driver, 0, 0, TRUE );
                    nLastUpdate = GetTickCount();
                    }
                }
            }
        }
    catch (...)
        {
        nStatus = GetLastError();
        }
    }
else
    printf( "Syntax: TESTNAB [-s] [ scanline1 [scanline2] ]\n" );

if ( nStatus )
    fprintf( stderr, "Program failed with LastErrorCode=%d!\n", nStatus );

return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oleds.inc ===
OLEDSLIB_W95=$(PROJECT_ROOT)\adsi\public\lib\win95

!IF "$(ADSI_NT40_BUILD)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_FOR_NT40 -DUSE_DS_VER
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\tests\testcc\testcc.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <wincon.h>
#include <conio.h>


#include <ccdecode.h>

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

#define CONCURRENT_READS    180 
#define READ_BUFFER_SIZE    2

/* Update statistics every n milliseconds (16ms is generally too fast) */
#define UPDATE_PERIOD       100

void
PrintStatistics( ICCDecode &Driver, int row, int column, BOOL bSavePosition)
{
HANDLE                                  hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
COORD                                   Pos = {(short)row, (short)column};
CONSOLE_SCREEN_BUFFER_INFO              SavedPos;
VBICODECFILTERING_STATISTICS_CC         Statistics;
VBICODECFILTERING_STATISTICS_CC_PIN     PinStatistics;
VBICODECFILTERING_SCANLINES             ScanlinesRequested, ScanlinesDiscovered;
VBICODECFILTERING_CC_SUBSTREAMS         VideoFieldsRequested, VideoFieldsDiscovered;

char    szBuffer[11][80];
if ( bSavePosition )
     GetConsoleScreenBufferInfo( hStdout, &SavedPos );
SetConsoleCursorPosition( hStdout, Pos );

if ( Driver.GetCodecStatistics( Statistics ) == 0 )
    {

    memset( &ScanlinesRequested, 0, sizeof(ScanlinesRequested) );
    memset( &ScanlinesDiscovered, 0, sizeof(ScanlinesDiscovered) );
    memset( &VideoFieldsRequested, 0, sizeof(VideoFieldsRequested) );
    memset( &VideoFieldsDiscovered, 0, sizeof(VideoFieldsDiscovered) );

    Driver.m_ScanlinesRequested.GetValue(&ScanlinesRequested);
    Driver.m_SubstreamsRequested.GetValue(&VideoFieldsRequested);
    Driver.m_ScanlinesDiscovered.GetValue(&ScanlinesDiscovered);
    Driver.m_SubstreamsDiscovered.GetValue(&VideoFieldsDiscovered);

    sprintf(szBuffer[0], "-----R:%08x:%08x----- CC Codec Statistics ------D:%08x:%08x-----",
            ScanlinesRequested.DwordBitArray[0], VideoFieldsRequested.SubstreamMask, 
            ScanlinesDiscovered.DwordBitArray[0], VideoFieldsDiscovered.SubstreamMask );
    sprintf(szBuffer[1], "InputSRBsProcessed: %u, OutputSRBsProcessed: %u, SRBsIgnored: %u",
            Statistics.Common.InputSRBsProcessed, Statistics.Common.OutputSRBsProcessed, Statistics.Common.SRBsIgnored );
    sprintf(szBuffer[2], "InputSRBsMissing: %u, OutputSRBsMissing: %u, OutputFailures: %u", 
            Statistics.Common.InputSRBsMissing, Statistics.Common.OutputSRBsMissing, Statistics.Common.OutputFailures );
    sprintf(szBuffer[3], "InternalErrors: %u, ExternalErrors: %u, InputDiscontinuities: %u",
            Statistics.Common.InternalErrors, Statistics.Common.ExternalErrors, Statistics.Common.InputDiscontinuities );
    sprintf(szBuffer[4], "DSPFailures: %u, TvTunerChanges: %u, VBIHeaderChanges: %u",
            Statistics.Common.DSPFailures, Statistics.Common.TvTunerChanges, Statistics.Common.VBIHeaderChanges );
    sprintf(szBuffer[5], "LineConfidenceAvg: %u, BytesOutput: %u",
            Statistics.Common.LineConfidenceAvg, Statistics.Common.BytesOutput );
    }

if ( Driver.GetPinStatistics( PinStatistics ) == 0 )
    {
    memset( &ScanlinesRequested, 0, sizeof(ScanlinesRequested) );
    memset( &ScanlinesDiscovered, 0, sizeof(ScanlinesDiscovered) );
    memset( &VideoFieldsRequested, 0, sizeof(VideoFieldsRequested) );
    memset( &VideoFieldsDiscovered, 0, sizeof(VideoFieldsDiscovered) );

    Driver.m_OutputPin.m_ScanlinesRequested.GetValue(&ScanlinesRequested);
    Driver.m_OutputPin.m_SubstreamsRequested.GetValue(&VideoFieldsRequested);
    Driver.m_OutputPin.m_ScanlinesDiscovered.GetValue(&ScanlinesDiscovered);
    Driver.m_OutputPin.m_SubstreamsDiscovered.GetValue(&VideoFieldsDiscovered);

    sprintf(szBuffer[6], "-----R:%08x:%08x------- CCPin Statistics -------D:%08x:%08x-----",
            ScanlinesRequested.DwordBitArray[0], VideoFieldsRequested.SubstreamMask, 
            ScanlinesDiscovered.DwordBitArray[0], VideoFieldsDiscovered.SubstreamMask );
    sprintf(szBuffer[7], "SRBsProcessed: %u, SRBsMissing: %u, SRBsIgnored: %u",
            PinStatistics.Common.SRBsProcessed, PinStatistics.Common.SRBsMissing, PinStatistics.Common.SRBsIgnored );
    sprintf(szBuffer[8], "InternalErrors: %u, ExternalErrors: %u, Discontinuities: %u",
            PinStatistics.Common.InternalErrors, PinStatistics.Common.ExternalErrors, PinStatistics.Common.Discontinuities );
    sprintf(szBuffer[9], "LineConfidenceAvg: %u, BytesOutput: %u", 
            PinStatistics.Common.LineConfidenceAvg, PinStatistics.Common.BytesOutput );
    sprintf(szBuffer[10], "===============================================================================");

    printf("%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n",
            szBuffer[0], szBuffer[1], szBuffer[2], szBuffer[3], szBuffer[4], 
            szBuffer[5], szBuffer[6], szBuffer[7], szBuffer[8], szBuffer[9],
            szBuffer[10] );

    }
if ( bSavePosition )
	SetConsoleCursorPosition( hStdout, SavedPos.dwCursorPosition );
}

void
interpret_Vchip(unsigned char *buf, int buflen)
{
	static int m_bGetVChip = FALSE;
	static int m_bGetCurrentOnEven = FALSE;
	//long lLevel = -1;
	unsigned char *bp, *ep;

    bp = buf;
	ep = &buf[buflen];
	while (bp < ep)
    {
		UCHAR ucData = *bp++;

		if ( m_bGetVChip )
		{
			// state is we are looking for vchip data
			if ( ucData & 0x40 )
			{
				UCHAR ucData2;
				
				if (bp >= ep)
					break;

				// it's a valid char, get the next one
				ucData2 = *bp++;		

				// we have a valid one, determine what it is
				if ( !(ucData & 0x08) )
				{
					// MPAA
					UCHAR ucMPAA = (ucData & 0x07);
					printf("\bVChip MPAA-" );
					switch ( ucMPAA )
					{
					case 0x00:
						printf("NONE");
						break;
					case 0x01:
						printf("G");
						break;
					case 0x02:
						printf("PG");
						break;
					case 0x03:
						printf("PG13");
						break;
					case 0x04:
						printf("R");
						break;
					case 0x05:
						printf("NC17");
						break;
					case 0x06:
						printf("X");
						break;
					case 0x07:
						printf("NOTRATED");
						break;

					}
					printf("\n");
				}
				else if ( !(ucData & 0x10 ) )
				{
						// TV Parental Guidelines
					if ( ucData2 & 0x40 )
					{
						UCHAR ucTVParental = (ucData2 & 0x07);
						printf("\bVChip TVP-" );

						switch ( ucTVParental )
						{
						case 0x00:
							printf("NONE");
							break;
						case 0x01:
							printf("Y");
							break;
						case 0x02:
							printf("Y7");
							break;
						case 0x03:
							printf("G");
							break;
						case 0x04:
							printf("PG");
							break;
						case 0x05:
							printf("TV14");
							break;
						case 0x06:
							printf("TVMA");
							break;
						case 0x07:
							printf("NONE");
							break;

						}

						// Now do the TV sub-codes:
						if (ucData & 0x20)
							printf(" D");
						if (ucData2 & 0x20) {
							printf(" ");
							if (0x02 == ucTVParental)
								printf("F");
							printf("V");
						}
						if (ucData2 & 0x10)
							printf(" S");
						if (ucData2 & 0x08)
							printf(" L");

						printf("\n");

					}
					else
					{
						printf("VChip NonUS- 0x%02x 0x%02x\n", ucData, ucData2 );
						// non-US system
					}


				}
				else
				{
					// it's not a valid vchip char
					m_bGetVChip = FALSE;
				}

			}
			else
			{
				// it's not a valid vchip char
				m_bGetVChip = FALSE;
			}

		}
		else if ( m_bGetCurrentOnEven )
		{
			// state is we have started Current Class
			if ( ucData == 0x05 )
			{
				m_bGetVChip = TRUE;
			}
			m_bGetCurrentOnEven = FALSE;

		}
		else
		{
			// state is something else
			if ( ucData == 0x01 || ucData == 0x02 )
			{
				m_bGetCurrentOnEven = TRUE;
			}

		}

    }	
}

int __cdecl
main( int argc, char *argv[] )
{
int	        nStatus = 0;
int         arg = 1; // Next unparsed command line parameter
const int   bDoVchip = arg < argc && strcmp(argv[arg],"-v") == 0 ? arg++ : 0;
const int   bStatistics = arg < argc && strcmp(argv[arg],"-s") == 0 ? arg++ : 0;
long        nLastUpdate = 0;
const int   nScanline = arg < argc ? atoi(argv[arg++]) : 21;  // Closed Captioning Scanline(21)
int         nSubstream = KS_CC_SUBSTREAM_ODD;
unsigned char	VchipBuffer[128], *vcp = VchipBuffer;
int				VchipBytes = 0;

if ( nScanline )
    {
    try {
        ICCDecode	Driver;
        if ( Driver.IsValid() )
            {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );

            if ( bStatistics )
                PrintStatistics( Driver, 0, 0, FALSE );

            if ( (nStatus = Driver.ClearRequestedScanlines() ) == 0)
                {
                printf( "Starting decoding%s on line %d", bDoVchip? " [VCHIP mode]":"", nScanline ); // No newline, see below
                if ( (nStatus = Driver.AddRequestedScanline(nScanline) ) != 0)
                    {
                    fprintf( stderr, "\nFailed to AddRequestedScanlines(%d)=%d\n", nScanline, nStatus );
                    return nStatus;
                    }
                }
            else
                {
                fprintf( stderr, "\nFailed to ClearRequestedScanlines()=%d\n", nStatus );
                return nStatus;
                }

            if ( ( nStatus = Driver.ClearRequestedVideoFields() ) == 0 )
                {
                do
                    {
                    if ( arg < argc )
                        if ( !(nSubstream = atoi( argv[arg] ) ) )
                            printf( "Invalid substream: '%s'\n", argv[arg] );
                    printf( ", Substream %d", nSubstream );
                    if ( ( nStatus = Driver.AddRequestedVideoField(nSubstream) ) != 0 )
                        {
                        fprintf( stderr, "\nFailed to AddRequestedVideoField(%d)=%d\n", nSubstream, nStatus );
                        return nStatus;
                        }
                    }
                while ( ++arg < argc );
                }
            else
                {
                fprintf( stderr, "\nFailed to ClearRequestedVideoFields()=%d\n", nStatus );
                return nStatus;
                }

            printf("\n");

            int         nNextRead = 0;//, nNextCompleted = 0;
            DWORD       nBytes = 0;
            OVERLAPPED  Overlapped[CONCURRENT_READS] = {0};
            BYTE		ccdata[CONCURRENT_READS][READ_BUFFER_SIZE];

            for( nNextRead = 0; !nStatus && nNextRead < CONCURRENT_READS; nNextRead++ )
	            {
	            if ( !( Overlapped[nNextRead].hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
                    {
                    nStatus = GetLastError();
                    break;
                    }
                nStatus = Driver.ReadData( ccdata[nNextRead], READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
                if ( !nStatus || nStatus == ERROR_IO_PENDING )
                    nStatus = 0;
                else
                    break;
	            }
            nNextRead = 0;

            while ( !nStatus && !_kbhit() )
                {
                if ( !(nStatus = Driver.GetOverlappedResult(Overlapped+nNextRead, &nBytes, FALSE ) ) )
                    {
		            nBytes = min(nBytes, READ_BUFFER_SIZE);
                    for(DWORD i=0; i<nBytes; i++ )
                        ccdata[nNextRead][i] &= 0x7F;
	                //printf( "CC Data #%d=%d:[%.*s]\n", nNextRead, nBytes, nBytes, ccdata[nNextRead] );
					if (bDoVchip)
					{
						unsigned int		i;

						for (i = 0; i < nBytes && vcp < &VchipBuffer[sizeof (VchipBuffer)]; ++i, ++VchipBytes)
							*vcp++ = ccdata[nNextRead][i];
						if (VchipBytes >= sizeof (VchipBuffer)) {
							printf(".");
							//printf( "interpret_Vchip([%.*s], %d)\n", VchipBytes, ccdata[nNextRead], VchipBytes );
							interpret_Vchip((unsigned char *)VchipBuffer, VchipBytes);
							vcp = VchipBuffer;
							VchipBytes = 0;
						}
					}
					else
	                    printf("%.*s", nBytes, ccdata[nNextRead]);
        
                    nStatus = Driver.ReadData( ccdata[nNextRead], READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
                    if ( !nStatus  || nStatus == ERROR_IO_PENDING )
                        {
                        nNextRead = ++nNextRead % CONCURRENT_READS;
                        nStatus = 0;
                        }
                    }
                else if ( nStatus == ERROR_IO_INCOMPLETE || nStatus == ERROR_IO_PENDING )
                    {
                    Sleep(10); // Chill out a few milliseconds so we don't run full tilt.
                    nStatus = 0;
                    }

                if ( bStatistics && GetTickCount()-nLastUpdate > UPDATE_PERIOD )
                    {
                    PrintStatistics( Driver, 0, 0, TRUE );
                    nLastUpdate = GetTickCount();
                    }
                }

                // Drain any chars pressed
                while ( _kbhit() )
                    _getch();
            }
        }
    catch (...)
        {
        nStatus = GetLastError();
        }
    }
else
    printf( "CC TESTAPP Syntax: TESTAPP [-v][-s] [scanline [substream1 [substream2] ] ]\n" );

if ( nStatus )
    fprintf( stderr, "Program failed with LastErrorCode=%d!\n", nStatus );

return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wmilib\wmilib.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    wmilib.c

Abstract:

    WMI library utility functions

    CONSIDER adding the following functionality to the library:
        * Dynamic instance names
        * Different instance names for different guids

Author:

    AlanWar

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "wdm.h"
#include "wmistr.h"
#include "wmilib.h"
#include "wmiguid.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


BOOLEAN
WmiLibpFindGuid(
    IN PWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, WmiLibpFindGuid)
#pragma alloc_text(PAGE, WmiSystemControl)


#endif


//
// Pool tag for WMILIB
#define WMILIBPOOLTAG 'LimW'

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Temporary entry point needed to initialize the class system dll.
    It doesn't do anything.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/
{
    return(STATUS_SUCCESS);
}

BOOLEAN
WmiLibpFindGuid(
    IN PWMIGUIDREGINFO GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex,
    OUT PULONG InstanceCount
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid

    *InstanceCount returns the count of instances for the guid

Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, GuidList[i].Guid))
        {
            *GuidIndex = i;
            *InstanceCount = GuidList[i].InstanceCount;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmiSystemControl(
    IN PWMILIB_CONTEXT WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    OUT PSYSCTL_IRP_DISPOSITION IrpDisposition
    )
/*++

Routine Description:

    Dispatch helper routine for IRP_MJ_SYSTEM_CONTROL. This routine will
    determine if the irp passed contains a WMI request and if so process it
    by invoking the appropriate callback in the WMILIB structure.

    This routine may only be called at passive level

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    IrpDisposition - Returns a value that specifies how the irp was handled.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    PAGED_CODE();

    //
    // First ensure that the irp is a WMI irp
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) &&
        (minorFunction != IRP_MN_REGINFO_EX))
    {
        //
        // This is not a WMI irp
        *IrpDisposition = IrpNotWmi;
        return(STATUS_SUCCESS);
    }

    //
    // If the irp is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    if ( (irpStack->Parameters.WMI.ProviderId != (UINT_PTR)DeviceObject) ||
         (WmiLibInfo == NULL) )
    {
#if DBG
        if (WmiLibInfo == NULL)
        {
            KdPrint(("WMILIB: DeviceObject %X passed NULL WmiLibInfo\n",
                    DeviceObject));
        }
#endif
        *IrpDisposition = IrpForward;
        return(Irp->IoStatus.Status);
    }

    //
    // The irp is a WMI irp targetted towards this device driver
    *IrpDisposition = IrpProcessed;
    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if ((minorFunction != IRP_MN_REGINFO) &&
         (minorFunction != IRP_MN_REGINFO_EX))
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        ASSERT(WmiLibInfo->GuidList != NULL);
        if (WmiLibpFindGuid(WmiLibInfo->GuidList,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex,
                            &instanceCount))
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (NT_SUCCESS(status) &&
            ((minorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
             (minorFunction == IRP_MN_EXECUTE_METHOD)))
        {
            instanceIndex = ((PWNODE_SINGLE_INSTANCE)buffer)->InstanceIndex;

            if ( (((PWNODE_HEADER)buffer)->Flags) &
                                          WNODE_FLAG_STATIC_INSTANCE_NAMES)
            {
                if ( instanceIndex >= instanceCount )
                {
                    status = STATUS_WMI_INSTANCE_NOT_FOUND;
                }
            } else {
                status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }

        //
        // If we couldn't find the guid or the instance name index is out
        // of range then return an error.
        if (! NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            *IrpDisposition = IrpNotCompleted;
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        case IRP_MN_REGINFO_EX:
        {
            ULONG guidCount;
            PWMIGUIDREGINFO guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            UNICODE_STRING mofResourceName;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG mofResourceOffset;
            ULONG bufferNeeded;
            ULONG i;
            ULONG nameSize, nameOffset, nameFlags;
            ULONG_PTR nameInfo;
            UNICODE_STRING name;
            UNICODE_STRING nullUnicodeString;
            BOOLEAN addRefPDO;

            //
            // Make sure that the required parts of the WMILIB_INFO structure
            // are filled in.
            ASSERT(WmiLibInfo->QueryWmiRegInfo != NULL);

            name.Buffer = NULL;
            name.Length = 0;
            name.MaximumLength = 0;
    
            mofResourceName.Buffer = NULL;
            mofResourceName.Length = 0;
            mofResourceName.MaximumLength = 0;
    
            nameFlags = 0;
            status = WmiLibInfo->QueryWmiRegInfo(
                                                    DeviceObject,
                                                    &nameFlags,
                                                    &name,
                                                    &regPath,
                                                    &mofResourceName,
                                                    &pdo);

            if (NT_SUCCESS(status) &&
                (! (nameFlags &  WMIREG_FLAG_INSTANCE_PDO) &&
                (name.Buffer == NULL)))
            {
                //
                // if PDO flag not specified then an instance name must be
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

#if DBG
            if (nameFlags &  WMIREG_FLAG_INSTANCE_PDO)
            {
                ASSERT(pdo != NULL);
            }
#endif
            if (NT_SUCCESS(status))
            {
                ASSERT(WmiLibInfo->GuidList != NULL);

                guidList = WmiLibInfo->GuidList;
                guidCount = WmiLibInfo->GuidCount;

                nameOffset = sizeof(WMIREGINFO) +
                                      guidCount * sizeof(WMIREGGUIDW);

                addRefPDO = FALSE;
                if (nameFlags & WMIREG_FLAG_INSTANCE_PDO)
                {
                    nameSize = 0;
                    nameInfo = (UINT_PTR)pdo;
                    if (minorFunction == IRP_MN_REGINFO_EX)
                    {
                        addRefPDO = TRUE;
                    }
                } else {
                    if ((nameFlags & WMIREG_FLAG_INSTANCE_BASENAME) == 0)
                    {
                        nameFlags |= WMIREG_FLAG_INSTANCE_LIST;
                    }
                    nameSize = name.Length + sizeof(USHORT);
                    nameInfo = nameOffset;
                }

                nullUnicodeString.Buffer = NULL;
                nullUnicodeString.Length = 0;
                nullUnicodeString.MaximumLength = 0;
                
                if (regPath == NULL)
                {
                    //
                    // No registry path specified. This is a bad thing for
                    // the device to do, but is not fatal
#if DBG
                    KdPrint(("WMI: No registry path specified for device %x\n",
                             DeviceObject));
#endif
                    regPath = &nullUnicodeString;
                }
        
                mofResourceOffset = nameOffset + nameSize;

                registryPathOffset = mofResourceOffset +
                                     mofResourceName.Length + sizeof(USHORT);

                bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

                if (bufferNeeded <= bufferSize)
                {
                    retSize = bufferNeeded;

                    wmiRegInfo = (PWMIREGINFO)buffer;
                    wmiRegInfo->BufferSize = bufferNeeded;
                    wmiRegInfo->NextWmiRegInfo = 0;
                    wmiRegInfo->MofResourceName = mofResourceOffset;
                    wmiRegInfo->RegistryPath = registryPathOffset;
                    wmiRegInfo->GuidCount = guidCount;

                    for (i = 0; i < guidCount; i++)
                    {
                        wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                        wmiRegGuid->Guid = *guidList[i].Guid;
                        wmiRegGuid->Flags = guidList[i].Flags | nameFlags;
                        wmiRegGuid->InstanceInfo = nameInfo;
                        wmiRegGuid->InstanceCount = guidList[i].InstanceCount;
                        if (addRefPDO)
                        {
                            ObReferenceObject(pdo);
                        }
                    }

                    if ( nameFlags &  (WMIREG_FLAG_INSTANCE_LIST |
                                       WMIREG_FLAG_INSTANCE_BASENAME))
                    {
                        stringPtr = (PWCHAR)((PUCHAR)buffer + nameOffset);
                        *stringPtr++ = name.Length;
                        RtlCopyMemory(stringPtr,
                                  name.Buffer,
                                  name.Length);
                    }

                    stringPtr = (PWCHAR)((PUCHAR)buffer + mofResourceOffset);
                    *stringPtr++ = mofResourceName.Length;
                    RtlCopyMemory(stringPtr,
                                  mofResourceName.Buffer,
                                  mofResourceName.Length);

                    stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                    *stringPtr++ = regPath->Length;
                    RtlCopyMemory(stringPtr,
                              regPath->Buffer,
                              regPath->Length);
                } else {
                    *((PULONG)buffer) = bufferNeeded;
                    retSize = sizeof(ULONG);
                }
            } else {
                retSize = 0;
            }

            if (name.Buffer != NULL)
            {
                ExFreePool(name.Buffer);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            *IrpDisposition = IrpNotCompleted;
            return(status);
        }

        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            ULONG bufferAvail;
            PULONG instanceLengthArray;
            PUCHAR dataBuffer;
            ULONG instanceLengthArraySize;
            ULONG dataBlockOffset;

            ASSERT(WmiLibInfo->QueryWmiDataBlock != NULL);

            wnode = (PWNODE_ALL_DATA)buffer;

            if (bufferSize < sizeof(WNODE_ALL_DATA))
            {
                //
                // The buffer should never be smaller than the size of
                // WNODE_ALL_DATA, however if it is then return with an
                // error requesting the minimum sized buffer.
                ASSERT(FALSE);

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;

                break;
            }

            wnode->InstanceCount = instanceCount;

            wnode->WnodeHeader.Flags &= ~WNODE_FLAG_FIXED_INSTANCE_SIZE;

            instanceLengthArraySize = instanceCount * sizeof(OFFSETINSTANCEDATAANDLENGTH);

            dataBlockOffset = (FIELD_OFFSET(WNODE_ALL_DATA, OffsetInstanceDataAndLength) + instanceLengthArraySize + 7) & ~7;

            wnode->DataBlockOffset = dataBlockOffset;
            if (dataBlockOffset <= bufferSize)
            {
                instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
                dataBuffer = buffer + dataBlockOffset;
                bufferAvail = bufferSize - dataBlockOffset;
            } else {
                //
                // There is not enough room in the WNODE to complete
                // the query
                instanceLengthArray = NULL;
                dataBuffer = NULL;
                bufferAvail = 0;
            }

            status = WmiLibInfo->QueryWmiDataBlock(
                                             DeviceObject,
                                             Irp,
                                             guidIndex,
                                             0,
                                             instanceCount,
                                             instanceLengthArray,
                                             bufferAvail,
                                             dataBuffer);
            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            ULONG dataBlockOffset;

            ASSERT(WmiLibInfo->QueryWmiDataBlock != NULL);
            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            dataBlockOffset = wnode->DataBlockOffset;

            status = WmiLibInfo->QueryWmiDataBlock(
                                          DeviceObject,
                                          Irp,
                                          guidIndex,
                                          instanceIndex,
                                          1,
                                          &wnode->SizeDataBlock,
                                          bufferSize - dataBlockOffset,
                                          (PUCHAR)wnode + dataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;

            if (WmiLibInfo->SetWmiDataBlock != NULL)
            {
                wnode = (PWNODE_SINGLE_INSTANCE)buffer;

                status = WmiLibInfo->SetWmiDataBlock(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->SizeDataBlock,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);
            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = /*STATUS_WMI_READ_ONLY*/ STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }


            break;
        }

        case IRP_MN_CHANGE_SINGLE_ITEM:
        {
            PWNODE_SINGLE_ITEM wnode;

            if (WmiLibInfo->SetWmiDataItem != NULL)
            {
                wnode = (PWNODE_SINGLE_ITEM)buffer;

                status = WmiLibInfo->SetWmiDataItem(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     instanceIndex,
                                     wnode->ItemId,
                                     wnode->SizeDataItem,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            } else {
                //
                // If set callback is not filled in then it must be readonly
                status = /*STATUS_WMI_READ_ONLY*/  STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;

            if (WmiLibInfo->ExecuteWmiMethod != NULL)
            {
                wnode = (PWNODE_METHOD_ITEM)buffer;

                status = WmiLibInfo->ExecuteWmiMethod(
                                         DeviceObject,
                                         Irp,
                                         guidIndex,
                                         instanceIndex,
                                         wnode->MethodId,
                                         wnode->SizeDataBlock,
                                         bufferSize - wnode->DataBlockOffset,
                                         buffer + wnode->DataBlockOffset);

            } else {
                //
                // If method callback is not filled in then it must be error
                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }

            break;
        }

        case IRP_MN_ENABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventControl,
                                                           TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_EVENTS:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           WmiEventControl,
                                                           FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockControl,
                                                         TRUE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        case IRP_MN_DISABLE_COLLECTION:
        {
            if (WmiLibInfo->WmiFunctionControl != NULL)
            {
                status = WmiLibInfo->WmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         WmiDataBlockControl,
                                                         FALSE);
            } else {
                //
                // If callback is not filled in then just succeed
                status = STATUS_SUCCESS;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                *IrpDisposition = IrpNotCompleted;
            }
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            *IrpDisposition = IrpNotCompleted;
            break;
        }

    }

    return(status);
}

NTSTATUS
WmiCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    )
/*++

Routine Description:


    This routine will do the work of completing a WMI irp. Depending upon the
    the WMI request this routine will fixup the returned WNODE appropriately.

    This may be called at DPC level
Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

    Status has the return status code for the IRP

    BufferUsed has the number of bytes needed by the device to return the
       data requested in any query. In the case that the buffer passed to
       the device is too small this has the number of bytes needed for the
       return data. If the buffer passed is large enough then this has the
       number of bytes actually used by the device.

    PriorityBoost is the value used for the IoCompleteRequest call.

Return Value:

    status

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    UCHAR MinorFunction;
    PUCHAR buffer;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG bufferSize;

    minorFunction = irpStack->MinorFunction;
    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    switch(minorFunction)
    {
        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;
            ULONG instanceCount;
            POFFSETINSTANCEDATAANDLENGTH offsetInstanceDataAndLength;
            ULONG i;
            PULONG instanceLengthArray;
            ULONG dataBlockOffset;

            wnode = (PWNODE_ALL_DATA)buffer;

            dataBlockOffset = wnode->DataBlockOffset;
            instanceCount = wnode->InstanceCount;
            bufferNeeded = dataBlockOffset + BufferUsed;

            if ((NT_SUCCESS(Status)) &&
                (bufferNeeded > irpStack->Parameters.WMI.BufferSize))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        
            if (! NT_SUCCESS(Status))
            {
                if (Status == STATUS_BUFFER_TOO_SMALL)
                {
                    wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                    wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                    wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                    wnodeTooSmall->SizeNeeded = bufferNeeded;

                    retSize = sizeof(WNODE_TOO_SMALL);
                    Status = STATUS_SUCCESS;
                } else {
                    retSize = 0;
                }
                break;
            }

            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

            instanceLengthArray = (PULONG)&wnode->OffsetInstanceDataAndLength[0];
            offsetInstanceDataAndLength = (POFFSETINSTANCEDATAANDLENGTH)instanceLengthArray;

            wnode->WnodeHeader.BufferSize = bufferNeeded;
            retSize = bufferNeeded;

            for (i = instanceCount; i != 0; i--)
            {
                offsetInstanceDataAndLength[i-1].LengthInstanceData = instanceLengthArray[i-1];
            }

            for (i = 0; i < instanceCount; i++)
            {
                offsetInstanceDataAndLength[i].OffsetInstanceData = dataBlockOffset;
                dataBlockOffset = (dataBlockOffset + offsetInstanceDataAndLength[i].LengthInstanceData + 7) & ~7;
            }

            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

                ASSERT(wnode->SizeDataBlock <= BufferUsed);

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_METHOD_ITEM)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        default:
        {
            //
            // All other requests don't return any data
            retSize = 0;
            break;
        }

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = retSize;
    IoCompleteRequest(Irp, PriorityBoost);
    return(Status);
}

NTSTATUS
WmiFireEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    )
/*++

Routine Description:

    This routine will fire a WMI event using the data buffer passed. This
    routine may be called at or below DPC level

Arguments:

    DeviceObject - Supplies a pointer to the device object for this event

    Guid is pointer to the GUID that represents the event

    InstanceIndex is the index of the instance of the event

    EventDataSize is the number of bytes of data that is being fired with
       with the event

    EventData is the data that is fired with the events. This may be NULL
        if there is no data associated with the event


Return Value:

    status

--*/
{

    ULONG sizeNeeded;
    PWNODE_SINGLE_INSTANCE event;
    NTSTATUS status;

    if (EventData == NULL)
    {
        EventDataSize = 0;
    }

    sizeNeeded = sizeof(WNODE_SINGLE_INSTANCE) + EventDataSize;

    event = ExAllocatePoolWithTag(NonPagedPool, sizeNeeded, WMILIBPOOLTAG);
    if (event != NULL)
    {
        event->WnodeHeader.Guid = *Guid;
        event->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(DeviceObject);
        event->WnodeHeader.BufferSize = sizeNeeded;
        event->WnodeHeader.Flags =  WNODE_FLAG_SINGLE_INSTANCE |
                                    WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_STATIC_INSTANCE_NAMES;
        KeQuerySystemTime(&event->WnodeHeader.TimeStamp);

        event->InstanceIndex = InstanceIndex;
        event->SizeDataBlock = EventDataSize;
        event->DataBlockOffset = sizeof(WNODE_SINGLE_INSTANCE);
        if (EventData != NULL)
        {
            RtlCopyMemory( &event->VariableData, EventData, EventDataSize);
            ExFreePool(EventData);
        }

        status = IoWMIWriteEvent(event);
        if (! NT_SUCCESS(status))
        {
            ExFreePool(event);
        }
        
    } else {
        if (EventData != NULL)
        {
            ExFreePool(EventData);
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\nabtsfec\wdm\wdmioctl.h ===
#ifndef _WDMIOCTL
#define _WDMIOCTL

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

#include <devioctl.h>

//
// Enumerate base functions
//

typedef enum {
    RECEIVE_DATA,
    MAX_IOCTLS
    };



//
// Internal IOCTLs for communication between WSHBPC and the BPC Transport.
//

#define FSCTL_NAB_BASE     FILE_DEVICE_NETWORK

#define _NAB_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_NAB_BASE, function, method, access)


//
// Incoming data IoCtl.
//

#define IOCTL_NAB_RECEIVE_DATA \
    _NAB_CTL_CODE(RECEIVE_DATA, METHOD_OUT_DIRECT, FILE_WRITE_ACCESS)

// Structure passed for IOCTL_NAB_RECEIVE_DATA
typedef struct _NABDATA {
    ULONG ulStreamId;
    PVOID pvIn;
    ULONG ulIn;
} NAB_DATA, *PNAB_DATA;


#ifdef __cplusplus
} // end - extern "C"
#endif /*__cplusplus*/

#endif // _WDMIOCTL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\vbi\tests\testfec\testfec.cpp ===
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <windows.h>
#include <wincon.h>

#include <nabtsfec.h>

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

#define CONCURRENT_READS    180 
#define READ_BUFFER_SIZE    sizeof(NABTSFEC_BUFFER)

/* Update statistics every n milliseconds (16ms is generally too fast) */
#define UPDATE_PERIOD       200

unsigned int
atox( char *pszInput )
{
const int       HEX = 16;
const int       DECIMAL = 10;
const int       OCTAL = 8;

char            *psz = pszInput;
int             radix = DECIMAL;
unsigned int    value = 0;

if ( psz )
    {
    if ( *psz == '0' )
        {
        ++psz;
        if ( *psz == 'x' || *psz == 'X' )
            {
            ++psz;
            radix = HEX;
            }
        else
            {
            radix = OCTAL;
            }
        }

    while ( *psz )
        {
        switch ( radix )
            {
            case    HEX:
                *psz = (char)toupper( *psz );
                if ( *psz == 'A' || *psz == 'B' || *psz == 'C' 
                  || *psz == 'D' || *psz == 'E' || *psz == 'F' )
                    {
                    value *= radix;
                    value += *psz++ - 'A' + 10;
                    continue;
                    }
            case    DECIMAL:
                if ( *psz == '8' || *psz == '9' )
                    {
                    value *= radix;
                    value += *psz++ - '0';
                    continue;
                    }
            case    OCTAL:
                if ( *psz == '0' || *psz == '1' || *psz == '2' || *psz == '3' 
                  || *psz == '4' || *psz == '5' || *psz == '6' || *psz == '7' )
                    {
                    value *= radix;
                    value += *psz++ - '0';
                    continue;
                    }
            default:
                printf("Illegal char '%c' found number: '%s'!\n", *psz, radix );
                break;
            }
        }
    }

return value;
}

void
PrintStatistics( INabtsFEC &Driver, int row, int column, BOOL bSavePosition)
{
HANDLE                                  hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
COORD                                   Pos = {(short)row, (short)column};
CONSOLE_SCREEN_BUFFER_INFO              SavedPos;
VBICODECFILTERING_STATISTICS_NABTS      Statistics;
VBICODECFILTERING_STATISTICS_NABTS_PIN  PinStatistics;

if ( Driver.GetCodecStatistics( Statistics ) == 0 
 &&  Driver.GetPinStatistics( PinStatistics ) == 0)
    {
    char    szBuffer[13][128] = { 0 };
    if ( bSavePosition )
        GetConsoleScreenBufferInfo( hStdout, &SavedPos );

    SetConsoleCursorPosition( hStdout, Pos );
    
    sprintf(szBuffer[0], "-------------------------- NABTS Codec Statistics -----------------------------");
    sprintf(szBuffer[1], "InputSRBsProcessed: %u, OutputSRBsProcessed: %u, SRBsIgnored: %u",
            Statistics.Common.InputSRBsProcessed, Statistics.Common.OutputSRBsProcessed, Statistics.Common.SRBsIgnored );
    sprintf(szBuffer[2], "InputSRBsMissing: %u, OutputSRBsMissing: %u, OutputFailures: %u", 
            Statistics.Common.InputSRBsMissing, Statistics.Common.OutputSRBsMissing, Statistics.Common.OutputFailures );
    sprintf(szBuffer[3], "InternalErrors: %u, ExternalErrors: %u, InputDiscontinuities: %u",
            Statistics.Common.InternalErrors, Statistics.Common.ExternalErrors, Statistics.Common.InputDiscontinuities );
    sprintf(szBuffer[4], "DSPFailures: %u, TvTunerChanges: %u, VBIHeaderChanges: %u",
            Statistics.Common.DSPFailures, Statistics.Common.TvTunerChanges, Statistics.Common.VBIHeaderChanges );
    sprintf(szBuffer[5], "LineConfidenceAvg: %u, BytesOutput: %u, FECBundleBadLines: %u",
            Statistics.Common.LineConfidenceAvg, Statistics.Common.BytesOutput, Statistics.FECBundleBadLines );
    sprintf(szBuffer[6], "FECQueueOverflows: %u, FECCorrectedLines: %u, FECUncorrectableLines: %u",
            Statistics.FECQueueOverflows, Statistics.FECCorrectedLines, Statistics.FECUncorrectableLines );
    sprintf(szBuffer[7], "BundlesProcessed: %u, BundlesSent2IP: %u, FilteredLines: %u",
            Statistics.BundlesProcessed, Statistics.BundlesSent2IP, Statistics.FilteredLines );
    sprintf(szBuffer[8], "---------------------------- FEC Pin Statistics -------------------------------");
    sprintf(szBuffer[9], "SRBsProcessed: %u, SRBsMissing: %u, SRBsIgnored: %u",
            PinStatistics.Common.SRBsProcessed, PinStatistics.Common.SRBsMissing, PinStatistics.Common.SRBsIgnored );
    sprintf(szBuffer[10], "InternalErrors: %u, ExternalErrors: %u, Discontinuities: %u",
            PinStatistics.Common.InternalErrors, PinStatistics.Common.ExternalErrors, PinStatistics.Common.Discontinuities );
    sprintf(szBuffer[11], "LineConfidenceAvg: %u, BytesOutput: %u", 
            PinStatistics.Common.LineConfidenceAvg, PinStatistics.Common.BytesOutput );
    sprintf(szBuffer[12], "===============================================================================");

    printf("%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n%-79.79s\n",
            szBuffer[0], szBuffer[1], szBuffer[2], szBuffer[3], szBuffer[4], 
            szBuffer[5], szBuffer[6], szBuffer[7], szBuffer[8], szBuffer[9],
            szBuffer[10], szBuffer[11], szBuffer[12] );

    if ( bSavePosition )
        SetConsoleCursorPosition( hStdout, SavedPos.dwCursorPosition );
    }
}

int __cdecl
main( int argc, char *argv[] )
{
int	        nStatus = 0;
int         arg = 1; // Next unparsed command line parameter
const int   bPrintHelp = arg < argc && 
            ( strcmp( argv[arg], "-h" ) || strcmp( argv[arg], "-h" ) ) == 0 ? arg++ : 0;
const int   bStatistics = arg < argc && strcmp( argv[arg], "-s" ) == 0 ? arg++ : 0;
long        nLastUpdate = 0;
int         nSubstream = -1;

if ( !bPrintHelp )
    {
    try {
        INabtsFEC	Driver;
        if ( Driver.IsValid() )
            {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );

            if ( bStatistics )
                PrintStatistics( Driver, 0, 0, FALSE );

            if ( arg < argc )
                {
                if ( ( nStatus = Driver.ClearRequestedGroups() ) == 0 )
                    {
                    do
                        {
                        if ( !(nSubstream = atox( argv[arg] ) ) )
                            printf( "Invalid substream: '%s'\n", argv[arg] );
                        printf( "GroupID:0x%03X ", nSubstream );
                        if ( ( nStatus = Driver.AddRequestedGroup(nSubstream) ) != 0 )
                            {
                            fprintf( stderr, "\nFailed to AddRequestedGroups(%d)=%d\n", nSubstream, nStatus );
                            return nStatus;
                            }
                        }
                    while ( ++arg < argc );
                    }
                else
                    {
                    fprintf( stderr, "\nFailed to ClearRequestedGroups()=%d\n", nStatus );
                    return nStatus;
                    }
                printf("\n");
                }
            else
                printf( "Using default GroupIDs\n" );

            int                 nNextRead = 0;
            DWORD               nBytes = 0;
            OVERLAPPED          Overlapped[CONCURRENT_READS] = {0};
            NABTSFEC_BUFFER		NabtsFECBuffer[CONCURRENT_READS];

            for( nNextRead = 0; !nStatus && nNextRead < CONCURRENT_READS; nNextRead++ )
	            {
	            if ( !( Overlapped[nNextRead].hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ) ) )
                    {
                    nStatus = GetLastError();
                    break;
                    }
                nStatus = Driver.ReadData( NabtsFECBuffer+nNextRead, READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );

                if ( !nStatus || nStatus == ERROR_IO_PENDING )
                    nStatus = 0;
                else
                    break;
                }
            nNextRead = 0;

            while ( !nStatus && !_kbhit() )
                {
                if ( !(nStatus = Driver.GetOverlappedResult(Overlapped+nNextRead, &nBytes, FALSE ) ) )
                    {
		            nBytes = min(nBytes, READ_BUFFER_SIZE);

                    printf("[%03X]", NabtsFECBuffer[nNextRead].groupID );
                    nStatus = Driver.ReadData( NabtsFECBuffer+nNextRead, READ_BUFFER_SIZE, &nBytes, Overlapped + nNextRead );
        
                    if ( !nStatus  || nStatus == ERROR_IO_PENDING )
                        {
                        nNextRead = ++nNextRead % CONCURRENT_READS;
                        nStatus = 0;
                        }
                    }
                else if ( nStatus == ERROR_IO_INCOMPLETE || nStatus == ERROR_IO_PENDING )
                    {
                    Sleep(10); // Chill out a few milliseconds so we don't run full tilt.
                    nStatus = 0;
                    }

                if ( bStatistics && GetTickCount()-nLastUpdate > UPDATE_PERIOD )
                    {
                    PrintStatistics( Driver, 0, 0, TRUE );
                    nLastUpdate = GetTickCount();
                    }
                }
            }
        }
    catch (...)
        {
        nStatus = GetLastError();
        }
    }
else
    printf( "Syntax: TESTNAB [-s] [ substream1 [substream2] ]\n" );

if ( nStatus )
    fprintf( stderr, "Program failed with LastErrorCode=%d!\n", nStatus );

return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\sources.inc ===
!IF "$(ADSI_NT40_BUILD)" == "1"
!INCLUDE ..\common\sources.40
!INCLUDE adsi40.mk
!ELSE IF "$(ADSI_PROFILE_BUILD)" == "1"
!INCLUDE ..\common\sources.prf
!ELSE
!INCLUDE ..\common\sources
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\caiheap.h ===
//+---------------------------------------------------------------------------
//  File:       caiheap.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//              in commnot
//
//  History:    28-Oct-92   IsaacHe     Created
//
//----------------------------------------------------------------------------

#ifndef _CAIHEAP_H_
#define _CAIHEAP_H_

//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26                 // depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
        DWORD   sum;            // checksum of stack backtrace
        void *fTrace[ DEPTHTRACE ];     // stack backtrace
        DWORD   count;          // # of un-freed allocs from this place
        size_t  bytes;          // # of un-freed bytes from this place
        struct AllocArena *paa; // points back to the beginning...
        struct {
                DWORD   count;  // # of allocs from this place
                size_t  bytes;  // # of bytes from this place
        } total;
        union {
                struct HeapAllocRec *next; // next bucket in the hash list
                void *ImageBase;        // base addr of containing module
        } u;
};

struct AllocArena {

        char Signature [ sizeof(HEAPSIG) ];
        char comment[ 32 ];
        CRITICAL_SECTION csExclusive;   // ensures single writer

        struct {
                int KeepStackTrace:1;   // are stack records being kept?
        } flags;

        ULONG cAllocs;                  // # of non zero Alloc calls
        ULONG czAllocs;                 // # of Alloc calls w/zero count
        ULONG cFrees;                   // # of Free calls
        ULONG cReAllocs;                // # of realloc calls
        ULONG cMissed;                  // # of missed stack backtraces
        ULONG cRecords;                 // index of next free AllocRec entry
        ULONG cBytesNow;                // # of bytes currently allocated
        ULONG cBytesTotal;              // # of bytes ever allocated
        ULONG cTotalRecords;            // Total # of AllocRecs
        ULONG cPaths;                   // # of distinct allocation paths

        struct {
                ULONG total[ 32 ];      // total number of allocations
                ULONG now[ 32 ];        // current # of simul allocs
                ULONG simul[ 32 ];      // highest # of simul allocs
        } Histogram;

        struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
        struct HeapAllocRec FAR *p;
        size_t size;
};

STDAPI_(struct AllocArena ** )
AllocArenaAddr( void );

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
                        size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp );

#endif  // ifndef _CAIHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\heapstat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Heapstats.hxx
//
//  Contents:   Structure that holds heap statistics.
//
//  Classes:    HEAPSTATS
//
//  History:    26-Oct-93 DavidBak      Created
//
//--------------------------------------------------------------------------

#if !defined(__HEAPSTAT_HXX__)
#define __HEAPSTAT_HXX__

#if (PERFSNAP == 1) || (DBG == 1)

//+-------------------------------------------------------------------------
//
//  Class:      HEAPSTATS
//
//  Purpose:    Data structure containing performance counters from the heap.
//              Used in our version of operator new.
//              See common\src\except\memory.cxx.
//
//--------------------------------------------------------------------------

typedef struct _HeapStats
{
    ULONG	cNew;
    ULONG	cZeroNew;
    ULONG	cDelete;
    ULONG	cZeroDelete;
    ULONG	cRealloc;
    ULONG       cbNewed;
    ULONG       cbDeleted;
} HEAPSTATS;

//
// GetHeapStats is in memory.cxx
//

#ifdef __cplusplus
extern "C" {
#endif

void GetHeapStats(HEAPSTATS * hsStats);

#ifdef __cplusplus
}
#endif


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocADsMem(
    DWORD cb
);

BOOL
FreeADsMem(
   LPVOID pMem
);

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocADsStr(
    LPCWSTR pStr
);

BOOL
FreeADsStr(
   LPWSTR pStr
);


BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitADsMem(
    VOID
    ) ;

VOID AssertADsMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitADsMem()
#define AssertADsMemLeaks()

#define DumpMemoryTracker()



#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\dswarn.h ===
#include <warning.h>

#pragma warning (disable: 4101 4201 4100 4244 4245 4706 4786 4267 4701 4115 4509 4214 4057 4127 4189 4702)

#pragma warning (disable:  4514 4512 4663)

/**************************************************************************

DESCRIPTION OF WARNINGS THAT ARE DISABLED

4101  unreferenced local variable

*4201  nonstandard extension: nameless struct or union

*4214  non standard extension: bit field types other than int

*4115  named type definition in paranthesis -- does not like THSTATE

*4127  conditional expression is a constant

4100  ureferenced formal parameter

*4189  local variable is initialized but not referenced 

*4057 slightly different base types -- char * and unsigned char *

4244 conversion from into to char --loss of data -- I saw a few of these and disabled in an effort to get the code to compile -- need further investigation.

4245 conversion from long to unsigned long -- signed/unsigned mismatch

*4509 non standard extension used -- uses SEH and has destructor

4706 assignment within a conditional expression

4702  *unreacheable code

*4701  var used before initializing

4786  identifier truncated to 255 chars in debug information

4267  Signal to noise ratio of this warning is pretty poor -- too many 
      '=' conversion from size_t to unsigned long, possible loss of data
      The problem is that size_t in 64 bit is defined as a 64 bit int,
      while ulong is still a 32 bit int. In practice most places this is
      used -- e.g sizeof operator, or string len etc the value will fit 
      in a 32 bit ULONG

4514 unreferenced inline function has been removed

4512 assignment operator could not be generated

4663 C++ language change: to explicitly specialize class template 'identifier' use the following syntax

VALID WARNINGS ENCOUNTERED 

( 4267, 4701, 4702 and 4706 can also be included in
this list if desired )

4306 TypeCast -- conversion from unsigned short to unsigned short *

4305 Typecase -- truncation from unsigned short * to unsigned short

4312 TypeCase -- Conversion from unsigned long to void * __ptr64 of greater size



****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\formdeb.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       formdeb.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//              08-Aug-94   DonCl       copied from cinc and renamed formdeb.h
//
//----------------------------------------------------------------------------

#ifndef __FORMDEB_H__
#define __FORMDEB_H__
#define __DEBNOT_H__    // keep debnot.h from being included accidentally

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
 #include <windef.h>
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Assert(x)      \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif



//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Assert(x)      NULL
# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\adstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:
//
//  Contents:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#ifndef _ADSTYPE_H_INCLUDED_
#define _ADSTYPE_H_INCLUDED_

typedef enum {
   ADSTYPE_INVALID = 0,
   ADSTYPE_DN_STRING,
   ADSTYPE_CASE_EXACT_STRING,
   ADSTYPE_CASE_IGNORE_STRING,
   ADSTYPE_PRINTABLE_STRING,
   ADSTYPE_NUMERIC_STRING,
   ADSTYPE_BOOLEAN,
   ADSTYPE_INTEGER,
   ADSTYPE_OCTET_STRING,
   ADSTYPE_UTC_TIME,
   ADSTYPE_LARGE_INTEGER,
   ADSTYPE_PROV_SPECIFIC,
   ADSTYPE_OBJECT_CLASS,
   ADSTYPE_CASEIGNORE_LIST,
   ADSTYPE_OCTET_LIST,
   ADSTYPE_PATH,
   ADSTYPE_POSTALADDRESS,
   ADSTYPE_TIMESTAMP,
   ADSTYPE_BACKLINK,
   ADSTYPE_TYPEDNAME,
   ADSTYPE_HOLD,
   ADSTYPE_NETADDRESS,
   ADSTYPE_REPLICAPOINTER,
   ADSTYPE_FAXNUMBER,
   ADSTYPE_EMAIL,
   ADSTYPE_NT_SECURITY_DESCRIPTOR,
   ADSTYPE_UNKNOWN,
   ADSTYPE_DN_WITH_BINARY,
   ADSTYPE_DN_WITH_STRING
} ADSTYPEENUM;
typedef ADSTYPEENUM ADSTYPE;

//
// ADSTYPE_UNKNOWN was added to the end to be save and not break anyone.
// If further types are added, this will be in the middle which is not
// the best position but nonethesless functional.
//


typedef unsigned char BYTE, *LPBYTE, *PBYTE;


//
// ADS Case DN String syntax
//

typedef LPWSTR ADS_DN_STRING, * PADS_DN_STRING;

//
// ADS Case Exact String syntax
//

typedef LPWSTR ADS_CASE_EXACT_STRING, * PADS_CASE_EXACT_STRING;

//
// ADS Case Ignore String syntax
//

typedef LPWSTR ADS_CASE_IGNORE_STRING, *PADS_CASE_IGNORE_STRING;

//
// ADS Printable String syntax
//

typedef LPWSTR ADS_PRINTABLE_STRING, *PADS_PRINTABLE_STRING;

//
// ADS Numeric String syntax
//
//

typedef LPWSTR ADS_NUMERIC_STRING, *PADS_NUMERIC_STRING;


//
// ADS Boolean syntax
//

typedef DWORD ADS_BOOLEAN, * LPNDS_BOOLEAN;

//
// Example: ADS Integer syntax
//

typedef DWORD ADS_INTEGER, *PADS_INTEGER;

//
// ADS Octet String syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_OCTET_STRING, *PADS_OCTET_STRING;


//
// ADS NT Security Descriptor syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_NT_SECURITY_DESCRIPTOR, *PADS_NT_SECURITY_DESCRIPTOR;


//
// ADS UTC Time Syntax
//

typedef SYSTEMTIME ADS_UTC_TIME, *PADS_UTC_TIME;


typedef LARGE_INTEGER ADS_LARGE_INTEGER, *PADS_LARGE_INTEGER;



//
// ADS ClassName syntax
//

typedef LPWSTR  ADS_OBJECT_CLASS, *PADS_OBJECT_CLASS;

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_PROV_SPECIFIC, *PADS_PROV_SPECIFIC;

//
// Extended Syntaxes for NDS
//
typedef struct _ADS_CASEIGNORE_LIST
{
    struct _ADS_CASEIGNORE_LIST *Next;
    LPWSTR            String;

}
ADS_CASEIGNORE_LIST, *PADS_CASEIGNORE_LIST;


typedef struct _ADS_OCTET_LIST
{
    struct _ADS_OCTET_LIST *Next;
    DWORD  Length;
    BYTE * Data;

} ADS_OCTET_LIST, *PADS_OCTET_LIST;

typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ADS_PATH, *PADS_PATH;

typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ADS_POSTALADDRESS, *PADS_POSTALADDRESS;

typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ADS_TIMESTAMP, *PADS_TIMESTAMP;

typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ADS_BACKLINK, *PADS_BACKLINK;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ADS_TYPEDNAME, *PADS_TYPEDNAME;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ADS_HOLD, *PADS_HOLD;

typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ADS_NETADDRESS, *PADS_NETADDRESS;

typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    PADS_NETADDRESS ReplicaAddressHints;
} ADS_REPLICAPOINTER, *PADS_REPLICAPOINTER;

typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;
} ADS_FAXNUMBER, *PADS_FAXNUMBER;

typedef struct
{
    LPWSTR Address;
    DWORD  Type;
} ADS_EMAIL, *PADS_EMAIL;

typedef struct
{
    DWORD dwLength;
    LPBYTE lpBinaryValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_BINARY, *PADS_DN_WITH_BINARY;

typedef struct
{
    LPWSTR pszStringValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_STRING, *PADS_DN_WITH_STRING;


typedef struct _adsvalue{
   ADSTYPE dwType;
   union {
      ADS_DN_STRING                     DNString;
      ADS_CASE_EXACT_STRING             CaseExactString;
      ADS_CASE_IGNORE_STRING            CaseIgnoreString;
      ADS_PRINTABLE_STRING              PrintableString;
      ADS_NUMERIC_STRING                NumericString;
      ADS_BOOLEAN                       Boolean;
      ADS_INTEGER                       Integer;
      ADS_OCTET_STRING                  OctetString;
      ADS_UTC_TIME                      UTCTime;
      ADS_LARGE_INTEGER                 LargeInteger;
      ADS_OBJECT_CLASS                  ClassName;
      ADS_PROV_SPECIFIC                 ProviderSpecific;
      PADS_CASEIGNORE_LIST              pCaseIgnoreList;
      PADS_OCTET_LIST                   pOctetList;
      PADS_PATH                         pPath;
      PADS_POSTALADDRESS                pPostalAddress;
      ADS_TIMESTAMP                     Timestamp;
      ADS_BACKLINK                      BackLink;
      PADS_TYPEDNAME                    pTypedName;
      ADS_HOLD                          Hold;
      PADS_NETADDRESS                   pNetAddress;
      PADS_REPLICAPOINTER               pReplicaPointer;
      PADS_FAXNUMBER                    pFaxNumber;
      ADS_EMAIL                         Email;
      ADS_NT_SECURITY_DESCRIPTOR        SecurityDescriptor;
      PADS_DN_WITH_BINARY               pDNWithBinary;
      PADS_DN_WITH_STRING               pDNWithString;
   };
}ADSVALUE, *PADSVALUE, *LPADSVALUE;

typedef struct _ads_attr_info{
    LPWSTR  pszAttrName;
    DWORD   dwControlCode;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD   dwNumValues;
} ADS_ATTR_INFO, *PADS_ATTR_INFO;

typedef enum {
    ADS_SECURE_AUTHENTICATION = 0x00000001,
    ADS_USE_ENCRYPTION        = 0x00000002,
    ADS_USE_SSL               = 0x00000002,
    ADS_READONLY_SERVER       = 0x00000004,
    ADS_PROMPT_CREDENTIALS    = 0x00000008,
    ADS_NO_AUTHENTICATION     = 0x00000010,
    ADS_FAST_BIND             = 0x00000020,
    ADS_USE_SIGNING           = 0x00000040,
    ADS_USE_SEALING           = 0x00000080,
    ADS_USE_DELEGATION        = 0x00000100,
    ADS_SERVER_BIND           = 0x00000200,
    ADS_AUTH_RESERVED         = 0x80000000
} ADS_AUTHENTICATION_ENUM;

/* ADS attribute modification operations */

const int ADS_ATTR_CLEAR          =  1; /* Clear all values from an attribute */
const int ADS_ATTR_UPDATE         =  2; /* Update values on an attribute */
const int ADS_ATTR_APPEND         =  3; /* Append  values to an attribute  */
const int ADS_ATTR_DELETE         =  4; /* Delete values from an attribute  */


typedef struct _ads_object_info{
    LPWSTR pszRDN;
    LPWSTR pszObjectDN;
    LPWSTR pszParentDN;
    LPWSTR pszSchemaDN;
    LPWSTR pszClassName;
} ADS_OBJECT_INFO, *PADS_OBJECT_INFO;

typedef enum {
    ADS_STATUS_S_OK = 0,
    ADS_STATUS_INVALID_SEARCHPREF,
    ADS_STATUS_INVALID_SEARCHPREFVALUE
} ADS_STATUSENUM;

typedef ADS_STATUSENUM ADS_STATUS, *PADS_STATUS;



typedef enum {
    ADS_DEREF_NEVER           = 0,
    ADS_DEREF_SEARCHING       = 1,
    ADS_DEREF_FINDING         = 2,
    ADS_DEREF_ALWAYS          = 3
} ADS_DEREFENUM;

typedef enum {
    ADS_SCOPE_BASE            = 0,
    ADS_SCOPE_ONELEVEL        = 1,
    ADS_SCOPE_SUBTREE         = 2
} ADS_SCOPEENUM;

// Some more useful enums moved from other places
typedef enum {

    ADSIPROP_ASYNCHRONOUS       =   0x00000000,
    ADSIPROP_DEREF_ALIASES      =   0x00000001,
    ADSIPROP_SIZE_LIMIT         =   0x00000002,
    ADSIPROP_TIME_LIMIT         =   0x00000003,
    ADSIPROP_ATTRIBTYPES_ONLY   =   0x00000004,
    ADSIPROP_SEARCH_SCOPE       =   0x00000005,
    ADSIPROP_TIMEOUT            =   0x00000006,
    ADSIPROP_PAGESIZE           =   0x00000007,
    ADSIPROP_PAGED_TIME_LIMIT   =   0x00000008,
    ADSIPROP_CHASE_REFERRALS    =   0x00000009,
    ADSIPROP_SORT_ON            =   0x0000000a,
    ADSIPROP_CACHE_RESULTS      =   0x0000000b,
    ADSIPROP_ADSIFLAG           =   0x0000000c

} ADS_PREFERENCES_ENUM;


typedef enum {

    ADSI_DIALECT_LDAP     =  0x00000000,
    ADSI_DIALECT_SQL      =  0x00000001

} ADSI_DIALECT_ENUM;

//
// Values for ChaseReferral Option.
typedef enum {

    ADS_CHASE_REFERRALS_NEVER         =  0x00000000,
    ADS_CHASE_REFERRALS_SUBORDINATE   =  0x00000020,
    ADS_CHASE_REFERRALS_EXTERNAL      =  0x00000040,
    ADS_CHASE_REFERRALS_ALWAYS        =
            (ADS_CHASE_REFERRALS_SUBORDINATE | ADS_CHASE_REFERRALS_EXTERNAL)
} ADS_CHASE_REFERRALS_ENUM;

typedef enum {
   ADS_SEARCHPREF_ASYNCHRONOUS,
   ADS_SEARCHPREF_DEREF_ALIASES,
   ADS_SEARCHPREF_SIZE_LIMIT,
   ADS_SEARCHPREF_TIME_LIMIT,
   ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
   ADS_SEARCHPREF_SEARCH_SCOPE,
   ADS_SEARCHPREF_TIMEOUT,
   ADS_SEARCHPREF_PAGESIZE,
   ADS_SEARCHPREF_PAGED_TIME_LIMIT,
   ADS_SEARCHPREF_CHASE_REFERRALS,
   ADS_SEARCHPREF_SORT_ON,
   ADS_SEARCHPREF_CACHE_RESULTS,
   ADS_SEARCHPREF_DIRSYNC,
   ADS_SEARCHPREF_TOMBSTONE,
   ADS_SEARCHPREF_VLV,
   ADS_SEARCHPREF_ATTRIBUTE_QUERY,
   ADS_SEARCHPREF_SECURITY_MASK,
   ADS_SEARCHPREF_DIRSYNC_FLAG,
   ADS_SEARCHPREF_EXTENDED_DN

} ADS_SEARCHPREF_ENUM;

typedef enum {

    ADS_PASSWORD_ENCODE_REQUIRE_SSL         =  0,
    ADS_PASSWORD_ENCODE_CLEAR   =  1
    
} ADS_PASSWORD_ENCODING_ENUM;

typedef ADS_SEARCHPREF_ENUM ADS_SEARCHPREF;

typedef struct ads_searchpref_info{
    ADS_SEARCHPREF dwSearchPref;
    ADSVALUE vValue;
    ADS_STATUS dwStatus;
} ADS_SEARCHPREF_INFO, *PADS_SEARCHPREF_INFO, *LPADS_SEARCHPREF_INFO;


const LPWSTR ADS_DIRSYNC_COOKIE=L"fc8cb04d-311d-406c-8cb9-1ae8b843b418";
const LPWSTR ADS_VLV_RESPONSE  =L"fc8cb04d-311d-406c-8cb9-1ae8b843b419";

typedef HANDLE ADS_SEARCH_HANDLE, *PADS_SEARCH_HANDLE;


typedef struct ads_search_column {
   LPWSTR  pszAttrName;
   ADSTYPE dwADsType;
   PADSVALUE pADsValues;
   DWORD   dwNumValues;
   HANDLE hReserved;
} ADS_SEARCH_COLUMN, *PADS_SEARCH_COLUMN;


typedef struct _ads_attr_def {
   LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    DWORD dwMinRange;
    DWORD dwMaxRange;
    BOOL fMultiValued;
}ADS_ATTR_DEF, *PADS_ATTR_DEF;


typedef struct _ads_class_def {
    LPWSTR pszClassName;
    DWORD  dwMandatoryAttrs;
    LPWSTR *ppszMandatoryAttrs;
    DWORD optionalAttrs;
    LPWSTR **ppszOptionalAttrs;
    DWORD dwNamingAttrs;
    LPWSTR **ppszNamingAttrs;
    DWORD dwSuperClasses;
    LPWSTR **ppszSuperClasses;
    BOOL fIsContainer;
}ADS_CLASS_DEF, *PADS_CLASS_DEF;


typedef struct _ads_sortkey {

    LPWSTR  pszAttrType;
    LPWSTR  pszReserved;
    BOOLEAN fReverseorder;

} ADS_SORTKEY, *PADS_SORTKEY;


typedef struct _ads_vlv {

    DWORD dwBeforeCount;
    DWORD dwAfterCount;
    DWORD dwOffset;
    DWORD dwContentCount;
    LPWSTR pszTarget;
    DWORD  dwContextIDLength;
    LPBYTE lpContextID;
} ADS_VLV, *PADS_VLV;

//
// Valid dispids for extension.
//
// - Max 24 bits.
// - 0 reserved for DISPID_VALUE dealt with by aggregator.
// - DISPID_UNKNOWN (-1) also allowed.
// - Others -ve dispids dealt with by aggregator only.
//

const int ADS_EXT_MINEXTDISPID = 1 ;
const int ADS_EXT_MAXEXTDISPID = 16777215 ;


//
// dwCodes for IADsExtension::Operate
//

const int ADS_EXT_INITCREDENTIALS       = 1 ;
const int ADS_EXT_INITIALIZE_COMPLETE   = 2 ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\svcprov.h ===
#include "rpc.h"
#include "rpcndr.h"

#ifndef __svcprov_h__
#define __svcprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideDBService_FWD_DEFINED__
#define __IProvideDBService_FWD_DEFINED__
typedef interface IProvideDBService IProvideDBService;
#endif 	/* __IProvideDBService_FWD_DEFINED__ */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IProvideDBService_INTERFACE_DEFINED__
#define __IProvideDBService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDBService
 * at Mon Apr 22 16:40:51 1996
 * using MIDL 2.00.72
 ****************************************/
/* [unique][uuid][object][local] */ 

// @msg IID_IProvideDBService | {EFF65380-9C98-11CF-B963-00AA0044773D}
DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideDBService : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ProvideService( 
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider) = 0;
        
    };
    
#else 	/* C style interface */
    
    typedef struct IProvideDBServiceVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideDBService __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideDBService __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ProvideService )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);
        
    } IProvideDBServiceVtbl;
    
    interface IProvideDBService
    {
        CONST_VTBL struct IProvideDBServiceVtbl __RPC_FAR *lpVtbl;
    };
    
    

#ifdef COBJMACROS


#define IProvideDBService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDBService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDBService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDBService_ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)	\
    (This)->lpVtbl -> ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideDBService_ProvideService_Proxy( 
    IProvideDBService __RPC_FAR * This,
    /* [in] */ ULONG cProvidedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
    /* [in] */ ULONG cRequestedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ IUnknown __RPC_FAR *pDataProvider,
    /* [in] */ REFIID riidRequested,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);



void __RPC_STUB IProvideDBService_ProvideService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDBService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\oledsdbg.h ===
//+-------------------------------------------------------------------------
//
// File:      oledsdbg.h
//
// Contains:  Debugging stuff for use by the ADs code
//
// History:
//
//
//--------------------------------------------------------------------------

#ifndef _ADSDBG_H_
#define _ADSDBG_H_
//--------------------------------------------------------------------------
//
// Debugging Stuff
//
//--------------------------------------------------------------------------


#include <formdeb.h>

#if DBG == 1
#define ADsDebugOut(x)  ADsInlineDebugOut x
#define ADsAssert(x)    Win4Assert(x)
#define ADsVerify(x)    ADsAssert(x)

//
// HeapValidate() is only available from NTs kernel32.dll
//

#if defined(DAYTONA)
#define VDATEHEAP()       Win4Assert(HeapValidate(GetProcessHeap(), 0, NULL))
#else
#define VDATEHEAP()
#endif

#else
#define ADsDebugOut(x)
#define ADsAssert(x)
#define ADsVerify(x)    x
#define VDATEHEAP()
#endif


DECLARE_DEBUG(ADs);

#ifdef Assert
#undef Assert
#endif

//
// You should use ADsAssert, not Assert
//
#define Assert(x) ADsAssert(x)

#endif //_ADSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\oledserr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.h

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

Author:


    Ram Viswanathan (ramv) 20-Sep-1996

Environment:

    User Mode - Win32


---*/

#ifndef _OLEDSERR_H_INCLUDED_
#define _OLEDSERR_H_INCLUDED_

#ifdef _cplusplus
extern "C" {
#endif

HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    );

VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPCWSTR  pszError,
    IN  LPCWSTR  pszProvider
    );

VOID
ADsFreeAllErrorRecords(
    VOID
    );

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   dwThreadId;
    DWORD                   dwErrorCode;
    LPWSTR                  pszErrorText;      // This is an allocated buffer
    LPWSTR                  pszProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;



//
// Global Data Structures
//

extern
ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader

extern
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx



//=======================
// MACROS
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;


//
// Local Functions
//

LPERROR_RECORD
ADsAllocErrorRecord(
    VOID);

LPERROR_RECORD
ADsFindErrorRecord(
    VOID);

VOID
ADsFreeThreadErrorRecords(
    VOID);

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\umi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __umi_h__
#define __umi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUmiPropList_FWD_DEFINED__
#define __IUmiPropList_FWD_DEFINED__
typedef interface IUmiPropList IUmiPropList;
#endif 	/* __IUmiPropList_FWD_DEFINED__ */


#ifndef __IUmiBaseObject_FWD_DEFINED__
#define __IUmiBaseObject_FWD_DEFINED__
typedef interface IUmiBaseObject IUmiBaseObject;
#endif 	/* __IUmiBaseObject_FWD_DEFINED__ */


#ifndef __IUmiObject_FWD_DEFINED__
#define __IUmiObject_FWD_DEFINED__
typedef interface IUmiObject IUmiObject;
#endif 	/* __IUmiObject_FWD_DEFINED__ */


#ifndef __IUmiConnection_FWD_DEFINED__
#define __IUmiConnection_FWD_DEFINED__
typedef interface IUmiConnection IUmiConnection;
#endif 	/* __IUmiConnection_FWD_DEFINED__ */


#ifndef __IUmiContainer_FWD_DEFINED__
#define __IUmiContainer_FWD_DEFINED__
typedef interface IUmiContainer IUmiContainer;
#endif 	/* __IUmiContainer_FWD_DEFINED__ */


#ifndef __IUmiCursor_FWD_DEFINED__
#define __IUmiCursor_FWD_DEFINED__
typedef interface IUmiCursor IUmiCursor;
#endif 	/* __IUmiCursor_FWD_DEFINED__ */


#ifndef __IUmiObjectSink_FWD_DEFINED__
#define __IUmiObjectSink_FWD_DEFINED__
typedef interface IUmiObjectSink IUmiObjectSink;
#endif 	/* __IUmiObjectSink_FWD_DEFINED__ */


#ifndef __IUmiURLKeyList_FWD_DEFINED__
#define __IUmiURLKeyList_FWD_DEFINED__
typedef interface IUmiURLKeyList IUmiURLKeyList;
#endif 	/* __IUmiURLKeyList_FWD_DEFINED__ */


#ifndef __IUmiURL_FWD_DEFINED__
#define __IUmiURL_FWD_DEFINED__
typedef interface IUmiURL IUmiURL;
#endif 	/* __IUmiURL_FWD_DEFINED__ */


#ifndef __IUmiQuery_FWD_DEFINED__
#define __IUmiQuery_FWD_DEFINED__
typedef interface IUmiQuery IUmiQuery;
#endif 	/* __IUmiQuery_FWD_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_FWD_DEFINED__
#define __IUmiCustomInterfaceFactory_FWD_DEFINED__
typedef interface IUmiCustomInterfaceFactory IUmiCustomInterfaceFactory;
#endif 	/* __IUmiCustomInterfaceFactory_FWD_DEFINED__ */


#ifndef __UmiDefURL_FWD_DEFINED__
#define __UmiDefURL_FWD_DEFINED__

#ifdef __cplusplus
typedef class UmiDefURL UmiDefURL;
#else
typedef struct UmiDefURL UmiDefURL;
#endif /* __cplusplus */

#endif 	/* __UmiDefURL_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __UMI_V6_LIBRARY_DEFINED__
#define __UMI_V6_LIBRARY_DEFINED__

/* library UMI_V6 */
/* [uuid] */ 












typedef 
enum tag_UMI_TYPE_ENUMERATION
    {	UMI_TYPE_NULL	= 0,
	UMI_TYPE_I1	= 1,
	UMI_TYPE_I2	= 2,
	UMI_TYPE_I4	= 3,
	UMI_TYPE_I8	= 4,
	UMI_TYPE_UI1	= 5,
	UMI_TYPE_UI2	= 6,
	UMI_TYPE_UI4	= 7,
	UMI_TYPE_UI8	= 8,
	UMI_TYPE_R4	= 9,
	UMI_TYPE_R8	= 10,
	UMI_TYPE_FILETIME	= 12,
	UMI_TYPE_SYSTEMTIME	= 13,
	UMI_TYPE_BOOL	= 14,
	UMI_TYPE_IDISPATCH	= 15,
	UMI_TYPE_IUNKNOWN	= 16,
	UMI_TYPE_VARIANT	= 17,
	UMI_TYPE_LPWSTR	= 20,
	UMI_TYPE_OCTETSTRING	= 21,
	UMI_TYPE_UMIARRAY	= 22,
	UMI_TYPE_DISCOVERY	= 23,
	UMI_TYPE_UNDEFINED	= 24,
	UMI_TYPE_DEFAULT	= 25,
	UMI_TYPE_ARRAY_FLAG	= 0x2000
    } 	UMI_TYPE_ENUMERATION;

typedef ULONG UMI_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0001
    {	UMI_GENUS_CLASS	= 1,
	UMI_GENUS_INSTANCE	= 2
    } 	UMI_GENUS_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0002
    {	UMI_DONT_COMMIT_SECURITY_DESCRIPTOR	= 0x10
    } 	UMI_COMMIT_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0003
    {	UMI_FLAG_GETPROPS_ALL	= 1,
	UMI_FLAG_GETPROPS_SCHEMA	= 0x2,
	UMI_MASK_GETPROPS_PROP	= 0xff,
	UMI_FLAG_GETPROPS_NAMES	= 0x100,
	UMI_MASK_GETPROPS_EXT	= 0x100
    } 	UMI_GETPROPS_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0004
    {	UMI_FLAG_OWNER_SECURITY_INFORMATION	= 0x1,
	UMI_FLAG_GROUP_SECURITY_INFORMATION	= 0x2,
	UMI_FLAG_DACL_SECURITY_INFORMATION	= 0x4,
	UMI_FLAG_SACL_SECURITY_INFORMATION	= 0x8,
	UMI_SECURITY_MASK	= 0xf,
	UMI_FLAG_PROVIDER_CACHE	= 0x10,
	UMI_FLAG_PROPERTY_ORIGIN	= 0x20
    } 	UMI_GET_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0005
    {	UMI_FLAG_REFRESH_ALL	= 0,
	UMI_FLAG_REFRESH_PARTIAL	= 1
    } 	UMI_REFRESH_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0006
    {	UMI_OPERATION_NONE	= 0,
	UMI_OPERATION_APPEND	= 1,
	UMI_OPERATION_UPDATE	= 2,
	UMI_OPERATION_EMPTY	= 3,
	UMI_OPERATION_INSERT_AT	= 4,
	UMI_OPERATION_REMOVE_AT	= 5,
	UMI_OPERATION_DELETE_AT	= 6,
	UMI_OPERATION_DELETE_FIRST_MATCH	= 7,
	UMI_OPERATION_DELETE_ALL_MATCHES	= 8,
	UMI_OPERATION_RESTORE_DEFAULT	= 9
    } 	UMI_PROP_INSTRUCTION;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0007
    {	UMI_OPERATION_INSTANCE	= 0x1000,
	UMI_OPERATION_CLASS	= 0x2000
    } 	UMI_OPERATION_PATH;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0008
    {	UMIPATH_CREATE_AS_NATIVE	= 0x8000,
	UMIPATH_CREATE_AS_EITHER	= 0x4000,
	UMIPATH_CREATE_ACCEPT_RELATIVE	= 0x4
    } 	tag_UMI_PATH_CREATE_FLAG;

typedef 
enum tag_WMI_PATH_STATUS_FLAG
    {	UMIPATH_INFO_NATIVE_STRING	= 0x1,
	UMIPATH_INFO_RELATIVE_PATH	= 0x2,
	UMIPATH_INFO_INSTANCE_PATH	= 0x4,
	UMIPATH_INFO_CLASS_PATH	= 0x8,
	UMIPATH_INFO_SINGLETON_PATH	= 0x10
    } 	tag_UMI_PATH_STATUS_FLAG;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0009
    {	UMI_S_NO_ERROR	= 0,
	UMI_E_CONNECTION_FAILURE	= 0x80041001,
	UMI_E_TIMED_OUT	= 0x80041002,
	UMI_E_TYPE_MISMATCH	= 0x80041003,
	UMI_E_NOT_FOUND	= 0x80041004,
	UMI_E_INVALID_FLAGS	= 0x80041005,
	UMI_E_UNSUPPORTED_FLAGS	= 0x80041006,
	UMI_E_SYNCHRONIZATION_REQUIRED	= 0x80041007,
	UMI_E_UNSUPPORTED_OPERATION	= 0x80041008,
	UMI_E_TRANSACTION_FAILURE	= 0x80041009,
	UMI_E_UNBOUND_OBJECT	= 0x8004100a
    } 	UMI_STATUS;

typedef struct tag_UMI_OCTET_STRING
    {
    ULONG uLength;
    byte __RPC_FAR *lpValue;
    } 	UMI_OCTET_STRING;

typedef struct tag_UMI_OCTET_STRING __RPC_FAR *PUMI_OCTET_STRING;

typedef struct tag_UMI_COM_OBJECT
    {
    IID __RPC_FAR *priid;
    LPVOID pInterface;
    } 	UMI_COM_OBJECT;

typedef struct tag_UMI_COM_OBJECT __RPC_FAR *PUMI_COM_OBJECT;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ union __MIDL___MIDL_itf_umi_0000_0010
    {
    CHAR cValue[ 1 ];
    UCHAR ucValue[ 1 ];
    WCHAR wcValue[ 1 ];
    WORD wValue[ 1 ];
    DWORD dwValue[ 1 ];
    LONG lValue[ 1 ];
    ULONG uValue[ 1 ];
    BYTE byteValue[ 1 ];
    BOOL bValue[ 1 ];
    LPWSTR pszStrValue[ 1 ];
    FILETIME fileTimeValue[ 1 ];
    SYSTEMTIME sysTimeValue[ 1 ];
    double dblValue[ 1 ];
    unsigned __int64 uValue64[ 1 ];
    __int64 nValue64[ 1 ];
    UMI_OCTET_STRING octetStr[ 1 ];
    UMI_COM_OBJECT comObject[ 1 ];
    } 	UMI_VALUE;

typedef union __MIDL___MIDL_itf_umi_0000_0010 __RPC_FAR *PUMI_VALUE;

typedef /* [public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0011
    {
    UMI_TYPE uType;
    ULONG uCount;
    ULONG uOperationType;
    LPWSTR pszPropertyName;
    UMI_VALUE __RPC_FAR *pUmiValue;
    } 	UMI_PROPERTY;

typedef struct __MIDL___MIDL_itf_umi_0000_0011 __RPC_FAR *PUMI_PROPERTY;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0012
    {
    ULONG uCount;
    UMI_PROPERTY __RPC_FAR *pPropArray;
    } 	UMI_PROPERTY_VALUES;

typedef struct __MIDL___MIDL_itf_umi_0000_0012 __RPC_FAR *PUMI_PROPERTY_VALUES;


EXTERN_C const IID LIBID_UMI_V6;

#ifndef __IUmiPropList_INTERFACE_DEFINED__
#define __IUmiPropList_INTERFACE_DEFINED__

/* interface IUmiPropList */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiPropList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7b-d9db-11d3-a11f-00105a1f515a")
    IUmiPropList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAs( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeMemory( 
            ULONG uReserved,
            LPVOID pMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutFrom( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiPropListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiPropList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiPropList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiPropList __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        END_INTERFACE
    } IUmiPropListVtbl;

    interface IUmiPropList
    {
        CONST_VTBL struct IUmiPropListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiPropList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiPropList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiPropList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiPropList_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiPropList_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiPropList_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiPropList_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiPropList_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiPropList_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiPropList_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiPropList_Put_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Get_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAt_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [out] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_GetAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAs_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCoercionType,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_GetAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_FreeMemory_Proxy( 
    IUmiPropList __RPC_FAR * This,
    ULONG uReserved,
    LPVOID pMem);


void __RPC_STUB IUmiPropList_FreeMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Delete_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiPropList_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_GetProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_PutProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutFrom_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [in] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_PutFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiPropList_INTERFACE_DEFINED__ */


#ifndef __IUmiBaseObject_INTERFACE_DEFINED__
#define __IUmiBaseObject_INTERFACE_DEFINED__

/* interface IUmiBaseObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7c-d9db-11d3-a11f-00105a1f515a")
    IUmiBaseObject : public IUmiPropList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLastStatus( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfacePropList( 
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiBaseObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        END_INTERFACE
    } IUmiBaseObjectVtbl;

    interface IUmiBaseObject
    {
        CONST_VTBL struct IUmiBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiBaseObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiBaseObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiBaseObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiBaseObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiBaseObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiBaseObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiBaseObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiBaseObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiBaseObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetLastStatus_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);


void __RPC_STUB IUmiBaseObject_GetLastStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetInterfacePropList_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);


void __RPC_STUB IUmiBaseObject_GetInterfacePropList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiBaseObject_INTERFACE_DEFINED__ */


#ifndef __IUmiObject_INTERFACE_DEFINED__
#define __IUmiObject_INTERFACE_DEFINED__

/* interface IUmiObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee23-64a4-11d3-a0da-00105a1f515a")
    IUmiObject : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ ULONG uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        END_INTERFACE
    } IUmiObjectVtbl;

    interface IUmiObject
    {
        CONST_VTBL struct IUmiObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiObject_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiObject_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiObject_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiObject_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObject_Clone_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_CopyTo_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Refresh_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uNameCount,
    /* [in] */ LPWSTR __RPC_FAR *pszNames);


void __RPC_STUB IUmiObject_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Commit_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiObject_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObject_INTERFACE_DEFINED__ */


#ifndef __IUmiConnection_INTERFACE_DEFINED__
#define __IUmiConnection_INTERFACE_DEFINED__

/* interface IUmiConnection */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee20-64a4-11d3-a0da-00105a1f515a")
    IUmiConnection : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiConnection __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        END_INTERFACE
    } IUmiConnectionVtbl;

    interface IUmiConnection
    {
        CONST_VTBL struct IUmiConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiConnection_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiConnection_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiConnection_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiConnection_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiConnection_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiConnection_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiConnection_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiConnection_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiConnection_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiConnection_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiConnection_Open_Proxy( 
    IUmiConnection __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiConnection_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiConnection_INTERFACE_DEFINED__ */


#ifndef __IUmiContainer_INTERFACE_DEFINED__
#define __IUmiContainer_INTERFACE_DEFINED__

/* interface IUmiContainer */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee21-64a4-11d3-a0da-00105a1f515a")
    IUmiContainer : public IUmiObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObject( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnum( 
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiContainer __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEnum )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);
        
        END_INTERFACE
    } IUmiContainerVtbl;

    interface IUmiContainer
    {
        CONST_VTBL struct IUmiContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiContainer_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiContainer_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiContainer_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiContainer_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiContainer_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiContainer_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiContainer_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiContainer_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiContainer_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiContainer_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiContainer_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiContainer_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiContainer_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)


#define IUmiContainer_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#define IUmiContainer_PutObject(This,uFlags,TargetIID,pObj)	\
    (This)->lpVtbl -> PutObject(This,uFlags,TargetIID,pObj)

#define IUmiContainer_DeleteObject(This,pURL,uFlags)	\
    (This)->lpVtbl -> DeleteObject(This,pURL,uFlags)

#define IUmiContainer_Create(This,pURL,uFlags,pNewObj)	\
    (This)->lpVtbl -> Create(This,pURL,uFlags,pNewObj)

#define IUmiContainer_Move(This,uFlags,pOldURL,pNewURL)	\
    (This)->lpVtbl -> Move(This,uFlags,pOldURL,pNewURL)

#define IUmiContainer_CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)	\
    (This)->lpVtbl -> CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)

#define IUmiContainer_ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)	\
    (This)->lpVtbl -> ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiContainer_Open_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiContainer_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_PutObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out][in] */ void __RPC_FAR *pObj);


void __RPC_STUB IUmiContainer_PutObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_DeleteObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [optional][in] */ ULONG uFlags);


void __RPC_STUB IUmiContainer_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Create_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);


void __RPC_STUB IUmiContainer_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Move_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pOldURL,
    /* [in] */ IUmiURL __RPC_FAR *pNewURL);


void __RPC_STUB IUmiContainer_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_CreateEnum_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);


void __RPC_STUB IUmiContainer_CreateEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_ExecQuery_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiQuery __RPC_FAR *pQuery,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IUmiContainer_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiContainer_INTERFACE_DEFINED__ */


#ifndef __IUmiCursor_INTERFACE_DEFINED__
#define __IUmiCursor_INTERFACE_DEFINED__

/* interface IUmiCursor */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCursor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee26-64a4-11d3-a0da-00105a1f515a")
    IUmiCursor : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIID( 
            /* [in] */ REFIID riid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ ULONG __RPC_FAR *puNumObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Previous( 
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCursorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCursor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiCursor __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIID )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IUmiCursor __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puNumObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Previous )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj);
        
        END_INTERFACE
    } IUmiCursorVtbl;

    interface IUmiCursor
    {
        CONST_VTBL struct IUmiCursorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCursor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCursor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCursor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCursor_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiCursor_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiCursor_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiCursor_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiCursor_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiCursor_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiCursor_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiCursor_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiCursor_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiCursor_SetIID(This,riid)	\
    (This)->lpVtbl -> SetIID(This,riid)

#define IUmiCursor_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IUmiCursor_Next(This,uNumRequested,puNumReturned,pObjects)	\
    (This)->lpVtbl -> Next(This,uNumRequested,puNumReturned,pObjects)

#define IUmiCursor_Count(This,puNumObjects)	\
    (This)->lpVtbl -> Count(This,puNumObjects)

#define IUmiCursor_Previous(This,uFlags,pObj)	\
    (This)->lpVtbl -> Previous(This,uFlags,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCursor_SetIID_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB IUmiCursor_SetIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Reset_Proxy( 
    IUmiCursor __RPC_FAR * This);


void __RPC_STUB IUmiCursor_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Next_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uNumRequested,
    /* [out] */ ULONG __RPC_FAR *puNumReturned,
    /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);


void __RPC_STUB IUmiCursor_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Count_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puNumObjects);


void __RPC_STUB IUmiCursor_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Previous_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ LPVOID __RPC_FAR *pObj);


void __RPC_STUB IUmiCursor_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCursor_INTERFACE_DEFINED__ */


#ifndef __IUmiObjectSink_INTERFACE_DEFINED__
#define __IUmiObjectSink_INTERFACE_DEFINED__

/* interface IUmiObjectSink */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee24-64a4-11d3-a0da-00105a1f515a")
    IUmiObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResult( 
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResult )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject);
        
        END_INTERFACE
    } IUmiObjectSinkVtbl;

    interface IUmiObjectSink
    {
        CONST_VTBL struct IUmiObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObjectSink_Put(This,lNumObjects,ppObjects)	\
    (This)->lpVtbl -> Put(This,lNumObjects,ppObjects)

#define IUmiObjectSink_SetResult(This,hResStatus,uFlags,pObject)	\
    (This)->lpVtbl -> SetResult(This,hResStatus,uFlags,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObjectSink_Put_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ LONG lNumObjects,
    /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);


void __RPC_STUB IUmiObjectSink_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObjectSink_SetResult_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ HRESULT hResStatus,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUnknown __RPC_FAR *pObject);


void __RPC_STUB IUmiObjectSink_SetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObjectSink_INTERFACE_DEFINED__ */


#ifndef __IUmiURLKeyList_INTERFACE_DEFINED__
#define __IUmiURLKeyList_INTERFACE_DEFINED__

/* interface IUmiURLKeyList */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IUmiURLKeyList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cf779c98-4739-4fd4-a415-da937a599f2f")
    IUmiURLKeyList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeysInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLKeyListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllKeys )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeysInfo )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        END_INTERFACE
    } IUmiURLKeyListVtbl;

    interface IUmiURLKeyList
    {
        CONST_VTBL struct IUmiURLKeyListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURLKeyList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURLKeyList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURLKeyList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURLKeyList_GetCount(This,puKeyCount)	\
    (This)->lpVtbl -> GetCount(This,puKeyCount)

#define IUmiURLKeyList_SetKey(This,pszName,pszValue)	\
    (This)->lpVtbl -> SetKey(This,pszName,pszValue)

#define IUmiURLKeyList_GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)	\
    (This)->lpVtbl -> GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)

#define IUmiURLKeyList_RemoveKey(This,pszName,uFlags)	\
    (This)->lpVtbl -> RemoveKey(This,pszName,uFlags)

#define IUmiURLKeyList_RemoveAllKeys(This,uFlags)	\
    (This)->lpVtbl -> RemoveAllKeys(This,uFlags)

#define IUmiURLKeyList_GetKeysInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetKeysInfo(This,uRequestedInfo,puResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetCount_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puKeyCount);


void __RPC_STUB IUmiURLKeyList_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_SetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [string][in] */ LPCWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
    /* [in] */ LPWSTR pszKeyName,
    /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
    /* [in] */ LPWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveAllKeys_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveAllKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKeysInfo_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURLKeyList_GetKeysInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURLKeyList_INTERFACE_DEFINED__ */


#ifndef __IUmiURL_INTERFACE_DEFINED__
#define __IUmiURL_INTERFACE_DEFINED__

/* interface IUmiURL */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiURL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7d-d9db-11d3-a11f-00105a1f515a")
    IUmiURL : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocator( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocator( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRootNamespace( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootNamespace( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponentFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponent( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveComponent( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllComponents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLeafName( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLeafName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateLeafPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLeafPart( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURL __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPathInfo )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentCount )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponentFromText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentAsText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllComponents )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeyList )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IUmiURLVtbl;

    interface IUmiURL
    {
        CONST_VTBL struct IUmiURLVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURL_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURL_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURL_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURL_Set(This,lFlags,pszText)	\
    (This)->lpVtbl -> Set(This,lFlags,pszText)

#define IUmiURL_Get(This,lFlags,puBufSize,pszDest)	\
    (This)->lpVtbl -> Get(This,lFlags,puBufSize,pszDest)

#define IUmiURL_GetPathInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetPathInfo(This,uRequestedInfo,puResponse)

#define IUmiURL_SetLocator(This,Name)	\
    (This)->lpVtbl -> SetLocator(This,Name)

#define IUmiURL_GetLocator(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetLocator(This,puNameBufLength,pName)

#define IUmiURL_SetRootNamespace(This,Name)	\
    (This)->lpVtbl -> SetRootNamespace(This,Name)

#define IUmiURL_GetRootNamespace(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetRootNamespace(This,puNameBufLength,pName)

#define IUmiURL_GetComponentCount(This,puCount)	\
    (This)->lpVtbl -> GetComponentCount(This,puCount)

#define IUmiURL_SetComponent(This,uIndex,pszClass)	\
    (This)->lpVtbl -> SetComponent(This,uIndex,pszClass)

#define IUmiURL_SetComponentFromText(This,uIndex,pszText)	\
    (This)->lpVtbl -> SetComponentFromText(This,uIndex,pszText)

#define IUmiURL_GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)	\
    (This)->lpVtbl -> GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)

#define IUmiURL_GetComponentAsText(This,uIndex,puTextBufSize,pszText)	\
    (This)->lpVtbl -> GetComponentAsText(This,uIndex,puTextBufSize,pszText)

#define IUmiURL_RemoveComponent(This,uIndex)	\
    (This)->lpVtbl -> RemoveComponent(This,uIndex)

#define IUmiURL_RemoveAllComponents(This)	\
    (This)->lpVtbl -> RemoveAllComponents(This)

#define IUmiURL_SetLeafName(This,Name)	\
    (This)->lpVtbl -> SetLeafName(This,Name)

#define IUmiURL_GetLeafName(This,puBuffLength,pszName)	\
    (This)->lpVtbl -> GetLeafName(This,puBuffLength,pszName)

#define IUmiURL_GetKeyList(This,pOut)	\
    (This)->lpVtbl -> GetKeyList(This,pOut)

#define IUmiURL_CreateLeafPart(This,lFlags,Name)	\
    (This)->lpVtbl -> CreateLeafPart(This,lFlags,Name)

#define IUmiURL_DeleteLeafPart(This,lFlags)	\
    (This)->lpVtbl -> DeleteLeafPart(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURL_Set_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiURL_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_Get_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBufSize,
    /* [string][in] */ LPWSTR pszDest);


void __RPC_STUB IUmiURL_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetPathInfo_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURL_GetPathInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentCount_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IUmiURL_GetComponentCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszClass);


void __RPC_STUB IUmiURL_SetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponentFromText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_SetComponentFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
    /* [out][in] */ LPWSTR pszClass,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);


void __RPC_STUB IUmiURL_GetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentAsText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
    /* [out][in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_GetComponentAsText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IUmiURL_RemoveComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveAllComponents_Proxy( 
    IUmiURL __RPC_FAR * This);


void __RPC_STUB IUmiURL_RemoveAllComponents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszName);


void __RPC_STUB IUmiURL_GetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetKeyList_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);


void __RPC_STUB IUmiURL_GetKeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_CreateLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_CreateLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_DeleteLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IUmiURL_DeleteLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURL_INTERFACE_DEFINED__ */


#ifndef __IUmiQuery_INTERFACE_DEFINED__
#define __IUmiQuery_INTERFACE_DEFINED__

/* interface IUmiQuery */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7e-d9db-11d3-a11f-00105a1f515a")
    IUmiQuery : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiQuery __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuery )( 
            IUmiQuery __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf);
        
        END_INTERFACE
    } IUmiQueryVtbl;

    interface IUmiQuery
    {
        CONST_VTBL struct IUmiQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiQuery_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiQuery_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiQuery_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiQuery_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiQuery_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiQuery_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiQuery_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiQuery_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiQuery_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiQuery_Set(This,pszLanguage,uFlags,pszText)	\
    (This)->lpVtbl -> Set(This,pszLanguage,uFlags,pszText)

#define IUmiQuery_GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)	\
    (This)->lpVtbl -> GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiQuery_Set_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [in] */ LPCWSTR pszLanguage,
    /* [in] */ ULONG uFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiQuery_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiQuery_GetQuery_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
    /* [out][in] */ LPWSTR pszLangBuf,
    /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
    /* [out][in] */ LPWSTR pszQueryTextBuf);


void __RPC_STUB IUmiQuery_GetQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiQuery_INTERFACE_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__
#define __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__

/* interface IUmiCustomInterfaceFactory */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCustomInterfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14CD599E-2BE7-4c6f-B95B-B150DCD93585")
    IUmiCustomInterfaceFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForIID( 
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectByCLSID( 
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForNames( 
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCustomInterfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForIID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectByCLSID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForNames )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        END_INTERFACE
    } IUmiCustomInterfaceFactoryVtbl;

    interface IUmiCustomInterfaceFactory
    {
        CONST_VTBL struct IUmiCustomInterfaceFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCustomInterfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCustomInterfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCustomInterfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCustomInterfaceFactory_GetCLSIDForIID(This,riid,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForIID(This,riid,lFlags,pCLSID)

#define IUmiCustomInterfaceFactory_GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)	\
    (This)->lpVtbl -> GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)

#define IUmiCustomInterfaceFactory_GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForIID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetObjectByCLSID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ CLSID clsid,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);


void __RPC_STUB IUmiCustomInterfaceFactory_GetObjectByCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForNames_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_UmiDefURL;

#ifdef __cplusplus

class DECLSPEC_UUID("d4b21cc2-f2a5-453e-8459-b27f362cb0e0")
UmiDefURL;
#endif
#endif /* __UMI_V6_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\include\rowprov.h ===
//-----------------------------------------------------------------------------------
// Microsoft OLE DB Provider for ODBC data
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module ROWPROV.H | Definition of the Row Provider interface used by the generic
//					   flavor of the TempTable.
//
//
// @rev 1 | 04-03-96 | WlodekN | Created
// @rev 2 | 07-24-96 | EricJ   | Added PropID
//
//-----------------------------------------------------------------------------------


#ifndef __ROWPROV_INCL__
#define __ROWPROV_INCL__


//---------------------------------- C L A S S E S ----------------------------------


// Abstract class for objects providing row data to the generic TempTable.
class IRowProvider : public IUnknown
{
	public:
		virtual STDMETHODIMP GetColumn
				(
				ULONG		icol,
				DBSTATUS	*pwStatus,
				ULONG		*pdwLength,
				BYTE		*pbData
				) = 0;
		virtual STDMETHODIMP NextRow
				(
				void
				) = 0;
};

EXTERN_C const IID IID_IRowProvider;
EXTERN_C const GUID DBPROPSET_TEMPTABLE;

// TempTable Property IDs.
enum tagetmptablepropid
{
	DBPROP_INSTANTPOPULATION=2,	// TRUE = Prepopulate.  FALSE = Lazy population.
	DBPROP_DBCOLBYREF,			// TRUE = Clear BYREF flags from IColumnsInfo, source owns memory.
	DBPROP_DONTALLOCBYREFCOLS,	// TRUE = TempTable only allocates ptr for BYREF columns.
};


#endif	// __ROWPROV_INCL__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cconcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cconnect.hxx
//
//  Contents: Class factory for the LDAP Connection Object.
//
//            CLDAPConnectionCF::CreateInstance.
//
//  History:    03-12-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
// Function:   CLDAPConnectionCF::CreateInstance
//
// Synopsis:   Standard CreateInstance implementation.
//
// Arguments:  pUnkOuter     ---- standard outer IUnknown ptr.
//             iid           ---- interface requested.
//             ppv           ---- output ptr for created object.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPConnectionCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;
    CLDAPConObject * pConObject;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CLDAPConObject::CreateConnectionObject(&pConObject);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pConObject) {
        hr = pConObject->QueryInterface(iid, ppv);
        pConObject->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cconnect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cconnect.cxx
//
//  Contents: LDAP Connection object - this object implements the 
//        IUmiConnection interface.
//
//  Functions: TBD.
//
//  History:    03-03-00    AjayR  Created.
//
//----------------------------------------------------------------------------

#include "ldap.hxx"


//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::CLDAPConObject
//
// Synopsis:   Constructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPConObject::CLDAPConObject():
    _pPropMgr(NULL),
    _fConnected(FALSE),
    _pLdapHandle(NULL),
    _ulErrorStatus(0)
{
}


//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::~CLDAPConObject
//
// Synopsis:   Destructor
//
// Arguments:  None
//
// Returns:    N/A
//
// Modifies:   N/A
//
//----------------------------------------------------------------------------
CLDAPConObject::~CLDAPConObject()
{
    delete _pPropMgr;
    //
    // Close the handle if needed - this will deref and free if appropriate.
    //
    if (_pLdapHandle) {
        LdapCloseObject(_pLdapHandle);
        _pLdapHandle = NULL;
    }
}


//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::CreateConnectionObject
//
// Synopsis:   Static allocation routine for connection object.
//
// Arguments:  CLDAPConObject * --- contains new connection object
//             PADSLDP          --- ldap handle defaulted NULL.
//
// Returns:    HRESULT - S_OK or any failure error code.
//
// Modifies:   CLDAPConObject ** - ptr to newly created object.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPConObject::CreateConnectionObject(
    CLDAPConObject FAR * FAR * ppConnectionObject,
    PADSLDP pLdapHandle // defaulted to NULL
    )
{
    HRESULT hr = S_OK;
    CLDAPConObject FAR * pConObj = NULL;
    CPropertyManager FAR * pIntfPropMgr = NULL;

    pConObj = new CLDAPConObject();

    if (!pConObj) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    //
    // Add a ref to the ldap handle if one was passed in.
    //
    if (pLdapHandle) {
        pConObj->_pLdapHandle = pLdapHandle;
        pConObj->_fConnected = TRUE;
        LdapCacheAddRef(pConObj->_pLdapHandle);
    }

    hr = CPropertyManager::CreatePropertyManager(
             (IUmiConnection *) pConObj,
             NULL, // outer unk
             NULL, // credentials
             IntfPropsConnection,
             &pIntfPropMgr
             );

    BAIL_ON_FAILURE(hr);

    pConObj->_pPropMgr = pIntfPropMgr;
    *ppConnectionObject = pConObj;

    RRETURN(S_OK);
error:

    //
    // If we get here, we likely could not create the property manager.
    //
    if (pConObj) {
        delete pConObj;
    }

    RRETURN(hr);
}


STDMETHODIMP
CLDAPConObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    HRESULT hr = S_OK;

    SetLastStatus(0);

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown)){
        *ppv = (IUnknown FAR *) this;
    } 
    else if (IsEqualIID(iid, IID_IUmiPropList)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiBaseObject)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IUmiConnection)) {
        *ppv = (IUmiConnection FAR *) this;
    }
    else {
        *ppv = NULL;
        SetLastStatus(E_NOINTERFACE);
        return E_NOINTERFACE;
    }
    
    AddRef();
    return NOERROR;
}



//
// IUmiConnection methods.
//

//+---------------------------------------------------------------------------
// Function:   CLDAPConObject::Open
//
// Synopsis:   Opens a connection to the server (either implicityly 
//          specified in the url or explicitly in the interface 
//          properties. If there is already an underlyng ldap connection,
//          subsequent open operations will fail if they do not use the same
//          underlying connection.
//          
// Arguments:  pUrl      - IUmiUrl object pointing to object to be fetched.
//             uFlags    - Flags for the operation (currently on 0).
//             TargetIID - IID requested on the target object.
//             ppvRes    - ptr to return the target object.
//
// Returns:    HRESULT   - S_OK or any failure error code.
//
// Modifies:   The status of the object and underlying ldap handle ptr.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPConObject::Open(
    IUmiURL *pURL,
    ULONG uFlags,
    REFIID TargetIID,
    void ** ppvRes
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszUrl = NULL;
    IUnknown *pUnk = NULL;
    IADsObjOptPrivate * pPrivOpt = NULL;
    PADSLDP pLdapTmpHandle = NULL;
    //
    // Default values for credentials.
    //
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    LPWSTR pszLdapPath = NULL;
    DWORD dwFlags = 0;
    BOOL fFlag;
        
    SetLastStatus(0);

    if (!ppvRes || !pURL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    if (uFlags != 0) {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
    }

    *ppvRes = NULL;
    //
    // UrlToLDAPPath can handle both native and umi paths.
    //
    hr = UrlToLDAPPath(
             pURL,
             &pszLdapPath
             );
    BAIL_ON_FAILURE(hr);

    //
    // Prepare the credentials if applicable.
    //
    if (!_pCredentials) {
        //
        // Get the params from the property mgr.
        //
        hr = _pPropMgr->GetStringProperty(L"__UserId", &pszUserName);
        
        if (hr == E_OUTOFMEMORY) {
            BAIL_ON_FAILURE(hr);
        }

        hr = _pPropMgr->GetStringProperty(L"__Password", &pszPassword);
        
        if (hr == E_OUTOFMEMORY) {
            BAIL_ON_FAILURE(hr);
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__SECURE_AUTHENTICATION",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_SECURE_AUTHENTICATION;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__NO_AUTHENTICATION",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_NO_AUTHENTICATION;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_READONLY_SERVER",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_READONLY_SERVER;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_PROMPT_CREDENTIALS",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_PROMPT_CREDENTIALS;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_SERVER_BIND",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_SERVER_BIND;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_FAST_BIND",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_FAST_BIND;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_USE_SIGNING",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_USE_SIGNING;
        }

        hr = _pPropMgr->GetBoolProperty(
                 L"__PADS_USE_SEALING",
                 &fFlag
                 );
        BAIL_ON_FAILURE(hr);

        if (fFlag) {
            dwFlags |= ADS_USE_SEALING;
        }

//        hr = _pPropMgr->GetLongProperty(L"__USE_ENCRYPTION", &lVal);
//        BAIL_ON_FAILURE(hr);
//        Spec needs to be resolved before we can do this.


        //
        // Always do this as this is what tells us we are in UMI mode.
        //
        dwFlags |= ADS_AUTH_RESERVED;

        _pCredentials = new CCredentials(
                                pszUserName,
                                pszPassword,
                                dwFlags
                                );

        if (!_pCredentials) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }
    
    //

    // In the future we might want to add some sanity check before 
    // making this call. That might save some network traffic in the
    // rare cases. 
    // Note that currently, we always get the object and then we compare
    // the handles to see if we have inded got an object on the same
    // connection (and fail appropriately if not).
    //
    hr = ::GetObject(
               pszLdapPath,
               *_pCredentials,
               (LPVOID *) &pUnk
               ) ;
    BAIL_ON_FAILURE(hr);

    //
    // By default we get back IADs, so we need to QI for intf.
    //
    hr = pUnk->QueryInterface(TargetIID, ppvRes);
    BAIL_ON_FAILURE(hr);

    //
    // At this point copy over the handle if applicable. If the handle is
    // already set, then we need to make sure we are using the same
    // connection.
    // If do not get the handle for whatever reason, we will use the 
    // defaulted NULL value and in that case we wont save the handle or
    // compare the value.
    //
    hr = pUnk->QueryInterface(IID_IADsObjOptPrivate, (LPVOID *) &pPrivOpt);
    if (SUCCEEDED(hr)) {
        //
        // If we succeeded then we want to try and compare handles.
        //
        hr = pPrivOpt->GetOption(
                 LDP_CACHE_ENTRY,
                 (void*) &pLdapTmpHandle
                 );

    }

    //
    // Reset hr just in case the above failed.
    //
    hr = S_OK;
    
    if (_fConnected) {
        //
        // Verify that the handles are the same.
        //
        if (_pLdapHandle 
            && pLdapTmpHandle
            && (_pLdapHandle != pLdapTmpHandle)) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
    } 
    else {
        //
        // New connection.
        //
        if (pLdapTmpHandle) {
            _pLdapHandle = pLdapTmpHandle;
            _fConnected = TRUE;
            LdapCacheAddRef(_pLdapHandle);
        }
        
    }

error:

    //
    // Release the ref in all cases. If QI failed that will del the obj.
    //
    if (pUnk) {
        pUnk->Release();
    }

    if (pPrivOpt) {
        pPrivOpt->Release();
    }
    
    if (FAILED(hr)) {
        //
        // Update the error status.
        //
        SetLastStatus(hr);

        hr = MapHrToUmiError(hr);
         
        if (*ppvRes) {
            //  
            // We got the object but a subsequent operation failed.
            //
            *ppvRes = NULL;
            pUnk->Release();
        }
    }

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }
    
    if (pszLdapPath) {
        FreeADsMem(pszLdapPath);
    }
    
    RRETURN(hr);
}

//
// IUmiBaseObject methods.
//
STDMETHODIMP
CLDAPConObject::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if (pStatusObj) {
        *pStatusObj = NULL;
    }
    
    if (puSpecificStatus) {
        *puSpecificStatus = 0;
    }
    else {
        RRETURN(E_INVALIDARG);
    }
    
    if (uFlags) {
        RRETURN(UMI_E_INVALID_FLAGS);
    }
    
    *puSpecificStatus = _ulErrorStatus;
    
    RRETURN(S_OK);
}

STDMETHODIMP
CLDAPConObject::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    RRETURN(_pPropMgr->QueryInterface(IID_IUmiPropList, (void **) pPropList));
}


//
// Methods defined on the proplist interface - none are implemented.
// All the properties need to be set on the interface property list.
//


STDMETHODIMP
CLDAPConObject::Put(
    IN LPCWSTR pszName,
    IN ULONG   uFlags,
    IN UMI_PROPERTY_VALUES *pProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::Get(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::GetAt(
    IN  LPCWSTR pszName,
    IN  ULONG   uFlags,
    IN  ULONG   uBufferLength,
    OUT LPVOID  pExisitingMem
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPConObject::Delete(
    IN  LPCWSTR pszName,
    IN  ULONG ulFlags
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CLDAPConObject::GetAs(
    IN     LPCWSTR pszName,
    IN     ULONG uFlags,
    IN     ULONG uCoercionType,
    IN OUT UMI_PROPERTY_VALUES **pProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::FreeMemory(
    ULONG  uReserved,
    LPVOID pMem
    )
{
    if (pMem) {
        //
        // At this time this has to be a pUmiProperty. Ideally we should
        // tag this in some way so that we can check to make sure.
        //
        RRETURN(FreeUmiPropertyValues((UMI_PROPERTY_VALUES *)pMem));
    }

    RRETURN(S_OK);
}


STDMETHODIMP
CLDAPConObject::GetProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    OUT UMI_PROPERTY_VALUES **pProps
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT 
CLDAPConObject::PutProps(
    IN LPCWSTR* pszNames,
    IN ULONG uNameCount,
    IN ULONG uFlags,
    IN UMI_PROPERTY_VALUES *pProps
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CLDAPConObject::PutFrom(
    IN  LPCWSTR pszName,
    IN  ULONG uFlags,
    IN  ULONG uBufferLength,
    IN  LPVOID pExistingMem
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregatorDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "ldap.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include ".\cdispmgr.hxx"
#include ".\iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[200];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
    *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
    DispId < 0 || DispId >= 0x10000)
    {
    //
    // Might happen if some object has very large dispid's.
    // But we can't handle it if it does.
    //
    *pResult = DISPID_UNKNOWN;
    }
    else
    *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    if (rgdispid[i] == DISPID_UNKNOWN)
        continue;

    //
    // This is either a stack of DispMgrs >127 high, or
    // a programming error.  More likely the latter.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    //
    // It should never be less than zero, and the only place
    // this is called from guarantees it is not zero.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct Def
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;

CRITICAL_SECTION g_TypeInfoCritSect;

#define ENTER_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_TypeInfoCritSect)
#define LEAVE_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_TypeInfoCritSect)

PTYPEINFO_TABLE gpAggregatorTypeInfoTable = NULL;
LONG glnLDAPObjCount = 0;
LONG glnLDAPTypesOfInfo = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}


CAggregatorDispMgr::CAggregatorDispMgr(CCredentials &Credentials)
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _Credentials = Credentials;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;

        pTypeInfo->Release();

        InterlockedDecrement(&glnLDAPObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_TYPEINFO_CRITSECT();

    if (glnLDAPObjCount == glnLDAPTypesOfInfo) {
        //
        // We need to clean up the list
        //
        AggregatorFreeTypeInfoTable();

        glnLDAPObjCount = glnLDAPTypesOfInfo = 0;

    }
    LEAVE_TYPEINFO_CRITSECT();
}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                (PDWORD)(rgdispid + dw)))) {
                    hr = DISP_E_UNKNOWNNAME;
                    rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregatorDynamicDispidInvoke(
                        _pPropertyCache,
                        _Credentials,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregatorDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    CCredentials &Credentials,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid, pvarResult, Credentials);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // All ADSI property put requests take only one
        // argument/value (multi-valued attributes take
        // an array of multiple values, but the array
        // itself is still only a single argument)
        // --> multiple arguments = bad parameters
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
AggregatorFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AggregatorAddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregatorLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_TYPEINFO_CRITSECT();
    pTypeInfo = ::AggregatorFindTypeInfo(gpAggregatorTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_TYPEINFO_CRITSECT();

        hr = AggregatorLoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_TYPEINFO_CRITSECT();

        gpAggregatorTypeInfoTable = ::AggregatorAddTypeInfo(
                                          gpAggregatorTypeInfoTable,
                                          iid,
                                          pTypeInfo
                                          );

        if (!gpAggregatorTypeInfoTable) {
            LEAVE_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnLDAPTypesOfInfo);

        InterlockedIncrement(&glnLDAPObjCount);


    }
    pTypeInfo->AddRef();

    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnLDAPObjCount);

    LEAVE_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
AggregatorFreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpAggregatorTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpAggregatorTypeInfoTable = NULL;
}

BOOL
AggregatorDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_TYPEINFO_CRITSECT();
    retVal = (glnLDAPObjCount == 0);
    LEAVE_TYPEINFO_CRITSECT();

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cdssch.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssch.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
CLDAPGenObject::EnumAttributes(
    LPWSTR * ppszAttrNames,
    DWORD dwNumAttributes,
    PADS_ATTR_DEF * ppAttrDefinition,
    DWORD * pdwNumAttributes
    )
{
    HRESULT hr = S_OK;

    hr = ADsEnumAttributes(
             _pszLDAPServer,
             _pszLDAPDn,
             _Credentials,
             _dwPort,
             ppszAttrNames,
             dwNumAttributes,
             ppAttrDefinition,
             pdwNumAttributes
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::CreateAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsCreateAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );
    RRETURN(hr);
}


HRESULT
CLDAPGenObject::WriteAttributeDefinition(
    LPWSTR pszAttributeName,
    PADS_ATTR_DEF  pAttributeDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsWriteAttributeDefinition(
             pszAttributeName,
             pAttributeDefinition
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::DeleteAttributeDefinition(
    LPWSTR pszAttributeName
    )
{
    HRESULT hr = S_OK;

    hr = ADsDeleteAttributeDefinition(
             pszAttributeName
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::EnumClasses(
    LPWSTR * ppszClassNames,
    DWORD dwNumClasses,
    PADS_CLASS_DEF * ppClassDefinition,
    DWORD * pdwNumClasses
    )
{
    HRESULT hr = S_OK;

    hr = ADsEnumClasses(
             ppszClassNames,
             dwNumClasses,
             ppClassDefinition,
             pdwNumClasses
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::CreateClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF pClassDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsCreateClassDefinition(
             pszClassName,
             pClassDefinition
             );
    RRETURN(hr);
}


HRESULT
CLDAPGenObject::WriteClassDefinition(
    LPWSTR pszClassName,
    PADS_CLASS_DEF  pClassDefinition
    )
{
    HRESULT hr = S_OK;

    hr = ADsWriteClassDefinition(
             pszClassName,
             pClassDefinition
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::DeleteClassDefinition(
    LPWSTR pszClassName
    )
{
    HRESULT hr = S_OK;

    hr = ADsDeleteClassDefinition(
             pszClassName
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumns.cxx
//
//  Contents:  LDAP Enumerator Code
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop


DWORD
GetDefaultServer(
    DWORD dwPort,
    BOOL fVerify,
    LPWSTR szDomainDnsName,
    LPWSTR szServerName,
    BOOL fWriteable
    );

DWORD
GetDefaultLdapServer(
    LPWSTR Addresses[],
    LPDWORD Count,
    BOOL Verify,
    DWORD dwPort
    ) ;

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPNamespaceEnum::Create(
    CLDAPNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials,
    LPTSTR pszNamespace
    )
{
    HRESULT hr = S_OK;
    CLDAPNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CLDAPNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ObjectTypeList::CreateObjectTypeList(
             var,
             &penumvariant->_pObjList
             );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    penumvariant->_pszNamespace = AllocADsStr(pszNamespace);
    if (!(penumvariant->_pszNamespace)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if( IsGCNamespace(pszNamespace) )
        penumvariant->_dwPort = (DWORD) USE_DEFAULT_GC_PORT;
    else
        penumvariant->_dwPort = (DWORD) USE_DEFAULT_LDAP_PORT;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    if (penumvariant) {
        delete penumvariant;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::CLDAPNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPNamespaceEnum::CLDAPNamespaceEnum()
{
    _dwIndex = 0;
    _pObjList = NULL;

}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::~CLDAPNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLDAPNamespaceEnum::~CLDAPNamespaceEnum()
{
    if (_pszNamespace)
        FreeADsMem(_pszNamespace);

    if ( _pObjList )
        delete _pObjList;
}

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CLDAPNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if ( _dwIndex > 0 )  // only your default ds will be returned, one element
    {
        if (pcElementFetched)
            *pcElementFetched = 0;

        RRETURN(S_FALSE);
    }

    hr = EnumObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPNamespaceEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        if ( _dwIndex > 0 )  // only your default ds will be returned,
                             // i.e. one element only
        {
            hr = S_FALSE;
            break;
        }

        _dwIndex++;

        hr = GetTreeObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CLDAPNamespaceEnum::GetTreeObject(
    IDispatch ** ppDispatch
    )
{
    DWORD err = NO_ERROR;
    HRESULT hr = S_OK;
    LPTSTR *aValuesNamingContext = NULL;
    LPTSTR *aValuesObjectClass = NULL;
    int nCountValues = 0;
    TCHAR *pszLDAPPathName = NULL;
    TCHAR szADsClassName[64];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    TCHAR *pszNewADsPath = NULL;
    TCHAR *pszLast = NULL;

    LPWSTR pszNamingContext = NULL;

    LPWSTR pszNewADsParent = NULL;
    LPWSTR pszNewADsCommonName = NULL;

    DWORD fVerify = FALSE;

    *ppDispatch = NULL;
    ADS_LDP *ld = NULL;

    BOOL fGCDefaulted = FALSE;

    //
    // Now send back the current object
    //

RetryGetDefaultServer:

    if ( err = GetDefaultServer(
                   _dwPort,
                   fVerify,
                   szDomainName,
                   szServerName,
                   TRUE) ){

        hr = HRESULT_FROM_WIN32(err);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Read the naming contexts
    //


    if (_dwPort == USE_DEFAULT_GC_PORT) {
        fGCDefaulted = TRUE;
        pszNamingContext = NULL;
    } else {
        pszNamingContext = TEXT(LDAP_OPATT_DEFAULT_NAMING_CONTEXT);
    }


    hr = LdapOpenObject2(
                szDomainName,
                szServerName,
                NULL,
                &ld,
                _Credentials,
                _dwPort
                );

    if (((hr == HRESULT_FROM_WIN32(ERROR_BAD_NETPATH)) ||
         (hr == HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN)))
                    && !fVerify) {
        fVerify = TRUE;
        goto RetryGetDefaultServer ;
    }

    BAIL_ON_FAILURE(hr);

    if (!fGCDefaulted) {

        hr = LdapReadAttributeFast(
                ld,
                NULL,
                pszNamingContext,
                &aValuesNamingContext,
                &nCountValues
                );

        BAIL_ON_FAILURE(hr);

        if ( nCountValues == 0 ) {

            //
            // The hr will be modified at the end of the function to S_FALSE
            // in case of error

            BAIL_ON_FAILURE(hr = E_FAIL);

        }

        hr = BuildADsPathFromLDAPPath2(
                        FALSE,              //Server is present till DSSnapin Works
                        _pszNamespace,
                        szDomainName,
                        _dwPort,
                        fGCDefaulted ?
                            TEXT("") :
                            aValuesNamingContext[0],
                        &pszNewADsPath
                        );

    } else {
        //
        // In this case we want to force it to be GC://yourDomain
        // so that all searches will be truly global
        //

        hr = BuildADsPathFromLDAPPath2(
                 TRUE, // server is present
                 _pszNamespace,
                 szDomainName,
                 _dwPort,
                 TEXT(""),
                 &pszNewADsPath
                 );

    }

    BAIL_ON_FAILURE(hr);

    // this part is common to both code paths
    hr = BuildADsParentPath(
              pszNewADsPath,
              &pszNewADsParent,
              &pszNewADsCommonName
              );
    BAIL_ON_FAILURE(hr);

    nCountValues = 0;

    //
    // Read the object class of the path if necessary
    //

    if (!fGCDefaulted) {

        hr = LdapReadAttributeFast(
                 ld,
                 aValuesNamingContext[0],
                 L"objectClass",
                 &aValuesObjectClass,
                 &nCountValues
                 );

        BAIL_ON_FAILURE(hr);

    }

    if ( nCountValues == 0 && !fGCDefaulted)
    {
        // This object exists but does not contain objectClass attribute
        // which is required for all DS objects. Hence, ignore the object
        // and return error.

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Create the object
    //

    if (fGCDefaulted) {

        hr = CLDAPGenObject::CreateGenericObject(
                 pszNewADsParent,
                 pszNewADsCommonName,
                 L"top",
                 _Credentials,
                 ADS_OBJECT_BOUND,
                 IID_IUnknown,
                 (void **) ppDispatch
                 );

    } else {
        //
        // Send all the classes so we can load all extensions
        //
        hr = CLDAPGenObject::CreateGenericObject(
                 pszNewADsParent,
                 pszNewADsCommonName,
                 aValuesObjectClass,
                 nCountValues,
                 _Credentials,
                 ADS_OBJECT_BOUND,
                 IID_IDispatch,
                 (void **) ppDispatch
                 );
    }

    BAIL_ON_FAILURE(hr);

error:


    if ( aValuesNamingContext )
        LdapValueFree( aValuesNamingContext );

    if ( aValuesObjectClass )
        LdapValueFree( aValuesObjectClass );

    if ( pszNewADsPath )
        FreeADsStr( pszNewADsPath );

    if ( pszNewADsParent) {
       FreeADsStr(pszNewADsParent);
    }

    if (pszNewADsCommonName) {
       FreeADsStr(pszNewADsCommonName);
    }

    if ( ld ){
        LdapCloseObject( ld );
    }

    RRETURN_ENUM_STATUS(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cdssrch.cxx ===
//--------------LDAP----------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdssrch.cxx
//
//  Contents:  Microsoft ADs LDAP Provider Generic Object
//
//
//  History:   03-02-97     ShankSh    Created.
//
//----------------------------------------------------------------------------
#include "ldap.hxx"
#include "stdio.h"
#pragma hdrstop

//
// Sets the appropriate search preferences.
//


HRESULT
CLDAPGenObject::SetSearchPreference(
    IN PADS_SEARCHPREF_INFO pSearchPrefs,
    IN DWORD   dwNumPrefs
    )
{

    HRESULT hr = S_OK;

    //
    // Need to initialize the searchprefs in case this fn
    // is being called for the 2nd time.
    //
    LdapInitializeSearchPreferences(&_SearchPref, TRUE);

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsSetSearchPreference(
             pSearchPrefs,
             dwNumPrefs,
             &_SearchPref,
             _pszLDAPServer,
             _pszLDAPDn,
             _Credentials,
             _dwPort
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::ExecuteSearch(
    IN LPWSTR pszSearchFilter,
    IN LPWSTR * pAttributeNames,
    IN DWORD dwNumberAttributes,
    OUT PADS_SEARCH_HANDLE phSearchHandle
    )
{

    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsExecuteSearch(
             _SearchPref,
             _ADsPath,
             _pszLDAPServer,
             _pszLDAPDn,
             pszSearchFilter,
             pAttributeNames,
             dwNumberAttributes,
             phSearchHandle
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::AbandonSearch(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{

    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsAbandonSearch(
             hSearchHandle
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::CloseSearchHandle (
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsCloseSearchHandle(
             hSearchHandle
             );

    RRETURN(hr);

}


HRESULT
CLDAPGenObject::GetFirstRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetFirstRow(
             hSearchHandle,
             _Credentials
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::GetNextRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetNextRow(
             hSearchHandle,
             _Credentials
             );

    RRETURN(hr);
}

HRESULT
CLDAPGenObject::GetPreviousRow(
    IN ADS_SEARCH_HANDLE hSearchHandle
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetPreviousRow(
             hSearchHandle,
             _Credentials
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::GetColumn(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    IN LPWSTR pszColumnName,
    OUT PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetColumn(
             hSearchHandle,
             pszColumnName,
             _Credentials,
             _dwPort,
             pColumn
             );

    RRETURN(hr);
}



HRESULT
CLDAPGenObject::GetNextColumnName(
    IN ADS_SEARCH_HANDLE hSearchHandle,
    OUT LPWSTR * ppszColumnName
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsGetNextColumnName(
             hSearchHandle,
             ppszColumnName
             );

    RRETURN(hr);
}


HRESULT
CLDAPGenObject::FreeColumn(
    IN PADS_SEARCH_COLUMN pColumn
    )
{
    HRESULT hr = S_OK;

    //
    // Make sure that the last error is reset
    //
    Macro_ClearADsLastError(L"LDAP Provider");

    hr = ADsFreeColumn(
             pColumn
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\ldap\cenumobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  LDAP Object Enumeration Code
//
//              CLDAPGenObjectEnum::CLDAPGenObjectEnum()
//              CLDAPGenObjectEnum::CLDAPGenObjectEnum
//
//  History:
//----------------------------------------------------------------------------
#include "ldap.hxx"
#pragma hdrstop

HRESULT
BuildLDAPFilterArray(
    VARIANT vFilter,
    LPTSTR  *ppszFilter
);

#define FILTER_BUFFER_LEN 256

//+---------------------------------------------------------------------------
//
//  Function:   CLDAPEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLDAPGenObjectEnum::Create(
    CLDAPGenObjectEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    PADSLDP pLdapHandle,
    IADs *pADs,
    VARIANT vFilter,
    CCredentials& Credentials,
    DWORD dwOptReferral,
    DWORD dwPageSize
    )
{
    HRESULT hr = NOERROR;
    CLDAPGenObjectEnum FAR* penumvariant = NULL;
    TCHAR *pszLDAPServer = NULL;
    DWORD dwModificationTime = 0L;
    DWORD dwNumberOfEntries = 0L;
    LPTSTR aStrings[2];
    DWORD dwPort = 0;
    WCHAR **aValues = NULL;
    int nCount = 0;
    DWORD totalCount = 0;
    DWORD dwcEntriesReturned = 0;


    PLDAPControl    pPagedControl = NULL;
    LDAPControl     referralControl =
                    {
                        LDAP_CONTROL_REFERRALS_W,
                        {
                            sizeof( DWORD ), (PCHAR) &dwOptReferral
                        },
                        TRUE
                    };

    PLDAPControl    clientControls[2] =
                    {
                        &referralControl,
                        NULL
                    };


    PLDAPControl    serverControls[2] = {NULL, NULL};
    PLDAPControl    *serverReturnedControls = NULL;

    penumvariant = new CLDAPGenObjectEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    penumvariant->_dwOptReferral = dwOptReferral;
    penumvariant->_dwPageSize = dwPageSize;

    hr = BuildLDAPFilterArray(
                vFilter,
                &penumvariant->_pszFilter
                );

    if ( FAILED(hr) || !penumvariant->_pszFilter )  // this might happen when vFilter is empty
    {
        hr = S_OK;
        penumvariant->_pszFilter = AllocADsStr(TEXT("(objectClass=*)"));

        if ( penumvariant->_pszFilter == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    penumvariant->_Credentials = Credentials;

    hr = BuildLDAPPathFromADsPath2(
                ADsPath,
                &pszLDAPServer,
                &penumvariant->_pszLDAPDn,
                &dwPort
     