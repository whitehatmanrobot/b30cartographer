gister is TRUE, the created object is registered as the calling
	thread's component manager.
	Returns TRUE if successful. */
MSOAPI_(BOOL) MsoFCreateStdComponentManager(
	IUnknown *piUnkOuter,
	IMsoComponentHost *pich,
	BOOL fRegister,
	REFIID riid,
	void **ppvObj);

#endif // MSOCI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbout.h ===
#include "ConvBase.h"

class CInccHzGbOut : public CINetCodeConverter
{
public:
	CInccHzGbOut();
	~CInccHzGbOut() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	BOOL fDoubleByte;
	BYTE byLead;
	BOOL fGBMode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\jisin.h ===
#include "ConvBase.h"

// This class converts a Internet code page, ISO-2022-JP (known as JIS), into a Windows code page, 932 (known as Shift-JIS).

class CInccJisIn : public CINetCodeConverter
{
public:
	CInccJisIn();
	~CInccJisIn() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	HRESULT (CInccJisIn::*pfnNextProc)(BOOL fCleanUp, BYTE by, long lParam);
	long lNextParam;

	BOOL fKanaMode; // Indicates converting Hankaku(Single Byte) Katakana Code (>= 0x80) by SI/SO.
	BOOL fKanjiMode; // Indicates converting Double Byte Codes.

	HRESULT ConvMain(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvEsc(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanjiIn2(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanjiIn3(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanjiOut2(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvStar(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKanji(BOOL fCleanUp, BYTE byJisTrail, long lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbin.h ===
#include "ConvBase.h"

class CInccHzGbIn : public CINetCodeConverter
{
public:
	CInccHzGbIn();
	~CInccHzGbIn() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	HRESULT (CInccHzGbIn::*pfnNextProc)(BOOL fCleanUp, BYTE by, long lParam);
	long lNextParam;

	BOOL fGBMode;

	HRESULT ConvMain(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvTilde(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvDoubleByte(BOOL fCleanUp, BYTE byTrail, long lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\jisin.cpp ===
// =================================================================================
// Internet Character Set Conversion: Input from IS-2022-JP
// =================================================================================

#include "pch.hxx"
#include "JisIn.h"
#include "FEChrCnv.h"

int JIS_to_ShiftJIS (CONV_CONTEXT *pcontext, UCHAR *pJIS, int JIS_len, UCHAR *pSJIS, int SJIS_len)
{
	long lConvertedSize;

	if (!SJIS_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccJisIn;

		if (FAILED(((CInccJisIn*)pcontext->pIncc0)->GetStringSizeA(pJIS, JIS_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccJisIn;

		if (FAILED(((CInccJisIn*)pcontext->pIncc)->ConvertStringA(pJIS, JIS_len, pSJIS, SJIS_len, &lConvertedSize)))
			return -1;
	}

	if (!pJIS) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccJisIn::CInccJisIn()
{
	pfnNextProc = ConvMain;
	fKanaMode = FALSE;
	fKanjiMode = FALSE;
}

HRESULT CInccJisIn::ConvertByte(BYTE by)
{
	return (this->*pfnNextProc)(FALSE, by, lNextParam);
}

HRESULT CInccJisIn::CleanUp()
{
	return (this->*pfnNextProc)(TRUE, 0, lNextParam);
}

HRESULT CInccJisIn::ConvMain(BOOL fCleanUp, BYTE by, long lParam)
{
	HRESULT hr = S_OK;

	if (!fCleanUp) {
		switch (by) {
		case SO:
			fKanaMode = TRUE;
			break;

		case SI:
			fKanaMode = FALSE;
			break;

		default:
			if (fKanaMode) {
				hr = Output(by | 0x80);
			} else {
				if (by == ESC) {
					pfnNextProc = ConvEsc;
				} else {
					if (fKanjiMode) {
						if (by == '*') {
							pfnNextProc = ConvStar;
						} else {
							pfnNextProc = ConvKanji;
							lNextParam = (long)by;
						}
					} else {
						hr = Output(by);
					}
				}
			}
			break;
		}
	}
	return hr;
}

HRESULT CInccJisIn::ConvEsc(BOOL fCleanUp, BYTE by, long lParam)
{
	if (!fCleanUp) {
		switch (by) {
		case KANJI_IN_1ST_CHAR:
			pfnNextProc = ConvKanjiIn2;
			return ResultFromScode(S_OK);

		case KANJI_OUT_1ST_CHAR:
			pfnNextProc = ConvKanjiOut2;
			return ResultFromScode(S_OK);

		default:
			pfnNextProc = ConvMain;
			(void)Output(ESC);
			return ConvertByte(by);
		}
	} else {
		pfnNextProc = ConvMain;
		return Output(ESC);
	}
}

HRESULT CInccJisIn::ConvKanjiIn2(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		switch (by) {
		case KANJI_IN_2ND_CHAR1:
		case KANJI_IN_2ND_CHAR2:
			fKanjiMode = TRUE;
			return ResultFromScode(S_OK);

		case KANJI_IN_2ND_CHAR3:
			pfnNextProc = ConvKanjiIn3;
			return ResultFromScode(S_OK);

		default:
			(void)Output(ESC);
			(void)ConvertByte(KANJI_IN_1ST_CHAR);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(KANJI_IN_1ST_CHAR);
		return CleanUp();
	}
}

HRESULT CInccJisIn::ConvKanjiIn3(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == KANJI_IN_3RD_CHAR) {
			fKanjiMode = TRUE;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			(void)ConvertByte(KANJI_IN_1ST_CHAR);
			(void)ConvertByte(KANJI_IN_2ND_CHAR3);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(KANJI_IN_1ST_CHAR);
		(void)ConvertByte(KANJI_IN_2ND_CHAR3);
		return CleanUp();
	}
}

HRESULT CInccJisIn::ConvKanjiOut2(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		switch (by) {
		case KANJI_OUT_2ND_CHAR1:
		case KANJI_OUT_2ND_CHAR2:
			fKanjiMode = FALSE;
			return ResultFromScode(S_OK);

		default:
			(void)Output(ESC);
			(void)ConvertByte(KANJI_OUT_1ST_CHAR);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(KANJI_OUT_1ST_CHAR);
		return CleanUp();
	}
}

HRESULT CInccJisIn::ConvStar(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;
	if (!fCleanUp) {
		return Output(by | 0x80);
	} else {
		return Output('*');
	}
}

HRESULT CInccJisIn::ConvKanji(BOOL fCleanUp, BYTE byJisTrail, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		BYTE bySJisLead;
		BYTE bySJisTrail;

		bySJisLead = ((BYTE)lParam - 0x21 >> 1) + 0x81;
		if (bySJisLead > 0x9f)
			bySJisLead += 0x40;

		bySJisTrail = byJisTrail + ((BYTE)lParam & 1 ? 0x1f : 0x7d);
		if (bySJisTrail >= 0x7f)
			bySJisTrail++;

		(void)Output(bySJisLead);
		return Output(bySJisTrail);
	} else {
		return Output((BYTE)lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbin.cpp ===
// =================================================================================
// Internet Character Set Conversion: Input from HZ-GB-2312
// =================================================================================

#include "pch.hxx"
#include "HzGbIn.h"
#include "FEChrCnv.h"

int HZGB_to_GB2312 (CONV_CONTEXT *pcontext, UCHAR *pHZGB, int HZGB_len, UCHAR *pGB2312, int GB2312_len)
{
	long lConvertedSize;

	if (!GB2312_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccHzGbIn;

		if (FAILED(((CInccHzGbIn*)pcontext->pIncc0)->GetStringSizeA(pHZGB, HZGB_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccHzGbIn;

		if (FAILED(((CInccHzGbIn*)pcontext->pIncc)->ConvertStringA(pHZGB, HZGB_len, pGB2312, GB2312_len, &lConvertedSize)))
			return -1;
	}

	if (!pHZGB) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccHzGbIn::CInccHzGbIn()
{
	pfnNextProc = ConvMain;
	fGBMode = FALSE;
}

HRESULT CInccHzGbIn::ConvertByte(BYTE by)
{
	return (this->*pfnNextProc)(FALSE, by, lNextParam);
}

HRESULT CInccHzGbIn::CleanUp()
{
	return (this->*pfnNextProc)(TRUE, 0, lNextParam);
}

HRESULT CInccHzGbIn::ConvMain(BOOL fCleanUp, BYTE by, long lParam)
{
	HRESULT hr = S_OK;

	if (!fCleanUp) {
		if (!fGBMode) {
			if (by == '~') {
				pfnNextProc = ConvTilde;
			} else {
				hr = Output(by);
			}
		} else {
			if (by >= 0x20 && by <= 0x7e) {
				pfnNextProc = ConvDoubleByte;
				lNextParam = (long)by;
			} else {
				hr = Output(by);
			}
		}
	}
	return hr;
}

HRESULT CInccHzGbIn::ConvTilde(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		switch (by) {
		case '~':
			return Output('~');

		case '{':
			fGBMode = TRUE;
			return ResultFromScode(S_OK);

		case '\n':
			// Just eat it
			return ResultFromScode(S_OK);

		default:
			(void)Output('~');
			return ConvertByte(by);
		}
	} else {
		return Output('~');
	}
}

HRESULT CInccHzGbIn::ConvDoubleByte(BOOL fCleanUp, BYTE byTrail, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if ((BYTE)lParam >= 0x21 && (BYTE)lParam <= 0x77 && byTrail >= 0x21 && byTrail <= 0x7e) { // Check if GB char
			(void)Output((BYTE)lParam | 0x80);
			return Output(byTrail | 0x80);
		} else if ((BYTE)lParam == '~' && byTrail == '}') { // 0x7e7d
			fGBMode = FALSE;
			return ResultFromScode(S_OK);
		} else if ((BYTE)lParam >= 0x78 && (BYTE)lParam <= 0x7d && byTrail >= 0x21 && byTrail <= 0x7e) { // Check if non standard extended code
			(void)Output(0xa1); // Output blank box symbol
			return Output(0xf5);
		} else if ((BYTE)lParam == '~') {
			(void)Output('~'); // Output blank box symbol
			return Output(byTrail);
		} else if ((BYTE)lParam == ' ') {
			return Output(byTrail);
		} else if (byTrail == ' ') {
			(void)Output(0xa1); // Output space symbol
			return Output(0xa1);
		} else {
			(void)Output((BYTE)lParam);
			return Output(byTrail);
		}
	} else {
		return Output((BYTE)lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\hzgbout.cpp ===
// =================================================================================
// Internet Character Set Conversion: Output to HZ-GB-2312
// =================================================================================

#include "pch.hxx"
#include "HzGbOut.h"
#include "FEChrCnv.h"

int GB2312_to_HZGB (CONV_CONTEXT *pcontext, UCHAR *pGB2312, int GB2312_len, UCHAR *pHZGB, int HZGB_len)
{
	long lConvertedSize;

	if (!HZGB_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccHzGbOut;

		if (FAILED(((CInccHzGbOut*)pcontext->pIncc0)->GetStringSizeA(pGB2312, GB2312_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccHzGbOut;

		if (FAILED(((CInccHzGbOut*)pcontext->pIncc)->ConvertStringA(pGB2312, GB2312_len, pHZGB, HZGB_len, &lConvertedSize)))
			return -1;
	}

	if (!pGB2312) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccHzGbOut::CInccHzGbOut()
{
	fDoubleByte = FALSE;
	fGBMode = FALSE;
}

HRESULT CInccHzGbOut::ConvertByte(BYTE by)
{
	HRESULT hr = S_OK;

	if (!fDoubleByte) {
		if (by & 0x80) {
			fDoubleByte = TRUE;
			byLead = by;
		} else {
			if (fGBMode) {
				(void)Output('~');
				hr = Output('}');
				fGBMode = FALSE;
			}
			hr = Output(by);
		}
	} else {
		fDoubleByte = FALSE;
		if (!fGBMode) {
			(void)Output('~');
			(void)Output('{');
			fGBMode = TRUE;
		}
		(void)Output(byLead & 0x7f);
		hr = Output(by & 0x7f);
	}
	return hr;
}

HRESULT CInccHzGbOut::CleanUp()
{
	HRESULT hr = S_OK;

	if (fGBMode) {
		(void)Output('~');
		hr = Output('}');
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\fechrcnv.h ===
// Copyright (c) 1995  Microsoft Corpration
//
// File Name : fechrcnv.h
// Owner     : Tetsuhide Akaishi
// Revision  : 1.00 07/20/'95 Tetsuhide Akaishi
//

#ifdef __cplusplus
extern "C" {
#endif 

// Shift JIS Kanji Code Check
#define SJISISKANJI(c) ( ( (UCHAR)(c) >= 0x81 && (UCHAR)(c) <= 0x9f ) || \
                         ( (UCHAR)(c) >= 0xe0 && (UCHAR)(c) <= 0xfc ) )

// Shift JIS Kana Code Check
#define SJISISKANA(c) ( (UCHAR)(c) >= 0xa1 && (UCHAR)(c) <= 0xdf )

#define ESC     0x1b
#define SO      0x0e
#define SI      0x0f

#define IS2022_IN_CHAR           '$'
#define IS2022_IN_KSC_CHAR1      ')'
#define IS2022_IN_KSC_CHAR2      'C'

// Define for JIS Code Kanji and Kana IN/OUT characters
#define KANJI_IN_1ST_CHAR       '$'
#define KANJI_IN_2ND_CHAR1      'B'
#define KANJI_IN_2ND_CHAR2      '@'
#define KANJI_IN_2ND_CHAR3      '('
#define KANJI_IN_3RD_CHAR       'D'
#define KANJI_IN_STR            "$B"
#define KANJI_IN_LEN             3
#define KANJI_OUT_1ST_CHAR      '('
#define KANJI_OUT_2ND_CHAR1     'J'
#define KANJI_OUT_2ND_CHAR2     'B'
#define KANJI_OUT_LEN            3
#define KANJI_OUT_STR           "(J"


// Define for Internet Code Type
#define CODE_UNKNOWN            0
#define CODE_ONLY_SBCS          0
#define CODE_JPN_JIS            1
#define CODE_JPN_EUC            2
#define CODE_JPN_SJIS           3
#define CODE_PRC_CNGB           4
#define CODE_PRC_HZGB           5
#define CODE_TWN_BIG5           6
#define CODE_KRN_KSC            7
#define CODE_KRN_UHC            8

// Minimum length to determine if the string is EUC
#define MIN_JPN_DETECTLEN      48

typedef struct _dbcs_status
{
    int nCodeSet;
    UCHAR cSavedByte;
    BOOL fESC;
} DBCS_STATUS;

typedef struct _conv_context
{
    DBCS_STATUS dStatus0;
    DBCS_STATUS dStatus;
    
    BOOL blkanji0;  // Kanji In Mode
    BOOL blkanji;   // Kanji In Mode
    BOOL blkana;    // Kana Mode
    int  nCurrentCodeSet;

    void* pIncc0;
    void* pIncc;
} CONV_CONTEXT;

// ----------------------------------
// Public Functions for All FarEast
//-----------------------------------

// Convert from PC Code Set to UNIX Code Set
int WINAPI PC_to_UNIX (
    void *pcontext,
    int CodePage,
    int CodeSet,
    UCHAR *pPC,
    int PC_len,
    UCHAR *pUNIX,
    int UNIX_len
    );

// Convert from UNIX Code Set to PC Code Set
int WINAPI UNIX_to_PC (
    void *pcontext,
    int CodePage,
    int CodeSet,
    UCHAR *pUNIX,
    int UNIX_len,
    UCHAR *pPC,
    int PC_len
    );

//--------------------------------
// Internal Functions for Japanese
//--------------------------------

// Detect Japanese Code
int DetectJPNCode ( UCHAR *string, int len );

// Convert from Shift JIS to JIS
int ShiftJIS_to_JIS (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from Shift JIS to EUC
int ShiftJIS_to_EUC (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

#ifdef NOTIMPLEMENTED
// Convert from JIS  to EUC
int JIS_to_EUC (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );
#endif

// Convert from JIS to Shift JIS
int JIS_to_ShiftJIS (
    CONV_CONTEXT *pcontext,
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

#ifdef NOTIMPLEMENTED
// Convert from EUC to JIS
int EUC_to_JIS (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );
#endif

// Convert from EUC to Shift JIS
int EUC_to_ShiftJIS (
    CONV_CONTEXT *pcontext,
    UCHAR *pEUC,
    int EUC_len,
    UCHAR *pShiftJIS,
    int ShiftJIS_len
    );

//--------------------------------
// Internal Functions for PRC
//--------------------------------

// Convert from HZ-GB to GB2312
int HZGB_to_GB2312 (
    CONV_CONTEXT *pcontext,
    UCHAR *pGB2312,
    int GB2312_len,
    UCHAR *pHZGB,
    int HZGB_len
    );

// Convert from GB2312 to HZ-GB
int GB2312_to_HZGB (
    CONV_CONTEXT *pcontext,
    UCHAR *pGB2312,
    int GB2312_len,
    UCHAR *pHZGB,
    int HZGB_len
    );

//--------------------------------
// Internal Functions for Korea
//--------------------------------

// Convert from KSC to Hangeul
int KSC_to_Hangeul (
    CONV_CONTEXT *pcontext,
    UCHAR *pHangeul,
    int Hangeul_len,
    UCHAR *pKSC,
    int KSC_len
    );

// Convert from Hangeul to KSC
int Hangeul_to_KSC (
    CONV_CONTEXT *pcontext,
    UCHAR *pHangeul,
    int Hangeul_len,
    UCHAR *pKSC,
    int KSC_len
    );

void WINAPI FCC_Init( PVOID );
int WINAPI FCC_GetCurrentEncodingMode( PVOID );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscin.cpp ===
// =================================================================================
// Internet Character Set Conversion: Input from IS-2022-KR
// =================================================================================

#include "pch.hxx"
#include "KscIn.h"
#include "FEChrCnv.h"

int KSC_to_Hangeul (CONV_CONTEXT *pcontext, UCHAR *pKSC, int KSC_len, UCHAR *pHangeul, int Hangeul_len)
{
	long lConvertedSize;

	if (!Hangeul_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccKscIn;

		if (FAILED(((CInccKscIn*)pcontext->pIncc0)->GetStringSizeA(pKSC, KSC_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccKscIn;

		if (FAILED(((CInccKscIn*)pcontext->pIncc)->ConvertStringA(pKSC, KSC_len, pHangeul, Hangeul_len, &lConvertedSize)))
			return -1;
	}

	if (!pKSC) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccKscIn::CInccKscIn()
{
	pfnNextProc = ConvMain;
	fIsoMode = FALSE;
	fKscMode = FALSE;
}

HRESULT CInccKscIn::ConvertByte(BYTE by)
{
	return (this->*pfnNextProc)(FALSE, by, lNextParam);
}

HRESULT CInccKscIn::CleanUp()
{
	return (this->*pfnNextProc)(TRUE, 0, lNextParam);
}

HRESULT CInccKscIn::ConvMain(BOOL fCleanUp, BYTE by, long lParam)
{
	HRESULT hr = S_OK;

	if (!fCleanUp) {
		if (by == ESC) {
			pfnNextProc = ConvEsc;
		} else {
			if (fIsoMode) {
				switch (by) {
				case SO:
					fKscMode = TRUE;
					break;

				case SI:
					fKscMode = FALSE;
					break;

				default:
					if (fKscMode) {
						switch (by) {
						case ' ':
						case '\t':
						case '\n':
							hr = Output(by);
							break;

						default:
							hr = Output(by | 0x80);
							break;
						}
					} else {
						hr = Output(by);
					}
					break;
				}
			} else {
				hr = Output(by);
			}
		}
	}
	return hr;
}

HRESULT CInccKscIn::ConvEsc(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == IS2022_IN_CHAR) {
			pfnNextProc = ConvIsoIn;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			return ConvertByte(by);
		}
	} else {
		return Output(ESC);
	}
}

HRESULT CInccKscIn::ConvIsoIn(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == IS2022_IN_KSC_CHAR1) {
			pfnNextProc = ConvKsc1st;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			(void)ConvertByte(IS2022_IN_CHAR);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(IS2022_IN_CHAR);
		return CleanUp();
	}
}

HRESULT CInccKscIn::ConvKsc1st(BOOL fCleanUp, BYTE by, long lParam)
{
	pfnNextProc = ConvMain;

	if (!fCleanUp) {
		if (by == IS2022_IN_KSC_CHAR2) {
			fIsoMode = TRUE;
			return ResultFromScode(S_OK);
		} else {
			(void)Output(ESC);
			(void)ConvertByte(IS2022_IN_CHAR);
			(void)ConvertByte(IS2022_IN_KSC_CHAR1);
			return ConvertByte(by);
		}
	} else {
		(void)Output(ESC);
		(void)ConvertByte(IS2022_IN_CHAR);
		(void)ConvertByte(IS2022_IN_KSC_CHAR1);
		return CleanUp();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscout.h ===
#include "ConvBase.h"

class CInccKscOut : public CINetCodeConverter
{
public:
	CInccKscOut();
	~CInccKscOut() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	BOOL fDoubleByte;
	BYTE byLead;
	BOOL fIsoMode;
	BOOL fKscMode;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\pch_c.h ===
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shfusion.h>
/*#include "common.h"*/

/*#ifdef NT_BUILD*/
#include <shlobjp.h>
#include <shlguidp.h>
#include <comctrlp.h>
/*#endif*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscout.cpp ===
// =================================================================================
// Internet Character Set Conversion: Output to IS-2022-KSC
// =================================================================================

#include "pch.hxx"
#include "KscOut.h"
#include "FEChrCnv.h"

int Hangeul_to_KSC (CONV_CONTEXT *pcontext, UCHAR *pHangeul, int Hangeul_len, UCHAR *pKSC, int KSC_len)
{
	long lConvertedSize;

	if (!KSC_len) {
		// Wanted the converted size
		if (!pcontext->pIncc0)
			pcontext->pIncc0 = new CInccKscOut;

		if (FAILED(((CInccKscOut*)pcontext->pIncc0)->GetStringSizeA(pHangeul, Hangeul_len, &lConvertedSize)))
			return -1;
	} else {
		if (!pcontext->pIncc)
			pcontext->pIncc = new CInccKscOut;

		if (FAILED(((CInccKscOut*)pcontext->pIncc)->ConvertStringA(pHangeul, Hangeul_len, pKSC, KSC_len, &lConvertedSize)))
			return -1;
	}

	if (!pHangeul) {
		// Let's clean up our context here.
		if (pcontext->pIncc0) {
			delete pcontext->pIncc0;
			pcontext->pIncc0 = NULL;
		}
		if (pcontext->pIncc) {
			delete pcontext->pIncc;
			pcontext->pIncc = NULL;
		}
		return 0;
	}

	return (int)lConvertedSize;
}

CInccKscOut::CInccKscOut()
{
	fDoubleByte = FALSE;
	fIsoMode = FALSE;
	fKscMode = FALSE;
}

HRESULT CInccKscOut::ConvertByte(BYTE by)
{
	HRESULT hr = S_OK;

	if (!fIsoMode) {
		(void)Output(ESC);
		(void)Output(IS2022_IN_CHAR);
		(void)Output(IS2022_IN_KSC_CHAR1);
		(void)Output(IS2022_IN_KSC_CHAR2);
		fIsoMode = TRUE;
	}
	if (!fDoubleByte) {
		if (by > 0x80) {
			fDoubleByte = TRUE;
			byLead = by;
		} else {
			if (fIsoMode && fKscMode) {
				(void)Output(SI);
				fKscMode = FALSE;
			}
			hr = Output(by);
		}
	} else {
		fDoubleByte = FALSE;
		if (by > 0x40) { // Check if trail byte indicates Hangeul
			if (!fKscMode) {
				(void)Output(SO);
				fKscMode = TRUE;
			}
			if (byLead > 0xa0 && by > 0xa0) { // Check if it's a Wansung
				(void)Output(byLead & 0x7f);
				hr = Output(by & 0x7f);
			} else {
				(void)Output(0x22); // Replace to inversed question mark
				hr = Output(0x2f);
			}
		} else {
			if (fIsoMode && fKscMode) {
				(void)Output(SI);
				fKscMode = FALSE;
			}
			(void)Output(byLead);
			hr = Output(by);
		}
	}
	return hr;
}

HRESULT CInccKscOut::CleanUp()
{
	if (!fDoubleByte)
		return S_OK;
	else
		return Output(byLead);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\kscin.h ===
#include "ConvBase.h"

class CInccKscIn : public CINetCodeConverter
{
public:
	CInccKscIn();
	~CInccKscIn() {}
	virtual HRESULT ConvertByte(BYTE by);
	virtual HRESULT CleanUp();

private:
	HRESULT (CInccKscIn::*pfnNextProc)(BOOL fCleanUp, BYTE by, long lParam);
	long lNextParam;

	BOOL fIsoMode;
	BOOL fKscMode;

	HRESULT ConvMain(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvEsc(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvIsoIn(BOOL fCleanUp, BYTE by, long lParam);
	HRESULT ConvKsc1st(BOOL fCleanUp, BYTE by, long lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\sjis2euc.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2euc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"

//Shift JIS(SJC) to EUC Conversion algorithm
//Two byte KANJI
//  - 1st byte of Shift JIS charcter 
//	  (XX = Hex value of 1st byte of Shift JIS Charcter)
//    Range 0x81 - 0x9f
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xa1-0xdd
//              EUC 1st byte = (XX-0x81)*2 + 0xa1
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0x81)*2 + 0xa2
//
//    Range 0xe0 - 0xef
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xdf-0xfd
//              EUC 1st byte = (XX-0xe0)*2 + 0xdf
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0xe0)*2 + 0xe0
//
//  - 2nd byte of Shift JIS charcter 
//	  (YY = Hex value of 2nd byte of Shift JIS Charcter)
//    Range 0x40 - 0x7e                       (EUC)0xa1 - 0xdf
//              EUC 2nd byte = (YY+0x61)
//    Range 0x80 - 0x9e                       (EUC)0xe0 - 0xfe
//              EUC 2nd byte = (YY+0x60)
//    Range 0x9f - 0xfc                       (EUC)0xa1 - 0xfe
//              EUC 2nd byte = (YY+0x02)
//
//  Range 0x0a1 - 0x0df(Hankaku KATAKANA)
//    1st byte of EUC charcter = 0x08e
//    2nd byte if EUC charcter = C6220 Hankaku KATAKANA code
//    (same byte value as Shift JIS Hankaku KATAKANA) (0x0a1 - 0x0df)

//@
// 
// Syntax:

int ShiftJISChar_to_EUCChar ( UCHAR *pShiftJIS, UCHAR *pEUC )


// The ShiftJISChar_to_EUCChar function convert one Shift JIS character 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//
// Return Value
//      The number of bytes to copy.
//

{
	if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
		}
		goto SECOND_BYTE;
	}
	if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
		}
		goto SECOND_BYTE;
	}

	// Is the charcter Hankaku KATAKANA ?
	if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
		*pEUC = 0x08e;
		*(pEUC+1) = *pShiftJIS;
		return( 2 );
	}
	// Is the charcter IBM Extended Charcter?
	if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
		// There are no IBM Extended Charcte in EUC charset.
		*pEUC = ' ';
		*(pEUC+1) = ' ';
		return( 2 );
	}
		// Is the charcter ASCII charcter ?
	*pEUC = *pShiftJIS;
	return ( 1 );

SECOND_BYTE:
	if ( *(pShiftJIS+1) >= 0x040 && *(pShiftJIS+1) <= 0x07e ) {
		*(pEUC+1) = *(pShiftJIS + 1) + 0x061;
	}
	else {
		if ( *(pShiftJIS+1) >= 0x080 && *(pShiftJIS+1) <= 0x09e ) {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x060;
		}
		else {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x002;
		}
	}
	return ( 2 );
}


int ShiftJIS_to_EUC ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pEUC, int EUC_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a EUC code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//         
// int   EUC_len        Specifies the size, in EUC characters of the buffer
//                      pointed to by the pEUC parameter. If the value is zero,
//                      the function returns the number of EUC characters 
//                      required for the buffer, and makes no use of the pEUC 
//                      buffer.
//
// Return Value
// If the function succeeds, and EUC_len is nonzero, the return value is the 
// number of EUC characters written to the buffer pointed to by pEUC.
//
// If the function succeeds, and EUC_len is zero, the return value is the
// required size, in EUC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pEUC buffer
// is small for setting converted strings.
//

{

    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
    
    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( EUC_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {
                pShiftJIS+=2;
                i+=2;
                re+=2;
                continue;
            }
            if ( SJISISKANA(*pShiftJIS) ) {
                pShiftJIS++;
                i++;
                re+=2;
                continue;
            }
            pShiftJIS++;
            i++;
            re++;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            *pEUC = 0x08e;
            pEUC++;
            (*pEUC) = *pShiftJIS;
            re+=2;
            i++;
            pShiftJIS++;
            pEUC++;
            continue;
        }

        // Is the charcter IBM Extended Charcter?
        if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            // There are no IBM Extended Charcte in EUC charset.
            *pEUC = ' ';
            pEUC++;
            (*pEUC) = ' ';
            re+=2;
            i+=2;
            pShiftJIS+=2;
            pEUC++;
            continue;
	}

        // Is the charcter ASCII charcter ?
        if ( re  >= EUC_len ) {    // Buffer Over?
            return ( -1 );
        }
        *pEUC = *pShiftJIS;
        re++;
        i++;
        pShiftJIS++;
        pEUC++;
        continue;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\pc2unix.c ===
// File Name:   pc2unix.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"



int FE_PC_to_UNIX (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                           UCHAR *pPCChar, int PCChar_len,
                           UCHAR *pUNIXChar, int UNIXChar_len )
// The FE_PC_to_UNIX function convert a character string as PC code 
// set string to a Japanese UNIX code set string. 
//
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pPCChar string 
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pPCChar string 
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pPCChar       Points to the character string to be converted.
//         
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//         
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is 
//                      zero, the function returns the number of UNIX characters 
//                      required for the buffer, and makes no use of the 
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is 
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar 
// buffer is small for setting converted strings.
//
//@
{
    int    re;

        switch ( CodeSet ) {
        default:
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from Shift JIS to JIS
			if (pPCChar) {
				re = ShiftJIS_to_JIS ( pPCChar, PCChar_len,
											   pUNIXChar, UNIXChar_len );
			} else {
				re = 0;
			}
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from Shift JIS to EUC
			if (pPCChar) {
				re = ShiftJIS_to_EUC ( pPCChar, PCChar_len,
											   pUNIXChar, UNIXChar_len );
			} else {
				re = 0;
			}
            break;
        case CODE_KRN_KSC:    // Korean KSC
            // Convert from Hangeul to KSC
            re = Hangeul_to_KSC ( pcontext, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_PRC_HZGB:   // PRC HZ-GB
            // Convert from GB2312 to HZ-GB
            re = GB2312_to_HZGB ( pcontext, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
        case CODE_KRN_UHC:     // Korean UHC
        case CODE_PRC_CNGB:    // PRC CN-GB
        case CODE_TWN_BIG5:    // Taiwanese BIG5
            // Convert from Shift JIS to Shift JIS
			if (pPCChar) {
				if ( PCChar_len == -1 ) {
					PCChar_len = strlen ( pPCChar ) + 1;
				}
				if ( UNIXChar_len != 0 ) {
					if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
						return ( -1 );
					}
					// Copy from pPCChar to pUNIXChar
					memmove ( pUNIXChar, pPCChar, PCChar_len );
				}
				re = PCChar_len;
			} else {
				re = 0;
			}
            break;
        }
		return ( re );
}


int WINAPI PC_to_UNIX (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                        UCHAR *pPCChar, int PCChar_len,
                        UCHAR *pUNIXChar, int UNIXChar_len )

// The PC_to_UNIX function convert a character string as PC code 
// set string to a UNIX code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pPCChar string 
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pPCChar string 
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pPCChar       Points to the character string to be converted.
//         
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//         
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is 
//                      zero, the function returns the number of UNIX characters 
//                      required for the buffer, and makes no use of the 
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is 
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar 
// buffer is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
        case 950:    // Taiwan Code Page
        case 949:    // Korea Code Page
        case 936:    // PRC Code Page
            re = FE_PC_to_UNIX (pcontext, CodePage, CodeSet, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        default:
            // Start Only Copy Process
            if ( PCChar_len == -1 ) {
                PCChar_len = strlen ( pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) {
                if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\sjis2jis.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2jis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"

void ShiftJISChar_to_JISChar ( UCHAR *pShiftJIS, UCHAR *pJIS )

// The ShiftJISChar_to_JISChar function convert one character string 
// as Shift JIS code to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//
// Return Value
// None 

{
	USHORT	hi_code, low_code;

	hi_code = (*pShiftJIS);
	low_code = *(pShiftJIS+1);
	hi_code -= (hi_code > 0x9f ? 0xb1 : 0x71);
	hi_code = hi_code * 2 + 1;
	if ( low_code > 0x9e ) {
		low_code -= 0x7e;
		hi_code ++;
	}
	else {
		if ( low_code > 0x7e ) {
			low_code --;
		}
		low_code -= 0x1f;
	}
	*(pJIS) = (UCHAR)hi_code;
	*(pJIS+1) = (UCHAR)low_code;
	return;
}


int ShiftJIS_to_JIS ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pJIS, int JIS_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//         
// int   JIS_len        Specifies the size, in JIS characters of the buffer
//                      pointed to by the pJIS parameter. If the value is zero,
//                      the function returns the number of JIS characters 
//                      required for the buffer, and makes no use of the pJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and JIS_len is nonzero, the return value is the 
// number of JIS characters written to the buffer pointed to by pJIS.
//
// If the function succeeds, and JIS_len is zero, the return value is the
// required size, in JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pJIS buffer
// is small for setting converted strings.
//

{
    BOOL    kanji_in = FALSE;      // Kanji Mode
    BOOL    kana_in = FALSE;       // Kana  Mode
    int     re;                    // Convert Lenght
    int     i;                     // Loop Counter

    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( JIS_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
                if ( kana_in ) {            // Kana Mode?
                    re ++;
                    kana_in = FALSE;         // Reset Kana Mode;
                }
                if ( kanji_in == FALSE ) {  // Kanji Mode?
                    re += KANJI_IN_LEN;
                    kanji_in = TRUE;        // Set Kanji Mode
                }

                i+=2;
                re += 2;
                pShiftJIS+=2;
            }
            else if ( SJISISKANA(*pShiftJIS) ) {
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                if ( kana_in == FALSE ) {
                     re ++;
                     kana_in = TRUE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
            else {
                if ( kana_in ) {
                    re ++;
                    kana_in = FALSE;
                }
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
        }
        if ( kana_in ) {
            re ++;
            kana_in = FALSE;
        }
        if ( kanji_in ) {
            re += KANJI_OUT_LEN;
            kanji_in = FALSE;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
            if ( kana_in ) {            // Kana Mode?
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;     // Set Kana Out Charcter
                re ++;
                kana_in = FALSE;         // Reset Kana Mode;
            }
            if ( kanji_in == FALSE ) {  // Kanji Mode?
                if ( re + KANJI_IN_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = ESC;    // Set Kanji In Charcter
                (*pJIS++) = KANJI_IN_1ST_CHAR;
                (*pJIS++) = KANJI_IN_2ND_CHAR1;
                re += KANJI_IN_LEN;
                kanji_in = TRUE;        // Set Kanji Mode
            }

            if ( re + 2 > JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            ShiftJISChar_to_JISChar ( pShiftJIS, pJIS );
            i+=2;
            re += 2;
            pShiftJIS+=2;
            pJIS += 2;
        }
        else if ( SJISISKANA(*pShiftJIS) ) {
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( kana_in == FALSE ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SO;	// Set Kana In Charcter
                re ++;
                kana_in = TRUE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++) & 0x7f;
            i++;
            re++;
        }
        else {
            if ( kana_in ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;	// Set Kana Out Charcter
                re ++;
                kana_in = FALSE;
            }
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++);
            i++;
            re++;
        }
    }
    if ( kana_in ) {
        if ( re >= JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        (*pJIS++) = SI;	// Set Kana Out Charcter
        re ++;
        kana_in = FALSE;
    }
    if ( kanji_in ) {
        if ( re + KANJI_OUT_LEN  > JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        // Set Kanji Out Charcter
        (*pJIS++) = ESC;
        (*pJIS++) = KANJI_OUT_1ST_CHAR;
        (*pJIS++) = KANJI_OUT_2ND_CHAR1;
        re += KANJI_OUT_LEN;
        kanji_in = FALSE;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\help\mailnews.h ===
//Generic text for all groupbox labels
#define IDH_NEWS_COMM_GROUPBOX                  353500

//Columns dialog box: View menu, columns
#define IDH_NEWS_COL_AVAIL                      353501
#define IDH_NEWS_COL_DISPL                      353502
#define IDH_NEWS_COL_ADD                        353503
#define IDH_NEWS_COL_REMOVE                     353504
#define IDH_NEWS_COL_MOVEUP                     353505
#define IDH_NEWS_COL_MOVEDN                     353506
#define IDH_NEWS_COL_RESET                      353507

//Columns dialog: View menu, columns (mail)
#define IDH_VIEW_COLUMNS_LIST                 	50400
#define IDH_VIEW_COLUMNS_MOVE_UP                50405
#define IDH_VIEW_COLUMNS_MOVE_DOWN            	50410
#define IDH_VIEW_COLUMNS_SHOW                	50415
#define IDH_VIEW_COLUMNS_HIDE                	50420
#define IDH_VIEW_COLUMNS_WIDTH                	50425

//Newsgroups dialog box
#define IDH_NEWS_SERVER_LIST                    353508
#define IDH_NEWS_SEARCH_GROUPS_CONTAINING       353509
#define IDH_NEWS_GROUP_LISTS                    353510
//#define IDH_NEWS_FAVES_ONLY                     353511
#define IDH_NEWS_SEARCH_GROUPS_DESC             353512
#define IDH_NEWS_OPEN_SELECTED_GROUP            353513
#define IDH_NEWS_ADD_SELECTED_GROUP             353514
#define IDH_NEWS_REMOVE_SELECTED_GROUP          353515
//#define IDH_NEWS_NEW_LIST                       353516
//#define IDH_NEWS_UPDATE_NEW_LIST_NOW            353517
#define IDH_NEWS_RESET_NEW_LIST                 353518
#define IDH_NEWSGROUP_LIST_ALL                  353511
#define IDH_NEWSGROUP_LIST_SUBSCRIBE            353516
#define IDH_NEWSGROUP_LIST_NEW                  353517


//News menu, Options
////Read tab
#define IDH_NEWS_OPT_READ_MARK_MESSAGE_READ     353521
#define IDH_NEWS_OPT_CHECK_FOR_NEW              353522


////Read Tab, Tools/Options menu
#define IDH_MAIL_OPT_READ_MARK_READ             25252509
#define IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ         353519
#define IDH_NEWS_OPT_READ_AUTO_EXPAND           353520
#define IDH_NEWS_OPT_IN_PREVIEW                 353600
#define IDH_NEWS_OPT_READ_MARK_ALL_EXIT         353524
#define IDH_OPTIONS_READ_SHOW_PICTURE_ATTACHMENTS 35520
#define IDH_OPTIONS_READ_SHOW_SLIDESHOW         35525
#define IDH_OPTIONS_READ_FONT_SETTINGS          35530
#define IDH_OPTIONS_READ_INTL_SETTINGS         	35535
#define IDH_INTL_SETTINGS_READ_ENCODING         35540
#define IDH_INTL_SETTINGS_READ_DEFAULT_ENCODING  35545

#define IDH_OPT_READ_TOOLTIPS			502050
#define IDH_OPT_READ_CHAR_SETS			502055
#define IDH_OPT_READ_REMOVE_CHARSET		502060
#define IDH_OPTIONS_READ_WATCH_COLOR		35526

//General tab, Tools/Options menu
#define IDH_MAIL_OPT_READ_CHECK_4NEW            25252510
#define IDH_MAIL_OPT_READ_PLYSND                25252508
#define IDH_OPT_GENERAL_NOT_CONNECTED           25252507
#define IDH_MAIL_OPT_READ_EMPTY_DELETED         25252511
#define IDH_OPTIONS_ADD_REPLIES                 25252550
#define IDH_OPTIONS_REPLY_USING_SENT_FORMAT     25252555
#define IDH_NEWS_OPT_READ_NOTIFY_NEW_NEWS       353523
#define IDH_NEWS_OPT_READ_DEFAULT               353525
#define IDH_NEWS_SEND_IM_DEFAULT                353532
#define IDH_OPTIONS_GO_TO_INBOX                 25252560
#define IDH_GENERAL_MAKE_SIMPLE_MAPI_CLIENT     25252565
#define IDH_OPT_GEN_DISP_FOLDERS		502000
#define IDH_OPTIONS_MAINT_PURGE_DEL_IMAP	502001
#define IDH_OPTIONS_MAINT_BACKGR_COMPACT	502002
#define IDH_OPTIONS_MAINT_STORE_FOLDER		502003
#define IDH_OPTIONS_GEN_MESSENGER		502004
#define IDH_MAIL_OPT_SENDREC_AT_STARTUP		502005

////Spelling tab, Tools/Options menu
#define IDH_NEWS_SPELL_SUGGEST_REPL             353561
#define IDH_NEWS_SPELL_CHECK_BEFORE_SEND        353562
#define IDH_NEWS_SPELL_IGNORE_UPPERCASE         353563
#define IDH_NEWS_SPELL_IGNORE_WITH_NUMBERS      353564
#define IDH_NEWS_SPELL_ORIGINAL_TEXT            353565
#define IDH_OPTIONS_SPELLING_INTERNET_ADDRESSES 355500
#define IDH_OPTIONS_SPELLING_LANGUAGE           355510
#define IDH_OPTIONS_SPELLING_DICTIONARY         355520
#define IDH_OPTIONS_SPELL_BACKGROUND_CHECK	355521


//Security tab, Tools/Options menu
#define IDH_OPTIONS_ADD_DIGITAL_SIGNATURE       355530
#define IDH_OPTIONS_ENCRYPT_MESSAGES            355535
#define IDH_OPTIONS_SECURITY_ADVANCED           355540
#define IDH_MORE_ON_CERTIFICATES                355541
#define IDH_GET_DIGITAL_ID                      355542
#define IDH_SECURITY_ZONES_SETTINGS             355543
#define IDH_SECURITY_DIGITAL_ID	                355544
#define IDH_SECURITY_LABEL                      355546
#define IDH_SECURITY_SETLABEL       	        355548
#define IDH_SECURITY_SENDMAIL_WARN              355549
#define IDH_SECURITY_SAFE_ATTACHMENTS           355550

//Tools/Options/Security/Label settings		
#define IDH_SECURITY_POLICY_MODULE		355502
#define IDH_SECURITY_CLASSIFICATION		355504
#define IDH_SECURITY_PRIVACY			355506
#define IDH_SECURITY_CONFIGURE			355508

//Tools/Options/Security/Advanced settings
#define IDH_SECURITY_ADVANCED_ENCRYPTION        355522        
#define IDH_SECURITY_ADVANCED_INCLUDE_SELF      355523
#define IDH_SECURITY_SEND_TO_OTHERS             355524
#define IDH_SECURITY_ADVANCED_INCLUDE_ID        355525
#define IDH_SECURITY_ADVANCED_INCLUDE_PKCS      355526
#define IDH_OPTIONS_SECURITY_STRENGTH_WARN	355527
#define IDH_OPTIONS_SECURITY_ADV_ADD_TO_WAB	355528
#define IDH_OPTIONS_SECURITY_ADV_REVOKE_ONLINE	355529
#define IDH_OPTIONS_SECURITY_ADV_REVOKE_NEVER	355531

//Dialup tab, Tools/Options menu
#define IDH_OPTIONS_DIALUP_DONT_CONNECT         25252570
#define IDH_OPTIONS_DIALUP_CONNECTION_NUMBER    25252575
#define IDH_OPTIONS_DIALUP_ASK                  25252580
#define IDH_OPTIONS_DIALUP_WARN_BEFORE_SWITCHING 25252585
#define IDH_OPTIONS_DIALUP_HANG_UP              25252590
#define IDH_OPTIONS_DIALUP_AUTODIAL             25252595
#define IDH_OPTIONS_DIALUP_CHANGE             	25252596

//Advanced tab, Tools/Options menu
#define IDH_DELETE_AFTER_XXDAYS                 353740
#define IDH_DELETE_READ                         353745
#define IDH_COMPACT_WHEN_WASTED                 353750
#define IDH_CLEAN_UP_BUTTON                     353755
#define IDH_OPTIONS_NEWS_TRANSPORT              355560
#define IDH_OPTIONS_MAIL_TRANSPORT              355565
#define IDH_OPTIONS_HTTPLOG			355567
#define IDH_OPTIONS_OFFLINE_LOG                 355570
#define IDH_OPTIONS_IMAP_TRANSPORT              355575
#define IDH_ADVANCED_STORE_FOLDER               355576

////Send tab
#define IDH_NEWS_SEND_SAVE_COPY                 353526
#define IDH_NEWS_SEND_AUTO_WORD_SELECT          353527
#define IDH_NEWS_SEND_MESS_IN_REPLY             353528
#define IDH_NEWS_SEND_INDENT_WITH               353529
#define IDH_NEWS_SEND_ADV_SETTINGS              353530
#define IDH_NEWS_SEND_SAVE_COPY_SENT_ITEMS      353531
#define IDH_NEWS_MAILSEND_ADV_SETTINGS          353533
#define IDH_OPTIONS_SEND_SETTINGS_SEND_PICTURE  35660
#define IDH_MAIL_SEND_CHECK_ADDRESS		502065
#define IDH_OPT_SEND_INDENT_REPLY		502066
#define IDH_OPT_SEND_INDENT_WITH_X		502067


////Send tab (Mail)
#define IDH_MAIL_SEND_SAVE_COPY                 25252512
#define IDH_MAIL_SEND_IM_DEFAULT                25252516


//////Send tab, Advanced Settings 
#define IDH_NEWSMAIL_SEND_ADVSET_CHARSET        353534
#define IDH_NEWSMAIL_SEND_ADVSET_MIME           353535
#define IDH_NEWSMAIL_SEND_ADVSET_UUENCODE       353536
#define IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR   353538
#define IDH_NEWSMAIL_SEND_ADVSET_SEND_IMMED     353539
#define IDH_NEWSMAIL_SEND_ADVSET_ENCODE_WITH    353540


////Fonts tab
#define IDH_NEWS_FONTS_REPLY_SAMPLE             353557
#define IDH_NEWS_FONTS_FORMATS_NOT_INCLUDED     353558
#define IDH_NEWS_FONTS_IN_QUOTED                353559
#define IDH_NEWS_CHANGE                         353560


///Signature tab
#define IDH_NEWS_SIGNATURE_NONE                 353566
#define IDH_NEWS_SIGNATURE_TEXT                 353567
#define IDH_NEWS_SIGNATURE_FILE                 353568
#define IDH_NEWS_SIGNATURE_ADD_TO_ALL           353569
#define IDH_NEWS_SIGNATURE_NOT_REPLIES          353609
#define IDH_STATIONERY_NEW_SIGNATURE		35591
#define IDH_STATIONERY_REMOVE_SIGNATURE		35592
#define IDH_STATIONERY_RENAME_SIGNATURE		35593
#define IDH_STATIONERY_SIGNATURE_LIST		35594
#define IDH_STATIONERY_MAKE_DEFAULT_SIG		35596
#define IDH_STATIONERY_SIG_ADVANCED		35597


//Spelling dialog box
#define IDH_NEWS_SPELL_NOT_IN_DICT              353583
#define IDH_NEWS_SPELL_CHANGE_TO                353584
#define IDH_NEWS_SPELL_SUGGESTIONS              353585
#define IDH_NEWS_SPELL_OPTIONS                  353586
#define IDH_NEWS_SPELL_UNDO_LAST                353587
#define IDH_NEWS_SPELL_IGNORE                   353588
#define IDH_NEWS_SPELL_CHANGE                   353589
#define IDH_NEWS_SPELL_ADD                      353590
#define IDH_NEWS_SPELL_CANCEL                   353591
#define IDH_NEWS_SPELL_IGNORE_ALL               353592
#define IDH_NEWS_SPELL_CHANGE_ALL               353593
#define IDH_NEWS_SPELL_SUGGEST                  353594

//customize tool bar procedure for Help button in dlg
//#define IDH_PROCED_CUST_TOOL                    353700

//New ids
#define IDH_SEND_HTML                           353705
#define IDH_SEND_PLAINTEXT                      353710
#define IDH_SEND_SETTINGS                       353715
#define IDH_SEND_SETTINGS_HTML			353718
#define IDH_START_IN_LAST_NEWSGROUP             353720
#define IDH_SEND_SETTING_8BIT_HEADINGS          353725


//Mark Newsgroups dlg
#define IDH_NEWS_DWNLOAD_GET_ALL                354007  //All subscribed newsgroups
#define IDH_NEWS_DWNLOAD_GET_SELECTED           354008  //selected newsgroups
#define IDH_NEWS_DWNLOAD_GET_SELECTED_LIST      354009  //newsgroups list
#define IDH_NEWS_DWNLOAD_HEADERS                354010  //download headers only
#define IDH_NEWS_DWNLOAD_ENTIRE                 354011  //download entire message
#define IDH_NEWS_DWNLOAD_DONT_OLD_POSTS         354012  //Don't download new messages more than xx
#define IDH_NEWS_DWNLOAD_NOW_BUTTON             354013  //Download now button

//Format Font dialog box
#define IDH_FORMAT_FONT_FONT                    35420
#define IDH_FORMAT_FONT_FONTSTYLE               35425
#define IDH_FORMAT_FONT_SIZE                    35430
#define IDH_FORMAT_FONT_SAMPLE                  35435
#define IDH_FORMAT_FONT_COLOR                   35440
#define IDH_FORMAT_FONT_UNDERLINE               35445 
#define IDH_FORMAT_FONT_PALETTE               	35446

//Insert Picture (image) dialog box
#define IDH_INSERT_PICTURE_IMAGESOURCE          35450
#define IDH_INSERT_PICTURE_ALT_TEXT             35455
#define IDH_INSERT_PICTURE_LAYOUT               35460
#define IDH_INSERT_PICTURE_BROWSE               35462

#define IDH_INSERT_PICTURE_ALIGNMENT            35465
#define IDH_INSERT_PICTURE_BORDER               35470
#define IDH_INSERT_PICTURE_HSPACING             35475
#define IDH_INSERT_PICTURE_VSPACING             35480

//Insert Attachment dialog box
#define IDH_INSERT_ATTACHMENT_MAKE_SHORTCUT     35500

//Edit Link dialog box
#define IDH_INSERT_LINK_LINKINFO                35550

//Stationery dialog box, Tools menu
#define IDH_STATIONERY_FONT_SETTINGS            35560
#define IDH_STATIONERY_MY_FONT                  35565
#define IDH_STATIONERY_USE_STATIONERY           35570
#define IDH_STATIONERY_SELECT                   35575
#define IDH_STATIONERY_SIGNATURE                35580
#define IDH_STATIONERY_SAMPLE	                35585
#define IDH_STATIONERY_NAME	                35586
#define IDH_STATIONERY_USE_SELECTED             35587

//Signature dialog box, Tools/Stationery menu
#define IDH_STATIONERY_ADD_SIGNATURE            35590
#define IDH_STATIONERY_ADD_TEXT                 35595
#define IDH_STATIONERY_ADD_FILE                 35600
#define IDH_STATIONERY_BROWSE_FILES             35605
#define IDH_STATIONERY_DONT_ADD_SIGNATURE       35610
#define IDH_STATIONERY_INCLUDE_BUS_CARD		35611
#define IDH_STATIONERY_DISPLAY_BUS_CARD		35612
#define IDH_STATIONERY_NEW_BUSINESS_CARD        35615
#define IDH_STATIONERY_EDIT_BUSINESS_CARD       35620
#define IDH_STATIONERY_ATTACH_BUSINESS_CARD     35625
#define IDH_STATIONERY_ENTER_BUSINESS_CARD      35630
#define IDH_STATIONERY_CREATENEW		35632

//Select stationery dialog box, Tools/Stationery menu
#define IDH_STATIONERY_LISTBOX                  35635
#define IDH_STATIONERY_PREVIEW                  35640
#define IDH_STATIONERY_EDIT                     35645
#define IDH_STATIONERY_GET_MORE                 35650
#define IDH_STATIONERY_BROWSE_PICTURE           35655
#define IDH_STATIONERY_SHOW_PREVIEW           	35656

//Window Layout Properties (View/Layout menu)
#define  IDH_LAYOUT_OUTLOOK_BAR                 35700
#define  IDH_LAYOUT_CONTACTS                 	35702
#define  IDH_LAYOUT_STATUS_BAR                 	35704
#define  IDH_LAYOUT_TOOLBAR                 	35706
#define  IDH_LAYOUT_VIEWS_BAR                 	35708
#define  IDH_LAYOUT_FOLDER_LIST                 35710
#define  IDH_LAYOUT_INFO_PANE                 	35712
#define  IDH_LAYOUT_FOLDER_BAR                  35715
#define  IDH_LAYOUT_TIP_OF_DAY                  35720
#define  IDH_LAYOUT_TOOLBAR_MOVE                35725
#define  IDH_LAYOUT_SHOW_TEXT                   35730
#define  IDH_LAYOUT_CUSTOMIZE_BUTTONS           35735
#define  IDH_LAYOUT_PREVIEW_PANE                35740
#define  IDH_LAYOUT_PREVIEW_PANE_MOVE           35745
#define  IDH_LAYOUT_SHOW_HEADERS                35750

//Format Background Sound/Picture
#define IDH_BACKGR_FILE				50180
#define IDH_BACKGR_BROWSE			50185
#define IDH_BACKGR_SOUND_PLAY_X_TIMES		50190
#define IDH_BACKGR_SOUND_PLAY_CONTINUOUS	50195

//Misc
#define IDH_FORMAT_PARA_ALIGN			50200
#define IDH_FORMAT_PARA_BULLETS			50205
#define IDH_MAIL_NEW_USING_WEB			50210
#define IDH_MAILNEWS_BLOCK_SENDER_ADDRESS	50215
#define IDH_MAILNEWS_BLOCK_SENDER_BLOCKTYPE	50220

//Edit menu, Find options
#define IDH_FIND_TEXT				50300
#define IDH_FIND_NEXT				50305
#define IDH_FIND_IN_DOWNLOADED			50310
#define IDH_FIND_ADVANCED			50315

//Tools menu, IMAP folders
#define IDH_IMAP_SERVER_LIST			50500
#define IDH_IMAP_DISPLAY_FOLDERS_CONTAINING	50505
#define IDH_IMAP_FOLDER_LIST			50510
#define IDH_IMAP_OPEN_SELECTED_FOLDER		50515
#define IDH_IMAP_SHOW_SELECTED_FOLDER		50520
#define IDH_IMAP_HIDE_SELECTED_FOLDER		50525
#define IDH_IMAP_RESET_LIST			50530

//View menu, Current View / Customize Current View
#define IDH_VIEW_CUSTOM_CONDITIONS		50600
#define IDH_VIEW_CUSTOM_DESCRIPTION		50605
#define IDH_VIEW_CUSTOM_NAME			50610

//Tools/Message Rules/Mail Rules tab and News Rule Tab
#define IDH_RULES_NEW				50700
#define IDH_RULES_MODIFY			50705
#define IDH_RULES_COPY				50710
#define IDH_RULES_REMOVE			50715
#define IDH_RULES_APPLYNOW			50720
#define IDH_RULES_MOVEUP			50725
#define IDH_RULES_MOVEDOWN			50730
#define IDH_RULES_DESCRIPTION			50735

//Tools/Message Rules/Mail Rules or News Rules/New (Mail or News) Rules and Edit (maile or News) Rules
#define IDH_NEWRULE_CONDITION			50740
#define IDH_NEWRULE_ACTION			50745
#define IDH_NEWRULE_DESCRIPTION			50750
#define IDH_NEWRULE_NAME			50755

//Tools/Messatge Rules/Mail or News tabs/Apply now
#define IDH_APPLYRULES_SELECT			50760
#define IDH_APPLYRULES_SELECTALL		50765
#define IDH_APPLYRULES_SELECTNONE		50770
#define IDH_APPLYRULES_DESCRIPTION		50775
#define IDH_APPLYRULES_FOLDER			50780
#define IDH_APPLYRULES_SUBFOLDERS		50785
#define IDH_APPLYRULES_BROWSE			50790
#define IDH_APPLYRULES_APPLYNOW			50795

//Tools/Message Rules/June Mail tab
#define IDH_JUNKMAIL_DETECT			50800
#define IDH_JUNKMAIL_EXCEPTIONS			50805
#define IDH_JUNKMAIL_ADJUST			50810
#define IDH_JUNKMAIL_DELETE			50815

//Tools/Message Rules/Blocked Senders tab
#define IDH_BLOCKSENDERS_ADD			50820
#define IDH_BLOCKSENDERS_MODIFY			50825
#define IDH_BLOCKSENDERS_REMOVE			50830

//View/Current View/Customize current view and 
//View/Current View/Define Views/New and Modify
#define IDH_VIEW_CONDITIONS			50840
#define IDH_VIEW_DESCRIPTION			50845
#define IDH_VIEW_NAME				50850

//View/Current View/Define Views
#define IDH_DEFINEVIEWS_NEW			50860
#define IDH_DEFINEVIEWS_MODIFY			50865
#define IDH_DEFINEVIEWS_COPY			50870
#define IDH_DEFINEVEIWS_REMOVE			50875
#define IDH_DEFINEVIEWS_APPLY			50880
#define IDH_DEFINEVIEWS_DESCRIPTION		50885

//Tools/Options/Send/International setings
#define IDH_INTL_SETTINGS_DEFAULT_ENCODING	50910
#define IDH_INTL_SETTINGS_RTL                   50912
#define IDH_INTL_SETTINGS_HEADER_SETTINGS	50915

//Receipts Tab, Tools/Options menu
#define IDH_RECEIPTS_REQUEST			50260
#define IDH_RECEIPTS_NEVER			50266
#define IDH_RECEIPTS_ASK			50270
#define IDH_RECEIPTS_ALWAYS			50275
#define IDH_RECEIPTS_EXCEPTIONS			50280
#define IDH_RECEIPTS_SECURE			50285

//Secure Receipt Options dialog box, Tools/Options/Receipts menu
#define IDH_SECURERECEIPTS_REQUEST		50230
#define IDH_SECURERECEIPTS_NEVER		50235
#define IDH_SECURERECEIPTS_ASK			50240
#define IDH_SECURERECEIPTS_ALWAYS		50245
#define IDH_SECURERECEIPTS_ENCRYPT		50250
#define IDH_SECURERECEIPTS_VERIFY		50255

// Virus protection help
#define IDH_MAIL_VIRUS_TO               		70000
#define IDH_MAIL_VIRUS_SUBJECT               	70001
#define IDH_MAIL_VIRUS_SEND               		70002
#define IDH_MAIL_VIRUS_DONT_SEND               	70003
#define IDH_MAIL_VIRUS_HELP_BUTTON              70004
#define IDH_MAIL_VIRUS_HELP_TEXT               	70005

//Online tab of WAB properties
#define IDH_WAB_ONLINE_ADDNEW               96969740
#define IDH_WAB_ONLINE_ADD                  96969742
#define IDH_WAB_ONLINE_SETAS                96969744
#define IDH_WAB_ONLINE_SENDIM               96969746
#define IDH_WAB_ONLINE_LIST                 96969748
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\status.c ===
// File Name:   status.c
// Owner:       Masahiro Teragawa
// Revision:    1.00  08/23/'95  Masahiro Teragawa
//              Made it thread safe 2/23/96 yutakan
//

#include "pch_c.h"
#include "fechrcnv.h"

#if 0 // yutakan: will be initialized anyway.
#ifdef DBCS_DIVIDE
DBCS_STATUS dStatus0 = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji0 = FALSE;  // Kanji In Mode

DBCS_STATUS dStatus  = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji = FALSE;  // Kanji In Mode
BOOL blkana  = FALSE;  // Kana Mode
#endif  // DBCS_DIVIDE

int nCurrentCodeSet = CODE_UNKNOWN;
#endif

/*********************************************************************/
/* Function:   FCC_Init                                              */
/*********************************************************************/
void WINAPI FCC_Init( PVOID pcontext )
{
    if (!pcontext)
        return;
          
#ifdef DBCS_DIVIDE
    ((CONV_CONTEXT *)pcontext)->dStatus0.nCodeSet = CODE_UNKNOWN;
    ((CONV_CONTEXT *)pcontext)->dStatus0.cSavedByte = '\0';
    ((CONV_CONTEXT *)pcontext)->dStatus0.fESC = FALSE;

    ((CONV_CONTEXT *)pcontext)->blkanji0 = FALSE;

    ((CONV_CONTEXT *)pcontext)->dStatus.nCodeSet = CODE_UNKNOWN;
    ((CONV_CONTEXT *)pcontext)->dStatus.cSavedByte = '\0';
    ((CONV_CONTEXT *)pcontext)->dStatus.fESC = FALSE;

    ((CONV_CONTEXT *)pcontext)->blkanji = FALSE;
    ((CONV_CONTEXT *)pcontext)->blkana  = FALSE;
#endif  // DBCS_DIVIDE

    ((CONV_CONTEXT *)pcontext)->nCurrentCodeSet = CODE_UNKNOWN;

    ((CONV_CONTEXT *)pcontext)->pIncc0 = NULL;
    ((CONV_CONTEXT *)pcontext)->pIncc = NULL;

    return;
}

/*********************************************************************/
/* Function:   FCC_GetCurrentEncodingMode                            */
/*********************************************************************/
int WINAPI FCC_GetCurrentEncodingMode(void * pcontext )
{
    return pcontext?((CONV_CONTEXT *)pcontext)->nCurrentCodeSet:0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\http\httputil.h ===
/*
 *  h t t p u t i l. h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Utility functions used to implement http mail.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _HTTPUTIL_H
#define _HTTPUTIL_H

void Http_FreeTargetList(LPHTTPTARGETLIST pTargets);

HRESULT Http_NameFromUrl(LPCSTR pszUrl, LPSTR pszBuffer, DWORD *pdwBufferLen);

HRESULT Http_AddMessageToFolder(IMessageFolder *pFolder,
                                LPSTR pszAcctId,
                                LPHTTPMEMBERINFO pmi,
                                MESSAGEFLAGS dwFlags,
                                LPSTR pszUrl,
                                LPMESSAGEID pidMessage);

HRESULT Http_SetMessageStream(IMessageFolder *pFolder, 
                              MESSAGEID idMessage, 
                              IStream *pStream,
                              LPFILEADDRESS pfa,
                              BOOL fSetDisplayProps);
#endif // _HTTPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\fechrcnv\unix2pc.c ===
// File Name:   unix2pc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "pch_c.h"
#include "fechrcnv.h"

int FE_UNIX_to_PC (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                           UCHAR *pUNIXChar, int UNIXChar_len,
                           UCHAR *pPCChar, int PCChar_len )

// The FE_UNIX_to_PC function convert a character string as Japanese UNIX code 
// set string to a PC code set string. 
//
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
{
    int   re;
#ifdef DBCS_DIVIDE
    int   i = 0, nDelta = 0;



    if ( PCChar_len == 0 && pcontext->dStatus0.nCodeSet != CODE_UNKNOWN)
        CodeSet = pcontext->dStatus0.nCodeSet;
    else if ( PCChar_len != 0 && pcontext->dStatus.nCodeSet != CODE_UNKNOWN )
        CodeSet = pcontext->dStatus.nCodeSet;
    else
#endif

    if ( pcontext->nCurrentCodeSet == CODE_UNKNOWN ) {
        if ( CodeSet == CODE_UNKNOWN ) {
            if ( ( CodeSet = DetectJPNCode ( pUNIXChar, UNIXChar_len ) )
                                           == CODE_ONLY_SBCS ) {
                CodeSet = CODE_JPN_JIS;
            }
        }
        pcontext->nCurrentCodeSet = CodeSet;
    } 
    else
        CodeSet = pcontext->nCurrentCodeSet;

    switch ( CodeSet ) {
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from JIS to Shift JIS
            re = JIS_to_ShiftJIS (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from EUC to Shift JIS
            re = EUC_to_ShiftJIS (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_KRN_KSC:    // Korean KSC
            // Convert from KSC to Hangeul
            re = KSC_to_Hangeul (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_PRC_HZGB:   // PRC HZ-GB
            // Convert from HZ-GB to GB2312
            re = HZGB_to_GB2312 (pcontext, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        default:
        case CODE_ONLY_SBCS:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }

            if ( PCChar_len != 0 ) {
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;

        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
        case CODE_KRN_UHC:     // Korean UHC
        case CODE_PRC_CNGB:    // PRC CN-GB
        case CODE_TWN_BIG5:    // Taiwanese BIG5
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }

            if ( PCChar_len != 0 ) {
#ifdef DBCS_DIVIDE
                UCHAR *pPCCharEnd = pPCChar + PCChar_len - 1;
                if ( pcontext->dStatus.nCodeSet == CODE_JPN_SJIS && pcontext->dStatus.cSavedByte){
                    *pPCChar++ = pcontext->dStatus.cSavedByte;
                    *pPCChar = *pUNIXChar;
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    pcontext->dStatus.nCodeSet = CODE_UNKNOWN;
                    pcontext->dStatus.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByteEx(CodePage, *(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            pcontext->dStatus.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            pcontext->dStatus.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus.cSavedByte = *(pUNIXChar + i);
                            *(pPCChar + i) = '\0';
                            --UNIXChar_len;
                            break;
                        }
                        if(pPCChar + i > pPCCharEnd)  // check destination buf
                            break;
                        *(pPCChar + i++) = *(pUNIXChar + i);
                        *(pPCChar + i++) = *(pUNIXChar + i);
                    } else
                        *(pPCChar + i++) = *(pUNIXChar + i);
                }
#else
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
#endif
            }
#ifdef DBCS_DIVIDE
            else {   // Only retrun the required size
                if ( pcontext->dStatus0.nCodeSet == CODE_JPN_SJIS ){ // 1st byte was saved
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    pcontext->dStatus0.nCodeSet = CODE_UNKNOWN;
                    pcontext->dStatus0.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByteEx(CodePage, *(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            pcontext->dStatus0.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            pcontext->dStatus0.nCodeSet = CODE_JPN_SJIS;
                            pcontext->dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        }
                        i+=2;
                    } else
                        i++;
                }
            }
#endif
            re = UNIXChar_len;
            break;
    }
    return ( re );
}




int WINAPI UNIX_to_PC (CONV_CONTEXT *pcontext, int CodePage, int CodeSet,
                        UCHAR *pUNIXChar, int UNIXChar_len,
                        UCHAR *pPCChar, int PCChar_len )

// The UNIX_to_PC function convert a character string as UNIX code 
// set string to a PC code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
//@
{
        int     re;

        // we have to run on the given context to be multi-thread safe.
        if(!pcontext) return 0;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
        case 950:    // Taiwan Code Page
        case 949:    // Korea Code Page
        case 936:    // PRC Code Page
            re = FE_UNIX_to_PC (pcontext, CodePage, CodeSet, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        default:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }
            if ( PCChar_len != 0 ) {
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\http\httpserv.h ===
/*
 *  h t t p s e r v . h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Derives from IMessageServer to implement HTTPMail-specific 
 *           store communication.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _HTTPSERV_H
#define _HTTPSERV_H

#include "tmap.h"
#include "simpstr.h"

class CFolderList;

class CHTTPMailServer;
typedef HRESULT (CHTTPMailServer::*PFNHTTPOPFUNC)(void);
typedef HRESULT (CHTTPMailServer::*PFNHTTPRESPFUNC)(LPHTTPMAILRESPONSE pResponse);

typedef struct tagHTTPSTATEFUNCS
{
    PFNHTTPOPFUNC   pfnOp;      // operation function
    PFNHTTPRESPFUNC pfnResp;    // response function
} HTTPSTATEFUNCS, *LPHTTPSTATEFUNCS;

typedef struct tagMARKEDMESSAGE
{
    MESSAGEID       idMessage;
    MESSAGEFLAGS    dwFlags;
    BOOL            fMarked;
} MARKEDMESSAGE, *LPMARKEDMESSAGE;

typedef struct tagNEWMESSAGEINFO
{
    LPSTR           pszUrlComponent;
} NEWMESSAGEINFO, *LPNEWMESSAGEINFO;

#define HTTPCOPYMOVE_OUTOFSPACE     0x00000001
#define HTTPCOPYMOVE_ERROR          0x00000002

typedef struct tagHTTPOPERATION
{
    STOREOPERATIONTYPE      tyOperation;
    const HTTPSTATEFUNCS    *pfnState;
    BOOL                    fCancel;
    BOOL                    fStateWillAdvance;
    BOOL                    fNotifiedComplete;
    int                     iState;
    int                     cState;
    IStoreCallback          *pCallback;

    DWORD                   dwOptions;

    long                    lIndex;

    FOLDERID                idFolder;
    SYNCFOLDERFLAGS         dwSyncFlags;
    CFolderList             *pFolderList;

    IMessageFolder          *pMessageFolder;

    LPSTR                   pszProblem;

    LPSTR                   pszDestFolderUrl;
    LPSTR                   pszDestUrl;

    MESSAGEID               idMessage;
    FILEADDRESS             faStream;
    IStream                 *pMessageStream;

    TMap<CSimpleString, MARKEDMESSAGE>  *pmapMessageId;
    CSortedArray            *psaNewMessages;

    LPSTR                   pszFolderName;
    LPSTR                   pszAdUrl;

    FLDRFLAGS               dwFldrFlags;

    MESSAGEFLAGS            dwMsgFlags;

    // folder synchronization
    DWORD                   cMessages;
    DWORD                   cUnread;

    // setmessage flags
    BOOL                    fMarkRead;
    DWORD                   dwSetFlags;
    IPropPatchRequest       *pPropPatchRequest;
    DWORD                   dwIndex;
    LPMESSAGEIDLIST         pIDList;
    HROWSET                 hRowSet;

    // batch copy move errors
    DWORD                   dwCopyMoveErrorFlags;

    // delete message junk for
    // dealing with servers that
    // don't support message deletion (Hotmail)
    DELETEMESSAGEFLAGS      dwDelMsgFlags;
    BOOL                    fFallbackToMove;
    LPHTTPTARGETLIST        pTargets;

    MESSAGEID               idPutMessage;
    STOREERROR              error;
    DWORD                   dwMinPollingInterval;

} HTTPOPERATION, *LPHTTPOPERATION;

class CHTTPMailServer : public IMessageServer, IHTTPMailCallback, public IOperationCancel
{
public:
    //----------------------------------------------------------------------
    // Construction/Destruction
    //----------------------------------------------------------------------
    CHTTPMailServer(void);
    ~CHTTPMailServer(void);

private:
    // intentionally umimplemented copy constructor
    // and assignment operator
    CHTTPMailServer(const CHTTPMailServer& other);
    CHTTPMailServer& operator=(const CHTTPMailServer& other);

public: 
    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageServer Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP SetIdleCallback(IStoreCallback *pDefaultCallback);
    STDMETHODIMP SynchronizeFolder (SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback  *pCallback);
    STDMETHODIMP GetMessage (MESSAGEID idMessage, IStoreCallback  *pCallback);
    STDMETHODIMP PutMessage (FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream  *pStream, IStoreCallback  *pCallback);        
    STDMETHODIMP CopyMessages (IMessageFolder  *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteMessages (DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback  *pCallback);
    STDMETHODIMP SetMessageFlags (LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP GetServerMessageFlags(MESSAGEFLAGS *pFlags);
    STDMETHODIMP SynchronizeStore (FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP CreateFolder (FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP MoveFolder (FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback  *pCallback);
    STDMETHODIMP RenameFolder (FOLDERID idFolder, LPCSTR pszName, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteFolder (FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP SubscribeToFolder (FOLDERID idFolder, BOOL fSubscribe, IStoreCallback  *pCallback);
    STDMETHODIMP Close(DWORD dwFlags);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);
    STDMETHODIMP ConnectionAddRef() { return E_NOTIMPL; };
    STDMETHODIMP ConnectionRelease() { return E_NOTIMPL; };
    STDMETHODIMP GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback);
    STDMETHODIMP GetMinPollingInterval(IStoreCallback   *pCallback);
    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // IHTTPMailCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPHTTPMAILRESPONSE      pResponse);

    STDMETHODIMP GetParentWindow(
            HWND                    *phwndParent);

    //----------------------------------------------------------------------
    // IOperationCancel Members
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel);

    // ----------------------------------------------------------------------------
    // Private Implementation
    // ----------------------------------------------------------------------------
public:
    // ----------------------------------------------------------------------------
    // Operations
    // ----------------------------------------------------------------------------
    HRESULT Connect(void);
    HRESULT GetMsgFolderRoot(void);
    HRESULT BuildFolderUrl(void);
    HRESULT ListFolders(void);
    HRESULT AutoListFolders(void);
    HRESULT PurgeFolders(void);
    HRESULT ListHeaders(void);
    HRESULT PurgeMessages(void);
    HRESULT ResetMessageCounts(void);
    HRESULT GetMessage(void);
    HRESULT CreateFolder(void);
    HRESULT RenameFolder(void);
    HRESULT DeleteFolder(void);
    HRESULT CreateSetFlagsRequest(void);
    HRESULT SetMessageFlags(void);
    HRESULT ApplyFlagsToStore(void);
    HRESULT DeleteMessages(void);
    HRESULT DeleteFallbackToMove(void);
    HRESULT PurgeDeletedFromStore(void);
    HRESULT PutMessage(void);
    HRESULT AddPutMessage(void);
    HRESULT CopyMoveMessage(void);
    HRESULT BatchCopyMoveMessages(void);
    HRESULT FinalizeBatchCopyMove(void);
    HRESULT GetAdBarUrlFromServer(void);
    HRESULT GetMinPollingInterval(void);

    // ----------------------------------------------------------------------------
    // Response Handlers
    // ----------------------------------------------------------------------------
    HRESULT HandleListFolders(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleListHeaders(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleGetMessage(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleGetMsgFolderRoot(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleCreateFolder(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleRenameFolder(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleDeleteFolder(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleMemberErrors(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleDeleteFallbackToMove(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandlePutMessage(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleCopyMoveMessage(LPHTTPMAILRESPONSE pResponse);
    HRESULT HandleBatchCopyMoveMessages(LPHTTPMAILRESPONSE pResponse);

private:
    // ----------------------------------------------------------------------------
    // Other stuff(tm)
    // ----------------------------------------------------------------------------
    BOOL _CreateWnd(void);
    static LRESULT _WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT _BeginDeferredOperation(void);

    HRESULT _DoOperation(void);
    void _FreeOperation(BOOL fValidState = TRUE);

    HRESULT _DoCopyMoveMessages(STOREOPERATIONTYPE sot, IMessageFolder *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback *pCallback);

    HRESULT _LoadAccountInfo(IImnAccount *pAcct);
    HRESULT _LoadTransport(void);

    void    _Disconnect(void);
    BOOL    _FConnected(void) { return m_fConnected; }
    void    _SetConnected(BOOL fConnected) { if (m_fConnected) _Disconnect(); m_fConnected = fConnected; }

    HRESULT _CreateMessageIDMap(TMap<CSimpleString, MARKEDMESSAGE> **ppMap);
    HRESULT _HrBuildMapAndTargets(LPMESSAGEIDLIST pList, HROWSET hRowSet, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, TMap<CSimpleString, MARKEDMESSAGE> **ppMap, LPHTTPTARGETLIST *ppTargets);
    SPECIALFOLDER _TranslateHTTPSpecialFolderType(HTTPMAILSPECIALFOLDER tySpecial);
    BOOL _LoadSpecialFolderName(SPECIALFOLDER tySpecial, LPSTR pszName, DWORD cbBuffer);

    HRESULT _CopyMoveNextMessage(void);

    HRESULT _CopyMoveLocalMessage(MESSAGEID idMessage, 
                              IMessageFolder* pDestFolder,
                              LPSTR pszUrl,
                              BOOL fMoveSource);

    HRESULT _MarkMessageRead(MESSAGEID id, BOOL fRead);

    void _FillStoreError(LPSTOREERROR pErrorInfo, IXPRESULT *pResult);

    // ----------------------------------------------------------------------------
    // URL Manipulations
    // ----------------------------------------------------------------------------
    HRESULT _BuildUrl(LPCSTR pszFolderComponent, LPCSTR pszNameComponent, LPSTR *ppszUrl);
    HRESULT _BuildMessageUrl(LPCSTR pszFolderUrl, LPSTR pszNameComponent, LPSTR *ppszUrl);

private:
    LONG                            m_cRef;
    HWND                            m_hwnd;
    IMessageStore                   *m_pStore;
    IMessageFolder                  *m_pFolder;
    IHTTPMailTransport              *m_pTransport;
    LPSTR                           m_pszFldrLeafName;
    LPSTR                           m_pszMsgFolderRoot;
    FOLDERID                        m_idServer;
    FOLDERID                        m_idFolder;
    SPECIALFOLDER                   m_tySpecialFolder;
    LPSTR                           m_pszFolderUrl;
    BOOL                            m_fConnected;
    HTTPOPERATION                   m_op;
    INETSERVER                      m_rInetServerInfo;
    char                            m_szAccountName[CCHMAX_ACCOUNT_NAME];
    char                            m_szAccountId[CCHMAX_ACCOUNT_NAME];
    IImnAccount                     *m_pAccount;
    IHTTPMailTransport2             *m_pTransport2;

#ifdef DEBUG
    DWORD                           m_dwThreadId;
#endif // DEBUG
};

HRESULT CreateHTTPMailStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);

#endif // _HTTPSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\http\httputil.cpp ===
/*
 *  h t t p u t i l. c p p
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Utility functions used to implement http mail.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "httputil.h"
#include "xpcomm.h"
#include "iso8601.h"
#include "storutil.h"
#include "flagconv.h"
#include "demand.h"

//----------------------------------------------------------------------
// Http_FreeTargetList
//----------------------------------------------------------------------
void Http_FreeTargetList(LPHTTPTARGETLIST pTargets)
{
    if (pTargets)
    {
        if (pTargets->prgTarget)
        {
            for (DWORD dw = 0; dw < pTargets->cTarget; dw++)
            {
                if (pTargets->prgTarget[dw])
                    MemFree(const_cast<char *>(pTargets->prgTarget[dw]));
            }
            
            MemFree(pTargets->prgTarget);
        }
        
        MemFree(pTargets);
    }
}

//----------------------------------------------------------------------
// Http_NameFromUrl
//----------------------------------------------------------------------
HRESULT Http_NameFromUrl(LPCSTR pszUrl, LPSTR pszBuffer, DWORD *pdwBufferLen)
{
    HRESULT         hr = S_OK;
    char            szLocalBuf[MAX_PATH];
    URL_COMPONENTS  urlComponents;
    DWORD           dw = 0;

    ZeroMemory(&urlComponents, sizeof(URL_COMPONENTS));

    // use wininet to break the path out and to decode the url while
    // we're at it.
    urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
    urlComponents.lpszUrlPath = szLocalBuf;
    urlComponents.dwUrlPathLength = MAX_PATH;

    if (!InternetCrackUrl(pszUrl, lstrlen(pszUrl), NOFLAGS /* ICU_DECODE */, &urlComponents))
    {
        hr = GetLastError();
        goto exit;
    }
    
    // subtract one to start at the char before the last one. this skips
    // the last char in the case of a folder that ends in '/'
    dw = urlComponents.dwUrlPathLength - 1;
    while (dw && ('/' != szLocalBuf[dw - 1]))
        dw--;

    // dw represents the count of chars that are NOT in the
    // name. reverse it.
    dw = urlComponents.dwUrlPathLength - dw;

    if (dw >= *pdwBufferLen)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    CopyMemory(pszBuffer, &szLocalBuf[urlComponents.dwUrlPathLength - dw], dw + 1);
    *pdwBufferLen = dw;

exit:
    return hr;
}

//----------------------------------------------------------------------
// Http_AddMessageToFolder
//----------------------------------------------------------------------
HRESULT Http_AddMessageToFolder(IMessageFolder *pFolder,
                                LPSTR pszAcctId,
                                LPHTTPMEMBERINFO pmi,
                                MESSAGEFLAGS dwFlags,
                                LPSTR pszUrl,
                                LPMESSAGEID pidMessage)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     mi;
    FILETIME        ft;
    DWORD           dwTimeFlags = NOFLAGS;
    LPSTR           pszFreeFrom = NULL;
    LPSTR           pszFreeTo = NULL;
    ADDRESSLIST     addrList;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    PROPVARIANT     rDecodedSubj;
    PROPVARIANT     rDecodedFrom;
    PROPVARIANT     rDecodedTo;
    LPSTR           pszSubject = NULL;

    if (NULL == pszUrl)
        return E_INVALIDARG;

    ZeroMemory(&mi, sizeof(MESSAGEINFO));

    rDecodedSubj.vt = rDecodedFrom.vt = rDecodedTo.vt = VT_LPSTR;
    rDecodedSubj.pszVal = rDecodedFrom.pszVal = rDecodedTo.pszVal = NULL;

    // build a message info and pump the header into the store
    mi.pszAcctId = pszAcctId;

    // get the store to generate an id
    if (FAILED(hr = pFolder->GenerateId((DWORD *)&mi.idMessage)))
        goto exit;

    if (NULL != pidMessage)
        *pidMessage = mi.idMessage;

    if (FAILED(hr = Http_NameFromUrl(pszUrl, szUrlComponent, &dwUrlComponentLen)))
        goto exit;

    mi.dwFlags |= dwFlags;

    // if a message info was passed in, use its data
    if (NULL != pmi)
    {
        mi.cbMessage = pmi->dwContentLength;

        if (pmi->fRead)
            mi.dwFlags = ARF_READ;

        if (pmi->fHasAttachment)
            mi.dwFlags |= ARF_HASATTACH;

        if (NULL != pmi->pszSubject)
        {
            if (SUCCEEDED(MimeOleDecodeHeader(NULL, pmi->pszSubject, &rDecodedSubj, NULL)))
                pszSubject = rDecodedSubj.pszVal;
            else
                pszSubject = pmi->pszSubject;
            
            mi.pszSubject = pszSubject;
            mi.pszNormalSubj = SzNormalizeSubject(pszSubject);
            if (NULL == mi.pszNormalSubj)
                mi.pszNormalSubj = pszSubject;
        }

        if (pmi->pszFrom && S_OK == MimeOleParseRfc822Address(IAT_FROM, IET_ENCODED, pmi->pszFrom, &addrList))
        {
            if (addrList.cAdrs > 0)
            {
                pszFreeFrom = addrList.prgAdr[0].pszFriendly;
                addrList.prgAdr[0].pszFriendly = NULL;

                // only use the parsed address if it is at least three chars long
                if (pszFreeFrom && lstrlen(pszFreeFrom) >= 3)
                    mi.pszDisplayFrom = pszFreeFrom;
            }
            g_pMoleAlloc->FreeAddressList(&addrList);
        }

        if (NULL == mi.pszDisplayFrom && NULL != pmi->pszFrom)
        {
            if (SUCCEEDED(MimeOleDecodeHeader(NULL, pmi->pszFrom, &rDecodedFrom, NULL)))
                mi.pszDisplayFrom = rDecodedFrom.pszVal;
            else
                mi.pszDisplayFrom = pmi->pszFrom;
        }

        if (SUCCEEDED(iso8601::toFileTime(pmi->pszDate, &ft, &dwTimeFlags)))
        {
            if (!(dwTimeFlags & ISO8601_ST_HOUR))
                mi.dwFlags |= ARF_PARTIAL_RECVTIME;
            mi.ftReceived = ft;
        }
        
        if (pmi->pszTo && S_OK == MimeOleParseRfc822Address(IAT_TO, IET_ENCODED, pmi->pszTo, &addrList))
        {
            if (addrList.cAdrs > 0)
            {
                pszFreeTo = addrList.prgAdr[0].pszFriendly;
                addrList.prgAdr[0].pszFriendly = NULL;

                // only use the parsed address if it is at least three chars long
                if (pszFreeTo && lstrlen(pszFreeTo) >= 3)
                    mi.pszDisplayTo = pszFreeTo;
            }
            g_pMoleAlloc->FreeAddressList(&addrList);
        }

        if (NULL == mi.pszDisplayTo && NULL != pmi->pszTo)
        {
            if (SUCCEEDED(MimeOleDecodeHeader(NULL, pmi->pszTo, &rDecodedTo, NULL)))
                mi.pszDisplayTo = rDecodedTo.pszVal;
            else
                mi.pszDisplayTo = pmi->pszTo;
        }
    }

    mi.pszUrlComponent = szUrlComponent;

    // Add it to the database
    IF_FAILEXIT(hr = pFolder->InsertRecord(&mi));

    // normalize the response
    hr = S_OK;

exit:
    SafeMimeOleFree(rDecodedSubj.pszVal);
    SafeMimeOleFree(rDecodedFrom.pszVal);
    SafeMimeOleFree(rDecodedTo.pszVal);

    SafeMemFree(pszFreeFrom);
    SafeMemFree(pszFreeTo);

    return hr;
}

//----------------------------------------------------------------------
// Http_SetMessageStream
//----------------------------------------------------------------------
HRESULT Http_SetMessageStream(IMessageFolder *pFolder, 
                              MESSAGEID idMessage, 
                              IStream *pStream,
                              LPFILEADDRESS pfa,
                              BOOL fSetDisplayProps)
{
    HRESULT             hr = S_OK;
    IMimeMessage        *pMimeMsg = NULL;
    IMimePropertySet    *pPropertySet = NULL;
    DWORD               dwFlags = 0;
    MESSAGEINFO         mi = {0};
    LPMESSAGEINFO       pmiFree = NULL;
    FILETIME            ftCurrent;
    PROPVARIANT         rVariant;
    IMimeAddressTable   *pAdrTable = NULL;
    ADDRESSPROPS        rAddress = {0};

    LPSTR               pszDisplayFrom = NULL;
    LPSTR               pszEmailFrom = NULL;
    LPSTR               pszDisplayTo = NULL;
    LPSTR               pszEmailTo = NULL;
    LPSTR               pszMessageId = NULL;
    LPSTR               pszXref = NULL;
    LPSTR               pszReferences = NULL;
    LPSTR               pszSubject = NULL;
    LPSTR               pszNormalSubj = NULL;
    LPSTR               pszAcctId = NULL;
    LPSTR               pszAcctName = NULL;
    LPSTR               pszServer = NULL;
    LPSTR               pszForwardTo = NULL;
    LPSTR               pszMSOESRec = NULL;

    // Default Sent and Received Times...
    GetSystemTimeAsFileTime(&ftCurrent);

    // Create a Message. We can't use the folder's OpenMessage
    // method, because the folder's stream will be locked for write
    // access.
    IF_FAILEXIT(hr = MimeOleCreateMessage(NULL, &pMimeMsg));

    IF_FAILEXIT(hr = HrRewindStream(pStream));

    IF_FAILEXIT(hr = pMimeMsg->Load(pStream));

    // Get the Root Property Set from the Message
    IF_FAILEXIT(hr = pMimeMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropertySet));

    // find the message in the store
    IF_FAILEXIT(hr = GetMessageInfo(pFolder, idMessage, &mi));

    pmiFree = &mi;

    // update the fields of the message info
    if (SUCCEEDED(pMimeMsg->GetFlags(&dwFlags)))
        mi.dwFlags |= ConvertIMFFlagsToARF(dwFlags);

    // unset the download flag
    mi.dwFlags &= ~ARF_DOWNLOAD;

    // Set Variant tyStore
    rVariant.vt = VT_UI4;

    // Priority
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant)))
        mi.wPriority = (WORD)rVariant.ulVal;

    // Init Variant
    rVariant.vt = VT_FILETIME;

    if (0 == mi.ftSent.dwLowDateTime && 0 == mi.ftSent.dwHighDateTime)
    {
        if (SUCCEEDED(pMimeMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant)))
            mi.ftSent = rVariant.filetime;
        else
            mi.ftSent = ftCurrent;
    }

    if (0 == mi.ftReceived.dwLowDateTime && 0 == mi.ftReceived.dwHighDateTime)
    {
        if (SUCCEEDED(pMimeMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
            mi.ftReceived = rVariant.filetime;
        else
            mi.ftReceived = ftCurrent;
    }
    
    // Get Address Table
    IF_FAILEXIT(hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAdrTable));

    // Display From
    if (fSetDisplayProps && NULL == mi.pszDisplayFrom)
    {
        pAdrTable->GetFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &pszDisplayFrom);
        mi.pszDisplayFrom = pszDisplayFrom;
    }

    // Email From
    rAddress.dwProps = IAP_EMAIL;
    if (NULL == mi.pszEmailFrom && SUCCEEDED(pAdrTable->GetSender(&rAddress)))
    {
        pszEmailFrom = rAddress.pszEmail;
        mi.pszEmailFrom = pszEmailFrom;
    }

    // Display to
    if (fSetDisplayProps && NULL == mi.pszDisplayTo)
    {
        pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &pszDisplayTo);
        mi.pszDisplayTo = pszDisplayTo;
    }

    // Email To
    if (NULL == mi.pszEmailTo)
    {
        pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_EMAIL, &pszEmailTo);
        mi.pszEmailTo = pszEmailTo;
    }

    // String properties
    rVariant.vt = VT_LPSTR;

    // pszMessageId
    if (NULL == mi.pszMessageId && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &rVariant)))
    {
        pszMessageId = rVariant.pszVal;
        mi.pszMessageId = pszMessageId;
    }

    // pszXref
    if (NULL == mi.pszXref && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_XREF), NOFLAGS, &rVariant)))
    {
        pszXref = rVariant.pszVal;
        mi.pszXref = pszXref;
    }

    // pszReferences
    if (NULL == mi.pszReferences && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(STR_HDR_REFS), NOFLAGS, &rVariant)))
    {
        pszReferences = rVariant.pszVal;
        mi.pszReferences = pszReferences;
    }

    // pszSubject
    if (NULL == mi.pszSubject && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &rVariant)))
    {
        pszSubject = rVariant.pszVal;
        mi.pszSubject = pszSubject;
    }

    // pszNormalSubj
    if (fSetDisplayProps && NULL == mi.pszNormalSubj && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &rVariant)))
    {
        pszNormalSubj = rVariant.pszVal;
        mi.pszNormalSubj = pszNormalSubj;
    }

    // pszAcctId
    if (NULL == mi.pszAcctId && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &rVariant)))
    {
        pszAcctId = rVariant.pszVal;
        mi.pszAcctId = pszAcctId;
    }

    // pszAcctName
    if (NULL == mi.pszAcctName && SUCCEEDED(pPropertySet->GetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &rVariant)))
    {
        pszAcctName = rVariant.pszVal;
        mi.pszAcctName = pszAcctName;
    }

    // pszServer
    if (NULL == mi.pszServer && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &rVariant)))
    {
        pszServer = rVariant.pszVal;
        mi.pszServer = pszServer;
    }

    // ForwardTo
    if (NULL == mi.pszForwardTo && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_FORWARDTO), NOFLAGS, &rVariant)))
    {
        pszForwardTo = rVariant.pszVal;
        mi.pszForwardTo = pszForwardTo;
    }

    if (NULL == mi.pszMSOESRec && SUCCEEDED(pPropertySet->GetProp(STR_HDR_XMSOESREC, NOFLAGS, &rVariant)))
    {
        pszMSOESRec = rVariant.pszVal;
        mi.pszMSOESRec = pszMSOESRec;
    }

    IF_FAILEXIT(hr = pFolder->UpdateRecord(&mi));

    // if everything succeeded, commit the message to the store
    IF_FAILEXIT(hr = pFolder->SetMessageStream(idMessage, pStream));

    // the stream has now been used. null out the file address
    if (NULL != pfa)
        *pfa = NULL;

exit:
    MemFree(pszDisplayFrom);
    MemFree(pszEmailFrom);
    MemFree(pszDisplayTo);
    MemFree(pszEmailTo);
    MemFree(pszMessageId);
    MemFree(pszXref);
    MemFree(pszReferences);
    MemFree(pszSubject);
    MemFree(pszNormalSubj);
    MemFree(pszAcctId);
    MemFree(pszAcctName);
    MemFree(pszServer);
    MemFree(pszForwardTo);
    MemFree(pszMSOESRec);

    SafeRelease(pMimeMsg);
    SafeRelease(pPropertySet);
    if (pmiFree)
        pFolder->FreeRecord(pmiFree);
    SafeRelease(pAdrTable);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\imap\imapsync.h ===
//***************************************************************************
// IMAP4 Message Sync Header File (CIMAPSync)
// Written by Raymond Cheng, 5/5/98
//***************************************************************************


#ifndef __IMAPSync_H
#define __IMAPSync_H

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "taskutil.h"


//---------------------------------------------------------------------------
// Data Types
//---------------------------------------------------------------------------
enum IMAP_SERVERSTATE 
{
    issNotConnected,
    issNonAuthenticated,
    issAuthenticated,
    issSelected
};


enum CONN_FSM_EVENT {
    CFSM_EVENT_INITIALIZE,
    CFSM_EVENT_CMDAVAIL,
    CFSM_EVENT_CONNCOMPLETE,
    CFSM_EVENT_SELECTCOMPLETE,
    CFSM_EVENT_HDRSYNCCOMPLETE,
    CFSM_EVENT_OPERATIONSTARTED,
    CFSM_EVENT_OPERATIONCOMPLETE,
    CFSM_EVENT_ERROR,
    CFSM_EVENT_CANCEL,
    CFSM_EVENT_MAX
}; // CONN_FSM_EVENT

// Keep CONN_FSM_STATE in sync with c_pConnFSMEventHandlers
enum CONN_FSM_STATE {
    CFSM_STATE_IDLE,
    CFSM_STATE_WAITFORCONN,
    CFSM_STATE_WAITFORSELECT,
    CFSM_STATE_WAITFORHDRSYNC,
    CFSM_STATE_STARTOPERATION,
    CFSM_STATE_WAITFOROPERATIONDONE,
    CFSM_STATE_OPERATIONCOMPLETE,
    CFSM_STATE_MAX
}; // CONN_FSM_STATE

    
//---------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------
const char INVALID_HIERARCHY_CHAR = (char) 0xFF;


//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------
class CIMAPSyncCB;
class CRenameFolderInfo;


//---------------------------------------------------------------------------
// IMAPSync Util Function Prototypes
//---------------------------------------------------------------------------
HRESULT CreateImapStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);


//---------------------------------------------------------------------------
// CIMAPSync Class Declaration
//---------------------------------------------------------------------------
class CIMAPSync : 
    public IMessageServer,
    public IIMAPCallback, 
    public ITransportCallbackService,
    public IOperationCancel,
    public IIMAPStore
{
public:
    // Constructor, Destructor
    CIMAPSync();
    ~CIMAPSync();

    // IUnknown Members
    STDMETHODIMP            QueryInterface(REFIID iid, LPVOID *ppvObject);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IStoreSync Methods
    STDMETHODIMP Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP SetIdleCallback(IStoreCallback *pDefaultCallback);
    STDMETHODIMP SynchronizeFolder(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback *pCallback);
    STDMETHODIMP GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback);
    STDMETHODIMP PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream *pStream, IStoreCallback *pCallback);
    STDMETHODIMP CopyMessages(IMessageFolder *pDestFldr, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback);
    STDMETHODIMP DeleteMessages(DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback *pCallback);
    STDMETHODIMP SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP GetServerMessageFlags(MESSAGEFLAGS *pFlags);
    STDMETHODIMP SynchronizeStore(FOLDERID idParent, DWORD dwFlags,IStoreCallback *pCallback);
    STDMETHODIMP CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP MoveFolder(FOLDERID idFolder, FOLDERID idParentNew,IStoreCallback *pCallback);
    STDMETHODIMP RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback);
    STDMETHODIMP DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback);
    STDMETHODIMP SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);
    STDMETHODIMP Close(DWORD dwFlags);
    STDMETHODIMP ConnectionAddRef() { return E_NOTIMPL; };
    STDMETHODIMP ConnectionRelease() { return E_NOTIMPL; };
    STDMETHODIMP GetWatchedInfo(FOLDERID id, IStoreCallback *pCallback) { return E_NOTIMPL; }
    STDMETHODIMP GetAdBarUrl(IStoreCallback *pCallback) { return E_NOTIMPL; };
    STDMETHODIMP GetMinPollingInterval(IStoreCallback *pCallback) { return E_NOTIMPL; };

    // ITransportCallbackService
    HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);
    HRESULT STDMETHODCALLTYPE GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount);

    // ITransportCallback Members
    HRESULT STDMETHODCALLTYPE OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport);
    INT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnStatus(IXPSTATUS ixpStatus, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnError(IXPSTATUS ixpStatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    HRESULT STDMETHODCALLTYPE OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);

    // IIMAPCallback Functions
    HRESULT STDMETHODCALLTYPE OnResponse(const IMAP_RESPONSE *pirIMAPResponse);

    // IOperationCancel
    HRESULT STDMETHODCALLTYPE Cancel(CANCELTYPE tyCancel);

    // IIMAPStore
    HRESULT STDMETHODCALLTYPE ExpungeOnExit(void);


private:
    //---------------------------------------------------------------------------
    // Module Data Types
    //---------------------------------------------------------------------------
    enum IMAP_COMMAND 
    {
        icNO_COMMAND, // This indicates there are no cmds currently in progress
        icLOGIN_COMMAND,
        icCAPABILITY_COMMAND,
        icSELECT_COMMAND,
        icEXAMINE_COMMAND,
        icCREATE_COMMAND,
        icDELETE_COMMAND,
        icRENAME_COMMAND,
        icSUBSCRIBE_COMMAND,
        icUNSUBSCRIBE_COMMAND,
        icLIST_COMMAND,
        icLSUB_COMMAND,
        icAPPEND_COMMAND,
        icCLOSE_COMMAND,
        icEXPUNGE_COMMAND,
        icSEARCH_COMMAND,
        icFETCH_COMMAND,
        icSTORE_COMMAND,
        icCOPY_COMMAND,
        icLOGOUT_COMMAND,
        icNOOP_COMMAND,
        icAUTHENTICATE_COMMAND,
        icSTATUS_COMMAND,
        icALL_COMMANDS
    }; // IMAP_COMMAND


    enum READWRITE_STATUS 
    {
        rwsUNINITIALIZED,
        rwsREAD_WRITE,
        rwsREAD_ONLY
    }; // READWRITE_STATUS

    typedef struct tagIMAP_OPERATION 
    {
        WPARAM                      wParam;
        LPARAM                      lParam;
        IMAP_COMMAND                icCommandID;
        LPSTR                       pszCmdArgs;
        UINT                        uiPriority;
        IMAP_SERVERSTATE            issMinimum;
        struct tagIMAP_OPERATION   *pioNextCommand;
    } IMAP_OPERATION;

    typedef struct tagMARK_MSGS_INFO 
    {
        LPMESSAGEIDLIST     pList;
        ADJUSTFLAGS         afFlags;
        IRangeList         *pMsgRange;
        STOREOPERATIONTYPE  sotOpType;
    } MARK_MSGS_INFO;

    typedef struct tagIMAP_COPYMOVE_INFO 
    {
        COPYMESSAGEFLAGS    dwOptions;
        LPMESSAGEIDLIST     pList;
        IRangeList         *pCopyRange;
        FOLDERID            idDestFldr;
    } IMAP_COPYMOVE_INFO;

    // This structure makes me want to shower. It is used to pass info to
    // SendNextOperation, so I don't have to change its interface
    typedef struct tagAPPEND_SEND_INFO 
    {
        LPSTR           pszMsgFlags;
        FILETIME        ftReceived;
        LPSTREAM        lpstmMsg;
    } APPEND_SEND_INFO;


    enum HierCharFind_Stage 
    {
        hcfPLAN_A = 0,
        hcfPLAN_B,
        hcfPLAN_C
    };

    typedef struct tagHierarchyCharFinder 
    {
        HierCharFind_Stage  hcfStage;
        BOOL                fNonInboxNIL_Seen;
        BOOL                fDotHierarchyCharSeen;
        BYTE                bHierarchyCharBitArray[32];         // Bit-field array for 256 chars
        char                szTempFldrName[CCHMAX_STRINGRES];   // For use by Plan C (CREATE/LIST/DELETE)
    } HIERARCHY_CHAR_FINDER;

    // Used to tell FindHierarchicalFolderName what flags to set if folder is created
    typedef struct tagADD_HIER_FLDR_OPTIONS 
    {
        SPECIALFOLDER   sfType;
        FLDRFLAGS       ffFlagAdd;
        FLDRFLAGS       ffFlagRemove;
    } ADD_HIER_FLDR_OPTIONS;


    // Used to remember which folder we're dealing with during CREATE sequence
    // (CREATE, then LIST, then SUBSCRIBE). Also used when detecting existence
    // of special folders.

    enum CREATESF_STAGE 
    {
        CSF_INIT = 0,
        CSF_LIST,
        CSF_LSUBCREATE,
        CSF_CHECKSUB,
        CSF_NEXTFOLDER,
    };

    enum POSTCREATEOP
    {
        PCO_NONE = 0,
        PCO_FOLDERLIST,
        PCO_APPENDMSG,
    };

#define CFI_RECEIVEDLISTING 0x00000001 // Received LIST or LSUB response matching pszFullFolderPath
#define CFI_CREATEFAILURE   0x00000002 // CREATE failed with tagged NO so we attempted to list folder

    typedef struct tagCREATE_FOLDER_INFO 
    {
        LPSTR           pszFullFolderPath;
        FOLDERID        idFolder;               // Set after folder is created: allows us to subscribe fldr
        DWORD           dwFlags;                // Status flags like CFI_RECEIVEDLISTING
        DWORD           dwCurrentSfType;
        DWORD           dwFinalSfType;          // Used to allow us to create all special folders
        CREATESF_STAGE  csfCurrentStage;        // Used to allow us to create all special folders
        LPARAM          lParam;                 // Must carry around the lParam associated w/ fldr list
        POSTCREATEOP    pcoNextOp;              // Next operation to perform after folder creation
    } CREATE_FOLDER_INFO;


    typedef struct tagDELETE_FOLDER_INFO
    {
        LPSTR       pszFullFolderPath;
        char        cHierarchyChar;
        FOLDERID    idFolder;
    } DELETE_FOLDER_INFO;


    //---------------------------------------------------------------------------
    // Module Variables
    //---------------------------------------------------------------------------
    ULONG               m_cRef;
    IIMAPTransport2    *m_pTransport;
    INETSERVER          m_rInetServerInfo;
    FOLDERID            m_idFolder;
    FOLDERID            m_idSelectedFolder; // Currently selected fldr, DO NOT CONFUSE with m_idCurrent
    FOLDERID            m_idIMAPServer;
    LPSTR               m_pszAccountID;
    TCHAR               m_szAccountName[CCHMAX_ACCOUNT_NAME];
    LPSTR               m_pszFldrLeafName;
    IMessageStore      *m_pStore;
    IMessageFolder     *m_pFolder;
    IStoreCallback     *m_pDefCallback;

    IMAP_OPERATION     *m_pioNextOperation;

    // The following variables should be reset when we exit a folder
    DWORD               m_dwMsgCount;
    DWORD               m_dwNumNewMsgs;
    DWORD               m_dwNumHdrsDLed;
    DWORD               m_dwNumUnreadDLed;
    DWORD               m_dwNumHdrsToDL;
    DWORD               m_dwUIDValidity,
                        m_cFolders;
    DWORD               m_dwSyncFolderFlags;  // Copy of flags passed into SynchronizeFolder
    DWORD               m_dwSyncToDo;         // List of sync ops to do in current folder
    long                m_lSyncFolderRefCount; // Lets us know when to send CFSM_EVENT_HDRSYNCCOMPLETE
    DWORD_PTR           m_dwHighestCachedUID; // Highest cached UID when we processed SYNC_FOLDER_NEW_HEADERS
    READWRITE_STATUS    m_rwsReadWriteStatus;

    CONNECT_STATE       m_csNewConnState;
    IMAP_SERVERSTATE    m_issCurrent;

    TCHAR               m_cRootHierarchyChar; // For use during folder list (prefix creation) and GetFolderCounts
    HIERARCHY_CHAR_FINDER *m_phcfHierarchyCharInfo;

    char                m_szRootFolderPrefix[MAX_PATH];

    BOOL                m_fInited           :1,
                        m_fCreateSpecial    :1,
                        m_fPrefixExists     :1,
                        m_fMsgCountValid    :1,
                        m_fDisconnecting    :1,
                        m_fNewMail          :1,
                        m_fInbox            :1,
                        m_fDidFullSync      :1, // TRUE if full synchronization performed
                        m_fReconnect        :1, // TRUE to suppress operation abortion on IXP_DISCONNECTED
                        m_fTerminating      :1; // TRUE if current op is going to CFSM_STATE_OPERATIONCOMPLETE

    // Central repository to store data on the current operation
    STOREOPERATIONTYPE  m_sotCurrent;       // Current operation in progress
    IStoreCallback     *m_pCurrentCB;       // Callback for current operation in progress
    FOLDERID            m_idCurrent;        // FolderID for current operation, DO NOT CONFUSE with m_idSelectedFolder
    BOOL                m_fSubscribe;       // For SOT_SUBSCRIBE_FOLDER op, this indicates sub/unsub
    IHashTable         *m_pCurrentHash;     // List of folders cached locally
    IHashTable         *m_pListHash;        // List of folders returned via LIST response


    DWORD               m_dwThreadId;

    FILEADDRESS         m_faStream;
    LPSTREAM            m_pstmBody;
    MESSAGEID           m_idMessage;

    BOOL                m_fGotBody;

    // Connection FSM
    CONN_FSM_STATE      m_cfsState;
    CONN_FSM_STATE      m_cfsPrevState;
    HWND                m_hwndConnFSM;
    HRESULT             m_hrOperationResult;
    char                m_szOperationProblem[2*CCHMAX_STRINGRES];
    char                m_szOperationDetails[2*CCHMAX_STRINGRES];


    //---------------------------------------------------------------------------
    // Module Private Functions
    //---------------------------------------------------------------------------

    HRESULT PurgeMessageProgress(HWND hwndParent);
    HRESULT SetConnectionState(CONNECT_STATE tyConnect);

    HRESULT DownloadFoldersSequencer(const WPARAM wpTransactionID, const LPARAM lParam,
        HRESULT hrCompletionResult, const LPCSTR lpszResponseText, LPBOOL pfCompletion);
    HRESULT PostHCD(LPSTR pszErrorDescription, DWORD dwSizeOfErrorDescription,
        LPARAM lParam, LPBOOL pfCompletion);
    HRESULT CreatePrefix(LPSTR pszErrorDescription, DWORD dwSizeOfErrorDescription,
        LPARAM lParam, LPBOOL pfCompletion);
    void EndFolderList(void);

    HRESULT RenameSequencer(const WPARAM wpTransactionID, const LPARAM lParam,
        HRESULT hrCompletionResult, LPCSTR lpszResponseText, LPBOOL pfDone);
    inline BOOL EndOfRenameFolderPhaseOne(CRenameFolderInfo *pRenameInfo);
    inline BOOL EndOfRenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo);
    HRESULT RenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo,
        LPSTR szErrorDescription, DWORD dwSizeOfErrorDescription);

    void FlushOperationQueue(IMAP_SERVERSTATE issMaximum, HRESULT hrError);
    IMAP_SERVERSTATE IMAPCmdToMinISS(IMAP_COMMAND icCommandID);
    HRESULT GetNextOperation(IMAP_OPERATION **ppioOp);
    void DisposeOfWParamLParam(WPARAM wParam, LPARAM lParam, HRESULT hrResult);
    void NotifyMsgRecipients(DWORD_PTR dwUID, BOOL fCompletion,
        FETCH_BODY_PART *pFBPart, HRESULT hrCompletion, LPSTR pszDetails);
    void OnFolderExit(void);
    HRESULT _SelectFolder(FOLDERID idFolder);
    void LoadLeafFldrName(FOLDERID idFolder);

    void FillStoreError(LPSTOREERROR pErrorInfo, HRESULT hrResult,
        DWORD dwSocketError, LPSTR pszProblem, LPSTR pszDetails);
    HRESULT Fill_MESSAGEINFO(const FETCH_CMD_RESULTS_EX *pFetchResults,
        MESSAGEINFO *pMsgInfo);
    HRESULT ReadEnvelopeFields(MESSAGEINFO *pMsgInfo, const FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT ConcatIMAPAddresses(LPSTR *ppszDisplay, LPSTR *ppszEmailAddr, IMAPADDR *piaIMAPAddr);
    HRESULT ConstructIMAPEmailAddr(CByteStream &bstmOut, IMAPADDR *piaIMAPAddr);


    HRESULT CheckUIDValidity(void);
    HRESULT SyncDeletedMessages(void);

    HRESULT DeleteHashedFolders(IHashTable *pHash);
    HRESULT DeleteFolderFromCache(FOLDERID idFolder, BOOL fRecursive);
    HRESULT DeleteLeafFolder(FOLDERID *pidCurrent);
    BOOL IsValidIMAPMailbox(LPSTR pszMailboxName, char cHierarchyChar);
    HRESULT AddFolderToCache(LPSTR pszMailboxName, IMAP_MBOXFLAGS imfMboxFlags,
        char cHierarchyChar, DWORD dwAFTCFlags, FOLDERID *pFolderID,
        SPECIALFOLDER sfType);
    LPSTR RemovePrefixFromPath(LPSTR pszPrefix, LPSTR pszMailboxName,
        char cHierarchyChar, LPBOOL pfValidPrefix, SPECIALFOLDER *psfType);
    HRESULT FindHierarchicalFolderName(LPSTR lpszFolderPath, char cHierarchyChar,
        FOLDERID *phfTarget, ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo);
    HRESULT CreateFolderNode(FOLDERID idPrev, FOLDERID *pidCurrent,
        LPSTR pszCurrentFldrName, LPSTR pszNextFldrName, char cHierarchyChar,
        ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo);
    HRESULT SetTranslationMode(FOLDERID idFolderID);
    BOOL isUSASCIIOnly(LPCSTR pszFolderName);
    HRESULT CheckFolderNameValidity(LPCSTR pszName);

    HRESULT RenameFolderHelper(FOLDERID idFolder, LPSTR pszFolderPath,
        char cHierarchyChar, LPSTR pszNewFolderPath);
    HRESULT RenameTreeTraversal(WPARAM wpOperation, CRenameFolderInfo *pRenameInfo,
        BOOL fIncludeRenameFolder);
    HRESULT RenameTreeTraversalHelper(WPARAM wpOperation, CRenameFolderInfo *pRenameInfo,
        LPSTR pszCurrentFldrPath, DWORD dwLengthOfCurrentPath, BOOL fIncludeThisFolder,
        FOLDERINFO *pfiCurrentFldrInfo);
    HRESULT SubscribeSubtree(FOLDERID idFolder, BOOL fSubscribe);

    void FindRootHierarchyChar(BOOL fPlanA_Only, LPARAM lParam);
    void AnalyzeHierarchyCharInfo();
    void StopHierarchyCharSearch();
    HRESULT LoadSaveRootHierarchyChar(BOOL fSaveHC);

    HRESULT CreateNextSpecialFolder(CREATE_FOLDER_INFO *pcfiCreateInfo, LPBOOL pfCompletion);
    HRESULT _StartFolderList(LPARAM lParam);

    // notification handlers
    HRESULT _OnCmdComplete(WPARAM tid, LPARAM lParam, HRESULT hrCompletionResult, LPCSTR lpszResponseText);
    HRESULT _OnMailBoxUpdate(MBOX_MSGCOUNT *pNewMsgCount);
    HRESULT _OnMsgDeleted(DWORD dwDeletedMsgSeqNum);
    HRESULT _OnFetchBody(HRESULT hrFetchBodyResult, FETCH_BODY_PART *pFetchBodyPart);
    HRESULT _OnUpdateMsg(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT _OnApplFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags);
    HRESULT _OnPermFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags, LPSTR lpszResponseText);
    HRESULT _OnUIDValidity(WPARAM tid, DWORD dwUIDValidity, LPSTR lpszResponseText);
    HRESULT _OnReadWriteStatus(WPARAM tid, BOOL bReadWrite, LPSTR lpszResponseText);
    HRESULT _OnTryCreate(WPARAM tid, LPSTR lpszResponseText);
    HRESULT _OnSearchResponse(WPARAM tid, IRangeList *prlSearchResults);
    HRESULT _OnMailBoxList(WPARAM tid, LPARAM lParam, LPSTR pszMailboxName,
        IMAP_MBOXFLAGS imfMboxFlags, char cHierarchyChar, BOOL fNoTranslation);
    HRESULT _OnAppendProgress(LPARAM lParam, DWORD dwCurrent, DWORD dwTotal);
    HRESULT _OnStatusResponse(IMAP_STATUS_RESPONSE *pisrStatusInfo);

    // internal state helpers
    HRESULT _EnsureSelected();
    HRESULT _Connect();
    HRESULT _Disconnect();
    HRESULT _EnsureInited();

    // init helpers
    HRESULT _LoadTransport();
    HRESULT _LoadAccountInfo();

    // fetch command helpers
    HRESULT UpdateMsgHeader(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT UpdateMsgBody(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);
    HRESULT UpdateMsgFlags(WPARAM tid, HRESULT hrFetchCmdResult, FETCH_CMD_RESULTS_EX *pFetchResults);

    // command helpers
    HRESULT _ShowUserInfo(LPSTR pszTitle, LPSTR pszText1, LPSTR pszText2);
    HRESULT _SyncHeader(void);
    void ResetStatusCounts(void);
    HRESULT _SetMessageFlags(STOREOPERATIONTYPE sotOpType, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback *pCallback);


    // queuing support
    HRESULT _BeginOperation(STOREOPERATIONTYPE sotOpType, IStoreCallback *pCallback);
    HRESULT _EnqueueOperation(WPARAM wParam, LPARAM lParam, IMAP_COMMAND icCommandID, LPCSTR pszCmdArgs, UINT uiPriority);
    HRESULT _SendNextOperation(DWORD dwFlags);


public:
    // Connection FSM
    HRESULT _ConnFSM_Idle(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForConn(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForSelect(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForHdrSync(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_StartOperation(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_WaitForOpDone(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_OperationComplete(CONN_FSM_EVENT cfeEvent);

    HRESULT _ConnFSM_HandleEvent(CONN_FSM_EVENT cfeEvent);
    HRESULT _ConnFSM_ChangeState(CONN_FSM_STATE cfsNewState);
    HRESULT _ConnFSM_QueueEvent(CONN_FSM_EVENT cfeEvent);
    IMAP_SERVERSTATE _StoreOpToMinISS(STOREOPERATIONTYPE sot);
    HRESULT _LaunchOperation(void);
    HRESULT _OnOperationComplete(void);

    static LRESULT CALLBACK _ConnFSMWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
}; // CIMAPSync


// Connection FSM State Handler Functions (keep in sync with CONN_FSM_STATE)
typedef HRESULT (CIMAPSync::*CONN_FSM_EVENT_HANDLER)(CONN_FSM_EVENT cfeEvent);
const CONN_FSM_EVENT_HANDLER c_pConnFSMEventHandlers[] =
{
    &CIMAPSync::_ConnFSM_Idle,              // CFSM_STATE_IDLE,
    &CIMAPSync::_ConnFSM_WaitForConn,       // CFSM_STATE_WAITFORCONN,
    &CIMAPSync::_ConnFSM_WaitForSelect,     // CFSM_STATE_WAITFORSELECT,
    &CIMAPSync::_ConnFSM_WaitForHdrSync,    // CFSM_STATE_WAITFORHDRSYNC,
    &CIMAPSync::_ConnFSM_StartOperation,    // CFSM_STATE_STARTOPERATION,
    &CIMAPSync::_ConnFSM_WaitForOpDone,     // CFSM_STATE_WAITFOROPERATIONDONE,
    &CIMAPSync::_ConnFSM_OperationComplete, // CSFM_STATE_OPERATIONCOMPLETE
};


//---------------------------------------------------------------------------
// CRenameFolderInfo Class Declaration
//---------------------------------------------------------------------------
// This class makes me want to shower. It is used to pass info to
// SendNextOperation, so I don't have to change its interface... but even with an
// interface change, this is how the info structure would look.
class CRenameFolderInfo {
public:
    CRenameFolderInfo(void);
    ~CRenameFolderInfo(void);

    long AddRef(void);
    long Release(void);

    BOOL IsDone(void);
    HRESULT SetError(HRESULT hrResult, LPSTR pszProblemArg, LPSTR pszDetailsArg);

    LPSTR pszFullFolderPath; // Full folder path of old mailbox name
    char cHierarchyChar;
    LPSTR pszNewFolderPath;  // Full folder path of new mailbox name
    FOLDERID idRenameFolder;
    int iNumSubscribeRespExpected; // Count num of SUBSCRIBE's sent to detect end of phase one/two
    int iNumListRespExpected;      // Count num of LIST's sent to detect end of phase one
    int iNumRenameRespExpected;    // Count num of additional RENAME's sent to detect end of phase one
    int iNumUnsubscribeRespExpected; // Count num of UNSUBSCRIBE's to detect end of phase two
    int iNumFailedSubs; // Count number of failed SUBSCRIBE's to verify that we addressed them all
    int iNumFailedUnsubs; // Count number of failed UNSUBSCRIBE's, to let the user know at the end
    BOOL fNonAtomicRename; // TRUE if listing old tree returned something

    LPSTR pszRenameCmdOldFldrPath; // Old folder path for rename cmd
    BOOL fPhaseOneSent; // TRUE if all Phase One commands have been successfully sent
    BOOL fPhaseTwoSent; // TRUE if all Phase Two commands have been successfully sent

    HRESULT hrLastError;
    LPSTR   pszProblem;
    LPSTR   pszDetails;

private:
    long m_lRefCount;
}; // class CRenameFolderInfo


#endif // __IMAPSync_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\addrlist.h ===
// =================================================================================
// CAddressList Object Definition
// =================================================================================
#ifndef __ADDRESS_H
#define __ADDRESS_H

template<class TYPE, class ARG_TYPE> class CList;

// =================================================================================
// Internet address definition
// =================================================================================
class CAddress
{
private:
    ULONG       m_ulRef;

public:
    LPTSTR       m_lpszDisplay;
    LPTSTR       m_lpszAddress;
    LPTSTR       m_lpszReject;

public:
    // =================================================================================
    // Constructor / Destructor
    // =================================================================================
    CAddress ();
    ~CAddress ();

    // =================================================================================
    // Reference Counts
    // =================================================================================
    ULONG AddRef ();
    ULONG Release ();

    // =================================================================================
    // Set Props
    // =================================================================================
    void SetReject (LPTSTR lpszReject);
    void SetDisplay (LPTSTR lpszDisplay);
    void SetAddress (LPTSTR lpszAddress);
};

typedef CAddress *LPADDRESS;

// =================================================================================
// CAddressList
// =================================================================================
typedef CList<CAddress, LPADDRESS> CAddrList;
typedef CAddrList *LPADDRLIST;

// =================================================================================
// Useful functions for Address Lists
// =================================================================================
HRESULT HrAddToAddrList (LPADDRLIST lpal, LPTSTR lpszDisplay, LPTSTR lpszAddress);
HRESULT HrAddrListToDisplay (LPADDRLIST lpal, LPTSTR *lppszDisplay);
HRESULT HrCopyAddrList (LPADDRLIST lpalSrc, LPADDRLIST lpalDest);

#endif   //_IADDRESS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\imap\imapsync.cpp ===
//***************************************************************************
// IMAP4 Message Sync Class Implementation (CIMAPSync)
// Written by Raymond Cheng, 5/5/98
// Copyright (C) Microsoft Corporation, 1998
//***************************************************************************

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include "imapsync.h"
#include "xputil.h"
#include "flagconv.h"
#include "imapute.h"
#include "storutil.h"
#include "xpcomm.h"
#include "iert.h"
#include "menures.h"
#include "serverq.h"
#include "instance.h"
#include "demand.h"
#include "storecb.h"

#define USE_QUEUING_LAYER
//---------------------------------------------------------------------------
// Module Data Types
//---------------------------------------------------------------------------
typedef struct tagFOLDERIDLIST
{
    FOLDERID    idFolder;
    struct tagFOLDERIDLIST *pfilNextFolderID;
} FOLDERIDLISTNODE;

//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------
#define CCHMAX_CMDLINE          512
#define CCHMAX_IMAPFOLDERPATH   512
#define CHASH_BUCKETS           50

static const char cszIMAPFetchNewHdrsI4[] = "%lu:* (RFC822.HEADER RFC822.SIZE UID FLAGS INTERNALDATE)";
static const char cszIMAPFetchNewHdrsI4r1[] =
    "%lu:* (BODY.PEEK[HEADER.FIELDS (References X-Ref X-Priority X-MSMail-Priority X-MSOESRec Newsgroups)] "
    "ENVELOPE RFC822.SIZE UID FLAGS INTERNALDATE)";
static const char cszIMAPFetchCachedFlags[] = "1:%lu (UID FLAGS)";

enum
{
    tidDONT_CARE           = 0, // Means that transaction ID is unimportant or unavailable
    tidSELECTION,
    tidFETCH_NEW_HDRS,
    tidFETCH_CACHED_FLAGS,
    tidCOPYMSGS,                // The COPY command used to copy msgs to another IMAP fldr
    tidMOVEMSGS,                // The STORE command used to delete msg ranges - currently only used for moves
    tidBODYMSN,                 // The FETCH command used to get MsgSeqNumToUID translation before tidBODY
    tidBODY,                    // The FETCH command used to retrieve a msg body
    tidNOOP,                    // The NOOP command used to poll for new messages
    tidCLOSE,
    tidSELECT,
    tidUPLOADMSG,               // The APPEND command used to upload a message to IMAP server
    tidMARKMSGS,
    tidCREATE,                  // the CREATE cmd sent to create a folder
    tidCREATELIST,              // the LIST command sent after a CREATE
    tidCREATESUBSCRIBE,         // the SUBSCRIBE command sent after a CREATE
    tidHIERARCHYCHAR_LIST_B,    // the LIST cmd sent to find hierarchy char (Plan B)
    tidHIERARCHYCHAR_CREATE,    // the CREATE cmd sent to find hierarchy char
    tidHIERARCHYCHAR_LIST_C,    // the LIST cmd sent to find hierarchy char (Plan C)
    tidHIERARCHYCHAR_DELETE,    // the DELETE cmd sent to find hierarchy char
    tidPREFIXLIST,              // Prefixed hierarchy listing (eg, "~raych/Mail" prefix)
    tidPREFIX_HC,               // the LIST cmd sent to find hierarchy char for prefix
    tidPREFIX_CREATE,           // the CREATE cmd sent to create the prefix folder
    tidDELETEFLDR,              // the DELETE cmd sent to delete a folder
    tidDELETEFLDR_UNSUBSCRIBE,  // the UNSUBSCRIBE cmd sent to unsub a deleted fldr
    tidRENAME,                  // The RENAME cmd sent to rename a folder
    tidRENAMESUBSCRIBE,         // The subscribe cmd sent to subscribe a folder
    tidRENAMELIST,              // The LIST cmd sent to check if rename was atomic
    tidRENAMERENAME,            // The second rename attempt, if server does non-atomic rename
    tidRENAMESUBSCRIBE_AGAIN,   // The subscribe cmd sent to attempt second new-tree subscribe again
    tidRENAMEUNSUBSCRIBE,       // The unsubscribe cmd sent to unsubscribe the old folders
    tidSUBSCRIBE,               // The (un)subscribe command sent to (un)subscribe a folder
    tidSPECIALFLDRLIST,         // The LIST command sent to check if a special folder exists
    tidSPECIALFLDRLSUB,         // The LSUB command sent to list a special folder's subscribed subfolders
    tidSPECIALFLDRSUBSCRIBE,    // The SUBSCRIBE command sent out to subscribe an existing special folder
    tidFOLDERLIST,
    tidFOLDERLSUB,
    tidEXPUNGE,                 // EXPUNGE command
    tidSTATUS,                  // STATUS command used for IMessageServer::GetFolderCounts
};

enum
{
    fbpNONE,                    // Fetch Body Part identifier (lpFetchCookie1 is set to this)
    fbpHEADER,
    fbpBODY,
    fbpUNKNOWN
};

// Priorities, for use with _EnqueueOperation
enum
{
    uiTOP_PRIORITY,     // Ensures that we construct MsgSeqNum table before ALL user operations
    uiNORMAL_PRIORITY   // Priority level for all user operations
};


// Argument Readability Defines
const BOOL DONT_USE_UIDS = FALSE;               // For use with IIMAPTransport
const BOOL USE_UIDS = TRUE ;                    // For use with IIMAPTransport
const BOOL fUPDATE_OLD_MSGFLAGS = TRUE;         // For use with DownloadNewHeaders
const BOOL fDONT_UPDATE_OLD_MSGFLAGS = FALSE;   // For use with DownloadNewHeaders
const BOOL fCOMPLETED = 1;                      // For use with NotifyMsgRecipients
const BOOL fPROGRESS = 0;                       // For use with NotifyMsgRecipients
const BOOL fLOAD_HC = FALSE;                    // (LoadSaveRootHierarchyChar): Load hierarchy character from foldercache
const BOOL fSAVE_HC = TRUE;                     // (LoadSaveRootHierarchyChar): Save hierarchy character to foldercache
const BOOL fHCF_PLAN_A_ONLY = TRUE;             // Only execute Plan A in hierarchy char determination
const BOOL fHCF_ALL_PLANS = FALSE;              // Execute Plans A, B, C and Z in hierarchy char determination
const BOOL fSUBSCRIBE = TRUE;                   // For use with SubscribeToFolder
const BOOL fUNSUBSCRIBE = FALSE;                // For use with SubscribeToFolder
const BOOL fRECURSIVE = TRUE;                   // For use with DeleteFolderFromCache
const BOOL fNON_RECURSIVE = FALSE;              // For use with DeleteFolderFromCache
const BOOL fINCLUDE_RENAME_FOLDER = TRUE;       // For use with RenameTreeTraversal
const BOOL fEXCLUDE_RENAME_FOLDER = FALSE;      // For use with RenameTreeTraversal
const BOOL fREMOVE = TRUE;                      // For use with IHashTable::Find
const BOOL fNOPROGRESS = FALSE;                 // For use with CStoreCB::Initialize

#define pahfoDONT_CREATE_FOLDER NULL            // For use with FindHierarchalFolderName

const HRESULT S_CREATED = 1;                    // Indicates FindHierarchicalFolderName created the fldr

// None of the following bits can be set for a message to qualify as "unread"
const DWORD dwIMAP_UNREAD_CRITERIA = IMAP_MSG_SEEN | IMAP_MSG_DELETED;

// Internal flags for use with m_dwSyncToDo
const DWORD SYNC_FOLDER_NOOP    = 0x80000000;

const DWORD AFTC_SUBSCRIBED         = 0x00000001;   // For use with AddToFolderCache's dwATFCFlags
const DWORD AFTC_KEEPCHILDRENKNOWN  = 0x00000002;   // For use with AddToFolderCache's dwATFCFlags
const DWORD AFTC_NOTSUBSCRIBED      = 0x00000004;   // For use with AddToFolderCache's dwATFCFlags
const DWORD AFTC_NOTRANSLATION      = 0x00000008;   // For use with AddToFolderCache's dwATFCFlags

#define AssertSingleThreaded        AssertSz(m_dwThreadId == GetCurrentThreadId(), "The IMAPSync is not multithreaded. Someone is calling me on multiple threads")

const DWORD snoDO_NOT_DISPOSE       = 0x00000001;   // For use with _SendNextOperation


// Connection FSM
const UINT WM_CFSM_EVENT = WM_USER;


//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------

//***************************************************************************
//***************************************************************************
HRESULT CreateImapStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    CIMAPSync  *pIMAPSync;
    HRESULT     hr;

    TraceCall("CIMAPSync::CreateImapStore");
    IxpAssert(NULL != ppUnknown);

    // Initialize return values
    *ppUnknown = NULL;
    hr = E_NOINTERFACE;

    if (NULL != pUnkOuter)
    {
        hr = TraceResult(CLASS_E_NOAGGREGATION);
        goto exit;
    }

    pIMAPSync = new CIMAPSync;
    if (NULL == pIMAPSync)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

#ifdef USE_QUEUING_LAYER
    hr = CreateServerQueue(pIMAPSync, (IMessageServer **)ppUnknown);
    pIMAPSync->Release(); // Since we're not returning this ptr, bump down refcount
#else
    // If we reached this point, everything is working great
    *ppUnknown = SAFECAST(pIMAPSync, IMessageServer *);
    hr = S_OK;
#endif

exit:
    // Done
    return hr;
}



//***************************************************************************
// Function: CIMAPSync (constructor)
//***************************************************************************
CIMAPSync::CIMAPSync(void)
{
    TraceCall("CIMAPSync::CIMAPSync");

    m_cRef = 1;
    m_pTransport = NULL;
    ZeroMemory(&m_rInetServerInfo, sizeof(m_rInetServerInfo));
    m_idFolder = FOLDERID_INVALID;
    m_idSelectedFolder = FOLDERID_INVALID;
    m_idIMAPServer = FOLDERID_INVALID;
    m_pszAccountID = NULL;
    m_szAccountName[0] = '\0';
    m_pszFldrLeafName = NULL;
    m_pStore = NULL;
    m_pFolder = NULL;
    m_pDefCallback = NULL;

    m_pioNextOperation = NULL;

    m_dwMsgCount = 0;
    m_fMsgCountValid = FALSE;
    m_dwNumNewMsgs = 0;
    m_dwNumHdrsDLed = 0;
    m_dwNumUnreadDLed = 0;
    m_dwNumHdrsToDL = 0;
    m_dwUIDValidity = 0;
    m_dwSyncFolderFlags = 0;
    m_dwSyncToDo = 0;
    m_lSyncFolderRefCount = 0;
    m_dwHighestCachedUID = 0;
    m_rwsReadWriteStatus = rwsUNINITIALIZED;
    m_fCreateSpecial = TRUE;
    m_fNewMail = FALSE;
    m_fInbox = FALSE;
    m_fDidFullSync = FALSE;

    m_csNewConnState = CONNECT_STATE_DISCONNECT;
    m_cRootHierarchyChar = INVALID_HIERARCHY_CHAR;
    m_phcfHierarchyCharInfo = NULL;
    m_fReconnect = FALSE;

    m_issCurrent = issNotConnected;

    m_szRootFolderPrefix[0] = '\0';
    m_fPrefixExists = FALSE;

    // Central repository
    m_pCurrentCB = NULL;
    m_sotCurrent = SOT_INVALID;
    m_idCurrent = FOLDERID_INVALID;
    m_fSubscribe = FALSE;
    m_pCurrentHash = NULL;
    m_pListHash = NULL;
    m_fTerminating = FALSE;

    m_fInited = 0;
    m_fDisconnecting = 0;
    m_cFolders = 0;

    m_faStream = 0;
    m_pstmBody = NULL;
    m_idMessage = 0;

    m_fGotBody = FALSE;

    m_cfsState = CFSM_STATE_IDLE;
    m_cfsPrevState = CFSM_STATE_IDLE;
    m_hwndConnFSM = NULL;
    m_hrOperationResult = OLE_E_BLANK; // Uninitialized state
    m_szOperationProblem[0] = '\0';
    m_szOperationDetails[0] = '\0';

    m_dwThreadId = GetCurrentThreadId();
}



//***************************************************************************
// Function: ~CIMAPSync (destructor)
//***************************************************************************
CIMAPSync::~CIMAPSync(void)
{
    TraceCall("CIMAPSync::~CIMAPSync");
    IxpAssert(0 == m_cRef);

    if (NULL != m_phcfHierarchyCharInfo)
        delete m_phcfHierarchyCharInfo;

    ZeroMemory(&m_rInetServerInfo, sizeof(m_rInetServerInfo));        // Done for security

    IxpAssert (!IsWindow(m_hwndConnFSM));
    SafeMemFree(m_pszAccountID);
    SafeMemFree(m_pszFldrLeafName);
    SafeRelease(m_pStore);
    SafeRelease(m_pFolder);
}

HRESULT CIMAPSync::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr;

    TraceCall("CIMAPSync::QueryInterface");
    AssertSingleThreaded;

    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != ppvObject);

    // Init variables, arguments
    hr = E_NOINTERFACE;
    if (NULL == ppvObject)
        goto exit;

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid)
        *ppvObject = (IMessageServer *) this;
    else if (IID_IMessageServer == iid)
        *ppvObject = (IMessageServer *) this;
    else if (IID_ITransportCallback == iid)
        *ppvObject = (ITransportCallback *) this;
    else if (IID_ITransportCallbackService == iid)
        *ppvObject = (ITransportCallbackService *) this;
    else if (IID_IIMAPCallback == iid)
        *ppvObject = (IIMAPCallback *) this;
    else if (IID_IIMAPStore == iid)
        *ppvObject = (IIMAPStore *) this;

    // If we returned an interface, return success
    if (NULL != *ppvObject)
    {
        hr = S_OK;
        ((IUnknown *) *ppvObject)->AddRef();
    }

exit:
    return hr;
}



ULONG CIMAPSync::AddRef(void)
{
    TraceCall("CIMAPSync::AddRef");
    AssertSingleThreaded;

    IxpAssert(m_cRef > 0);

    m_cRef += 1;

    DOUT ("CIMAPSync::AddRef, returned Ref Count=%ld", m_cRef);
    return m_cRef;
}


ULONG CIMAPSync::Release(void)
{
    TraceCall("CIMAPSync::Release");
    AssertSingleThreaded;

    IxpAssert(m_cRef > 0);

    m_cRef -= 1;
    DOUT("CIMAPSync::Release, returned Ref Count = %ld", m_cRef);

    if (0 == m_cRef)
    {
        delete this;
        return 0;
    }
    else
        return m_cRef;
}


//===========================================================================
// IMessageSync Methods
//===========================================================================
//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder)
{
    HRESULT     hr;
    BOOL        fResult;
    WNDCLASSEX  wc;

    TraceCall("CIMAPSync::Initialize");
    AssertSingleThreaded;

    if (pStore == NULL || idStoreRoot == FOLDERID_INVALID)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // check to make sure we're not inited twice.
    if (m_fInited)
    {
        hr = TraceResult(CO_E_ALREADYINITIALIZED);
        goto exit;
    }

    // Save current folder data
    m_idIMAPServer = idStoreRoot;
    m_idFolder = idFolder;
    ReplaceInterface(m_pStore, pStore);
    ReplaceInterface(m_pFolder, pFolder);
    LoadLeafFldrName(idFolder);

    hr = _LoadAccountInfo();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = _LoadTransport();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Create a window to queue Connection FSM messages
    wc.cbSize = sizeof(WNDCLASSEX);
    fResult = GetClassInfoEx(g_hInst, c_szIMAPSyncCFSMWndClass, &wc);
    if (FALSE == fResult)
    {
        ATOM aResult;

        // Register this window class
        wc.style            = 0;
        wc.lpfnWndProc      = CIMAPSync::_ConnFSMWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hInst;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szIMAPSyncCFSMWndClass;
        wc.hIconSm          = NULL;

        aResult = RegisterClassEx(&wc);
        if (0 == aResult && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }
    }

    m_hwndConnFSM = CreateWindowEx(WS_EX_TOPMOST, c_szIMAPSyncCFSMWndClass,
        c_szIMAPSyncCFSMWndClass, WS_POPUP, 1, 1, 1, 1, NULL, NULL, g_hInst,
        (LPVOID)this);
    if (NULL == m_hwndConnFSM)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // flag successful initialization
    m_fInited = TRUE;

exit:
    return hr;
}



HRESULT CIMAPSync::ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder)
{
    TraceCall("CIMAPSync::ResetFolder");
    Assert(m_cRef > 0);

    m_idFolder = idFolder;
    ReplaceInterface(m_pFolder, pFolder);
    LoadLeafFldrName(idFolder);

    return S_OK;
}



void CIMAPSync::LoadLeafFldrName(FOLDERID idFolder)
{
    FOLDERINFO  fiFolderInfo;

    SafeMemFree(m_pszFldrLeafName);
    if (FOLDERID_INVALID != idFolder)
    {
        HRESULT hr;

        hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
        if (SUCCEEDED(hr))
        {
            m_pszFldrLeafName = PszDupA(fiFolderInfo.pszName);
            if (NULL == m_pszFldrLeafName)
            {
                TraceResult(E_OUTOFMEMORY);
                m_pszFldrLeafName = PszDupA(""); // If this fails, tough luck
            }

            m_pStore->FreeRecord(&fiFolderInfo);
        }
    }
}


HRESULT CIMAPSync::Close(DWORD dwFlags)
{
    HRESULT             hrTemp;

    BOOL                fCancelOperation = FALSE;
    STOREERROR          seErrorInfo;
    IStoreCallback     *pCallback = NULL;
    STOREOPERATIONTYPE  sotCurrent;

    TraceCall("CIMAPSync::Close");

    AssertSingleThreaded;

    // validate flags
    if (0 == (dwFlags & (MSGSVRF_HANDS_OFF_SERVER | MSGSVRF_DROP_CONNECTION)))
        return TraceResult(E_UNEXPECTED);

    // Check if we are to cancel the current operation
    if (SOT_INVALID != m_sotCurrent &&
        (dwFlags & (MSGSVRF_DROP_CONNECTION | MSGSVRF_HANDS_OFF_SERVER)))
    {
        fCancelOperation = TRUE;
        if (NULL != m_pCurrentCB)
        {
            IxpAssert(SOT_INVALID != m_sotCurrent);
            FillStoreError(&seErrorInfo, STORE_E_OPERATION_CANCELED, 0,
                MAKEINTRESOURCE(IDS_IXP_E_USER_CANCEL), NULL);

            // Remember how to call callback
            pCallback = m_pCurrentCB;
            sotCurrent = m_sotCurrent;
        }

        // Reset current operation vars
        m_hrOperationResult = OLE_E_BLANK;
        m_sotCurrent = SOT_INVALID;
        m_pCurrentCB = NULL;
        m_cfsState = CFSM_STATE_IDLE;
        m_cfsPrevState = CFSM_STATE_IDLE;
        m_fTerminating = FALSE;

        // Clear the Connection FSM event queue
        if (IsWindow(m_hwndConnFSM))
        {
            MSG msg;

            while (PeekMessage(&msg, m_hwndConnFSM, WM_CFSM_EVENT, WM_CFSM_EVENT, PM_REMOVE))
            {
                TraceInfoTag(TAG_IMAPSYNC,
                    _MSG("CIMAPSync::Close removing WM_CFSM_EVENT, cfeEvent = %lX",
                    msg.wParam));
            }
        }
    }

    // If connection still exists, perform purge-on-exit and disconnect us as required
    // Connection might not exist, however (eg, if modem connection terminated)
    if (dwFlags & MSGSVRF_DROP_CONNECTION || dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (m_pTransport)
        {
            m_fDisconnecting = TRUE;
            m_pTransport->DropConnection();
        }
    }

    SafeRelease(m_pCurrentHash);
    SafeRelease(m_pListHash);
    SafeRelease(m_pstmBody);

    if (dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        SafeRelease(m_pDefCallback);
        FlushOperationQueue(issNotConnected, STORE_E_OPERATION_CANCELED);

        if (IsWindow(m_hwndConnFSM))
        {
            if (m_dwThreadId == GetCurrentThreadId())
                SideAssert(DestroyWindow(m_hwndConnFSM));
            else
                SideAssert(PostMessage(m_hwndConnFSM, WM_CLOSE, 0, 0));
        }

        // Let go of our transport object
        if (m_pTransport)
        {
            m_pTransport->HandsOffCallback();
            m_pTransport->Release();
            m_pTransport = NULL;
        }

        m_fInited = 0;
    }

    // Notify caller that we're complete
    if (fCancelOperation && NULL != pCallback)
    {
        HRESULT hrTemp;

        hrTemp = pCallback->OnComplete(sotCurrent, seErrorInfo.hrResult, NULL, &seErrorInfo);
        TraceError(hrTemp);
        pCallback->Release();
    }
    // *** WARNING: After this point, OnComplete may have been called which may cause
    // us to have been re-entered. Make no reference to module vars!

    return S_OK;
}



HRESULT CIMAPSync::PurgeMessageProgress(HWND hwndParent)
{
    CStoreCB   *pCB = NULL;
    HRESULT     hrResult = S_OK;

    TraceCall("CIMAPSync::PurgeMessageProgress");

    // Check if we're connected and selected
    if (NULL == m_pTransport || issSelected != m_issCurrent ||
        FOLDERID_INVALID == m_idSelectedFolder || m_idSelectedFolder != m_idFolder ||
        CFSM_STATE_IDLE != m_cfsState)
    {
        // Not in proper state to issue CLOSE
        goto exit;
    }

    pCB = new CStoreCB;
    if (NULL == pCB)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    hrResult = pCB->Initialize(hwndParent, MAKEINTRESOURCE(idsPurgingMessages), fNOPROGRESS);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Issue the CLOSE command
    hrResult = _EnqueueOperation(tidCLOSE, 0, icCLOSE_COMMAND, NULL, uiNORMAL_PRIORITY);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = _BeginOperation(SOT_PURGING_MESSAGES, pCB);
    if (FAILED(hrResult) && E_PENDING != hrResult)
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Wait until CLOSE is complete
    hrResult = pCB->Block();
    TraceError(hrResult);

    // Shut down
    hrResult = pCB->Close();
    TraceError(hrResult);

exit:
    SafeRelease(pCB);
    return hrResult;
}




HRESULT CIMAPSync::_ConnFSM_HandleEvent(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    TraceCall("CIMAPSync::_HandleConnFSMEvent");

    if (cfeEvent >= CFSM_EVENT_MAX)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    if (m_cfsState >= CFSM_STATE_MAX)
    {
        hrResult = TraceResult(E_FAIL);
        goto exit;
    }

    IxpAssert(NULL != c_pConnFSMEventHandlers[m_cfsState]);
    hrResult = (this->*c_pConnFSMEventHandlers[m_cfsState])(cfeEvent);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
} // _ConnFSM_HandleEvent



HRESULT CIMAPSync::_ConnFSM_Idle(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_IDLE == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_Idle");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Don't need to do anything for this state
            break;

        case CFSM_EVENT_CMDAVAIL:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFORCONN);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            // We don't care about no stinking errors (not in this state)
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_Idle, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    return hrResult;
} // _ConnFSM_Idle



HRESULT CIMAPSync::_ConnFSM_WaitForConn(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFORCONN == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForConn");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // We need to connect and authenticate. Do this even if we're already
            // connected (we will check if user changed connection settings)
            hrResult = SetConnectionState(CONNECT_STATE_CONNECT);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_CONNCOMPLETE:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFORSELECT);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForConn, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch


exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_WaitForConn



HRESULT CIMAPSync::_ConnFSM_WaitForSelect(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;
    BOOL    fGoToNextState = FALSE;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFORSELECT == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForSelect");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Do we need to SELECT the current folder for this operation?
            if (_StoreOpToMinISS(m_sotCurrent) < issSelected)
            {
                // This operation does not require folder selection: ready to start operation
                hrResult = _ConnFSM_ChangeState(CFSM_STATE_STARTOPERATION);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            else
            {
                // Issue the SELECT command for the current folder
                hrResult = _EnsureSelected();
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
                else if (STORE_S_NOOP == hrResult)
                    fGoToNextState= TRUE;
            }

            if (FALSE == fGoToNextState)
                break;

            // *** If fGoToNextState, FALL THROUGH ***

        case CFSM_EVENT_SELECTCOMPLETE:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFORHDRSYNC);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForSelect, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_WaitForSelect



HRESULT CIMAPSync::_ConnFSM_WaitForHdrSync(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult=S_OK;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFORHDRSYNC == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForHdrSync");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Check if we're supposed to synchronize this folder
            if (0 != m_dwSyncToDo)
            {
                // Yup, send the synchronization commands
                Assert(0 == m_lSyncFolderRefCount);
                m_lSyncFolderRefCount = 0;
                hrResult = _SyncHeader();
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            else
                // No synchronization requested
                hrResult = STORE_S_NOOP;

            // If no synchronization requested, fall through and proceed to next state
            if (STORE_S_NOOP != hrResult)
                break; // Our work here is done

            // *** FALL THROUGH ***

        case CFSM_EVENT_HDRSYNCCOMPLETE:
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_STARTOPERATION);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForHdrSync, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_WaitForHdrSync



HRESULT CIMAPSync::_ConnFSM_StartOperation(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;
    BOOL    fMoreCmdsToSend;
    BOOL    fAbort = FALSE;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_STARTOPERATION == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_StartOperation");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Launch operation
            hrResult = _LaunchOperation();
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            else if (STORE_S_NOOP == hrResult)
            {
                // This means success, but no operation launched. Proceed directly to "DONE"
                hrResult = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            else
            {
                // Proceed to the next state to wait for command completion
                hrResult = _ConnFSM_ChangeState(CFSM_STATE_WAITFOROPERATIONDONE);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }
            break;

        case CFSM_EVENT_ERROR:
            fAbort = TRUE;
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_StartOperation, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    if (FAILED(hrResult) || fAbort)
    {
        HRESULT hrTemp;

        // Looks like we're going to have to dump this operation
        hrTemp = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
        TraceError(hrTemp);
    }

    return hrResult;
} // _ConnFSM_StartOperation



HRESULT CIMAPSync::_ConnFSM_WaitForOpDone(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_WAITFOROPERATIONDONE == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_WaitForOpDone");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // No need to do anything for initialization
            break;

        case CFSM_EVENT_OPERATIONCOMPLETE:
        case CFSM_EVENT_ERROR:
            // Proceed to next state
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_OPERATIONCOMPLETE);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_WaitForOpDone, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    return hrResult;
} // _ConnFSM_WaitForOpDone



HRESULT CIMAPSync::_ConnFSM_OperationComplete(CONN_FSM_EVENT cfeEvent)
{
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_OPERATIONCOMPLETE == m_cfsState);
    TraceCall("CIMAPSync::_ConnFSM_OperationComplete");

    switch (cfeEvent)
    {
        case CFSM_EVENT_INITIALIZE:
            // Clean up and send OnComplete callback to caller
            hrResult = _OnOperationComplete();

            // Proceed back to the IDLE state
            hrResult = _ConnFSM_ChangeState(CFSM_STATE_IDLE);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            break;

        case CFSM_EVENT_ERROR:
            // Ignore errors, we're on the way back to IDLE
            break;

        default:
            TraceInfoTag(TAG_IMAPSYNC, _MSG("CIMAPSync::_ConnFSM_OperationComplete, got cfeEvent = %lu", cfeEvent));
            hrResult = TraceResult(E_INVALIDARG);
            break;
    } // switch

exit:
    return hrResult;
} // _ConnFSM_OperationComplete



HRESULT CIMAPSync::_ConnFSM_ChangeState(CONN_FSM_STATE cfsNewState)
{
    HRESULT hrResult;

    IxpAssert(m_cRef > 0);
    IxpAssert(cfsNewState < CFSM_STATE_MAX);
    TraceCall("CIMAPSync::_ConnFSM_ChangeState");

    if (CFSM_STATE_OPERATIONCOMPLETE == cfsNewState)
        m_fTerminating = TRUE;

    m_cfsPrevState = m_cfsState;
    m_cfsState = cfsNewState;
    hrResult = _ConnFSM_QueueEvent(CFSM_EVENT_INITIALIZE);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
} // _ConnFSM_ChangeState



HRESULT CIMAPSync::_ConnFSM_QueueEvent(CONN_FSM_EVENT cfeEvent)
{
    BOOL    fResult;
    HRESULT hrResult = S_OK;

    IxpAssert(m_cRef > 0);
    IxpAssert(cfeEvent < CFSM_EVENT_MAX);
    TraceCall("CIMAPSync::_ConnFSM_QueueEvent");

    fResult = PostMessage(m_hwndConnFSM, WM_CFSM_EVENT, cfeEvent, 0);
    if (0 == fResult)
    {
        hrResult = TraceResult(E_FAIL);
        goto exit;
    }

exit:
    return hrResult;
} // _ConnFSM_QueueEvent



HRESULT CIMAPSync::_LaunchOperation(void)
{
    HRESULT hrResult = E_FAIL;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_STARTOPERATION == m_cfsState);
    TraceCall("CIMAPSync::_LaunchOperation");

    switch (m_sotCurrent)
    {
        case SOT_SYNC_FOLDER:
            IxpAssert(OLE_E_BLANK == m_hrOperationResult);
            hrResult = STORE_S_NOOP; // Nothing to do! We're already done!
            m_hrOperationResult = S_OK; // If we got this far we must be successful
            goto exit;

        default:
            // Do nothing for now
            break;
    } // switch

    // Launch Operation (for now, this just means to pump send queue)
    do
    {
        hrResult = _SendNextOperation(NOFLAGS);
        TraceError(hrResult);
    } while (S_OK == hrResult);

exit:
    return hrResult;
} // _LaunchOperation


HRESULT CIMAPSync::_OnOperationComplete(void)
{
    STOREERROR          seErrorInfo;
    STOREERROR         *pErrorInfo = NULL;
    HRESULT             hrTemp;
    HRESULT             hrOperationResult;
    IStoreCallback     *pCallback;
    STOREOPERATIONTYPE  sotCurrent;

    IxpAssert(m_cRef > 0);
    IxpAssert(CFSM_STATE_OPERATIONCOMPLETE == m_cfsState);

    // In some cases, CIMAPSync::Close does the OnComplete call for us
    if (SOT_INVALID == m_sotCurrent)
    {
        IxpAssert(NULL == m_pCurrentCB);
        IxpAssert(OLE_E_BLANK == m_hrOperationResult);
        return S_OK;
    }

    IxpAssert(OLE_E_BLANK != m_hrOperationResult);
    TraceCall("CIMAPSync::_OnOperationComplete");

    if (NULL != m_pCurrentCB && FAILED(m_hrOperationResult))
    {
        FillStoreError(&seErrorInfo, m_hrOperationResult, 0, NULL, NULL);
        pErrorInfo = &seErrorInfo;
    }

    // Ancient relic of the past: will be deleted when queue is removed
    FlushOperationQueue(issNotConnected, E_FAIL);

    // Remember a couple of things
    pCallback = m_pCurrentCB;
    sotCurrent = m_sotCurrent;
    hrOperationResult = m_hrOperationResult;

    // Reset all operation variables in case of re-entry during OnComplete call
    m_pCurrentCB = NULL;
    m_sotCurrent = SOT_INVALID;
    m_hrOperationResult = OLE_E_BLANK;
    m_fTerminating = FALSE;

    m_idCurrent = FOLDERID_INVALID;
    m_fSubscribe = FALSE;
    SafeRelease(m_pCurrentHash);
    SafeRelease(m_pListHash);

    // Now we're ready to call OnComplete
    if (NULL != pCallback)
    {
        // This should be the ONLY call to IStoreCallback::OnComplete in this class!
        hrTemp = pCallback->OnComplete(sotCurrent, hrOperationResult, NULL, pErrorInfo);
        TraceError(hrTemp);

        // *** WARNING: At this point, we may be re-entered if OnComplete call puts up
        // window. Make no references to module vars!
        pCallback->Release();
    }

    return S_OK;
} // _OnOperationComplete



IMAP_SERVERSTATE CIMAPSync::_StoreOpToMinISS(STOREOPERATIONTYPE sot)
{
    IMAP_SERVERSTATE    issResult = issSelected;

    switch (sot)
    {
        case SOT_INVALID:
            IxpAssert(FALSE);
            break;

        case SOT_CONNECTION_STATUS:
        case SOT_PUT_MESSAGE:
        case SOT_SYNCING_STORE:
        case SOT_CREATE_FOLDER:
        case SOT_MOVE_FOLDER:
        case SOT_DELETE_FOLDER:
        case SOT_RENAME_FOLDER:
        case SOT_SUBSCRIBE_FOLDER:
        case SOT_UPDATE_FOLDER:
        case SOT_SYNCING_DESCRIPTIONS:
            issResult = issAuthenticated;
            break;

        case SOT_SYNC_FOLDER:
        case SOT_GET_MESSAGE:
        case SOT_COPYMOVE_MESSAGE:
        case SOT_SEARCHING:
        case SOT_DELETING_MESSAGES:
        case SOT_SET_MESSAGEFLAGS:
        case SOT_PURGING_MESSAGES:
            issResult = issSelected;
            break;

        default:
            IxpAssert(FALSE);
            break;
    } // switch

    return issResult;
} // _StoreOpToMinISS



LRESULT CALLBACK CIMAPSync::_ConnFSMWndProc(HWND hwnd, UINT uMsg,
                                                   WPARAM wParam, LPARAM lParam)
{
    LRESULT     lResult = 0;
    CIMAPSync  *pThis;
    HRESULT     hrTemp;

    pThis = (CIMAPSync *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
        case WM_CREATE:
            IxpAssert(NULL == pThis);
            pThis = (CIMAPSync *)((CREATESTRUCT *)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
            lResult = 0;
            break;

        case WM_DESTROY:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            break;

        case WM_CFSM_EVENT:
            IxpAssert(wParam < CFSM_EVENT_MAX);
            IxpAssert(0 == lParam);
            IxpAssert(IsWindow(hwnd));

            hrTemp = pThis->_ConnFSM_HandleEvent((CONN_FSM_EVENT)wParam);
            if (FAILED(hrTemp))
            {
                TraceResult(hrTemp);
                pThis->m_hrOperationResult = hrTemp;
            }
            break;

        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return lResult;
}




HRESULT CIMAPSync::_EnsureInited()
{
    if (!m_fInited)
        return CO_E_NOTINITIALIZED;

    if (!m_pTransport)
        return E_UNEXPECTED;

    if (m_sotCurrent != SOT_INVALID)
    {
        AssertSz(m_sotCurrent != SOT_INVALID, "IMAPSync was called into during a command-execution. Bug in server queue?");
        return E_UNEXPECTED;
    }

    return S_OK;
}

/*
 *  Function : EnsureSelected()
 *
 *  Purpose:    make sure we are in the selected folder state
 *              if we are selected, then we're done.
 *
 *
 */
HRESULT CIMAPSync::_EnsureSelected(void)
{
    HRESULT hr;
    LPSTR   pszDestFldrPath = NULL;

    TraceCall("CIMAPSync::_EnsureSelected");
    AssertSingleThreaded;

    IxpAssert(m_pStore);
    IxpAssert(m_idIMAPServer != FOLDERID_INVALID);

    // If current folder is already selected, no need to issue SELECT
    if (FOLDERID_INVALID != m_idSelectedFolder &&
        m_idSelectedFolder == m_idFolder)
    {
        hr = STORE_S_NOOP; // Success, but no SELECT command issued
        goto exit;
    }

    if (m_idFolder == FOLDERID_INVALID)
    {
        // noone has called SetFolder on us yet, let's bail
        // with a badfolder error
        hr = TraceResult(STORE_E_BADFOLDERNAME);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, m_idFolder, &pszDestFldrPath,
        NULL, NULL, m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // We're about to issue a SELECT command, so clear operation queue
    // (it's filled with commands for previous folder)
    OnFolderExit();

    // Find out what translation mode we should be in
    hr = SetTranslationMode(m_idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pTransport->Select(tidSELECTION, (LPARAM) m_idFolder, this, pszDestFldrPath);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszDestFldrPath);
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SetIdleCallback(IStoreCallback *pDefaultCallback)
{
    TraceCall("CIMAPSync::SetOwner");
    AssertSingleThreaded;

    ReplaceInterface(m_pDefCallback, pDefaultCallback);
    return S_OK;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SetConnectionState(CONNECT_STATE csNewState)
{
    HRESULT hr;

    TraceCall("CIMAPSync::SetConnectionState");
    AssertSingleThreaded;

    m_csNewConnState = csNewState;
    if (CONNECT_STATE_CONNECT == csNewState)
    {
        hr = _Connect();
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        m_fCreateSpecial = TRUE;
    }
    else if (CONNECT_STATE_DISCONNECT == csNewState)
    {
        hr = _Disconnect();
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        AssertSz(FALSE, "What do you want?");
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: SynchronizeFolder
//
// Purpose:
//   This function is used to tell CIMAPSync what parts of the message
// list to synchronize with the IMAP server, and any special sync options.
// The call is treated as a STANDING ORDER, meaning that if this function
// is called to get new headers, CIMAPSync assumes that the caller is always
// interested in new headers. Therefore, the next time the IMAP server informs
// us of new headers, we download them.
//***************************************************************************
HRESULT CIMAPSync::SynchronizeFolder(DWORD dwFlags, DWORD cHeaders, IStoreCallback *pCallback)
{
    HRESULT     hr;

    TraceCall("CIMAPSync::SynchronizeFolder");
    AssertSingleThreaded;

    AssertSz(ISFLAGCLEAR(dwFlags, SYNC_FOLDER_CACHED_HEADERS) ||
        ISFLAGSET(dwFlags, SYNC_FOLDER_NEW_HEADERS),
        "Cannot currently sync cached headers without getting new headers as well");
    IxpAssert(0 == (dwFlags & ~(SYNC_FOLDER_ALLFLAGS)));

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Special-case SYNC_FOLDER_PURGE_DELETED. It doesn't really belong here
    // but it allows us to avoid adding a new function to IMessageServer.
    // Do not allow its presence to affect our standing orders
    if (SYNC_FOLDER_PURGE_DELETED & dwFlags)
    {
        // Need to set m_dwSyncFolderFlags with this flag because m_dwSyncToDo gets erased
        Assert(0 == (dwFlags & ~(SYNC_FOLDER_PURGE_DELETED)));
        dwFlags = m_dwSyncFolderFlags | SYNC_FOLDER_PURGE_DELETED;
    }

    m_dwSyncFolderFlags = dwFlags;
    m_dwSyncToDo = dwFlags | SYNC_FOLDER_NOOP;
    m_dwHighestCachedUID = 0;

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_SYNC_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback)
{
    HRESULT hr;
    BOOL    fNeedMsgSeqNum = FALSE;

    TraceCall("CIMAPSync::GetMessage");
    AssertSingleThreaded;

    IxpAssert(MESSAGEID_INVALID != idMessage);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    SafeRelease(m_pstmBody);
    hr = CreatePersistentWriteStream(m_pFolder, &m_pstmBody, &m_faStream);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    m_idMessage = idMessage;
    m_fGotBody = FALSE;

    // To FETCH a message we need to translate MsgSeqNum to UID, so check if we can do it
    if (FALSE == ISFLAGSET(m_dwSyncFolderFlags, (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)))
    {
        DWORD   dwMsgSeqNum;
        HRESULT hrTemp;

        // Both SYNC_FOLDER_NEW_HEADERS and SYNC_FOLDER_CACHED_HEADERS have to be
        // set to guarantee general MsgSeqNumToUID translation. Looks like we may
        // have to get the translation ourselves, but check if we already have it
        hrTemp = ImapUtil_UIDToMsgSeqNum(m_pTransport, (DWORD_PTR)idMessage, &dwMsgSeqNum);
        if (FAILED(hrTemp))
            fNeedMsgSeqNum = TRUE;
    }

    if (fNeedMsgSeqNum)
    {
        char    szFetchArgs[50];

        wnsprintfA(szFetchArgs, ARRAYSIZE(szFetchArgs), "%lu (UID)", idMessage);
        hr = _EnqueueOperation(tidBODYMSN, (LPARAM) idMessage, icFETCH_COMMAND,
            szFetchArgs, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        hr = _EnqueueOperation(tidBODY, (LPARAM) idMessage, icFETCH_COMMAND,
            NULL, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }


exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_GET_MESSAGE, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::PutMessage(FOLDERID idFolder,
                              MESSAGEFLAGS dwFlags,
                              LPFILETIME pftReceived,
                              IStream *pStream,
                              IStoreCallback *pCallback)
{
    HRESULT         hr;
    IMAP_MSGFLAGS   imfIMAPMsgFlags;
    LPSTR           pszDestFldrPath = NULL;
    APPEND_SEND_INFO *pAppendInfo = NULL;
    FOLDERINFO      fiFolderInfo;
    BOOL            fSuppressRelease = FALSE;

    TraceCall("CIMAPSync::PutMessage");
    AssertSingleThreaded;

    IxpAssert(FOLDERID_INVALID != m_idIMAPServer);
    IxpAssert(NULL != pStream);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr= SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Create a APPEND_SEND_INFO structure
    pAppendInfo = new APPEND_SEND_INFO;
    if (NULL == pAppendInfo)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }
    ZeroMemory(pAppendInfo, sizeof(APPEND_SEND_INFO));

    // Fill in the fields
    ImapUtil_LoadRootFldrPrefix(m_pszAccountID, m_szRootFolderPrefix, ARRAYSIZE(m_szRootFolderPrefix));
    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszDestFldrPath, NULL,
        NULL, m_pStore, NULL, m_szRootFolderPrefix);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Convert flags to a string
    imfIMAPMsgFlags = DwConvertARFtoIMAP(dwFlags);
    hr = ImapUtil_MsgFlagsToString(imfIMAPMsgFlags, &pAppendInfo->pszMsgFlags, NULL);
    if (FAILED(hr))
    {
        // The show must go on! Default to no IMAP msg flags
        TraceResult(hr);
        pAppendInfo->pszMsgFlags = NULL;
        hr = S_OK; // Suppress error
    }

    // Get a date/time for INTERNALDATE attribute of this msg
    if (NULL == pftReceived)
    {
        SYSTEMTIME  stCurrentTime;

        // Substitute current date/time
        GetSystemTime(&stCurrentTime);
        SystemTimeToFileTime(&stCurrentTime, &pAppendInfo->ftReceived);
    }
    else
        pAppendInfo->ftReceived = *pftReceived;

    pAppendInfo->lpstmMsg = pStream;
    pStream->AddRef();

    // Check for the case where destination is a special folder whose creation was deferred
    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {
        if (FOLDER_CREATEONDEMAND & fiFolderInfo.dwFlags)
        {
            CREATE_FOLDER_INFO *pcfi;

            Assert(FOLDER_NOTSPECIAL != fiFolderInfo.tySpecial);

            pcfi = new CREATE_FOLDER_INFO;
            if (NULL == pcfi)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            // Fill in all the fields
            pcfi->pszFullFolderPath = PszDupA(pszDestFldrPath);
            if (NULL == pcfi->pszFullFolderPath)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            pcfi->idFolder = FOLDERID_INVALID;
            pcfi->dwFlags = 0;
            pcfi->csfCurrentStage = CSF_INIT;
            pcfi->dwCurrentSfType = fiFolderInfo.tySpecial;
            pcfi->dwFinalSfType = fiFolderInfo.tySpecial;
            pcfi->lParam = (LPARAM) pAppendInfo;
            pcfi->pcoNextOp = PCO_APPENDMSG;

            hr = CreateNextSpecialFolder(pcfi, NULL);
            TraceError(hr); // CreateNextSpecialFolder deletes pcfi on its own if it fails
            fSuppressRelease = TRUE; // It also frees pAppendInfo if it fails

            m_pStore->FreeRecord(&fiFolderInfo);
            goto exit; // Don't send APPEND command until after entire CREATE operation
        }

        m_pStore->FreeRecord(&fiFolderInfo);
    }

    // We're ready to send the APPEND command!
    hr = _EnqueueOperation(tidUPLOADMSG, (LPARAM) pAppendInfo, icAPPEND_COMMAND,
        pszDestFldrPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (NULL != pszDestFldrPath)
        MemFree(pszDestFldrPath);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_PUT_MESSAGE, pCallback);
    else if (NULL != pAppendInfo && FALSE == fSuppressRelease)
    {
        SafeMemFree(pAppendInfo->pszMsgFlags);
        delete pAppendInfo;
    }

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SetMessageFlags(LPMESSAGEIDLIST pList,
                                                     LPADJUSTFLAGS pFlags,
                                                     SETMESSAGEFLAGSFLAGS dwFlags,
                                                     IStoreCallback *pCallback)
{
    HRESULT hr;

    TraceCall("CIMAPSync::SetMessageFlags");
    AssertSingleThreaded;
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL == pList || pList->cMsgs > 0);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = _SetMessageFlags(SOT_SET_MESSAGEFLAGS, pList, pFlags, pCallback);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_SET_MESSAGEFLAGS, pCallback);

    return hr;
}


HRESULT CIMAPSync::GetServerMessageFlags(MESSAGEFLAGS *pFlags)
{
    *pFlags = DwConvertIMAPtoARF(IMAP_MSG_ALLFLAGS);
    return S_OK;
}

//***************************************************************************
// Helper function to mark messages
//***************************************************************************
HRESULT CIMAPSync::_SetMessageFlags(STOREOPERATIONTYPE sotOpType,
                                    LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags,
                                    IStoreCallback *pCallback)
{
    HRESULT         hr;
    MARK_MSGS_INFO   *pMARK_MSGS_INFO = NULL;
    char            szFlagArgs[200];
    LPSTR           pszFlagList;
    DWORD           dwLen;
    LPSTR           p;
    IMAP_MSGFLAGS   imfFlags;
    DWORD           dw;
    ULONG           ul;

    TraceCall("CIMAPSync::_SetMessageFlags");
    AssertSingleThreaded;
    IxpAssert(NULL == pList || pList->cMsgs > 0);

    // Construct a mark msg operation
    // Check the requested flag adjustments
    if (0 == pFlags->dwRemove && 0 == pFlags->dwAdd)
    {
        // Nothing to do here, exit with a smile
        hr = S_OK;
        goto exit;
    }

    if ((0 != pFlags->dwRemove && 0 != pFlags->dwAdd) ||
        (0 != (pFlags->dwRemove & pFlags->dwAdd)))
    {
        // IMAP can't do any of the following:
        //    1) add and removal of flags at the same time (NYI: takes 2 STORE cmds)
        //    2) add/removal of same flag (makes no sense)
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // If ARF_ENDANGERED is set, be sure to set ARF_READ so we don't mess up
    // unread counts as returned by STATUS command
    if (pFlags->dwAdd & ARF_ENDANGERED)
        pFlags->dwAdd |= ARF_READ;

    // Construct MARK_MSGS_INFO structure
    pMARK_MSGS_INFO = new MARK_MSGS_INFO;
    if (NULL == pMARK_MSGS_INFO)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    ZeroMemory(pMARK_MSGS_INFO, sizeof(MARK_MSGS_INFO));

    // Create a rangelist
    hr = CreateRangeList(&pMARK_MSGS_INFO->pMsgRange);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Remember these args so we can set the message flags after server confirmation
    pMARK_MSGS_INFO->afFlags = *pFlags;
    hr = CloneMessageIDList(pList, &pMARK_MSGS_INFO->pList);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    pMARK_MSGS_INFO->sotOpType = sotOpType;

    // Get arguments for the STORE command
    if (0 != pFlags->dwRemove)
        szFlagArgs[0] = '-';
    else
        szFlagArgs[0] = '+';

    p = szFlagArgs + 1;
    p += wnsprintf(p, (ARRAYSIZE(szFlagArgs) - 1), "FLAGS.SILENT ");
    imfFlags = DwConvertARFtoIMAP(pFlags->dwRemove ? pFlags->dwRemove : pFlags->dwAdd);
    hr = ImapUtil_MsgFlagsToString(imfFlags, &pszFlagList, &dwLen);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    if (hr != S_FALSE)
    {
        IxpAssert(dwLen < (sizeof(szFlagArgs) - (p - szFlagArgs)));
        StrCpyN(p, pszFlagList, ARRAYSIZE(szFlagArgs) - (int) (p - szFlagArgs));
        MemFree(pszFlagList);
    }

    // Convert IDList to rangelist to submit to IIMAPTransport
    if (NULL != pList)
    {
        for (dw = 0; dw < pList->cMsgs; dw++)
        {
            HRESULT hrTemp;

            hrTemp = pMARK_MSGS_INFO->pMsgRange->AddSingleValue(PtrToUlong(pList->prgidMsg[dw]));
            TraceError(hrTemp);
        }
    }
    else
    {
        HRESULT hrTemp;

        // pList == NULL means to tackle ALL messages
        hrTemp = pMARK_MSGS_INFO->pMsgRange->AddRange(1, RL_LAST_MESSAGE);
        TraceError(hrTemp);
    }

    IxpAssert(SUCCEEDED(pMARK_MSGS_INFO->pMsgRange->Cardinality(&ul)) && ul > 0);

    // Send the command! (At last!)
    hr = _EnqueueOperation(tidMARKMSGS, (LPARAM) pMARK_MSGS_INFO, icSTORE_COMMAND,
        szFlagArgs, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::CopyMessages(IMessageFolder *pDestFldr,
                                COPYMESSAGEFLAGS dwOptions,
                                LPMESSAGEIDLIST pList,
                                LPADJUSTFLAGS pFlags,
                                IStoreCallback *pCallback)
{
    HRESULT         hr;
    FOLDERID        idDestFldr;
    FOLDERINFO      fiFolderInfo;
    BOOL            fFreeFldrInfo = FALSE;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];

    TraceCall("CIMAPSync::CopyMoveMessages");
    AssertSingleThreaded;

    IxpAssert(FOLDERID_INVALID != m_idIMAPServer);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Check if we can do an IMAP COPY command to satisfy this copy request
    hr = pDestFldr->GetFolderId(&idDestFldr);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pStore->GetFolderInfo(idDestFldr, &fiFolderInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    fFreeFldrInfo = TRUE;

    GetFolderAccountId(&fiFolderInfo, szAccountId, ARRAYSIZE(szAccountId));

    if (0 == lstrcmpi(m_pszAccountID, szAccountId) && FOLDER_IMAP == fiFolderInfo.tyFolder)
    {
        IMAP_COPYMOVE_INFO *pCopyInfo;
        LPSTR               pszDestFldrPath;
        DWORD               dw;
        ULONG               ul;

        // This copy can be accomplished with an IMAP copy command!
        // Check args
        if (NULL != pFlags && (0 != pFlags->dwAdd || 0 != pFlags->dwRemove))
            // IMAP cannot set the flags of copied msg. We would either have to set
            // flags on source before copying, or go to destination folder and set flags
            TraceResult(E_INVALIDARG); // Record error but continue (error not fatal)

        // Find out what translation mode we should be in
        hr = SetTranslationMode(idDestFldr);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Construct CopyMoveInfo structure
        pCopyInfo = new IMAP_COPYMOVE_INFO;
        if (NULL == pCopyInfo)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        pCopyInfo->dwOptions = dwOptions;
        pCopyInfo->idDestFldr = idDestFldr;
        hr = CloneMessageIDList(pList, &pCopyInfo->pList);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        hr = CreateRangeList(&pCopyInfo->pCopyRange);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Convert IDList to rangelist to submit to IIMAPTransport
        if (NULL != pList)
        {
            for (dw = 0; dw < pList->cMsgs; dw++)
            {
                HRESULT hrTemp;

                hrTemp = pCopyInfo->pCopyRange->AddSingleValue(PtrToUlong(pList->prgidMsg[dw]));
                TraceError(hrTemp);
            }
        }
        else
        {
            HRESULT hrTemp;

            // pList == NULL means to tackle ALL messages
            hrTemp = pCopyInfo->pCopyRange->AddRange(1, RL_LAST_MESSAGE);
            TraceError(hrTemp);
        }

        IxpAssert(SUCCEEDED(pCopyInfo->pCopyRange->Cardinality(&ul)) && ul > 0);

        // Construct destination folder path
        hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idDestFldr, &pszDestFldrPath,
            NULL, NULL, m_pStore, NULL, NULL);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Send command to server
        hr = _EnqueueOperation(tidCOPYMSGS, (LPARAM) pCopyInfo, icCOPY_COMMAND,
            pszDestFldrPath, uiNORMAL_PRIORITY);
        MemFree(pszDestFldrPath);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // This is a standard (download from src-save to dest) copy: let caller do it
        hr = STORE_E_NOSERVERCOPY;
        goto exit; // Don't record this error value, it's expected
    }

exit:
    if (fFreeFldrInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_COPYMOVE_MESSAGE, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::DeleteMessages(DELETEMESSAGEFLAGS dwOptions,
                                                    LPMESSAGEIDLIST pList,
                                                    IStoreCallback *pCallback)
{
    ADJUSTFLAGS afFlags;
    HRESULT     hr;

    TraceCall("CIMAPSync::DeleteMessages");
    AssertSingleThreaded;
    IxpAssert(NULL == pList || pList->cMsgs > 0);

    // This function currently only supports IMAP deletion model. Trashcan NYI.

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    if (dwOptions & DELETE_MESSAGE_UNDELETE)
    {
        afFlags.dwAdd = 0;
        afFlags.dwRemove = ARF_ENDANGERED;
    }
    else
    {
        afFlags.dwAdd = ARF_ENDANGERED;
        afFlags.dwRemove = 0;
    }

    hr = _SetMessageFlags(SOT_DELETING_MESSAGES, pList, &afFlags, pCallback);
    if (FAILED(hr))
    {
        TraceError(hr);
        goto exit;
    }

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_DELETING_MESSAGES, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SynchronizeStore(FOLDERID idParent,
                                    DWORD dwFlags,
                                    IStoreCallback *pCallback)
{
    HRESULT hr = S_OK;

    TraceCall("CIMAPSync::SynchronizeStore");
    AssertSingleThreaded;

    IxpAssert(SOT_INVALID == m_sotCurrent);
    IxpAssert(NULL == m_pCurrentCB);

    // This function currently ignores the dwFlags argument
    m_cFolders = 0;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Force mailbox translation since we only issue LIST *
    hr = SetTranslationMode(FOLDERID_INVALID);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    SafeRelease(m_pCurrentHash);
    SafeRelease(m_pListHash);
    m_sotCurrent = SOT_SYNCING_STORE;
    m_pCurrentCB = pCallback;
    if (NULL != pCallback)
        pCallback->AddRef();

    hr = CreateFolderHash(m_pStore, m_idIMAPServer, &m_pCurrentHash);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = MimeOleCreateHashTable(CHASH_BUCKETS, TRUE, &m_pListHash);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
    {
        // Set us up to find out root hierarchy char
        m_phcfHierarchyCharInfo = new HIERARCHY_CHAR_FINDER;
        if (NULL == m_phcfHierarchyCharInfo)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        ZeroMemory(m_phcfHierarchyCharInfo, sizeof(HIERARCHY_CHAR_FINDER));
    }

    ImapUtil_LoadRootFldrPrefix(m_pszAccountID, m_szRootFolderPrefix, ARRAYSIZE(m_szRootFolderPrefix));

    hr = _StartFolderList((LPARAM)FOLDERID_INVALID);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }


exit:
    if (FAILED(hr))
    {
        m_sotCurrent = SOT_INVALID;
        m_pCurrentCB = NULL;
        m_fTerminating = FALSE;
        if (NULL != pCallback)
            pCallback->Release();
    }
    else
        hr = _BeginOperation(m_sotCurrent, m_pCurrentCB);

    return hr;
} // SynchronizeStore



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::CreateFolder(FOLDERID idParent,
                                SPECIALFOLDER tySpecial,
                                LPCSTR pszName,
                                FLDRFLAGS dwFlags,
                                IStoreCallback *pCallback)
{
    HRESULT             hr;
    CHAR                chHierarchy;
    LPSTR               pszFullPath=NULL;
    CREATE_FOLDER_INFO  *pcfi=NULL;
    DWORD               dwFullPathLen;
    LPSTR               pszEnd;

    TraceCall("CIMAPSync::CreateFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Validate folder name
    hr = CheckFolderNameValidity(pszName);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idParent);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    else if (S_FALSE == hr)
    {
        // Parent not translatable from UTF7. In such a case, we only allow creation
        // if child foldername is composed ENTIRELY of USASCII
        if (FALSE == isUSASCIIOnly(pszName))
        {
            // We can't create this folder: parent prohibits UTF7 translation
            hr = TraceResult(STORE_E_NOTRANSLATION);
            goto exit;
        }
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idParent, &pszFullPath, &dwFullPathLen,
        &chHierarchy, m_pStore, pszName, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    pcfi = new CREATE_FOLDER_INFO;
    if (NULL == pcfi)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Fill in all the fields
    pcfi->pszFullFolderPath = pszFullPath;
    pcfi->idFolder = FOLDERID_INVALID;
    pcfi->dwFlags = 0;
    pcfi->csfCurrentStage = CSF_INIT;
    pcfi->dwCurrentSfType = FOLDER_NOTSPECIAL;
    pcfi->dwFinalSfType = FOLDER_NOTSPECIAL;
    pcfi->lParam = NULL;
    pcfi->pcoNextOp = PCO_NONE;

    // Send the CREATE command
    hr = _EnqueueOperation(tidCREATE, (LPARAM)pcfi, icCREATE_COMMAND, pszFullPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // If there is a trailing HC (required to create folder-bearing folders on UW IMAP),
    // remove it from pszFullPath so that LIST and SUBSCRIBE do not carry it (IE5 bug #60054)
    pszEnd = CharPrev(pszFullPath, pszFullPath + dwFullPathLen);
    if (chHierarchy == *pszEnd)
    {
        *pszEnd = '\0';
        Assert(*CharPrev(pszFullPath, pszEnd) != chHierarchy); // Shouldn't get > 1 HC at end
    }

exit:
    if (FAILED(hr))
    {
        SafeMemFree(pszFullPath);
        delete pcfi;
    }
    else
        hr = _BeginOperation(SOT_CREATE_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::MoveFolder(FOLDERID idFolder,
                                                FOLDERID idParentNew,
                                                IStoreCallback *pCallback)
{
    HRESULT hr;

    TraceCall("CIMAPSync::MoveFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = TraceResult(E_NOTIMPL);

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_MOVE_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::RenameFolder(FOLDERID idFolder,
                                LPCSTR pszName,
                                IStoreCallback *pCallback)
{
    HRESULT     hr;
    FOLDERINFO  fiFolderInfo;
    LPSTR       pszOldPath = NULL;
    LPSTR       pszNewPath = NULL;
    char        chHierarchy;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::RenameFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Validate folder name
    hr = CheckFolderNameValidity(pszName);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    else if (S_FALSE == hr)
    {
        // Folder not translatable from UTF7. In such a case, we only allow creation
        // if new foldername is composed ENTIRELY of USASCII. A bit conservative, yes
        // (if leaf node is only un-translatable part, we COULD rename), but I'm too
        // lazy to check for FOLDER_NOTRANSLATEUTF7 all the way to server node.
        if (FALSE == isUSASCIIOnly(pszName))
        {
            // We can't rename this folder: we assume parents prohibit UTF7 translation
            hr = TraceResult(STORE_E_NOTRANSLATION);
            goto exit;
        }
    }

    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Check validity
    fFreeInfo = TRUE;
    IxpAssert(FOLDER_NOTSPECIAL == fiFolderInfo.tySpecial);
    IxpAssert('\0' != fiFolderInfo.pszName);
    IxpAssert('\0' != pszName);
    if (0 == lstrcmp(fiFolderInfo.pszName, pszName))
    {
        hr = E_INVALIDARG; // Nothing to do! Return error.
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszOldPath, NULL,
        &chHierarchy, m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, fiFolderInfo.idParent, &pszNewPath,
        NULL, &chHierarchy, m_pStore, pszName, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = RenameFolderHelper(idFolder, pszOldPath, chHierarchy, pszNewPath);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_RENAME_FOLDER, pCallback);

    SafeMemFree(pszOldPath);
    SafeMemFree(pszNewPath);

    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::DeleteFolder(FOLDERID idFolder,
                                DELETEFOLDERFLAGS dwFlags,
                                IStoreCallback *pCallback)
{
    HRESULT             hr;
    DELETE_FOLDER_INFO *pdfi = NULL;
    LPSTR               pszPath = NULL;
    CHAR                chHierarchy;

    TraceCall("CIMAPSync::DeleteFolder");
    AssertSingleThreaded;

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszPath, NULL,
        &chHierarchy, m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Create a CreateFolderInfo structure
    if (!MemAlloc((LPVOID *)&pdfi, sizeof(DELETE_FOLDER_INFO)))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    pdfi->pszFullFolderPath = pszPath;
    pdfi->cHierarchyChar = chHierarchy;
    pdfi->idFolder = idFolder;

    // Send the DELETE command
    hr = _EnqueueOperation(tidDELETEFLDR, (LPARAM)pdfi, icDELETE_COMMAND, pszPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (FAILED(hr))
    {
        SafeMemFree(pszPath);
        SafeMemFree(pdfi);
    }
    else
        hr = _BeginOperation(SOT_DELETE_FOLDER, pCallback);

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SubscribeToFolder(FOLDERID idFolder,
                                     BOOL fSubscribe,
                                     IStoreCallback *pCallback)
{
    HRESULT hr;
    LPSTR   pszPath = NULL;

    TraceCall("CIMAPSync::SubscribeToFolder");
    AssertSingleThreaded;
    IxpAssert(FOLDERID_INVALID == m_idCurrent);
    IxpAssert(FALSE == m_fSubscribe);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszPath, NULL, NULL,
        m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Send the SUBSCRIBE/UNSUBSCRIBE command
    m_idCurrent = idFolder;
    m_fSubscribe = fSubscribe;
    hr = _EnqueueOperation(tidSUBSCRIBE, 0, fSubscribe ? icSUBSCRIBE_COMMAND :
        icUNSUBSCRIBE_COMMAND, pszPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszPath);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_SUBSCRIBE_FOLDER, pCallback);

    return hr;
}


//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT     hr;
    LPSTR       pszPath = NULL;
    DWORD       dwCapabilities;
    FOLDERINFO  fiFolderInfo;
    BOOL        fFreeFldrInfo = FALSE;

    TraceCall("CIMAPSync::GetFolderCounts");
    AssertSingleThreaded;
    IxpAssert(FOLDERID_INVALID != idFolder);
    IxpAssert(NULL != pCallback);

    hr = _EnsureInited();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode(idFolder);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Perform some verification: folder cannot be \NoSelect, server must be IMAP4rev1
    // Unfortunately, we can't get capability unless we're currently connected
    hr = m_pTransport->IsState(IXP_IS_AUTHENTICATED);
    if (S_OK == hr)
    {
        hr = m_pTransport->Capability(&dwCapabilities);
        if (SUCCEEDED(hr) && 0 == (dwCapabilities & IMAP_CAPABILITY_IMAP4rev1))
        {
            // This server does not support STATUS command, we don't support alternate
            // method of unread count update (eg, EXAMINE folder)
            hr = E_NOTIMPL;
            goto exit;
        }
    }
    // If not connected then we'll check capabilities during connection

    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {
        fFreeFldrInfo = TRUE;
        if (fiFolderInfo.dwFlags & (FOLDER_NOSELECT | FOLDER_NONEXISTENT))
        {
            // This folder cannot have an unread count because it cannot contain messages
            hr = TraceResult(STORE_E_NOSERVERSUPPORT);
            goto exit;
        }
    }

    hr = ImapUtil_FolderIDToPath(m_idIMAPServer, idFolder, &pszPath, NULL, NULL,
        m_pStore, NULL, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    ImapUtil_LoadRootFldrPrefix(m_pszAccountID, m_szRootFolderPrefix, ARRAYSIZE(m_szRootFolderPrefix));
    hr = LoadSaveRootHierarchyChar(fLOAD_HC);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Send the STATUS command
    hr = _EnqueueOperation(tidSTATUS, (LPARAM)idFolder, icSTATUS_COMMAND, pszPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszPath);
    if (fFreeFldrInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (SUCCEEDED(hr))
        hr = _BeginOperation(SOT_UPDATE_FOLDER, pCallback);

    return hr;
}

STDMETHODIMP CIMAPSync::GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    return E_NOTIMPL;
}



HRESULT STDMETHODCALLTYPE CIMAPSync::ExpungeOnExit(void)
{
    HWND    hwndParent;
    HRESULT hrResult = S_OK;

    // Check if user wants us to purge on exit (only if no operations in progress)
    if (DwGetOption(OPT_IMAPPURGE))
    {
        hrResult = GetParentWindow(0, &hwndParent);
        if (SUCCEEDED(hrResult))
        {
            hrResult = PurgeMessageProgress(hwndParent);
            TraceError(hrResult);
        }
    }

    return hrResult;
} // ExpungeOnExit



HRESULT CIMAPSync::Cancel(CANCELTYPE tyCancel)
{
    // $TODO: Translate tyCancel into an HRESULT to return to the caller
    FlushOperationQueue(issNotConnected, STORE_E_OPERATION_CANCELED);
    _Disconnect();

    // The m_hrOperationResult and m_szOperationDetails/m_szOperationProblem
    // vars can be blown away by by _OnCmdComplete caused by disconnect
    m_hrOperationResult = STORE_E_OPERATION_CANCELED;

    // Verify that we are indeed terminating current operation: if not, FORCE IT!
    if (FALSE == m_fTerminating)
    {
        HRESULT hrTemp;

        IxpAssert(FALSE); // This should not happen: fix the problem
        hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_ERROR);
        TraceError(hrTemp);
    }

    return S_OK;
}



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//***************************************************************************
//***************************************************************************

HRESULT CIMAPSync::_LoadAccountInfo()
{
    HRESULT         hr;
    FOLDERINFO      fi;
    FOLDERINFO      *pfiFree=NULL;
    IImnAccount     *pAcct=NULL;
    CHAR            szAccountId[CCHMAX_ACCOUNT_NAME];

    TraceCall("CIMAPSync::_LoadAccountInfo");

    IxpAssert (m_idIMAPServer);
    IxpAssert (m_pStore);
    IxpAssert (g_pAcctMan);

    if (!m_pStore || !g_pAcctMan)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    hr = m_pStore->GetFolderInfo(m_idIMAPServer, &fi);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    pfiFree = &fi;

    hr = GetFolderAccountId(&fi, szAccountId, ARRAYSIZE(szAccountId));
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    m_pszAccountID = PszDupA(szAccountId);
    if (!m_pszAccountID)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAccountId, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // failure of the account name is recoverable
    pAcct->GetPropSz(AP_ACCOUNT_NAME, m_szAccountName, ARRAYSIZE(m_szAccountName));

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    ReleaseObj(pAcct);
    return hr;
}

HRESULT CIMAPSync::_LoadTransport()
{
    HRESULT             hr;
    TCHAR               szLogfilePath[MAX_PATH];
    TCHAR              *pszLogfilePath = NULL;
    IImnAccount        *pAcct=NULL;

    TraceCall("CIMAPSync::_LoadTransport");

    IxpAssert (g_pAcctMan);
    IxpAssert (m_pszAccountID);
    if (!g_pAcctMan)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    // Create and initialize IMAP transport
    hr = CreateIMAPTransport2(&m_pTransport);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Check if logging is enabled
    if (DwGetOption(OPT_MAIL_LOGIMAP4))
    {
        char    szDirectory[MAX_PATH];
        char    szLogFileName[MAX_PATH];
        DWORD   cb;

        *szDirectory = 0;

        // Get the log filename
        cb = GetOption(OPT_MAIL_IMAP4LOGFILE, szLogFileName, ARRAYSIZE(szLogFileName));
        if (0 == cb)
        {
            // Bring out the defaults, and blast it back into registry
            StrCpyN(szLogFileName, c_szDefaultImap4Log, ARRAYSIZE(szLogFileName));
            SetOption(OPT_MAIL_IMAP4LOGFILE, (void *)c_szDefaultImap4Log,
                        lstrlen(c_szDefaultImap4Log) + sizeof(TCHAR), NULL, 0);
        }

        m_pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory));
        pszLogfilePath = PathCombineA(szLogfilePath, szDirectory, szLogFileName);
    }

    hr = m_pTransport->InitNew(pszLogfilePath, this);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pTransport->SetDefaultCP(IMAP_MBOXXLATE_DEFAULT | IMAP_MBOXXLATE_VERBATIMOK, GetACP());
    TraceError(hr);

    hr = m_pTransport->EnableFetchEx(IMAP_FETCHEX_ENABLE);
    if (FAILED(hr))
    {
        // It would be easy for us to add code to handle irtUPDATE_MSG, but nothing is currently in place
        TraceResult(hr);
        goto exit;
    }

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Fill m_rInetServerInfo
    hr = m_pTransport->InetServerFromAccount(pAcct, &m_rInetServerInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    ReleaseObj(pAcct);
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_Connect(void)
{
    HRESULT         hr;
    IXPSTATUS       ixpCurrentStatus;
    INETSERVER      rServerInfo;
    BOOL            fForceReconnect = FALSE;
    IImnAccount    *pAcct;
    HRESULT         hrTemp;

    TraceCall("CIMAPSync::_Connect");

    IxpAssert (g_pAcctMan);
    IxpAssert (m_cRef > 0);
    IxpAssert (m_pTransport);
    if (!g_pAcctMan)
        return E_UNEXPECTED;
    
    // Check if any connection settings changed
    hrTemp = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, &pAcct);
    TraceError(hrTemp);
    if (SUCCEEDED(hrTemp))
    {
        hrTemp = m_pTransport->InetServerFromAccount(pAcct, &rServerInfo);
        TraceError(hrTemp);
        if (SUCCEEDED(hrTemp))
        {
            // Check if anything changed
            if (m_rInetServerInfo.rasconntype != rServerInfo.rasconntype ||
                m_rInetServerInfo.dwPort != rServerInfo.dwPort ||
                m_rInetServerInfo.fSSL != rServerInfo.fSSL ||
                m_rInetServerInfo.fTrySicily != rServerInfo.fTrySicily ||
                m_rInetServerInfo.dwTimeout != rServerInfo.dwTimeout ||
                0 != lstrcmp(m_rInetServerInfo.szUserName, rServerInfo.szUserName) ||
                ('\0' != rServerInfo.szPassword[0] &&
                    0 != lstrcmp(m_rInetServerInfo.szPassword, rServerInfo.szPassword)) ||
                0 != lstrcmp(m_rInetServerInfo.szServerName, rServerInfo.szServerName) ||
                0 != lstrcmp(m_rInetServerInfo.szConnectoid, rServerInfo.szConnectoid))
            {
                CopyMemory(&m_rInetServerInfo, &rServerInfo, sizeof(m_rInetServerInfo));
                fForceReconnect = TRUE;
            }
        }
        pAcct->Release();
    }

    // Find out if we're already connected or in the middle of connecting
    hr = m_pTransport->GetStatus(&ixpCurrentStatus);
    if (FAILED(hr))
    {
        // We'll call IIMAPTransport::Connect and see what happens
        TraceResult(hr);
        hr = S_OK; // Suppress error
        ixpCurrentStatus = IXP_DISCONNECTED;
    }

    // If we're to force a reconnect and we're not currently disconnected, disconnect us
    if (fForceReconnect && IXP_DISCONNECTED != ixpCurrentStatus)
    {
        m_fReconnect = TRUE; // Prohibit abortion of current operation due to disconnect
        hrTemp = m_pTransport->DropConnection();
        TraceError(hrTemp);
        m_fReconnect = FALSE;
    }

    // Ask our client if we can connect. If no CB or if failure, we just try to connect
    // Make sure we call CanConnect after DropConnection above, to avoid msg pumping
    if (NULL != m_pCurrentCB)
    {
        hr = m_pCurrentCB->CanConnect(m_pszAccountID,
            SOT_PURGING_MESSAGES == m_sotCurrent ? CC_FLAG_DONTPROMPT : NOFLAGS);
        if (S_OK != hr)
        {
            // Make sure all non-S_OK success codes are treated as failures
            // Convert all error codes to HR_E_USER_CANCEL_CONNECT if we were purging-on-exit
            // This prevents error dialogs while purging-on-exit.
            hr = TraceResult(hr);
            if (SUCCEEDED(hr) || SOT_PURGING_MESSAGES == m_sotCurrent)
                hr = HR_E_USER_CANCEL_CONNECT;

            goto exit;
        }
    }

    // If we're already in the middle of connecting, do nothing and return successful HRESULT
    if (IXP_DISCONNECTED == ixpCurrentStatus || IXP_DISCONNECTING == ixpCurrentStatus ||
        fForceReconnect)
    {
        // Make sure m_rInetServerInfo is loaded with latest cached password from user
        // This allows reconnect without user intervention if user didn't save password
        GetPassword(m_rInetServerInfo.dwPort, m_rInetServerInfo.szServerName,
            m_rInetServerInfo.szUserName, m_rInetServerInfo.szPassword,
            ARRAYSIZE(m_rInetServerInfo.szPassword));

        // We're neither connected nor in the process of connecting: start connecting
        hr = m_pTransport->Connect(&m_rInetServerInfo, iitAUTHENTICATE, iitDISABLE_ONCOMMAND);
    }
    else
    {
        // "Do Nothing" in the comment above now means to kick the FSM to the next state
        hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_CONNCOMPLETE);
        TraceError(hrTemp);
    }

exit:
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_Disconnect(void)
{
    HRESULT hr;
    IXPSTATUS   ixpCurrentStatus;

    TraceCall("CIMAPSync::_Disconnect");
    IxpAssert(m_cRef > 0);

    // Find out if we're already disconnected or in the middle of disconnecting
    hr = m_pTransport->GetStatus(&ixpCurrentStatus);
    if (FAILED(hr))
    {
        // We'll call IIMAPTransport::DropConnection and see what happens
        TraceResult(hr);
        hr = S_OK; // Suppress error
        ixpCurrentStatus = IXP_CONNECTED;
    }

    // If we're already in the middle of disconnecting, do nothing and return successful HRESULT
    if (IXP_DISCONNECTED != ixpCurrentStatus &&
        IXP_DISCONNECTING != ixpCurrentStatus && NULL != m_pTransport && FALSE == m_fDisconnecting)
    {
        m_fDisconnecting = TRUE;
        m_hrOperationResult = STORE_E_OPERATION_CANCELED;
        hr = m_pTransport->DropConnection();
    }

    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_BeginOperation(STOREOPERATIONTYPE sotOpType,
                                   IStoreCallback *pCallback)
{
    HRESULT             hr;
    STOREOPERATIONINFO  soi;
    STOREOPERATIONINFO  *psoi=NULL;

    IxpAssert(SOT_INVALID != sotOpType);

    m_sotCurrent = sotOpType;
    ReplaceInterface(m_pCurrentCB, pCallback);
    m_hrOperationResult = OLE_E_BLANK; // Unitialized state
    m_szOperationProblem[0] = '\0';
    m_szOperationDetails[0] = '\0';
    m_fTerminating = FALSE;

    // Kickstart the connection state machine
    hr = _ConnFSM_QueueEvent(CFSM_EVENT_CMDAVAIL);
    if (FAILED(hr))
    {
        TraceResult(hr);
    }
    else
    {
        if (sotOpType == SOT_GET_MESSAGE)
        {
            // provide message id on get message start
            soi.cbSize = sizeof(STOREOPERATIONINFO);
            soi.idMessage = m_idMessage;
            psoi = &soi;
        }

        if (pCallback)
            pCallback->OnBegin(sotOpType, psoi, this);

        hr = E_PENDING;
    }

    return hr;
}



//***************************************************************************
// Function: _EnqueueOperation
//
// Purpose:
//   This function enqueues IMAP operations for execution once we have
// entered the SELECTED state on the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - transaction ID identifying this operation.
//     This ID is always returned to CmdCompletionNotification, and possibly
//     returned to any untagged responses which result from the given cmd.
//   LPARAM lParam [in] - lParam associated with this transaction.
//   IMAP_COMMAND icCommandID [in] - this identifies the IMAP command the
//     caller wishes to send to the IMAP server.
//   LPSTR pszCmdArgs [in] - the command arguments. Pass in NULL if the
//     queued command has no arguments.
//   UINT uiPriority [in] - a priority associated with this IMAP command.
//     The value of "0" is highest priority. Before an IMAP command of
//     a given priority can be sent, there must be NO higher-priority cmds
//     waiting.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::_EnqueueOperation(WPARAM wParam, LPARAM lParam,
                                    IMAP_COMMAND icCommandID, LPCSTR pszCmdArgs,
                                    UINT uiPriority)
{
    IMAP_OPERATION *pioCommand;
    IMAP_OPERATION *pioPrev, *pioCurrent;
    HRESULT         hr = S_OK;

    TraceCall("CIMAPSync::_EnqueueOperation");
    IxpAssert(m_cRef > 0);

    // Construct a IMAP_OPERATION queue element for this command
    pioCommand = new IMAP_OPERATION;
    if (NULL == pioCommand)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }
    pioCommand->wParam = wParam;
    pioCommand->lParam = lParam;
    pioCommand->icCommandID = icCommandID;
    pioCommand->pszCmdArgs = PszDupA(pszCmdArgs);
    pioCommand->uiPriority = uiPriority;
    pioCommand->issMinimum = IMAPCmdToMinISS(icCommandID);
    IxpAssert(pioCommand->issMinimum >= issNonAuthenticated);

    // Refcount if this is a streamed operation
    if (tidRENAME == wParam ||
        tidRENAMESUBSCRIBE == wParam ||
        tidRENAMELIST == wParam ||
        tidRENAMERENAME == wParam ||
        tidRENAMESUBSCRIBE_AGAIN == wParam ||
        tidRENAMEUNSUBSCRIBE == wParam)
        ((CRenameFolderInfo *)lParam)->AddRef();

    // Insert element into the queue
    // Find a node which has lower priority than the cmd we want to enqueue
    pioPrev = NULL;
    pioCurrent = m_pioNextOperation;
    while (NULL != pioCurrent && pioCurrent->uiPriority <= uiPriority)
    {
        // Advance both pointers
        pioPrev = pioCurrent;
        pioCurrent = pioCurrent->pioNextCommand;
    }

    // pioPrev now points to the insertion point
    if (NULL == pioPrev)
    {
        // Insert command at head of queue
        pioCommand->pioNextCommand = m_pioNextOperation;
        m_pioNextOperation = pioCommand;
    }
    else {
        // Insert command in middle/end of queue
        pioCommand->pioNextCommand = pioCurrent;
        pioPrev->pioNextCommand = pioCommand;
    }

    // Try to send immediately if we're in correct state
    if (CFSM_STATE_WAITFOROPERATIONDONE == m_cfsState)
    {
        do {
            hr = _SendNextOperation(snoDO_NOT_DISPOSE);
            TraceError(hr);
        } while (S_OK == hr);
    }

exit:
    return hr;
}



//***************************************************************************
// Function: _SendNextOperation
//
// Purpose:
//   This function sends the next IMAP operation in the queue if the
// conditions are correct. Currently, these conditions are:
//     a) We are in the SELECTED state on the IMAP server
//     b) The IMAP operation queue is not empty
//
// Arguments:
//    DWORD dwFlags [in] - one of the following:
//      snoDO_NOT_DISPOSE - do not dispose of LPARAM if error occurs, typically
//        because EnqueueOperation will return error to caller thus causing
//        caller to dispose of data.
//
// Returns:
//   S_OK if there are more operations available to be sent. S_FALSE if no more
// IMAP operations can be sent at this time. Failure result if an error occured.
//***************************************************************************
HRESULT CIMAPSync::_SendNextOperation(DWORD dwFlags)
{
    IMAP_OPERATION *pioNextCmd;
    IMAP_OPERATION *pioPrev;
    HRESULT         hr;

    TraceCall("CIMAPSync::_SendNextOperation");
    IxpAssert(m_cRef > 0);

    // Check if conditions permit sending of an IMAP operation
    hr = m_pTransport->IsState(IXP_IS_AUTHENTICATED);
    if (S_OK != hr)
    {
        hr = S_FALSE; // No operations to send (YET)
        goto exit;
    }

    // Look for next eligible command
    hr = GetNextOperation(&pioNextCmd);
    if (STORE_S_NOOP == hr || FAILED(hr))
    {
        TraceError(hr);
        hr = S_FALSE;
        goto exit;
    }

    // Send it
    hr = S_OK;
    switch (pioNextCmd->icCommandID)
    {
        case icFETCH_COMMAND:
        {
            LPSTR pszFetchArgs;
            char szFetchArgs[CCHMAX_CMDLINE];

            // Check if this is a BODY FETCH. We have to construct args for body fetch
            if (tidBODY == pioNextCmd->wParam)
            {
                DWORD dwCapabilities;

                // Check if this is IMAP4 or IMAP4rev1 (RFC822.PEEK or BODY.PEEK[])
                IxpAssert(NULL == pioNextCmd->pszCmdArgs);
                hr = m_pTransport->Capability(&dwCapabilities);
                if (FAILED(hr))
                {
                    TraceResult(hr);
                    dwCapabilities = IMAP_CAPABILITY_IMAP4; // Carry on assuming IMAP4
                }

                wnsprintf(szFetchArgs, ARRAYSIZE(szFetchArgs), "%lu (%s UID)", pioNextCmd->lParam,
                    (dwCapabilities & IMAP_CAPABILITY_IMAP4rev1) ? "BODY.PEEK[]" : "RFC822.PEEK");
                pszFetchArgs = szFetchArgs;
            }
            else
            {
                IxpAssert(NULL != pioNextCmd->pszCmdArgs);
                pszFetchArgs = pioNextCmd->pszCmdArgs;
            }

            hr = m_pTransport->Fetch(pioNextCmd->wParam, pioNextCmd->lParam,
                this, NULL, USE_UIDS, pszFetchArgs); // We always use UIDs
            TraceError(hr);
        }
            break;

        case icSTORE_COMMAND:
        {
            MARK_MSGS_INFO   *pMARK_MSGS_INFO;

            pMARK_MSGS_INFO = (MARK_MSGS_INFO *) pioNextCmd->lParam;
            IxpAssert(tidMARKMSGS == pioNextCmd->wParam);
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            hr = m_pTransport->Store(pioNextCmd->wParam,
                pioNextCmd->lParam, this, pMARK_MSGS_INFO->pMsgRange,
                USE_UIDS, pioNextCmd->pszCmdArgs); // We always use UIDs
            TraceError(hr);
        }
        break;

        case icCOPY_COMMAND:
        {
            IMAP_COPYMOVE_INFO *pCopyMoveInfo;

            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            pCopyMoveInfo = (IMAP_COPYMOVE_INFO *) pioNextCmd->lParam;
            IxpAssert(NULL != pCopyMoveInfo->pCopyRange);

            // Find out what translation mode we should be in
            hr = SetTranslationMode(pCopyMoveInfo->idDestFldr);
            if (FAILED(hr))
            {
                TraceResult(hr);
                break;
            }

            hr = m_pTransport->Copy(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pCopyMoveInfo->pCopyRange,
                USE_UIDS, pioNextCmd->pszCmdArgs); // We always use UIDs
            TraceError(hr);
        }
            break; // icCOPY_COMMAND

        case icCLOSE_COMMAND:
            IxpAssert(NULL == pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Close(pioNextCmd->wParam, pioNextCmd->lParam, this);
            TraceError(hr);
            break;

        case icAPPEND_COMMAND:
        {
            APPEND_SEND_INFO *pAppendInfo;

            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            pAppendInfo = (APPEND_SEND_INFO *) pioNextCmd->lParam;
            hr = m_pTransport->Append(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs, pAppendInfo->pszMsgFlags,
                pAppendInfo->ftReceived, pAppendInfo->lpstmMsg);
            TraceError(hr);
        }
            break; // case icAPPEND_COMMAND

        case icLIST_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->List(pioNextCmd->wParam, pioNextCmd->lParam,
                this, "", pioNextCmd->pszCmdArgs); // Reference is always blank
            TraceError(hr);
            break; // case icLIST_COMMAND

        case icLSUB_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Lsub(pioNextCmd->wParam, pioNextCmd->lParam,
                this, "", pioNextCmd->pszCmdArgs); // Reference is always blank
            TraceError(hr);
            break; // case icLSUB_COMMAND

        case icCREATE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);

            hr = m_pTransport->Create(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icCREATE_COMMAND

        case icSUBSCRIBE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Subscribe(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icSUBSCRIBE_COMMAND

        case icDELETE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Delete(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icDELETE_COMMAND

        case icUNSUBSCRIBE_COMMAND:
            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            hr = m_pTransport->Unsubscribe(pioNextCmd->wParam, pioNextCmd->lParam,
                this, pioNextCmd->pszCmdArgs);
            TraceError(hr);
            break; // case icUNSUBSCRIBE_COMMAND

        case icRENAME_COMMAND:
        {
            CRenameFolderInfo *pRenameInfo;
            LPSTR pszOldFldrName;

            IxpAssert(NULL != pioNextCmd->pszCmdArgs);
            IxpAssert(NULL != pioNextCmd->lParam);

            pRenameInfo = (CRenameFolderInfo *) pioNextCmd->lParam;
            hr = m_pTransport->Rename(pioNextCmd->wParam, (LPARAM) pRenameInfo,
                this, pRenameInfo->pszRenameCmdOldFldrPath, pioNextCmd->pszCmdArgs);
            TraceError(hr);
        } // case icRENAME_COMMAND
            break; // case icRENAME_COMMAND

        case icSTATUS_COMMAND:
        {
            DWORD dwCapabilities;

            IxpAssert(FOLDERID_INVALID != (FOLDERID)pioNextCmd->lParam);

            // Have to check if this is an IMAP4rev1 server. If not, FAIL the Status operation
            hr = m_pTransport->Capability(&dwCapabilities);
            if (SUCCEEDED(hr) && 0 == (dwCapabilities & IMAP_CAPABILITY_IMAP4rev1))
            {
                // Can't currently check unread count for non-IMAP4rev1 servers
                hr = STORE_E_NOSERVERSUPPORT;
            }
            else
            {
                hr = m_pTransport->Status(pioNextCmd->wParam, pioNextCmd->lParam,
                    this, pioNextCmd->pszCmdArgs, "(MESSAGES UNSEEN)");
            }
        }
            break;

        default:
            AssertSz(FALSE, "Someone queued an operation I can't handle!");
            break;
    }

    // Handle any errors encountered above
    if (FAILED(hr))
    {
        TraceResult(hr);

        // Free any non-NULL lParam's and call IStoreCallback::OnComplete
        if (0 == (dwFlags & snoDO_NOT_DISPOSE))
        {
            if ('\0' == m_szOperationDetails)
                // Fill in error information: error propagation causes IStoreCallback::OnComplete call
                LoadString(g_hLocRes, idsIMAPSendNextOpErrText, m_szOperationDetails, ARRAYSIZE(m_szOperationDetails));

            DisposeOfWParamLParam(pioNextCmd->wParam, pioNextCmd->lParam, hr);
        }
    }

    // Deallocate the imap operation
    if (NULL != pioNextCmd->pszCmdArgs)
        MemFree(pioNextCmd->pszCmdArgs);

    delete pioNextCmd;

exit:
    return hr;
}



//***************************************************************************
// Function: FlushOperationQueue
//
// Purpose:
//   This function frees the entire contents of the IMAP operation queue.
// Usually used by the CIMAPSync destructor, and whenever an error occurs
// which would prevent the sending of queued IMAP operations (eg, login
// failure).
//
// Arguments:
//   IMAP_SERVERSTATE issMaximum [in] - defines the maximum server state
//     currently allowed in the queue. For instance, if a select failed,
//     we would call FlushOperationQueue(issAuthenticated) to remove all
//     commands that require issSelected as their minimum state. To remove
//     all commands, pass in issNotConnected.
//***************************************************************************
void CIMAPSync::FlushOperationQueue(IMAP_SERVERSTATE issMaximum, HRESULT hrError)
{
    IMAP_OPERATION *pioCurrent;
    IMAP_OPERATION *pioPrev;

    IxpAssert(((int) m_cRef) >= 0); // Can be called by destructor

    pioPrev = NULL;
    pioCurrent = m_pioNextOperation;
    while (NULL != pioCurrent)
    {
        // Check if current command should be deleted
        if (pioCurrent->issMinimum > issMaximum)
        {
            IMAP_OPERATION *pioDead;
            HRESULT         hr;

            // Current command level exceeds the maximum. Unlink from queue and delete
            pioDead = pioCurrent;
            if (NULL == pioPrev)
            {
                // Dequeue from head of queue
                m_pioNextOperation = pioCurrent->pioNextCommand;
                pioCurrent = pioCurrent->pioNextCommand;
            }
            else
            {
                // Dequeue from mid/end of queue
                pioPrev->pioNextCommand = pioCurrent->pioNextCommand;
                pioCurrent = pioCurrent->pioNextCommand;
            }

            // Free any non-NULL lParam's and call IStoreCallback::OnComplete
            if ('\0' == m_szOperationDetails)
                // Fill in error information: error propagation causes IStoreCallback::OnComplete call
                LoadString(g_hLocRes, idsIMAPSendNextOpErrText, m_szOperationDetails,
                    ARRAYSIZE(m_szOperationDetails));

            DisposeOfWParamLParam(pioDead->wParam, pioDead->lParam, hrError);

            if (NULL != pioDead->pszCmdArgs)
                MemFree(pioDead->pszCmdArgs);

            delete pioDead;
        }
        else
        {
            // Current command is within maximum level. Advance pointers
            pioPrev = pioCurrent;
            pioCurrent = pioCurrent->pioNextCommand;
        }
    } // while

} // FlushOperationQueue



//***************************************************************************
//***************************************************************************
IMAP_SERVERSTATE CIMAPSync::IMAPCmdToMinISS(IMAP_COMMAND icCommandID)
{
    IMAP_SERVERSTATE    issResult;

    TraceCall("CIMAPSync::IMAPCmdToMinISS");
    switch (icCommandID)
    {
        case icSELECT_COMMAND:
        case icEXAMINE_COMMAND:
        case icCREATE_COMMAND:
        case icDELETE_COMMAND:
        case icRENAME_COMMAND:
        case icSUBSCRIBE_COMMAND:
        case icUNSUBSCRIBE_COMMAND:
        case icLIST_COMMAND:
        case icLSUB_COMMAND:
        case icAPPEND_COMMAND:
        case icSTATUS_COMMAND:
            issResult = issAuthenticated;
            break;

        case icCLOSE_COMMAND:
        case icSEARCH_COMMAND:
        case icFETCH_COMMAND:
        case icSTORE_COMMAND:
        case icCOPY_COMMAND:
            issResult = issSelected;
            break;

        default:
            AssertSz(FALSE, "What command are you trying to send?");

            // *** FALL THROUGH ***

        case icLOGOUT_COMMAND:
        case icNOOP_COMMAND:
            issResult = issNonAuthenticated;
            break;
    }

    return issResult;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetNextOperation(IMAP_OPERATION **ppioOp)
{
    HRESULT         hr = S_OK;
    IMAP_OPERATION *pioCurrent;
    IMAP_OPERATION *pioPrev;

    TraceCall("CIMAPSync::GetNextOperation");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != ppioOp);

    pioPrev = NULL;
    pioCurrent = m_pioNextOperation;

    while (NULL != pioCurrent)
    {
        // Check if we are able to send the current command
        if (pioCurrent->issMinimum <= m_issCurrent)
            break;

        // Advance pointers
        pioPrev = pioCurrent;
        pioCurrent = pioCurrent->pioNextCommand;
    }

    // Check if we found anything
    if (NULL == pioCurrent)
    {
        hr = STORE_S_NOOP; // Nothing to send at the moment
        goto exit;
    }

    // If we reached here, we found something. Dequeue operation.
    *ppioOp = pioCurrent;
    if (NULL == pioPrev)
    {
        // Dequeue from head of queue
        m_pioNextOperation = pioCurrent->pioNextCommand;
    }
    else
    {
        // Dequeue from mid/end of queue
        pioPrev->pioNextCommand = pioCurrent->pioNextCommand;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: DisposeofWParamLParam
//
// Purpose:
//   This function eliminates the wParam and lParam arguments of an IMAP
// operation in the event of failure.
//
// Arguments:
//   WPARAM wParam - the wParam of the failed IMAP operation.
//   LPARAM lPAram - the lParam of the failed IMAP operation.
//   HRESULT hr - the error condition that caused the IMAP op failure
//***************************************************************************
void CIMAPSync::DisposeOfWParamLParam(WPARAM wParam, LPARAM lParam, HRESULT hr)
{
    TraceCall("CIMAPSync::DisposeofWParamLParam");
    IxpAssert(m_cRef > 0);
    AssertSz(FAILED(hr), "If you didn't fail, why are you here?");

    switch (wParam)
    {
        case tidCOPYMSGS:
        case tidMOVEMSGS:
        {
            IMAP_COPYMOVE_INFO *pCopyMoveInfo;

            // Notify the user that the operation has failed, and free the structure
            pCopyMoveInfo = (IMAP_COPYMOVE_INFO *) lParam;

            SafeMemFree(pCopyMoveInfo->pList);
            pCopyMoveInfo->pCopyRange->Release();
            delete pCopyMoveInfo;
            break;
        }

        case tidBODYMSN:
        case tidBODY:
            LoadString(g_hLocRes, idsIMAPBodyFetchFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            NotifyMsgRecipients(lParam, fCOMPLETED, NULL, hr, m_szOperationProblem);
            break; // case tidBODYMSN, tidBODY

        case tidMARKMSGS:
        {
            MARK_MSGS_INFO   *pMarkMsgInfo;

            // Notify the user that the operation has failed, and free the structure
            pMarkMsgInfo = (MARK_MSGS_INFO *) lParam;

            SafeMemFree(pMarkMsgInfo->pList);
            SafeRelease(pMarkMsgInfo->pMsgRange);
            delete pMarkMsgInfo;
            break;
        }
            break; // case tidMARKMSGS

        case tidFETCH_NEW_HDRS:
            IxpAssert(lParam == NULL);
            break;

        case tidFETCH_CACHED_FLAGS:
            IxpAssert(lParam == NULL);
            break;

        case tidNOOP:
            IxpAssert(lParam == NULL);
            break;

        case tidSELECTION:
            IxpAssert(lParam != NULL);
            break;

        case tidUPLOADMSG:
        {
            APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) lParam;

            SafeMemFree(pAppendInfo->pszMsgFlags);
            SafeRelease(pAppendInfo->lpstmMsg);
            delete pAppendInfo;
        }
            break;

        case tidCREATE:
        case tidCREATELIST:
        case tidCREATESUBSCRIBE:
        case tidSPECIALFLDRLIST:
        case tidSPECIALFLDRLSUB:
        case tidSPECIALFLDRSUBSCRIBE:
        {
            CREATE_FOLDER_INFO *pcfiCreateInfo;

            pcfiCreateInfo = (CREATE_FOLDER_INFO *) lParam;

            MemFree(pcfiCreateInfo->pszFullFolderPath);
            if (NULL != pcfiCreateInfo->lParam)
            {
                switch (pcfiCreateInfo->pcoNextOp)
                {
                    case PCO_NONE:
                        AssertSz(FALSE, "Expected NULL lParam. Check for memleak.");
                        break;

                    case PCO_FOLDERLIST:
                        AssertSz(FOLDERID_INVALID == (FOLDERID) pcfiCreateInfo->lParam,
                            "Expected FOLDERID_INVALID lParam. Check for memleak.");
                        break;

                    case PCO_APPENDMSG:
                    {
                        APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) pcfiCreateInfo->lParam;

                        SafeMemFree(pAppendInfo->pszMsgFlags);
                        SafeRelease(pAppendInfo->lpstmMsg);
                        delete pAppendInfo;
                    }
                        break;

                    default:
                        AssertSz(FALSE, "Unhandled CREATE_FOLDER_INFO lParam. Check for memleak.");
                        break;
                } // switch
            }
            delete pcfiCreateInfo;

            break;
        }


        case tidDELETEFLDR:
        case tidDELETEFLDR_UNSUBSCRIBE:
            MemFree(((DELETE_FOLDER_INFO *)lParam)->pszFullFolderPath);
            MemFree((DELETE_FOLDER_INFO *)lParam);
            break; // case tidDELETEFLDR_UNSUBSCRIBE

        case tidSUBSCRIBE:
            IxpAssert(NULL == lParam);
            break;

        case tidRENAME:
        case tidRENAMESUBSCRIBE:
        case tidRENAMELIST:
        case tidRENAMERENAME:
        case tidRENAMESUBSCRIBE_AGAIN:
        case tidRENAMEUNSUBSCRIBE:
            ((CRenameFolderInfo *) lParam)->Release();
            break;

        case tidHIERARCHYCHAR_LIST_B:
        case tidHIERARCHYCHAR_CREATE:
        case tidHIERARCHYCHAR_LIST_C:
        case tidHIERARCHYCHAR_DELETE:
        case tidPREFIXLIST:
        case tidPREFIX_HC:
        case tidPREFIX_CREATE:
        case tidFOLDERLIST:
        case tidFOLDERLSUB:
        case tidSTATUS:
            break;

        default:
            AssertSz(NULL == lParam, "Is this a possible memory leak?");
            break;
    }
} // DisposeOfWParamLParam



//***************************************************************************
// Function: NotifyMsgRecipients
//
// Purpose:
//   This function sends notifications to all registered recipients of a
// given message UID. Currently handles IMC_BODYAVAIL and IMC_ARTICLEPROG
// messages.
//
// Arguments:
//   DWORD dwUID [in] - the UID identifying the message whose recipients
//     are to be updated.
//   BOOL fCompletion [in] - TRUE if we're done fetching the msg body.
//     FALSE if we're still in the middle of fetching (progress indication)
//   FETCH_BODY_PART *pFBPart [in] - fragment of FETCH body currently being
//     downloaded. Should always be NULL if fCompletion is TRUE.
//   HRESULT hrCompletion [in] - completion result. Should always be S_OK
//     if fCompletion is FALSE.
//   LPSTR pszDetails [in] - error message details for completion. Should
//     always be NULL unless fCompletion is TRUE and hrCompletion is a
//     failure code.
//***************************************************************************
void CIMAPSync::NotifyMsgRecipients(DWORD_PTR dwUID, BOOL fCompletion,
                                    FETCH_BODY_PART *pFBPart,
                                    HRESULT hrCompletion, LPSTR pszDetails)
{
    HRESULT hrTemp; // For recording non-fatal errors
    ADJUSTFLAGS         flags;
    MESSAGEIDLIST       list;

    TraceCall("CIMAPSync::NotifyMsgRecipients");
    IxpAssert(m_cRef > 0);
    IxpAssert(0 != dwUID);
    AssertSz(NULL == pFBPart || FALSE == fCompletion, "pFBPart must be NULL if fCompletion TRUE!");
    AssertSz(NULL != pFBPart || fCompletion, "pFBPart cannot be NULL if fCompletion FALSE!");
    AssertSz(NULL == pszDetails || fCompletion, "pszDetails must be NULL if fCompletion FALSE!");
    AssertSz(S_OK == hrCompletion || fCompletion, "hrCompletion must be S_OK if fCompletion FALSE!");
    IxpAssert(m_pCurrentCB || fCompletion);
    IxpAssert(m_pstmBody);
    IxpAssert(m_idMessage || FALSE == fCompletion);

    // If this is a failed completion, fill out a STOREERROR struct
    if (fCompletion && FAILED(hrCompletion))
    {
        if (IS_INTRESOURCE(pszDetails))
        {
            // pszDetails is actually a string resource, so load it up
            LoadString(g_hLocRes, PtrToUlong(pszDetails), m_szOperationDetails,
                ARRAYSIZE(m_szOperationDetails));
            pszDetails = m_szOperationDetails;
        }
        LoadString(g_hLocRes, idsIMAPDnldDlgDLFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
    }

    if (fCompletion)
    {
        if (SUCCEEDED(hrCompletion))
        {
            HRESULT hr;

            hr = CommitMessageToStore(m_pFolder, NULL, m_idMessage, m_pstmBody);
            if (FAILED(hr))
            {
                TraceResult(hr);
                LoadString(g_hLocRes, idsErrSetMessageStreamFailed, m_szOperationProblem,
                    ARRAYSIZE(m_szOperationProblem));
            }
            else
                m_faStream = 0;
        }
        else if (hrCompletion == STORE_E_EXPIRED)
        {
            list.cAllocated = 0;
            list.cMsgs = 1;
            list.prgidMsg = &m_idMessage;

            flags.dwAdd = ARF_ARTICLE_EXPIRED;
            flags.dwRemove = ARF_DOWNLOAD;

            Assert(m_pFolder);
            m_pFolder->SetMessageFlags(&list, &flags, NULL, NULL);
            //m_pFolder->SetMessageStream(m_idMessage, m_pstmBody);
        }

        SafeRelease(m_pstmBody);
        if (0 != m_faStream)
        {
            Assert(m_pFolder);
            m_pFolder->DeleteStream(m_faStream);
            m_faStream = 0;
        }
    }
    else
    {
        DWORD   dwCurrent;
        DWORD   dwTotal;
        ULONG   ulWritten;

        // Write this fragment to the stream
        IxpAssert(fbpBODY == pFBPart->lpFetchCookie1);
        hrTemp = m_pstmBody->Write(pFBPart->pszData, pFBPart->dwSizeOfData, &ulWritten);
        if (FAILED(hrTemp))
            m_hrOperationResult = TraceResult(hrTemp); // Make sure we don't commit stream
        else
            IxpAssert(ulWritten == pFBPart->dwSizeOfData);

        if (pFBPart->dwSizeOfData > 0)
            m_fGotBody = TRUE;

        // Indicate message download progress
        if (pFBPart->dwTotalBytes > 0)
        {
            dwCurrent = pFBPart->dwOffset + pFBPart->dwSizeOfData;
            dwTotal = pFBPart->dwTotalBytes;
            m_pCurrentCB->OnProgress(SOT_GET_MESSAGE, dwCurrent, dwTotal, NULL);
        }
    }
} // NotifyMsgRecipients


//***************************************************************************
// Function: OnFolderExit
//
// Purpose:
//   This function is called when a folder is exited (currently occurs only
// through a disconnect). It resets the module's folder-specific variables
// so that re-connection to the folder (or a different folder) cause
// carry-over of information from the previous session.
//***************************************************************************
void CIMAPSync::OnFolderExit(void)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::OnFolderExit");
    IxpAssert(m_cRef > 0);

    m_dwMsgCount = 0;
    m_fMsgCountValid = FALSE;
    m_dwNumHdrsDLed = 0;
    m_dwNumUnreadDLed = 0;
    m_dwNumHdrsToDL = 0;
    m_dwUIDValidity = 0;
    m_dwSyncToDo = 0; // Leave m_dwSyncFolderFlags as-is, so we can re-sync on re-connect
    m_dwHighestCachedUID = 0;
    m_rwsReadWriteStatus = rwsUNINITIALIZED;
    m_fNewMail = FALSE;
    m_fInbox = FALSE;
    m_fDidFullSync = FALSE;
    m_idSelectedFolder = FOLDERID_INVALID;

    // Clear MsgSeqNumToUID table
    hrTemp = m_pTransport->ResetMsgSeqNumToUID();
    TraceError(hrTemp);
}



//***************************************************************************
//***************************************************************************
void CIMAPSync::FillStoreError(LPSTOREERROR pErrorInfo, HRESULT hr,
                               DWORD dwSocketError, LPSTR pszProblem,
                               LPSTR pszDetails)
{
    DWORD   dwFlags = 0;

    TraceCall("CIMAPSync::FillStoreError");
    IxpAssert(((int) m_cRef) >= 0); // Can be called during destruction
    IxpAssert(NULL != pErrorInfo);

    // pszProblem/pszDetails = NULL means m_szOperationProblem/m_szOperationDetails already filled out
    // Use defaults if any of the text fields are blank
    if (NULL != pszProblem && IS_INTRESOURCE(pszProblem))
    {
        LoadString(g_hLocRes, PtrToUlong(pszProblem), m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
    }
    else if (NULL != pszProblem)
    {
        if ('\0' == *pszProblem)
            LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
        else
            StrCpyN(m_szOperationProblem, pszProblem, ARRAYSIZE(m_szOperationProblem));
    }

    if (NULL != pszDetails && IS_INTRESOURCE(pszDetails))
    {
        LoadString(g_hLocRes, PtrToUlong(pszDetails), m_szOperationDetails, ARRAYSIZE(m_szOperationDetails));
    }
    else if (NULL != pszDetails)
    {
        if ('\0' == *pszDetails)
            m_szOperationDetails[0] = '\0';
        else
            StrCpyN(m_szOperationDetails, pszDetails, ARRAYSIZE(m_szOperationDetails));
    }

    // If we are currently disconnected, it is unlikely that any additional operations
    // should be sent to the IMAP server: there's likely a connection error or user cancellation.
    if (STORE_E_OPERATION_CANCELED == hr || m_cfsPrevState <= CFSM_STATE_WAITFORCONN)
        dwFlags |= SE_FLAG_FLUSHALL;

    // Fill out the STOREERROR structure
    ZeroMemory(pErrorInfo, sizeof(*pErrorInfo));
    pErrorInfo->hrResult = hr;
    pErrorInfo->uiServerError = 0; // No such thing in the IMAP protocol
    pErrorInfo->hrServerError = S_OK;
    pErrorInfo->dwSocketError = dwSocketError; // Oops, not propagated in IIMAPCallback::OnResponse
    pErrorInfo->pszProblem = m_szOperationProblem;
    pErrorInfo->pszDetails = m_szOperationDetails;
    pErrorInfo->pszAccount = m_rInetServerInfo.szAccount;
    pErrorInfo->pszServer = m_rInetServerInfo.szServerName;
    pErrorInfo->pszUserName = m_rInetServerInfo.szUserName;
    pErrorInfo->pszProtocol = "IMAP";
    pErrorInfo->pszConnectoid = m_rInetServerInfo.szConnectoid;
    pErrorInfo->rasconntype = m_rInetServerInfo.rasconntype;
    pErrorInfo->ixpType = IXP_IMAP;
    pErrorInfo->dwPort = m_rInetServerInfo.dwPort;
    pErrorInfo->fSSL = m_rInetServerInfo.fSSL;
    pErrorInfo->fTrySicily = m_rInetServerInfo.fTrySicily;
    pErrorInfo->dwFlags = dwFlags;
}



//***************************************************************************
// Function: Fill_MESSAGEINFO
//
// Purpose:
//   This function is no longer largely based on (shamelessly stolen) code
// from MsgIn.Cpp's. As Brett rewrote it to use MIMEOLE. Fingers crossed, kids...
// This function takes a FETCH_CMD_RESULTS_EX struct (which MUST
// have a header or a body) and fills out a MESSAGEINFO structure based on
// the information in the header.
//
// Arguments:
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - contains the results of
//     a FETCH response. This MUST contain either a header or a body.
//   MESSAGEINFO *pMsgInfo [out] - this function fills out the given
//     MESSAGEINFO with the information from the FETCH response. Note that
//     this function zeroes the destination, so the caller need not.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::Fill_MESSAGEINFO(const FETCH_CMD_RESULTS_EX *pFetchResults,
                                    MESSAGEINFO *pMsgInfo)
{
    // Locals
    HRESULT             hr = S_OK;
    LPSTR               lpsz;
    IMimePropertySet   *pPropertySet = NULL;
    IMimeAddressTable  *pAddrTable = NULL;
    ADDRESSPROPS        rAddress;
    IMSGPRIORITY        impPriority;
    PROPVARIANT         rVariant;
    LPSTREAM            lpstmRFC822;

    TraceCall("CIMAPSync::Fill_MESSAGEINFO");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(NULL != pMsgInfo);
    IxpAssert(TRUE == pFetchResults->bUID);

    // Initialize the destination
    ZeroMemory(pMsgInfo, sizeof(MESSAGEINFO));

    // Fill in fields that need no thought
    pMsgInfo->pszAcctId = PszDupA(m_pszAccountID);
    pMsgInfo->pszAcctName = PszDupA(m_szAccountName);

    // Deal with the easy FETCH_CMD_RESULTS_EX fields, first
    if (pFetchResults->bUID)
        pMsgInfo->idMessage = (MESSAGEID)((ULONG_PTR)pFetchResults->dwUID);

    if (pFetchResults->bMsgFlags)
        pMsgInfo->dwFlags = DwConvertIMAPtoARF(pFetchResults->mfMsgFlags);

    if (pFetchResults->bRFC822Size)
        pMsgInfo->cbMessage = pFetchResults->dwRFC822Size;

    if (pFetchResults->bInternalDate)
        pMsgInfo->ftReceived = pFetchResults->ftInternalDate;

    if (pFetchResults->bEnvelope)
    {
        hr= ReadEnvelopeFields(pMsgInfo, pFetchResults);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

    // Now, it's time to parse the header (or partial header, if we only asked for certain fields)
    lpstmRFC822 = (LPSTREAM) pFetchResults->lpFetchCookie2;
    if (NULL == lpstmRFC822)
    {
        if (FALSE == pFetchResults->bEnvelope)
            hr = TraceResult(E_FAIL); // Hmm, no envelope, no header... sounds like failure!

        goto exit;
    }

    hr = MimeOleCreatePropertySet(NULL, &pPropertySet);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = HrRewindStream(lpstmRFC822);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // call IPS::Load on the header, and get the parsed stuff out.
    hr = pPropertySet->Load(lpstmRFC822);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Don't ask for the following basic (non-derived) fields unless we did NOT get an envelope
    if (FALSE == pFetchResults->bEnvelope)
    {
        // Don't bother tracing non-fatal errors, as not all msgs will have all properties
        hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszMessageId = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszSubject = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &lpsz);
        TraceError(hr); // Actually, this is odd
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszFromHeader = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        rVariant.vt = VT_FILETIME;
        hr = pPropertySet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);
        if (SUCCEEDED(hr))
            CopyMemory(&pMsgInfo->ftSent, &rVariant.filetime, sizeof(FILETIME));
    }

    // The following fields are not normally supplied via envelope
    // [PaulHi] 6/10/99
    // !!!Note that the IMAP server will not include these properties in the header download
    // unless they are listed in the request string.  See cszIMAPFetchNewHdrsI4r1 string
    // declared above!!!
    hr = MimeOleGetPropA(pPropertySet, STR_HDR_XMSOESREC, NOFLAGS, &lpsz);
    TraceError(hr); // Actually, this is odd
    if (SUCCEEDED(hr))
    {
        pMsgInfo->pszMSOESRec = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
    }

    hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &lpsz);
    if (SUCCEEDED(hr))
    {
        pMsgInfo->pszReferences = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
    }

    hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_XREF), NOFLAGS, &lpsz);
    if (SUCCEEDED(hr))
    {
        pMsgInfo->pszXref = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
    }

    rVariant.vt = VT_UI4;
    hr = pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
    if (SUCCEEDED(hr))
        // Convert IMSGPRIORITY to ARF_PRI_*
        pMsgInfo->wPriority = (WORD)rVariant.ulVal;

    // Make sure every basic (ie, non-derived) string field has SOMETHING
    if (NULL == pMsgInfo->pszMessageId)
        pMsgInfo->pszMessageId = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszSubject)
        pMsgInfo->pszSubject = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszFromHeader)
        pMsgInfo->pszFromHeader = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszReferences)
        pMsgInfo->pszReferences = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszXref)
        pMsgInfo->pszXref = PszDupA (c_szEmpty);


    // Now that every basic string field is non-NULL, calculate DERIVED str fields
    pMsgInfo->pszNormalSubj = SzNormalizeSubject(pMsgInfo->pszSubject);
    if (NULL == pMsgInfo->pszNormalSubj)
        pMsgInfo->pszNormalSubj = pMsgInfo->pszSubject;

    // Only calculate "To" and "From" if we did NOT get an envelope
    if (FALSE == pFetchResults->bEnvelope)
    {
        // Get an address table
        hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAddrTable);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Split "From" field into a display name and email name
        rAddress.dwProps = IAP_FRIENDLY | IAP_EMAIL;
        hr = pAddrTable->GetSender(&rAddress);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszDisplayFrom = rAddress.pszFriendly;
            pMsgInfo->pszEmailFrom = rAddress.pszEmail;
        }

        // Split "To" field into a display name and email name
        hr = pAddrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszDisplayTo = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }

        hr = pAddrTable->GetFormat(IAT_TO, AFT_DISPLAY_EMAIL, &lpsz);
        if (SUCCEEDED(hr))
        {
            pMsgInfo->pszEmailTo = PszDupA(lpsz);
            SafeMimeOleFree(lpsz);
        }
    }

    // If "Newsgroups" field is present, it supercedes the "To" field
    hr = MimeOleGetPropA(pPropertySet, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &lpsz);
    if (SUCCEEDED(hr))
    {
        SafeMemFree(pMsgInfo->pszDisplayTo); // Free what's already there
        pMsgInfo->pszDisplayTo = PszDupA(lpsz);
        SafeMimeOleFree(lpsz);
        pMsgInfo->dwFlags |= ARF_NEWSMSG;
    }

    // Make sure that all derived fields are non-NULL
    if (NULL == pMsgInfo->pszDisplayFrom)
        pMsgInfo->pszDisplayFrom = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszEmailFrom)
        pMsgInfo->pszEmailFrom = PszDupA(c_szEmpty);

    if (NULL == pMsgInfo->pszDisplayTo)
        pMsgInfo->pszDisplayTo = PszDupA(c_szEmpty);

    // OK, if we get to here, we've decided to live with errors. Suppress errors.
    hr = S_OK;

exit:
    // Cleanup
    SafeRelease(pPropertySet);
    SafeRelease(pAddrTable);

    // Done
    return hr;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::ReadEnvelopeFields(MESSAGEINFO *pMsgInfo,
                                      const FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT     hrResult;
    PROPVARIANT rDecoded;

    // (1) Date
    pMsgInfo->ftSent = pFetchResults->ftENVDate;

    // (2) Subject
    rDecoded.vt = VT_LPSTR;
    if (FAILED(MimeOleDecodeHeader(NULL, pFetchResults->pszENVSubject, &rDecoded, NULL)))
        pMsgInfo->pszSubject = PszDupA(pFetchResults->pszENVSubject);
    else
        pMsgInfo->pszSubject = rDecoded.pszVal;

    if (NULL == pMsgInfo->pszSubject)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // (3) From
    hrResult = ConcatIMAPAddresses(&pMsgInfo->pszDisplayFrom, &pMsgInfo->pszEmailFrom,
        pFetchResults->piaENVFrom);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (4) Sender: IGNORE
    // (5) ReplyTo: IGNORE

    // (6) To
    hrResult = ConcatIMAPAddresses(&pMsgInfo->pszDisplayTo, &pMsgInfo->pszEmailTo,
        pFetchResults->piaENVTo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (7) Cc: IGNORE
    // (8) Bcc: IGNORE
    // (9) In-Reply-To: IGNORE

    // (10) MessageID
    pMsgInfo->pszMessageId = PszDupA(pFetchResults->pszENVMessageID);
    if (NULL == pMsgInfo->pszMessageId)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

exit:
    return hrResult;
} // ReadEnvelopeFields



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::ConcatIMAPAddresses(LPSTR *ppszDisplay, LPSTR *ppszEmailAddr,
                                       IMAPADDR *piaIMAPAddr)
{
    HRESULT     hrResult = S_OK;
    CByteStream bstmDisplay;
    CByteStream bstmEmail;
    BOOL        fPrependDisplaySeparator = FALSE;
    BOOL        fPrependEmailSeparator = FALSE;

    // Initialize output
    if (NULL != ppszDisplay)
        *ppszDisplay = NULL;

    if (NULL != ppszEmailAddr)
        *ppszEmailAddr = NULL;


    // Loop through all IMAP addresses
    while (NULL != piaIMAPAddr)
    {
        // Concatenate current email address to list of email addresses
        // Do email address first to allow substitution of email addr for missing display name
        if (NULL != ppszEmailAddr)
        {
            if (FALSE == fPrependEmailSeparator)
                fPrependEmailSeparator = TRUE;
            else
            {
                hrResult = bstmEmail.Write(c_szSemiColonSpace, 2, NULL);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }

            hrResult = ConstructIMAPEmailAddr(bstmEmail, piaIMAPAddr);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
        } // if (NULL != ppszEmailAddr)

        // Concatenate current display name to list of display names
        if (NULL != ppszDisplay)
        {
            PROPVARIANT rDecoded;
            LPSTR       pszName;
            int         iLen;

            if (FALSE == fPrependDisplaySeparator)
                fPrependDisplaySeparator = TRUE;
            else
            {
                hrResult = bstmDisplay.Write(c_szSemiColonSpace, 2, NULL);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }
            }

            PropVariantInit(&rDecoded);
            rDecoded.vt = VT_LPSTR;
            if (FAILED(MimeOleDecodeHeader(NULL, piaIMAPAddr->pszName, &rDecoded, NULL)))
                pszName = StrDupA(piaIMAPAddr->pszName);
            else
                pszName = rDecoded.pszVal;

            if(FAILED(hrResult = MimeOleUnEscapeStringInPlace(pszName)))
                TraceResult(hrResult);

            iLen = lstrlen(pszName);
            if (0 != iLen)
                hrResult = bstmDisplay.Write(pszName, iLen, NULL);
            else
                // Friendly name is not available! Substitute email address
                hrResult = ConstructIMAPEmailAddr(bstmDisplay, piaIMAPAddr);

            if (rDecoded.pszVal)
                MemFree(rDecoded.pszVal); // Probably should be SafeMimeOleFree, but we also ignore above

            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
        } // if (NULL != ppszDisplay)

        // Advance pointer
        piaIMAPAddr = piaIMAPAddr->pNext;

    } // while


    // Convert stream to buffer for return to caller
    if (NULL != ppszDisplay)
    {
        hrResult = bstmDisplay.HrAcquireStringA(NULL, ppszDisplay, ACQ_DISPLACE);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    }

    if (NULL != ppszEmailAddr)
    {
        hrResult = bstmEmail.HrAcquireStringA(NULL, ppszEmailAddr, ACQ_DISPLACE);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    }

exit:
    return hrResult;
} // ConcatIMAPAddresses



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::ConstructIMAPEmailAddr(CByteStream &bstmOut, IMAPADDR *piaIMAPAddr)
{
    HRESULT hrResult;

    hrResult = bstmOut.Write(piaIMAPAddr->pszMailbox, lstrlen(piaIMAPAddr->pszMailbox), NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = bstmOut.Write(c_szAt, 1, NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = bstmOut.Write(piaIMAPAddr->pszHost, lstrlen(piaIMAPAddr->pszHost), NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_SyncHeader(void)
{
    HRESULT hr = S_OK;
    char    szFetchArgs[200];
    BOOL    fNOOP = TRUE;

    TraceCall("CIMAPSync::_SyncHeader");
    IxpAssert(m_cRef > 0);

    // Look at the flags to determine the next operation
    if (SYNC_FOLDER_NEW_HEADERS & m_dwSyncToDo)
    {
        // Remove this flag, as we are handling it now
        m_dwSyncToDo &= ~(SYNC_FOLDER_NEW_HEADERS);

        // Check if there are any new messages to retrieve
        // Retrieve new headers iff > 0 msgs in this mailbox (Cyrus bug: sending
        // UID FETCH in empty mailbox results in terminated connection)
        // (NSCP v2.0 bug: no EXISTS resp when SELECT issued from selected state)
        if ((m_dwMsgCount > 0 || FALSE == m_fMsgCountValid) &&
            (FALSE == m_fDidFullSync || m_dwNumNewMsgs > 0))
        {
            DWORD dwCapability;

            // No need to send NOOP anymore
            m_dwSyncToDo &= ~(SYNC_FOLDER_NOOP);

            // New messages available! Send FETCH to retrieve new headers
            hr = GetHighestCachedMsgID(m_pFolder, &m_dwHighestCachedUID);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }

            hr = m_pTransport->Capability(&dwCapability);
            if (SUCCEEDED(dwCapability) && (IMAP_CAPABILITY_IMAP4rev1 & dwCapability))
                wnsprintf(szFetchArgs, ARRAYSIZE(szFetchArgs), cszIMAPFetchNewHdrsI4r1, m_dwHighestCachedUID + 1);
            else
                wnsprintf(szFetchArgs, ARRAYSIZE(szFetchArgs), cszIMAPFetchNewHdrsI4, m_dwHighestCachedUID + 1);

            hr = m_pTransport->Fetch(tidFETCH_NEW_HDRS, NULL, this,
                NULL, USE_UIDS, szFetchArgs); // We always use UIDs
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
            else
                ResetStatusCounts();

            // Reset progress indicator variables
            m_dwNumHdrsDLed = 0;
            m_dwNumUnreadDLed = 0;
            m_dwNumHdrsToDL = m_dwNumNewMsgs;
            m_dwNumNewMsgs = 0; // We're handling this now
            m_fNewMail = FALSE;

            m_lSyncFolderRefCount += 1;
            fNOOP = FALSE;
            goto exit; // Limit to one operation at a time, exit function now
        }
    }

    if (SYNC_FOLDER_CACHED_HEADERS & m_dwSyncToDo)
    {
        // Remove this flag, as we are handling it now
        m_dwSyncToDo &= ~(SYNC_FOLDER_CACHED_HEADERS);

        // Check if we have any cached headers, and if we've already done flag update
        if (0 == m_dwHighestCachedUID)
        {
            // Either m_dwHighestCachedUID was never loaded, or it really is zero. Check.
            hr = GetHighestCachedMsgID(m_pFolder, &m_dwHighestCachedUID);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        }

        if (FALSE == m_fDidFullSync && 0 != m_dwHighestCachedUID)
        {
            // No need to send NOOP anymore
            m_dwSyncToDo &= ~(SYNC_FOLDER_NOOP);

            wnsprintf(szFetchArgs, ARRAYSIZE(szFetchArgs), cszIMAPFetchCachedFlags, m_dwHighestCachedUID);
            hr = m_pTransport->Fetch(tidFETCH_CACHED_FLAGS, NULL, this,
                NULL, USE_UIDS, szFetchArgs); // We always use UIDs
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
            else
                ResetStatusCounts();

            m_lSyncFolderRefCount += 1;
            fNOOP = FALSE;
            goto exit; // Limit to one operation at a time, exit function now
        }
    }

    if (SYNC_FOLDER_PURGE_DELETED & m_dwSyncToDo)
    {
        // Remove the purge flag. Also, no need to send NOOP anymore since EXISTS
        // and FETCH responses can be sent during EXPUNGE
        m_dwSyncToDo &= ~(SYNC_FOLDER_PURGE_DELETED | SYNC_FOLDER_NOOP);
        m_dwSyncFolderFlags &= ~(SYNC_FOLDER_PURGE_DELETED); // Not a standing order

        hr = m_pTransport->Expunge(tidEXPUNGE, 0, this);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        else
            ResetStatusCounts();

        fNOOP = FALSE;
        m_lSyncFolderRefCount += 1;
        goto exit; // Limit to one operation at a time, exit function now
    }

    // If we reached this point, ping svr for new mail/cached hdr updates
    // New mail/cached msg updates will be handled like any other unilateral response
    if (SYNC_FOLDER_NOOP & m_dwSyncToDo)
    {
        // Remove these flags, as we are handling it now
        m_dwSyncToDo &= ~(SYNC_FOLDER_NOOP);
        IxpAssert(0 == (m_dwSyncToDo & (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)));

        hr = m_pTransport->Noop(tidNOOP, NULL, this);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        else
            ResetStatusCounts();

        fNOOP = FALSE;
        m_lSyncFolderRefCount += 1;
        goto exit; // Limit to one operation at a time, exit function now
    }

    // Check if we had nothing left to do
    if (fNOOP)
        hr = STORE_S_NOOP;

exit:
    return hr;
} // _SyncHeader



//***************************************************************************
//***************************************************************************
void CIMAPSync::ResetStatusCounts(void)
{
    HRESULT     hrTemp;
    FOLDERINFO  fiFolderInfo;

    // We're about to do a full synchronization, so restore unread counts to
    // pre-STATUS response levels
    hrTemp = m_pStore->GetFolderInfo(m_idSelectedFolder, &fiFolderInfo);
    TraceError(hrTemp);
    if (SUCCEEDED(hrTemp))
    {
        if (0 != fiFolderInfo.dwStatusMsgDelta || 0 != fiFolderInfo.dwStatusUnreadDelta)
        {
            // Make sure that we never cause counts to dip below 0
            if (fiFolderInfo.dwStatusMsgDelta > fiFolderInfo.cMessages)
                fiFolderInfo.dwStatusMsgDelta = fiFolderInfo.cMessages;

            if (fiFolderInfo.dwStatusUnreadDelta > fiFolderInfo.cUnread)
                fiFolderInfo.dwStatusUnreadDelta = fiFolderInfo.cUnread;

            fiFolderInfo.cMessages -= fiFolderInfo.dwStatusMsgDelta;
            fiFolderInfo.cUnread -= fiFolderInfo.dwStatusUnreadDelta;
            fiFolderInfo.dwStatusMsgDelta = 0;
            fiFolderInfo.dwStatusUnreadDelta = 0;

            Assert((LONG)fiFolderInfo.cMessages >= 0);
            Assert((LONG)fiFolderInfo.cUnread >= 0);
            hrTemp = m_pStore->UpdateRecord(&fiFolderInfo);
            TraceError(hrTemp);
        }
        m_pStore->FreeRecord(&fiFolderInfo);
    }
} // ResetStatusCounts



//***************************************************************************
// Function: CheckUIDValidity
//
// Purpose:
//   This function checks the value in m_dwUIDValidity against the
// UIDValidity in the message cache for this folder. If the two match, no
// action is taken. Otherwise, the message cache is emptied.
//***************************************************************************
HRESULT CIMAPSync::CheckUIDValidity(void)
{
    FOLDERUSERDATA  fudUserData;
    HRESULT         hr;

    TraceCall("CIMAPSync::CheckUIDValidity");
    IxpAssert(m_cRef > 0);

    // Load in UIDValidity of cache file
    hr = m_pFolder->GetUserData(&fudUserData, sizeof(fudUserData));
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Is our current cache file invalid?
    if (m_dwUIDValidity == fudUserData.dwUIDValidity)
        goto exit; // We're the same as ever

    // If we reached this point, the UIDValidity has changed
    // Take out the cache
    hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
    if (FAILED(hr))
    {
        TraceError(hr);
        goto exit;
    }

    // Write the new UIDValidity to the cache
    fudUserData.dwUIDValidity = m_dwUIDValidity;
    hr = m_pFolder->SetUserData(&fudUserData, sizeof(fudUserData));
    if (FAILED(hr))
    {
        TraceError(hr);
        goto exit;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: SyncDeletedMessages
//
// Purpose:
//   This function is called after the message cache is filled with all of
// the headers on the IMAP server (for this folder). This function deletes
// all messages from the message cache which no longer exist on the server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::SyncDeletedMessages(void)
{
    HRESULT hr;
    DWORD      *pdwMsgSeqNumToUIDArray = NULL;
    DWORD      *pdwCurrentServerUID;
    DWORD      *pdwLastServerUID;
    ULONG_PTR   ulCurrentCachedUID;
    DWORD       dwHighestMsgSeqNum;
    HROWSET     hRowSet = HROWSET_INVALID;
    HLOCK       hLockNotify=NULL;
    MESSAGEINFO miMsgInfo = {0};

    TraceCall("CIMAPSync::SyncDeletedMessages");
    IxpAssert(m_cRef > 0);

    // First, check for case where there are NO messages on server
    hr = m_pTransport->GetMsgSeqNumToUIDArray(&pdwMsgSeqNumToUIDArray, &dwHighestMsgSeqNum);
    if (FAILED(hr))
    {
        TraceResult(hr);
        pdwMsgSeqNumToUIDArray = NULL; // Just in case
        goto exit;
    }

    if (0 == dwHighestMsgSeqNum)
    {
        // No messages on server! Blow away the entire message cache
        hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
        TraceError(hr);
        goto exit;
    }

    // If we've reached this point, there are messages on the server and thus
    // we must delete messages from the cache which are no longer on server
    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowSet);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = m_pFolder->QueryRowset(hRowSet, 1, (void **)&miMsgInfo, NULL);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }
    else if (S_OK != hr)
    {
        // There are 0 messages in cache. Our work here is done
        IxpAssert(S_FALSE == hr);
        goto exit;
    }

    // This forces all notifications to be queued (this is good since you do segmented deletes)
    m_pFolder->LockNotify(0, &hLockNotify);

    // Step through each UID in the cache and delete those which do not exist
    // in our Msg Seq Num -> UID table (which holds all UIDs currently on server)
    pdwCurrentServerUID = pdwMsgSeqNumToUIDArray;
    pdwLastServerUID = pdwMsgSeqNumToUIDArray + dwHighestMsgSeqNum - 1;
    while (S_OK == hr)
    {
        ulCurrentCachedUID = (ULONG_PTR) miMsgInfo.idMessage;

        // Advance pdwCurrentServerUID so its value is always >= ulCurrentCachedUID
        while (pdwCurrentServerUID < pdwLastServerUID &&
               ulCurrentCachedUID > *pdwCurrentServerUID)
            pdwCurrentServerUID += 1;

        // If *pdwCurrentServerUID != ulCurrentCachedUID, the message in our
        // cache has been deleted from the server
        if (ulCurrentCachedUID != *pdwCurrentServerUID)
        {
            MESSAGEIDLIST   midList;
            MESSAGEID       mid;

            // This message in our cache has been deleted from the server. Nuke it.
            // $REVIEW: Would probably be more efficient if we constructed MESSAGEID list
            // and deleted whole thing at once, but ask me again when I have time
            mid = (MESSAGEID) ulCurrentCachedUID;
            midList.cAllocated = 0;
            midList.cMsgs = 1;
            midList.prgidMsg = &mid;

            hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &midList, NULL, NULL);
            TraceError(hr); // Record error but otherwise continue
        }

        // Advance current cached UID
        m_pFolder->FreeRecord(&miMsgInfo);
        hr = m_pFolder->QueryRowset(hRowSet, 1, (void **)&miMsgInfo, NULL);
    }
    IxpAssert(pdwCurrentServerUID <= pdwLastServerUID);

exit:
    m_pFolder->UnlockNotify(&hLockNotify);

    if (HROWSET_INVALID != hRowSet)
    {
        HRESULT hrTemp;

        // Record but otherwise ignore error
        hrTemp = m_pFolder->CloseRowset(&hRowSet);
        TraceError(hrTemp);
    }

    if (NULL != pdwMsgSeqNumToUIDArray)
        MemFree(pdwMsgSeqNumToUIDArray);

    return hr;
}



#define CMAX_DELETE_SEARCH_BLOCK 50

HRESULT CIMAPSync::DeleteHashedFolders(IHashTable *pHash)
{
    ULONG   cFound=0;
    LPVOID  *rgpv;

    TraceCall("CIMAPSync::DeleteHashedFolders");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pHash);

    pHash->Reset();
    while (SUCCEEDED(pHash->Next(CMAX_DELETE_SEARCH_BLOCK, &rgpv, &cFound)))
    {
        while(cFound--)
        {
            HRESULT hrTemp;

            hrTemp = DeleteFolderFromCache((FOLDERID)rgpv[cFound], fNON_RECURSIVE);
            TraceError(hrTemp);
        }

        SafeMemFree(rgpv);
    }
    return S_OK;
}



//***************************************************************************
// Function: DeleteFolderFromCache
//
// Purpose:
//   This function attempts to delete the specified folder from the
// folder cache. If the folder is a leaf folder, it may be deleted immediately.
// If the folder is an internal node, this function marks the folder for
// deletion, and deletes the internal node when it no longer has children.
// Regardless of whether the folder node is removed from the folder cache,
// the message cache for the given folder is blown away.
//
// Arguments:
//   FOLDERID idFolder [in] - the folder which you want to delete.
//   BOOL fRecursive [in] - TRUE if we should delete all child folders of the
//     victim. If FALSE, the victim is deleted only if it has no children.
//     Otherwise the victim is marked as \NoSelect and non-existent.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::DeleteFolderFromCache(FOLDERID idFolder, BOOL fRecursive)
{
    HRESULT     hr;
    HRESULT     hrTemp;
    FOLDERINFO  fiFolderInfo;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::DeleteFolderFromCache");

    // Check args and codify assumptions
    IxpAssert(m_cRef > 0);
    IxpAssert(FOLDERID_INVALID != idFolder);

    // Get some info about the node
    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hr))
    {
        if (DB_E_NOTFOUND == hr)
            hr = S_OK; // Deletion target already gone, don't confuse user out w/ err msgs
        else
            TraceResult(hr);

        goto exit;
    }

    fFreeInfo = TRUE;

    // OK, now we can get rid of the foldercache node based on the following rules:
    // 1) Non-listing of an interior node must not remove its inferiors: the interior node
    //    just becomes \NoSelect for us, and we delete it once it loses its children.
    // 2) Deletion of a leaf node removes the node and any deleted parents. (If a
    //    parent is deleted, we keep it around until it has no kids.)
    // 3) fRecursive TRUE means take no prisoners.

    // Check if we need to recurse on the children
    if (fRecursive)
    {
        IEnumerateFolders  *pEnum;
        FOLDERINFO          fiChildInfo={0};

        if (SUCCEEDED(m_pStore->EnumChildren(idFolder, fUNSUBSCRIBE, &pEnum)))
        {
            while (S_OK == pEnum->Next(1, &fiChildInfo, NULL))
            {
                hr = DeleteFolderFromCache(fiChildInfo.idFolder, fRecursive);
                if (FAILED(hr))
                {
                    TraceResult(hr);
                    break;
                }

                m_pStore->FreeRecord(&fiChildInfo);
            }

            m_pStore->FreeRecord(&fiChildInfo);

            pEnum->Release();

            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }

            // Re-load the current folder node
            m_pStore->FreeRecord(&fiFolderInfo);
            hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        }

    }

    // Is this an interior node?
    if (FOLDER_HASCHILDREN & fiFolderInfo.dwFlags)
    {
        IMessageFolder *pFolder;

        // It's an interior node. Awwwww, no nukes... make it \NoSelect,
        // and mark it for deletion as soon as it loses its kids
        fiFolderInfo.dwFlags |= FOLDER_NOSELECT | FOLDER_NONEXISTENT;
        fiFolderInfo.cMessages = 0;
        fiFolderInfo.cUnread = 0;
        fiFolderInfo.dwStatusMsgDelta = 0;
        fiFolderInfo.dwStatusUnreadDelta = 0;
        hr = m_pStore->UpdateRecord(&fiFolderInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Plow the associated message cache
        hrTemp = m_pStore->OpenFolder(fiFolderInfo.idFolder, NULL, NOFLAGS, &pFolder);
        TraceError(hrTemp);
        if (SUCCEEDED(hrTemp))
        {
            hrTemp = pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
            TraceError(hrTemp);
            pFolder->Release();
        }
    }
    else
    {
        // It's a leaf node. Nuke it, AND its family. DeleteLeafFolder fills in
        // fiFolderInfo.idParent for use in RecalculateParentFlags call (no longer called)
        fiFolderInfo.idParent = idFolder;
        hr = DeleteLeafFolder(&fiFolderInfo.idParent);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hr;
}



//***************************************************************************
// Function: DeleteLeafFolder
//
// Purpose:
//   This function is used by DeleteFolderFromCache to delete a leaf folder.
// More than just a leaf blower, this function also checks if the parents of
// the given leaf node can be deleted.
//
// The reason we keep folder nodes around even though they haven't been
// listed is that it is possible on some IMAP servers to create folders whose
// parents aren't listed. For instance, "CREATE foo/bar" might not create foo,
// but "foo/bar" will be there. There has to be SOME path to that node, so
// when foo/bar goes, you can bet that we'll want to get rid of our "foo".
//
// Arguments:
//   FOLDERID *pidCurrent [in/out] - pass in the HFOLDER identifying the leaf
//     node to delete. The function returns a pointer to the closest existing
//     ancestor of the deleted node (several parent nodes may be deleted).
//
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::DeleteLeafFolder(FOLDERID *pidCurrent)
{
    HRESULT     hr;
    BOOL        fFirstFolder;
    FOLDERINFO  fiFolderInfo;

    // Check args and codify assumptions
    TraceCall("CIMAPSync::DeleteLeafFolder");
    IxpAssert(m_cRef > 0);

    // Initialize variables
    fFirstFolder = TRUE;

    // Loop until the folder is not a deletion candidate
    while (FOLDERID_INVALID != *pidCurrent && FOLDERID_ROOT != *pidCurrent &&
           m_idIMAPServer != *pidCurrent)
    {

        // Get the dirt on this node
        hr = m_pStore->GetFolderInfo(*pidCurrent, &fiFolderInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // Check if this folder is a deletion candidate. To be a deletion candidate,
        // it must either be the first folder we see (we assume the caller gave us a
        // leaf node to delete), or marked for deletion AND have no children left.
        if (FALSE == fFirstFolder && (0 == (FOLDER_NONEXISTENT & fiFolderInfo.dwFlags) ||
            (FOLDER_HASCHILDREN & fiFolderInfo.dwFlags)))
            {
            m_pStore->FreeRecord(&fiFolderInfo);
            break;
            }

        // We've got some deletion to do
        // Unlink the leaf folder node from its parent folder
        AssertSz(0 == (FOLDER_HASCHILDREN & fiFolderInfo.dwFlags),
            "Hey, what's the idea, orphaning child nodes?");
        hr = m_pStore->DeleteFolder(fiFolderInfo.idFolder,
            DELETE_FOLDER_NOTRASHCAN | DELETE_FOLDER_DELETESPECIAL, NOSTORECALLBACK);
        if (FAILED(hr))
        {
            m_pStore->FreeRecord(&fiFolderInfo);
            TraceResult(hr);
            goto exit;
        }

        // Next stop: your mama
        *pidCurrent = fiFolderInfo.idParent;
        m_pStore->FreeRecord(&fiFolderInfo);
        fFirstFolder = FALSE;
    }

exit:
    return hr;
}



//***************************************************************************
// Function: AddFolderToCache
//
// Purpose:
//   This function saves the given folder (fresh from
// _OnMailBoxList) to the folder cache. This code used to live
// in _OnMailBoxList but, that function got too big after I
// added hierarchy determination code.
//
// Arguments:
//   LPSTR pszMailboxName [in] - name of the mailbox as returned by LIST/LSUB
//   IMAP_MBOXFLAGS [in] - flags of mailbox as returned by LIST/LSUB
//   char cHierarchyChar [in] - hierarchy char returned by LIST/LSUB
//   DWORD dwAFTCFlags [in] - Set the following flags:
//     AFTC_SUBSCRIBED if folder is subscribed (eg, returned via LSUB)
//     AFTC_KEEPCHILDRENKNOWN to suppress removal of FOLDER_CHILDRENKNOWN
//     AFTC_NOTSUBSCRIBED if folder is no longer subscribed (NEVER set via
//       LIST, but instead at end of successful UNSUBSCRIBE command)
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::AddFolderToCache(LPSTR pszMailboxName,
                                    IMAP_MBOXFLAGS imfMboxFlags,
                                    char cHierarchyChar, DWORD dwAFTCFlags,
                                    FOLDERID *pFolderID, SPECIALFOLDER sfType)
{
    HRESULT             hr;
    BOOL                bResult;
    ADD_HIER_FLDR_OPTIONS  ahfo;
    BOOL                fValidPrefix;

    TraceCall("CIMAPSync::AddFolderToCache");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pszMailboxName);
    IxpAssert(NULL != pFolderID);

    // Create or find a folder node for this folder name
    // Fill in foldercache props. INBOX is always treated as a subscribed folder
    // Add new IMAP mbox flags, remove all IMAP mbox flags that we're not adding
    ahfo.sfType = sfType;
    ahfo.ffFlagAdd = DwConvertIMAPMboxToFOLDER(imfMboxFlags);
    ahfo.ffFlagRemove = DwConvertIMAPMboxToFOLDER(IMAP_MBOX_ALLFLAGS) & ~(ahfo.ffFlagAdd);
    ahfo.ffFlagRemove |= FOLDER_NONEXISTENT; // Always remove: folder must exist if we listed it
    ahfo.ffFlagRemove |= FOLDER_HIDDEN; // If we listed the folder, we no longer need to hide it
    ahfo.ffFlagRemove |= FOLDER_CREATEONDEMAND; // If we listed the folder, we no longer need to create it

    // Figure out which flags to add and remove
    if (ISFLAGSET(dwAFTCFlags, AFTC_SUBSCRIBED) || FOLDER_INBOX == sfType)
        ahfo.ffFlagAdd |= FOLDER_SUBSCRIBED;    // This folder is subscribed
    else if (ISFLAGSET(dwAFTCFlags, AFTC_NOTSUBSCRIBED))
        ahfo.ffFlagRemove |= FOLDER_SUBSCRIBED; // This folder is no longer subscribed

    if (AFTC_NOTRANSLATION & dwAFTCFlags)
        ahfo.ffFlagAdd |= FOLDER_NOTRANSLATEUTF7;
    else
        ahfo.ffFlagRemove |= FOLDER_NOTRANSLATEUTF7;

    if (IMAP_MBOX_NOINFERIORS & imfMboxFlags)
        // NoInferiors folders cannot have children, so we never have to ask
        ahfo.ffFlagAdd |= FOLDER_CHILDRENKNOWN;
    else if (ISFLAGCLEAR(dwAFTCFlags, AFTC_KEEPCHILDRENKNOWN))
        // Remove FOLDER_CHILDRENKNOWN from this fldr so we ask for its chldrn when it's expanded
        ahfo.ffFlagRemove |= FOLDER_CHILDRENKNOWN;

    hr = FindHierarchicalFolderName(pszMailboxName, cHierarchyChar,
        pFolderID, &ahfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    AssertSz(FOLDERID_INVALID != *pFolderID, "Hey, what does it take to get a folder handle?");

exit:
    return hr;
}



//***************************************************************************
// Function: RemovePrefixFromPath
//
// Purpose:
//   This function removes the prefix from the given mailbox path. If the
// given path is a special folder, this function removes all of the special
// folder path prefix except for the leaf node (eg, "foo/Sent Items/bar"
// becomes "Sent Items/bar").
//
// Arguments:
//   LPSTR pszPrefix [in] - the prefix to strip from pszMailboxName. Note
//     that this may not necessarily be the prefix stripped from pszMailboxName,
//     if we match a special folder path.
//   LPSTR pszMailboxName [in] - the full path to the mailbox, incl prefix
//   char cHierarchyChar [in] - used to interpret pszMailboxName.
//   LPBOOL pfValidPrefix [out] - returns TRUE if this mailbox name has a
//     valid prefix, FALSE otherwise. Pass NULL if not interested.
//   SPECIALFOLDER *psfType [out] - returns SPECIALFOLDER (eg, FOLDER_NOTSPECIAL,
//     FOLDER_INBOX) of folder. Pass NULL if not interested.
//
// Returns:
//   LPSTR pointing past the prefix and hierarchy character.
//***************************************************************************
LPSTR CIMAPSync::RemovePrefixFromPath(LPSTR pszPrefix, LPSTR pszMailboxName,
                                      char cHierarchyChar, LPBOOL pfValidPrefix,
                                      SPECIALFOLDER *psfType)
{
    LPSTR           pszSpecial = NULL;
    LPSTR           pszRFP = NULL;
    BOOL            fValidPrefix = FALSE;
    SPECIALFOLDER   sfType;

    TraceCall("CIMAPSync::RemovePrefixFromPath");
    IxpAssert(INVALID_HIERARCHY_CHAR != cHierarchyChar);

    // Check for special folder path prefixes
    pszSpecial = ImapUtil_GetSpecialFolderType(m_pszAccountID, pszMailboxName,
        cHierarchyChar, pszPrefix, &sfType);
    if (NULL != pszSpecial)
        fValidPrefix = TRUE;


    // If this is a special folder, no need to check for root folder prefix
    if (FOLDER_NOTSPECIAL != sfType)
    {
        IxpAssert(NULL != pszSpecial);
        pszMailboxName = pszSpecial;
        goto exit;
    }

    // Check for the root folder prefix
    if ('\0' != pszPrefix[0] && '\0' != cHierarchyChar)
    {
        int iResult, iPrefixLength;

        // Do case-INSENSITIVE compare (IE5 bug #59121). If we ask for Inbox/* we must be
        // able to handle receipt of INBOX/*. Don't worry about case-sensitive servers since
        // they will never return an RFP of different case than the one we specified
        iPrefixLength = lstrlen(pszPrefix);
        iResult = StrCmpNI(pszMailboxName, pszPrefix, iPrefixLength);
        if (0 == iResult)
        {
            // Prefix name found at front of this mailbox name! Remove it iff
            // it is followed immediately by hierarchy character
            if (cHierarchyChar == pszMailboxName[iPrefixLength])
            {
                pszRFP = pszMailboxName + iPrefixLength + 1; // Point past the hierarchy char
                fValidPrefix = TRUE;
            }
            else if ('\0' == pszMailboxName[iPrefixLength])
            {
                pszRFP = pszMailboxName + iPrefixLength;
                fValidPrefix = TRUE;
            }
        }
    }
    else
        fValidPrefix = TRUE;


    // We basically want to return the shortest mailbox name. For instance, in choosing
    // between "INBOX.foo" and "foo", we should choose "foo"
    IxpAssert(pszMailboxName > NULL && pszRFP >= NULL && pszSpecial >= NULL);
    if (NULL != pszRFP || NULL != pszSpecial)
    {
        IxpAssert(pszRFP >= pszMailboxName || pszSpecial >= pszMailboxName);
        pszMailboxName = max(pszRFP, pszSpecial);
    }

exit:
    if (NULL != pfValidPrefix)
        *pfValidPrefix = fValidPrefix;

    if (NULL != psfType)
        *psfType = sfType;

    return pszMailboxName;
}



//***************************************************************************
// Function: FindHierarchicalFolderName
//
// Purpose:
//   This function takes a mailbox name as returned by LIST/LSUB and
// determines whether the given mailbox already exists in the folder cache.
// If so, a handle to the folder is returned. If not, and the fCreate argument
// is TRUE, then the mailbox and any intermediate nodes are created, and a
// handle to the mailbox (leaf node) is returned.
//
// Arguments:
//   LPSTR lpszFolderPath [in] - the name of the mailbox as returned by
//     a LIST or LSUB response. This should NOT include the prefix!
//   char cHierarchyChar [in] - the hierarchy character used in
//     lpszFolderPath. Used to determine parenthood.
//   FOLDERID *pidTarget [out] - if the function is successful, a handle
//     to the folder is returned here.
//   ADD_HIER_FLDR_OPTIONS pahfoCreateInfo [in] - set to NULL if this function
//     should find the given lpszFolderPath, but NOT create the folder. Pass
//     in a ptr to a ADD_HIER_FLDR_OPTIONS structure if the folder should be
//     created. pahfoCreateInfo defines the dwImapFlags and sftype to use
//     if the folder has to be created.
//
// Returns:
//   HRESULT indicating success or failure. If successful, a handle to the
// desired folder is returned in the pidTarget parameter. There are two
// possible success results:
//     S_OK - found the folder, did not have to create
//     S_CREATED - folder was successfully created
//***************************************************************************
HRESULT CIMAPSync::FindHierarchicalFolderName(LPSTR lpszFolderPath,
                                              char cHierarchyChar,
                                              FOLDERID *pidTarget,
                                              ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo)
{
    char       *pszCurrentFldrName;
    FOLDERID    idCurrent, idPrev;
    HRESULT     hr;
    LPSTR       pszTok;
    LPSTR       pszIHateStrTok = NULL;
    char        szHierarchyChar[2];

    TraceCall("CIMAPSync::FindHierarchicalFolderName");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszFolderPath);
    IxpAssert(NULL != pidTarget);

    // Initialize variables
    *pidTarget = FOLDERID_INVALID;
    hr = S_OK;
    idPrev = FOLDERID_INVALID;
    idCurrent = m_idIMAPServer;
    szHierarchyChar[0] = cHierarchyChar;
    szHierarchyChar[1] = '\0';

#ifdef DEBUG
    // Make sure this fn is never called with a prefix (DEBUG-ONLY)
    // Note that false alarm is possible, eg, RFP=foo and folder="foo/foo/bar".
    BOOL    fValidPrefix;
    LPSTR   pszPostPrefix;

    pszPostPrefix = RemovePrefixFromPath(m_szRootFolderPrefix, lpszFolderPath,
        cHierarchyChar, &fValidPrefix, NULL);
    AssertSz(FALSE == fValidPrefix || pszPostPrefix == lpszFolderPath,
        "Make sure you've removed the prefix before calling this fn!");
#endif // DEBUG

    // Initialize pszCurrentFldrName to point to name of first-level mailbox node
    // $REVIEW: We now need to remove the reference portion of the LIST/LSUB cmd
    // from the mailbox name!
    pszIHateStrTok = StringDup(lpszFolderPath);
    pszTok = pszIHateStrTok;
    pszCurrentFldrName = StrTokEx(&pszTok, szHierarchyChar);

    // Loop through mailbox node names until we hit the leaf node
    while (NULL != pszCurrentFldrName)
    {
        LPSTR pszNextFldrName;

        // Pre-load the NEXT folder node so we know when we are at the leaf node
        pszNextFldrName = StrTokEx(&pszTok, szHierarchyChar);

        // Look for the current folder name
        idPrev = idCurrent;
        hr = GetFolderIdFromName(m_pStore, pszCurrentFldrName, idCurrent, &idCurrent);
        IxpAssert(SUCCEEDED(hr) || FOLDERID_INVALID == idCurrent);

        if (NULL == pahfoCreateInfo)
        {
            if (FOLDERID_INVALID == idCurrent)
                break; // Fldr doesn't exist and user doesn't want to create it
        }
        else
        {
            // Create desired folder, including intermediate nodes
            hr = CreateFolderNode(idPrev, &idCurrent, pszCurrentFldrName,
                pszNextFldrName, cHierarchyChar, pahfoCreateInfo);
            if (FAILED(hr))
                break;
        }

        // Advance to the next folder node name
        pszCurrentFldrName = pszNextFldrName;
    }


    // Return results
    if (SUCCEEDED(hr) && FOLDERID_INVALID != idCurrent)
    {
        *pidTarget = idCurrent;
    }
    else
    {
        IxpAssert(FOLDERID_INVALID == *pidTarget); // We set this at start of fn
        if (SUCCEEDED(hr))
            hr = DB_E_NOTFOUND; // Can't return success
    }

    SafeMemFree(pszIHateStrTok);
    return hr;
}



//***************************************************************************
// Function: CreateFolderNode
//
// Purpose:
//   This function is called when creating a new folder in the foldercache.
// It is called for every node from the root folder and the new folder.
// This function is responsible for creating the terminal node and any
// intermediate nodes. If these nodes already exist, this function is
// responsible for adjusting the FLDR_* flags to reflect the new folder
// that is about to be added.
//
// Arguments:
//   FOLDERID idPrev [in] - FOLDERID to parent of current node.
//   FOLDERID *pidCurrent [in/out] - FOLDERID to current node. If current node
//     exists, this is a valid FOLDERID. If the current node must be created,
//     the value here is FOLDERID_INVALID. In this case, the FOLDERID of the
//     created node is returned here.
//   LPSTR pszCurrentFldrName [in] - the name of the current folder node.
//   LPSTR pszNextFldrName [in] - the name of the next folder node. This is
//     NULL if the current node is the terminal node.
//   char cHierarchyChar [in] - hierarchy character for this folder path.
//     Used to save FLDINFO::bHierarchy.
//   ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo [in] - information used to create
//     the terminal folder node and update all of its parent nodes that
//     already exist.
//
// Returns:
//   HRESULT indicating success or failure. S_CREATED means a folder node
// was created.
//***************************************************************************
HRESULT CIMAPSync::CreateFolderNode(FOLDERID idPrev, FOLDERID *pidCurrent,
                                    LPSTR pszCurrentFldrName,
                                    LPSTR pszNextFldrName, char cHierarchyChar,
                                    ADD_HIER_FLDR_OPTIONS *pahfoCreateInfo)
{
    HRESULT     hr = S_OK;
    FOLDERINFO  fiFolderInfo;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::CreateFolderNode");
    IxpAssert(NULL != pahfoCreateInfo);
    IxpAssert(0 == (pahfoCreateInfo->ffFlagAdd & pahfoCreateInfo->ffFlagRemove));

    // If current folder name not found, we have to create it
    if (FOLDERID_INVALID == *pidCurrent)
    {
        // Initialize
        ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));

        // FIRST: Add folder to folder cache
        // Fill out a folderinfo structure (just use it as a scratchpad)
        fiFolderInfo.idParent = idPrev;
        fiFolderInfo.pszName = pszCurrentFldrName;
        fiFolderInfo.bHierarchy = cHierarchyChar;

        // If this is the last folder node name (ie, leaf node), use the
        // IMAP flags returned via the LIST/LSUB, and use the supplied
        // special folder type

        if (NULL == pszNextFldrName)
        {
            fiFolderInfo.tySpecial = pahfoCreateInfo->sfType;
            fiFolderInfo.dwFlags |= pahfoCreateInfo->ffFlagAdd;
            fiFolderInfo.dwFlags &= ~(pahfoCreateInfo->ffFlagRemove);

            if (fiFolderInfo.tySpecial == FOLDER_INBOX)
                fiFolderInfo.dwFlags |= FOLDER_DOWNLOADALL;
        }
        else
        {
            // Otherwise, here are the defaults
            // Non-listed folders are \NoSelect by default, and candidates for deletion
            fiFolderInfo.dwFlags = FOLDER_NOSELECT | FOLDER_NONEXISTENT;
            fiFolderInfo.tySpecial = FOLDER_NOTSPECIAL;
        }

        // Add folder to folder cache
        hr = m_pStore->CreateFolder(NOFLAGS, &fiFolderInfo, NULL);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        *pidCurrent = fiFolderInfo.idFolder;
        hr = S_CREATED; // Tell the user we created this folder
    }
    else if (NULL == pszNextFldrName)
    {
        DWORD dwFlagsChanged = 0;
        BOOL  fChanged = FALSE;

        // Folder exists, check that its flags are correct
        hr = m_pStore->GetFolderInfo(*pidCurrent, &fiFolderInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        fFreeInfo = TRUE;
        if (fiFolderInfo.bHierarchy != cHierarchyChar)
        {
            AssertSz(INVALID_HIERARCHY_CHAR == (char) fiFolderInfo.bHierarchy, "What's YOUR excuse?");
            fiFolderInfo.bHierarchy = cHierarchyChar;
            fChanged = TRUE;
        }

        if (NULL == pszNextFldrName && (fiFolderInfo.tySpecial != pahfoCreateInfo->sfType ||
            (fiFolderInfo.dwFlags & pahfoCreateInfo->ffFlagAdd) != pahfoCreateInfo->ffFlagAdd ||
            (fiFolderInfo.dwFlags & pahfoCreateInfo->ffFlagRemove) != 0))
        {
            DWORD dwFlagAddChange;
            DWORD dwFlagRemoveChange;

            // The terminal folder node exists, set everything given via pahfoCreateInfo
            // Check if anything changed, first

            if (pahfoCreateInfo->sfType == FOLDER_INBOX &&
                fiFolderInfo.tySpecial != pahfoCreateInfo->sfType)
                fiFolderInfo.dwFlags |= FOLDER_DOWNLOADALL;

            fiFolderInfo.tySpecial = pahfoCreateInfo->sfType;

            // Figure out which flags changed so we know if we need to recalculate parents
            dwFlagAddChange = (fiFolderInfo.dwFlags & pahfoCreateInfo->ffFlagAdd) ^
                pahfoCreateInfo->ffFlagAdd;
            dwFlagRemoveChange = (~(fiFolderInfo.dwFlags) & pahfoCreateInfo->ffFlagRemove) ^
                pahfoCreateInfo->ffFlagRemove;
            dwFlagsChanged = dwFlagAddChange | dwFlagRemoveChange;

            fiFolderInfo.dwFlags |= pahfoCreateInfo->ffFlagAdd;
            fiFolderInfo.dwFlags &= ~(pahfoCreateInfo->ffFlagRemove);

            fChanged = TRUE;
        }

        // Set the folder properties
        if (fChanged)
        {
            hr = m_pStore->UpdateRecord(&fiFolderInfo);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        }
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hr;
}


//***************************************************************************
// Function: SetTranslationMode
//
// Purpose:
//   This function enables or disables mailbox translation in IIMAPTransport2,
// depending on whether the FOLDER_NOTRANSLATEUTF7 flags is set for this folder.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     S_OK - mailbox translation has been successfully enabled.
//     S_FALSE - mailbox translation has been successfully disabled.
//***************************************************************************
HRESULT CIMAPSync::SetTranslationMode(FOLDERID idFolderID)
{
    HRESULT     hrResult = S_OK;
    FOLDERINFO  fiFolderInfo = {0};
    DWORD       dwTranslateFlags;
    BOOL        fTranslate = TRUE;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::SetTranslationMode");

    // Check for FOLDERID_INVALID (we get this during folder lists)
    // If FOLDERID_INVALID, assume we want to translate everything: leave fiFolderInfo at zero
    if (FOLDERID_INVALID != idFolderID)
    {
        hrResult = m_pStore->GetFolderInfo(idFolderID, &fiFolderInfo);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        fFreeInfo = TRUE;
    }
    else
    {
        Assert(0 == fiFolderInfo.dwFlags);
    }

    fTranslate = TRUE;
    dwTranslateFlags = IMAP_MBOXXLATE_DEFAULT | IMAP_MBOXXLATE_VERBATIMOK | IMAP_MBOXXLATE_RETAINCP;
    if (fiFolderInfo.dwFlags & FOLDER_NOTRANSLATEUTF7)
    {
        fTranslate = FALSE;
        dwTranslateFlags |= IMAP_MBOXXLATE_DISABLE;
        dwTranslateFlags &= ~(IMAP_MBOXXLATE_DEFAULT);
    }

    hrResult = m_pTransport->SetDefaultCP(dwTranslateFlags, 0);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (SUCCEEDED(hrResult))
        hrResult = (fTranslate ? S_OK : S_FALSE);

    return hrResult;
} // SetTranslationMode



//***************************************************************************
//***************************************************************************
BOOL CIMAPSync::isUSASCIIOnly(LPCSTR pszFolderName)
{
    LPCSTR  psz;
    BOOL    fUSASCII = TRUE;

    psz = pszFolderName;
    while ('\0' != *psz)
    {
        if (0 != (*psz & 0x80))
        {
            fUSASCII = FALSE;
            break;
        }

        psz += 1;
    }

    return fUSASCII;
} // isUSASCIIOnly



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::CheckFolderNameValidity(LPCSTR pszName)
{
    HRESULT hrResult = S_OK;

    if (NULL == pszName || '\0' == *pszName)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Figure out what our root hierarchy character is: assume that server does not
    // support multiple hierarchy characters
    if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
    {
        hrResult = LoadSaveRootHierarchyChar(fLOAD_HC);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            hrResult = S_OK; // We can't say if this is valid or not, so just assume it is
            goto exit;
        }
    }

    if ('\0' == m_cRootHierarchyChar || INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
        goto exit; // Anything goes!

    while ('\0' != *pszName)
    {
        // No hierarchy characters are allowed in the folder name, except at the very end
        if (m_cRootHierarchyChar == *pszName && '\0' != *(pszName + 1))
        {
            // Figure out which HRESULT to use (we need to bring up the correct text)
            switch (m_cRootHierarchyChar)
            {
                case '/':
                    hrResult = STORE_E_IMAP_HC_NOSLASH;
                    break;

                case '\\':
                    hrResult = STORE_E_IMAP_HC_NOBACKSLASH;
                    break;

                case '.':
                    hrResult = STORE_E_IMAP_HC_NODOT;
                    break;

                default:
                    hrResult = STORE_E_IMAP_HC_NOHC;
                    break;
            }
            TraceResult(hrResult);
            goto exit;
        }

        // Advance pointer
        pszName += 1;
    }

exit:
    return hrResult;
}



//***************************************************************************
// Function: RenameFolderHelper
//
// Purpose:
//   This function is called by RenameFolder. This function is responsible
// for issuing the RENAME command for the folder which is to be renamed.
// If the folder to be renamed does not actually exist (eg, Cyrus server),
// this function recurses on the child folders until a real folder is found.
//
// Arguments:
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::RenameFolderHelper(FOLDERID idFolder,
                                      LPSTR pszFolderPath,
                                      char cHierarchyChar,
                                      LPSTR pszNewFolderPath)
{
    HRESULT             hr;
    CRenameFolderInfo  *pRenameInfo = NULL;
    FOLDERINFO          fiFolderInfo;
    IEnumerateFolders  *pFldrEnum = NULL;
    BOOL                fFreeInfo = FALSE;

    TraceCall("CIMAPSync::RenameFolderHelper");
    IxpAssert(m_cRef > 0);

    // Check if the folder actually exists on the IMAP server
    hr = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // If current folder doesn't exist, recurse rename cmd on child folders
    fFreeInfo = TRUE;
    if (fiFolderInfo.dwFlags & FOLDER_NONEXISTENT) {
        FOLDERINFO  fiChildFldrInfo;

        // Perform rename on folder nodes which EXIST: recurse through children
        hr = m_pStore->EnumChildren(idFolder, fUNSUBSCRIBE, &pFldrEnum);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        hr = pFldrEnum->Next(1, &fiChildFldrInfo, NULL);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        while (S_OK == hr)
        {
            LPSTR   pszOldPath, pszNewPath;
            DWORD   dwLeafFolderLen, dwFolderPathLen, dwNewFolderPathLen;
            DWORD   cchOldPath, cchNewPath;
            BOOL    fResult;
            CHAR    szHierarchyStr[2];

            szHierarchyStr[0] = cHierarchyChar;
            szHierarchyStr[1] = 0;

            // Calculate string sizes, + 2 for HC and null-term
            dwLeafFolderLen = lstrlen(fiChildFldrInfo.pszName);
            dwFolderPathLen = lstrlen(pszFolderPath);
            dwNewFolderPathLen = lstrlen(pszNewFolderPath);

            // Allocate space
            cchOldPath = dwFolderPathLen + dwLeafFolderLen + 2;
            fResult = MemAlloc((void **)&pszOldPath, cchOldPath * sizeof(pszOldPath[0]));
            if (FALSE == fResult)
            {
                m_pStore->FreeRecord(&fiChildFldrInfo);
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            cchNewPath = dwNewFolderPathLen + dwLeafFolderLen + 2;
            fResult = MemAlloc((void **)&pszNewPath, cchNewPath * sizeof(pszNewPath[0]));
            if (FALSE == fResult)
            {
                MemFree(pszOldPath);
                m_pStore->FreeRecord(&fiChildFldrInfo);
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            // Append current child's name to current path, new path
            StrCpyN(pszOldPath, pszFolderPath, cchOldPath);
            StrCatBuff(pszOldPath, szHierarchyStr, cchOldPath);
            StrCatBuff(pszOldPath, fiChildFldrInfo.pszName, cchOldPath);

            StrCpyN(pszNewPath, pszNewFolderPath, cchNewPath);
            StrCatBuff(pszNewPath, szHierarchyStr, cchNewPath);
            StrCatBuff(pszNewPath, fiChildFldrInfo.pszName, cchNewPath);

            // Recurse into the children, in hopes of finding an existing folder
            hr = RenameFolderHelper(fiChildFldrInfo.idFolder, pszOldPath, cHierarchyChar, pszNewPath);
            MemFree(pszOldPath);
            MemFree(pszNewPath);
            if (FAILED(hr))
            {
                m_pStore->FreeRecord(&fiChildFldrInfo);
                TraceResult(hr);
                goto exit;
            }

            // Load in the next child folder
            m_pStore->FreeRecord(&fiChildFldrInfo);
            hr = pFldrEnum->Next(1, &fiChildFldrInfo, NULL);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }
        } // while (S_OK == hr)

        goto exit; // We don't attempt to rename non-existent folders
    } // if (fiFolderInfo.dwImapFlags & FOLDER_NONEXISTENT)


    // Create a CRenameFolderInfo structure
    pRenameInfo = new CRenameFolderInfo;
    if (NULL == pRenameInfo)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Fill in all the fields
    pRenameInfo->pszFullFolderPath = StringDup(pszFolderPath);
    pRenameInfo->cHierarchyChar = cHierarchyChar;
    pRenameInfo->pszNewFolderPath = StringDup(pszNewFolderPath);
    pRenameInfo->idRenameFolder = idFolder;

    // Send the RENAME command
    pRenameInfo->pszRenameCmdOldFldrPath = StringDup(pszFolderPath);
    hr = _EnqueueOperation(tidRENAME, (LPARAM)pRenameInfo, icRENAME_COMMAND,
        pRenameInfo->pszNewFolderPath, uiNORMAL_PRIORITY);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    if (NULL != pRenameInfo)
        pRenameInfo->Release();

    if (NULL != pFldrEnum)
        pFldrEnum->Release();

    return hr;
} // RenameFolderHelper



//***************************************************************************
// Function: RenameTreeTraversal
//
// Purpose:
//   This function performs the requested operation on all child folders of
// the rename folder (specified in pRenameInfo->hfRenameFolder). For example,
// the tidRENAMESUBSCRIBE operation indicates that the entire renamed folder
// hierarchy should be subscribed.
//
// Arguments:
//   WPARAM wpOperation [in] - identifies the operation to perform on the
//     rename hierarchy. Current operations include:
//       tidRENAMESUBSCRIBE - subscribe new (renamed) folder hierarchy
//       tidRENAMESUBSCRIBE_AGAIN - same as tidRENAMESUBSCRIBE
//       tidRENAMERENAME - issue individual RENAME's for all old child folders
//                         (simulates an atomic rename)
//       tidRENAMELIST - list the FIRST child of the rename folder.
//       tidRENAMEUNSUBSCRIBE - unsubscribe old folder hierarchy.
//
//   CRenameFolderInfo [in] - the CRenameFolderInfo class associated with
//     the RENAME operation.
//   BOOL fIncludeRenameFolder [in] - TRUE if the rename folder (top node)
//     should be included in the operation, otherwise FALSE.
//
// Returns:
//   HRESULT indicating success or failure. S_FALSE is a possible result,
// indicating that recursion has occurred in RenameTreeTraversalHelper.
//***************************************************************************
HRESULT CIMAPSync::RenameTreeTraversal(WPARAM wpOperation,
                                       CRenameFolderInfo *pRenameInfo,
                                       BOOL fIncludeRenameFolder)
{
    HRESULT hrResult;
    LPSTR pszCurrentPath;
    DWORD dwSizeOfCurrentPath;
    FOLDERINFO fiFolderInfo;
    BOOL fFreeInfo = FALSE;

    TraceCall("CIMAPSync::RenameTreeTraversal");
    IxpAssert(m_cRef > 0);

    // Construct the path name to renamed folder's parent, based on operation
    if (tidRENAMESUBSCRIBE == wpOperation ||
        tidRENAMESUBSCRIBE_AGAIN == wpOperation ||
        tidRENAMERENAME == wpOperation)
        pszCurrentPath = pRenameInfo->pszNewFolderPath;
    else
        pszCurrentPath = pRenameInfo->pszFullFolderPath;

    dwSizeOfCurrentPath = lstrlen(pszCurrentPath);

    // We need to get some details about renamed folder node to start the recursion
    hrResult = m_pStore->GetFolderInfo(pRenameInfo->idRenameFolder, &fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }
    fFreeInfo = TRUE;

    // Start the mayhem
    hrResult = RenameTreeTraversalHelper(wpOperation, pRenameInfo, pszCurrentPath,
        dwSizeOfCurrentPath, fIncludeRenameFolder, &fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiFolderInfo);

    return hrResult;
} // RenameTreeTraversal



//***************************************************************************
// Function: RenameTreeTraversalHelper
//
// Purpose:
//   This function actually does the work for RenameTreeTraversal. This
// function is separate so that it can perform the necessary recursion to
// execute the desired operation on every child folder of the rename folder.
//
// Arguments:
//   WPARAM wpOperation [in] - same as for RenameTreeTraversal.
//   CRenameFolderInfo [in/out] - same as for RenameTreeTraversal. Member
//     variables of this class are updated as required in this function
//     (for instance, iNumListRespExpected is incremented for each LIST sent).
//   LPSTR pszCurrentFldrPath [in/out] - a string describing the full path to
//     the current folder. The first call to this function (from Rename-
//     TreeTraversal) is a full path to the rename folder. This function
//     modifies this buffer (adds leaf node names) as needed.
//   DWORD dwLengthOfCurrentPath [in] - length of pszCurrentFldrPath.
//   BOOL fIncludeThisFolder [in] - TRUE if this function should perform
//     the requested operation on the current node. Otherwise, FALSE.
//   FOLDERINFO *pfiCurrentFldrInfo [in] - contains information about the
//     current folder.
//
// Returns:
//   HRESULT indicating success or failure. S_FALSE is a possible return
// result, typically indicating that recursion has taken place.
//***************************************************************************
HRESULT CIMAPSync::RenameTreeTraversalHelper(WPARAM wpOperation,
                                             CRenameFolderInfo *pRenameInfo,
                                             LPSTR pszCurrentFldrPath,
                                             DWORD dwLengthOfCurrentPath,
                                             BOOL fIncludeThisFolder,
                                             FOLDERINFO *pfiCurrentFldrInfo)
{
    HRESULT             hrResult = S_OK;
    FOLDERINFO          fiFolderInfo;
    IEnumerateFolders  *pFldrEnum = NULL;

    TraceCall("CIMAPSync::RenameTreeTraversalHelper");
    IxpAssert(m_cRef > 0);

    // Execute the requested operation, if current folder is not suppressed
    // and if current folder actually exists
    if (fIncludeThisFolder && 0 == (pfiCurrentFldrInfo->dwFlags & FOLDER_NONEXISTENT))
    {
        switch (wpOperation)
        {
            case tidRENAMESUBSCRIBE:
            case tidRENAMESUBSCRIBE_AGAIN:
                hrResult = _EnqueueOperation(wpOperation, (LPARAM) pRenameInfo,
                    icSUBSCRIBE_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumSubscribeRespExpected += 1;
                break; // case tidRENAMESUBSCRIBE

            case tidRENAMELIST:
                // This operation is special-cased to send only ONE list command, a list cmd
                // for the first child fldr. The reason this operation is HERE is because this
                // operation used to list ALL the child fldrs, until I found that IIMAPTransport
                // couldn't resolve the ambiguities. (IIMAPTransport will eventually get queuing).
                IxpAssert(0 == pRenameInfo->iNumListRespExpected); // Send only ONE list cmd!
                hrResult = _EnqueueOperation(tidRENAMELIST, (LPARAM) pRenameInfo,
                    icLIST_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumListRespExpected += 1;
                goto exit; // Do not recurse any further into the folder hierarchy
                break; // case tidRENAMELIST

            case tidRENAMEUNSUBSCRIBE:
                hrResult = _EnqueueOperation(tidRENAMEUNSUBSCRIBE, (LPARAM) pRenameInfo,
                    icUNSUBSCRIBE_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumUnsubscribeRespExpected += 1;
                break; // case tidRENAMEUNSUBSCRIBE

            case tidRENAMERENAME: {
                LPSTR pszRenameCmdOldFldrPath;
                DWORD cchFullFolderPathLen, cchLeafNodeLen;
                LPSTR pszOldFldrPath;
                BOOL fResult;

                // Allocate a buffer for old folder path
                cchFullFolderPathLen = lstrlen(pRenameInfo->pszFullFolderPath);
                cchLeafNodeLen = lstrlen(RemovePrefixFromPath(
                    pRenameInfo->pszNewFolderPath, pszCurrentFldrPath,
                    pRenameInfo->cHierarchyChar, NULL, NULL));
                DWORD cchSizeOldFldrPath = (cchFullFolderPathLen + cchLeafNodeLen + 2);
                fResult = MemAlloc((void **)&pszOldFldrPath, cchSizeOldFldrPath * sizeof(pszOldFldrPath[0]));
                if (FALSE == fResult)
                {
                    hrResult = TraceResult(E_OUTOFMEMORY); // Abort, folder paths aren't getting shorter
                    goto exit;
                }

                // Construct old folder path (MUST be below rename folder level)
                MemFree(pRenameInfo->pszRenameCmdOldFldrPath);
                StrCpyN(pszOldFldrPath, pRenameInfo->pszFullFolderPath, cchSizeOldFldrPath);
                *(pszOldFldrPath + cchFullFolderPathLen) = pfiCurrentFldrInfo->bHierarchy;
                StrCatBuff(pszOldFldrPath,
                    RemovePrefixFromPath(pRenameInfo->pszNewFolderPath, pszCurrentFldrPath, pRenameInfo->cHierarchyChar, NULL, NULL), cchSizeOldFldrPath);
                pRenameInfo->pszRenameCmdOldFldrPath = pszOldFldrPath;

                hrResult = _EnqueueOperation(tidRENAMERENAME, (LPARAM) pRenameInfo,
                    icRENAME_COMMAND, pszCurrentFldrPath, uiNORMAL_PRIORITY);
                if (FAILED(hrResult))
                {
                    TraceResult(hrResult);
                    goto exit;
                }

                pRenameInfo->iNumRenameRespExpected += 1;
            } // case todRENAMERENAME
                break; // case tidRENAMERENAME

            default:
                AssertSz(FALSE, "I don't know how to perform this operation.");
                hrResult = TraceResult(E_FAIL);
                goto exit;
        } // switch (wpOperation)
    } // if (fIncludeThisFolder)


    // Now, recurse upon all my children, if there are any
    if (0 == (FOLDER_HASCHILDREN & pfiCurrentFldrInfo->dwFlags))
        goto exit; // We're done!

    // Initialize the child-traversal-loop
    hrResult = m_pStore->EnumChildren(pfiCurrentFldrInfo->idFolder, fUNSUBSCRIBE, &pFldrEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    while (S_OK == hrResult)
    {
        LPSTR pszCurrentChild;
        DWORD cchLengthOfCurrentChild;
        BOOL fResult;

        // Construct path to current child
        cchLengthOfCurrentChild = dwLengthOfCurrentPath +
            lstrlen(fiFolderInfo.pszName) + 1; // HC = 1
        fResult = MemAlloc((void **)&pszCurrentChild, (cchLengthOfCurrentChild + 1) * sizeof(pszCurrentChild[0])); // 1 for null-term
        if (FALSE == fResult)
        {
            m_pStore->FreeRecord(&fiFolderInfo);
            hrResult = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        StrCpyN(pszCurrentChild, pszCurrentFldrPath, cchLengthOfCurrentChild+1);
        *(pszCurrentChild + dwLengthOfCurrentPath) = pfiCurrentFldrInfo->bHierarchy;
        StrCatBuff(pszCurrentChild, fiFolderInfo.pszName, cchLengthOfCurrentChild+1);

        // Recurse on the child folder, NEVER suppress folders from here on in
        hrResult = RenameTreeTraversalHelper(wpOperation, pRenameInfo,
            pszCurrentChild, cchLengthOfCurrentChild, TRUE, &fiFolderInfo);
        MemFree(pszCurrentChild);
        if (FAILED(hrResult))
        {
            m_pStore->FreeRecord(&fiFolderInfo);
            TraceResult(hrResult);
            goto exit;
        }

        m_pStore->FreeRecord(&fiFolderInfo);
        if (tidRENAMELIST == wpOperation)
            break; // Special case for LIST: only send ONE list cmd (for first child fldr)

        // Advance the loop
        hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    } // while

exit:
    if (NULL != pFldrEnum)
        pFldrEnum->Release();

    return hrResult;
} // RenameTreeTraversalHelper



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::SubscribeSubtree(FOLDERID idFolder, BOOL fSubscribe)
{
    HRESULT             hrResult;
    IEnumerateFolders  *pFldrEnum = NULL;
    FOLDERINFO          fiFolderInfo;

    TraceCall("CIMAPSync::SubscribeSubtree");
    IxpAssert(m_cRef > 0);
    IxpAssert(FOLDERID_INVALID != idFolder);

    // First subscribe the current node
    hrResult = m_pStore->SubscribeToFolder(idFolder, fSubscribe, NOSTORECALLBACK);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Now work on the children
    hrResult = m_pStore->EnumChildren(idFolder, fUNSUBSCRIBE, &pFldrEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    while (S_OK == hrResult)
    {
        // Recurse into children
        hrResult = SubscribeSubtree(fiFolderInfo.idFolder, fSubscribe);
        TraceError(hrResult); // Record error but otherwise continue

        // Advance to next child
        m_pStore->FreeRecord(&fiFolderInfo);
        hrResult = pFldrEnum->Next(1, &fiFolderInfo, NULL);
        TraceError(hrResult);
    }

exit:
    if (NULL != pFldrEnum)
        pFldrEnum->Release();

    return hrResult;
}



//***************************************************************************
// Function: FindRootHierarchyChar
//
// Purpose:
//   This function is called to analyze hierarchy character information
// collected in m_phcfHierarchyCharInfo, and take appropriate action based
// on the analysis (for example, try to find the hierarchy character using
// a different method if the current method failed). Currently there are 3
// methods of finding a hierarchy character. I call these Plan A, B and C.
//      Plan A: Look for hierarchy char in folder hierarchy listing.
//      Plan B: Issue LIST c_szEmpty c_szEmpty
//      Plan C: Create a temp fldr (no HC's in name), list it, delete it
//      Plan Z: Give up and default HC to NIL. This is still under debate.
//
// Arguments:
//   BOOL fPlanA_Only [in] - TRUE if this function should execute plan A
//     only, and not execute plans B, C or Z.
//   LPARAM lParam [in] - lParam to use when issuing IMAP commands
//
// Returns:
//   If a hierarchy character is found, it is placed in m_cRootHierarchyChar.
//***************************************************************************
void CIMAPSync::FindRootHierarchyChar(BOOL fPlanA_Only, LPARAM lParam)
{
    HRESULT hr;

    TraceCall("CIMAPSync::FindRootHierarchyChar");
    IxpAssert(m_cRef > 0);
    AssertSz(INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar,
        "You want to find the root hierarchy char... but you ALREADY have one. Ah! Efficient.");

    if (NULL == m_phcfHierarchyCharInfo)
    {
        AssertSz(FALSE, "What's the idea, starting a folder DL without a hierarchy char finder?");
        return;
    }

    // Figure out what the hierarchy char is from the collected information
    AnalyzeHierarchyCharInfo();

    // If we haven't found the hierarchy character, launch plan B or C
    if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar && FALSE == fPlanA_Only)
    {
        switch (m_phcfHierarchyCharInfo->hcfStage)
        {
            case hcfPLAN_A:
                // Didn't find in folder hierarchy DL (Plan A). Plan "B" is to issue <LIST c_szEmpty c_szEmpty>
                m_phcfHierarchyCharInfo->hcfStage = hcfPLAN_B;
                hr = _EnqueueOperation(tidHIERARCHYCHAR_LIST_B, lParam, icLIST_COMMAND,
                    c_szEmpty, uiNORMAL_PRIORITY);
                TraceError(hr);
                break; // case hcfPLAN_A

            case hcfPLAN_B:
            {
                // Didn't find in <LIST c_szEmpty c_szEmpty> (Plan B). Plan "C": attempt CREATE, LIST, DELETE
                // There's no folders on the server, so very little chance of conflict
                // $REVIEW: Localize fldr name when IMAP handles UTF-7. (idsIMAP_HCFTempFldr)
                StrCpyN(m_phcfHierarchyCharInfo->szTempFldrName, "DeleteMe", ARRAYSIZE(m_phcfHierarchyCharInfo->szTempFldrName));
                m_phcfHierarchyCharInfo->hcfStage = hcfPLAN_C;
                hr = _EnqueueOperation(tidHIERARCHYCHAR_CREATE, lParam, icCREATE_COMMAND,
                    m_phcfHierarchyCharInfo->szTempFldrName, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
                break; // case hcfPLAN_B

            default:
            case hcfPLAN_C:
                IxpAssert(hcfPLAN_C == m_phcfHierarchyCharInfo->hcfStage);
                AssertSz(FALSE, "This server won't budge - I can't figure out hierarchy char");
                // $REVIEW: Should I put up a message box informing user of situation? Will they understand?
                // We'll just have to assume the hierarchy char is NIL
                // $REVIEW: Is this a good idea? What else can I do about it?
                m_cRootHierarchyChar = '\0';
                break; // case hcfPLAN_C
        }
    }

    // Finally, if we've found hierarchy character, or assumed a value in case
    // hcfPLAN_C above, stop the search and save character to disk
    if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
    {
        StopHierarchyCharSearch();
        hr = LoadSaveRootHierarchyChar(fSAVE_HC);
        TraceError(hr);
    }
}



//***************************************************************************
// Function: AnalyzeHierarchyCharInfo
//
// Purpose:
//   This function examines m_phcfHierarchyCharInfo and attempts to determine
// what the root hierarchy character is. The rules it uses are as follows:
// 1) If more than 1 Non-NIL, Non-"." (NNND), hierarchy char is indeterminate.
// 2) If one NNND-HC found, it is taken as HC. "." and NIL HC's are ignored.
// 3) If no NNND-HC's, but we saw a ".", then "." is HC.
// 4) If no NNND-HC's, no ".", but we saw a non-INBOX NIL, then NIL is HC.
//***************************************************************************
void CIMAPSync::AnalyzeHierarchyCharInfo(void)
{
    int     i;
    int     iNonNilNonDotCount;
    BYTE   *pbBitArray;

    TraceCall("CIMAPSync::AnalyzeHierarchyCharInfo");
    IxpAssert(m_cRef > 0);

    // First, count the number of non-NIL, non-"." hierarchy chars encountered
    iNonNilNonDotCount = 0;
    pbBitArray = m_phcfHierarchyCharInfo->bHierarchyCharBitArray;
    for (i = 0; i < sizeof(m_phcfHierarchyCharInfo->bHierarchyCharBitArray); i++)
    {
        if (0 != *pbBitArray)
        {
            BYTE bCurrentByte;
            int j;

            // Count the number of bits set in this byte
            bCurrentByte = *pbBitArray;
            IxpAssert(1 == sizeof(bCurrentByte)); // Must change code for > 1 byte at a time
            for (j=0; j<8; j++)
            {
                if (bCurrentByte & 0x01)
                {
                    iNonNilNonDotCount += 1;
                    m_cRootHierarchyChar = i*8 + j;
                }

                bCurrentByte >>= 1;
            }
        }

        // Advance the pointer
        pbBitArray += 1;
    }

    // Set the hierarchy character based on priority rules: '/' or '\', then '.', then NIL
    if (iNonNilNonDotCount > 1)
    {
        m_cRootHierarchyChar = INVALID_HIERARCHY_CHAR; // Which one WAS it?

        // Nuke all flags and start afresh
        AssertSz(FALSE, "Hey, lookee here! More than one NNND-HC! How quaint.");
        ZeroMemory(m_phcfHierarchyCharInfo->bHierarchyCharBitArray,
            sizeof(m_phcfHierarchyCharInfo->bHierarchyCharBitArray));
        m_phcfHierarchyCharInfo->fDotHierarchyCharSeen = FALSE;
        m_phcfHierarchyCharInfo->fNonInboxNIL_Seen = FALSE;
    }
    else if (0 == iNonNilNonDotCount)
    {
        // Hmmm, looks like we didn't find anything non-'.' or non-NIL
        IxpAssert(INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar); // Just paranoid
        if (m_phcfHierarchyCharInfo->fDotHierarchyCharSeen)
            m_cRootHierarchyChar = '.';
        else if (m_phcfHierarchyCharInfo->fNonInboxNIL_Seen)
            m_cRootHierarchyChar = '\0';

        // If we reach this point and INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar,
        // all flags must be 0, so no need to nuke as for iNonNilNonDotCount > 1 above
    }
    else
    {
        // We found a non-NIL, non-"." hierarchy char. This will take priority
        // over any NIL or "." hierarchy chars we encountered. STILL, I want to
        // know if we talk to a server who has both one NNND-HC and a "." HC.
        IxpAssert(1 == iNonNilNonDotCount);
        AssertSz(FALSE == m_phcfHierarchyCharInfo->fDotHierarchyCharSeen,
            "Take a look at THIS! A server with one NNND-HC and a '.' HC.");
    }
}



//***************************************************************************
// Function: StopHierarchyCharSearch
//
// Purpose:
//   This function stops future hierarchy character searches by freeing
// the m_phcfHierarchyCharInfo struct.
//***************************************************************************
void CIMAPSync::StopHierarchyCharSearch(void)
{
    TraceCall("CIMAPSync::StopHierararchyCharSearch");
    IxpAssert(m_cRef > 0);

    // Deallocate m_phcfHierarchyCharInfo
    if (NULL != m_phcfHierarchyCharInfo)
    {
        delete m_phcfHierarchyCharInfo;
        m_phcfHierarchyCharInfo = NULL;
    }
    else {
        AssertSz(FALSE, "No search for a root-lvl hierarchy character is in progress.");
    }
}



//***************************************************************************
// Function: LoadSaveRootHierarchyChar
//
// Arguments:
//   BOOL fSaveHC [in] - TRUE if we should save m_cRootHierarchyChar to
//     the root folder entry in the folder cache. FALSE to read
//     m_cRootHierarchyChar from the root folder entry in foldercache.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::LoadSaveRootHierarchyChar(BOOL fSaveHC)
{
    FOLDERINFO  fiRootFldrInfo;
    HRESULT     hr;
    FOLDERID    idCurrFldr;
    BOOL        fFreeInfo = FALSE;

    TraceCall("CIMAPSync::LoadSaveRootHierarchyChar");
    IxpAssert(m_cRef > 0);
    IxpAssert(m_pStore != NULL);

    // First thing we have to do is load fiFolderInfo with IMAP server node
    hr = m_pStore->GetFolderInfo(m_idIMAPServer, &fiRootFldrInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Now load or save m_cRootHierarchyChar as directed by user
    fFreeInfo = TRUE;
    if (fSaveHC)
    {
        // Save the hierarchy character to disk
        fiRootFldrInfo.bHierarchy = m_cRootHierarchyChar;
        hr = m_pStore->UpdateRecord(&fiRootFldrInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // Load the hierarchy character
        m_cRootHierarchyChar = fiRootFldrInfo.bHierarchy;
    }

exit:
    if (fFreeInfo)
        m_pStore->FreeRecord(&fiRootFldrInfo);

    return hr;
}



//***************************************************************************
// Function: CreateNextSpecialFolder
//
// Purpose:
//   This function is called after the tidINBOXLIST operation. This function
// tries to create all IMAP special folders (Sent Items, Drafts, Deleted
// Items). If no more special folders need to be created, the
// post-tidINBOXLIST activities are executed (tidPREFIXLIST/tidBROWSESTART/
// tidFOLDERLIST).
//
// Arguments:
//   CREATE_FOLDER_INFO *pcfiCreateInfo [in] - pointer to CREATE_FOLDER_INFO
//     with properly set pcfiCreateInfo. This function will
//     MemFree pcfiCreateInfo->pszFullFolderPath and delete pcfiCreateInfo
//     when all special folders have been created.
//   LPBOOL pfCompletion [out] - returns TRUE if we are done creating special
//     folders.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::CreateNextSpecialFolder(CREATE_FOLDER_INFO *pcfiCreateInfo,
                                           LPBOOL pfCompletion)
{
    HRESULT     hr = S_OK;
    HRESULT     hrTemp;
    LPARAM      lParam = pcfiCreateInfo->lParam;
    char        szSpecialFldrPath[2*MAX_PATH + 3]; // Leave room for HC, null-term and asterisk
    BOOL        fDone = FALSE;
    BOOL        fPostOp = FALSE;
    BOOL        fSuppressRelease = FALSE;
    IXPSTATUS   ixpCurrentStatus;

    TraceCall("CIMAPSync::CreateNextSpecialFolder");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pcfiCreateInfo);
    IxpAssert(FOLDER_NOTSPECIAL != pcfiCreateInfo->dwCurrentSfType);
    IxpAssert(FOLDER_NOTSPECIAL != pcfiCreateInfo->dwFinalSfType);
    IxpAssert(FOLDER_OUTBOX != pcfiCreateInfo->dwCurrentSfType);
    IxpAssert(FOLDER_OUTBOX != pcfiCreateInfo->dwFinalSfType);
    IxpAssert(pcfiCreateInfo->dwFinalSfType <= FOLDER_MAX);
    IxpAssert(pcfiCreateInfo->dwCurrentSfType <= pcfiCreateInfo->dwFinalSfType);

    szSpecialFldrPath[0] = '\0';

    // If we're looking for root-lvl hierarchy char, maybe this listing will help
    if (NULL != m_phcfHierarchyCharInfo)
        FindRootHierarchyChar(fHCF_PLAN_A_ONLY, lParam);

    hrTemp = LoadSaveRootHierarchyChar(fLOAD_HC);
    TraceError(hrTemp);

    // Get the next folder path if we're in CSF_NEXTFOLDER or CSF_INIT stage
    while (CSF_NEXTFOLDER == pcfiCreateInfo->csfCurrentStage || CSF_INIT == pcfiCreateInfo->csfCurrentStage)
    {
        // If CSF_NEXTFOLDER, bump up current special folder type and check for done-ness
        if (CSF_NEXTFOLDER == pcfiCreateInfo->csfCurrentStage)
        {
            pcfiCreateInfo->dwCurrentSfType += 1;
            if (FOLDER_OUTBOX == pcfiCreateInfo->dwCurrentSfType)
                pcfiCreateInfo->dwCurrentSfType += 1; // Skip Outbox

            if (pcfiCreateInfo->dwCurrentSfType > pcfiCreateInfo->dwFinalSfType)
            {
                fDone = TRUE;
                break;
            }
        }

        hr = ImapUtil_SpecialFldrTypeToPath(m_pszAccountID,
            (SPECIALFOLDER) pcfiCreateInfo->dwCurrentSfType, NULL, m_cRootHierarchyChar,
            szSpecialFldrPath, ARRAYSIZE(szSpecialFldrPath));

        if (SUCCEEDED(hr))
        {
            // Re-use current pcfiCreateInfo to launch next creation attempt
            if (NULL != pcfiCreateInfo->pszFullFolderPath)
                MemFree(pcfiCreateInfo->pszFullFolderPath);
            pcfiCreateInfo->idFolder = FOLDERID_INVALID;
            pcfiCreateInfo->pszFullFolderPath = StringDup(szSpecialFldrPath);
            pcfiCreateInfo->dwFlags = 0;
            pcfiCreateInfo->csfCurrentStage = CSF_LIST;
            break; // We're ready to create some special folders!
        }
        else if (CSF_INIT == pcfiCreateInfo->csfCurrentStage)
        {
            // Need to exit now on ANY failure, to avoid infinite loop
            fDone = TRUE;
            break;
        }
        else if (STORE_E_NOREMOTESPECIALFLDR == hr)
        {
            // Suppress error: current special folder is disabled or not supported on IMAP
            hr = S_OK;
        }
        else
        {
            TraceResult(hr); // Record but ignore unexpected error
        }

    } // while

    // Check for termination condition
    if (fDone)
        goto exit;

    // If we reach this point, we're ready to act on this special folder
    switch (pcfiCreateInfo->csfCurrentStage)
    {
        case CSF_INIT:
            // CSF_INIT should be resolved by loading a special fldr path and going to CSF_LIST!!
            hr = TraceResult(E_UNEXPECTED);
            break;

        case CSF_LIST:
            IxpAssert('\0' != szSpecialFldrPath[0]);

            if (FOLDER_INBOX == pcfiCreateInfo->dwCurrentSfType)
            {
                // For INBOX ONLY: Issue LIST <specialfldr>* to get subchildren of folder (and folder itself)
                StrCatBuff(szSpecialFldrPath, g_szAsterisk, ARRAYSIZE(szSpecialFldrPath)); // Append "*" to special folder name
            }

            pcfiCreateInfo->csfCurrentStage = CSF_LSUBCREATE;
            hr = _EnqueueOperation(tidSPECIALFLDRLIST, (LPARAM) pcfiCreateInfo,
                icLIST_COMMAND, szSpecialFldrPath, uiNORMAL_PRIORITY);
            TraceError(hr);
            break;

        case CSF_LSUBCREATE:
            // Check if the LIST operation returned the special folder path
            if (CFI_RECEIVEDLISTING & pcfiCreateInfo->dwFlags)
            {
                LPSTR pszPath;

                // Folder exists: Issue LSUB <specialfldr>* to get subscribed subchildren
                IxpAssert(NULL != pcfiCreateInfo->pszFullFolderPath &&
                    '\0' != pcfiCreateInfo->pszFullFolderPath[0]);

                if (FOLDER_INBOX == pcfiCreateInfo->dwCurrentSfType)
                {
                    // For INBOX only: Append "*" to special folder name
                    wnsprintf(szSpecialFldrPath, ARRAYSIZE(szSpecialFldrPath), "%s*", pcfiCreateInfo->pszFullFolderPath);
                    pszPath = szSpecialFldrPath;
                }
                else
                    pszPath = pcfiCreateInfo->pszFullFolderPath;

                pcfiCreateInfo->dwFlags = 0;
                pcfiCreateInfo->csfCurrentStage = CSF_CHECKSUB;
                hr = _EnqueueOperation(tidSPECIALFLDRLSUB, (LPARAM) pcfiCreateInfo,
                    icLSUB_COMMAND, pszPath, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
            else
            {
                // Folder does not appear to exist: better create it
                pcfiCreateInfo->dwFlags = 0;
                pcfiCreateInfo->csfCurrentStage = CSF_NEXTFOLDER;
                hr = _EnqueueOperation(tidCREATE, (LPARAM)pcfiCreateInfo, icCREATE_COMMAND,
                    pcfiCreateInfo->pszFullFolderPath, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
            break;

        case CSF_CHECKSUB:
            // Check if the LSUB operation returned the special folder path
            if (CFI_RECEIVEDLISTING & pcfiCreateInfo->dwFlags)
            {
                // Special folder is already subscribed, advance to next folder
                IxpAssert(FALSE == fDone);
                pcfiCreateInfo->csfCurrentStage = CSF_NEXTFOLDER;
                hr = CreateNextSpecialFolder(pcfiCreateInfo, &fDone);
                TraceError(hr);

                // BEWARE: do not access pcfiCreateInfo past this point, might be GONE
                fSuppressRelease = TRUE;
            }
            else
            {
                FOLDERID        idTemp;
                LPSTR           pszLocalPath;
                char            szInbox[CCHMAX_STRINGRES];
                SPECIALFOLDER   sfType;

                // Special folder not subscribed. Subscribe it!
                // We need to convert full path to local path. Local path = folder name as it appears in our cache
                pszLocalPath = ImapUtil_GetSpecialFolderType(m_pszAccountID,
                    pcfiCreateInfo->pszFullFolderPath, m_cRootHierarchyChar,
                    m_szRootFolderPrefix, &sfType);

                if (FOLDER_INBOX == sfType)
                {
                    // SPECIAL CASE: We need to replace INBOX with the localized name for INBOX
                    LoadString(g_hLocRes, idsInbox, szInbox, ARRAYSIZE(szInbox));
                    pszLocalPath = szInbox;
                }

                // Remove special folder from unsubscribed folder list (ignore error)
                if (NULL != m_pListHash)
                {
                    hr = m_pListHash->Find(pszLocalPath, fREMOVE, (void **) &idTemp);
                    IxpAssert(FAILED(hr) || idTemp == pcfiCreateInfo->idFolder);
                }

                // Use full path here (not local path)
                pcfiCreateInfo->csfCurrentStage = CSF_NEXTFOLDER;
                hr = _EnqueueOperation(tidSPECIALFLDRSUBSCRIBE, (LPARAM)pcfiCreateInfo,
                    icSUBSCRIBE_COMMAND, pcfiCreateInfo->pszFullFolderPath, uiNORMAL_PRIORITY);
                TraceError(hr);
            }
            break;

        default:
            AssertSz(FALSE, "We are at an unknown stage!");
            hr = TraceResult(E_FAIL);
            break;
    }

exit:
    // At this point, do not access pcfiCreateInfo if fSuppressRelease is TRUE!!

    if (FAILED(hr))
        fDone = TRUE;

    // Check if we are done and there are post-create operations to perform
    if (FALSE == fSuppressRelease && PCO_NONE != pcfiCreateInfo->pcoNextOp)
    {
        IxpAssert(PCO_APPENDMSG == pcfiCreateInfo->pcoNextOp);
        if (fDone && SUCCEEDED(hr))
        {
            hr = _EnqueueOperation(tidUPLOADMSG, pcfiCreateInfo->lParam, icAPPEND_COMMAND,
                pcfiCreateInfo->pszFullFolderPath, uiNORMAL_PRIORITY);
            TraceError(hr);

            fPostOp = TRUE; // Returns *pfCompletion = FALSE but releases CREATE_FOLDER_INFO
        }
        else if (FAILED(hr))
        {
            APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) pcfiCreateInfo->lParam;

            SafeMemFree(pAppendInfo->pszMsgFlags);
            SafeRelease(pAppendInfo->lpstmMsg);
            delete pAppendInfo;
        }
    }

    if (fDone && FALSE == fSuppressRelease)
    {
        EndFolderList();

        if (NULL != pcfiCreateInfo->pszFullFolderPath)
            MemFree(pcfiCreateInfo->pszFullFolderPath);

        delete pcfiCreateInfo;
    }

    if (NULL != pfCompletion)
        *pfCompletion = (fDone && FALSE == fPostOp);

    return hr;
}



// This is not the only place to start a folder list. For example,
// look at successful tidPREFIXLIST. Use this fn only where applicable.
HRESULT CIMAPSync::_StartFolderList(LPARAM lParam)
{
    HRESULT         hr = E_FAIL;
    IImnAccount    *pAcct;

    TraceCall("CIMAPSync::_StartFolderList");
    IxpAssert(g_pAcctMan);
    IxpAssert(m_cRef > 0);
    if (!g_pAcctMan)
        return E_UNEXPECTED;

    // If user started a folder list, we'll clear the AP_IMAP_DIRTY property
    // The goal is not to pester the user with refresh folder list dialogs
    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, &pAcct);
    TraceError(hr);
    if (SUCCEEDED(hr))
    {
        DWORD dwSrc;

        hr = pAcct->GetPropDw(AP_IMAP_DIRTY, &dwSrc);
        TraceError(hr);
        if (SUCCEEDED(hr))
        {
            DWORD dwDest;

            AssertSz(0 == (dwSrc & ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY |
                IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY)), "Please update my dirty bits!");

            // Clear these dirty bits since folder refresh solves all of these problems
            dwDest = dwSrc & ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY |
                    IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY);

            if (dwDest != dwSrc)
            {
                hr = pAcct->SetPropDw(AP_IMAP_DIRTY, dwDest);
                TraceError(hr);
                if (SUCCEEDED(hr))
                {
                    hr = pAcct->SaveChanges();
                    TraceError(hr);
                }
            }
        }

        pAcct->Release();
    }

    // Find out what translation mode we should be in
    hr = SetTranslationMode((FOLDERID) lParam);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Did user specify a root folder prefix?
    if ('\0' != m_szRootFolderPrefix[0])
    {
        // User-specified prefix exists. Check if prefix exists on IMAP server
        hr = _EnqueueOperation(tidPREFIXLIST, lParam, icLIST_COMMAND,
            m_szRootFolderPrefix, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // No root prefix folder, start folder refresh
        hr = _EnqueueOperation(tidFOLDERLIST, lParam, icLIST_COMMAND,
            g_szAsterisk, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

exit:
    return hr;
}



//***************************************************************************
// Function: OnResponse
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::OnResponse(const IMAP_RESPONSE *pimr)
{
    HRESULT     hr=S_OK;

    TraceCall("CIMAPSync::OnResponse");
    AssertSingleThreaded;

    switch (pimr->irtResponseType)
    {
        case irtERROR_NOTIFICATION:
            AssertSz(FALSE, "Received IIMAPCallback(irtERROR_NOTIFICATION). Ignoring it.");
            break;

        case irtCOMMAND_COMPLETION:
            hr = _OnCmdComplete(pimr->wParam, pimr->lParam,
                                pimr->hrResult, pimr->lpszResponseText);
            break;

        case irtSERVER_ALERT:
            hr = _ShowUserInfo(MAKEINTRESOURCE(idsIMAPServerAlertTitle),
                                MAKEINTRESOURCE(idsIMAPServerAlertIntro),
                                pimr->lpszResponseText);
            break;

        case irtPARSE_ERROR:
            // Do not display PARSE errors to user. These are really just WARNINGS
            // and so no need to interrupt flow with these. Besides, UW IMAP puts up
            // tonnes of these when you ask for ENVELOPE and it feels that the msgs are mal-formed
            break;

        case irtMAILBOX_UPDATE:
            hr = _OnMailBoxUpdate(pimr->irdResponseData.pmcMsgCount);
            break;

        case irtDELETED_MSG:
            hr = _OnMsgDeleted(pimr->irdResponseData.dwDeletedMsgSeqNum);
            break;

        case irtFETCH_BODY:
            hr = _OnFetchBody(pimr->hrResult, pimr->irdResponseData.pFetchBodyPart);
            break;

        case irtUPDATE_MSG:
            AssertSz(FALSE, "We should no longer get irtUPDATE_MSG, but the extended version instead");
            break;

        case irtUPDATE_MSG_EX:
            hr = _OnUpdateMsg(pimr->wParam, pimr->hrResult, pimr->irdResponseData.pFetchResultsEx);
            break;

        case irtAPPLICABLE_FLAGS:
            hr = _OnApplFlags(pimr->wParam,
                                pimr->irdResponseData.imfImapMessageFlags);
            break;

        case irtPERMANENT_FLAGS:
            hr = _OnPermFlags(pimr->wParam,
                                pimr->irdResponseData.imfImapMessageFlags,
                                pimr->lpszResponseText);
            break;

        case irtUIDVALIDITY:
            hr = _OnUIDValidity(pimr->wParam,
                                pimr->irdResponseData.dwUIDValidity,
                                pimr->lpszResponseText);
            break;

        case irtREADWRITE_STATUS:
            hr = _OnReadWriteStatus(pimr->wParam,
                                    pimr->irdResponseData.bReadWrite,
                                    pimr->lpszResponseText);
            break;

        case irtTRYCREATE:
            _OnTryCreate(pimr->wParam, pimr->lpszResponseText);
            break;

        case irtSEARCH:
            hr = _OnSearchResponse(pimr->wParam,
                                    pimr->irdResponseData.prlSearchResults);
            break;

        case irtMAILBOX_LISTING:
            hr = _OnMailBoxList(pimr->wParam,
                                pimr->lParam,
                                pimr->irdResponseData.illrdMailboxListing.pszMailboxName,
                                pimr->irdResponseData.illrdMailboxListing.imfMboxFlags,
                                pimr->irdResponseData.illrdMailboxListing.cHierarchyChar,
                                IXP_S_IMAP_VERBATIM_MBOX == pimr->hrResult);
            break;

        case irtAPPEND_PROGRESS:
            IxpAssert(tidUPLOADMSG == pimr->wParam);
            hr = _OnAppendProgress(pimr->lParam,
                pimr->irdResponseData.papAppendProgress->dwUploaded,
                pimr->irdResponseData.papAppendProgress->dwTotal);
            break;

        case irtMAILBOX_STATUS:
            hr = _OnStatusResponse(pimr->irdResponseData.pisrStatusResponse);
            break;

        default:
            AssertSz(FALSE, "Received unknown IMAP response type via OnResponse");
            break;
    }

    TraceError(hr);
    return S_OK;    // never fail the OnResponse
}



//***************************************************************************
// Function: OnTimeout
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    HRESULT hr;
    AssertSingleThreaded;

    TraceCall("CIMAPSync::OnTimeout");
    IxpAssert(m_cRef > 0);

    if (NULL == m_pCurrentCB)
        return S_OK; // We'll just wait until the cows come home
    else
        return m_pCurrentCB->OnTimeout(&m_rInetServerInfo, pdwTimeout, IXP_IMAP);
}



//***************************************************************************
// Function: OnLogonPrompt
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnLogonPrompt(LPINETSERVER pInetServer,
                                 IInternetTransport *pTransport)
{
    BOOL    bResult;
    char    szPassword[CCHMAX_PASSWORD];
    HRESULT hr;
    HWND    hwnd;

    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, ARRAYSIZE(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        StrCpyN(pInetServer->szPassword, szPassword, ARRAYSIZE(pInetServer->szPassword));
        return S_OK;
    }

    // Propagate call up to callback
    if (NULL == m_pCurrentCB)
        return S_FALSE;

    hr = m_pCurrentCB->OnLogonPrompt(pInetServer, IXP_IMAP);
    if (S_OK == hr)
    {
        // Cache password for future reference this session
        SavePassword(pInetServer->dwPort, pInetServer->szServerName,
            pInetServer->szUserName, pInetServer->szPassword);
    }

    else if (S_FALSE == hr)
    {
        m_hrOperationResult = STORE_E_OPERATION_CANCELED;
        LoadString(g_hLocRes, IDS_IXP_E_USER_CANCEL, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
    }
    else if (FAILED(hr))
        m_hrOperationResult = hr;

    return hr;
}



//***************************************************************************
// Function: OnPrompt
// Description: See imnxport.idl for details.
//***************************************************************************
INT CIMAPSync::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption,
                        UINT uType, IInternetTransport *pTransport)
{
    INT     iResult=IDCANCEL;

    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    if (NULL != m_pCurrentCB)
    {
        HRESULT hr;

        hr = m_pCurrentCB->OnPrompt(hrError, pszText, pszCaption,
            uType, &iResult);
        TraceError(hr);
    }

    return iResult;
}



//***************************************************************************
// Function: OnStatus
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnStatus(IXPSTATUS ixpStatus, IInternetTransport *pTransport)
{
    HRESULT hrTemp;
    IStoreCallback *pCallback;

    TraceCall("CIMAPSync::OnStatus");
    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    if (NULL != m_pCurrentCB)
        pCallback = m_pCurrentCB;
    else
        pCallback = m_pDefCallback;

    // Report status to UI component
    if (NULL != pCallback)
    {
        hrTemp = pCallback->OnProgress(SOT_CONNECTION_STATUS, ixpStatus, 0,
            m_rInetServerInfo.szServerName);
        TraceError(hrTemp);
    }

    switch (ixpStatus)
    {
        case IXP_AUTHORIZED:
            m_issCurrent = issAuthenticated;

            // Clear any OnError's collected (typ. from one or more login rejections)
            m_hrOperationResult = OLE_E_BLANK;

            hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_CONNCOMPLETE);
            TraceError(hrTemp);
            break;

        case IXP_DISCONNECTED:
            // If we're disconnecting due to reconnect attempt, do not abort operation
            if (m_fReconnect)
            {
                // if we got disconnected reset the current and pending state
                OnFolderExit();
                m_issCurrent = issNotConnected;
                m_fDisconnecting = FALSE; // We are now done with disconnection
                break;
            }

            // Figure out if we were ever connected
            if (OLE_E_BLANK == m_hrOperationResult)
            {
                if (issNotConnected == m_issCurrent)
                    m_hrOperationResult = IXP_E_FAILED_TO_CONNECT;
                else
                    m_hrOperationResult = IXP_E_CONNECTION_DROPPED;
            }

            OnFolderExit();
            FlushOperationQueue(issNotConnected, m_hrOperationResult);

            // if we got disconnected reset the current and pending state
            m_issCurrent = issNotConnected;
            m_fDisconnecting = FALSE; // We are now done with disconnection

            // There is only one case where _OnCmdComplete doesn't get the chance
            // to issue the CFSM_EVENT_ERROR, and that's when we never even connect
            if (CFSM_STATE_WAITFORCONN == m_cfsState)
            {
                // Move state machine along to abort this operation and reset
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_ERROR);
                TraceError(hrTemp);
                m_fTerminating = TRUE; // CFSM_EVENT_ERROR should make us go to CFSM_STATE_OPERATIONCOMPLETE
            }
            break;

        case IXP_CONNECTED:
            // if we get the first 'connected' then we are not yet
            // AUTH'ed, so trasition into issNonAuthenticated if we
            // get authorized, we transition into Authenticated
            if (m_issCurrent == issNotConnected)
                m_issCurrent = issNonAuthenticated;
            break;
    }

    return S_OK; // Yippee, we have status
}



//***************************************************************************
// Function: OnError
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnError(IXPSTATUS ixpStatus, LPIXPRESULT pResult,
                           IInternetTransport *pTransport)
{
    AssertSingleThreaded;

    // Currently all OnError calls are due to logon/connection problems
    // Not much we can do: there's no way to show error outside of OnComplete

    // One thing we CAN do is to store error text. If we are disconnected next,
    // we will have something to show the user
    if (NULL != pResult->pszProblem)
        StrCpyN(m_szOperationProblem, pResult->pszProblem, ARRAYSIZE(m_szOperationProblem));

    if (NULL != pResult->pszResponse)
        StrCpyN(m_szOperationDetails, pResult->pszResponse, ARRAYSIZE(m_szOperationDetails));

    m_hrOperationResult = pResult->hrResult;

    // Ignore all errors except for the following:
    if (IXP_E_IMAP_LOGINFAILURE == pResult->hrResult)
    {
        HRESULT         hrTemp;
        HWND            hwndParent;

        hrTemp = GetParentWindow(0, &hwndParent);
        if (FAILED(hrTemp))
        {
            // Not much we can do here!
            TraceInfoTag(TAG_IMAPSYNC, _MSG("*** CIMAPSync::OnError received for %s operation",
                sotToSz(m_sotCurrent)));
        }
        else
        {
            STOREERROR  seErrorInfo;

            // Display error to user ourselves
            FillStoreError(&seErrorInfo, pResult->hrResult, pResult->dwSocketError, NULL, NULL);
            CallbackDisplayError(hwndParent, seErrorInfo.hrResult, &seErrorInfo);
        }
    }

    return S_OK;
} // OnError



//***************************************************************************
// Function: OnCommand
// Description: See imnxport.idl for details.
//***************************************************************************
HRESULT CIMAPSync::OnCommand(CMDTYPE cmdtype, LPSTR pszLine,
                             HRESULT hrResponse, IInternetTransport *pTransport)
{
    IxpAssert(m_cRef > 0);
    AssertSingleThreaded;

    // We should never get this
    AssertSz(FALSE, "*** Received ITransportCallback::OnCommand callback!!!");
    return S_OK;
}




//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr = E_FAIL;

    AssertSingleThreaded;

    // Ask the callback recipient
    if (NULL != m_pCurrentCB)
    {
        hr = m_pCurrentCB->GetParentWindow(dwReserved, phwndParent);
        TraceError(hr);
    }
    else if (NULL != m_pDefCallback)
    {
        hr = m_pDefCallback->GetParentWindow(dwReserved, phwndParent);
        TraceError(hr);
    }

    if (FAILED(hr))
    {
        // We're not supposed to put up any UI
        *phwndParent = NULL;
    }

    return hr;
}

//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount)
{
    // Locals
    HRESULT hr = E_UNEXPECTED;

    // Invalid Args
    Assert(ppAccount);
    Assert(g_pAcctMan);
    Assert(m_pszAccountID);

    // Initialize
    *ppAccount = NULL;

    if (g_pAcctMan)
    {
        // Find the Account
        IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_pszAccountID, ppAccount));

        // Set the server type
        *pdwServerType = SRV_IMAP;
    }

exit:
    // Done
    return(hr);
}

//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_ShowUserInfo(LPSTR pszTitle, LPSTR pszText1, LPSTR pszText2)
{
    char            szTitle[CCHMAX_STRINGRES];
    char            szUserInfo[2 * CCHMAX_STRINGRES];
    LPSTR           p;
    HRESULT         hr;
    INT             iTemp;
    IStoreCallback *pCallback;

    TraceCall("CIMAPSync::_ShowUserInfo");
    AssertSingleThreaded;

    // Check args
    if (NULL == pszTitle || NULL == pszText1)
    {
        AssertSz(FALSE, "pszTitle and pszText1 cannot be NULL");
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    if (NULL != m_pCurrentCB)
        pCallback = m_pCurrentCB;
    else
        pCallback = m_pDefCallback;

    // Check if we have a callback to call
    if (NULL == pCallback)
        return S_OK; // Nothing to do here!

    if (IS_INTRESOURCE(pszTitle))
    {
        LoadString(g_hLocRes, PtrToUlong(pszTitle), szTitle, ARRAYSIZE(szTitle));
        pszTitle = szTitle;
    }

    p = szUserInfo;
    if (IS_INTRESOURCE(pszText1))
        p += LoadString(g_hLocRes, PtrToUlong(pszText1), szUserInfo, ARRAYSIZE(szUserInfo));

    if (NULL != pszText2)
    {
        if (IS_INTRESOURCE(pszText2))
            LoadString(g_hLocRes, PtrToUlong(pszText2), p, ARRAYSIZE(szUserInfo) -
                (int) (p - szUserInfo));
        else
            StrCpyN(p, pszText2, ARRAYSIZE(szUserInfo) - (int) (p - szUserInfo));
    }

    hr = pCallback->OnPrompt(S_OK, szUserInfo, pszTitle, MB_OK, &iTemp);
    TraceError(hr);

exit:
    return hr;
}



//***************************************************************************
// Function: OnMailBoxUpdate
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnMailBoxUpdate(MBOX_MSGCOUNT *pNewMsgCount)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::OnMailBoxUpdate");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pNewMsgCount);

    // Handle EXISTS response - calculate number of new msgs, update m_dwMsgCount
    if (pNewMsgCount->bGotExistsResponse)
    {
        // Since we are guaranteed to get all EXPUNGE responses, and since
        // we decrement m_dwMsgCount for each EXPUNGE, number of new messages
        // is difference between current EXISTS count and m_dwMsgCount.
        if (m_fMsgCountValid)
        {
            if (pNewMsgCount->dwExists >= m_dwMsgCount)
                m_dwNumNewMsgs += pNewMsgCount->dwExists - m_dwMsgCount;
        }

        m_dwMsgCount = pNewMsgCount->dwExists;
        m_fMsgCountValid = TRUE;

        // Make sure msg seq num <-> UID table is proper size for this mbox
        // Record but otherwise ignore errors
        hrTemp = m_pTransport->ResizeMsgSeqNumTable(pNewMsgCount->dwExists);
        TraceError(hrTemp);
    }


    // New messages! Woo hoo!
    if (m_dwNumNewMsgs > 0)
    {
        m_dwSyncToDo |= (m_dwSyncFolderFlags & SYNC_FOLDER_NEW_HEADERS);
        hrTemp = _SyncHeader();
        TraceError(hrTemp);
    }
    return S_OK;
}



//***************************************************************************
// Function: _OnMsgDeleted
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnMsgDeleted(DWORD dwDeletedMsgSeqNum)
{
    DWORD           dwDeletedMsgUID, dwHighestMSN;
    HRESULT         hr;
    MESSAGEIDLIST   midList;
    MESSAGEID       mid;

    TraceCall("CIMAPSync::DeletedMsgNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(0 != dwDeletedMsgSeqNum);

    // Regardless of outcome, an EXPUNGE means there's one less msg - update vars
    if (m_fMsgCountValid)
        m_dwMsgCount -= 1;

    // Is this msg seq num within our translation range?
    hr = m_pTransport->GetHighestMsgSeqNum(&dwHighestMSN);
    if (SUCCEEDED(hr) && dwDeletedMsgSeqNum > dwHighestMSN)
        return S_OK; // We got an EXPUNGE for a hdr we've never DL'ed

    // Find out who got the axe
    hr = m_pTransport->MsgSeqNumToUID(dwDeletedMsgSeqNum, &dwDeletedMsgUID);
    if (FAILED(hr) || 0 == dwDeletedMsgUID)
    {
        // Failure here means we either got a bogus msg seq num, or we got an
        // EXPUNGE during SELECT (before the tidFETCH_CACHED_FLAGS transaction).
        // If the latter is true, it's no big deal since FETCHes will sync us up.
        TraceResult(E_FAIL); // Record but otherwise ignore error
        goto exit;
    }

    // Delete message from the cache. Note that we do not care about error
    // because even in case of error, we must resequence the table
    mid = (MESSAGEID)((DWORD_PTR)dwDeletedMsgUID);
    midList.cAllocated = 0;
    midList.cMsgs = 1;
    midList.prgidMsg = &mid;

    hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &midList, NULL, NULL);
    TraceError(hr);

exit:
    // Resequence our msg seq num <-> UID table
    hr = m_pTransport->RemoveSequenceNum(dwDeletedMsgSeqNum);
    TraceError(hr);
    return S_OK;
}



//***************************************************************************
// Function: _OnFetchBody
// Purpose: This function handles the irtFETCH_BODY response type of
//   IIMAPCallback::OnResponse.
//***************************************************************************
HRESULT CIMAPSync::_OnFetchBody(HRESULT hrFetchBodyResult,
                                FETCH_BODY_PART *pFetchBodyPart)
{
    LPSTREAM    lpstmRFC822; // Only used for RFC822.HEADER
    HRESULT     hr;

    TraceCall("CIMAPSync::_OnFetchBody");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchBodyPart);
    IxpAssert(NULL != pFetchBodyPart->pszBodyTag);
    IxpAssert(NULL != pFetchBodyPart->pszData);
    IxpAssert(0 != pFetchBodyPart->dwMsgSeqNum);

    // Initialize variables
    hr = S_OK;
    lpstmRFC822 = (LPSTREAM) pFetchBodyPart->lpFetchCookie2;

    // Check for (and deal with) failure
    if (FAILED(hrFetchBodyResult))
    {
        DWORD dwUID;

        TraceResult(hrFetchBodyResult);
        pFetchBodyPart->lpFetchCookie1 = fbpNONE;
        if (NULL != lpstmRFC822)
        {
            lpstmRFC822->Release();
            pFetchBodyPart->lpFetchCookie2 = NULL;
        }

        // Get the UID of this message
        hr = m_pTransport->MsgSeqNumToUID(pFetchBodyPart->dwMsgSeqNum, &dwUID);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        NotifyMsgRecipients(dwUID, fCOMPLETED, NULL, hrFetchBodyResult, NULL);
        goto exit;
    }

    // Identify this fetch body tag, if we haven't already
    if (fbpNONE == pFetchBodyPart->lpFetchCookie1)
    {
        // First check for incoming body, then check for incoming header
        if (0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "RFC822") ||
            0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "BODY[]"))
        {
            pFetchBodyPart->lpFetchCookie1 = fbpBODY;
        }
        else if (0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "RFC822.HEADER") ||
                 0 == lstrcmpi(pFetchBodyPart->pszBodyTag, "BODY[HEADER.FIELDS"))
        {
            pFetchBodyPart->lpFetchCookie1 = fbpHEADER;

            // Create a stream
            IxpAssert(NULL == lpstmRFC822);
            hr = MimeOleCreateVirtualStream(&lpstmRFC822);
            if (FAILED(hr))
            {
                TraceResult(hr);
                goto exit;
            }

            pFetchBodyPart->lpFetchCookie2 = (LPARAM) lpstmRFC822;
        }
        else
        {
            AssertSz(FALSE, "What kind of tag is this?");
            pFetchBodyPart->lpFetchCookie1 = fbpUNKNOWN;
        }

    }

    // If this is a message body, update progress
    if (fbpBODY == pFetchBodyPart->lpFetchCookie1)
    {
        DWORD dwUID;

        hr = m_pTransport->MsgSeqNumToUID(pFetchBodyPart->dwMsgSeqNum, &dwUID);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        NotifyMsgRecipients(dwUID, fPROGRESS, pFetchBodyPart, S_OK, NULL);
    }

    // Append the data to a stream
    if (NULL != lpstmRFC822)
    {
        DWORD dwNumBytesWritten;

        IxpAssert(fbpHEADER == pFetchBodyPart->lpFetchCookie1);
        hr = lpstmRFC822->Write(pFetchBodyPart->pszData,
            pFetchBodyPart->dwSizeOfData, &dwNumBytesWritten);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
        IxpAssert(dwNumBytesWritten == pFetchBodyPart->dwSizeOfData);
    }

exit:
    return S_OK;
}



//***************************************************************************
// Function: _OnUpdateMsg
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnUpdateMsg(WPARAM tid, HRESULT hrFetchCmdResult,
                                FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::UpdateMsgNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);

    // Keep our msg seq num <-> UID table up to date
    if (pFetchResults->bUID)
    {
        // Record error but otherwise ignore
        hrTemp = m_pTransport->UpdateSeqNumToUID(pFetchResults->dwMsgSeqNum,
            pFetchResults->dwUID);
        TraceError(hrTemp);
    }
    else
    {
        HRESULT hr;
        DWORD dwHighestMSN;

        // No UID w/ FETCH resp means this is unsolicited: check that we already have hdr
        hr = m_pTransport->GetHighestMsgSeqNum(&dwHighestMSN);
        TraceError(hr);
        if (SUCCEEDED(hr) && pFetchResults->dwMsgSeqNum > dwHighestMSN)
            goto exit; // Can't translate MsgSeqNum to UID, typ. because svr is reporting
                       // flag updates on msgs which we haven't had hdrs DL'ed yet. No prob,
                       // if svr reported EXISTS correctly, we should be DL'ing hdrs shortly

        // Either unsolicited FETCH, or server needs to learn to send UID for UID cmds
        hr = m_pTransport->MsgSeqNumToUID(pFetchResults->dwMsgSeqNum, &pFetchResults->dwUID);
        if (FAILED(hr) || 0 == pFetchResults->dwUID)
        {
            TraceResult(hr);
            goto exit;
        }
        else
            pFetchResults->bUID = TRUE;
    }

    // We classify our fetch responses as header downloads, body downloads,
    // and flag updates.
    if (pFetchResults->bEnvelope)
    {
        // We only get envelopes when we are asking for headers
        Assert(fbpBODY != pFetchResults->lpFetchCookie1);
        pFetchResults->lpFetchCookie1 = fbpHEADER;
    }

    switch (pFetchResults->lpFetchCookie1)
    {
        case fbpHEADER:
            UpdateMsgHeader(tid, hrFetchCmdResult, pFetchResults);
            break;

        case fbpBODY:
            UpdateMsgBody(tid, hrFetchCmdResult, pFetchResults);
            break;

        default:
            AssertSz(fbpNONE == pFetchResults->lpFetchCookie1, "Unhandled FetchBodyPart type");
            UpdateMsgFlags(tid, hrFetchCmdResult, pFetchResults);
            break;
    }


exit:
    // If we allocated a stream, free it
    if (NULL != pFetchResults->lpFetchCookie2)
        ((LPSTREAM)pFetchResults->lpFetchCookie2)->Release();

    return S_OK;
}



//***************************************************************************
// Function: UpdateMsgHeader
//
// Purpose:
//   This function takes a message header returned via FETCH response,
// caches it, and notifies the view.
//
// Arguments:
//   WPARAM wpTransactionID [in] - transaction ID of fetch response.
//     Currently ignored.
//   HRESULT hrFetchCmdResult [in] - success/failure of FETCH cmd
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - the information from
//     the FETCH response.
//***************************************************************************
HRESULT CIMAPSync::UpdateMsgHeader( WPARAM tid,
                                    HRESULT hrFetchCmdResult,
                                    FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT     hr;
    MESSAGEINFO miMsgInfo={0};

    TraceCall("CIMAPSync::UpdateMsgHeader");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(pFetchResults->bUID);
    IxpAssert(fbpHEADER == pFetchResults->lpFetchCookie1);

    // Make sure we have everything we need
    if (FAILED(hrFetchCmdResult))
    {
        // Error on FETCH response, forget this header
        hr = TraceResult(hrFetchCmdResult);
        goto exit;
    }

    if (NULL == pFetchResults->lpFetchCookie2 && FALSE == pFetchResults->bEnvelope)
    {
        // I don't do ANYTHING without an RFC822.HEADER stream or envelope
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // First, check if we already have this header cached
    miMsgInfo.idMessage = (MESSAGEID)((DWORD_PTR)pFetchResults->dwUID);
    hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &miMsgInfo, NULL);
    if (DB_S_FOUND == hr)
    {
        // No need for alarm, we'll just swallow this header
        m_pFolder->FreeRecord(&miMsgInfo);
        goto exit; // We already have this header - we shouldn't have gotten this
                    // On some IMAP servers, if you UID FETCH <highestCachedUID + 1>:*
                    // you get a fetch response for highestCachedUID! Ignore this fetch result.
    }

    m_pFolder->FreeRecord(&miMsgInfo);

    // Cache this header, since it's not in our cache already
    hr = Fill_MESSAGEINFO(pFetchResults, &miMsgInfo);
    if (FAILED(hr))
    {
        FreeMessageInfo(&miMsgInfo); // There could be a couple of fields in there
        TraceResult(hr);
        goto exit;
    }

    hr = m_pFolder->InsertRecord(&miMsgInfo);
    if (SUCCEEDED(hr) && 0 == (ARF_READ & miMsgInfo.dwFlags))
        m_fNewMail = TRUE;

    FreeMessageInfo(&miMsgInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Bump up synchronize headers progress
    // Currently the only way we can get a hdr is through sync-up. Later on we'll
    // be able to get individual hdrs at which point this code should be updated
    if (TRUE)
    {
        DWORD dwNumExpectedMsgs;

        // Recalculate total number of expected messages
        if (m_fMsgCountValid &&
            m_dwMsgCount + m_dwNumHdrsDLed + 1 >= pFetchResults->dwMsgSeqNum)
        {
            IxpAssert(m_dwNumHdrsDLed < pFetchResults->dwMsgSeqNum);
            dwNumExpectedMsgs = m_dwMsgCount + m_dwNumHdrsDLed + 1 -
                pFetchResults->dwMsgSeqNum;
            if (dwNumExpectedMsgs != m_dwNumHdrsToDL)
            {
                // Record but otherwise ignore this fact
                TraceInfoTag(TAG_IMAPSYNC, _MSG("*** dwNumExpectedMsgs = %lu, m_dwNumHdrsToDL = %lu!",
                    dwNumExpectedMsgs, m_dwNumHdrsToDL));
            }
        }

        m_dwNumHdrsDLed += 1;
        if (pFetchResults->bMsgFlags && ISFLAGCLEAR(pFetchResults->mfMsgFlags, IMAP_MSG_SEEN))
            m_dwNumUnreadDLed += 1;

        if (NULL != m_pCurrentCB && SOT_SYNC_FOLDER == m_sotCurrent)
        {
            HRESULT hrTemp;

            hrTemp = m_pCurrentCB->OnProgress(SOT_SYNC_FOLDER,
                m_dwNumHdrsDLed, dwNumExpectedMsgs, m_pszFldrLeafName);
            TraceError(hrTemp);
        }
    }


exit:
    return hr;
}



//***************************************************************************
// Function: UpdateMsgBody
//
// Purpose:
//   This function takes a message body returned via FETCH response,
// caches it, and notifies all interested parties (there may be more
// than one).
//
// Arguments:
//   WPARAM wpTransactionID [in] - transaction ID of fetch response.
//     Currently ignored.
//   HRESULT hrFetchCmdResult [in] - success/failure of FETCH cmd
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - the information from
//     the FETCH response.
//***************************************************************************
HRESULT CIMAPSync::UpdateMsgBody(   WPARAM tid,
                                    HRESULT hrFetchCmdResult,
                                    FETCH_CMD_RESULTS_EX *pFetchResults)
{
    TraceCall("CIMAPSync::UpdateMsgBody");

    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(pFetchResults->bUID);
    IxpAssert(fbpBODY == pFetchResults->lpFetchCookie1);

    // Record any fetch error
    TraceError(hrFetchCmdResult);

    // We used to call NotifyMsgRecipients(fCOMPLETED) here, but since we only
    // get one body at a time, we should defer to _OnCmdComplete. This is because
    // FETCH body responses have multiple failure modes: tagged OK with no body,
    // tagged NO with no body, tagged OK with literal of size 0 (Netscape). To
    // easily avoid calling NotifyMsgRecipients twice, don't call from here.

    // It's possible to have FETCH response with no body: If you fetch an expunged
    // msg from a Netscape svr, you get a literal of size 0. Check for this case.
    if (SUCCEEDED(hrFetchCmdResult) && FALSE == m_fGotBody)
        hrFetchCmdResult = STORE_E_EXPIRED;

    if (FAILED(hrFetchCmdResult) &&
       (SUCCEEDED(m_hrOperationResult) || OLE_E_BLANK == m_hrOperationResult))
    {
        // We don't have an error set yet. Record this error
        m_hrOperationResult = hrFetchCmdResult;
    }

    return S_OK;
}



//***************************************************************************
// Function: UpdateMsgFlags
//
// Purpose:
//   This function takes a message's flags returned via FETCH response,
// updates the cache, and notifies the view.
//
// Arguments:
//   WPARAM wpTransactionID [in] - transaction ID of fetch response.
//     Currently ignored.
//   HRESULT hrFetchCmdResult [in] - success/failure of FETCH cmd
//   const FETCH_CMD_RESULTS_EX *pFetchResults [in] - the information from
//     the FETCH response.
//***************************************************************************
HRESULT CIMAPSync::UpdateMsgFlags(  WPARAM tid,
                                    HRESULT hrFetchCmdResult,
                                    FETCH_CMD_RESULTS_EX *pFetchResults)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     miMsgInfo;
    MESSAGEFLAGS    mfFlags;
    BOOL            fFreeMsgInfo = FALSE;


    TraceCall("CIMAPSync::UpdateMsgFlags");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pFetchResults);
    IxpAssert(pFetchResults->bUID);
    IxpAssert(fbpNONE == pFetchResults->lpFetchCookie1);
    IxpAssert(0 == pFetchResults->lpFetchCookie2);

    if (FAILED(hrFetchCmdResult))
    {
        // Error on FETCH response, forget this flag update
        hr = TraceResult(hrFetchCmdResult);
        goto exit;
    }

    // We expect that if there is no header and no body, that this is either
    // a solicited or unsolicited flag update
    if (FALSE == pFetchResults->bMsgFlags)
    {
        hr = S_OK; // We'll just ignore this fetch response. No need to wig out
        goto exit;
    }

    // Get the header for this message
    miMsgInfo.idMessage = (MESSAGEID)((DWORD_PTR)pFetchResults->dwUID);
    hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &miMsgInfo, NULL);
    if (DB_S_FOUND != hr)
    {
        TraceError(hr);
        goto exit;
    }

    // Convert IMAP flags to ARF_* flags
    fFreeMsgInfo = TRUE;
    mfFlags = miMsgInfo.dwFlags;
    mfFlags &= ~DwConvertIMAPtoARF(IMAP_MSG_ALLFLAGS); // Clear old IMAP flags
    mfFlags |= DwConvertIMAPtoARF(pFetchResults->mfMsgFlags); // Set IMAP flags

    // Are the new flags any different from our cached ones?
    if (mfFlags != miMsgInfo.dwFlags)
    {
        // Save new flags
        miMsgInfo.dwFlags = mfFlags;
        hr = m_pFolder->UpdateRecord(&miMsgInfo);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }

exit:
    if (fFreeMsgInfo)
        m_pFolder->FreeRecord(&miMsgInfo);

    return hr;
}



//***************************************************************************
// Function: _OnApplFlags
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnApplFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags)
{
    TraceCall("CIMAPSync::_OnApplFlags");

    // Save flags and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.
    return S_OK;
}



//***************************************************************************
// Function: _OnPermFlags
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnPermFlags(WPARAM tid, IMAP_MSGFLAGS imfApplicableFlags, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::PermanentFlagsNotification");
    IxpAssert(m_cRef > 0);

    // Save flags and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.
    return S_OK;
}



//***************************************************************************
// Function: _OnUIDValidity
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnUIDValidity(WPARAM tid, DWORD dwUIDValidity, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::UIDValidityNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);

    // Save UIDVALIDITY and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.
    m_dwUIDValidity = dwUIDValidity;
    return S_OK;
}



//***************************************************************************
// Function: _OnReadWriteStatus
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnReadWriteStatus(WPARAM tid, BOOL bReadWrite, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::_OnReadWriteStatus");
    IxpAssert(NULL != lpszResponseText);

    // Save status and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.

    // I'm ignoring above statement because UW server sends READ-ONLY unilaterally.
    // Above statement isn't currently valid anyway, I don't re-use connection if
    // it's in the middle of SELECT (found out how bad it was after I tried it).

    // Look for READ-WRITE to READ-ONLY transition
    if (rwsUNINITIALIZED != m_rwsReadWriteStatus)
    {
        if (rwsREAD_WRITE == m_rwsReadWriteStatus && FALSE == bReadWrite)
        {
            HRESULT hrTemp;

            hrTemp = _ShowUserInfo(MAKEINTRESOURCE(idsAthenaMail),
                MAKEINTRESOURCE(idsIMAPFolderReadOnly), lpszResponseText);
            TraceError(hrTemp);
        }
    }

    // Save current read-write status for future reference
    if (bReadWrite)
        m_rwsReadWriteStatus = rwsREAD_WRITE;
    else
        m_rwsReadWriteStatus = rwsREAD_ONLY;

    return S_OK;
}



//***************************************************************************
// Function: TryCreateNotification
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnTryCreate(WPARAM tid, LPSTR lpszResponseText)
{
    TraceCall("CIMAPSync::TryCreateNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);

    // Save response and process after SELECT is complete. DO NOT PROCESS HERE
    // because this response can be part of previously selected folder.

    return S_OK;
}



//***************************************************************************
// Function: SearchResponseNotification
// Description: See imnxport.idl (this is part of IIMAPCallback).
//***************************************************************************
HRESULT CIMAPSync::_OnSearchResponse(WPARAM tid, IRangeList *prlSearchResults)
{
    TraceCall("CIMAPSync::SearchResponseNotification");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != prlSearchResults);

    // Process search response here (currently does nothing)
    return S_OK;
}



//***************************************************************************
// Function: OnCmdComplete
// Description: See imnxport.idl (this is part of IIMAPCallback).
//
// For a CIMAPFolder class to be useful, it must enter the SELECTED state
// on the IMAP server. This function is written so that entering the SELECTED
// state is done in an orderly fashion: First the login, then the SELECT
// command.
//
// Once we are in SELECTED state, we can send IMAP commands at any time.
//***************************************************************************
HRESULT CIMAPSync::_OnCmdComplete(WPARAM tid, LPARAM lParam, HRESULT hrCompletionResult,
                                  LPCSTR lpszResponseText)
{
    TCHAR               szFmt[CCHMAX_STRINGRES];
    IStoreCallback     *pCallback = NULL;
    STOREOPERATIONTYPE  sotOpType = SOT_INVALID;
    BOOL                fCompletion = FALSE;
    BOOL                fCreateDone = FALSE,
                        fDelFldrFromCache = FALSE,
                        fSuppressDetails = FALSE;
    HRESULT             hrTemp;

    TraceCall("CIMAPSync::CmdCompletionNotification");
    IxpAssert(NULL != lpszResponseText);

    // Initialize variables
    *szFmt = NULL;

    // If we got any new unread messages, play sound and update tray icon
    // Do it here instead of case tidFETCH_NEW_HDRS because if we were IDLE when we got
    // new mail, m_sotCurrent is SOT_INVALID and we exit on the next if-statement
    if (tidFETCH_NEW_HDRS == tid && m_fNewMail && m_fInbox &&
        (NULL != m_pDefCallback || NULL != m_pCurrentCB))
    {
        IStoreCallback *pCB;

        pCB = m_pDefCallback;
        if (NULL == pCB)
            pCB = m_pCurrentCB;

        hrTemp = pCB->OnProgress(SOT_NEW_MAIL_NOTIFICATION, m_dwNumUnreadDLed, 0, NULL);
        TraceError(hrTemp);
        m_fNewMail = FALSE; // We've notified user
    }

    // We want to do the following even if there is no current operation
    switch (tid)
    {
        case tidFETCH_NEW_HDRS:
        case tidFETCH_CACHED_FLAGS:
        case tidEXPUNGE:
        case tidNOOP:
            m_lSyncFolderRefCount -= 1;
            break;
    }

    // We don't do a thing if there is no current operation (typ. means OnComplete
    // already sent)
    if (SOT_INVALID == m_sotCurrent)
        return S_OK;

    // Find out if this is a significant command which just completed
    switch (tid)
    {
        case tidSELECTION:
            // Select failure results in failure of current operation (eg, SOT_GET_MESSAGE
            // or SOT_SYNC_FOLDER) but does not otherwise invoke a call to OnComplete

            // This transaction ID identifies our mailbox SELECT attempt
            if (SUCCEEDED(hrCompletionResult))
            {
                FOLDERINFO fiFolderInfo;

                m_issCurrent = issSelected;
                m_idSelectedFolder = m_idFolder;

                // Set m_fInbox for new mail notification purposes
                Assert(FALSE == m_fInbox); // Should only get set to TRUE in one place
                hrTemp = m_pStore->GetFolderInfo(m_idSelectedFolder, &fiFolderInfo);
                if (SUCCEEDED(hrTemp))
                {
                    if (FOLDER_INBOX == fiFolderInfo.tySpecial)
                        m_fInbox = TRUE;

                    m_pStore->FreeRecord(&fiFolderInfo);
                }

                // Check if cached messages are still applicable to this folder
                hrCompletionResult = CheckUIDValidity();
                if (FAILED(hrCompletionResult))
                {
                    fCompletion = TRUE;
                    LoadString(g_hLocRes, idsIMAPUIDValidityError, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                    break;
                }

                // Restore to-do flags
                m_dwSyncToDo = m_dwSyncFolderFlags;
                Assert(0 == (SYNC_FOLDER_NOOP & m_dwSyncFolderFlags)); // Should not be a standing order
                if (ISFLAGSET(m_dwSyncFolderFlags, (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)))
                    m_dwSyncToDo |= SYNC_FOLDER_NOOP; // Subsequent FULL sync's can be replaced with NOOP

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_SELECTCOMPLETE);
                TraceError(hrTemp);
            }
            else
            {
                // Report error to user
                fCompletion = TRUE;
                LoadString(g_hLocRes, idsIMAPSelectFailureTextFmt, szFmt, ARRAYSIZE(szFmt));
                wnsprintf(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), szFmt, (m_pszFldrLeafName ? m_pszFldrLeafName : ""));
            }
            break; // case tidSELECTION


        case tidFETCH_NEW_HDRS:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // This transaction ID identifies our attempt to fetch new msg headers
            if (FAILED(hrCompletionResult))
            {
                LoadString(g_hLocRes, idsIMAPNewMsgDLErrText, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            else
            {
                if (FALSE == m_fMsgCountValid)
                {
                    DWORD   dwCachedCount;

                    // Svr didn't give us EXISTS (typ. NSCP v2.0). Assume m_cFilled == EXISTS
                    hrTemp = m_pFolder->GetRecordCount(IINDEX_PRIMARY, &dwCachedCount);
                    TraceError(hrTemp); // Record error but otherwise ignore
                    if (SUCCEEDED(hrTemp))
                    {
                        m_dwMsgCount = dwCachedCount; // I sure hope this is correct!
                        m_fMsgCountValid = TRUE;
                    }
                }

                // Launch next synchronization operation
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidFETCH_NEW_HDRS


        case tidFETCH_CACHED_FLAGS:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // If any errors occurred, bail out
            if (FAILED(hrCompletionResult))
            {
                LoadString(g_hLocRes, idsIMAPOldMsgUpdateFailure, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            else
            {
                // Delete all msgs deleted from server since last sync-up
                hrCompletionResult = SyncDeletedMessages();
                if (FAILED(hrCompletionResult))
                {
                    LoadString(g_hLocRes, idsIMAPMsgDeleteSyncErrText, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                }

                // Check we if we did a full sync
                if (ISFLAGSET(m_dwSyncFolderFlags, (SYNC_FOLDER_NEW_HEADERS | SYNC_FOLDER_CACHED_HEADERS)))
                    m_fDidFullSync = TRUE;

                // Launch next synchronization operation
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                    break;
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidFETCH_CACHED_FLAGS

        case tidEXPUNGE:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // Launch next synchronization operation
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                    break;
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidEXPUNGE

        case tidBODYMSN:
            if (SUCCEEDED(hrCompletionResult))
            {
                // We now have the MsgSeqNumToUID translation. Get the body
                hrCompletionResult = _EnqueueOperation(tidBODY, lParam, icFETCH_COMMAND,
                    NULL, uiNORMAL_PRIORITY);
                if (FAILED(hrCompletionResult))
                    TraceResult(hrCompletionResult);
                else
                    break;
            }

            // *** If tidBODYMSN failed, FALL THROUGH and code below will handle failure

        case tidBODY:
            // As commented in CIMAPSync::UpdateMsgBody, FETCH has many failure modes
            if (SUCCEEDED(hrCompletionResult))
            {
                if (OLE_E_BLANK != m_hrOperationResult && FAILED(m_hrOperationResult))
                    hrCompletionResult = m_hrOperationResult;
                else if (FALSE == m_fGotBody)
                    hrCompletionResult = STORE_E_EXPIRED;
            }

            // Load error info if this failed
            if (FAILED(hrCompletionResult))
                LoadString(g_hLocRes, idsIMAPBodyFetchFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));

            // Commit message body to stream (or not, depending on success/failure)
            NotifyMsgRecipients(lParam, fCOMPLETED, NULL, hrCompletionResult, m_szOperationProblem);

            m_fGotBody = FALSE;
            fCompletion = TRUE;
            break;

        case tidNOOP:
            fCompletion = TRUE; // We'll assume this unless we find otherwise

            // Launch next synchronization operation
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                hrCompletionResult = _SyncHeader();
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    LoadString(g_hLocRes, idsGenericError, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                    break;
                }
                else if (STORE_S_NOOP != hrCompletionResult || m_lSyncFolderRefCount > 0 ||
                         CFSM_STATE_WAITFORHDRSYNC != m_cfsState)
                {
                    // Successfully launched next sync operation, so we're not done yet
                    fCompletion = FALSE;
                }
            }

            if (SUCCEEDED(hrCompletionResult) && fCompletion)
            {
                // We're done with header sync (but not with the operation)
                fCompletion = FALSE;

                // Inform the Connection FSM of this event
                hrTemp = _ConnFSM_QueueEvent(CFSM_EVENT_HDRSYNCCOMPLETE);
                TraceError(hrTemp);
            }
            break; // case tidNOOP


        case tidMARKMSGS:
        {
            MARK_MSGS_INFO   *pMarkMsgInfo = (MARK_MSGS_INFO *) lParam;

            // We're done now whether or not we succeeded/failed
            sotOpType = pMarkMsgInfo->sotOpType;
            pCallback = m_pCurrentCB;
            SafeRelease(pMarkMsgInfo->pMsgRange);
            // Defer freeing MessageIDList until we have time to use it
            fCompletion = TRUE;

            IxpAssert(NULL != pMarkMsgInfo);
            TraceError(hrCompletionResult);
            if (SUCCEEDED(hrCompletionResult))
            {

                // Update the IMessageFolder with the new server state
                hrCompletionResult = m_pFolder->SetMessageFlags(pMarkMsgInfo->pList,
                    &pMarkMsgInfo->afFlags, NULL, NULL);
                TraceError(hrCompletionResult);
            }

            SafeMemFree(pMarkMsgInfo->pList);
            delete pMarkMsgInfo;
        }
            break; // case tidMARKMSGS


        case tidCOPYMSGS:
        {
            IMAP_COPYMOVE_INFO *pCopyMoveInfo = (IMAP_COPYMOVE_INFO *) lParam;
            BOOL                fCopyDone;

            // Check if this is the last SELECT command we sent out
            IxpAssert(NULL != lParam);
            fCopyDone = FALSE;
            TraceError(hrCompletionResult);

            if (FALSE == fCopyDone && SUCCEEDED(hrCompletionResult) &&
                (COPY_MESSAGE_MOVE & pCopyMoveInfo->dwOptions))
            {
                ADJUSTFLAGS afFlags;

                // Delete source messages as part of the move
                afFlags.dwAdd = ARF_ENDANGERED;
                afFlags.dwRemove = 0;
                hrCompletionResult = _SetMessageFlags(SOT_COPYMOVE_MESSAGE, pCopyMoveInfo->pList,
                    &afFlags, m_pCurrentCB);
                if (E_PENDING == hrCompletionResult)
                {
                    hrCompletionResult = S_OK; // Suppress error
                }
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    fCopyDone = TRUE;
                }
            }
            else
                fCopyDone = TRUE;

            if (FAILED(hrCompletionResult))
            {
                // Inform user of the error
                IxpAssert(fCopyDone);
                LoadString(g_hLocRes, idsIMAPCopyMsgsFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }

            // Whether or not copy is done, we have to free the data
            SafeMemFree(pCopyMoveInfo->pList);
            SafeRelease(pCopyMoveInfo->pCopyRange);

            if (fCopyDone)
            {
                // Set up callback information for OnComplete
                sotOpType = SOT_COPYMOVE_MESSAGE;
                pCallback = m_pCurrentCB;
                fCompletion = TRUE;
            }

            delete pCopyMoveInfo;
        }
            break; // case tidCOPYMSGS


        case tidUPLOADMSG:
        {
            APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) lParam;

            // We're done the upload, whether the APPEND succeeded or failed
            SafeMemFree(pAppendInfo->pszMsgFlags);
            SafeRelease(pAppendInfo->lpstmMsg);

            sotOpType = SOT_PUT_MESSAGE;
            pCallback = m_pCurrentCB;
            fCompletion = TRUE;
            delete pAppendInfo;

            // Inform the user of any errors
            if (FAILED(hrCompletionResult))
                LoadString(g_hLocRes, idsIMAPAppendFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
        }
            break; // case tidUPLOADMSG


        case tidPREFIXLIST:
        case tidPREFIX_HC:
        case tidPREFIX_CREATE:
        case tidFOLDERLIST:
        case tidFOLDERLSUB:
        case tidHIERARCHYCHAR_LIST_B:
        case tidHIERARCHYCHAR_CREATE:
        case tidHIERARCHYCHAR_LIST_C:
        case tidHIERARCHYCHAR_DELETE:
        case tidSPECIALFLDRLIST:
        case tidSPECIALFLDRLSUB:
        case tidSPECIALFLDRSUBSCRIBE:
            hrCompletionResult = DownloadFoldersSequencer(tid, lParam,
                hrCompletionResult, lpszResponseText, &fCompletion);
            break; // DownloadFoldersSequencer transactions

        case tidCREATE:
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                CREATE_FOLDER_INFO *pcfi = (CREATE_FOLDER_INFO *) lParam;

                // If CREATE returns tagged NO, folder may already exist. Issue LIST and find out!
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                {
                    pcfi->dwFlags |= CFI_CREATEFAILURE;
                    StrCpyN(m_szOperationDetails, lpszResponseText, ARRAYSIZE(m_szOperationDetails));
                }

                // Add the folder to our foldercache, by listing it
                hrCompletionResult = _EnqueueOperation(tidCREATELIST, lParam, icLIST_COMMAND,
                    pcfi->pszFullFolderPath, uiNORMAL_PRIORITY);

                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    fCreateDone = TRUE;
                    LoadString(g_hLocRes, idsIMAPCreateListFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                }
            }
            else
            {
                // If we failed, notify user and free the folder pathname string
                TraceResult(hrCompletionResult);
                if (NULL != lParam)
                    fCreateDone = TRUE;

                // Inform the user of the error.
                LoadString(g_hLocRes, idsIMAPCreateFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidCREATE


        case tidCREATELIST:
            if (SUCCEEDED(hrCompletionResult) &&
                (CFI_RECEIVEDLISTING & ((CREATE_FOLDER_INFO *)lParam)->dwFlags))
            {
                // We received a listing of this mailbox, so it's now cached. Subscribe it!
                hrCompletionResult = _EnqueueOperation(tidCREATESUBSCRIBE, lParam,
                    icSUBSCRIBE_COMMAND, ((CREATE_FOLDER_INFO *)lParam)->pszFullFolderPath,
                    uiNORMAL_PRIORITY);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    fCreateDone = TRUE;
                    LoadString(g_hLocRes, idsIMAPCreateSubscribeFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                }
            }
            else
            {
                CREATE_FOLDER_INFO *pcfi = (CREATE_FOLDER_INFO *) lParam;

                // Check if we were issuing a LIST in response to a failed CREATE command
                if (CFI_CREATEFAILURE & pcfi->dwFlags)
                {
                    LoadString(g_hLocRes, idsIMAPCreateFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                    fSuppressDetails = TRUE; // Use response line from previous CREATE failure
                    hrCompletionResult = IXP_E_IMAP_TAGGED_NO_RESPONSE;
                    fCreateDone = TRUE;
                    break;
                }

                TraceError(hrCompletionResult);
                if (SUCCEEDED(hrCompletionResult))
                {
                    // The LIST was OK, but no folder name returned. This may mean
                    // we've assumed an incorrect hierarchy character
                    AssertSz(FALSE, "You might have an incorrect hierarchy char, here.");
                    hrCompletionResult = TraceResult(E_FAIL);
                }

                // If we failed, notify user and free the folder pathname string
                if (NULL != lParam)
                    fCreateDone = TRUE;

                // Inform the user of the error.
                LoadString(g_hLocRes, idsIMAPCreateListFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidCREATELIST


        case tidCREATESUBSCRIBE:
            // Whether we succeeded or not, free the CREATE_FOLDER_INFO
            // (We're at the end of the create folder sequence)
            if (NULL != lParam)
                fCreateDone = TRUE;

            // Remove this folder from LISTed folder list, if we were listing folders (this
            // way the special folder we created doesn't get marked as unsubscribed)
            if (NULL != m_pListHash && NULL != lParam)
            {
                CREATE_FOLDER_INFO *pcfiCreateInfo = (CREATE_FOLDER_INFO *) lParam;
                FOLDERID            idTemp;

                hrTemp = m_pListHash->Find(
                    ImapUtil_ExtractLeafName(pcfiCreateInfo->pszFullFolderPath, m_cRootHierarchyChar),
                    fREMOVE, (void **) &idTemp);
                TraceError(hrTemp);
            }

            // Check for errors.
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPCreateSubscribeFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            else if (NULL != lParam)
            {
                // Update the subscription status on the folder
                IxpAssert(FOLDERID_INVALID != ((CREATE_FOLDER_INFO *)lParam)->idFolder);
                hrCompletionResult = m_pStore->SubscribeToFolder(
                    ((CREATE_FOLDER_INFO *)lParam)->idFolder, fSUBSCRIBE, NOSTORECALLBACK);
                TraceError(hrCompletionResult);
            }

            break; // case tidCREATESUBSCRIBE


        case tidDELETEFLDR:
            DELETE_FOLDER_INFO *pdfi;

            pdfi = (DELETE_FOLDER_INFO *)lParam;
            if (SUCCEEDED(hrCompletionResult))
            {
                // Unsubscribe the folder to complete the delete process
                _EnqueueOperation(tidDELETEFLDR_UNSUBSCRIBE, lParam, icUNSUBSCRIBE_COMMAND,
                    pdfi->pszFullFolderPath, uiNORMAL_PRIORITY);
            }
            else
            {
                // If I unsubscribe a failed delete, user might never realize he has this
                // folder kicking around. Therefore, don't unsubscribe.

                // We won't be needing this information, anymore
                if (pdfi)
                {
                    MemFree(pdfi->pszFullFolderPath);
                    MemFree(pdfi);
                }

                // Inform the user of the error
                IxpAssert(SOT_DELETE_FOLDER == m_sotCurrent);
                sotOpType = m_sotCurrent;
                pCallback = m_pCurrentCB;
                fCompletion = TRUE;
                LoadString(g_hLocRes, idsIMAPDeleteFldrFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidDELETEFLDR


        case tidDONT_CARE:
            hrCompletionResult = S_OK; // Suppress all error
            break;

        case tidDELETEFLDR_UNSUBSCRIBE:
            // This folder is already deleted, so even if unsubscribe fails, delete from cache
            fDelFldrFromCache = TRUE;

            // Inform the user of any errors
            if (FAILED(hrCompletionResult))
            {
                LoadString(g_hLocRes, idsIMAPDeleteFldrUnsubFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidDELETEFLDR_UNSUBSCRIBE

        case tidCLOSE:
            fCompletion = TRUE;
            OnFolderExit();
            m_issCurrent = issAuthenticated;
            hrCompletionResult = S_OK; // Suppress error
            break;

        case tidSUBSCRIBE:
        {
            UINT uiErrorFmtID; // In case of error

            uiErrorFmtID = 0;
            fCompletion = TRUE;
            if (SUCCEEDED(hrCompletionResult))
            {
                IxpAssert(FOLDERID_INVALID != m_idCurrent);

                // Update store subscription status
                hrCompletionResult = m_pStore->SubscribeToFolder(m_idCurrent, m_fSubscribe, NOSTORECALLBACK);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    uiErrorFmtID = m_fSubscribe ? idsIMAPSubscrAddErrorFmt :
                        idsIMAPUnsubRemoveErrorFmt;
                }
            }
            else
            {
                TraceResult(hrCompletionResult);
                uiErrorFmtID = m_fSubscribe ? idsIMAPSubscribeFailedFmt : idsIMAPUnsubscribeFailedFmt;
            }

            // Load error message, if an error occurred
            if (FAILED(hrCompletionResult))
            {
                FOLDERINFO  fiFolderInfo;

                LoadString(g_hLocRes, uiErrorFmtID, szFmt, ARRAYSIZE(szFmt));
                hrTemp = m_pStore->GetFolderInfo(m_idCurrent, &fiFolderInfo);
                if (FAILED(hrTemp))
                {
                    // Time to lie, cheat and STEAL!!!
                    TraceResult(hrTemp);
                    ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));
                    fiFolderInfo.pszName = PszDupA(c_szFolderV1);
                }
                wnsprintf(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), szFmt, fiFolderInfo.pszName);
                m_pStore->FreeRecord(&fiFolderInfo);
            } // if (FAILED(hrCompletionResult))
        } // case tidSUBSCRIBE
            break; // case tidSUBSCRIBE


        case tidRENAME:
        case tidRENAMESUBSCRIBE:
        case tidRENAMELIST:
        case tidRENAMERENAME:
        case tidRENAMESUBSCRIBE_AGAIN:
        case tidRENAMEUNSUBSCRIBE:
            hrCompletionResult = RenameSequencer(tid, lParam, hrCompletionResult,
                lpszResponseText, &fCompletion);
            break; // Rename operations


        case tidSTATUS:
            IxpAssert(FOLDERID_INVALID != (FOLDERID)lParam);
            fCompletion = TRUE;

            if (FAILED(hrCompletionResult))
            {
                FOLDERINFO  fiFolderInfo;

                // Construct descriptive error message
                LoadString(g_hLocRes, idsGetUnreadCountFailureFmt, szFmt, ARRAYSIZE(szFmt));
                if (SUCCEEDED(m_pStore->GetFolderInfo((FOLDERID) lParam, &fiFolderInfo)))
                {
                    wnsprintf(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), szFmt, fiFolderInfo.pszName, m_szAccountName);
                    m_pStore->FreeRecord(&fiFolderInfo);
                }
            }
            break;

        default:
            AssertSz(FALSE, "Unhandled transaction ID!");
            break; // default case
    }


    // If we've finished a create folder (success/failure), tell them he can nuke us, now
    if (fCreateDone)
    {
        CREATE_FOLDER_INFO *pcfiCreateInfo = (CREATE_FOLDER_INFO *)lParam;

        if (FOLDER_NOTSPECIAL == pcfiCreateInfo->dwFinalSfType)
        {
            IxpAssert(SOT_INVALID != m_sotCurrent);
            IxpAssert(PCO_NONE == pcfiCreateInfo->pcoNextOp); // Regular fldr creation no longer has any post-ops

            fCompletion = TRUE;
            pCallback = m_pCurrentCB;
            sotOpType = m_sotCurrent;

            MemFree(pcfiCreateInfo->pszFullFolderPath);
            delete pcfiCreateInfo;
        }
        else
        {
            // We trying to create all the special folders: move on to the next one
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                hrCompletionResult = CreateNextSpecialFolder(pcfiCreateInfo, &fCompletion);
                TraceError(hrCompletionResult);
            }
        }
    }


    // If we've successfully deleted a folder, remove it from the foldercache
    if (fDelFldrFromCache)
    {
        DELETE_FOLDER_INFO *pdfi = (DELETE_FOLDER_INFO *)lParam;

        hrCompletionResult = DeleteFolderFromCache(pdfi->idFolder, fRECURSIVE);
        if (FAILED(hrCompletionResult))
            LoadString(g_hLocRes, idsErrDeleteCachedFolderFail, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));

        MemFree(pdfi->pszFullFolderPath);
        MemFree(pdfi);

        IxpAssert(SOT_DELETE_FOLDER == m_sotCurrent);
        sotOpType = m_sotCurrent;
        pCallback = m_pCurrentCB;
        fCompletion = TRUE;
    }


    // Report command completion
    if (fCompletion)
    {
        CONN_FSM_EVENT  cfeEvent;

        // Report command completion
        if (FAILED(hrCompletionResult))
        {
            if (FALSE == fSuppressDetails)
                StrCpyN(m_szOperationDetails, lpszResponseText, ARRAYSIZE(m_szOperationDetails));

            cfeEvent = CFSM_EVENT_ERROR;
        }
        else
            cfeEvent = CFSM_EVENT_OPERATIONCOMPLETE;

        m_fTerminating = TRUE; // Either event should make us go to CFSM_STATE_OPERATIONCOMPLETE
        m_hrOperationResult = hrCompletionResult;

        // Check for user-induced connection drop, replace with non-UI error code
        if (IXP_E_CONNECTION_DROPPED == hrCompletionResult && m_fDisconnecting)
            m_hrOperationResult = STORE_E_OPERATION_CANCELED;

        hrTemp = _ConnFSM_QueueEvent(cfeEvent);
        TraceError(hrTemp);

        // Might not want to do anything past this point, we might be all released

    }
    else if (CFSM_STATE_WAITFOROPERATIONDONE == m_cfsState)
    {
        // *** TEMPORARY until we remove CIMAPSync queueing code
        do {
            hrTemp = _SendNextOperation(NOFLAGS);
            TraceError(hrTemp);
        } while (S_OK == hrTemp);
    }

    return S_OK;
} // _OnCmdComplete



//***************************************************************************
// Function: DownloadFoldersSequencer
//
// Purpose:
//   This function is a helper function for CmdCompletionNotification. I
// created it because the former function was getting big and unwieldy. I
// probably shouldn't have bothered, but now I'm too lazy to put it back.
// Besides, the comments for this function are going to be HUGE.
// This function contains all of the operations involved in a folder
// hierarchy download. In addition to the actual hierarchy download, this
// includes Root Folder Path (or Prefix) creation, and hierarchy character
// determination (often abbreviated HCF, where "F" is for Finding).
//
// Details: See the end of the module, where many details are provided.
//
// Arguments:
//   WPARAM tid [in] - the wParam associated with this operation.
//   LPARAM lParam [in] - the lParam associated with this operation, if any.
//   HRESULT hrCompletionResult [in] - HRESULT indicating success or failure
//     of the IMAP command.
//   LPSTR lpszResponseText [in] - response text associated with the tagged
//     response from the IMAP server.
//   LPBOOL pfCompletion [out] - set to TRUE if current operation is finished.
//
// Returns:
//   HRESULT indicating success or failure. This return value should be
// assigned to hrCompletionResult so that errors are displayed and the
// dialog taken down.
//***************************************************************************
HRESULT CIMAPSync::DownloadFoldersSequencer(const WPARAM wpTransactionID,
                                            const LPARAM lParam,
                                            HRESULT hrCompletionResult,
                                            const LPCSTR lpszResponseText,
                                            LPBOOL pfCompletion)
{
    HRESULT hrTemp;

    TraceCall("CIMAPSync::CIMAPFolderMgr::DownloadFoldersSequencer");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);
    IxpAssert(SOT_SYNCING_STORE == m_sotCurrent || SOT_PUT_MESSAGE == m_sotCurrent);
    IxpAssert(NULL != pfCompletion);
    IxpAssert(FALSE == *pfCompletion);

    // Initialize variables
    m_szOperationProblem[0] = '\0';

    // Take action on the completion of certain commands
    switch (wpTransactionID)
    {
        case tidPREFIXLIST:
            AssertSz('\0' != m_szRootFolderPrefix[0], "You tried to list a blank folder. Brilliant.");
            if (SUCCEEDED(hrCompletionResult))
            {
                // If we're looking for root-lvl hierarchy char, maybe this listing will help
                if (NULL != m_phcfHierarchyCharInfo)
                    FindRootHierarchyChar(fHCF_PLAN_A_ONLY, lParam);

                if (INVALID_HIERARCHY_CHAR == m_cRootHierarchyChar)
                {
                    AssertSz(FALSE == m_fPrefixExists, "This doesn't make sense. Where's my HC?");
                    // List top level of hierarchy for hierarchy char determination
                    hrCompletionResult = _EnqueueOperation(tidPREFIX_HC, lParam,
                        icLIST_COMMAND, g_szPercent, uiNORMAL_PRIORITY);
                    TraceError(hrCompletionResult);
                }
                else
                {
                    // We don't need to find HC - list the prefixed hierarchy or create prefix
                    if (m_fPrefixExists)
                    {
                        char szBuf[CCHMAX_IMAPFOLDERPATH+3];

                        // Prefix exists, so list it (only fixed buffers, so limited overflow risk)
                        wnsprintf(szBuf, ARRAYSIZE(szBuf), "%.512s%c*", m_szRootFolderPrefix, m_cRootHierarchyChar);
                        hrCompletionResult = _EnqueueOperation(tidFOLDERLIST, lParam,
                            icLIST_COMMAND, szBuf, uiNORMAL_PRIORITY);
                        TraceError(hrCompletionResult);
                    }
                    else
                    {
                        // Prefix doesn't exist, better create it
                        hrCompletionResult = CreatePrefix(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), lParam, pfCompletion);
                        TraceError(hrCompletionResult);
                    }
                }
            }
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidPREFIXLIST


        case tidPREFIX_HC:
            if (SUCCEEDED(hrCompletionResult))
            {
                // If we're looking for root-lvl hierarchy char, maybe this listing will help
                AssertSz(NULL != m_phcfHierarchyCharInfo, "Why LIST % if you already KNOW HC?")
                FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

                // If Plan A for LIST % was sufficient to find HC, create prefix
                if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
                {
                    hrCompletionResult = CreatePrefix(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), lParam, pfCompletion);
                    TraceError(hrCompletionResult);
                }
                // else - Plan B has already been launched. Wait for its completion.
            }
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidPREFIX_HC


        case tidHIERARCHYCHAR_LIST_B:
            // I don't care if this succeeded or failed. FindRootHierarchyChar will launch Plan C,
            // if necessary. Suppress error-reporting due to failed tidHIERARCHYCHAR_LIST_B
            IxpAssert(NULL != m_phcfHierarchyCharInfo);
            IxpAssert(hcfPLAN_B == m_phcfHierarchyCharInfo->hcfStage);
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress error-reporting - don't take down dialog
                else
                    break;
            }

            FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

            // If we found the hierarchy char, proceed with prefix OR special folder creation
            if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
            {
                hrCompletionResult = PostHCD(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), lParam, pfCompletion);
                TraceError(hrCompletionResult);
            }
            // else - Plan C has already been launched. Wait for its completion
            break; // case tidHIERARCHYCHAR_LIST_B


        case tidHIERARCHYCHAR_CREATE:
            IxpAssert(NULL != m_phcfHierarchyCharInfo);
            IxpAssert(hcfPLAN_C == m_phcfHierarchyCharInfo->hcfStage);
            if (SUCCEEDED(hrCompletionResult))
            {
                // Try to list the folder for its juicy hierarchy char
                hrCompletionResult = _EnqueueOperation(tidHIERARCHYCHAR_LIST_C, lParam,
                    icLIST_COMMAND, m_phcfHierarchyCharInfo->szTempFldrName,
                    uiNORMAL_PRIORITY);
                TraceError(hrCompletionResult);
            }
            else if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
            {
                // Try the next plan in the list (which should succeed), and create prefix/special fldrs
                TraceResult(hrCompletionResult);
                FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

                AssertSz(NULL == m_phcfHierarchyCharInfo,
                    "HEY, you added a new hierarchy char search plan and you didn't TELL ME!?");
                hrCompletionResult = PostHCD(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), lParam, pfCompletion);
                TraceError(hrCompletionResult);
            }
            break; // case tidHIERARCHYCHAR_CREATE


        case tidHIERARCHYCHAR_LIST_C:
            // I don't care if this succeeded or failed. Defer check for hierarchy
            // char, we MUST delete the temp fldr, for now
            IxpAssert(NULL != m_phcfHierarchyCharInfo);
            IxpAssert(hcfPLAN_C == m_phcfHierarchyCharInfo->hcfStage);
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress default error-handling - don't take down dialog
                else
                    break;
            }

            hrCompletionResult = _EnqueueOperation(tidHIERARCHYCHAR_DELETE, lParam,
                icDELETE_COMMAND, m_phcfHierarchyCharInfo->szTempFldrName, uiNORMAL_PRIORITY);
            TraceError(hrCompletionResult);
            break; // case tidHIERARCHYCHAR_LIST_C


        case tidHIERARCHYCHAR_DELETE:
            if (FAILED(hrCompletionResult))
            {
                TraceError(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress error
                else
                    break;
            }
            // Look for hierarchy char - doesn't matter if delete failed, or not
            FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);
            AssertSz(NULL == m_phcfHierarchyCharInfo,
                "HEY, you added a new hierarchy char search plan and you didn't TELL ME!?");

            // Proceed with prefix/special folder creation (I assume I've found the hierarchy char)
            AssertSz(INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar,
                "By this stage, I should have a HC - an assumed one, if necessary.");
            hrCompletionResult = PostHCD(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem),
                lParam, pfCompletion);
            TraceError(hrCompletionResult);
            break; // case tidHIERARCHYCHAR_DELETE


        case tidFOLDERLIST:
            if (SUCCEEDED(hrCompletionResult))
            {
                char szBuf[CCHMAX_IMAPFOLDERPATH+3];

                // Launch LSUB * or LSUB <prefix>/* as appropriate
                if ('\0' != m_szRootFolderPrefix[0])
                    // Construct prefix + * (only fixed buffers, so limited overflow risk)
                    wnsprintf(szBuf, ARRAYSIZE(szBuf), "%.512s%c*", m_szRootFolderPrefix, m_cRootHierarchyChar);
                else
                {
                    szBuf[0] = '*';
                    szBuf[1] = '\0';
                }

                hrCompletionResult = _EnqueueOperation(tidFOLDERLSUB, lParam,
                    icLSUB_COMMAND, szBuf, uiNORMAL_PRIORITY);
                TraceError(hrCompletionResult);
            }
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidFOLDERLIST


        case tidPREFIX_CREATE:
            if (FAILED(hrCompletionResult))
            {
                char szFmt[2*CCHMAX_STRINGRES];

                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPPrefixCreateFailedFmt, szFmt, ARRAYSIZE(szFmt));
                wnsprintf(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), szFmt, m_szRootFolderPrefix);
                break;
            }

            // Check if we need to create special folders
            m_fPrefixExists = TRUE; // Make sure PostHCD creates special fldrs instead of the prefix
            hrCompletionResult = PostHCD(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), lParam, pfCompletion);
            if (FAILED(hrCompletionResult) || FALSE == *pfCompletion)
            {
                // We're not ready to sync deleted folders just yet: special folders are being created
                break;
            }

            // If we reached this point, tidPREFIX_CREATE was successful:
            // Prefix was created. No need to list its hierarchy (it has none),
            // and we'll assume it can take Inferiors. We're DONE!

            // *** FALL THROUGH to tidFOLDERLSUB, to sync deleted folders ***

        case tidFOLDERLSUB:
            if (SUCCEEDED(hrCompletionResult))
            {
                if (NULL != m_phcfHierarchyCharInfo)
                    FindRootHierarchyChar(fHCF_ALL_PLANS, lParam);

                if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
                {
                    if (m_fCreateSpecial)
                    {
                        // We now have the hierarchy character (required to create special folders).
                        // Create special folders
                        hrCompletionResult = PostHCD(m_szOperationProblem, ARRAYSIZE(m_szOperationProblem), lParam, pfCompletion);
                        if (FAILED(hrCompletionResult))
                        {
                            TraceResult(hrCompletionResult);
                            break;
                        }
                    }
                    else
                    {
                        EndFolderList();

                        // Close the download folders dialog, IF we've found the hierarchy char
                        // If HC not found, Plan B has already been launched, so wait for its completion
                        if (FOLDERID_INVALID == (FOLDERID)lParam)
                        {
                            Assert(INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar);
                            *pfCompletion = TRUE;
                        }
                    }
                } // if (INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar)
            } // if (SUCCEEDED(hrCompletionResult))
            else
            {
                // Inform the user of the error.
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidFOLDERLSUB

        case tidSPECIALFLDRSUBSCRIBE:
            // Regardless of success/failure, subscribe this special folder locally!
            hrTemp = m_pStore->SubscribeToFolder(((CREATE_FOLDER_INFO *)lParam)->idFolder,
                fSUBSCRIBE, NOSTORECALLBACK);
            TraceError(hrTemp);
            hrCompletionResult = S_OK; // Suppress error

            // *** FALL THROUGH ***

        case tidSPECIALFLDRLIST:
        case tidSPECIALFLDRLSUB:
            if (SUCCEEDED(hrCompletionResult) || IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                hrCompletionResult = CreateNextSpecialFolder((CREATE_FOLDER_INFO *)lParam, pfCompletion);

            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsCreateSpecialFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }
            break; // case tidSPECIALFLDRLIST, tidSPECIALFLDRLSUB, tidSPECIALFLDRSUBSCRIBE


        default:
            AssertSz(FALSE, "Hey, why is DownloadFoldersSequencer getting called?");
            break; // default case
    }; // switch (wpTransactionID)

    if (FAILED(hrCompletionResult))
    {
        *pfCompletion = TRUE;
        DisposeOfWParamLParam(wpTransactionID, lParam, hrCompletionResult);
    }

    return hrCompletionResult;
} // DownloadFoldersSequencer

// Details for DownloadFoldersSequencer (1/16/97, raych)
// ------------------------------------
// DownloadFoldersSequencer implements a somewhat complicated flow of execution.
// For a map of the execution flow, you can either create one from the function,
// or look on pp. 658-659 of my logbook. In any case, you can basically divide
// the execution flow into two categories, one for a prefixed account (ie, one
// with a Root Folder Path), and the flow for a non-prefixed account.
//
// (12/02/1998): This code is getting unmaintainable, but previous attempts to
// clean it up failed due to insufficient time. If you get the chance to re-write
// then please do. The process is greatly simplified if we assume IMAP4rev1 servers
// because then hierarchy character determination becomes a straightforward matter.
//
// For a non-prefixed account, the longest possible path is:
// 1) tidFOLDERLSUB (LIST *), syncs deleted msgs
// 2) tidHIERARCHYCHAR_LIST_B   3) tidHIERARCHYCHAR_CREATE
// 4) tidHIERARCHYCHAR_LIST_C   5) tidHIERARCHYCHAR_DELETE
// 6) Special Folder Creation (END).
//
// For a prefixed account, where the prefix already exists:
// 1) tidPREFIXLIST - this WILL discover HC
// 2) tidFOLDERLSUB (LIST <PREFIX><HC>*), syncs deleted msgs
// 3) Special Folder Creation (END).
//
// For a prefixed account, where the prefix does not exist:
// 1) tidPREFIXLIST
// 2) tidPREFIX_HC              3) tidHIERARCHYCHAR_LIST_B
// 4) tidHIERARCHYCHAR_CREATE   5) tidHIERARCHYCHAR_LIST_C
// 6) tidHIERARCHYCHAR_DELETE   7) tidPREFIX_CREATE, syncs deleted msgs
// 8) Special Folder Creation (END).



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::PostHCD(LPSTR pszErrorDescription,
                           DWORD dwSizeOfErrorDescription,
                           LPARAM lParam, LPBOOL pfCompletion)
{
    HRESULT             hrResult;
    CREATE_FOLDER_INFO *pcfiCreateInfo;

    // First, we try to create the prefix
    hrResult = CreatePrefix(pszErrorDescription, dwSizeOfErrorDescription,
        lParam, pfCompletion);

    if (FAILED(hrResult) || (SUCCEEDED(hrResult) && FALSE == *pfCompletion))
    {
        // Either we successfully launched tidPREFIX_CREATE or something failed.
        // Return as if caller had called CreatePrefix directly.
        goto exit;
    }

    // At this point, CreatePrefix has told us that we do not need to create a prefix
    Assert(TRUE == *pfCompletion);
    Assert(SUCCEEDED(hrResult));

    // Start special folder creation
    pcfiCreateInfo = new CREATE_FOLDER_INFO;
    if (NULL == pcfiCreateInfo)
    {
        hrResult = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    pcfiCreateInfo->pszFullFolderPath = NULL;
    pcfiCreateInfo->idFolder = FOLDERID_INVALID;
    pcfiCreateInfo->dwFlags = 0;
    pcfiCreateInfo->csfCurrentStage = CSF_INIT;
    pcfiCreateInfo->dwCurrentSfType = FOLDER_INBOX;
    pcfiCreateInfo->dwFinalSfType = FOLDER_MAX - 1;
    pcfiCreateInfo->lParam = (LPARAM) FOLDERID_INVALID;
    pcfiCreateInfo->pcoNextOp = PCO_NONE;

    hrResult = CreateNextSpecialFolder(pcfiCreateInfo, pfCompletion);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    m_fCreateSpecial = FALSE;

exit:
    return hrResult;
}



//***************************************************************************
// Function: CreatePrefix
//
// Purpose:
//   This function is called after the hierarchy character is found. If the
// user specified a prefix, this function creates it. Otherwise, it takes
// down the dialog box (since HC discovery is the last step for non-prefixed
// accounts).
//
// Arguments:
//   LPSTR pszErrorDescription [out] - if an error is encountered, this
//     function deposits a description into this output buffer.
//   DWORD dwSizeOfErrorDescription [in] - size of pszErrorDescription.
//   LPARAM lParam [in] - lParam to issue with IMAP command.
//
// Returns:
//   HRESULT indicating success or failure. This return value should be
// assigned to hrCompletionResult so that errors are displayed and the
// dialog taken down.
//***************************************************************************
HRESULT CIMAPSync::CreatePrefix(LPSTR pszErrorDescription,
                                DWORD dwSizeOfErrorDescription,
                                LPARAM lParam, LPBOOL pfCompletion)
{
    char    szBuf[CCHMAX_IMAPFOLDERPATH+2];
    HRESULT hr = S_OK;

    TraceCall("CIMAPSync::CreatePrefix");
    IxpAssert(m_cRef > 0);
    AssertSz(INVALID_HIERARCHY_CHAR != m_cRootHierarchyChar,
        "How do you intend to create a prefix when you don't know HC?");
    IxpAssert(NULL != pfCompletion);
    IxpAssert(FALSE == *pfCompletion);

    // Check if there IS a prefix to create
    if ('\0' == m_szRootFolderPrefix[0] || m_fPrefixExists)
    {
        // No prefix to create. We are done: we've discovered the hierarchy character
        *pfCompletion = TRUE;
        goto exit;
    }

    // Create the prefix
    if ('\0' != m_cRootHierarchyChar)
    {
        wnsprintf(szBuf, ARRAYSIZE(szBuf), "%.512s%c", m_szRootFolderPrefix, m_cRootHierarchyChar);
        hr = _EnqueueOperation(tidPREFIX_CREATE, lParam, icCREATE_COMMAND,
            szBuf, uiNORMAL_PRIORITY);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }
    }
    else
    {
        // We have a prefix on a non-hierarchical IMAP server!
        LoadString(g_hLocRes, idsIMAPNoHierarchyLosePrefix, pszErrorDescription, dwSizeOfErrorDescription);
        hr = TraceResult(hrIMAP_E_NoHierarchy);
        goto exit;
    }

exit:
    return hr;
}



void CIMAPSync::EndFolderList(void)
{
    HRESULT hrTemp;

    // Folder DL complete: Delete any folders in foldercache which weren't LISTed
    // and unsubscribe any folders which weren't LSUBed
    if (NULL != m_pCurrentHash)
    {
        hrTemp = DeleteHashedFolders(m_pCurrentHash);
        TraceError(hrTemp);
    }

    if (NULL != m_pListHash)
    {
        hrTemp = UnsubscribeHashedFolders(m_pStore, m_pListHash);
        TraceError(hrTemp);
    }
}



//***************************************************************************
// Function: RenameSequencer
//
// Purpose:
//   This function is a helper function for CmdCompletionNotification. It
// contains all of the sequencing operations required to perform a folder
// rename. For details, see the end of the function.
//
// Arguments:
//   Same as for CmdCompletionNotification.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::RenameSequencer(const WPARAM wpTransactionID,
                                   const LPARAM lParam,
                                   HRESULT hrCompletionResult,
                                   LPCSTR lpszResponseText,
                                   LPBOOL pfDone)
{
    CRenameFolderInfo *pRenameInfo;
    BOOL fRenameDone;

    TraceCall("CIMAPSync::RenameSequencer");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lpszResponseText);

    // Initialize variables
    pRenameInfo = (CRenameFolderInfo *) lParam;
    fRenameDone = FALSE;
    *pfDone = FALSE;

    // Take action on the completion of certain commands
    switch (wpTransactionID)
    {
        case tidRENAME:
            if (SUCCEEDED(hrCompletionResult))
            {
                // Update the foldercache (ignore errors, it reports them itself)
                // Besides, user can hopefully fix foldercache errors by refreshing folderlist

                // Assume server did a hierarchical rename: if not, we fix
                hrCompletionResult = m_pStore->RenameFolder(pRenameInfo->idRenameFolder,
                    ImapUtil_ExtractLeafName(pRenameInfo->pszNewFolderPath,
                    pRenameInfo->cHierarchyChar), NOFLAGS, NOSTORECALLBACK);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    lpszResponseText = c_szEmpty; // This isn't applicable anymore
                    LoadString(g_hLocRes, idsIMAPRenameFCUpdateFailure, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                    fRenameDone = TRUE; // This puts a damper on things, yes?
                    break;
                }

                // Subscribe the renamed tree
                hrCompletionResult = RenameTreeTraversal(tidRENAMESUBSCRIBE,
                    pRenameInfo, fINCLUDE_RENAME_FOLDER);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    lpszResponseText = c_szEmpty; // This isn't applicable anymore
                    LoadString(g_hLocRes, idsIMAPRenameSubscribeFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                    fRenameDone = TRUE;
                    break;
                }

                // List the old tree to see if it still exists (exclude renamed fldr)
                hrCompletionResult = RenameTreeTraversal(tidRENAMELIST,
                    pRenameInfo, fEXCLUDE_RENAME_FOLDER);
                if (FAILED(hrCompletionResult))
                {
                    TraceResult(hrCompletionResult);
                    lpszResponseText = c_szEmpty; // This isn't applicable anymore
                    // Let's reuse the string for folder list failure
                    LoadString(g_hLocRes, idsIMAPFolderListFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                }

                // Arm the trigger for Phase Two launch
                pRenameInfo->fPhaseOneSent = TRUE;
            } // if (SUCCEEDED(hrCompletionResult))
            else
            {
                // Inform the user of any errors
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPRenameFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                fRenameDone = TRUE;
            }
            break; // case tidRENAME


        case tidRENAMESUBSCRIBE:
            // Count the number of failed subscriptions
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                pRenameInfo->iNumFailedSubs += 1;

                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress failure report
            }

            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Decrement subscribe response counter, Watch for phase 2 launch condition
            pRenameInfo->iNumSubscribeRespExpected -= 1;
            if (0 == pRenameInfo->iNumSubscribeRespExpected)
            {
                HRESULT hrTemp;

                // Theoretically, all subfolders of renamed folder are now subscribed
                hrTemp = SubscribeSubtree(pRenameInfo->idRenameFolder, fSUBSCRIBE);
                TraceError(hrTemp);
            }

            if (EndOfRenameFolderPhaseOne(pRenameInfo) && SUCCEEDED(hrCompletionResult))
            {
                // It is time to start the next phase of the operation
                hrCompletionResult = RenameFolderPhaseTwo(pRenameInfo, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                TraceError(hrCompletionResult);
            }
            break; // case tidRENAMESUBSCRIBE


        case tidRENAMELIST:
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                if (IXP_E_IMAP_TAGGED_NO_RESPONSE == hrCompletionResult)
                    hrCompletionResult = S_OK; // Suppress failure report
            }

            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Count the number of list responses returned. Watch for phase 2 launch condition
            pRenameInfo->iNumListRespExpected -= 1;
            if (EndOfRenameFolderPhaseOne(pRenameInfo) && SUCCEEDED(hrCompletionResult))
            {
                // It is time to start the next phase of the operation
                hrCompletionResult = RenameFolderPhaseTwo(pRenameInfo, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
                TraceError(hrCompletionResult);
            }
            break; // case tidRENAMELIST

        case tidRENAMERENAME:
            // Failure will not be tolerated
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                LoadString(g_hLocRes, idsIMAPAtomicRenameFailed, m_szOperationProblem, ARRAYSIZE(m_szOperationProblem));
            }

            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Decrement the (second) rename counts, watch for phase 2 launch condition
            pRenameInfo->iNumRenameRespExpected -= 1;
            if (EndOfRenameFolderPhaseTwo(pRenameInfo))
                fRenameDone = TRUE;
            break; // tidRENAMERENAME


        case tidRENAMESUBSCRIBE_AGAIN:
            // Modify the number of failed subscriptions based on success
            if (SUCCEEDED(hrCompletionResult))
                pRenameInfo->iNumFailedSubs -= 1;
            else
                pRenameInfo->iNumFailedSubs += 1;

            hrCompletionResult = S_OK; // Suppress failure report
            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Count the number of subscribe responses returned, watch for end-of-operation
            pRenameInfo->iNumSubscribeRespExpected -= 1;
            if (0 == pRenameInfo->iNumSubscribeRespExpected)
            {
                // Theoretically, all subfolders of renamed folder are now subscribed
                hrCompletionResult = SubscribeSubtree(pRenameInfo->idRenameFolder, fSUBSCRIBE);
                TraceError(hrCompletionResult);
            }

            if (EndOfRenameFolderPhaseTwo(pRenameInfo))
                fRenameDone = TRUE;
            break; // case tidRENAMESUBSCRIBE_AGAIN


        case tidRENAMEUNSUBSCRIBE:
            // Count the number of failed unsubscribe's, to report to user at end-of-operation
            if (FAILED(hrCompletionResult))
            {
                TraceResult(hrCompletionResult);
                pRenameInfo->iNumFailedUnsubs += 1;
            }

            hrCompletionResult = S_OK; // Suppress failure report
            lpszResponseText = c_szEmpty; // This isn't applicable anymore

            // Count the number of unsubscribe responses returned, watch for end-of-operation
            pRenameInfo->iNumUnsubscribeRespExpected -= 1;
            if (EndOfRenameFolderPhaseTwo(pRenameInfo))
                fRenameDone = TRUE;
            break; // case tidRENAMEUNSUBSCRIBE

        default:
            AssertSz(FALSE, "This is not an understood rename operation.");
            break; // default case

    } // switch (wpTransactionID)

    // That's one less rename command pending from the server
    pRenameInfo->Release();

    *pfDone = fRenameDone;
    return hrCompletionResult;
} // RenameSequencer

// Details for RenameSequencer (2/4/97, raych)
// ---------------------------
// A rename operation includes the original rename, subscription tracking, and
// atomic rename simulation (for Cyrus servers). To perform this, the rename
// operation is divided into two phases:
//
// PHASE ONE:
//   1) Assume rename was atomic. Subscribe new (renamed) folder hierarchy.
//   2) List first child of old rename folder, to check if rename was in fact atomic.
//
// PHASE TWO:
//   1) If rename was not atomic, issue a RENAME for each child of rename folder
//      in order to SIMULATE an atomic rename. This does not check for collisions
//      in the renamed space.
//   2) If the rename was not atomic, try to subscribe the new (renamed) folder
//      hierarchy, again.
//   3) Unsubscribe the old folder hierarchy.
//
// What a pain.



//***************************************************************************
// Function: EndOfRenameFolderPhaseOne
//
// Purpose:
//   This function detects whether Phase One of the rename operation has
// completed.
//
// Arguments:
//   CRenameFolderInfo *pRenameInfo [in] - the CRenameFolderInfo associated
//     with the RENAME operation.
//
// Returns:
//   TRUE if Phase One has ended, otherwise FALSE. Phase One cannot end
// if it has not been sent, yet.
//***************************************************************************
inline BOOL CIMAPSync::EndOfRenameFolderPhaseOne(CRenameFolderInfo *pRenameInfo)
{
    if (pRenameInfo->fPhaseOneSent &&
        pRenameInfo->iNumSubscribeRespExpected <= 0 &&
        pRenameInfo->iNumListRespExpected <= 0)
    {
        IxpAssert(0 == pRenameInfo->iNumSubscribeRespExpected);
        IxpAssert(0 == pRenameInfo->iNumListRespExpected);

        return TRUE; // This marks the end of phase one
    }
    else
        return FALSE;
} // EndOfRenameFolderPhaseOne



//***************************************************************************
// Function: EndOfRenameFolderPhaseTwo
//
// Purpose:
//   This function detects whether Phase Two of the rename operation has
// completed.
//
// Arguments:
//   CRenameFolderInfo *pRenameInfo [in] - the CRenameFolderInfo associated
//     with the RENAME operation.
//
// Returns:
//   TRUE if Phase Two has ended, otherwise FALSE. Phase Two cannot end
// if it has not been sent, yet.
//***************************************************************************
inline BOOL CIMAPSync::EndOfRenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo)
{
    if (pRenameInfo->fPhaseTwoSent &&
        pRenameInfo->iNumRenameRespExpected <= 0 &&
        pRenameInfo->iNumSubscribeRespExpected <= 0 &&
        pRenameInfo->iNumUnsubscribeRespExpected <= 0)
    {
        IxpAssert(0 == pRenameInfo->iNumRenameRespExpected);
        IxpAssert(0 == pRenameInfo->iNumSubscribeRespExpected);
        IxpAssert(0 == pRenameInfo->iNumUnsubscribeRespExpected);

        return TRUE; // This marks the end of phase two
    }
    else
        return FALSE;
} // EndOfRenameFolderPhaseTwo



//***************************************************************************
// Function: RenameFolderPhaseTwo
//
// Purpose:
//   This function launches Phase Two of the RENAME operation.
//
// Arguments:
//   CRenameFolderInfo *pRenameInfo [in] - the CRenameFolderInfo associated
//     with the RENAME operation.
//   LPSTR szErrorDescription [in] - if an error occurs, this function
//     deposits a desription in this buffer.
//   DWORD dwSizeOfErrorDescription [in] - size of szErrorDescription.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CIMAPSync::RenameFolderPhaseTwo(CRenameFolderInfo *pRenameInfo,
                                        LPSTR szErrorDescription,
                                        DWORD dwSizeOfErrorDescription)
{
    HRESULT hrCompletionResult;

    // Rename subfolders, re-attempt subscription of renamed tree, exclude rename folder
    if (pRenameInfo->fNonAtomicRename)
    {
        hrCompletionResult = RenameTreeTraversal(tidRENAMERENAME,
            pRenameInfo, fEXCLUDE_RENAME_FOLDER);
        if (FAILED(hrCompletionResult))
        {
            TraceResult(hrCompletionResult);
            LoadString(g_hLocRes, idsIMAPAtomicRenameFailed, szErrorDescription,
                dwSizeOfErrorDescription);
            goto exit;
        }

        hrCompletionResult = RenameTreeTraversal(tidRENAMESUBSCRIBE_AGAIN,
            pRenameInfo, fEXCLUDE_RENAME_FOLDER);
        if (FAILED(hrCompletionResult))
        {
            TraceResult(hrCompletionResult);
            LoadString(g_hLocRes, idsIMAPRenameSubscribeFailed, szErrorDescription,
                dwSizeOfErrorDescription);
            goto exit;
        }
    }

    // Unsubscribe from the old tree, include rename folder
    hrCompletionResult = RenameTreeTraversal(tidRENAMEUNSUBSCRIBE,
        pRenameInfo, fINCLUDE_RENAME_FOLDER);
    if (FAILED(hrCompletionResult))
    {
        TraceResult(hrCompletionResult);
        LoadString(g_hLocRes, idsIMAPRenameUnsubscribeFailed, szErrorDescription,
            dwSizeOfErrorDescription);
        goto exit;
    }

    // Arm the trigger for end-of-operation launch
    pRenameInfo->fPhaseTwoSent = TRUE;

exit:
    return hrCompletionResult;
} // RenameFolderPhaseTwo



//***************************************************************************
// Function: _OnMailBoxList
// Description: Helper function for OnResponse.
//
// This function saves the information from the LIST/LSUB command to the
// folder cache. If the folder already exists in the folder cache, its
// mailbox flags are updated. If it does not exist, a handle (and message
// cache filename) are reserved for the folder, and it is entered into
// the folder cache. This function is also part of the hierarchy character
// determination code. If a hierarchy character is encountered during a
// folder hierarchy download, we assume this is the hierarchy character
// for root-level folders.
//
// Arguments:
//   WPARAM wpTransactionID [in] - the wParam of this operation (eg,
//     tidFOLDERLSUB or tidCREATELIST).
//   LPARAM lParam [in] - the lParam of this operation.
//   LPSTR pszMailboxName [in] - the mailbox name returned via the LIST
//     response, eg "INBOX".
//   IMAP_MBOXFLAGS imfMboxFlags [in] - the mailbox flags returned via the
//     LIST response, eg "\NoSelect".
//   char cHierarchyChar [in] - the hierarchy character returned via the
//     LIST response, eg '/'.
//***************************************************************************
HRESULT CIMAPSync::_OnMailBoxList(  WPARAM tid,
                                    LPARAM lParam,
                                    LPSTR pszMailboxName,
                                    IMAP_MBOXFLAGS imfMboxFlags,
                                    char cHierarchyChar,
                                    BOOL fNoTranslation)
{
    const DWORD dwProgressInterval = 1;

    HRESULT         hr = S_OK;
    FOLDERID        idNewFolder = FOLDERID_INVALID;
    FOLDERID        idTemp = FOLDERID_INVALID;
    BOOL            fHandledLPARAM = FALSE;
    LPSTR           pszLocalPath = NULL;
    BOOL            fValidPrefix;
    SPECIALFOLDER   sfType;
    BOOL            fFreeLocalPath = FALSE;

    TraceCall("CIMAPSync::_OnMailBoxList");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != pszMailboxName);

    // Hierarchy-character determination code
    if (NULL != m_phcfHierarchyCharInfo)
    {
        switch (cHierarchyChar)
        {
            case '\0':
                // If our prefix is not INBOX, we MUST treat NIL as a valid hierarchy char
                if (tidPREFIXLIST == tid ||
                    0 != lstrcmpi(pszMailboxName, c_szInbox))
                    m_phcfHierarchyCharInfo->fNonInboxNIL_Seen = TRUE;
                break;

            case '.':
                m_phcfHierarchyCharInfo->fDotHierarchyCharSeen = TRUE;
                break;

            default:
                // Set the bit in the array which corresponds to this character
                m_phcfHierarchyCharInfo->bHierarchyCharBitArray[cHierarchyChar/8] |=
                    (1 << cHierarchyChar%8);
                break;
        }
    }


    // Remove prefix from full folder path
    pszLocalPath = RemovePrefixFromPath(m_szRootFolderPrefix, pszMailboxName,
        cHierarchyChar, &fValidPrefix, &sfType);

    // Replace leading INBOX with localized folder name
    const int c_iLenOfINBOX = 5; // Let me know if this changes
    Assert(lstrlen(c_szINBOX) == c_iLenOfINBOX);
    if (0 == StrCmpNI(pszLocalPath, c_szINBOX, c_iLenOfINBOX))
    {
        char cNextChar;

        cNextChar = pszLocalPath[c_iLenOfINBOX];
        if ('\0' == cNextChar || cHierarchyChar == cNextChar)
        {
            BOOL    fResult;
            int     iLocalizedINBOXLen;
            int     cchNewPathLen;
            char    szInbox[CCHMAX_STRINGRES];
            LPSTR   pszNew;

            // We found INBOX or INBOX<HC>: replace INBOX with localized version
            Assert(FOLDER_INBOX == sfType || '\0' != cNextChar);
            iLocalizedINBOXLen = LoadString(g_hLocRes, idsInbox, szInbox, ARRAYSIZE(szInbox));

            cchNewPathLen = iLocalizedINBOXLen + lstrlen(pszLocalPath + c_iLenOfINBOX) + 1;
            fResult = MemAlloc((void **)&pszNew, cchNewPathLen * sizeof(pszNew[0]));
            if (FALSE == fResult)
            {
                hr = TraceResult(E_OUTOFMEMORY);
                goto exit;
            }

            StrCpyN(pszNew, szInbox, cchNewPathLen);
            StrCatBuff(pszNew, (pszLocalPath + c_iLenOfINBOX), cchNewPathLen);

            pszLocalPath = pszNew;
            fFreeLocalPath = TRUE;
        }
    }

    // Add folder to foldercache if current operation warrants it (LIST only, ignore LSUB)
    switch (tid)
    {
        case tidSPECIALFLDRLIST:
        case tidFOLDERLIST:
        case tidCREATELIST:
            if (fValidPrefix && pszLocalPath[0] != '\0')
            {
                DWORD dwAFTCFlags;

                dwAFTCFlags = (fNoTranslation ? AFTC_NOTRANSLATION : 0);
                hr = AddFolderToCache(pszLocalPath, imfMboxFlags, cHierarchyChar,
                    dwAFTCFlags, &idNewFolder, sfType);
                if (FAILED(hr))
                {
                    TraceResult(hr);
                    goto exit;
                }
            }
    }


    // Tie up loose ends and exit
    switch (tid)
    {
        // Are we looking for a prefix listing?
        case tidPREFIXLIST:
            IxpAssert(0 == lstrcmpi(pszMailboxName, m_szRootFolderPrefix));
            m_fPrefixExists = TRUE;
            fHandledLPARAM = TRUE;
            goto exit; // Skip addition to foldercache


        case tidRENAMELIST:
            if (NULL != lParam)
            {
                // Well, looks like we have some subfolders to rename
                ((CRenameFolderInfo *)lParam)->fNonAtomicRename = TRUE;
                fHandledLPARAM = TRUE;
            }
            break;


        case tidSPECIALFLDRLIST:
        case tidFOLDERLIST:
        case tidCREATELIST:
            fHandledLPARAM = TRUE;

            // Only act on validly prefixed folders
            if (fValidPrefix && NULL != m_pCurrentHash)
            {
                // Remove LISTed folder from m_pCurrentHash (list of cached folders)
                hr = m_pCurrentHash->Find(pszLocalPath, fREMOVE, (void **)&idTemp);
                if (FAILED(hr))
                {
                    if (FOLDERID_INVALID != idNewFolder)
                        idTemp = idNewFolder;
                    else
                        idTemp = FOLDERID_INVALID;
                }

                // NOTE that it is possible for idTemp != idNewFolder. This occurs if
                // I change RFP from "" to "aaa" and there exists two folders, "bbb" and
                // "aaa/bbb". Believe it or not, this happened to me during rudimentary testing.
                // The correct folder to use in this case is idTemp, which is determined using FULL path

                // Record all LISTed folders in m_pListHash
                if (NULL != m_pListHash)
                {
                    hr = m_pListHash->Insert(pszLocalPath, idTemp, HF_NO_DUPLICATES);
                    TraceError(hr);
                }
            }

            if (tidCREATELIST != tid && FALSE == (tidSPECIALFLDRLIST == tid && NULL != lParam &&
                0 == lstrcmpi(pszMailboxName, ((CREATE_FOLDER_INFO *)lParam)->pszFullFolderPath)))
                break;

            // *** FALL THROUGH if tidCREATELIST, or tidSPECIALFLDRLIST and exact path match ***

            if (NULL != lParam)
            {
                CREATE_FOLDER_INFO *pcfi = (CREATE_FOLDER_INFO *) lParam;

                // Inform cmd completion that it's OK to send the subscribe cmd
                // Also record fldrID of new fldr so we can update store after successful subscribe
                pcfi->dwFlags |= CFI_RECEIVEDLISTING;
                pcfi->idFolder = idNewFolder;
                fHandledLPARAM = TRUE;
            }
            break;

        case tidSPECIALFLDRLSUB:
        case tidFOLDERLSUB:
            // Verify that we already received this folderpath via a LIST response
            // If we DID receive this folder via LIST, remove from m_pListHash
            fHandledLPARAM = TRUE;

            // Only act on validly prefixed folders
            if (fValidPrefix)
            {
                hr = m_pListHash->Find(pszLocalPath, fREMOVE, (void **)&idTemp);
                if (SUCCEEDED(hr))
                {
                    // This folder was received via LIST and thus it exists: subscribe it
                    if (FOLDERID_INVALID != idTemp)
                    {
                        hr = m_pStore->SubscribeToFolder(idTemp, fSUBSCRIBE, NOSTORECALLBACK);
                        TraceError(hr);
                    }
                }
                else
                {
                    DWORD   dwTranslateFlags;
                    HRESULT hrTemp;

                    // This folder was not returned via LIST. Destroy it
                    hrTemp = FindHierarchicalFolderName(pszLocalPath, cHierarchyChar,
                        &idTemp, pahfoDONT_CREATE_FOLDER);
                    if (SUCCEEDED(hrTemp))
                    {
                        // Do record result of this in hr because failure here is not cool
                        hr = DeleteFolderFromCache(idTemp, fNON_RECURSIVE);
                        TraceError(hr);
                    }
                    // if FAILED(hr), we probably never cached this folder, so ignore it

                    // Unsubscribe it regardless of whether it was in the foldercache
                    // If this folder is fNoTranslation, we have to disable translation for this
                    // call to UNSUBSCRIBE. Otherwise IIMAPTransport2 should already have translation enabled
                    hrTemp = S_OK;
                    if (fNoTranslation)
                    {
                        dwTranslateFlags = IMAP_MBOXXLATE_VERBATIMOK | IMAP_MBOXXLATE_RETAINCP |
                                           IMAP_MBOXXLATE_DISABLE;

                        hrTemp = m_pTransport->SetDefaultCP(dwTranslateFlags, 0);
                    }

                    if (SUCCEEDED(hrTemp))
                    {
                        hrTemp = _EnqueueOperation(tidDONT_CARE, 0, icUNSUBSCRIBE_COMMAND,
                            pszMailboxName, uiNORMAL_PRIORITY);
                        TraceError(hrTemp);
                    }

                    // Restore translation mode to default (luckily we always know translation mode
                    // of a folder list)
                    if (fNoTranslation)
                    {
                        dwTranslateFlags &= ~(IMAP_MBOXXLATE_DISABLE);
                        dwTranslateFlags |= IMAP_MBOXXLATE_DEFAULT;
                        hrTemp = m_pTransport->SetDefaultCP(dwTranslateFlags, 0);
                    }
                }
            }

            if (tidSPECIALFLDRLSUB == tid && NULL != lParam &&
                0 == (IMAP_MBOX_NOSELECT & imfMboxFlags))
            {
                // Inform cmd completion that there's no need to subscribe special folder
                if (0 == lstrcmpi(pszMailboxName, ((CREATE_FOLDER_INFO *)lParam)->pszFullFolderPath))
                    ((CREATE_FOLDER_INFO *)lParam)->dwFlags |= CFI_RECEIVEDLISTING;
            }
            break;

        case tidHIERARCHYCHAR_LIST_B:
        case tidHIERARCHYCHAR_LIST_C:
        case tidPREFIX_HC:
            fHandledLPARAM = TRUE;
            break;

        default:
            AssertSz(FALSE, "Unhandled LIST/LSUB operation");
            break;
    }

    // Provide progress indication
    if (SOT_SYNCING_STORE == m_sotCurrent && NULL != m_pCurrentCB)
    {
        // Update progress indication
        m_pCurrentCB->OnProgress(m_sotCurrent, ++m_cFolders, 0, m_szAccountName);
    }

exit:
    IxpAssert(NULL == lParam || fHandledLPARAM || FAILED(hr));
    if (fFreeLocalPath)
        MemFree(pszLocalPath);

    return S_OK;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_OnAppendProgress(LPARAM lParam, DWORD dwCurrent, DWORD dwTotal)
{
    APPEND_SEND_INFO *pAppendInfo = (APPEND_SEND_INFO *) lParam;
    TraceCall("CIMAPSync::OnAppendProgress");
    IxpAssert(m_cRef > 0);
    IxpAssert(NULL != lParam);
    IxpAssert(SOT_PUT_MESSAGE == m_sotCurrent);

    if (NULL != m_pCurrentCB)
    {
        HRESULT hrTemp;
        hrTemp = m_pCurrentCB->OnProgress(SOT_PUT_MESSAGE, dwCurrent, dwTotal, NULL);
        TraceError(hrTemp);
    }
    return S_OK;
}



//***************************************************************************
//***************************************************************************
HRESULT CIMAPSync::_OnStatusResponse(IMAP_STATUS_RESPONSE *pisrStatusInfo)
{
    HRESULT     hrResult;
    FOLDERID    idFolder;
    FOLDERINFO  fiFolderInfo;
    LPSTR       pszMailboxName;
    BOOL        fValidPrefix;
    LONG        lMsgDelta;
    LONG        lUnreadDelta;
    CHAR        szInbox[CCHMAX_STRINGRES];

    TraceCall("CIMAPSync::_OnStatusResponse");
    IxpAssert(m_cRef > 0);

    // Check that we have the data we need
    if (NULL == pisrStatusInfo ||
        NULL == pisrStatusInfo->pszMailboxName ||
        '\0' == pisrStatusInfo->pszMailboxName[0] ||
        FALSE == pisrStatusInfo->fMessages ||
        FALSE == pisrStatusInfo->fUnseen)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Figure out who this folder is (figure from path rather than module var FOLDERID for now)
    // Assume m_cRootHierarchyChar is HC for this mbox, because IMAP doesn't return it
    pszMailboxName = RemovePrefixFromPath(m_szRootFolderPrefix, pisrStatusInfo->pszMailboxName,
        m_cRootHierarchyChar, &fValidPrefix, NULL);
    AssertSz(fValidPrefix, "Foldercache can only select prefixed folders!");

    // bobn, QFE, 7/9/99
    // If we have the INBOX, we need to get the local name...
    if(0 == StrCmpI(pszMailboxName, c_szINBOX))
    {
        LoadString(g_hLocRes, idsInbox, szInbox, ARRAYSIZE(szInbox));
        pszMailboxName = szInbox;
    }

    hrResult = FindHierarchicalFolderName(pszMailboxName, m_cRootHierarchyChar,
        &idFolder, pahfoDONT_CREATE_FOLDER);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = m_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Calculate the number of messages and unread added by this STATUS response
    Assert(sizeof(DWORD) == sizeof(LONG));
    lMsgDelta = ((LONG)pisrStatusInfo->dwMessages) - ((LONG)fiFolderInfo.cMessages);
    lUnreadDelta = ((LONG)pisrStatusInfo->dwUnseen) - ((LONG)fiFolderInfo.cUnread);

    // If this is INBOX, we might just send a new mail notification
    if (FOLDER_INBOX == fiFolderInfo.tySpecial && lUnreadDelta > 0 && NULL != m_pCurrentCB)
    {
        HRESULT hrTemp;

        hrTemp = m_pCurrentCB->OnProgress(SOT_NEW_MAIL_NOTIFICATION, lUnreadDelta, 0, NULL);
        TraceError(hrTemp);
    }

    // Update counts, and update delta so we can un-apply STATUS changes when re-syncing
    fiFolderInfo.cMessages = pisrStatusInfo->dwMessages;
    fiFolderInfo.cUnread = pisrStatusInfo->dwUnseen;
    fiFolderInfo.dwStatusMsgDelta = ((LONG)fiFolderInfo.dwStatusMsgDelta) + lMsgDelta;
    fiFolderInfo.dwStatusUnreadDelta = ((LONG)fiFolderInfo.dwStatusUnreadDelta) + lUnreadDelta;
    hrResult = m_pStore->UpdateRecord(&fiFolderInfo);
    m_pStore->FreeRecord(&fiFolderInfo);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

exit:
    return hrResult;
}



//===========================================================================
// CRenameFolderInfo Class
//===========================================================================
// The CRenameFolderInfo class used to be a structure (much like
// AppendSendInfo). However, the RENAME operation was the first to
// stream IMAP commands without waiting for completion (no sequencing). This
// meant that if any errors occurred while IMAP commands were still in the
// air, the structure had to wait until the last command came back from the
// server. This was most easily done via AddRef/Release. A class was born.
//
// In the event that a send error occurred, this class is responsible for
// issuing the WM_IMAP_RENAMEDONE window message to the caller.

//***************************************************************************
// Function: CRenameFolderInfo (Constructor)
//***************************************************************************
CRenameFolderInfo::CRenameFolderInfo(void)
{
    pszFullFolderPath = NULL;
    cHierarchyChar = INVALID_HIERARCHY_CHAR;
    pszNewFolderPath = NULL;
    idRenameFolder = FOLDERID_INVALID;
    iNumSubscribeRespExpected = 0;
    iNumListRespExpected = 0;
    iNumRenameRespExpected = 0;
    iNumUnsubscribeRespExpected = 0;
    iNumFailedSubs = 0;
    iNumFailedUnsubs = 0;
    fNonAtomicRename = 0;
    pszRenameCmdOldFldrPath = NULL;
    fPhaseOneSent = FALSE;
    fPhaseTwoSent = FALSE;

    hrLastError = S_OK;
    pszProblem = NULL;
    pszDetails = NULL;

    m_lRefCount = 1;
} // CRenameFolderInfo;



//***************************************************************************
// Function: ~CRenameFolderInfo (Destructor)
//***************************************************************************
CRenameFolderInfo::~CRenameFolderInfo(void)
{
    IxpAssert(0 == m_lRefCount);

    MemFree(pszFullFolderPath);
    MemFree(pszNewFolderPath);
    MemFree(pszRenameCmdOldFldrPath);
    SafeMemFree(pszProblem);
    SafeMemFree(pszDetails);
} // ~CRenameFolderInfo



//***************************************************************************
// Function: AddRef (same one that you already know and love)
//***************************************************************************
long CRenameFolderInfo::AddRef(void)
{
    IxpAssert(m_lRefCount > 0);

    m_lRefCount += 1;
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release (same one that you already know and love)
//***************************************************************************
long CRenameFolderInfo::Release(void)
{
    IxpAssert(m_lRefCount > 0);

    m_lRefCount -= 1;

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release



//***************************************************************************
//***************************************************************************
BOOL CRenameFolderInfo::IsDone(void)
{
    if (m_lRefCount > 1)
        return FALSE;
    else
    {
        IxpAssert(1 == m_lRefCount);
        return TRUE;
    }
}



//***************************************************************************
//***************************************************************************
HRESULT CRenameFolderInfo::SetError(HRESULT hrResult, LPSTR pszProblemArg,
                                    LPSTR pszDetailsArg)
{
    HRESULT hr = S_OK;

    TraceCall("CRenameFolderInfo::SetError");
    IxpAssert(FAILED(hrResult));

    hrLastError = hrResult;
    SafeMemFree(pszProblem);
    SafeMemFree(pszDetails);
    if (NULL != pszProblemArg)
    {
        pszProblem = PszDupA(pszProblemArg);
        if (NULL == pszProblem)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
    }

    if (NULL != pszDetailsArg)
    {
        pszDetails = PszDupA(pszDetailsArg);
        if (NULL == pszDetails)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }
    }

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\cmdtargt.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     CmdTargt.h
//
//  PURPOSE:    Defines the GUIDs and command ID's for the IOleCommandTarget
//              interfaces defined in this program.
//

// Defines the GUID for the IOleCommandTarget's used by the views
DEFINE_GUID(CGID_View,     0x89292110L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);

// GCID_View Command Target ID's
enum {
    VCMDID_NEWMAIL = 0                  // Creates a new mail message
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\imap\imapute.h ===
/*
 *    imaputil.h
 *    
 *    Purpose:                     
 *        IMAP utility functions
 *    
 *    Owner:
 *        Raych
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#ifndef __IMAPUTIL_H
#define __IMAPUTIL_H

//---------------------------------------------------------------------------
// Function Prototypes
//---------------------------------------------------------------------------
HRESULT ImapUtil_MsgFlagsToString(IMAP_MSGFLAGS imfSource, LPSTR *ppszDestination,
                                  DWORD *pdwLengthOfDestination);
void ImapUtil_LoadRootFldrPrefix(LPCTSTR pszAccountID, LPSTR pszRootFolderPrefix,
                                 DWORD dwSizeofPrefixBuffer);
HRESULT ImapUtil_FolderIDToPath(FOLDERID idServer, FOLDERID idFolder, char **ppszPath,
                                LPDWORD pdwPathLen, char *pcHierarchyChar,
                                IMessageStore *pFldrCache, LPCSTR pszAppendStr,
                                LPCSTR pszRootFldrPrefix);
HRESULT ImapUtil_SpecialFldrTypeToPath(LPCSTR pszAccount, SPECIALFOLDER sfType,
                                       LPSTR pszRootFldrPrefix, char cHierarchyChar,
                                       LPSTR pszPath, DWORD dwSizeOfPath);
LPSTR ImapUtil_GetSpecialFolderType(LPSTR pszAccountName, LPSTR pszFullPath,
                                    char cHierarchyChar, LPSTR pszRootFldrPrefix,
                                    SPECIALFOLDER *psfType);
HRESULT ImapUtil_UIDToMsgSeqNum(IIMAPTransport *pIMAPTransport, DWORD_PTR dwUID, LPDWORD pdwMsgSeqNum);
LPSTR ImapUtil_ExtractLeafName(LPSTR pszFolderPath, char cHierarchyChar);
void ImapUtil_B2SetDirtyFlag(void);

#endif // __IMAPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\http\httpserv.cpp ===
/*
 *  h t t p s e r v . cpp
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Derives from IMessageServer to implement HTTPMail-specific 
 *           store communication.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "httpserv.h"
#include "httputil.h"
#include "storutil.h"
#include "serverq.h"
#include "tmap.h"
#include "acctcach.h"
#include "urlmon.h"
#include "useragnt.h"
#include "spoolapi.h"
#include "demand.h"

#define CCHMAX_RES 255

static const char s_szHTTPMailServerWndClass[] = "HTTPMailWndClass";

#define AssertSingleThreaded AssertSz(m_dwThreadId == GetCurrentThreadId(), "Multi-threading makes me sad.")

// explicit template instantiations
template class TMap<FOLDERID, CSimpleString>;
template class TPair<FOLDERID, CSimpleString>;

const UINT WM_HTTP_BEGIN_OP = WM_USER;

// SOT_SYNCING_STORE
static const HTTPSTATEFUNCS c_rgpfnSyncStore[] = 
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::ListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL }
};

// SOT_SYNC_FOLDER
static const HTTPSTATEFUNCS c_rgpfnSyncFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::ListHeaders, &CHTTPMailServer::HandleListHeaders },
    { &CHTTPMailServer::PurgeMessages, NULL },
    { &CHTTPMailServer::ResetMessageCounts, NULL }
};

// SOT_GET_MESSAGE
static const HTTPSTATEFUNCS c_rgpfnGetMessage[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::GetMessage, &CHTTPMailServer::HandleGetMessage }
};

// SOT_CREATE_FOLDER
static const HTTPSTATEFUNCS c_rgpfnCreateFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::CreateFolder, &CHTTPMailServer::HandleCreateFolder }
};

// SOT_RENAME_FOLDER
static const HTTPSTATEFUNCS c_rgpfnRenameFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::RenameFolder, &CHTTPMailServer::HandleRenameFolder }
};

// SOT_DELETE_FOLDER
static const HTTPSTATEFUNCS c_rgpfnDeleteFolder[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::DeleteFolder, &CHTTPMailServer::HandleDeleteFolder }
};

// SOT_SET_MESSAGEFLAGS
static const HTTPSTATEFUNCS c_rgpfnSetMessageFlags[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::SetMessageFlags, &CHTTPMailServer::HandleMemberErrors},
    { &CHTTPMailServer::ApplyFlagsToStore, NULL }
};

// SOT_DELETING_MESSAGES
static const HTTPSTATEFUNCS c_rgpfnDeleteMessages[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::DeleteMessages, &CHTTPMailServer::HandleMemberErrors },
    { &CHTTPMailServer::DeleteFallbackToMove, &CHTTPMailServer::HandleDeleteFallbackToMove },
    { &CHTTPMailServer::PurgeDeletedFromStore, NULL }
};

// SOT_PUT_MESSAGE
static const HTTPSTATEFUNCS c_rgpfnPutMessage[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::PutMessage, &CHTTPMailServer::HandlePutMessage },
    { &CHTTPMailServer::AddPutMessage, NULL }
};

// SOT_COPYMOVE_MESSAGES (copying or moving one message)
static const HTTPSTATEFUNCS c_rgpfnCopyMoveMessage[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::CopyMoveMessage, &CHTTPMailServer::HandleCopyMoveMessage }
};

// SOT_COPYMOVE_MESSAGES (moving multiple messages)
static const HTTPSTATEFUNCS c_rgpfnBatchCopyMoveMessages[] =
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMsgFolderRoot, &CHTTPMailServer::HandleGetMsgFolderRoot },
    { &CHTTPMailServer::AutoListFolders, &CHTTPMailServer::HandleListFolders },
    { &CHTTPMailServer::PurgeFolders, NULL },
    { &CHTTPMailServer::BuildFolderUrl, NULL },
    { &CHTTPMailServer::BatchCopyMoveMessages, &CHTTPMailServer::HandleBatchCopyMoveMessages},
    { &CHTTPMailServer::FinalizeBatchCopyMove, NULL }
};

// SOT_GET_ADURL (gets ad url from Hotmail)
static const HTTPSTATEFUNCS c_rgpfnGetAdUrl[] = 
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetAdBarUrlFromServer, NULL }
};


// SOT_GET_HTTP_MINPOLLINGINTERVAL (gets Minimum polling interval from http server)
static const HTTPSTATEFUNCS c_rgpfnGetMinPollingInterval[] = 
{
    { &CHTTPMailServer::Connect, NULL },
    { &CHTTPMailServer::GetMinPollingInterval, NULL }
};

class CFolderList
{
public:
    // Public factory function.
    static HRESULT Create(IMessageStore *pStore, FOLDERID idRoot, CFolderList **ppFolderList);

private:
    // Constructor is private. Use "Create" to instantiate.
    CFolderList();
    ~CFolderList();

private:
    // unimplemented copy constructor/assignment operator
    CFolderList(const CFolderList& other);
    CFolderList& operator=(const CFolderList& other);

public:
    ULONG   AddRef(void);
    ULONG   Release(void);

    FOLDERID    FindAndRemove(LPSTR pszUrlComponent, DWORD *pcMessages, DWORD *pcUnread);
    FOLDERID    FindAndRemove(SPECIALFOLDER tySpecial, DWORD *pcMessages, DWORD *pcUnread);

    void    PurgeRemainingFromStore(void);
private:
    typedef struct tagFOLDERLISTNODE
    {
        LPSTR               pszUrlComponent;
        FLDRFLAGS           dwFlags;
        FOLDERID            idFolder;
        SPECIALFOLDER       tySpecial;
        DWORD               cMessages;
        DWORD               cUnread;
        tagFOLDERLISTNODE   *pflnNext;
    } FOLDERLISTNODE, *LPFOLDERLISTNODE;

    LPFOLDERLISTNODE _AllocNode(void)
    {
        LPFOLDERLISTNODE pflnNode = new FOLDERLISTNODE;
        if (pflnNode)
        {
            pflnNode->pszUrlComponent = NULL;
            pflnNode->dwFlags = 0;
            pflnNode->idFolder = FOLDERID_INVALID;
            pflnNode->tySpecial = FOLDER_NOTSPECIAL;
            pflnNode->cMessages = 0;
            pflnNode->cUnread = 0;
            pflnNode->pflnNext = NULL;
        }
        return pflnNode;
    }
    
    HRESULT HrInitialize(IMessageStore *pStore, FOLDERID idRoot);

    void _FreeNode(LPFOLDERLISTNODE pflnNode)
    {
        if (pflnNode)
        {
            SafeMemFree(pflnNode->pszUrlComponent);
            delete pflnNode;
        }
    }

    void _FreeList(void);

private:
    ULONG               m_cRef;
    IMessageStore       *m_pStore;
    LPFOLDERLISTNODE    m_pflnList;
};

//----------------------------------------------------------------------
// CFolderList::Create
//----------------------------------------------------------------------

HRESULT CFolderList::Create(IMessageStore *pStore, FOLDERID idRoot, CFolderList **ppFolderList)
{
    HRESULT     hr = S_OK;
    CFolderList *pFolderList = NULL;

    if (NULL == pStore || FOLDERID_INVALID == idRoot || NULL == ppFolderList)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    *ppFolderList = NULL;
    pFolderList = new CFolderList();
    if (!pFolderList)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    IF_FAILEXIT(hr = pFolderList->HrInitialize(pStore, idRoot));

    *ppFolderList = pFolderList;
    pFolderList = NULL;

exit:

    SafeRelease(pFolderList);
    return hr;
}

//----------------------------------------------------------------------
// CFolderList::CFolderList
//----------------------------------------------------------------------
CFolderList::CFolderList(void) :
    m_cRef(1),
    m_pStore(NULL),
    m_pflnList(NULL)
{
    // nothing to do
}

//----------------------------------------------------------------------
// CFolderList::~CFolderList
//----------------------------------------------------------------------
CFolderList::~CFolderList(void)
{    
    _FreeList();
    SafeRelease(m_pStore);
}

//----------------------------------------------------------------------
// CFolderList::AddRef
//----------------------------------------------------------------------
ULONG CFolderList::AddRef(void)
{
    return (++m_cRef);
}

//----------------------------------------------------------------------
// CFolderList::Release
//----------------------------------------------------------------------
ULONG CFolderList::Release(void)
{
    if (0 == --m_cRef)
    {
        delete this;
        return 0;
    }
    else
        return m_cRef;
}

//----------------------------------------------------------------------
// CFolderList::_FreeList
//----------------------------------------------------------------------
void CFolderList::_FreeList(void)
{
    LPFOLDERLISTNODE pflnDeleteMe;

    while (m_pflnList)
    {
        pflnDeleteMe = m_pflnList;
        m_pflnList = m_pflnList->pflnNext;

        _FreeNode(pflnDeleteMe);
    }
}

//----------------------------------------------------------------------
// CFolderList::HrInitialize
//----------------------------------------------------------------------
HRESULT CFolderList::HrInitialize(IMessageStore *pStore, FOLDERID idRoot)
{
    HRESULT				hr=S_OK;
	IEnumerateFolders	*pFldrEnum = NULL;
    FOLDERINFO			fi;
    FOLDERLISTNODE      flnDummyHead= { NULL, 0, 0, NULL };
    LPFOLDERLISTNODE    pflnTail = &flnDummyHead;
    LPFOLDERLISTNODE    pflnNewNode = NULL;

    if (NULL == pStore)
    {
        hr = TraceResult(E_INVALIDARG);
        return hr;
    }
    
    if (NULL != m_pflnList)
    {
        hr = TraceResult(ERROR_ALREADY_INITIALIZED);
        return hr;
    }

    m_pStore = pStore;
    m_pStore->AddRef();

    // this function assumes that the folder list is flat.
    // it needs to be modified to support a hierarchical store.

    IF_FAILEXIT(hr = pStore->EnumChildren(idRoot, FALSE, &pFldrEnum));

    pFldrEnum->Reset();
    
    // build a linked list of folder nodes
    while (S_OK == pFldrEnum->Next(1, &fi, NULL))
    {
        pflnNewNode = _AllocNode();
        if (NULL == pflnNewNode)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            pStore->FreeRecord(&fi);
            _FreeList();
            goto exit;
        }
        
        pflnNewNode->pszUrlComponent = PszDupA(fi.pszUrlComponent);
        pflnNewNode->dwFlags = fi.dwFlags;
        pflnNewNode->idFolder = fi.idFolder;
        pflnNewNode->tySpecial = fi.tySpecial;
        pflnNewNode->cMessages = fi.cMessages;
        pflnNewNode->cUnread = fi.cUnread;

        pflnTail->pflnNext = pflnNewNode;
        pflnTail = pflnNewNode;
        pflnNewNode = NULL;

        pStore->FreeRecord(&fi);
    }

    m_pflnList = flnDummyHead.pflnNext;

exit:
    ReleaseObj(pFldrEnum);
    return hr;
}

//----------------------------------------------------------------------
// CFolderList::FindAndRemove
//----------------------------------------------------------------------
FOLDERID CFolderList::FindAndRemove(LPSTR pszUrlComponent,
                                    DWORD *pcMessages, 
                                    DWORD *pcUnread)
{
    LPFOLDERLISTNODE    pflnPrev = NULL;
    LPFOLDERLISTNODE    pflnCur = m_pflnList;
    FOLDERID            idFound = FOLDERID_INVALID;

    if (NULL == pszUrlComponent)
        return FOLDERID_INVALID;

    if (pcMessages)
        *pcMessages = 0;
    if (pcUnread)
        *pcUnread = 0;

    while (pflnCur)
    {
        if ((NULL != pflnCur->pszUrlComponent) && (0 == lstrcmp(pflnCur->pszUrlComponent, pszUrlComponent)))
        {
            if (NULL == pflnPrev)
                m_pflnList = pflnCur->pflnNext;
            else
                pflnPrev->pflnNext = pflnCur->pflnNext;

            idFound = pflnCur->idFolder;
            if (pcMessages)
                *pcMessages = pflnCur->cMessages;
            if (pcUnread)
                *pcUnread = pflnCur->cUnread;

            _FreeNode(pflnCur);
            break;
        }
        
        pflnPrev = pflnCur;
        pflnCur = pflnCur->pflnNext;
    }

    return idFound;
}

//----------------------------------------------------------------------
// CFolderList::FindAndRemove
//----------------------------------------------------------------------
FOLDERID CFolderList::FindAndRemove(SPECIALFOLDER tySpecial,
                                    DWORD *pcMessages, 
                                    DWORD *pcUnread)
{
    LPFOLDERLISTNODE    pflnPrev = NULL;
    LPFOLDERLISTNODE    pflnCur = m_pflnList;
    FOLDERID            idFound = FOLDERID_INVALID;

    if (FOLDER_NOTSPECIAL == tySpecial)
        return FOLDERID_INVALID;

    if (pcMessages)
        *pcMessages = 0;
    if (pcUnread)
        *pcUnread = 0;

    while (pflnCur)
    {
        if (pflnCur->tySpecial == tySpecial)
        {
            if (NULL == pflnPrev)
                m_pflnList = pflnCur->pflnNext;
            else
                pflnPrev->pflnNext = pflnCur->pflnNext;

            idFound = pflnCur->idFolder;
            if (pcMessages)
                *pcMessages = pflnCur->cMessages;
            if (pcUnread)
                *pcUnread = pflnCur->cUnread;

            _FreeNode(pflnCur);
            break;
        }
        
        pflnPrev = pflnCur;
        pflnCur = pflnCur->pflnNext;
    }

    return idFound;
}

//----------------------------------------------------------------------
// CFolderList::PurgeRemainingFromStore
//----------------------------------------------------------------------
void CFolderList::PurgeRemainingFromStore(void)
{
    HRESULT             hr = S_OK;
    LPFOLDERLISTNODE    pflnCur = m_pflnList;
    LPFOLDERLISTNODE    pflnDeleteMe = NULL;

    // take ownership of the list
    m_pflnList = NULL;

    while (pflnCur)
    {
        m_pStore->DeleteFolder(pflnCur->idFolder, DELETE_FOLDER_DELETESPECIAL | DELETE_FOLDER_NOTRASHCAN, NULL);
        pflnDeleteMe = pflnCur;
        pflnCur = pflnCur->pflnNext;
        
        _FreeNode(pflnDeleteMe);
    }
}

//----------------------------------------------------------------------
// FreeNewMessageInfo
//----------------------------------------------------------------------
static void __cdecl FreeNewMessageInfo(LPVOID pnmi)
{
    Assert(NULL != pnmi);

    SafeMemFree(((LPNEWMESSAGEINFO)pnmi)->pszUrlComponent);

    MemFree(pnmi);
}

#ifndef NOHTTPMAIL

//----------------------------------------------------------------------
// CreateHTTPMailStore (factory function)
//----------------------------------------------------------------------
HRESULT CreateHTTPMailStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    HRESULT hr = S_OK;

    // Trace
    TraceCall("CreateHTTPMailStore");

    // Invalid Args
    Assert(NULL != ppUnknown);
    if (NULL == ppUnknown)
        return E_INVALIDARG;

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CHTTPMailServer *pNew = new CHTTPMailServer();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    //*ppUnknown = SAFECAST(pNew, IMessageServer *);
 
    hr = CreateServerQueue(pNew, (IMessageServer **)ppUnknown);
    pNew->Release(); // Since we're not returning this ptr, bump down refcount


    // Done
    return hr;
}

#endif

//----------------------------------------------------------------------
// CHTTPMailServer::CHTTPMailServer
//----------------------------------------------------------------------
CHTTPMailServer::CHTTPMailServer(void) :
    m_cRef(1),
    m_hwnd(NULL),
    m_pStore(NULL),
    m_pFolder(NULL),
    m_pTransport(NULL),
    m_pszFldrLeafName(NULL),
    m_pszMsgFolderRoot(NULL),
    m_idServer(FOLDERID_INVALID),
    m_idFolder(FOLDERID_INVALID),
    m_tySpecialFolder(FOLDER_NOTSPECIAL),
    m_pszFolderUrl(NULL),
    m_fConnected(FALSE),
    m_pTransport2(NULL),
    m_pAccount(NULL)
{
    _FreeOperation(FALSE);

    ZeroMemory(&m_rInetServerInfo, sizeof(INETSERVER));

    m_szAccountName[0] = '\0';
    m_szAccountId[0] = '\0';

    m_op.pszAdUrl = NULL;

#ifdef DEBUG
    m_dwThreadId = GetCurrentThreadId();
#endif // DEBUG
}

//----------------------------------------------------------------------
// CHTTPMailServer::~CHTTPMailServer
//----------------------------------------------------------------------
CHTTPMailServer::~CHTTPMailServer(void)
{
    // Close the window    
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);

    ZeroMemory(&m_rInetServerInfo, sizeof(m_rInetServerInfo));        // Done for security

    SafeRelease(m_pStore);
    SafeRelease(m_pFolder);
    SafeRelease(m_pTransport);
    SafeRelease(m_pTransport2);
    SafeRelease(m_pAccount);

    SafeMemFree(m_pszFldrLeafName);
    SafeMemFree(m_pszMsgFolderRoot);
    SafeMemFree(m_pszFolderUrl);
}

//----------------------------------------------------------------------
// IUnknown Members
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// CHTTPMailServer::QueryInterface
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    TraceCall("CHTTPMailServer::QueryInterface");
    
    if (NULL == ppv)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (IID_IUnknown == riid || IID_IMessageServer == riid)
        *ppv = (IMessageServer *)this;
    else if (IID_ITransportCallback == riid)
        *ppv = (ITransportCallback *)this;
    else if (IID_IHTTPMailCallback == riid)
        *ppv = (IHTTPMailCallback *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // the interface was found. addref it
    ((IUnknown *)*ppv)->AddRef();

exit:
    // done
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::AddRef
//----------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailServer::AddRef(void)
{
    TraceCall("CHTTPMailServer::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//----------------------------------------------------------------------
// CHTTPMailServer::AddRef
//----------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailServer::Release(void)
{
    TraceCall("CHTTPMailServer::Release");
    ULONG cRef = InterlockedDecrement(&m_cRef);

    Assert(((LONG)cRef) >= 0);
    if (0 == cRef)
        delete this;
    return cRef;
}

//----------------------------------------------------------------------
// IMessageServer Members
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// CHTTPMailServer::Initialize
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::Initialize(   IMessageStore   *pStore, 
                                            FOLDERID        idStoreRoot, 
                                            IMessageFolder  *pFolder, 
                                            FOLDERID        idFolder)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;

    AssertSingleThreaded;

    if (NULL == pStore || FOLDERID_INVALID == idStoreRoot)
        return TraceResult(E_INVALIDARG);

    if (!_CreateWnd())
        return E_FAIL;

    m_idServer = idStoreRoot;
    m_idFolder = idFolder;

    ReplaceInterface(m_pFolder, pFolder);
    ReplaceInterface(m_pStore, pStore);

    if (FAILED(hr = m_pStore->GetFolderInfo(idStoreRoot, &fi)))
        goto exit;

    Assert(!!(fi.dwFlags & FOLDER_SERVER));
    StrCpyN(m_szAccountId, fi.pszAccountId, ARRAYSIZE(m_szAccountId));
    
    m_pStore->FreeRecord(&fi);

    // if we were passed a valid folder id, check to see if this folder is special?
    // we might get passed a bad folder id when we are syncing the store.
    if (FOLDERID_INVALID != idFolder)
    {
        if (FAILED(hr = m_pStore->GetFolderInfo(idFolder, &fi)))
            goto exit;
    
        m_tySpecialFolder = fi.tySpecial;
        m_pStore->FreeRecord(&fi);
    }

exit:
    return hr;
}

STDMETHODIMP CHTTPMailServer::ResetFolder(  IMessageFolder  *pFolder, 
                                            FOLDERID        idFolder)
{
    return(E_NOTIMPL);
}

//----------------------------------------------------------------------
// CHTTPMailServer::SetIdleCallback
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SetIdleCallback(IStoreCallback *pDefaultCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SynchronizeFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SynchronizeFolder(
                                    SYNCFOLDERFLAGS dwFlags, 
                                    DWORD cHeaders, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::SynchronizeFolder");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation = SOT_SYNC_FOLDER;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnSyncFolder;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncFolder);
    m_op.dwSyncFlags = dwFlags;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetMessage 
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetMessage(
                                MESSAGEID idMessage, 
                                IStoreCallback  *pCallback)
{
    HRESULT hr = S_OK;

    TraceCall("CHTTPMailServer::GetMessage");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    if (FAILED(hr = CreatePersistentWriteStream(m_pFolder, &m_op.pMessageStream, &m_op.faStream)))
        goto exit;

    m_op.tyOperation = SOT_GET_MESSAGE;
    m_op.pfnState = c_rgpfnGetMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMessage);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.idMessage = idMessage;

    hr = _BeginDeferredOperation();

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PutMessage
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::PutMessage(
                                    FOLDERID idFolder, 
                                    MESSAGEFLAGS dwFlags, 
                                    LPFILETIME pftReceived, 
                                    IStream  *pStream, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::PutMessage");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pStream || NULL == pCallback)
        return E_INVALIDARG;

    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        return SP_E_HTTP_CANTMODIFYMSNFOLDER;

    m_op.tyOperation = SOT_PUT_MESSAGE;
    m_op.pfnState = c_rgpfnPutMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnPutMessage);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.idFolder = idFolder;
    m_op.pMessageStream = pStream;
    m_op.pMessageStream->AddRef();
    m_op.dwMsgFlags = dwFlags;

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::CopyMessages
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::CopyMessages(
                                    IMessageFolder *pDest, 
                                    COPYMESSAGEFLAGS dwOptions, 
                                    LPMESSAGEIDLIST pList, 
                                    LPADJUSTFLAGS pFlags, 
                                    IStoreCallback  *pCallback)
{
    HRESULT         hr = S_OK;
    FOLDERID        idFolder;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    
    
    TraceCall("CHTTPMailServer::CopyMessages");

    if (NULL == pDest)
        return E_INVALIDARG;

    Assert(NULL != m_pStore);

    // disallow moving or copying into the msn promo folder
    IF_FAILEXIT(hr = pDest->GetFolderId(&idFolder));
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(idFolder, &fi));
    
    pfiFree = &fi;

    if (FOLDER_MSNPROMO == fi.tySpecial)
    {
        hr = TraceResult(SP_E_HTTP_CANTMODIFYMSNFOLDER);
        goto exit;
    }
    // convert moves out of the promo folder into copies
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        dwOptions = (dwOptions & ~COPY_MESSAGE_MOVE);

    hr = _DoCopyMoveMessages(SOT_COPYMOVE_MESSAGE, pDest, dwOptions, pList, pCallback);
exit:
    if (NULL != pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteMessages
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::DeleteMessages(DELETEMESSAGEFLAGS dwOptions, 
                                             LPMESSAGEIDLIST pList, 
                                             IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::DeleteMessages");

    AssertSingleThreaded;
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    // we don't allow messages to be deleted out of the msnpromo folder
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
    {
        // this is a hack. we test this flag to determine that the
        //operation is being performed as the last phase of a move
        // into a local folder. when this is the case, we fail
        // silently.
        if (!!(DELETE_MESSAGE_MAYIGNORENOTRASH & dwOptions))
            return S_OK;
        else
            return SP_E_HTTP_CANTMODIFYMSNFOLDER;
    }

    if ((NULL !=pList && 0 == pList->cMsgs) || NULL == pCallback)
        return E_INVALIDARG;

    HRESULT         hr = S_OK;
    IMessageFolder  *pDeletedItems = NULL;

    m_op.dwDelMsgFlags = dwOptions;

    // if the current folder is the deleted items folder, then delete the
    // messages, otherwise move them to deleted items
    if (FOLDER_DELETED != m_tySpecialFolder && !(dwOptions & DELETE_MESSAGE_NOTRASHCAN))
    {
        // find the deleted items folder
        if (SUCCEEDED(m_pStore->OpenSpecialFolder(m_idServer, NULL, FOLDER_DELETED, &pDeletedItems)) && NULL != pDeletedItems)
        {
            hr = _DoCopyMoveMessages(SOT_DELETING_MESSAGES, pDeletedItems, COPY_MESSAGE_MOVE, pList, pCallback);
            goto exit;
        }
    }
    
    // handle the case where the messages are not in the deleted items folder
    // if pList is null, apply the operation to the entire folder
    if (NULL != pList)
        hr = CloneMessageIDList(pList, &m_op.pIDList);
    else
        hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &m_op.hRowSet);

    if (FAILED(hr))
        goto exit;

    m_op.tyOperation = SOT_DELETING_MESSAGES;
    m_op.pfnState = c_rgpfnDeleteMessages;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnDeleteMessages);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    hr = _BeginDeferredOperation();

exit:
    SafeRelease(pDeletedItems);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SetMessageFlags
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SetMessageFlags(
                                        LPMESSAGEIDLIST pList, 
                                        LPADJUSTFLAGS pFlags, 
                                        SETMESSAGEFLAGSFLAGS dwFlags,
                                        IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::SetMessageFlags");

    AssertSingleThreaded;
    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(NULL != pCallback);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(m_pStore != NULL);

    if ((NULL !=pList && 0 == pList->cMsgs) || NULL == pFlags || NULL == pCallback)
        return E_INVALIDARG;

    // the only remote flag supported by httpmail is the "read" flag
    // it is an error to attempt to set or unset any other flag
    Assert(0 == (pFlags->dwRemove & ~ARF_READ));
    Assert(0 == (pFlags->dwAdd & ~ARF_READ));
    Assert((ARF_READ == (ARF_READ & pFlags->dwRemove)) || (ARF_READ == (ARF_READ & pFlags->dwAdd)));
 
    HRESULT     hr = S_OK;

    // if pList is null, apply the operation to the entire folder
    if (NULL != pList)
        hr = CloneMessageIDList(pList, &m_op.pIDList);
    else
        hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &m_op.hRowSet);

    if (FAILED(hr))
        return hr;

    m_op.tyOperation = SOT_SET_MESSAGEFLAGS;
    m_op.pfnState = c_rgpfnSetMessageFlags;
    m_op.cState = ARRAYSIZE(c_rgpfnSetMessageFlags);
    m_op.iState = 0;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.fMarkRead = !!(pFlags->dwAdd & ARF_READ);
    m_op.dwSetFlags = dwFlags;
    
    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetServerMessageFlags
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetServerMessageFlags(MESSAGEFLAGS *pFlags)
{
    if (NULL == pFlags)
        return E_INVALIDARG;

    *pFlags = ARF_READ;
    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SynchronizeStore
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SynchronizeStore(
                                    FOLDERID idParent, 
                                    SYNCSTOREFLAGS dwFlags, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::SynchronizeStore");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(m_pStore != NULL);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation =  SOT_SYNCING_STORE;
    m_op.pfnState = c_rgpfnSyncStore;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncStore);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::CreateFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::CreateFolder(
                                    FOLDERID idParent, 
                                    SPECIALFOLDER tySpecial, 
                                    LPCSTR pszName, 
                                    FLDRFLAGS dwFlags, 
                                    IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::CreateFolder");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(NULL != m_pStore);

    // why would we be called to create a special folder?
    Assert(FOLDER_NOTSPECIAL == tySpecial);

    if (NULL == pCallback || NULL == pszName)
        return E_INVALIDARG;

    // hotmail doesn't support hierarchical folders.
    Assert(m_idServer == idParent);
    if (m_idServer != idParent)
        return E_FAIL;

    m_op.pszFolderName = PszDupA(pszName);
    if (NULL == m_op.pszFolderName)
        return E_OUTOFMEMORY;

    m_op.tyOperation = SOT_CREATE_FOLDER;
    m_op.pfnState = c_rgpfnCreateFolder;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnCreateFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();
    m_op.dwFldrFlags = dwFlags;

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::MoveFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback  *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::RenameFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::RenameFolder(FOLDERID idFolder, 
                                           LPCSTR pszName, 
                                           IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::RenameFolder");
    
    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);
    Assert(NULL != pszName);

    // don't allow the user to rename the promo folder
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        return SP_E_HTTP_CANTMODIFYMSNFOLDER;

    if (NULL == pszName || NULL == pCallback)
        return E_INVALIDARG;

    m_op.pszFolderName = PszDupA(pszName);
    if (NULL == m_op.pszFolderName)
    {
        TraceResult(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    m_op.idFolder = idFolder;

    m_op.tyOperation = SOT_RENAME_FOLDER;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnRenameFolder;
    m_op.cState = ARRAYSIZE(c_rgpfnRenameFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::DeleteFolder(FOLDERID idFolder, 
                                           DELETEFOLDERFLAGS dwFlags, 
                                           IStoreCallback  *pCallback)
{
    TraceCall("CHTTPMailServer::DeleteFolder");
    
    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);
    Assert(FOLDERID_INVALID != idFolder);

    // don't allow the user to delete the msn promo folder
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        return SP_E_HTTP_CANTMODIFYMSNFOLDER;

    // we don't support hierarchical folders - if we are asked to delete
    // the children of a folder, just return immediately
    if (!!(DELETE_FOLDER_CHILDRENONLY & dwFlags))
        return S_OK;

    if (NULL == pCallback || FOLDERID_INVALID == idFolder)
        return E_INVALIDARG;

    m_op.idFolder = idFolder;

    m_op.tyOperation = SOT_DELETE_FOLDER;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnDeleteFolder;
    m_op.cState = ARRAYSIZE(c_rgpfnDeleteFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
} 

//----------------------------------------------------------------------
// CHTTPMailServer::SubscribeToFolder
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe, IStoreCallback  *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::Close
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::Close(DWORD dwFlags)
{
    // if we are processing a command, cancel it
    Cancel(CT_CANCEL);

    if (dwFlags & MSGSVRF_DROP_CONNECTION)
        _SetConnected(FALSE);

    if (dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (m_pTransport)
        {
            m_pTransport->DropConnection();
            m_pTransport->HandsOffCallback();
            m_pTransport->Release(); 
            m_pTransport = NULL;
        }
    }
    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetFolderCounts
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetNewGroups
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnLogonPrompt
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    HRESULT     hr = S_OK;
    LPSTR       pszCachedPassword = NULL;
    INETSERVER  rInetServer;

    TraceCall("CHTTPMailServer::OnLogonPrompt");

    AssertSingleThreaded;
    Assert(pInetServer != NULL);
    Assert(pTransport != NULL);
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);

    // pull password out of the cache
    GetAccountPropStrA(m_szAccountId, CAP_PASSWORD, &pszCachedPassword);
    if (NULL != pszCachedPassword && 0 != lstrcmp(pszCachedPassword, pInetServer->szPassword))
    {
        StrCpyN(pInetServer->szPassword, pszCachedPassword, ARRAYSIZE(pInetServer->szPassword));
        goto exit;
    }
    
    hr = m_op.pCallback->OnLogonPrompt(pInetServer, IXP_HTTPMail);
    if (S_OK == hr)
    {
        // cache the password
        HrCacheAccountPropStrA(m_szAccountId, CAP_PASSWORD, pInetServer->szPassword);

        // copy the new username and password into our local server info
        StrCpyN(m_rInetServerInfo.szPassword, pInetServer->szPassword, ARRAYSIZE(m_rInetServerInfo.szPassword));
        StrCpyN(m_rInetServerInfo.szUserName, pInetServer->szUserName, ARRAYSIZE(m_rInetServerInfo.szUserName));
    }

exit:
    SafeMemFree(pszCachedPassword);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnPrompt
//----------------------------------------------------------------------
STDMETHODIMP_(INT) CHTTPMailServer::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return 0;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnStatus
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport)
{
        // Stack
    TraceCall("CHTTPMailServer::OnStatus");

    AssertSingleThreaded;

    // If we were disconnected, then clean up some internal state.
    if (IXP_DISCONNECTED == ixpstatus)
    {
        if (m_op.tyOperation != SOT_INVALID)
        {
            Assert(m_op.pCallback != NULL);
        
            if (m_op.fCancel && !m_op.fNotifiedComplete)
            {
                IXPRESULT   rIxpResult;

                // Fake an IXPRESULT
                ZeroMemory(&rIxpResult, sizeof(rIxpResult));
                rIxpResult.hrResult = STORE_E_OPERATION_CANCELED;

                // Return meaningful error information
                _FillStoreError(&m_op.error, &rIxpResult);
                Assert(STORE_E_OPERATION_CANCELED == m_op.error.hrResult);

                m_op.fNotifiedComplete = TRUE;
                m_op.pCallback->OnComplete(m_op.tyOperation, m_op.error.hrResult, NULL, &m_op.error);
                _FreeOperation();
            }
        }

        m_fConnected = FALSE;
    }

    return(S_OK);
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnError
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnProgress
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnCommand
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnTimeout
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------
// CHTTPMailServer::OnResponse
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::OnResponse(
            LPHTTPMAILRESPONSE      pResponse)
{
    HRESULT     hr = S_OK;
    HRESULT     hrResponse;
    HRESULT     hrSaved;
    BOOL        fInvokeResponseHandler = TRUE;

    AssertSingleThreaded;

    Assert(SOT_INVALID != m_op.tyOperation);

    if (!m_op.fCancel && !m_op.fNotifiedComplete && 
        (SOT_GET_ADURL == m_op.tyOperation  || SOT_GET_HTTP_MINPOLLINGINTERVAL == m_op.tyOperation))
    {
        STOREOPERATIONINFO  StoreInfo = {0};

        m_op.fNotifiedComplete = TRUE;

        if (SOT_GET_ADURL == m_op.tyOperation)
        {
            StoreInfo.pszUrl = pResponse->rGetPropInfo.pszProp;

            pResponse->rGetPropInfo.pszProp = NULL;
        }

        if (SOT_GET_HTTP_MINPOLLINGINTERVAL == m_op.tyOperation)
        {
            StoreInfo.dwMinPollingInterval = pResponse->rGetPropInfo.dwProp;
        }

        m_op.pCallback->OnComplete(m_op.tyOperation, pResponse->rIxpResult.hrResult, &StoreInfo, NULL);
        _FreeOperation();

        MemFree(StoreInfo.pszUrl);
        
        goto cleanup;

    }

    if (FAILED(pResponse->rIxpResult.hrResult))
    {
        Assert(pResponse->fDone);

        // Hotmail hack. Hotmail does not support deleting message. This interferes with operations
        // such as moving messages from a hotmail folder into the local store. we attempt to send
        // a delete to the server, since we don't know whether or not the server supports the command.
        // if it fails, we check the delete messages flag to determine if we are allowed to fallback
        // to a move operation.
        if (SOT_DELETING_MESSAGES == m_op.tyOperation && 
            (HTTPMAIL_DELETE == pResponse->command || HTTPMAIL_BDELETE == pResponse->command) && 
            IXP_E_HTTP_METHOD_NOT_ALLOW == pResponse->rIxpResult.hrResult &&
            FOLDER_DELETED != m_tySpecialFolder &&
            !!(m_op.dwDelMsgFlags & DELETE_MESSAGE_MAYIGNORENOTRASH))
        {
            m_op.fFallbackToMove = TRUE;
            fInvokeResponseHandler = FALSE;
            // cache the fact that this acct doesn't support msg delete so we don't
            // have to go through this nonsense again
            HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPNOMESSAGEDELETES, "TRUE");
        }
        else
        {
            hrSaved = pResponse->rIxpResult.hrResult;

            if (IXP_E_HTTP_ROOT_PROP_NOT_FOUND == hrSaved)
                pResponse->rIxpResult.hrResult = SP_E_HTTP_SERVICEDOESNTWORK;
            else if ((HTTPMAIL_DELETE == pResponse->command || HTTPMAIL_BDELETE == pResponse->command) && IXP_E_HTTP_METHOD_NOT_ALLOW == hrSaved)
                pResponse->rIxpResult.hrResult = SP_E_HTTP_NODELETESUPPORT;
        
            _FillStoreError(&m_op.error, &pResponse->rIxpResult);

            pResponse->rIxpResult.hrResult = hrSaved;
            
            if (!m_op.fNotifiedComplete)
            {
                m_op.fNotifiedComplete = TRUE;
                m_op.pCallback->OnComplete(m_op.tyOperation, m_op.error.hrResult, NULL, &m_op.error);
                _FreeOperation();
            }

            return S_OK;
        }
    }

    Assert(NULL != m_op.pfnState[m_op.iState].pfnResp);

    // by default, state advances occur when the the response indicates
    // that io is done. response functions can override this behavior
    // by setting fStateWillAdvance to FALSE to maintain the current state.
    m_op.fStateWillAdvance = pResponse->fDone;

    // invoke the response function
    if (fInvokeResponseHandler)
        hr = (this->*(m_op.pfnState[m_op.iState].pfnResp))(pResponse);

cleanup:
    
    if (FAILED(hr))
    {
        if (_FConnected())
        {
            m_pTransport->DropConnection();
            m_pTransport->HandsOffCallback();
            SafeRelease(m_pTransport);
        }

        if (!m_op.fNotifiedComplete)
        {
            m_op.fNotifiedComplete = TRUE;
            m_op.pCallback->OnComplete(m_op.tyOperation, hr, NULL, NULL);

            _FreeOperation();
        }
    }
    else if (SUCCEEDED(hr) && m_op.fStateWillAdvance)
    {
        m_op.iState++;
        _DoOperation();
    }

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetParentWindow
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::GetParentWindow(HWND *phwndParent)
{
    HRESULT     hr = E_FAIL;

    AssertSingleThreaded;

    if (m_op.tyOperation != SOT_INVALID && NULL != m_op.pCallback)
        hr = m_op.pCallback->GetParentWindow(0, phwndParent);

    return hr;
}

//----------------------------------------------------------------------
// IOperationCancel Members
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// CHTTPMailServer::Cancel
//----------------------------------------------------------------------
STDMETHODIMP CHTTPMailServer::Cancel(CANCELTYPE tyCancel)
{
    if (m_op.tyOperation != SOT_INVALID)
    {
        m_op.fCancel = TRUE;
        _Disconnect();
    }

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer Implementation
//----------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailServer::_CreateWnd
// --------------------------------------------------------------------------------
BOOL CHTTPMailServer::_CreateWnd()
{
    WNDCLASS wc;

    IxpAssert(!m_hwnd);
    if (m_hwnd)
        return TRUE;

    if (!GetClassInfo(g_hInst, s_szHTTPMailServerWndClass, &wc))
    {
        wc.style                = 0;
        wc.lpfnWndProc          = CHTTPMailServer::_WndProc;
        wc.cbClsExtra           = 0;
        wc.cbWndExtra           = 0;
        wc.hInstance            = g_hInst;
        wc.hIcon                = NULL;
        wc.hCursor              = NULL;
        wc.hbrBackground        = NULL;
        wc.lpszMenuName         = NULL;
        wc.lpszClassName        = s_szHTTPMailServerWndClass;
        
        RegisterClass(&wc);
    }

    m_hwnd = CreateWindowEx(WS_EX_TOPMOST,
                        s_szHTTPMailServerWndClass,
                        s_szHTTPMailServerWndClass,
                        WS_POPUP,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        g_hInst,
                        (LPVOID)this);

    return (NULL != m_hwnd);
}

// --------------------------------------------------------------------------------
// CHTTPMailServer::_WndProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK CHTTPMailServer::_WndProc(HWND hwnd,
                                         UINT msg,
                                         WPARAM wParam,
                                         LPARAM lParam)
{
    CHTTPMailServer     *pThis = (CHTTPMailServer*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    LRESULT             lr = 0;

    switch (msg)
    {
    case WM_NCCREATE:
        IxpAssert(!pThis);
        pThis = (CHTTPMailServer*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
        lr = DefWindowProc(hwnd, msg, wParam, lParam);       
        break;
    
    case WM_HTTP_BEGIN_OP:
        IxpAssert(pThis);
        pThis->_DoOperation();
        break;
        
    default:
        lr = DefWindowProc(hwnd, msg, wParam, lParam);
        break;
    }

    return lr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_BeginDeferredOperation
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_BeginDeferredOperation(void)
{
    return (PostMessage(m_hwnd, WM_HTTP_BEGIN_OP, 0, 0) ? E_PENDING : E_FAIL);
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleGetMsgFolderRoot
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleGetMsgFolderRoot(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT     hr      = S_OK;
    
    Assert(HTTPMAIL_GETPROP == pResponse->command);
    Assert(NULL == m_pszMsgFolderRoot);
    Assert(HTTPMAIL_PROP_MSGFOLDERROOT == pResponse->rGetPropInfo.type);

    if (NULL == pResponse->rGetPropInfo.pszProp)
    {
        hr = E_FAIL;
        goto exit;
    }

    m_pszMsgFolderRoot = pResponse->rGetPropInfo.pszProp;
    pResponse->rGetPropInfo.pszProp = NULL;

    // add it to the account data cache
    HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPMAILMSGFOLDERROOT, m_pszMsgFolderRoot);

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleListFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleListFolders(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                         hr = S_OK;
    SPECIALFOLDER                   tySpecial = FOLDER_NOTSPECIAL;
    FOLDERINFO                      fiNewFolder;
    FOLDERID                        idFound = FOLDERID_INVALID;
    LPHTTPMEMBERINFOLIST            pMemberList = &pResponse->rMemberInfoList;
    LPHTTPMEMBERINFO                pMemberInfo;
    CHAR                            szUrlComponent[MAX_PATH];
    DWORD                           dwUrlComponentLen;
    CHAR                            szSpecialFolder[CCHMAX_STRINGRES];
    DWORD                           cMessages;
    DWORD                           cUnread;
    FOLDERINFO                      fi = {0};

    for (ULONG ulIndex = 0; ulIndex < pMemberList->cMemberInfo; ++ulIndex)
    {
        idFound = FOLDERID_INVALID;

        pMemberInfo = &pMemberList->prgMemberInfo[ulIndex];

        // skip anything that isn't a folder
        if (!pMemberInfo->fIsFolder)
            continue;
        
        dwUrlComponentLen = ARRAYSIZE(szUrlComponent);
        IF_FAILEXIT(hr = Http_NameFromUrl(pMemberInfo->pszHref, szUrlComponent, &dwUrlComponentLen));

        // [shaheedp] Bug# 84477
        // If szUrlComponent is null, then we should not be adding this folder to the store. 
        if (!(*szUrlComponent))
        {
            hr = E_FAIL;
            goto exit;
        }


        // if we've found a reserved folder, translate the httpmail
        // special folder constant into the equivalent oe store
        // special folder type.
    
        tySpecial =  _TranslateHTTPSpecialFolderType(pMemberInfo->tySpecial);
        if (FOLDER_NOTSPECIAL != tySpecial)
            idFound = m_op.pFolderList->FindAndRemove(tySpecial, &cMessages, &cUnread);

        // if the folder wasn't found, try to find it by name
        if (FOLDERID_INVALID == idFound)
        {
            idFound = m_op.pFolderList->FindAndRemove(szUrlComponent, &cMessages, &cUnread);

            // if it still wasn't found, then add it
            if (FOLDERID_INVALID == idFound)
            {
                // fill in the folderinfo
                ZeroMemory(&fiNewFolder, sizeof(FOLDERINFO));
                fiNewFolder.idParent = m_idServer;
                fiNewFolder.tySpecial = tySpecial;
                fiNewFolder.tyFolder = FOLDER_HTTPMAIL;
                fiNewFolder.pszName = pMemberInfo->pszDisplayName;
                if (FOLDER_NOTSPECIAL != tySpecial)
                {
                    if (_LoadSpecialFolderName(tySpecial, szSpecialFolder, sizeof(szSpecialFolder)))
                        fiNewFolder.pszName = szSpecialFolder;
                }

                fiNewFolder.pszUrlComponent = szUrlComponent;
                fiNewFolder.dwFlags = (FOLDER_SUBSCRIBED | FOLDER_NOCHILDCREATE);

                // message counts
                fiNewFolder.cMessages = pMemberInfo->dwVisibleCount;
                fiNewFolder.cUnread = pMemberInfo->dwUnreadCount;
          
                if (tySpecial == FOLDER_INBOX)
                    fiNewFolder.dwFlags |= FOLDER_DOWNLOADALL;

                // Add the folder to the store
                IF_FAILEXIT(hr = m_pStore->CreateFolder(NOFLAGS, &fiNewFolder, NULL));
            }
        }
        
        // if the folder was found, update its message counts
        if (FOLDERID_INVALID != idFound)
        {
            if (SUCCEEDED(hr = m_pStore->GetFolderInfo(idFound, &fi)))
            {
                BOOL    bUpdate = FALSE;

                // only update folders that changed. always update the MSN_PROMO folder.

                // [shaheedp] Bug# 84477 
                // If the folder's pszUrlComponent was null or it is different, then reset it.
                if ((fi.pszUrlComponent == NULL) || 
                   (lstrcmpi(fi.pszUrlComponent, szUrlComponent)))
                {
                    bUpdate = TRUE;
                    fi.pszUrlComponent  = szUrlComponent;
                }

                if ((FOLDER_MSNPROMO == tySpecial) || 
                    (cMessages != pMemberInfo->dwVisibleCount) ||  
                    (cUnread != pMemberInfo->dwUnreadCount))
                {

                    fi.cMessages = pMemberInfo->dwVisibleCount;

                    // special handling for the promo folder - messages on the
                    // server are never marked unread.
                    if (FOLDER_MSNPROMO == fi.tySpecial)
                    {
                        // we attempt to approximate the number of unread msgs in
                        // the promo folder. we assume that the server will not track
                        // the read/unread state of promo messages. we figure out how
                        // many messages were read before we got the new counts, and
                        // subtract that number from the current number of visible
                        // messages to get the unread count. this number will not always
                        // be accurate, but since all we know is the counts, and we
                        // don't know how the count changed (additions vs deletions),
                        // this is the best we can do and it always errors on the side
                        // of a too-small count to avoid bothering the user with
                        // unread counts when no unread msgs exist.
                        DWORD dwReadMessages = cMessages - cUnread;

                        if (fi.cMessages > dwReadMessages)
                            fi.cUnread = fi.cMessages - dwReadMessages;
                        else
                            fi.cUnread = 0;
                    }
                    else
                        fi.cUnread = pMemberInfo->dwUnreadCount;
            
                        if (cMessages != fi.cMessages || cUnread != fi.cUnread)
                            bUpdate = TRUE;

                }

                if (bUpdate)
                    m_pStore->UpdateRecord(&fi);

                m_pStore->FreeRecord(&fi);
            }
        }

        // if we are syncing the store, notify the client of our progress
        if (SOT_SYNCING_STORE == m_op.tyOperation && NULL != m_op.pCallback)
            m_op.pCallback->OnProgress(
                            SOT_SYNCING_STORE, 
                            0,
                            0,
                            m_rInetServerInfo.szServerName);
    }

    IF_FAILEXIT(hr = m_pAccount->SetPropSz(AP_HTTPMAIL_ROOTTIMESTAMP, pMemberList->pszRootTimeStamp));
    IF_FAILEXIT(hr = m_pAccount->SetPropSz(AP_HTTPMAIL_ROOTINBOXTIMESTAMP, pMemberList->pszFolderTimeStamp));
exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleGetMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleGetMessage(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT         hr;
    
    IF_FAILEXIT(hr = m_op.pMessageStream->Write(
                        pResponse->rGetInfo.pvBody,
                        pResponse->rGetInfo.cbIncrement,
                        NULL));


    if (m_op.pCallback && pResponse->rGetInfo.cbTotal > 0)
    {
        m_op.pCallback->OnProgress(m_op.tyOperation, 
                                   pResponse->rGetInfo.cbCurrent,
                                   pResponse->rGetInfo.cbTotal,
                                   NULL);
    }

    // if not done yet, bail out
    if (!pResponse->fDone)
        goto exit;

    // we're done...write the stream out
    hr = Http_SetMessageStream(m_pFolder, m_op.idMessage, m_op.pMessageStream, &m_op.faStream, FALSE);

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_DoOperation
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_DoOperation(void)
{
    HRESULT hr = S_OK;
    STOREOPERATIONINFO  soi = { sizeof(STOREOPERATIONINFO), MESSAGEID_INVALID };
    STOREOPERATIONINFO  *psoi = NULL;
    BOOL                fCallComplete = TRUE;

    if (m_op.tyOperation == SOT_INVALID)
        return E_FAIL;

    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pfnState != NULL);
    Assert(m_op.cState > 0);
    Assert(m_op.iState <= m_op.cState);

    if (m_op.iState == 0)
    {
        if (m_op.tyOperation == SOT_GET_MESSAGE)
        {
            // provide message id on get message start
            soi.idMessage = m_op.idMessage;
            psoi = &soi;
        }

        if (m_op.tyOperation == SOT_GET_ADURL)
            m_op.pszAdUrl = NULL;

        m_op.pCallback->OnBegin(m_op.tyOperation, psoi, (IOperationCancel *)this);
    }

    while (m_op.iState < m_op.cState)
    {
        hr = (this->*(m_op.pfnState[m_op.iState].pfnOp))();

        if (FAILED(hr))
            break;

        m_op.iState++;
    }

    if ((m_op.iState == m_op.cState) || (FAILED(hr) && hr != E_PENDING))
    {
        LPSTOREERROR    perr = NULL;

        // provide message id 
        if (m_op.tyOperation == SOT_PUT_MESSAGE && MESSAGEID_INVALID != m_op.idPutMessage)
        {
            soi.idMessage = m_op.idPutMessage;
            psoi = &soi;
        }

        switch (m_op.tyOperation)
        {
            case SOT_GET_ADURL:
            {
                if (SUCCEEDED(hr))
                {
                    psoi = &soi;
                    psoi->pszUrl = m_op.pszAdUrl;
                }
                else
                {
                    psoi          = NULL;
                    fCallComplete = FALSE;
                }

                perr = NULL;
                break;
            }

            case SOT_GET_HTTP_MINPOLLINGINTERVAL:
            {
                if (SUCCEEDED(hr))
                {
                    psoi = &soi;
                    psoi->dwMinPollingInterval = m_op.dwMinPollingInterval;
                }
                else
                {
                    psoi            = NULL;
                    fCallComplete   = FALSE;

                }

                perr = NULL;
                break;
            }

            default:
            {
                if (FAILED(hr))
                {
                    IXPRESULT   rIxpResult;

                    // Fake an IXPRESULT
                    ZeroMemory(&rIxpResult, sizeof(rIxpResult));
                    rIxpResult.hrResult = hr;

                    // Return meaningful error information
                    _FillStoreError(&m_op.error, &rIxpResult);
                    Assert(m_op.error.hrResult == hr);
                }
                else
                    m_op.error.hrResult = hr;

                if (!m_op.fNotifiedComplete)
                    perr = &m_op.error;
                
                break;
            }

        }

        if (!m_op.fNotifiedComplete && fCallComplete)
        {
            m_op.fNotifiedComplete = TRUE;
            m_op.pCallback->OnComplete(m_op.tyOperation, hr, psoi, perr);
            _FreeOperation();
        }
    }

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_FreeOperation
//----------------------------------------------------------------------
void CHTTPMailServer::_FreeOperation(BOOL fValidState)
{
    if (fValidState)
    {
        if (m_op.pCallback != NULL)
            m_op.pCallback->Release();
        if (m_op.pFolderList != NULL)
            m_op.pFolderList->Release();
        if (m_op.pMessageFolder)
            m_op.pMessageFolder->Release();

        SafeMemFree(m_op.pszProblem);

        if (0 != m_op.faStream)
        {
            Assert(m_pFolder);
            m_pFolder->DeleteStream(m_op.faStream);
        }
        if (m_op.pMessageStream)
            m_op.pMessageStream->Release();
        if (m_op.pmapMessageId)
            delete m_op.pmapMessageId;
        if (m_op.psaNewMessages)
            delete m_op.psaNewMessages;

        if (m_op.pPropPatchRequest)
            m_op.pPropPatchRequest->Release();

        SafeMemFree(m_op.pszDestFolderUrl);
        SafeMemFree(m_op.pszDestUrl);

        SafeMemFree(m_op.pIDList);
        if (NULL != m_op.hRowSet)
            m_pFolder->CloseRowset(&m_op.hRowSet);

        SafeMemFree(m_op.pszFolderName);

        if (m_op.pTargets)
            Http_FreeTargetList(m_op.pTargets);

        SafeMemFree(m_op.pszAdUrl);

    }

    ZeroMemory(&m_op, sizeof(HTTPOPERATION));

    m_op.tyOperation = SOT_INVALID;
    m_op.idPutMessage = MESSAGEID_INVALID;
}

//----------------------------------------------------------------------
// CHTTPMailServer::Connect
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::Connect()
{
    HRESULT     hr = S_OK;
    INETSERVER  rInetServerInfo;
    BOOL        fInetInit = FALSE;
    LPSTR       pszCache = NULL;

    AssertSingleThreaded;
    Assert(m_op.pCallback != NULL);

    if (!m_pAccount)
    {
        IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, &m_pAccount));
        IF_FAILEXIT(hr = _LoadAccountInfo(m_pAccount));
    }

    if (_FConnected())
    {
        Assert(m_pTransport != NULL);

        IF_FAILEXIT(hr = m_pTransport->InetServerFromAccount(m_pAccount, &rInetServerInfo));

        // compare the current account from the account whose data we saved.
        // if the account has changed, drop the connection, and reconnect
        Assert(m_rInetServerInfo.szServerName[0] != 0);
        if (m_rInetServerInfo.rasconntype == rInetServerInfo.rasconntype &&
            m_rInetServerInfo.dwPort == rInetServerInfo.dwPort &&
            m_rInetServerInfo.fSSL == rInetServerInfo.fSSL &&
            m_rInetServerInfo.fTrySicily == rInetServerInfo.fTrySicily &&
            m_rInetServerInfo.dwTimeout == rInetServerInfo.dwTimeout &&
            0 == lstrcmp(m_rInetServerInfo.szUserName, rInetServerInfo.szUserName) &&
            ('\0' == rInetServerInfo.szPassword[0] ||
                0 == lstrcmp(m_rInetServerInfo.szPassword, rInetServerInfo.szPassword)) &&
            0 == lstrcmp(m_rInetServerInfo.szServerName, rInetServerInfo.szServerName) &&
            0 == lstrcmp(m_rInetServerInfo.szConnectoid, rInetServerInfo.szConnectoid))
        {
            goto exit;
        }

        fInetInit = TRUE;

        // synchronously drop the connection
        m_pTransport->DropConnection();
    }

    hr = m_op.pCallback->CanConnect(m_szAccountId, NOFLAGS);
    if (S_OK != hr)
    {
        if (hr == S_FALSE)
            hr = HR_E_USER_CANCEL_CONNECT;
        goto exit;
    }
    

    if (NULL == m_pTransport)
        IF_FAILEXIT(hr = _LoadTransport());

    // initialize the server info if we haven't already
    if (!fInetInit)
        IF_FAILEXIT(hr = m_pTransport->InetServerFromAccount(m_pAccount, &m_rInetServerInfo));
    else
        CopyMemory(&m_rInetServerInfo, &rInetServerInfo, sizeof(INETSERVER));

    GetAccountPropStrA(m_szAccountId, CAP_PASSWORD, &pszCache);
    if (NULL != pszCache)
    {
        StrCpyN(m_rInetServerInfo.szPassword, pszCache, sizeof(m_rInetServerInfo.szPassword));
        SafeMemFree(pszCache);
    }

    // connect to the server. the transport won't actually connect until
    // a command is issued.
    IF_FAILEXIT(hr = m_pTransport->Connect(&m_rInetServerInfo, TRUE, FALSE));

    _SetConnected(TRUE);

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetMsgFolderRoot
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::GetMsgFolderRoot(void)
{
    HRESULT     hr      = S_OK;
    
    // bail if we've already got it
    if (NULL != m_pszMsgFolderRoot)
        goto exit;

    // try to pull it out of the account data cache
    if (GetAccountPropStrA(m_szAccountId, CAP_HTTPMAILMSGFOLDERROOT, &m_pszMsgFolderRoot))
        goto exit;
    
    if (SUCCEEDED(hr = m_pTransport->GetProperty(HTTPMAIL_PROP_MSGFOLDERROOT, &m_pszMsgFolderRoot)))
    {
        Assert(NULL != m_pszMsgFolderRoot);
        if (NULL == m_pszMsgFolderRoot)
        {
            hr = E_FAIL;
            goto exit;
        }

        // add it to the account data cache
        HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPMAILMSGFOLDERROOT, m_pszMsgFolderRoot);
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::BuildFolderUrl
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::BuildFolderUrl(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    LPFOLDERINFO    fiFree = NULL;

    // just bail if we've already got it
    if (NULL != m_pszFolderUrl)
        goto exit;

    Assert(NULL != m_pszMsgFolderRoot);
    if (NULL == m_pszMsgFolderRoot)
    {
        hr = TraceResult(E_UNEXPECTED);
        goto exit;
    }

    if (FAILED(hr = m_pStore->GetFolderInfo(m_idFolder, &fi)))
        goto exit;

    fiFree = &fi;

    Assert(fi.pszUrlComponent);
    hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_pszFolderUrl);

exit:
    if (fiFree)
        m_pStore->FreeRecord(fiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ListFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ListFolders(void)
{
    HRESULT     hr = S_OK;
    CHAR        szRootTimeStamp[CCHMAX_RES];
    CHAR        szInboxTimeStamp[CCHMAX_RES];

    Assert(NULL == m_op.pFolderList);

    // cache a value that the account has been synced.
    HrCacheAccountPropStrA(m_szAccountId, CAP_HTTPAUTOSYNCEDFOLDERS, c_szTrue);

    // build the folder list
    IF_FAILEXIT(hr = CFolderList::Create(m_pStore, m_idServer, &m_op.pFolderList));

    hr = m_pAccount->GetPropSz(AP_HTTPMAIL_ROOTTIMESTAMP, szRootTimeStamp, ARRAYSIZE(szRootTimeStamp));
    if (FAILED(hr))
        *szRootTimeStamp = 0;

    hr = m_pAccount->GetPropSz(AP_HTTPMAIL_ROOTINBOXTIMESTAMP, szInboxTimeStamp, ARRAYSIZE(szInboxTimeStamp));
    if (FAILED(hr))
        *szInboxTimeStamp = 0;

    // execute the listfolders command
    IF_FAILEXIT(hr = m_pTransport2->RootMemberInfo(m_pszMsgFolderRoot, HTTP_MEMBERINFO_FOLDERPROPS, 
                                                   1, FALSE, 0, szRootTimeStamp, szInboxTimeStamp));

    hr = E_PENDING;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::AutoListFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::AutoListFolders(void)
{
    LPSTR   pszAutoSynced = NULL;
    HRESULT hr = S_OK;

    // look for a cached property that indicates that the folder list
    // for this server has been synchronized at least once this session
    if (GetAccountPropStrA(m_szAccountId, CAP_HTTPAUTOSYNCEDFOLDERS, &pszAutoSynced))
        goto exit;

    // initiate the sync
    hr = ListFolders();

exit:
    SafeMemFree(pszAutoSynced);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ListHeaders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ListHeaders(void)
{
    HRESULT     hr = S_OK;
    TABLEINDEX  index;
    CHAR        szTimeStamp[CCHMAX_RES];

    Assert(NULL != m_pszFolderUrl);
    Assert(NULL != m_pTransport);
    Assert(NULL != m_pStore);
    Assert(NULL == m_op.psaNewMessages);

    // look for an index on pszMessageID
    if ( FAILED(m_pFolder->GetIndexInfo(IINDEX_HTTPURL, NULL, &index)) ||
         (CompareTableIndexes(&index, &g_HttpUrlIndex) != S_OK) )
    {
        // the index didn't exist - create it
        IF_FAILEXIT(hr = m_pFolder->ModifyIndex(IINDEX_HTTPURL, NULL, &g_HttpUrlIndex));
    }

    IF_FAILEXIT(hr = _CreateMessageIDMap(&m_op.pmapMessageId));

    IF_FAILEXIT(hr = CSortedArray::Create(NULL, FreeNewMessageInfo, &m_op.psaNewMessages));

    hr = m_pAccount->GetPropSz(AP_HTTPMAIL_INBOXTIMESTAMP, szTimeStamp, ARRAYSIZE(szTimeStamp));
    if (FAILED(hr))
        *szTimeStamp = 0;

    // For now we are passing in null folder name. This is meant for future purposes.
    IF_FAILEXIT(hr = m_pTransport2->FolderMemberInfo(m_pszFolderUrl, HTTP_MEMBERINFO_MESSAGEPROPS, 
                                               1, FALSE, 0, szTimeStamp, NULL));

    hr = E_PENDING;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleListHeaders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleListHeaders(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                                 hr = S_OK;
    LPHTTPMEMBERINFOLIST                    pMemberList = &pResponse->rMemberInfoList;
    LPHTTPMEMBERINFO                        pMemberInfo;
    TPair<CSimpleString, MARKEDMESSAGE>     *pFoundPair = NULL;
    CSimpleString                           ss;
    char                                    szUrlComponent[MAX_PATH];
    DWORD                                   dwUrlComponentLen;

    Assert(NULL != m_op.pmapMessageId);

    for (ULONG ulIndex = 0; ulIndex < pMemberList->cMemberInfo; ++ulIndex)
    {
        pMemberInfo = &pMemberList->prgMemberInfo[ulIndex];

        // skip folders
        if (pMemberInfo->fIsFolder)
            continue;

        dwUrlComponentLen = MAX_PATH;
        if (FAILED(hr = Http_NameFromUrl(pMemberInfo->pszHref, szUrlComponent, &dwUrlComponentLen)))
            goto exit;

        // look for the message by its server-assigned id in the local map
        if (FAILED(hr = ss.SetString(szUrlComponent)))
            goto exit;

        pFoundPair = m_op.pmapMessageId->Find(ss);

        // if the message was found, synchronize its read state, otherwise
        // add the new message to the store
        if (pFoundPair)
        {
            pFoundPair->m_value.fMarked = TRUE;

            // if not syncing the msn promo folder, adopt the server's read state
            if (FOLDER_MSNPROMO != m_tySpecialFolder)
            {
                if ((!!(pFoundPair->m_value.dwFlags & ARF_READ)) != pMemberInfo->fRead)
                    hr = _MarkMessageRead(pFoundPair->m_value.idMessage, pMemberInfo->fRead);
            }
        }
        else
        {
            if (FAILED(hr = Http_AddMessageToFolder(m_pFolder, 
                                                    m_szAccountId, 
                                                    pMemberInfo,
                                                    FOLDER_DRAFT == m_tySpecialFolder ? ARF_UNSENT : NOFLAGS,
                                                    pMemberInfo->pszHref, 
                                                    NULL)))
            {
                if (DB_E_DUPLICATE == hr)
                    hr = S_OK;
                else
                    goto exit;
            }
        }
        
        // update our message and unread message counts
        m_op.cMessages++;

        // if syncing the promo folder, no headers on the server will
        // ever appear to be read.
        if (FOLDER_MSNPROMO == m_tySpecialFolder)
        {
            if (!pFoundPair || !(pFoundPair->m_value.dwFlags & ARF_READ))
                m_op.cUnread++;
        }
        else if (!pMemberInfo->fRead)
            m_op.cUnread++;
    }

    if (pMemberList->pszFolderTimeStamp)
    {
        IF_FAILEXIT(hr = m_pAccount->SetPropSz(AP_HTTPMAIL_INBOXTIMESTAMP, pMemberList->pszFolderTimeStamp));
    }
exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_Disconnect
//----------------------------------------------------------------------
void CHTTPMailServer::_Disconnect(void)
{
    if (m_pTransport)
        m_pTransport->DropConnection();
}

//----------------------------------------------------------------------
// CHTTPMailServer::_BuildUrl
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_BuildUrl(LPCSTR pszFolderComponent, 
                                   LPCSTR pszNameComponent, 
                                   LPSTR *ppszUrl)
{
    HRESULT     hr = S_OK;
    DWORD       cchMsgFolderRoot = 0;
    DWORD       cchFolderComponent = 0;
    DWORD       cchNameComponent = 0;
    DWORD       cchWritten = 0;
    LPSTR       pszUrl = NULL;
    CHAR        chSlash = '/';

    Assert(NULL != m_pszMsgFolderRoot);
    Assert(NULL != ppszUrl);

    *ppszUrl = NULL;

    if (NULL == m_pszMsgFolderRoot)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    cchMsgFolderRoot = lstrlen(m_pszMsgFolderRoot);
    if (pszFolderComponent)
        cchFolderComponent = lstrlen(pszFolderComponent);
    if (pszNameComponent)
        cchNameComponent = lstrlen(pszNameComponent);

    // add three bytes - two for trailing slashes and one for the eos
    if (!MemAlloc((void **)&pszUrl, cchMsgFolderRoot + cchFolderComponent + cchNameComponent + 3))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    *ppszUrl = pszUrl;

    CopyMemory(pszUrl, m_pszMsgFolderRoot, cchMsgFolderRoot);
    cchWritten = cchMsgFolderRoot;
    // make sure the msg folder root is terminated with a '/'
    if (chSlash != pszUrl[cchWritten - 1])
        pszUrl[cchWritten++] = chSlash;

    if (cchFolderComponent)
    {
        CopyMemory(&pszUrl[cchWritten], pszFolderComponent, cchFolderComponent);
        cchWritten += cchFolderComponent;
        if (chSlash != pszUrl[cchWritten - 1])
            pszUrl[cchWritten++] = chSlash;
    }

    if (cchNameComponent)
    {
        CopyMemory(&pszUrl[cchWritten], pszNameComponent, cchNameComponent);
        cchWritten += cchNameComponent;
    }

    // null terminate the string
    pszUrl[cchWritten] = 0;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_BuildMessageUrl
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_BuildMessageUrl(LPCSTR pszFolderUrl, 
                                          LPSTR pszNameComponent, 
                                          LPSTR *ppszUrl)
{
    DWORD   cchFolderUrlLen;
    DWORD   cchNameComponentLen;

    if (NULL != ppszUrl)
        *ppszUrl = NULL;

    if (NULL == pszFolderUrl || NULL == pszNameComponent || NULL == ppszUrl)
        return E_INVALIDARG;
    
    cchFolderUrlLen = lstrlen(pszFolderUrl);
    cchNameComponentLen = lstrlen(pszNameComponent);

    // allocate two extra bytes - one for the '/' delimeter and one for the eos
    DWORD cchTotal = (cchFolderUrlLen + cchNameComponentLen + 2);
    if (!MemAlloc((void **)ppszUrl, cchTotal * sizeof((*ppszUrl)[0])))
        return E_OUTOFMEMORY;

    if ('/' == pszFolderUrl[cchFolderUrlLen - 1])
        wnsprintf(*ppszUrl, cchTotal, "%s%s", pszFolderUrl, pszNameComponent);
    else
        wnsprintf(*ppszUrl, cchTotal, "%s/%s", pszFolderUrl, pszNameComponent);

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_MarkMessageRead
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_MarkMessageRead(MESSAGEID id, BOOL fRead)
{
    HRESULT         hr;
    MESSAGEINFO     mi = {0};
    BOOL            fFoundRecord = FALSE;

    ZeroMemory(&mi, sizeof(MESSAGEINFO));
    mi.idMessage = id;

    // find the message in the database
    if (FAILED(hr = GetMessageInfo(m_pFolder, id, &mi)))
        goto exit;

    fFoundRecord = TRUE;

    if (fRead)
        mi.dwFlags |= ARF_READ;
    else
        mi.dwFlags &= ~ARF_READ;

    hr = m_pFolder->UpdateRecord(&mi);

exit:
    if (fFoundRecord)
        m_pFolder->FreeRecord(&mi);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::CreateFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::CreateFolder(void)
{
    HRESULT     hr = S_OK;
    CHAR        szEncodedName[MAX_PATH];
    DWORD       cb = sizeof(szEncodedName);

    Assert(NULL != m_pTransport);
    Assert(NULL != m_op.pszFolderName);

    IF_FAILEXIT(hr = UrlEscapeA(m_op.pszFolderName, 
                                szEncodedName, 
                                &cb, 
                                URL_ESCAPE_UNSAFE | URL_ESCAPE_PERCENT | URL_ESCAPE_SEGMENT_ONLY));
    
    IF_FAILEXIT(hr = _BuildUrl(szEncodedName, NULL, &m_op.pszDestFolderUrl));

    IF_FAILEXIT(hr = m_pTransport->CommandMKCOL(m_op.pszDestFolderUrl, 0));
    
    hr = E_PENDING;

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::RenameFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::RenameFolder(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    LPSTR           pszSourceUrl = NULL;
    LPSTR           pszDestUrl = NULL;
    CHAR            szEncodedName[MAX_PATH];
    DWORD           cb = sizeof(szEncodedName);

    // build the source url
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi));

    pfiFree = &fi;

    IF_FAILEXIT(hr = _BuildUrl(fi.pszUrlComponent, NULL, &pszSourceUrl));

    // escape the new folder name
    IF_FAILEXIT(hr = UrlEscapeA(m_op.pszFolderName, 
                                szEncodedName, 
                                &cb, 
                                URL_ESCAPE_UNSAFE | URL_ESCAPE_PERCENT | URL_ESCAPE_SEGMENT_ONLY));

    // build the destination url
    IF_FAILEXIT(hr = _BuildUrl(szEncodedName, NULL, &pszDestUrl));

    // send the MOVE command to the transport
    IF_FAILEXIT(hr = m_pTransport->CommandMOVE(pszSourceUrl, pszDestUrl, TRUE, 0));

    hr = E_PENDING;

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);
    SafeMemFree(pszSourceUrl);
    SafeMemFree(pszDestUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::DeleteFolder(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;
    LPSTR           pszUrl = NULL;

    // build the folder's url
    if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
        goto exit;

    pfiFree = &fi;

    if (FAILED(hr = _BuildUrl(fi.pszUrlComponent, NULL, &pszUrl)))
        goto exit;

    // send the delete command to the transport
    hr = m_pTransport->CommandDELETE(pszUrl, 0);
    if (SUCCEEDED(hr))
        hr = E_PENDING;

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);
    SafeMemFree(pszUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleCreateFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleCreateFolder(LPHTTPMAILRESPONSE pResponse)
{
    FOLDERINFO  fi;
    CHAR        szUrlComponent[MAX_PATH];
    DWORD       dwUrlComponentLen = MAX_PATH;
    HRESULT     hr = pResponse->rIxpResult.hrResult;

    if (SUCCEEDED(hr))
    {
        // if the server specified a location, use it. otherwise, use
        // the url that we included in the request
        if (NULL != pResponse->rMkColInfo.pszLocation)
            IF_FAILEXIT(hr = Http_NameFromUrl(pResponse->rMkColInfo.pszLocation, szUrlComponent, &dwUrlComponentLen));
        else
            IF_FAILEXIT(hr = Http_NameFromUrl(m_op.pszDestFolderUrl, szUrlComponent, &dwUrlComponentLen));

        // [shaheedp] Bug# 84477
        // If szUrlComponent is null, then we should not be adding this folder to the store. 
        if (!(*szUrlComponent))
        {
            hr = E_FAIL;
            goto exit;
        }

        ZeroMemory(&fi, sizeof(FOLDERINFO));

        fi.idParent = m_idServer;
        fi.tySpecial = FOLDER_NOTSPECIAL;
        fi.tyFolder = FOLDER_HTTPMAIL;
        fi.pszName = m_op.pszFolderName;
        fi.pszUrlComponent = szUrlComponent;
        fi.dwFlags = (FOLDER_SUBSCRIBED | FOLDER_NOCHILDCREATE);

        m_pStore->CreateFolder(NOFLAGS, &fi, NULL);
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleRenameFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleRenameFolder(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT         hr = S_OK;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;

    // REVIEW: if the server doesn't return a response, return an error
    Assert(NULL != pResponse->rCopyMoveInfo.pszLocation);
    if (NULL != pResponse->rCopyMoveInfo.pszLocation)
    {
        if (FAILED(hr = Http_NameFromUrl(pResponse->rCopyMoveInfo.pszLocation, szUrlComponent, &dwUrlComponentLen)))
            goto exit;
        
        if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
            goto exit;

        pfiFree = &fi;

        fi.pszName = m_op.pszFolderName;
        fi.pszUrlComponent = szUrlComponent;

        hr = m_pStore->UpdateRecord(&fi);
    }

exit:
    if (NULL != pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleDeleteFolder
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleDeleteFolder(LPHTTPMAILRESPONSE pResponse)
{
    return m_pStore->DeleteFolder(m_op.idFolder, DELETE_FOLDER_NOTRASHCAN, NULL);
}

//----------------------------------------------------------------------
// CHTTPMailServer::PurgeFolders
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PurgeFolders(void)
{
    // the folder list will be null if we didn't need
    // to do an auto-sync
    if (NULL != m_op.pFolderList)
        m_op.pFolderList->PurgeRemainingFromStore();

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PurgeMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PurgeMessages(void)
{
    TPair<CSimpleString, MARKEDMESSAGE>     *pPair;
    MESSAGEID                               idMessage = MESSAGEID_INVALID;
    MESSAGEIDLIST                           rIdList = { 1, 1, &idMessage }; 
    Assert(NULL != m_op.pmapMessageId);

    long lMapLength = m_op.pmapMessageId->GetLength();
    for (long lIndex = 0; lIndex < lMapLength; lIndex++)
    {
        pPair = m_op.pmapMessageId->GetItemAt(lIndex);
        if (NULL != pPair && !pPair->m_value.fMarked)
        {
            idMessage = pPair->m_value.idMessage;
            m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &rIdList, NULL, NULL /* m_op.pCallback */);
        }
    }

    // don't need the map anymore
    SafeDelete(m_op.pmapMessageId);

    return S_OK;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ResetMessageCounts
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ResetMessageCounts(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    LPFOLDERINFO    pfiFree = NULL;

    // find the folder
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_idFolder, &fi));

    pfiFree = &fi;

    // update the counts
    if (fi.cMessages != m_op.cMessages || fi.cUnread != m_op.cUnread)
    {
        fi.cMessages = m_op.cMessages;
        fi.cUnread = m_op.cUnread;
    }

    hr = m_pStore->UpdateRecord(&fi);

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::GetMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::GetMessage(void)
{
    HRESULT             hr = S_OK;
    MESSAGEINFO         mi = {0};
    BOOL                fFoundRecord = FALSE;
    LPCSTR              rgszAcceptTypes[] = { c_szAcceptTypeRfc822, c_szAcceptTypeWildcard, NULL };
    LPSTR               pszUrl = NULL;
    TCHAR               szRes[CCHMAX_STRINGRES];

    // pull the message info out of the store
    if (FAILED(hr = GetMessageInfo(m_pFolder, m_op.idMessage, &mi)))
        goto exit;

    fFoundRecord = TRUE;
    Assert(mi.pszUrlComponent);

    if (FAILED(hr =_BuildMessageUrl(m_pszFolderUrl, mi.pszUrlComponent, &pszUrl)))
        goto exit;

    AthLoadString(idsRequestingArt, szRes, ARRAYSIZE(szRes));
    
    if (m_op.pCallback)
        m_op.pCallback->OnProgress(m_op.tyOperation, 0, 0, szRes);

    if (FAILED(hr = m_pTransport->CommandGET(pszUrl, rgszAcceptTypes, FALSE, 0)))
        goto exit;

    hr = E_PENDING;
    
exit:
    if (fFoundRecord)
        m_pFolder->FreeRecord(&mi);

    SafeMemFree(pszUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::CreateSetFlagsRequest
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::CreateSetFlagsRequest(void)
{
    HRESULT     hr;

    hr = CoCreateInstance(CLSID_IPropPatchRequest, NULL, CLSCTX_INPROC_SERVER, IID_IPropPatchRequest, (LPVOID *)&m_op.pPropPatchRequest);
    if (FAILED(hr))
        goto exit;

    if (m_op.fMarkRead)
        hr = m_op.pPropPatchRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "1");
    else
        hr = m_op.pPropPatchRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "0");

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::SetMessageFlags
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::SetMessageFlags(void)
{
    HRESULT             hr = S_OK;
    LPHTTPTARGETLIST    pTargets = NULL;
    LPSTR               pszMessageUrl = NULL;
    ADJUSTFLAGS         af;

    af.dwAdd = m_op.fMarkRead ? ARF_READ : 0;
    af.dwRemove = !m_op.fMarkRead ? ARF_READ : 0;
    
    // if we have a rowset, we shouldn't have an ID List.
    Assert(NULL == m_op.hRowSet || NULL == m_op.pIDList);
    IF_FAILEXIT(hr = _HrBuildMapAndTargets(m_op.pIDList, m_op.hRowSet, &af, m_op.dwSetFlags, &m_op.pmapMessageId, &pTargets));

    // if the folder is the msnpromo folder, advance to the next state.
    // don't actually send the command to the server
    if (FOLDER_MSNPROMO == m_tySpecialFolder)
        goto exit;

    // if there is only one target, build a complete url for the target
    // and invoke the non-batch version of the command. if there are no targets,
    // return S_OK, and don't send any commands to the xport
    if (1 == pTargets->cTarget)
    {
        IF_FAILEXIT(hr = _BuildMessageUrl(m_pszFolderUrl, const_cast<char *>(pTargets->prgTarget[0]), &pszMessageUrl));
        IF_FAILEXIT(hr = m_pTransport->MarkRead(pszMessageUrl, NULL, m_op.fMarkRead, 0));

        hr = E_PENDING;
    }
    else if (pTargets->cTarget > 0)
    {
        IF_FAILEXIT(hr = m_pTransport->MarkRead(m_pszFolderUrl, pTargets, m_op.fMarkRead, 0));

        hr = E_PENDING;
    }

exit:
    if (pTargets)
        Http_FreeTargetList(pTargets);
    SafeMemFree(pszMessageUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::ApplyFlagsToStore
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::ApplyFlagsToStore(void)
{
    HRESULT                                 hr = S_OK;
    TPair<CSimpleString, MARKEDMESSAGE>     *pPair;
    long                                    lMapLength = m_op.pmapMessageId->GetLength();
    ADJUSTFLAGS                             af;
    BOOL                                    fFoundMarked = FALSE;
    long                                    lIndex;

    af.dwAdd = m_op.fMarkRead ? ARF_READ : 0;
    af.dwRemove = !m_op.fMarkRead ? ARF_READ : 0;
    
    // if the operation was requested on the entire folder,
    // check to see if anything failed. if it did, then
    // build up an IDList so we can mark only the msgs that
    // were successfully modified
    if (NULL != m_op.hRowSet)
    {
        Assert(NULL == m_op.pIDList);
        for (lIndex = 0; lIndex < lMapLength && !fFoundMarked; lIndex++)
        {
            pPair = m_op.pmapMessageId->GetItemAt(lIndex);
            Assert(NULL != pPair);
            if (pPair && pPair->m_value.fMarked)
                fFoundMarked = TRUE;
        }
        
        // if no messages were marked, apply the operation to the entire folder
        if (!fFoundMarked)
        {
            hr = m_pFolder->SetMessageFlags(NULL, &af, NULL, NULL);
            // we're done
            goto exit;
        }

        // if one or more msgs were marked, allocate an idlist
        if (fFoundMarked)
        {
            // allocate the list structure
            if (!MemAlloc((void **)&m_op.pIDList, sizeof(MESSAGEIDLIST)))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            ZeroMemory(m_op.pIDList, sizeof(MESSAGEIDLIST));

            // allocate storage
            if (!MemAlloc((void **)&m_op.pIDList->prgidMsg, sizeof(MESSAGEID) * lMapLength))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            m_op.pIDList->cAllocated = lMapLength;
            m_op.pIDList->cMsgs = 0;
        }
    }
    

    // we need to apply the setflags operation to the local store. we
    // can't just pass the message id list that we got originally,
    // because some of the operation may have failed. instead, we
    // rebuild the id list (in place, since we know the successful
    // operations will never outnumber the attempted operations),
    // and send that into the store
    Assert(NULL != m_op.pIDList);
    Assert(NULL != m_op.pmapMessageId);
    Assert(m_op.pIDList->cMsgs >= (DWORD)lMapLength);

    m_op.pIDList->cMsgs = 0;

    for (lIndex = 0; lIndex < lMapLength; lIndex++)
    {
        pPair = m_op.pmapMessageId->GetItemAt(lIndex);
        Assert(NULL != pPair);
        // if the item isn't marked, then it was successfully modified
        if (pPair && !pPair->m_value.fMarked)
            m_op.pIDList->prgidMsg[m_op.pIDList->cMsgs++] = pPair->m_value.idMessage;
    }

    // if the resulting id list contains at least one message, perform the operation
    if (m_op.pIDList->cMsgs > 0)
        hr = m_pFolder->SetMessageFlags(m_op.pIDList, &af, NULL, NULL);

    // todo: alert user if the operation failed in part
exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleMemberErrors
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleMemberErrors(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                             hr = S_OK;
    LPHTTPMEMBERERROR                   pme = NULL;
    CHAR                                szUrlComponent[MAX_PATH];
    DWORD                               dwComponentBytes;
    CSimpleString                       ss;
    TPair<CSimpleString, MARKEDMESSAGE> *pFoundPair = NULL;

    // loop through the response looking for errors. we ignore
    // per-item success.

    for (DWORD dw = 0; dw < pResponse->rMemberErrorList.cMemberError; dw++)
    {
        pme = &pResponse->rMemberErrorList.prgMemberError[dw];

        if (SUCCEEDED(pme->hrResult))
            continue;

        Assert(NULL != pme->pszHref);
        if (NULL == pme->pszHref)
            continue;

        dwComponentBytes = ARRAYSIZE(szUrlComponent);
        if (FAILED(Http_NameFromUrl(pme->pszHref, szUrlComponent, &dwComponentBytes)))
            continue;

        IF_FAILEXIT(hr = ss.SetString(szUrlComponent));
        
        // find and mark the found message
        pFoundPair = m_op.pmapMessageId->Find(ss);
        Assert(NULL != pFoundPair);
        if (NULL != pFoundPair)
            pFoundPair->m_value.fMarked = TRUE;
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::DeleteMessages(void)
{
    HRESULT             hr = S_OK;
    LPSTR               pszMessageUrl = NULL;
    LPSTR               pszNoDeleteSupport = NULL;

    // if we have a rowset, we shouldn't have an ID List
    Assert(NULL == m_op.hRowSet || NULL == m_op.pIDList);
    IF_FAILEXIT(hr = _HrBuildMapAndTargets(m_op.pIDList, m_op.hRowSet, NULL, 0, &m_op.pmapMessageId, &m_op.pTargets));

    // look for an already cached property that indicates that the server
    // isn't going to support deleting messages (Hotmail doesn't)
    if (GetAccountPropStrA(m_szAccountId, CAP_HTTPNOMESSAGEDELETES, &pszNoDeleteSupport))
    {
        if (!!(DELETE_MESSAGE_MAYIGNORENOTRASH & m_op.dwDelMsgFlags))
            m_op.fFallbackToMove = TRUE;
        else
            hr = SP_E_HTTP_NODELETESUPPORT;
        goto exit;
    }

    // if there is only one target, build a complete url for the target,
    // and call the non-batch version of the command. if there are no targets,
    // return S_OK and don't issue any commands
    if (!m_op.pTargets)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (1 == m_op.pTargets->cTarget)
    {
        IF_FAILEXIT(hr = _BuildMessageUrl(m_pszFolderUrl, const_cast<char *>(m_op.pTargets->prgTarget[0]), &pszMessageUrl));
        IF_FAILEXIT(hr = m_pTransport->CommandDELETE(pszMessageUrl, 0));
    }
    else
        IF_FAILEXIT(hr = m_pTransport->CommandBDELETE(m_pszFolderUrl, m_op.pTargets, 0));

    hr = E_PENDING;

exit:
    SafeMemFree(pszNoDeleteSupport);
    SafeMemFree(pszMessageUrl);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::DeleteFallbackToMove
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::DeleteFallbackToMove(void)
{
    HRESULT             hr = S_OK;
    IMessageFolder      *pDeletedItems = NULL;

    if (!m_op.fFallbackToMove)
        goto exit;

    // find the deleted items folder
    IF_FAILEXIT(hr = m_pStore->OpenSpecialFolder(m_idServer, NULL, FOLDER_DELETED, &pDeletedItems));
    if (NULL == pDeletedItems)
    {
        hr = TraceResult(IXP_E_HTTP_NOT_FOUND);
        goto exit;
    }

    IF_FAILEXIT(hr = pDeletedItems->GetFolderId(&m_op.idFolder));

    Assert(NULL == m_op.pMessageFolder);
    
    // should already have a targets list by this point
    Assert(NULL != m_op.pTargets);

    m_op.pMessageFolder = pDeletedItems;
    pDeletedItems = NULL;

    m_op.dwOptions = COPY_MESSAGE_MOVE;

    if (1 == m_op.pTargets->cTarget)
        hr = CopyMoveMessage();
    else
        hr = BatchCopyMoveMessages();

exit:
    SafeRelease(pDeletedItems);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleDeleteFallbackToMove
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleDeleteFallbackToMove(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = S_OK;

    if (1 == m_op.pTargets->cTarget)
        hr = HandleCopyMoveMessage(pResponse);
    else
        hr = HandleBatchCopyMoveMessages(pResponse);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PutMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PutMessage(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    LPFOLDERINFO    pfiFree = NULL;
    
    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi));

    pfiFree = &fi;

    IF_FAILEXIT(hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_op.pszDestFolderUrl));

    IF_FAILEXIT(hr = m_pTransport->CommandPOST(m_op.pszDestFolderUrl, m_op.pMessageStream, c_szAcceptTypeRfc822, 0));

    hr = E_PENDING;

exit:
    //SafeMemFree(pv);

    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::BatchCopyMoveMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::BatchCopyMoveMessages(void)
{
    HRESULT             hr = S_OK;
    FOLDERINFO          fi = {0};
    LPFOLDERINFO        pfiFree = NULL;
    
    // build the destination folder urls
    IxpAssert(NULL == m_op.pszDestFolderUrl);

    if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
    {
        TraceResult(hr);
        goto exit;
    }

    pfiFree = &fi;

    if (FAILED(hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_op.pszDestFolderUrl)))
        goto exit;

    Assert(NULL == m_op.pTargets || m_op.fFallbackToMove);

    // build the target list and the message id map
    if (NULL == m_op.pTargets)
        IF_FAILEXIT(hr = _HrBuildMapAndTargets(m_op.pIDList, NULL, NULL, 0, &m_op.pmapMessageId, &m_op.pTargets));

    if (!!(m_op.dwOptions & COPY_MESSAGE_MOVE))
        hr = m_pTransport->CommandBMOVE(m_pszFolderUrl, m_op.pTargets, m_op.pszDestFolderUrl, NULL, TRUE, 0);
    else
        hr = m_pTransport->CommandBCOPY(m_pszFolderUrl, m_op.pTargets, m_op.pszDestFolderUrl, NULL, TRUE, 0);

    if (SUCCEEDED(hr))
        hr = E_PENDING;

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::CopyMoveMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::CopyMoveMessage(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi = {0};
    LPFOLDERINFO    pfiFree = NULL;

    // build the destination folder urls
    IxpAssert(NULL == m_op.pszDestFolderUrl);

    if (FAILED(hr = m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
    {
        TraceResult(hr);
        goto exit;
    }

    pfiFree = &fi;

    if (FAILED(hr = _BuildUrl(fi.pszUrlComponent, NULL, &m_op.pszDestFolderUrl)))
        goto exit;

    hr = _CopyMoveNextMessage();

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::FinalizeBatchCopyMove
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::FinalizeBatchCopyMove(void)
{
    HRESULT     hr = S_OK;

    if (NOFLAGS != m_op.dwCopyMoveErrorFlags)
    {
        hr = E_FAIL;
        
        if (HTTPCOPYMOVE_OUTOFSPACE == m_op.dwCopyMoveErrorFlags)
            m_op.pszProblem = AthLoadString(idsHttpBatchCopyNoStorage, NULL, 0);
        else
            m_op.pszProblem = AthLoadString(idsHttpBatchCopyErrors, NULL , 0);
    }

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::PurgeDeletedFromStore
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::PurgeDeletedFromStore(void)
{
    HRESULT                                 hr = S_OK;
    TPair<CSimpleString, MARKEDMESSAGE>     *pPair;
    long                                    lMapLength = m_op.pmapMessageId->GetLength();
    BOOL                                    fFoundMarked = FALSE;
    long                                    lIndex;

    if (m_op.fFallbackToMove)
        goto exit;

    // if the operation was requested on the entire folder,
    // check to see if anything failed. if it did, then build
    // up an IDList so we can mark only the msgs that were
    // successfully modified
    if (NULL != m_op.hRowSet)
    {
        Assert(NULL == m_op.pIDList);
        for (lIndex = 0; lIndex < lMapLength && !fFoundMarked; lIndex++)
        {
            pPair = m_op.pmapMessageId->GetItemAt(lIndex);
            Assert(NULL != pPair);
            if (pPair && pPair->m_value.fMarked)
                fFoundMarked = TRUE;
        }
        
        // if no messages were marked, apply the operation to the entire folder
        if (!fFoundMarked)
        {
            hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, NULL, NULL, NULL);
            // we're done
            goto exit;
        }

        // if one or more msgs were marked, allocate an idlist
        if (fFoundMarked)
        {
            // allocate the list structure
            if (!MemAlloc((void **)&m_op.pIDList, sizeof(MESSAGEIDLIST)))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            ZeroMemory(m_op.pIDList, sizeof(MESSAGEIDLIST));

            // allocate storage
            if (!MemAlloc((void **)&m_op.pIDList->prgidMsg, sizeof(MESSAGEID) * lMapLength))
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            m_op.pIDList->cAllocated = lMapLength;
            m_op.pIDList->cMsgs = 0;
        }
    }

    // apply the delete operation to the local store. we can't just pass
    // the message id list that we got originally, because some of the operation
    // may have failed. instead, we rebuild the id list (in place, since we know
    // the successful operations will never outnumber the attempted operations,
    // and send that to the store.
    Assert(NULL != m_op.pIDList);
    Assert(NULL != m_op.pmapMessageId);
    Assert(m_op.pIDList->cMsgs >= (DWORD)lMapLength);

    // set the idlist count to 0. we will re-populate the
    // idlist with ids from the messageID map. We know that
    // the idlist is the same size as the map, so there won't
    // be an overflow problem.
    m_op.pIDList->cMsgs = 0;

    for (lIndex = 0; lIndex < lMapLength; lIndex++)
    {
        pPair = m_op.pmapMessageId->GetItemAt(lIndex);
        Assert(NULL != pPair);
        // if the item isn't marked, then it was successfully modified
        if (pPair && !pPair->m_value.fMarked)
            m_op.pIDList->prgidMsg[m_op.pIDList->cMsgs++] = pPair->m_value.idMessage;
    }

    // if the resulting id list contains at least one message, perform the operation
    if (m_op.pIDList->cMsgs > 0)
        hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, m_op.pIDList, NULL, NULL);

    // todo: alert user if the operation failed in part

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandlePutMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandlePutMessage(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT hr = S_OK;

    if (!pResponse->fDone && m_op.pCallback)
    {
        m_op.pCallback->OnProgress(m_op.tyOperation, 
                                   pResponse->rPostInfo.cbCurrent,
                                   pResponse->rPostInfo.cbTotal,
                                   NULL);
    }

    if (pResponse->fDone)
    {
        Assert(NULL != pResponse->rPostInfo.pszLocation);
        if (NULL == pResponse->rPostInfo.pszLocation)
        {
            hr = E_FAIL;
            goto exit;
        }

        // assume ownership of the location url
        m_op.pszDestUrl = pResponse->rPostInfo.pszLocation;
        pResponse->rPostInfo.pszLocation = NULL;
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::AddPutMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::AddPutMessage()
{
    HRESULT         hr = S_OK;
    IMessageFolder  *pFolder = NULL;
    MESSAGEID       idMessage;
    MESSAGEFLAGS    dwFlags;
    
    // adopt some of the flags of the message we are putting
    dwFlags = m_op.dwMsgFlags & (ARF_READ | ARF_SIGNED | ARF_ENCRYPTED | ARF_HASATTACH | ARF_VOICEMAIL);

    if (!!(m_op.dwMsgFlags & ARF_UNSENT) || FOLDER_DRAFT == m_tySpecialFolder)
        dwFlags |= ARF_UNSENT;

    IF_FAILEXIT(hr = m_pStore->OpenFolder(m_op.idFolder, NULL, NOFLAGS, &pFolder));
    
    IF_FAILEXIT(hr = Http_AddMessageToFolder(pFolder, m_szAccountId, NULL, dwFlags, m_op.pszDestUrl, &idMessage));
    
    IF_FAILEXIT(hr = Http_SetMessageStream(pFolder, idMessage, m_op.pMessageStream, NULL, TRUE));

    m_op.idPutMessage = idMessage;

exit:
    SafeRelease(pFolder);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleBatchCopyMoveMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleBatchCopyMoveMessages(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT                                 hr = S_OK;
    CHAR                                    szUrlComponent[MAX_PATH];
    DWORD                                   dwComponentBytes;
    LPHTTPMAILBCOPYMOVE                     pCopyMove;
    CSimpleString                           ss;
    TPair<CSimpleString, MARKEDMESSAGE>     *pFoundPair = NULL;
    HLOCK                                   hLockNotify = NULL;
    BOOL                                    fDeleteOriginal = !!(m_op.dwOptions & COPY_MESSAGE_MOVE);

    // This forces all notifications to be queued (this is good since you do segmented deletes)
    m_pFolder->LockNotify(0, &hLockNotify);

    for (DWORD dw = 0; dw < pResponse->rBCopyMoveList.cBCopyMove; dw++)
    {
        pCopyMove = &pResponse->rBCopyMoveList.prgBCopyMove[dw];
        
        if (FAILED(pCopyMove->hrResult))
        {
            if (IXP_E_HTTP_INSUFFICIENT_STORAGE == pCopyMove->hrResult)
                m_op.dwCopyMoveErrorFlags |= HTTPCOPYMOVE_OUTOFSPACE;
            else
                m_op.dwCopyMoveErrorFlags |= HTTPCOPYMOVE_ERROR;
            continue;
        }

        Assert(NULL != pCopyMove->pszHref);
        if (pCopyMove->pszHref)
        {
            dwComponentBytes = ARRAYSIZE(szUrlComponent);
            if (FAILED(Http_NameFromUrl(pCopyMove->pszHref, szUrlComponent, &dwComponentBytes)))
                continue;
            
            if (FAILED(ss.SetString(szUrlComponent)))
                goto exit;

            pFoundPair = m_op.pmapMessageId->Find(ss);
            Assert(NULL != pFoundPair);

            if (NULL == pFoundPair)
                continue;
            
            // move the message and, if the move succeeds, mark the success
            if (SUCCEEDED(_CopyMoveLocalMessage(pFoundPair->m_value.idMessage, m_op.pMessageFolder, pCopyMove->pszLocation, fDeleteOriginal)))
                pFoundPair->m_value.fMarked = TRUE;
        }
    }

exit:
    m_pFolder->UnlockNotify(&hLockNotify);

    m_op.lIndex += pResponse->rBCopyMoveList.cBCopyMove;
    if (m_op.pCallback)
        m_op.pCallback->OnProgress(m_op.tyOperation, m_op.lIndex + 1, m_op.pmapMessageId->GetLength(), NULL);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::HandleCopyMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::HandleCopyMoveMessage(LPHTTPMAILRESPONSE pResponse)
{
    HRESULT         hr = S_OK;
    BOOL            fDeleteOriginal = !!(m_op.dwOptions & COPY_MESSAGE_MOVE);

    hr = _CopyMoveLocalMessage(m_op.pIDList->prgidMsg[m_op.dwIndex - 1], 
                        m_op.pMessageFolder, 
                        pResponse->rCopyMoveInfo.pszLocation,
                        fDeleteOriginal);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_CopyMoveLocalMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_CopyMoveLocalMessage(MESSAGEID    idMessage,
                                           IMessageFolder*  pDestFolder,
                                           LPSTR            pszUrl,
                                           BOOL             fMoveSource)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     miSource, miDest;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    IStream        *pStream = NULL;
    LPMESSAGEINFO   pmiFreeSource = NULL;
    MESSAGEIDLIST   rIdList = { 1, 1, &idMessage }; 

    ZeroMemory(&miDest, sizeof(MESSAGEINFO));

    if (FAILED(hr = GetMessageInfo(m_pFolder, idMessage, &miSource)))
        goto exit;

    pmiFreeSource = &miSource;

    // get the store to generate an id
    if (FAILED(hr = pDestFolder->GenerateId((DWORD *)&miDest.idMessage)))
        goto exit;

    // if the response specified a destination, use it. otherwise, assume
    // that the url component did not change
    if (pszUrl)
    {
        if (FAILED(hr = Http_NameFromUrl(pszUrl, szUrlComponent, &dwUrlComponentLen)))
            goto exit;
    }
    else if (miSource.pszUrlComponent)
    {
        StrCpyN(szUrlComponent, miSource.pszUrlComponent, ARRAYSIZE(szUrlComponent));
    }

    miDest.dwFlags = miSource.dwFlags;
    miDest.dwFlags &= ~(ARF_HASBODY | ARF_DELETED_OFFLINE);
    miDest.pszSubject = miSource.pszSubject;
    miDest.pszNormalSubj = miSource.pszNormalSubj;
    miDest.pszDisplayFrom = miSource.pszDisplayFrom;
    miDest.ftReceived = miSource.ftReceived;
    miDest.pszUrlComponent = szUrlComponent;
    miDest.pszEmailTo = miSource.pszEmailTo;

    // add it to the database
    if (FAILED(hr = m_op.pMessageFolder->InsertRecord(&miDest)))
        goto exit;

    // normalize the result code
    hr = S_OK;

    if (0 != miSource.faStream)
    {
        FILEADDRESS faDst;
        IStream *pStmDst;

        Assert(!!(miSource.dwFlags & ARF_HASBODY));

        if (FAILED(hr = m_pFolder->CopyStream(m_op.pMessageFolder, miSource.faStream, &faDst)))
            goto exit;

        if (FAILED(hr = m_op.pMessageFolder->OpenStream(ACCESS_READ, faDst, &pStmDst)))
            goto exit;

        if (FAILED(hr = m_op.pMessageFolder->SetMessageStream(miDest.idMessage, pStmDst)))
        {
            pStmDst->Release();
            goto exit;
        }

        pStmDst->Release();
    }

    if (fMoveSource)
        hr = m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &rIdList, NULL, NULL);

exit:
    SafeRelease(pStream);
    if (NULL != pmiFreeSource)
        m_pFolder->FreeRecord(pmiFreeSource);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_CopyMoveNextMessage
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_CopyMoveNextMessage(void)
{
    HRESULT         hr = S_OK;
    MESSAGEINFO     mi = {0};
    MESSAGEINFO     *pmiFree = NULL;
    char            szUrlComponent[MAX_PATH];
    DWORD           dwUrlComponentLen = MAX_PATH;
    LPSTR           pszSourceUrl = NULL;
    LPSTR           pszDestUrl = NULL;

    // return success when the index meets the count
    if (m_op.dwIndex == m_op.pIDList->cMsgs)
        goto exit;

    if (FAILED(hr = GetMessageInfo(m_pFolder, m_op.pIDList->prgidMsg[m_op.dwIndex], &mi)))
        goto exit;

    pmiFree = &mi;

    ++m_op.dwIndex;

    Assert(mi.pszUrlComponent);
    if (NULL == mi.pszUrlComponent)
    {
        hr = ERROR_INTERNET_INVALID_URL;
        goto exit;
    }

    // build the source url
    if (FAILED(hr = _BuildMessageUrl(m_pszFolderUrl, mi.pszUrlComponent, &pszSourceUrl)))
        goto exit;

    // build the destination url
    if (FAILED(hr = _BuildMessageUrl(m_op.pszDestFolderUrl, mi.pszUrlComponent, &pszDestUrl)))
        goto exit;

    if (!!(m_op.dwOptions & COPY_MESSAGE_MOVE))
        hr = m_pTransport->CommandMOVE(pszSourceUrl, pszDestUrl, TRUE, 0);
    else
        hr = m_pTransport->CommandCOPY(pszSourceUrl, pszDestUrl, TRUE, 0);
    
    if (SUCCEEDED(hr))
        hr = E_PENDING;

exit:
    if (NULL != pmiFree)
        m_pFolder->FreeRecord(pmiFree);
    SafeMemFree(pszSourceUrl);
    SafeMemFree(pszDestUrl);

    return hr;
    
}

//----------------------------------------------------------------------
// CHTTPMailServer::_DoCopyMoveMessages
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_DoCopyMoveMessages(STOREOPERATIONTYPE sot,
                                                IMessageFolder *pDest,
                                                COPYMESSAGEFLAGS dwOptions,
                                                LPMESSAGEIDLIST pList,
                                                IStoreCallback *pCallback)
{
    HRESULT     hr = S_OK;

    AssertSingleThreaded;

    Assert(NULL == pList || pList->cMsgs > 0);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if ((NULL == pList) || (0 == pList->cMsgs) || (NULL == pDest) || (NULL == pCallback))
        return E_INVALIDARG;

    if (FAILED(hr = pDest->GetFolderId(&m_op.idFolder)))
        goto exit;

    if (FAILED(hr = CloneMessageIDList(pList, &m_op.pIDList)))
    {
        m_op.idFolder = FOLDERID_INVALID;
        goto exit;
    }
    
    m_op.tyOperation = sot;

    if (1 == pList->cMsgs)
    {
        m_op.pfnState = c_rgpfnCopyMoveMessage;
        m_op.cState = ARRAYSIZE(c_rgpfnCopyMoveMessage);
    }
    else
    {
        m_op.pfnState = c_rgpfnBatchCopyMoveMessages;
        m_op.cState = ARRAYSIZE(c_rgpfnBatchCopyMoveMessages);
    }
    
    m_op.dwOptions = dwOptions;
    m_op.iState = 0;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.pMessageFolder = pDest;
    m_op.pMessageFolder->AddRef();

    hr = _BeginDeferredOperation();

exit:
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_LoadAccountInfo
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_LoadAccountInfo(IImnAccount *pAcct)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    FOLDERINFO      *pfiFree = NULL;;

    Assert(NULL != pAcct);
    Assert(FOLDERID_INVALID != m_idServer);
    Assert(NULL != m_pStore);
    Assert(NULL != g_pAcctMan);

    // free data associated with the account. if we connected to
    // a transport, and then disconnected, we might be reconnecting
    // with stale data left around.
    SafeMemFree(m_pszFldrLeafName);

    IF_FAILEXIT(hr = m_pStore->GetFolderInfo(m_idServer, &fi));
    
    pfiFree = &fi;

    m_pszFldrLeafName = PszDupA(fi.pszName);
    if (NULL == m_pszFldrLeafName)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // failure of the account name is recoverable
    pAcct->GetPropSz(AP_ACCOUNT_NAME, m_szAccountName, sizeof(m_szAccountName));

exit:
    if (pfiFree)
        m_pStore->FreeRecord(pfiFree);

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_LoadTransport
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_LoadTransport(void)
{
    HRESULT         hr = S_OK;
    char            szLogFilePath[MAX_PATH];
    char            *pszLogFilePath = NULL;
    LPSTR           pszUserAgent = NULL;
    
    Assert(NULL == m_pTransport);

    // Create and initialize HTTPMail transport
    hr = CoCreateInstance(CLSID_IHTTPMailTransport, NULL, CLSCTX_INPROC_SERVER, IID_IHTTPMailTransport, (LPVOID *)&m_pTransport);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    IF_FAILEXIT(hr = m_pTransport->QueryInterface(IID_IHTTPMailTransport2, (LPVOID*)&m_pTransport2));

    // check if logging is enabled
    if (DwGetOption(OPT_MAIL_LOGHTTPMAIL))
    {
        char    szDirectory[MAX_PATH];
        char    szLogFileName[MAX_PATH];

        DWORD   cb;

        *szDirectory = 0;

        // get the log filename
        cb = GetOption(OPT_MAIL_HTTPMAILLOGFILE, szLogFileName, sizeof(szLogFileName) / sizeof(TCHAR));
        if (0 == cb)
        {
            // push the defaults into the registry
            StrCpyN(szLogFileName, c_szDefaultHTTPMailLog, ARRAYSIZE(szLogFileName));
            SetOption(OPT_MAIL_HTTPMAILLOGFILE,
                (void *)c_szDefaultHTTPMailLog,
                lstrlen(c_szDefaultHTTPMailLog) + sizeof(TCHAR),
                NULL,
                0);                        
        }

        m_pStore->GetDirectory(szDirectory, ARRAYSIZE(szDirectory));
        PathCombineA(szLogFilePath, szDirectory, szLogFileName);

        pszLogFilePath = szLogFilePath;
    }

    pszUserAgent = GetOEUserAgentString();
    if (FAILED(hr = m_pTransport->InitNew(pszUserAgent, pszLogFilePath, this)))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    SafeMemFree(pszUserAgent);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_TranslateHTTPSpecialFolderType
//----------------------------------------------------------------------
SPECIALFOLDER CHTTPMailServer::_TranslateHTTPSpecialFolderType(HTTPMAILSPECIALFOLDER tySpecial)
{
    SPECIALFOLDER tyOESpecial;

    switch (tySpecial)
    {
        case HTTPMAIL_SF_INBOX:
            tyOESpecial = FOLDER_INBOX;
            break;

        case HTTPMAIL_SF_DELETEDITEMS:
            tyOESpecial = FOLDER_DELETED;
            break;

        case HTTPMAIL_SF_DRAFTS:
            tyOESpecial = FOLDER_DRAFT;
            break;

        case HTTPMAIL_SF_OUTBOX:
            tyOESpecial = FOLDER_OUTBOX;
            break;

        case HTTPMAIL_SF_SENTITEMS:
            tyOESpecial = FOLDER_SENT;
            break;

        case HTTPMAIL_SF_MSNPROMO:
            tyOESpecial = FOLDER_MSNPROMO;
            break;

        case HTTPMAIL_SF_BULKMAIL:
            tyOESpecial = FOLDER_BULKMAIL;
            break;

        default:
            tyOESpecial = FOLDER_NOTSPECIAL;
            break;
    }

    return tyOESpecial;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_LoadSpecialFolderName
//----------------------------------------------------------------------
BOOL CHTTPMailServer::_LoadSpecialFolderName(SPECIALFOLDER tySpecial,
                                             LPSTR pszName,
                                             DWORD cbBuffer)
{
    BOOL    fResult = TRUE;
    UINT    uID;

    switch (tySpecial)
    {
        case FOLDER_INBOX:
            uID = idsInbox;
            break;

        case FOLDER_DELETED:
            uID = idsDeletedItems;
            break;

        case FOLDER_DRAFT:
            uID = idsDraft;
            break;

        case FOLDER_OUTBOX:
            uID = idsOutbox;
            break;

        case FOLDER_SENT:
            uID = idsSentItems;
            break;

        case FOLDER_MSNPROMO:
            uID = idsMsnPromo;
            break;

        case FOLDER_BULKMAIL:
            uID = idsJunkFolderName;
            break;

        default:
            fResult = FALSE;
            break;
    }

    if (fResult && (0 == LoadString(g_hLocRes, uID, pszName, cbBuffer)))
        fResult = FALSE;

    return fResult;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_CreateMessageIDMap
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_CreateMessageIDMap(TMap<CSimpleString, MARKEDMESSAGE> **ppMap)
{
    HRESULT                                 hr = S_OK;
    TMap<CSimpleString, MARKEDMESSAGE>      *pMap = NULL;
    HROWSET                                 hRowSet = NULL;
    MESSAGEINFO                             mi;
    CSimpleString                           ss;
    MARKEDMESSAGE                           markedID = { 0, 0, FALSE };

    if (NULL == m_pStore || NULL == ppMap)
        return E_INVALIDARG;

    *ppMap = NULL;

    pMap = new TMap<CSimpleString, MARKEDMESSAGE>;
    if (NULL == pMap)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(&mi, sizeof(MESSAGEINFO));

    if (FAILED(hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowSet)))
        goto exit;

    // iterate through the messages
    while (S_OK == m_pFolder->QueryRowset(hRowSet, 1, (LPVOID *)&mi, NULL))
    {
        // add the message's info to the map
        markedID.idMessage = mi.idMessage;
        markedID.dwFlags = mi.dwFlags;

        hr = ss.SetString(mi.pszUrlComponent);
        if (FAILED(hr))
        {
            m_pFolder->FreeRecord(&mi);
            goto exit;
        }

        hr = pMap->Add(ss, markedID);

        // Free
        m_pFolder->FreeRecord(&mi);
        
        if (FAILED(hr))
            goto exit;
    }

    // the map was built successfully
    *ppMap = pMap;
    pMap = NULL;

exit:
    if (NULL != hRowSet)
        m_pFolder->CloseRowset(&hRowSet);

    if (NULL != pMap)
        delete pMap;

    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_HrBuildMapAndTargets
//----------------------------------------------------------------------
HRESULT CHTTPMailServer::_HrBuildMapAndTargets(LPMESSAGEIDLIST pList,
                                               HROWSET hRowSet,
                                               LPADJUSTFLAGS pFlags,
                                               SETMESSAGEFLAGSFLAGS dwFlags,
                                               TMap<CSimpleString, MARKEDMESSAGE> **ppMap,
                                               LPHTTPTARGETLIST *ppTargets)
{
    HRESULT                                 hr = S_OK;
    TMap<CSimpleString, MARKEDMESSAGE>      *pMap = NULL;
    LPHTTPTARGETLIST                        pTargets = NULL;
    MESSAGEINFO                             mi = { 0 };
    LPMESSAGEINFO                           pmiFree = NULL;
    CSimpleString                           ss;
    MARKEDMESSAGE                           markedID = { 0, 0, FALSE };
    BOOL                                    fSkipRead = (pFlags && !!(pFlags->dwAdd & ARF_READ));
    BOOL                                    fSkipUnread = (pFlags && !!(pFlags->dwRemove & ARF_READ));
    DWORD                                   cMsgs;
    DWORD                                   dwIndex = 0;

    if ((NULL == pList && NULL == hRowSet) || NULL == ppMap || NULL == ppTargets)
        return E_INVALIDARG;

    // expect either a list or a rowset, but not both
    Assert(NULL == pList || NULL == hRowSet);

    // if using a rowset, determine the rowcount
    if (NULL != hRowSet)
    {
        IF_FAILEXIT(hr = m_pFolder->GetRecordCount(0, &cMsgs));

        // seek the first row
        IF_FAILEXIT(hr = m_pFolder->SeekRowset(hRowSet, SEEK_ROWSET_BEGIN, 0, NULL));
    }
    else
        cMsgs = pList->cMsgs;

    *ppMap = NULL;
    *ppTargets = NULL;

    pMap = new TMap<CSimpleString, MARKEDMESSAGE>;
    if (NULL == pMap)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (!MemAlloc((void **)&pTargets, sizeof(HTTPTARGETLIST)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    pTargets->cTarget = 0;
    pTargets->prgTarget = NULL;

    // allocate enough space for all of the targets
    if (!MemAlloc((void **)&pTargets->prgTarget, sizeof(LPCSTR) * cMsgs))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    ZeroMemory(pTargets->prgTarget, sizeof(LPCSTR) * cMsgs);

    while (TRUE)
    {
        // fetch the next message
        if (NULL != pList)
        {
            if (dwIndex == pList->cMsgs)
                break;

            hr = GetMessageInfo(m_pFolder, pList->prgidMsg[dwIndex++], &mi);
            
            // if the record wasn't found, just skip it
            if (DB_E_NOTFOUND == hr)
                goto next;

            if (FAILED(hr))
                break;
        }
        else
        {
            // bail out if the number of targets is the same as the rowcount
            // we expected. this will prevent us from overflowing the target
            // array if the rowcount changes while we are building up our target
            // list.
            if (pTargets->cTarget == cMsgs)
                break;

            if (S_OK != m_pFolder->QueryRowset(hRowSet, 1, (LPVOID *)&mi, NULL))
                break;
        }

        pmiFree = &mi;

        // respect control flags, if they exist
        if (0 == (dwFlags & SET_MESSAGE_FLAGS_FORCE) && ((fSkipRead && !!(mi.dwFlags & ARF_READ)) || (fSkipUnread && !(mi.dwFlags & ARF_READ))))
            goto next;

        Assert(NULL != mi.pszUrlComponent);
        if (NULL == mi.pszUrlComponent)
        {
            hr = TrapError(ERROR_INTERNET_INVALID_URL);
            goto exit;
        }
        
        // add the url component to the target list
        pTargets->prgTarget[pTargets->cTarget] = PszDupA(mi.pszUrlComponent);
        if (NULL == pTargets->prgTarget[pTargets->cTarget])
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        pTargets->cTarget++;

        // add the url and the message id to the map
        markedID.idMessage = mi.idMessage;
        markedID.dwFlags = mi.dwFlags;

        if (FAILED(hr = ss.SetString(mi.pszUrlComponent)))
            goto exit;

        if (FAILED(hr = pMap->Add(ss, markedID)))
            goto exit;

next:
        if (pmiFree)
        {
            m_pFolder->FreeRecord(pmiFree);
            pmiFree = NULL;
        }
        hr = S_OK;
    }
    
    *ppMap = pMap;
    pMap = NULL;

    *ppTargets = pTargets;
    pTargets = NULL;

exit:
    if (pmiFree)
        m_pFolder->FreeRecord(pmiFree);

    if (pTargets)
        Http_FreeTargetList(pTargets);

    SafeDelete(pMap);
    return hr;
}

//----------------------------------------------------------------------
// CHTTPMailServer::_FillStoreError
//----------------------------------------------------------------------
void CHTTPMailServer::_FillStoreError(LPSTOREERROR pErrorInfo, 
                                      IXPRESULT *pResult)
{
    TraceCall("CHTTPMailServer::FillStoreError");

    Assert(m_cRef >= 0); // Can be called during destruction
    Assert(NULL != pErrorInfo);

    //TODO: Fill in pszFolder

    // Fill out the STOREERROR structure
    ZeroMemory(pErrorInfo, sizeof(*pErrorInfo));
    if (IXP_E_USER_CANCEL == pResult->hrResult)
        pErrorInfo->hrResult = STORE_E_OPERATION_CANCELED;
    else
        pErrorInfo->hrResult = pResult->hrResult;
    pErrorInfo->uiServerError = pResult->uiServerError; 
    pErrorInfo->hrServerError = pResult->hrServerError;
    pErrorInfo->dwSocketError = pResult->dwSocketError; 
    pErrorInfo->pszProblem = (NULL != m_op.pszProblem) ? m_op.pszProblem : pResult->pszProblem;
    pErrorInfo->pszDetails = pResult->pszResponse;
    pErrorInfo->pszAccount = m_rInetServerInfo.szAccount;
    pErrorInfo->pszServer = m_rInetServerInfo.szServerName;
    pErrorInfo->pszFolder = NULL;
    pErrorInfo->pszUserName = m_rInetServerInfo.szUserName;
    pErrorInfo->pszProtocol = "HTTPMail";
    pErrorInfo->pszConnectoid = m_rInetServerInfo.szConnectoid;
    pErrorInfo->rasconntype = m_rInetServerInfo.rasconntype;
    pErrorInfo->ixpType = IXP_HTTPMail;
    pErrorInfo->dwPort = m_rInetServerInfo.dwPort;
    pErrorInfo->fSSL = m_rInetServerInfo.fSSL;
    pErrorInfo->fTrySicily = m_rInetServerInfo.fTrySicily;
    pErrorInfo->dwFlags = 0;
}

STDMETHODIMP    CHTTPMailServer::GetAdBarUrl(IStoreCallback *pCallback)
{
    TraceCall("CHTTPMailServer::GetAdBarUrl");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation = SOT_GET_ADURL;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnGetAdUrl;
    m_op.cState = ARRAYSIZE(c_rgpfnGetAdUrl);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
    
}

HRESULT CHTTPMailServer::GetAdBarUrlFromServer()
{
    HRESULT     hr = S_OK;
    LPSTR       pszUrl = NULL;

    hr = m_pTransport->GetProperty(HTTPMAIL_PROP_ADBAR, &pszUrl);

    if (hr == S_OK)
        m_op.pszAdUrl = pszUrl;

    return hr;

}

STDMETHODIMP    CHTTPMailServer::GetMinPollingInterval(IStoreCallback *pCallback)
{
    TraceCall("CHTTPMailServer::GetMinPollingInterval");

    AssertSingleThreaded;
    Assert(NULL != pCallback);
    Assert(SOT_INVALID == m_op.tyOperation);
    Assert(NULL != m_pStore);

    if (NULL == pCallback)
        return E_INVALIDARG;

    m_op.tyOperation = SOT_GET_HTTP_MINPOLLINGINTERVAL;
    m_op.iState = 0;
    m_op.pfnState = c_rgpfnGetMinPollingInterval;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMinPollingInterval);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    return _BeginDeferredOperation();
    
}

HRESULT CHTTPMailServer::GetMinPollingInterval()
{
    DWORD       dwDone               = FALSE;
    DWORD       dwPollingInterval    = 0;
    HRESULT     hr                   = S_OK;

    hr = m_pTransport->GetPropertyDw(HTTPMAIL_PROP_MAXPOLLINGINTERVAL, &dwPollingInterval);

    if (hr == S_OK)
        m_op.dwMinPollingInterval = dwPollingInterval;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\imap\imapute.cpp ===
/*
 *    imaputil.cpp
 *
 *    Purpose:
 *        Implements IMAP utility functions
 *
 *    Owner:
 *        Raych
 *
 *    Copyright (C) Microsoft Corp. 1996
 */


//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include "imapute.h"
#include "storutil.h"
#include "imapsync.h"


//---------------------------------------------------------------------------
// Forward Declarations
//---------------------------------------------------------------------------
DWORD ImapUtil_ReverseSentence(LPSTR pszSentence, char cDelimiter);
void ImapUtil_ReverseString(LPSTR pszStart, LPSTR pszEnd);


//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------
const char c_szIMAP_MSG_ANSWERED[] = "Answered";
const char c_szIMAP_MSG_FLAGGED[] = "Flagged";
const char c_szIMAP_MSG_DELETED[] = "Deleted";
const char c_szIMAP_MSG_DRAFT[] = "Draft";
const char c_szIMAP_MSG_SEEN[] = "Seen";
const char c_szBACKSLASH[] = "\\";

typedef struct tagIMFToStr_LUT {
    IMAP_MSGFLAGS imfValue;
    LPCSTR pszValue;
} IMFTOSTR_LUT;

const IMFTOSTR_LUT g_IMFToStringLUT[] = {
    {IMAP_MSG_ANSWERED, c_szIMAP_MSG_ANSWERED},
    {IMAP_MSG_FLAGGED, c_szIMAP_MSG_FLAGGED},
    {IMAP_MSG_DELETED, c_szIMAP_MSG_DELETED},
    {IMAP_MSG_SEEN, c_szIMAP_MSG_SEEN},
    {IMAP_MSG_DRAFT, c_szIMAP_MSG_DRAFT}};



//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------

//***************************************************************************
// Function: ImapUtil_MsgFlagsToString
//
// Purpose:
//   This function converts a IMAP_MSGFLAGS register to its string
// equivalent. For instance, IMAP_MSG_SEEN is converted to "(\Seen)".
//
// Arguments:
//   IMAP_MSGFLAGS imfSource [in] - IMAP_MSGFLAGS register to convert to
//     string.
//   LPSTR *ppszDestination [out] - the string equivalent is returned here.
//     If imfSource is 0, NULL is returned here. Otherwise, a string buffer
//     is returned which the caller must MemFree when he is done with it.
//   DWORD *pdwLengthOfDestination [out] - the length of *ppszDestination.
//     Pass in NULL if not interested.
//
// Returns:
//   HRESULT indicating success or failure. Remember that it is possible
// for a successful HRESULT to be returned, even is *ppszDestination is NULL.
//***************************************************************************
HRESULT ImapUtil_MsgFlagsToString(IMAP_MSGFLAGS imfSource,
                                  LPSTR *ppszDestination,
                                  DWORD *pdwLengthOfDestination)
{
    CByteStream         bstmOutput;
    HRESULT             hrResult;
    const IMFTOSTR_LUT *pCurrent;
    const IMFTOSTR_LUT *pLastEntry;
    BOOL                fFirstFlag;

    TraceCall("ImapUtil_MsgFlagsToString");
    Assert(NULL != ppszDestination);
    AssertSz(0 == (imfSource & ~IMAP_MSG_ALLFLAGS), "Quit feeding me garbage.");

    // Codify assumptions
    Assert(IMAP_MSG_ALLFLAGS == 0x0000001F);

    *ppszDestination = NULL;
    if (NULL != pdwLengthOfDestination)
        *pdwLengthOfDestination = 0;

    if (0 == (imfSource & IMAP_MSG_ALLFLAGS))
        return S_FALSE; // Nothing to do here!

    hrResult = bstmOutput.Write("(", 1, NULL);
    if (FAILED(hrResult))
        goto exit;

    fFirstFlag = TRUE;
    pCurrent = g_IMFToStringLUT;
    pLastEntry = pCurrent + sizeof(g_IMFToStringLUT)/sizeof(IMFTOSTR_LUT) - 1;
    while (pCurrent <= pLastEntry) {

        if (imfSource & pCurrent->imfValue) {
            // Prepend a space to flag, if necessary
            if (FALSE == fFirstFlag) {
                hrResult = bstmOutput.Write(g_szSpace, 1, NULL);
                if (FAILED(hrResult))
                    goto exit;
            }
            else
                fFirstFlag = FALSE;

            // Output the backslash
            hrResult = bstmOutput.Write(c_szBACKSLASH,
                sizeof(c_szBACKSLASH) - 1, NULL);
            if (FAILED(hrResult))
                goto exit;

            // Output string associated with this IMAP flag
            hrResult = bstmOutput.Write(pCurrent->pszValue,
                lstrlen(pCurrent->pszValue), NULL);
            if (FAILED(hrResult))
                goto exit;
        } // if (imfSource & pCurrent->imfValue)

        // Advance current pointer
        pCurrent += 1;
    } // while

    hrResult = bstmOutput.Write(")", 1, NULL);
    if (FAILED(hrResult))
        goto exit;

    hrResult = bstmOutput.HrAcquireStringA(pdwLengthOfDestination,
        ppszDestination, ACQ_DISPLACE);

exit:
    return hrResult;
} // IMAPMsgFlagsToString



//***************************************************************************
// Function: ImapUtil_FolderIDToPath
//
// Purpose:
//   This function takes the given FolderID and returns the full path
// (including prefix) to the folder. The caller may also choose to append
// a string to the path.
//
// Arguments:
//   FolderID idFolder [in] - FolderID to convert into a full path.
//   char **ppszPath [out] - a full path to idFolder is returned here.
//   LPDWORD pdwPathLen [out] - if non-NULL, the length of *ppszPath is
//     returned here.
//   char *pcHierarchyChar [out] - the hierarchy char used to interpret
//     *ppszPath is returned here.
//   CFolderCache *pFldrCache [in] - a CFolderCache to use to generate
//     the path.
//   LPCSTR pszAppendStr [in] - this can be NULL if the caller does not need
//     to append a string to the path. Otherwise, a hierarchy character is
//     appended to the path and this string is appended after the HC. This
//     argument is typically used to tack a wildcard to the end of the path.
//   LPCSTR pszRootFldrPrefix [in] - the root folder prefix for this IMAP
//     account. If this is NULL, this function will find out for itself.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT ImapUtil_FolderIDToPath(FOLDERID idServer, FOLDERID idFolder, char **ppszPath,
                                LPDWORD pdwPathLen, char *pcHierarchyChar,
                                IMessageStore *pFldrCache, LPCSTR pszAppendStr,
                                LPCSTR pszRootFldrPrefix)
{
    FOLDERINFO  fiPath;
    HRESULT     hrResult;
    CByteStream bstmPath;
    DWORD       dwLengthOfPath;
    LPSTR       pszEnd;
    char        szRootFldrPrefix[MAX_PATH];
    char        szAccount[CCHMAX_ACCOUNT_NAME];
    BOOL        fAppendStrHC = FALSE,
                fFreeFldrInfo = FALSE;
    BOOL        fSpecialFldr = FALSE;
    DWORD       dwLen;
    
    TraceCall("ImapUtil_FolderIDToPath");
    
    if (FOLDERID_INVALID == idFolder || FOLDERID_INVALID == idServer)
    {
        hrResult = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Build full path to current folder in reverse (leaf->root)
    // Limited buffer overflow risk since user input limited to MAX_PATH

    // Start off with target folder (leaf) and return its HC if so requested
    hrResult = pFldrCache->GetFolderInfo(idFolder, &fiPath);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    fFreeFldrInfo = TRUE;

    GetFolderAccountId(&fiPath, szAccount, ARRAYSIZE(szAccount));

    if (NULL != pcHierarchyChar)
    {
        Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
        *pcHierarchyChar = (char) fiPath.bHierarchy;
    }

    // Append anything the user asked us to (will be at end of str after reversal)
    if (NULL != pszAppendStr)
    {
        char    szBuf[MAX_PATH + 1];

        // First, have to reverse the append string itself, in case it contains HC's
        Assert(lstrlen(pszAppendStr) < ARRAYSIZE(szBuf));
        StrCpyN(szBuf, pszAppendStr, ARRAYSIZE(szBuf));
        dwLen = ImapUtil_ReverseSentence(szBuf, fiPath.bHierarchy);

        hrResult = bstmPath.Write(szBuf, dwLen, NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
        fAppendStrHC = TRUE;
    }

    // Check if user gave us a root folder prefix: otherwise we need to load it ourselves
    if (NULL == pszRootFldrPrefix)
    {
        ImapUtil_LoadRootFldrPrefix(szAccount, szRootFldrPrefix, sizeof(szRootFldrPrefix));
        pszRootFldrPrefix = szRootFldrPrefix;
    }
    else
        // Copy to our buffer because we're going to reverse the RFP
        StrCpyN(szRootFldrPrefix, pszRootFldrPrefix, ARRAYSIZE(szRootFldrPrefix));

    // Proceed to root
    while (FALSE == fSpecialFldr && idServer != fiPath.idFolder)
    {
        LPSTR pszFolderName;

        Assert(FOLDERID_INVALID != fiPath.idFolder);
        Assert(FOLDERID_ROOT != fiPath.idParent);

        if (fAppendStrHC)
        {
            // Separate append str from path with HC
            Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
            hrResult = bstmPath.Write(&fiPath.bHierarchy, sizeof(fiPath.bHierarchy), NULL);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            fAppendStrHC = FALSE;
        }

        // Expand folder name to full path if this is a special folder
        if (FOLDER_NOTSPECIAL != fiPath.tySpecial)
        {
            char szSpecialFldrPath[MAX_PATH * 2 + 2]; // Room for HC and null-term

            fSpecialFldr = TRUE;
            hrResult = ImapUtil_SpecialFldrTypeToPath(szAccount, fiPath.tySpecial,
                szRootFldrPrefix, fiPath.bHierarchy, szSpecialFldrPath, sizeof(szSpecialFldrPath));
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }

            // Reverse special folder path so we can append it. It will be reversed back to normal
            // There should be no trailing HC's
            //Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
            dwLen = ImapUtil_ReverseSentence(szSpecialFldrPath, fiPath.bHierarchy);
            Assert(dwLen == 0 || fiPath.bHierarchy !=
                *(CharPrev(szSpecialFldrPath, szSpecialFldrPath + dwLen)));
            pszFolderName = szSpecialFldrPath;
        }
        else
            pszFolderName = fiPath.pszName;

        // Write folder name to stream
        hrResult = bstmPath.Write(pszFolderName, lstrlen(pszFolderName), NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        //Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
        hrResult = bstmPath.Write(&fiPath.bHierarchy, sizeof(fiPath.bHierarchy), NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        pFldrCache->FreeRecord(&fiPath);
        fFreeFldrInfo = FALSE;

        hrResult = pFldrCache->GetFolderInfo(fiPath.idParent, &fiPath);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
        fFreeFldrInfo = TRUE;

    } // while


    if (FALSE == fSpecialFldr && '\0' != szRootFldrPrefix[0])
    {
        if (fAppendStrHC)
        {
            // Separate append str from path with HC
            Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
            hrResult = bstmPath.Write(&fiPath.bHierarchy, sizeof(fiPath.bHierarchy), NULL);
            if (FAILED(hrResult))
            {
                TraceResult(hrResult);
                goto exit;
            }
            fAppendStrHC = FALSE;
        }

        // Reverse root folder path so we can append it. It will be reversed back to normal
        // There should be no trailing HC's (ImapUtil_LoadRootFldrPrefix guarantees this)
        Assert((BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
        dwLen = ImapUtil_ReverseSentence(szRootFldrPrefix, fiPath.bHierarchy);
        Assert(dwLen == 0 || fiPath.bHierarchy !=
            *(CharPrev(szRootFldrPrefix, szRootFldrPrefix + dwLen)));

        hrResult = bstmPath.Write(szRootFldrPrefix, dwLen, NULL);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }
    }

    // OK, path won't get any larger. Acquire mem buffer so we can reverse it
    hrResult = bstmPath.HrAcquireStringA(&dwLengthOfPath, ppszPath, ACQ_DISPLACE);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Blow away trailing hierarchy character or it becomes leading HC
    pszEnd = CharPrev(*ppszPath, *ppszPath + dwLengthOfPath);
    Assert('%' == *pszEnd || (BYTE)INVALID_HIERARCHY_CHAR != fiPath.bHierarchy);
    if (*pszEnd == (char) fiPath.bHierarchy)
        *pszEnd = '\0';

    // Reverse the 'sentence' (HC is delimiter) to get path
    dwLen = ImapUtil_ReverseSentence(*ppszPath, fiPath.bHierarchy);
    if (NULL != pdwPathLen)
        *pdwPathLen = dwLen;

exit:
    if (fFreeFldrInfo)
        pFldrCache->FreeRecord(&fiPath);

    return hrResult;
} // ImapUtil_FolderIDToPath



//***************************************************************************
// Function: ImapUtil_ReverseSentence
//
// Purpose:
//   This function reverses the words in the given sentence, where words are
// separated by the given delimiter. For instance, "one two three" with space
// as the delimiter is returned as "three two one".
//
// Arguments:
//   LPSTR pszSentence [in/out] - the sentence to be reversed. The sentence
//     is reversed in place.
//   char cDelimiter [in] - the character separating the words in the
//     sentence.
//
// Returns:
//   DWORD indicating length of reversed sentence.
//***************************************************************************
DWORD ImapUtil_ReverseSentence(LPSTR pszSentence, char cDelimiter)
{
    LPSTR pszStartWord, psz;
    Assert(NULL != pszSentence);
    BOOL fFoundDelimiter;
    BOOL fSkipByte = FALSE;

    TraceCall("ImapUtil_ReverseSentence");

    if ('\0' == cDelimiter)
        return 0; // Nothing to reverse

    // Check if first character is a delimiter
    if (cDelimiter != *pszSentence) {
        pszStartWord = pszSentence;
        psz = pszSentence;
        fFoundDelimiter = FALSE;
    }
    else {
        // Skip first delimiter char (it will be reversed at end of fn)
        pszStartWord = pszSentence + 1;
        psz = pszSentence + 1;
        fFoundDelimiter = TRUE;
    }

    // First, reverse each word in the sentence
    while (1) {
        char cCurrent = *psz;

        if (fSkipByte) {
            fSkipByte = FALSE;
            if ('\0' != cCurrent)
                psz += 1;
            continue;
        }

        if (cDelimiter == cCurrent || '\0' == cCurrent) {
            // We've gone past a word! Reverse it!
            ImapUtil_ReverseString(pszStartWord, psz - 1);
            pszStartWord = psz + 1; // Set us up for next word
            fFoundDelimiter = TRUE;
        }

        if ('\0' == cCurrent)
            break;
        else {
            if (IsDBCSLeadByteEx(GetACP(), cCurrent))
                fSkipByte = TRUE;
            psz += 1;
        }
    } // while (1)

    // Now reverse the entire sentence string (psz points to null-terminator)
    if (fFoundDelimiter && psz > pszSentence)
        ImapUtil_ReverseString(pszSentence, psz - 1);

    return (DWORD) (psz - pszSentence);
} // ImapUtil_ReverseSentence



//***************************************************************************
// Function: ImapUtil_ReverseString
//
// Purpose:
//   This function reverses the given string in-place
//
// Arguments:
//   LPSTR pszStart [in/out] - start of the string to be reversed.
//   LPSTR pszEnd [in/out] - the end of the string to be reversed.
//***************************************************************************
void ImapUtil_ReverseString(LPSTR pszStart, LPSTR pszEnd)
{
    TraceCall("ImapUtil_ReverseString");
    Assert(NULL != pszStart);
    Assert(NULL != pszEnd);

    while (pszStart < pszEnd) {
        char cTemp;

        // Swap characters
        cTemp = *pszStart;
        *pszStart = *pszEnd;
        *pszEnd = cTemp;

        // Advance pointers
        pszStart += 1;
        pszEnd -= 1;
    } // while
} // ImapUtil_ReverseString



//***************************************************************************
// Function: ImapUtil_SpecialFldrTypeToPath
//
// Purpose:
//   This function returns the path for the given special folder type.
//
// Arguments:
//   LPSTR pszAccountID [in] - ID of IMAP account where special folder resides.
//   SPECIALFOLDER sfType [in] - the special folder whose path should be returned
//     (eg, FOLDER_SENT).
//   LPCSTR pszRootFldrPrefix [in] - the root folder prefix for this IMAP
//     account. If this is NULL, this function will find out for itself.
//   LPSTR pszPath [out] - pointer to a buffer to receieve the special folder
//     path.
//   DWORD dwSizeOfPath [in] - size of buffer pointed to by pszPath.
//
// Returns:
//   HRESULT indicating success or failure. This can include:
//
//     STORE_E_NOREMOTESPECIALFLDR: indicates the given special folder has
//       been disabled by the user for this IMAP server.
//***************************************************************************
HRESULT ImapUtil_SpecialFldrTypeToPath(LPCSTR pszAccountID, SPECIALFOLDER sfType,
                                       LPSTR pszRootFldrPrefix, char cHierarchyChar,
                                       LPSTR pszPath, DWORD dwSizeOfPath)
{
    HRESULT         hrResult = E_FAIL;
    IImnAccount    *pAcct = NULL;
    DWORD           dw;
    int             iLen;

    TraceCall("ImapUtil_SpecialFldrTypeToPath");
    AssertSz(dwSizeOfPath >= MAX_PATH * 2 + 2, "RFP + Special Folder Path = Big Buffer, Dude"); // Room for HC, null-term

    *pszPath = '\0'; // Initialize
    switch (sfType)
    {
        case FOLDER_INBOX:
            StrCpyN(pszPath, c_szINBOX, dwSizeOfPath);
            hrResult = S_OK;
            break;


        case FOLDER_SENT:
        case FOLDER_DRAFT:
            Assert(g_pAcctMan);
            if (g_pAcctMan)
            {
                hrResult = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAcct);
            }
            if (FAILED(hrResult))
                break;

            hrResult = pAcct->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dw);
            if (FAILED(hrResult))
                break;
            else if (FALSE == dw) {
                hrResult = STORE_E_NOREMOTESPECIALFLDR;
                break;
            }

            // First prepend the root folder prefix
            // Check if user gave us a root folder prefix: otherwise we need to load it ourselves
            if (NULL == pszRootFldrPrefix)
                ImapUtil_LoadRootFldrPrefix(pszAccountID, pszPath, dwSizeOfPath);
            else
                StrCpyN(pszPath, pszRootFldrPrefix, dwSizeOfPath);

            iLen = lstrlen(pszPath);
            if (iLen > 0 && (DWORD)iLen + 1 < dwSizeOfPath)
            {
                pszPath[iLen] = cHierarchyChar;
                iLen += 1;
                pszPath[iLen] = '\0';
            }

            hrResult = pAcct->GetPropSz(FOLDER_SENT == sfType ?
                AP_IMAP_SENTITEMSFLDR : AP_IMAP_DRAFTSFLDR, pszPath + iLen,
                dwSizeOfPath - iLen);
            break;

        case FOLDER_DELETED:
        case FOLDER_ERRORS:
        case FOLDER_JUNK:
        case FOLDER_MSNPROMO:
        case FOLDER_OUTBOX:
        case FOLDER_BULKMAIL:
            hrResult = STORE_E_NOREMOTESPECIALFLDR;
            break;

        default:
            AssertSz(FALSE, "Invalid special folder type!");
            hrResult = E_INVALIDARG;
            break;
    } // switch (sfType)


    if (NULL != pAcct)
        pAcct->Release();

    // Check for blank path
    if (SUCCEEDED(hrResult) && '\0' == *pszPath)
        hrResult = STORE_E_NOREMOTESPECIALFLDR;
 
    return hrResult;
} // ImapUtil_SpecialFldrTypeToPath



//***************************************************************************
// Function: ImapUtil_LoadRootFldrPrefix
//
// Purpose:
//   This function loads the "Root Folder Path" option from the account
// manager. The Root Folder Path (prefix) identifies the parent of all of
// the user's folders. Thus, the Root Folder Path forms a prefix for all
// mailboxes which are not INBOX.
//
// Arguments:
//   LPCTSTR pszAccountID [in] - ID of the account
//   LPSTR pszRootFolderPrefix [out] - destination for Root Folder Path
//   DWORD dwSizeofPrefixBuffer [in] - size of buffer pointed to by
//     pszRootFolderPrefix.
//***************************************************************************
void ImapUtil_LoadRootFldrPrefix(LPCTSTR pszAccountID,
                                 LPSTR pszRootFolderPrefix,
                                 DWORD dwSizeofPrefixBuffer)
{
    IImnAccount *pAcct = NULL;
    HRESULT hrResult = E_UNEXPECTED;
    LPSTR pLastChar;

    Assert(g_pAcctMan);
    Assert(NULL != pszAccountID);
    Assert(NULL != pszRootFolderPrefix);
    Assert(0 != dwSizeofPrefixBuffer);
    if (!g_pAcctMan)
        return;

    // Initialize variables
    pAcct = NULL;
    pszRootFolderPrefix[0] = '\0'; // If we can't find a prefix, default to NONE

    // Get the prefix from the account manager
    hrResult = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAcct);
    if (FAILED(hrResult))
        goto exit;

    hrResult = pAcct->GetPropSz(AP_IMAP_ROOT_FOLDER, pszRootFolderPrefix,
        dwSizeofPrefixBuffer);
    if (FAILED(hrResult))
        goto exit;


    // OK, we now have the root folder prefix. Strip trailing hierarchy chars,
    // since we probably don't know server HC when we try to list the prefix
    pLastChar = CharPrev(pszRootFolderPrefix, pszRootFolderPrefix + lstrlen(pszRootFolderPrefix));
    while (pLastChar >= pszRootFolderPrefix &&
          ('/' == *pLastChar || '\\' == *pLastChar || '.' == *pLastChar)) {
        *pLastChar = '\0'; // Bye-bye, potential hierarchy char
        pLastChar = CharPrev(pszRootFolderPrefix, pLastChar);
    } // while

exit:
    if (NULL != pAcct)
        pAcct->Release();
} // ImapUtil_LoadRootFldrPrefix



//***************************************************************************
// Function: ImapUtil_GetSpecialFolderType
//
// Purpose:
//   This function takes the given account name and folder path, and
// determines whether the path points to a special IMAP folder. Note that
// although it is possible for a path to represent more than one type of
// IMAP special folder, only ONE special folder type is returned (based
// on evaluation order).
//
// Arguments:
//   LPSTR pszAccountID [in] - ID of the IMAP account whose special folder
//     paths we want to compare pszFullPath to.
//   LPSTR pszFullPath [in] - path to a potential special folder residing on
//     the pszAccountID account.
//   char cHierarchyChar [in] - hierarchy char used to interpret pszFullPath.
//   LPSTR pszRootFldrPrefix [in] - the root folder prefix for this IMAP
//     account. If this is NULL, this function will find out for itself.
//   SPECIALFOLDER *psfType [out] - the special folder type of given folder
//     (eg, FOLDER_NOTSPECIAL, FOLDER_SENT). Pass NULL if not interested.
//
// Returns:
//   LPSTR pointing to leaf name of special folder path. For instance, if
// the Drafts folder is set to "one/two/three/Drafts" and this function is
// called to process "one/two/three/Drafts/foo", then this function will
// return "Drafts/foo". If no match is found, NULL is returned.
//***************************************************************************
LPSTR ImapUtil_GetSpecialFolderType(LPSTR pszAccountID, LPSTR pszFullPath,
                                    char cHierarchyChar, LPSTR pszRootFldrPrefix,
                                    SPECIALFOLDER *psfType)
{
    HRESULT         hrResult;
    SPECIALFOLDER   sfType = FOLDER_NOTSPECIAL;
    BOOL            fSpecialFldrPrefix = FALSE;
    IImnAccount    *pAccount = NULL;
    DWORD           dw;
    int             iLeafNameOffset = 0;
    int             iTmp;
    int             iLen;
    char            sz[MAX_PATH * 2 + 2]; // Room for HC plus null-term

    Assert(INVALID_HIERARCHY_CHAR != cHierarchyChar);
    Assert(g_pAcctMan);
    if (!g_pAcctMan)
        goto exit;

    // First check if this is INBOX or one of its children
    iLen = lstrlen(c_szInbox);
    if (0 == StrCmpNI(pszFullPath, c_szInbox, iLen) &&
        (cHierarchyChar == pszFullPath[iLen] || '\0' == pszFullPath[iLen]))
    {
        fSpecialFldrPrefix = TRUE;
        iLeafNameOffset = 0; // "INBOX" is always the leaf name
        if ('\0' == pszFullPath[iLen])
        {
            sfType = FOLDER_INBOX; // Exact match for "INBOX"
            goto exit;
        }
    }

    hrResult = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAccount);
    if (FAILED(hrResult))
        goto exit;

#ifdef DEBUG
    hrResult = pAccount->GetServerTypes(&dw);
    Assert(SUCCEEDED(hrResult) && (SRV_IMAP & dw));
#endif // DEBUG

    hrResult = pAccount->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dw);
    if (SUCCEEDED(hrResult) && dw)
    {
        int iLenRFP;

        // Check if user gave us a root folder prefix: otherwise we need to load it ourselves
        if (NULL == pszRootFldrPrefix)
            ImapUtil_LoadRootFldrPrefix(pszAccountID, sz, sizeof(sz));
        else
            StrCpyN(sz, pszRootFldrPrefix, ARRAYSIZE(sz));

        iLenRFP = lstrlen(sz);
        if (iLenRFP > 0 && (DWORD)iLenRFP + 1 < sizeof(sz))
        {
            sz[iLenRFP] = cHierarchyChar;
            iLenRFP += 1;
            sz[iLenRFP] = '\0';
        }

        hrResult = pAccount->GetPropSz(AP_IMAP_SENTITEMSFLDR, sz + iLenRFP, sizeof(sz) - iLenRFP);
        if (SUCCEEDED(hrResult))
        {
            iLen = lstrlen(sz);
            if (0 == StrCmpNI(sz, pszFullPath, iLen) &&
                (cHierarchyChar == pszFullPath[iLen] || '\0' == pszFullPath[iLen]))
            {
                fSpecialFldrPrefix = TRUE;
                iTmp = (int) (ImapUtil_ExtractLeafName(sz, cHierarchyChar) - sz);
                iLeafNameOffset = max(iTmp, iLeafNameOffset);
                if ('\0' == pszFullPath[iLen])
                {
                    sfType = FOLDER_SENT; // Exact match for Sent Items
                    goto exit;
                }
            }
        }

        hrResult = pAccount->GetPropSz(AP_IMAP_DRAFTSFLDR, sz + iLenRFP, sizeof(sz) - iLenRFP);
        if (SUCCEEDED(hrResult))
        {
            iLen = lstrlen(sz);
            if (0 == StrCmpNI(sz, pszFullPath, iLen) && 
                (cHierarchyChar == pszFullPath[iLen] || '\0' == pszFullPath[iLen]))
            {
                fSpecialFldrPrefix = TRUE;
                iTmp = (int) (ImapUtil_ExtractLeafName(sz, cHierarchyChar) - sz);
                iLeafNameOffset = max(iTmp, iLeafNameOffset);
                if ('\0' == pszFullPath[iLen])
                {
                    sfType = FOLDER_DRAFT; // Exact match for Drafts folder
                    goto exit;
                }
            }
        }
    } // if (AP_IMAP_SVRSPECIALFLDRS)

exit:
    if (NULL != pAccount)
        pAccount->Release();

    if (NULL != psfType)
        *psfType = sfType;

    if (fSpecialFldrPrefix)
        return pszFullPath + iLeafNameOffset;
    else
        return NULL;
} // ImapUtil_GetSpecialFolderType



//***************************************************************************
// Function: ImapUtil_ExtractLeafName
//
// Purpose:
//   This function takes an IMAP folder path and extracts the leaf node name.
//
// Arguments:
//   LPSTR pszFolderPath [in] - a string containing the IMAP folder path.
//   char cHierarchyChar [in] - the hierarchy char used in pszFolderPath.
//
// Returns:
//   A pointer to the leaf node name in pszFolderPath. The default return
// value is pszFolderPath, if no hierarchy characters were found.
//***************************************************************************
LPSTR ImapUtil_ExtractLeafName(LPSTR pszFolderPath, char cHierarchyChar)
{
    LPSTR pszLastHierarchyChar, p;

    // Find out where the last hierarchy character lives
    pszLastHierarchyChar = pszFolderPath;
    p = pszFolderPath;
    while ('\0' != *p) {
        if (cHierarchyChar == *p)
            pszLastHierarchyChar = p;

        p += 1;
    }

    // Adjust pszLastHierarchyChar to point to leaf name
    if (cHierarchyChar == *pszLastHierarchyChar)
        return pszLastHierarchyChar + 1;
    else
        return pszFolderPath;
} // ImapUtil_ExtractLeafName



HRESULT ImapUtil_UIDToMsgSeqNum(IIMAPTransport *pIMAPTransport, DWORD_PTR dwUID,
                                LPDWORD pdwMsgSeqNum)
{
    HRESULT hrTemp;
    DWORD  *pdwMsgSeqNumToUIDArray = NULL;
    DWORD   dwHighestMsgSeqNum;
    DWORD   dw;
    BOOL    fFound = FALSE;

    TraceCall("ImapUtil_UIDToMsgSeqNum");

    if (NULL == pIMAPTransport || 0 == dwUID)
    {
        TraceResult(E_INVALIDARG);
        goto exit;
    }

    // Quickly check the highest MSN
    hrTemp = pIMAPTransport->GetHighestMsgSeqNum(&dwHighestMsgSeqNum);
    if (FAILED(hrTemp) || 0 == dwHighestMsgSeqNum)
    {
        TraceError(hrTemp);
        goto exit;
    }

    // OK, no more laziness, we gotta do a linear search now
    hrTemp = pIMAPTransport->GetMsgSeqNumToUIDArray(&pdwMsgSeqNumToUIDArray,
        &dwHighestMsgSeqNum);
    if (FAILED(hrTemp))
    {
        TraceResult(hrTemp);
        goto exit;
    }

    Assert(dwHighestMsgSeqNum > 0);
    for (dw = 0; dw < dwHighestMsgSeqNum; dw++)
    {
        // Look for match or overrun
        if (0 != pdwMsgSeqNumToUIDArray[dw] && dwUID <= pdwMsgSeqNumToUIDArray[dw])
        {
            if (dwUID == pdwMsgSeqNumToUIDArray[dw])
            {
                if (NULL != pdwMsgSeqNum)
                    *pdwMsgSeqNum = dw + 1;

                fFound = TRUE;
            }
            break;
        }
    } // for


exit:
    SafeMemFree(pdwMsgSeqNumToUIDArray);

    if (fFound)
        return S_OK;
    else
        return E_FAIL;
} // ImapUtil_UIDToMsgSeqNum



// *** REMOVE THIS after Beta-2! This sets the AP_IMAP_DIRTY flag if no IMAP special folders
// found after OE4->OE5 migration. We can then prompt user to refresh folder list.
void ImapUtil_B2SetDirtyFlag(void)
{
    IImnAccountManager *pAcctMan = NULL;
    IImnEnumAccounts   *pAcctEnum = NULL;
    IImnAccount        *pAcct = NULL;
    HRESULT             hrResult;

    TraceCall("ImapUtil_B2SetDirtyFlag");

    // Enumerate through all accounts. Set AP_IMAP_DIRTY flag on all IMAP accounts
    hrResult = HrCreateAccountManager(&pAcctMan);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pAcctMan->Init(NULL);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pAcctMan->Enumerate(SRV_IMAP, &pAcctEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = pAcctEnum->GetNext(&pAcct);
    while (SUCCEEDED(hrResult))
    {
        DWORD   dwIMAPDirty;

        hrResult = pAcct->GetPropDw(AP_IMAP_DIRTY, &dwIMAPDirty);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            dwIMAPDirty = 0;
        }

        // Mark this IMAP account as dirty so we prompt user to refresh folder list
        dwIMAPDirty |= (IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY);
        hrResult = pAcct->SetPropDw(AP_IMAP_DIRTY, dwIMAPDirty);
        TraceError(hrResult); // Record but otherwise ignore result

        hrResult = pAcct->SaveChanges();
        TraceError(hrResult); // Record but otherwise ignore result

        // Get next account
        SafeRelease(pAcct);
        hrResult = pAcctEnum->GetNext(&pAcct);
    }

exit:
    SafeRelease(pAcctMan);
    SafeRelease(pAcctEnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\imaildlg.h ===
#define idcMailProgress         1000
#define idcProgAni              1001
#define idsInetMailMsg1         1002
#define idsInetMailMsg2         1003
#define idlvDetails             1004
#define idbInetMailDetails      1005
#define idcIMProgSplitter       1006
#define idsInetMailError        1007
#define ideInetMailDetails      1009
#define IDS_STATIC              -1
#define idlvUnsetMsgs           1010
#define idsSentStatus           1011
#define idbInetProgHide         1012
#define idbInetProgStop         1013
#define idicoIdle               1014
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\imnglobl.h ===
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __IMNGLOBL_H
#define __IMNGLOBL_H

////////////////////////////////////////////////////////////////////////////
//
//  F O R W A R D S
//

#ifdef __cplusplus
class CFontCache;
#endif

interface ISpoolerEngine;
interface IImnAccountManager;
class CSubManager;
interface IMimeAllocator;
class CConnectionManager;

////////////////////////////////////////////////////////////////////////////
//
//  E N U M S , D E F I N E S and such
//

/* Identifiers for the section selected for search criteria Combo Box.  The
   number of different selections is defined by NumInOfTypeCB which is the 
   number of items in the combo box labelled "Of Type:".  The apparently random
   location of this enum is due to merging the tabs code with findwnd.cpp.  Note
   that this enum is critical; the ordering here is used throughout the 
   properties set up - see findwnd.cpp. */
typedef enum {Contact = 0, Message, Task, Appointment, NumInOfTypeCB} OFTYPE;


////////////////////////////////////////////////////////////////////////////
//
//  M A C R O S
//

//#define DllAddRef()     _DllAddRef(__FILE__, __LINE__);
//#define DllRelease()    _DllRelease(__FILE__, __LINE__);

////////////////////////////////////////////////////////////////////////////
//
//  I N L I N E S
//

////////////////////////////////////////////////////////////////////////////
//
//  P R O T O T Y P E S
//

//int _DllAddRef(LPTSTR szFile, int nLine);
//int _DllRelease(LPTSTR szFile, int nLine);

// AddRef and Release for SDI windows. They use DllAddRef depeding on
// platform as explorer causes ExitProcess in some instances
//ULONG SDIAddRef();
//ULONG SDIRelease();

////////////////////////////////////////////////////////////////////////////
//
//  E X T E R N S
//

#ifndef WIN16
extern HINSTANCE            g_hRichEditDll;     // athena.cpp
#endif
extern BOOL                 g_fRunDll;
extern HWND                 g_hwndInit;
extern HWND                 g_hwndDlgFocus;
extern UINT                 g_msgMSWheel;
extern HINSTANCE            g_hSicilyDll;
extern HINSTANCE            g_hInst;
extern HINSTANCE            g_hLocRes;
extern IMimeAllocator      *g_pMoleAlloc;
extern IImnAccountManager2 *g_pAcctMan;
// bobn: brianv says we have to take this out...
//extern DWORD                g_dwBrowserFlags;
extern DWORD                g_dwNoteThreadID,
                            g_dwBrowserThreadID;
extern DWORD                g_dwAthenaMode;

////////////////////////////////////////////////////////////////////////////
//
//  Flags for g_dwAthenaMode
//


#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\mpropdlg.h ===
#pragma once

#define idchkSaveCopy                   134
#define idcTagHeaders                   135
#define idcTxtHeaders                   136
#define idbMsgSource                    137
#define idcTxtSource                    143
#define idcTxtRecip                     151
#define idcTxtPriority                  155
#define idcTxtAttachFmt                 156
#define idcAddSignature                 157
#define idcSendCert                     158
#define idcChooseCert                   159
#define idcEncryptContents              160
#define idcChooseAlg                    161
#define idcVerifySig                    162
#define idcAddCert                      163
#define idcStaticDigSign                164
#define idcStaticAlter                  165
#define idcStaticTrust                  166
#define idcStaticCertInc                167
#define idcStaticEncrypt                168
#define idcStaticEncAlg                 169
#define idbSecMsgSource                 170
#define IDC_FOLDER_IMAGE                171
#define IDC_MSGSUBJECT                  172
#define IDC_MSGFROM                     173
#define IDC_TYPE_STATIC                 174
#define IDC_MSGSIZE                     175
#define IDC_MSGSIZE_STATIC              176
#define IDC_ATTACHMENTS_STATIC          177
#define IDC_TYPE                        178
#define IDC_MSGFOLDER                   179
#define IDC_ATTACHMENTS                 181
#define IDC_PRIORITY_STATIC             182
#define IDC_PRIORITY                    183
#define IDC_SENT_STATIC                 184
#define IDC_SENT                        185
#define IDC_RECEIVED_STATIC             186
#define IDC_RECEIVED                    187
#define idcStaticRevoked                188
#define idcStaticRevStatus              189
#define idcSecRecLabel                  190
#define idcRetRecReq                    191
#define idcSecLabelStat                 192
#define idcSecLabelText                 193
#define idcViewEncCert                  194
#define idcStaticRecAlg                 195
#define idcStaticEncCertInc             196
#define idcStaticSecReceipt             197
#define idcViewCerts                    198
#define idcAdvanced                     199
#define idcCertHelp                     200
#define idcStaticEncryptionCert         201
#define idcStaticSigningCert            202
#define idcStaticSendersCert            203
#define idcStaticEncryptAlgorithm       204
#define idcViewEncrytionCert            205
#define idcSendersEncryptionCert        206
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\msoedisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

#pragma once

// hack - from OLE headers
#define DISPID_VALUE                                ( 0 )
#define DISPID_NEWENUM                              ( -4 )

// hack - from OLE headers

#define DISPID_IOESESSION_BASE                      100
#define DISPID_IOEFOLDERCOLLECTION_BASE             200
#define DISPID_IOEFOLDER_BASE                       300
#define DISPID_IOEMESSAGECOLLECTION_BASE            400
#define DISPID_IOEMESSAGE_BASE                      500
#define DISPID_LISTPROP_BASE                        600
#define DISPID_LIST_BASE                            700
#define DISPID_LISTEVENT_BASE                       800
#define DISPID_IOEMSGLIST_BASE                      900
#define DISPID_IOEACCTWIZ_BASE                      1000

//
// DISPID_IOESESSION_*
//
#define DISPID_IOESESSION_FOLDERS                   (DISPID_IOESESSION_BASE + 1)
#define DISPID_IOESESSION_VERSION                   (DISPID_IOESESSION_BASE + 2)
#define DISPID_IOESESSION_CREATEMESSAGE             (DISPID_IOESESSION_BASE + 3)
#define DISPID_IOESESSION_OPENFOLDER                (DISPID_IOESESSION_BASE + 4)
#define DISPID_IOESESSION_OPENMESSAGE               (DISPID_IOESESSION_BASE + 5)
#define DISPID_IOESESSION_INBOX                     (DISPID_IOESESSION_BASE + 6)
//
// DISPID_IOEMSGLIST_*
//
#define DISPID_IOEMSGLIST_SORTCOL                   (DISPID_IOEMSGLIST_BASE + 1)
#define DISPID_IOEMSGLIST_SORTDIR                   (DISPID_IOEMSGLIST_BASE + 2)
#define DISPID_IOEMSGLIST_TEST                      (DISPID_IOEMSGLIST_BASE + 3)

//
// DISPID_IOEFOLDERCOLLECTION_*
//
#define DISPID_IOEFOLDERCOLLECTION_TOSTRING         DISPID_IOEFOLDERCOLLECTION_BASE+1
#define DISPID_IOEFOLDERCOLLECTION_LENGTH           DISPID_IOEFOLDERCOLLECTION_BASE
#define DISPID_IOEFOLDERCOLLECTION__NEWENUM         DISPID_NEWENUM
#define DISPID_IOEFOLDERCOLLECTION_ITEM             DISPID_VALUE
#define DISPID_IOEFOLDERCOLLECTION_TAGS             DISPID_IOEFOLDERCOLLECTION_BASE+2
#define DISPID_IOEFOLDERCOLLECTION_ADD              DISPID_IOEFOLDERCOLLECTION_BASE+3
#define DISPID_IOEFOLDERCOLLECTION_FOLDERS          DISPID_IOEFOLDERCOLLECTION_BASE+4

//
// DISPID_IOEFOLDER_*
//
#define DISPID_IOEFOLDER_NAME                       (DISPID_IOEFOLDER_BASE + 1)
#define DISPID_IOEFOLDER_PARENT                     (DISPID_IOEFOLDER_BASE + 2)
#define DISPID_IOEFOLDER_SIZE                       (DISPID_IOEFOLDER_BASE + 3)
#define DISPID_IOEFOLDER_ID                         (DISPID_IOEFOLDER_BASE + 4)
#define DISPID_IOEFOLDER_UNREAD                     (DISPID_IOEFOLDER_BASE + 5)
#define DISPID_IOEFOLDER_MESSAGES                   (DISPID_IOEFOLDER_BASE + 6)
#define DISPID_IOEFOLDER_FOLDERS                    (DISPID_IOEFOLDER_BASE + 7)
#define DISPID_IOEFOLDER_COUNT                      (DISPID_IOEFOLDER_BASE + 8)

//
// DISPID_IOEMESSAGECOLLECTION_*
//

#define DISPID_IOEMESSAGECOLLECTION_TOSTRING        (DISPID_IOEMESSAGECOLLECTION_BASE + 1)
#define DISPID_IOEMESSAGECOLLECTION_LENGTH          (DISPID_IOEMESSAGECOLLECTION_BASE + 2)
#define DISPID_IOEMESSAGECOLLECTION__NEWENUM        DISPID_NEWENUM
#define DISPID_IOEMESSAGECOLLECTION_ITEM            DISPID_VALUE
#define DISPID_IOEMESSAGECOLLECTION_TAGS            (DISPID_IOEMESSAGECOLLECTION_BASE + 5)



#define DISPID_IOEMESSAGE_SEND                  (DISPID_IOEMESSAGE_BASE + 1)
#define DISPID_IOEMESSAGE_TO                    (DISPID_IOEMESSAGE_BASE + 2)
#define DISPID_IOEMESSAGE_CC                    (DISPID_IOEMESSAGE_BASE + 3)
#define DISPID_IOEMESSAGE_SENDER                (DISPID_IOEMESSAGE_BASE + 4)
#define DISPID_IOEMESSAGE_SUBJECT               (DISPID_IOEMESSAGE_BASE + 5)
#define DISPID_IOEMESSAGE_TEXT                  (DISPID_IOEMESSAGE_BASE + 6)
#define DISPID_IOEMESSAGE_HTML                  (DISPID_IOEMESSAGE_BASE + 7)
#define DISPID_IOEMESSAGE_URL                   (DISPID_IOEMESSAGE_BASE + 8)
#define DISPID_IOEMESSAGE_DATE                  (DISPID_IOEMESSAGE_BASE + 9)

#define DISPID_IOEACCTWIZ_SET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 1)
#define DISPID_IOEACCTWIZ_GET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 2)
#define DISPID_IOEACCTWIZ_CLEAR_PROPS           (DISPID_IOEACCTWIZ_BASE + 3)
#define DISPID_IOEACCTWIZ_CLOSE                 (DISPID_IOEACCTWIZ_BASE + 4)
#define DISPID_IOEACCTWIZ_NEW_HOTMAIL_ACCOUNT   (DISPID_IOEACCTWIZ_BASE + 5)
#define DISPID_IOEACCTWIZ_WIDTH                 (DISPID_IOEACCTWIZ_BASE + 6)
#define DISPID_IOEACCTWIZ_HEIGHT                (DISPID_IOEACCTWIZ_BASE + 7)
#define DISPID_IOEACCTWIZ_SET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 8)
#define DISPID_IOEACCTWIZ_GET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 9)
#define DISPID_IOEACCTWIZ_NEW_ACCOUNT           (DISPID_IOEACCTWIZ_BASE + 10)
#define DISPID_IOEACCTWIZ_RELOAD                (DISPID_IOEACCTWIZ_BASE + 11)

/////////////////////////////////////////////////////////////////////////////
// IOEMessageList
//

// Properties
#define DISPID_LISTPROP_GROUP_MESSAGES          (DISPID_LISTPROP_BASE + 1)
#define DISPID_LISTPROP_EXPAND_GROUPS           (DISPID_LISTPROP_BASE + 2)
#define DISPID_LISTPROP_SELECT_FIRST_UNREAD     (DISPID_LISTPROP_BASE + 3)
#define DISPID_LISTPROP_COLUMN_SET              (DISPID_LISTPROP_BASE + 4)
#define DISPID_LISTPROP_COUNT                   (DISPID_LISTPROP_BASE + 5)
#define DISPID_LISTPROP_SELECTED_COUNT          (DISPID_LISTPROP_BASE + 6)
#define DISPID_LISTPROP_PREVIEW_SRC             (DISPID_LISTPROP_BASE + 7)
#define DISPID_LISTPROP_FOLDER                  (DISPID_LISTPROP_BASE + 8)
#define DISPID_LISTPROP_MESSAGE_TIPS            (DISPID_LISTPROP_BASE + 9)
#define DISPID_LISTPROP_SCROLL_TIPS             (DISPID_LISTPROP_BASE + 10)
#define DISPID_LISTPROP_UNREAD_COUNT            (DISPID_LISTPROP_BASE + 11)
#define DISPID_LISTPROP_FILTER_MESSAGES         (DISPID_LISTPROP_BASE + 12)
#define DISPID_LISTPROP_SHOW_DELETED            (DISPID_LISTPROP_BASE + 13)
#define DISPID_LISTPROP_SHOW_REPLIES            (DISPID_LISTPROP_BASE + 14)

// Methods
#define DISPID_LIST_SETFOLDER                   (DISPID_LIST_BASE + 1)
#define DISPID_LIST_GET_SELECTED_MESSAGE        (DISPID_LIST_BASE + 2)
#define DISPID_LIST_SET_RECT                    (DISPID_LIST_BASE + 3)
#define DISPID_LIST_GET_RECT                    (DISPID_LIST_BASE + 4)
#define DISPID_LIST_MARK_READ                   (DISPID_LIST_BASE + 5)
#define DISPID_LIST_GET_COLUMN_INFO             (DISPID_LIST_BASE + 6)
#define DISPID_LIST_ON_POPUP_MENU               (DISPID_LIST_BASE + 7)
#define DISPID_LIST_CREATE_LIST                 (DISPID_LIST_BASE + 8)
#define DISPID_LIST_SAVE_STATE                  (DISPID_LIST_BASE + 9)

/////////////////////////////////////////////////////////////////////////////
// _MessageListEvents Dispatch IDs
//

#define DISPID_LISTEVENT_SELECTIONCHANGED       (DISPID_LISTEVENT_BASE + 1)
#define DISPID_LISTEVENT_FOCUSCHANGED           (DISPID_LISTEVENT_BASE + 2)
#define DISPID_LISTEVENT_COUNTCHANGED           (DISPID_LISTEVENT_BASE + 3)
#define DISPID_LISTEVENT_UPDATESTATUS           (DISPID_LISTEVENT_BASE + 4)
#define DISPID_LISTEVENT_UPDATEPROGRESS         (DISPID_LISTEVENT_BASE + 5)
#define DISPID_LISTEVENT_ERROR                  (DISPID_LISTEVENT_BASE + 6)
#define DISPID_LISTEVENT_ITEMACTIVATE           (DISPID_LISTEVENT_BASE + 7)
#define DISPID_LISTEVENT_UPDATECOMMANDSTATE     (DISPID_LISTEVENT_BASE + 8)
#define DISPID_LISTEVENT_ONMESSAGEAVAILABLE     (DISPID_LISTEVENT_BASE + 9)
#define DISPID_LISTEVENT_FILTERCHANGED          (DISPID_LISTEVENT_BASE + 10)
#define DISPID_LISTEVENT_ADURL_AVAILABLE        (DISPID_LISTEVENT_BASE + 11)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\htmlstr.h ===
/*
 * htmlstr.h
 *
 * HTML string constants
 *
 */

#ifndef _HTMLSTR_H
#define _HTMLSTR_H

#if !defined( WIN16 ) || !defined( __WATCOMC__ )

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" CDECL const WORD DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, L##strdata}; \
    extern "C" CDECL BSTR name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y

#else
#define MAKEBSTR(name, count, strdata) extern "C" CDECL LPCWSTR name

#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#else // !WIN16 || !__WATCOMC__

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" const char CDECL DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, strdata}; \
    extern "C" BSTR  CDECL name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y

#else
#define MAKEBSTR(name, count, strdata) extern "C" LPCWSTR CDECL name

#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#endif

#endif // !WIN16 || !__WATCOMC__

STR_GLOBAL(c_szHtml_MetaTagf, "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;charset=%s\">\r\n");

MAKEBSTR(c_bstr_Word,       4,  "Word");
MAKEBSTR(c_bstr_Character,  9,  "Character");
MAKEBSTR(c_bstr_StartToEnd, 10, "StartToEnd");
MAKEBSTR(c_bstr_EndToEnd,   8,  "EndToEnd");
MAKEBSTR(c_bstr_StartToStart,   12,  "StartToStart");
MAKEBSTR(c_bstr_EndToStart, 10, "EndToStart");

MAKEBSTR(c_bstr_OnNewMail,        9, "onNewMail");
MAKEBSTR(c_bstr_OnAccountChange, 15, "onAccountChange");

#endif //_HTMLSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\optdlg.h ===
/*
 *	o p t d l g . h
 *	
 *	Purpose: Contains defines and prototypes shared by mail and news
 *           on the options prop sheet.
 */

#ifndef __OPTDLG_H
#define __OPTDLG_H

#define idbtnPlain                  1043
#define idbtnHTML                   1044
#define idrbPlain                   1045
#define idrbHTML                    1046

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\listtemp.h ===
// ===========================================================================================
// CList Template Definition
// ===========================================================================================
#ifndef __LISTTEMP_H
#define __LISTTEMP_H

// ===========================================================================================
// Required Inlcudes
// ===========================================================================================
#include "xpcomm.h"

// ===========================================================================================
// abstract iteration listpos
// ===========================================================================================
struct __LISTPOS { int unused; };
typedef __LISTPOS* LISTPOS;

// ===========================================================================================
// CList Class Template 
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
class CList
{
private:
    ULONG       m_ulRef;

protected:
    // ===========================================================================================
    // Double-linked list NODE
    // ===========================================================================================
    struct CNode
    {
	    CNode    *pNext;
	    CNode    *pPrev;
	    ARG_TYPE  data;
    };

public:
    // ===========================================================================================
    // Create, delete
    // ===========================================================================================
    CList ();
    ~CList ();

    // ===========================================================================================
    // Reference Counts
    // ===========================================================================================
    ULONG AddRef ();
    ULONG Release ();

    // ===========================================================================================
    // Counts
    // ===========================================================================================
    INT GetCount () const;
    BOOL IsEmpty () const;

    // ===========================================================================================
    // Peek at head or tail
    // ===========================================================================================
	ARG_TYPE GetHead ();
	ARG_TYPE GetTail ();

    // ===========================================================================================
    // Adding To
    // ===========================================================================================
	ARG_TYPE AddHead ();
	ARG_TYPE AddTail ();
	void AddHead (ARG_TYPE newData);
	void AddTail (ARG_TYPE newData);

    // ===========================================================================================
    // Deletion
    // ===========================================================================================
	void RemoveHead();
	void RemoveTail();
    void Remove (ARG_TYPE oldData);

    // ===========================================================================================
    // Iteration
    // ===========================================================================================
	LISTPOS GetHeadPosition() const;
	LISTPOS GetTailPosition() const;
   	ARG_TYPE GetNext(LISTPOS& Position);
   	void MoveNext(LISTPOS& Position);
	ARG_TYPE GetPrev(LISTPOS& Position);

    // ===========================================================================================
    // Getting and modifying data
    // ===========================================================================================
	ARG_TYPE GetAt(LISTPOS listpos);
	void SetAt(LISTPOS pos, ARG_TYPE newElement);

    // ===========================================================================================
    // Alloc and free
    // ===========================================================================================
    void RemoveAll ();
    void FreeNode (CNode *pNode);
    CNode *NewNode (CNode* pPrev, CNode* pNext, ARG_TYPE data);

protected:
    INT             m_nCount;
    CNode          *m_pHead;
    CNode          *m_pTail;
};

// ===========================================================================================
// CList::CList
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline CList<TYPE, ARG_TYPE>::CList()
{
    m_ulRef = 0;
	m_nCount = 0;
	m_pHead = m_pTail = NULL;
    AddRef ();
}

// ===========================================================================================
// CList::~CList
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline CList<TYPE, ARG_TYPE>::~CList()
{
    RemoveAll ();
    Assert (m_nCount == 0);
    DOUT ("CList::destructor - Ref Count=%d", m_ulRef);
	Assert (m_ulRef == 0);
}

// ===========================================================================================
// CList::AddRef
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ULONG CList<TYPE, ARG_TYPE>::AddRef()
{
	++m_ulRef; 								  
    DOUT ("CList::AddRef () Ref Count=%d", m_ulRef);
    return m_ulRef; 						  
}

// ===========================================================================================
// CList::Release
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ULONG CList<TYPE, ARG_TYPE>::Release ()
{
    ULONG ulCount = --m_ulRef;
    DOUT ("CList::Release () Ref Count=%d", ulCount);
    if (!ulCount) 
	{ 
	    delete this; 
	}
    return ulCount;
}

// ===========================================================================================
// CList::GetCount
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline INT CList<TYPE, ARG_TYPE>::GetCount() const
{ 
    return m_nCount; 
}

// ===========================================================================================
// CList::IsEmpty
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
{
    return m_nCount == 0; 
}

// ===========================================================================================
// CList::GetHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetHead()
{ 
    Assert (m_pHead != NULL);
    Assert (m_pHead->data);
    m_pHead->data->AddRef();
    return m_pHead->data; 
}

// ===========================================================================================
// CList::GetTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetTail()
{
    Assert (m_pTail != NULL);
    Assert (m_pTail->data);
#ifndef WIN16   // No SafeAddRef def anywhere
    SafeAddRef (m_pTail->data);
#endif
    return m_pTail->data; 
}

// ===========================================================================================
// CList::AddHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::AddHead()
{
	CNode* pNewNode = NewNode(NULL, m_pHead, NULL);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pHead != NULL)
		m_pHead->pPrev = pNewNode;
	else
		m_pTail = pNewNode;
	m_pHead = pNewNode;
    pNewNode->data->AddRef();
	return pNewNode->data;
}

// ===========================================================================================
// CList::AddTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::AddTail()
{
	CNode* pNewNode = NewNode(m_pTail, NULL, NULL);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pTail != NULL)
		m_pTail->pNext = pNewNode;
	else
		m_pHead = pNewNode;
	m_pTail = pNewNode;
    pNewNode->data->AddRef();
	return pNewNode->data;
}

// ===========================================================================================
// CList::AddHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newData)
{
	CNode* pNewNode = NewNode(NULL, m_pHead, newData);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pHead != NULL)
		m_pHead->pPrev = pNewNode;
	else
		m_pTail = pNewNode;
	m_pHead = pNewNode;
	return;
}

// ===========================================================================================
// CList::AddTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newData)
{
	CNode* pNewNode = NewNode(m_pTail, NULL, newData);
    Assert (pNewNode);
    Assert (pNewNode->data);
	if (m_pTail != NULL)
		m_pTail->pNext = pNewNode;
	else
		m_pHead = pNewNode;
	m_pTail = pNewNode;
	return;
}

// ===========================================================================================
// CList::RemoveHead
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::RemoveHead()
{
	Assert (m_pHead != NULL);
	CNode* pOldNode = m_pHead;
	m_pHead = pOldNode->pNext;
	if (m_pHead != NULL)
		m_pHead->pPrev = NULL;
	else
		m_pTail = NULL;
	FreeNode (pOldNode);
	return;
}

// ===========================================================================================
// CList::RemoveTail
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::RemoveTail()
{
	Assert (m_pHead != NULL);
	CNode* pOldNode = m_pTail;
	m_pTail = pOldNode->pPrev;
	if (m_pTail != NULL)
		m_pTail->pNext = NULL;
	else
		m_pHead = NULL;
	FreeNode(pOldNode);
	return;
}

// ===========================================================================================
// CList::Remove
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::Remove(ARG_TYPE oldData)
{
	CList::CNode *pNext, *pPrev = NULL, *pNode = m_pHead;
    Assert (pNode && oldData && m_nCount > 0);
	for (;;)
    {
        if (!pNode) 
            break;
        pNext = pNode->pNext;
        if (pNode->data == oldData)
        {
            if (pPrev == NULL)
            {
                m_pHead = pNext;
                if (pNext)
                    pNext->pPrev = NULL;
                if (m_pHead == NULL)
                    m_pTail = NULL;
            }

            else
            {
                pPrev->pNext = pNext;
                if (pNext)
                    pNext->pPrev = pPrev;
                else
                    m_pTail = m_pTail->pPrev;
            }

            FreeNode (pNode);
            break;
        }
        pPrev = pNode;
        pNode = pNext;
    }
}

// ===========================================================================================
// CList::GetHeadPosition
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline LISTPOS CList<TYPE, ARG_TYPE>::GetHeadPosition() const
{ 
    return (LISTPOS) m_pHead; 
}

// ===========================================================================================
// CList::GetTailPosition
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline LISTPOS CList<TYPE, ARG_TYPE>::GetTailPosition() const
{ 
    return (LISTPOS) m_pTail; 
}

// ===========================================================================================
// CList::MoveNext
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::MoveNext(LISTPOS& rPosition)
{
    CNode* pNode = (CNode*) rPosition;
    Assert (pNode);
    rPosition = (LISTPOS)pNode->pNext;
}

// ===========================================================================================
// CList::GetNext
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetNext(LISTPOS& rPosition)
{

    CNode* pNode = (CNode*) rPosition;
    Assert (pNode);
    rPosition = (LISTPOS)pNode->pNext;
    Assert (pNode->data);
    pNode->data->AddRef();
    return pNode->data; 
}

// ===========================================================================================
// CList::GetPrev
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetPrev(LISTPOS& rPosition)
{ 
    CNode* pNode = (CNode*) rPosition;
	Assert (pNode);
	rPosition = (LISTPOS) pNode->pPrev;
    Assert (pNode->data);
#ifndef WIN16   // No SafeAddRef def anywhere
    SafeAddRef (pNode->data);
#endif
	return pNode->data; 
}

// ===========================================================================================
// CList::GetAt non-const
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline ARG_TYPE CList<TYPE, ARG_TYPE>::GetAt(LISTPOS listpos)
{ 
    CNode* pNode = (CNode*) listpos;
	Assert (pNode);
    Assert (pNode->data);
#ifndef WIN16   // No SafeAddRef def anywhere
    SafeAddRef (pNode->data);
#endif
    return pNode->data; 
}

// ===========================================================================================
// CList::SetAt
// ===========================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(LISTPOS pos, ARG_TYPE newElement)
{ 
    CNode* pNode = (CNode*) pos;
	Assert (pNode);
    SafeRelease (pNode->data);
	pNode->data = newElement; 
    if (pNode->data)
        pNode->data->AddRef();
}

// =================================================================================
// CList::FreeNode
// =================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::FreeNode (CList::CNode *pNode)
{
    // Check Param
    Assert (pNode);

    // Free Address Members
    if (pNode->data)
    {
        ULONG ulCount;
        SafeReleaseCnt (pNode->data, ulCount);
        //AssertSz (ulCount == 0, "Linked list items should have ref counts of zero when freed.");
    }
    
    // Free Node
    SafeMemFree (pNode);

    // Dec Count
	m_nCount--;
	Assert (m_nCount >= 0);
}

// =================================================================================
// CList::RemoveAll
// =================================================================================
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::RemoveAll ()
{
	// destroy elements
	CList::CNode *pNext, *pNode = m_pHead;
	for (;;)
    {
        if (!pNode) break;
        pNext = pNode->pNext;
        FreeNode (pNode);
        pNode = pNext;
    }

	m_nCount = 0;
	m_pHead = m_pTail = NULL;
}

// =================================================================================
// CList::NewNode
// =================================================================================
template<class TYPE, class ARG_TYPE>
#ifdef WIN16
inline
#endif
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext, ARG_TYPE data)
{
    // Locals
    CList::CNode* pNode;

    // Allocate Memory
    MemAlloc ((LPVOID *)&pNode, sizeof (CList::CNode));    
    if (pNode)
    {
        if (data == NULL)
        {
            pNode->data = new TYPE;
        }
        else
        {
            pNode->data = data;
            data->AddRef();
        }
	    pNode->pPrev = pPrev;
	    pNode->pNext = pNext;
	    m_nCount++;
	    Assert (m_nCount > 0);  // make sure we don't overflow
    }

	return pNode;
}

#endif // __LISTTEMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\papres.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
// Common Papyrus/OE resource IDs
// Created 12/1/97 by YST


#ifndef __PAPRES_H__
#define __PAPRES_H__

#define RESID_START                     22222

#define IDB_PAPLEFT                     22223
#define IDB_PAPRIGHT                    22224
#define IDC_PAPSMALLICON                22225
#define IDC_PAPLARGEICON                22226
#define IDS_PAPFBARFONT                 22227
#define IDS_PAPFBARTEXT                 22228
#define IDB_PAPFLDL			22229
#define IDB_PAPFLDS			22230


#endif // __PAPRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\ourguid.h ===
/************
**  ATHGUID.H
**      Holds the GUIDs for Athena, including
**  those copied from Ren.
**
**  Author:  t-ErikN  (8/22/95)
*/

#ifndef __ATHGUID_H
#define __ATHGUID_H

#include "imnact.h"
#include <shlguidp.h>

////////////////////////////////////////////////////////////////////////
//
//  Athena CLSID
//
//  every OLE2 object class must have a unique CLSID (class id)
//  ours are: 
//  
//      Athena  {89292101-4755-11cf-9DC2-00AA006C2B84}
//      Mail    {89292102-4755-11cf-9DC2-00AA006C2B84}    
//      News    {89292103-4755-11cf-9DC2-00AA006C2B84}
//
//  you get a CLSID by running the guidgen application in the Win96 PDK
//
////////////////////////////////////////////////////////////////////////

DEFINE_GUID(CLSID_Athena,           0x8929210AL, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(CLSID_AddrObject,       0x56AA9BC0L, 0xAB09, 0x11CE, 0xB8, 0x73, 0x0, 0xAA, 0x0, 0x6E, 0xC3, 0x49);

DEFINE_GUID(IID_IIMAPSvrInfo,       0xdb3ba9f8L, 0xe368, 0x11d0, 0x8d, 0x4c, 0x0, 0xc0, 0x4f, 0xb6, 0xfb, 0xfd);
DEFINE_GUID(IID_IServerInfo,        0x89292104L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_IAthenaBrowser,     0x89292105L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_IAthenaView,        0x89292106L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_IStateInfo,         0xd0d8ed41L, 0x2000, 0x11cf, 0xbf, 0xe9, 0x0, 0xaa, 0x0, 0x6e, 0xb9, 0xf7);
DEFINE_GUID(IID_IGroupInfo,         0x89292107L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);
DEFINE_GUID(IID_ITreeViewNotify,    0x89292108L, 0x4755, 0x11cf, 0x9d, 0xc2, 0x0, 0xaa, 0x0, 0x6c, 0x2b, 0x84);

// {6152D280-1283-11d0-A56C-00C04FD61319}
DEFINE_GUID(IID_IBodyObj, 0x6152d280, 0x1283, 0x11d0, 0xa5, 0x6c, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x19);

// {2009013E-98D3-11d1-AF06-00C04FA31B90}
DEFINE_GUID(IID_IBodyObj2, 0x2009013e, 0x98d3, 0x11d1, 0xaf, 0x6, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// {44BBA840-CC51-11CF-AAFA-00AA00B6015C}
DEFINE_GUID(CLSID_AthenaSetup, 0x44BBA840L, 0xCC51, 0x11CF, 0xAA, 0xFA, 0x0, 0xAA, 0x0, 0xB6, 0x01, 0x5C);

/////////////////////////////////////////////////////////////////////////////
// Beavis's Thumbnail Extractor

DEFINE_GUID( CLSID_HtmlThumbnailExtractor,
    0xeab841a0, 0x9550, 0x11cf, 0x8c, 0x16, 0x0, 0x80, 0x5f, 0x14, 0x8, 0xf3);

// {BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractImage,          0xbb2e617c, 0x920, 0x11d1, 0x9a, 0xb, 
     0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

/////////////////////////////////////////////////////////////////////////////
// For Splash Screen

// {A2B0DD40-CC59-11d0-A3A5-00C04FD706EC}
//DEFINE_GUID( CLSID_IESplashScreen, 0xa2b0dd40, 0xcc59, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {CB81A3CB-1039-11d1-AB74-00C04FC30936}
//DEFINE_GUID( IID_ISplashScreen, 0xcb81a3cb, 0x1039, 0x11d1, 0xab, 0x74, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

/////////////////////////////////////////////////////////////////////////////
// For Envelope Object CommandTarget
// {EB5E6950-4A58-11d1-82D4-00C04FD9753F}
DEFINE_GUID(IID_IHeader, 0xeb5e6950, 0x4a58, 0x11d1, 0x82, 0xd4, 0x0, 0xc0, 0x4f, 0xd9, 0x75, 0x3f);
// {3B963A20-4A59-11d1-82D4-00C04FD9753F}
DEFINE_GUID(IID_IHeaderSite, 0x3b963a20, 0x4a59, 0x11d1, 0x82, 0xd4, 0x00, 0xc0, 0x4f, 0xd9, 0x75, 0x3f);
// {00067298-0000-0000-C000-000000000046}
/////////////////////////////////////////////////////////////////////////////
// New Columns handler

// {1C714A04-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(IID_IColumnInfo, 0x1C714A04, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {1C714A03-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(CLSID_ColumnsDlg, 0x1C714A03, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);


/////////////////////////////////////////////////////////////////////////////
// Message View Interface

// {1C714A05-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(IID_IMessageWindow, 0x1C714A05, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {1C714A07-9454-11D1-9E38-006097D50408}")
DEFINE_GUID(IID_IViewWindow, 0x1C714A07, 0x9454, 0x11D1, 0x9E, 0x38, 0x00, 0x60, 0x97, 0xD5, 0x04, 0x08);

// {0A776020-3496-11d2-9F03-0000F8058D9F}
DEFINE_GUID(IID_IViewData, 0xa776020, 0x3496, 0x11d2, 0x9f, 0x3, 0x0, 0x0, 0xf8, 0x5, 0x8d, 0x9f);

// ---------------------------------------------------------------------------------------
// Spooler
// ---------------------------------------------------------------------------------------
// {39419C53-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerEngine, 0x39419c53, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C54-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerBindContext, 0x39419c54, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C57-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CInboxRules, 0x39419c57, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C58-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerTask, 0x39419c58, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {39419C59-A6B8-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_ISpoolerUI, 0x39419c59, 0xa6b8, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {63BF8452-A7C1-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreInbox, 0x63bf8452, 0xa7c1, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {63BF8453-A7C1-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreOutbox, 0x63bf8453, 0xa7c1, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {63BF8454-A7C1-11d0-85C7-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreSentItems, 0x63bf8454, 0xa7c1, 0x11d0, 0x85, 0xc7, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {A2F07CA1-C0EF-11d0-85E9-00C04FD85AB4}
DEFINE_GUID(IID_CLocalStoreDeleted, 0xa2f07ca1, 0xc0ef, 0x11d0, 0x85, 0xe9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {CE4D0F21-BF13-11d0-85E5-00C04FD85AB4}
DEFINE_GUID(IID_CUidlCache, 0xce4d0f21, 0xbf13, 0x11d0, 0x85, 0xe5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6F023F65-F8B1-11d0-8A35-00C04FB951F3}
DEFINE_GUID(IID_CPop3LogFile, 0x6f023f65, 0xf8b1, 0x11d0, 0x8a, 0x35, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);

// {6F023F66-F8B1-11d0-8A35-00C04FB951F3}
DEFINE_GUID(IID_CSmtpLogFile, 0x6f023f66, 0xf8b1, 0x11d0, 0x8a, 0x35, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);

// ---------------------------------------------------------------------------------------
// Connection manager
// ---------------------------------------------------------------------------------------
// {D27E30B3-7AF4-11d0-83B5-00C04FD6131A}
DEFINE_GUID(IID_IConnectionNotify, 0xd27e30b3, 0x7af4, 0x11d0, 0x83, 0xb5, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x1a);

// ---------------------------------------------------------------------------------------
// General Note Guids
// ---------------------------------------------------------------------------------------
// {CAE80521-F685-11d1-AF32-00C04FA31B90}
DEFINE_GUID(CLSID_OENote, 0xcae80521, 0xf685, 0x11d1, 0xaf, 0x32, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// {CAE80522-F685-11d1-AF32-00C04FA31B90}
DEFINE_GUID(IID_IOENote, 0xcae80522, 0xf685, 0x11d1, 0xaf, 0x32, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// {8446AEC0-FBEA-11d1-AF35-00C04FA31B90}
DEFINE_GUID(IID_IOEMsgSite, 0x8446aec0, 0xfbea, 0x11d1, 0xaf, 0x35, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

//+-------------------------------------------------------------------------
// Private GUIDs
//--------------------------------------------------------------------------
// {663921AF-4D57-11d1-8A95-00C04FB951F3}
DEFINE_GUID(IID_CStoreFolder, 0x663921af, 0x4d57, 0x11d1, 0x8a, 0x95, 0x0, 0xc0, 0x4f, 0xb9, 0x51, 0xf3);

// {4DB85D00-AD69-11d1-AA67-006097D474C4}
DEFINE_GUID(IID_IEnumSubscription, 0x4db85d00, 0xad69, 0x11d1, 0xaa, 0x67, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// {4DB85D01-AD69-11d1-AA67-006097D474C4}
DEFINE_GUID(IID_ISubscriptionManager, 0x4db85d01, 0xad69, 0x11d1, 0xaa, 0x67, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// {DC0CCB27-BAB7-11d1-9E7A-0000F8058D9F}
DEFINE_GUID(IID_IDropDownFldrBar, 0xdc0ccb27, 0xbab7, 0x11d1, 0x9e, 0x7a, 0x0, 0x0, 0xf8, 0x5, 0x8d, 0x9f);

// {9D239B0F-0788-11d2-ACE4-00C04F8EC8A5}
DEFINE_GUID(IID_IStatusBar, 0x9d239b0f, 0x788, 0x11d2, 0xac, 0xe4, 0x0, 0xc0, 0x4f, 0x8e, 0xc8, 0xa5);

// {626BAFEC-E5D6-11D1-B1DD-006097D503D9}
DEFINE_GUID(IID_IOERuleAddrList, 0X626BAFEC, 0xE5D6, 0X11D1, 0xB1, 0xDD, 0x0, 0x60, 0x97, 0xD5, 0x03, 0xD9);

// --------------------------------------------------------------------------------
// Spooler GUIDS
// --------------------------------------------------------------------------------
// {92FB68A4-D785-11d0-A0D4-00C04FD6131A}
DEFINE_GUID(IID_ITimeoutCallback, 0x92fb68a4, 0xd785, 0x11d0, 0xa0, 0xd4, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x1a);

// {26E79700-FF05-11d1-AAAE-006097D474C4}
DEFINE_GUID(IID_IGroupListAdvise, 0x26e79700, 0xff05, 0x11d1, 0xaa, 0xae, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// --------------------------------------------------------------------------------
// OneStop GUIDS
// --------------------------------------------------------------------------------
// {D2984AB4-F2DE-11d1-AF07-00C04FA35D02}
DEFINE_GUID(CLSID_OEOneStopHandler, 0xd2984ab4, 0xf2de, 0x11d1, 0xaf, 0x7, 0x0, 0xc0, 0x4f, 0xa3, 0x5d, 0x2);

// HACK - Need to get this from somewhere else!
//{3af36230-a269-11d1-b5bf-0000f8051515}
DEFINE_GUID(CLSID_MobilityFeature,   0x3af36230, 0xa269, 0x11d1, 0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15);

// {279644D0-0C73-11d2-AF3A-00C04FA31B90}
DEFINE_GUID(CMDSETID_OutlookExpress, 0x279644d0, 0xc73, 0x11d2, 0xaf, 0x3a, 0x0, 0xc0, 0x4f, 0xa3, 0x1b, 0x90);

// --------------------------------------------------------------------------------
// BA control 
// --------------------------------------------------------------------------------
// {233A9694-667E-11d1-9DFB-006097D50408}
DEFINE_GUID(CLSID_OEBAControl, 0x233a9694, 0x667e, 0x11d1, 0x9d, 0xfb, 0x00, 0x60, 0x97, 0xd5, 0x04, 0x08);

#endif // include //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\rasdlgsp.h ===
#define idbDet                          1000
#define idlbDetails                     1001
#define ideProgress                     1002
#define idcSplitter                     1003
#define idchSavePassword                1004
#define ideUserName                     1005
#define idePassword                     1006
#define idePhone                        1007
#define idbEditConnection               1009
#define idrgUseCurrent                  1010
#define idrgDialNew                     1011
#define idcCurrentMsg                   1012
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\tbcustom.h ===
#ifndef      __TBCUSTOM_H
#define     __TBCUSTOM_H

#define     IDC_SHOWTEXT        110
#define     IDC_SMALLICONS      111

#endif //__TBCUSTOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\syncop.h ===
#ifndef _INC_SYNCOP_H
#define _INC_SYNCOP_H

// {26FE9D30-1A8F-11d2-AABF-006097D474C4}
DEFINE_GUID(CLSID_SyncOpDatabase, 0x26fe9d30, 0x1a8f, 0x11d2, 0xaa, 0xbf, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

//------------------------------------------------------------------
// Types
//------------------------------------------------------------------
DECLARE_HANDLE(SYNCOPID);
typedef SYNCOPID *LPSYNCOPID;

//------------------------------------------------------------------
// SYNCOPID Constants
//------------------------------------------------------------------
const SYNCOPID   SYNCOPID_INVALID = (SYNCOPID)-1;

//------------------------------------------------------------------
// SyncOp Database Version
//------------------------------------------------------------------
const DWORD SYNCOP_DATABASE_VERSION = 2;

//------------------------------------------------------------------
// SYNCOPTABLECOLID
//------------------------------------------------------------------
typedef enum tagSYNCOPTABLECOLID {
    OPCOL_ID = 0,
    OPCOL_SERVER,
    OPCOL_FOLDER,
    OPCOL_MESSAGE,
    OPCOL_OPTYPE,
    OPCOL_FLAGS,
    OPCOL_ADD_FLAGS,
    OPCOL_REMOVE_FLAGS,
    OPCOL_FOLDER_DEST,
    OPCOL_MESSAGE_DEST,
    OPCOL_LASTID
} SYNCOPTABLECOLID;

//------------------------------------------------------------------
// SYNCUSERDATA
//------------------------------------------------------------------
typedef struct tagSYNCOPUSERDATA {
    DWORD               fInitialized;                   // 4   Has this folder been initialized yet
    BYTE                rgReserved[248];                // Reserved
} SYNCOPUSERDATA, *LPSYNCOPUSERDATA;

typedef enum tagSYNCOPTYPE {
    SYNC_INVALID        = 0x0000,
    SYNC_SETPROP_MSG    = 0x0001,
    SYNC_CREATE_MSG     = 0x0002,
    SYNC_COPY_MSG       = 0x0004,
    SYNC_MOVE_MSG       = 0x0008,
    SYNC_DELETE_MSG     = 0x0010
} SYNCOPTYPE;

//------------------------------------------------------------------
// SOF_ sync op flags
//------------------------------------------------------------------
typedef DWORD SYNCOPFLAGS;
#define SOF_ALLFLAGS                 0x00000001

//------------------------------------------------------------------
// SYNCOPINFO
//------------------------------------------------------------------
typedef struct tagSYNCOPINFO {
    BYTE               *pAllocated;
    BYTE                bVersion;
    SYNCOPID            idOperation;
    FOLDERID            idServer;
    FOLDERID            idFolder;
    MESSAGEID           idMessage;
    SYNCOPTYPE          tyOperation;
    SYNCOPFLAGS         dwFlags;
    MESSAGEFLAGS        dwAdd;
    MESSAGEFLAGS        dwRemove;
    FOLDERID            idFolderDest;
    MESSAGEID           idMessageDest;
} SYNCOPINFO, *LPSYNCOPINFO;

//------------------------------------------------------------------
// Operation Record Members
//------------------------------------------------------------------
BEGIN_COLUMN_ARRAY(g_rgOpTblColumns, OPCOL_LASTID)
    DEFINE_COLUMN(OPCOL_ID,             CDT_DWORD,    SYNCOPINFO, idOperation)
    DEFINE_COLUMN(OPCOL_SERVER,         CDT_DWORD,    SYNCOPINFO, idServer)
    DEFINE_COLUMN(OPCOL_FOLDER,         CDT_DWORD,    SYNCOPINFO, idFolder)
    DEFINE_COLUMN(OPCOL_MESSAGE,        CDT_DWORD,    SYNCOPINFO, idMessage)
    DEFINE_COLUMN(OPCOL_OPTYPE,         CDT_WORD,     SYNCOPINFO, tyOperation)
    DEFINE_COLUMN(OPCOL_FLAGS,          CDT_DWORD,    SYNCOPINFO, dwFlags)
    DEFINE_COLUMN(OPCOL_ADD_FLAGS,      CDT_DWORD,    SYNCOPINFO, dwAdd)
    DEFINE_COLUMN(OPCOL_REMOVE_FLAGS,   CDT_DWORD,    SYNCOPINFO, dwRemove)
    DEFINE_COLUMN(OPCOL_FOLDER_DEST,    CDT_DWORD,    SYNCOPINFO, idFolderDest)
    DEFINE_COLUMN(OPCOL_MESSAGE_DEST,   CDT_DWORD,    SYNCOPINFO, idMessageDest)
END_COLUMN_ARRAY

//------------------------------------------------------------------
// g_OpTblPrimaryIndex
//------------------------------------------------------------------
BEGIN_TABLE_INDEX(g_OpTblPrimaryIndex, 1)
    DEFINE_KEY(OPCOL_ID,        0,  0)
END_TABLE_INDEX

BEGIN_TABLE_INDEX(g_OpFolderIdIndex, 3)
    DEFINE_KEY(OPCOL_SERVER,    0,  0)
    DEFINE_KEY(OPCOL_FOLDER,    0,  0)
    DEFINE_KEY(OPCOL_ID,        0,  0)
END_TABLE_INDEX

extern const TABLEINDEX g_OpFolderIdIndex;

//------------------------------------------------------------------
// Operation Record Format
//------------------------------------------------------------------
BEGIN_TABLE_SCHEMA(g_SyncOpTableSchema, CLSID_SyncOpDatabase, SYNCOPINFO)
    SCHEMA_PROPERTY(SYNCOP_DATABASE_VERSION)
    SCHEMA_PROPERTY(TSF_RESETIFBADVERSION)
    SCHEMA_PROPERTY(sizeof(SYNCOPUSERDATA))
    SCHEMA_PROPERTY(offsetof(SYNCOPINFO, idOperation))
    SCHEMA_PROPERTY(OPCOL_LASTID)
    SCHEMA_PROPERTY(g_rgOpTblColumns)
    SCHEMA_PROPERTY(&g_OpTblPrimaryIndex)
    SCHEMA_PROPERTY(NULL)
END_TABLE_SCHEMA

extern const TABLESCHEMA g_SyncOpTableSchema;

#endif // _INC_SYNCOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\thormsgs.h ===
////////////////////////////////////////////////////////////////////////
//
//  THORMSGS.H
//
//  Internally defined window messages
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_THORMSGS_H
#define _INC_THORMSGS_H

// newsview/mailview common messages
#define CM_OPTIONADVISE             (WM_USER + 1034)
#define WMR_CLICKOUTSIDE            (WM_USER + 1035)
#define WM_UPDATELAYOUT             (WM_USER + 1036)
#define WM_POSTCREATE               (WM_USER + 1037)
#define WM_FINDNEXT                 (WM_USER + 1038)
#define WM_SELECTROW                (WM_USER + 1039)
#define WM_TEST_GETMSGID            (WM_USER + 1040)
#define WM_TEST_SAVEMSG             (WM_USER + 1041)
#define WM_TOGGLE_CLOSE_PIN         (WM_USER + 1042)
#define WM_GET_TITLE_BAR_HEIGHT     (WM_USER + 1043)
#define WM_NEW_MAIL                 (WM_USER + 1044)
#define WM_UPDATE_PREVIEW           (WM_USER + 1045)
#define WM_OE_ENABLETHREADWINDOW    (WM_USER + 10666)
#define WM_OE_ACTIVATETHREADWINDOW  (WM_USER + 10667)
#define WM_OESETFOCUS               (WM_USER + 1046)
#define WM_OE_DESTROYNOTE           (WM_USER + 1047)
#define WM_OENOTE_ON_COMPLETE       (WM_USER + 1048)
#define WM_HEADER_GETFONT           (WM_USER + 1049)

// WMR_CLICKOUTSIDE - Subcodes, passed in the wParam to indicate what action cause this
// message to be sent. If MOUSE, hwnd is in lParam, if KeyBd VK code in  LPARAM
// If deactivate lparam is 0. Also the combination 0,0 may be sent to
// indicate other cases

#define CLK_OUT_MOUSE	0
#define CLK_OUT_KEYBD	1
#define CLK_OUT_DEACTIVATE 2


// newsview-specific messages
#define NVM_INITHEADERS         (WM_USER + 1101)
#define NVM_CHANGESERVERS       (WM_USER + 1104)  // Used in subscr.cpp
#define NVM_GETNEWGROUPS        (WM_USER + 1105)

// mailview-specific messages
#define MVM_REDOCOLUMNS     (WM_USER + 1202)
#define MVM_SPOOLERDELIVERY (WM_USER + 1206)
#define MVM_NOTIFYICONEVENT (WM_USER + 1208)

// note window messages
#define NWM_UPDATETOOLBAR   (WM_USER + 1300)
#define NWM_TESTGETDISP     (WM_USER + 1301)
#define NWM_TESTGETADDR     (WM_USER + 1302)
#define NWM_DROPFILEDESC    (WM_USER + 1303)
#define NWM_SETDROPTARGET   (WM_USER + 1304)
#define NWM_DEFEREDINIT     (WM_USER + 1305)
#define NWM_GETDROPTARGET   (WM_USER + 1306)
#define NWM_FILTERACCELERATOR   (WM_USER + 1307)
#define NWM_SHOWVCARDPROP   (WM_USER + 1308)
#define NWM_PASTETOATTACHMENT (WM_USER + 1309)

// dochost window messages
#define DHM_AUTODETECT       (WM_USER + 1350)

// Font cache notifications
#define FTN_POSTCHANGE      (WM_USER + 1403)
#define FTN_PRECHANGE       (WM_USER + 1404)

// Test team hooks
#define TT_GETCOOLBARFOLDER (WM_USER + 1501)
#define TT_ISTEXTVISIBLE    (WM_USER + 1502)

// INETMAIL Delivery Messages
#define IMAIL_DELIVERNOW        (WM_USER + 1700)
#define IMAIL_UPDATENOTIFYICON  (WM_USER + 1701)
#define IMAIL_POOLFORMAIL       (WM_USER + 1702)
#define IMAIL_WATCHDOGTIMER     (WM_USER + 1703)
#define IMAIL_NEXTTASK          (WM_USER + 1704)
#define IMAIL_SHOWWINDOW        (WM_USER + 1705)
#define IMAIL_SETPROGRESSRANGE  (WM_USER + 1706)
#define IMAIL_UPDATEPROGRESS    (WM_USER + 1707)
#define IMAIL_UPDATEGENERAL     (WM_USER + 1708)

// Spooler Messages
#define SPOOLER_POLLTIMER       (WM_USER + 1750)
#define SPOOLER_DELIVERNOW      (WM_USER + 1751)
#define SPOOLER_APPENDQUEUE     (WM_USER + 1752)
#define SPOOLER_NEXTEVENT       (WM_USER + 1753)

// IInetMsgCont notification messages
#define IMC_UPDATEHDR           (WM_USER + 1800)
#define IMC_ARTICLEPROG         (WM_USER + 1801)
#define IMC_UPDATEANDREFOCUS    (WM_USER + 1802)  
#define IMC_HDRSTATECHANGE      (WM_USER + 1803)
#define IMC_BODYAVAIL           (WM_USER + 1804)
#define IMC_BODYERROR           (WM_USER + 1805)
#define IMC_INSERTROW           (WM_USER + 1806)
#define IMC_DELETEROW           (WM_USER + 1807)
#define IMC_DISKOUTOFSPACE      (WM_USER + 1808)    // Bug #50704 (v-snatar)

// Connection Manager Messages
#define CM_CONNECT              (WM_USER + 2100)    // wParam is an HMENU, lParam is the command ID
#define CM_UPDATETOOLBAR        (WM_USER + 2101)
#define CM_NOTIFY               (WM_USER + 2102)
#define CM_INTERNALRECONNECT    (WM_USER + 2103)

// Spooler task messages
#define NTM_NEXTSTATE           (WM_USER + 2202)
#define NTM_NEXTARTICLESTATE    (WM_USER + 2203)

// Outlook Bar notification message
#define WM_RELOADSHORTCUTS      (WM_USER + 2301)

// OE Rules messages
#define WM_OE_GET_RULES         (WM_USER + 2400)
#define WM_OE_FIND_DUP          (WM_USER + 2401)

//Toolbar notifications
#define WM_OE_TOOLBAR_STYLE     (WM_USER + 2402)
#endif // _INC_THORMSGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\rulesdlg.h ===
//
// rulesdlg.h
//
// contains resource identifiers for the rules dialogs
//

#ifndef __RULESDLG_H_
#define __RULESDLG_H_

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

// For Rules Manager
#define idlvRulesList                   128
#define idtbRulesTab                    129
#define idbNewRule                      130
#define idbDeleteRule                   131
#define idbModifyRule                   132
#define idbMoveUpRule                   133
#define idbMoveDownRule                 134
#define idredtRuleDescription           135
#define idbRuleOptions                  136
#define idbRulesApplyTo                 137
#define idbCopyRule                     138
#define idcRuleTitle                    139
#define idhNewRule                      50700
#define idhModifyRule                   50705
#define idhCopyRule                     50710
#define idhRemoveRule                   50715
#define idhRuleApply                    50720
#define idhRuleUp                       50725
#define idhRuleDown                     50730
#define idhRuleDescription              50735

// For Edit Rule dialog
#define idcRuleDir                      128
#define idlvCriteria                    129
#define idlvActions                     130
#define idredtDescription               131
#define idedtRuleName                   132
#define idhCriteriaView                 50600
#define idhDescriptionView              50605
#define idhViewName                     50610
#define idhCriteriaRule                 50740
#define idhActionsRule                  50745
#define idhDescriptionRule              50750
#define idhRuleName                     50755

// For Rename Rule dialog
#define idedtRenameRule                 128

// For Select Text dialog
#define idedtCriteriaText               128

// For Select Address dialog
#define idedtCriteriaAddr               128
#define idbCriteriaAddr                 129

// For Select Account dialog
#define idcCriteriaAcct                 128

// For Select Color dialog
#define idcCriteriaColor                128

// For Select Size dialog
#define idcCriteriaSize                 128
#define idspnCriteriaSize               129

// For Select Lines dialog
#define idcCriteriaLines                128
#define idspnCriteriaLines              129

// For Select Age dialog
#define idcCriteriaAge                  128
#define idspnCriteriaAge                129

// For Select Show dialog
#define idcCriteriaShow                 128
#define idcCriteriaHide                 129

// For Select Secure dialog
#define idcCriteriaSigned               128
#define idcCriteriaEncrypt              129

// For Select Priority dialog
#define idcCriteriaHighPri              128
#define idcCriteriaLowPri               129

// For Select Thread State dialog
#define idcCriteriaWatchThread          128
#define idcCriteriaIgnoreThread         129

// For Select Logic dialog
#define idcCriteriaAnd                  128
#define idcCriteriaOr                   129

// For Select Flag dialog
#define idcCriteriaFlag                 128
#define idcCriteriaNoFlag               129

// For Select Downloaded dialog
#define idcCriteriaDownloaded           128
#define idcCriteriaNotDownloaded        129

// For Select Read dialog
#define idcCriteriaRead                 128
#define idcCriteriaNotRead              129

// For Select Watch dialog
#define idcActionsWatchThread           128
#define idcActionsIgnoreThread          129

// For Block Senders dialog
#define idbAddSender                    128
#define idbRemoveSender                 129
#define idbModifySender                 130
#define idlvSenderList                  131
#define idcSenderTitle                  132
#define idhAddSender                    50820
#define idhModifySender                 50825
#define idhRemoveSender                 50830

// For Select Sender dialog
#define idedtSender                     128
#define idcBlockMail                    129
#define idcBlockNews                    130
#define idcBlockBoth                    131

// For Junk Mail page
#define idcJunkMail                     128
#define idbExceptions                   130
#define idcJunkSliderIcon               131
#define idcJunkSlider                   133
#define idcJunkSliderMore               134
#define idcJunkSliderLess               135
#define idcJunkDeleteIcon               136
#define idcJunkDelete                   137
#define idedtJunkDelete                 138
#define idcJunkDeleteSpin               139
#define idcJunkDays                     140
#define idcJunkTitle                    141
#define idhJunkMail                     50800
#define idhExceptions                   50805
#define idhJunkSlider                   50810
#define idhJunkDelete                   50815

// For Apply Rules dialog
#define idtbRulesApplyTab               128

// For Apply Mail Rules dialog
#define idlvRulesApplyList              128
#define idredtApplyDescription          129
#define idcRulesApplySubfolder          131
#define idcRulesApply                   132
#define idcApplyFolder                  133
#define idcBrowseApplyFolder            134
#define idcApplyRulesAll                135
#define idcApplyRulesNone               136
#define idhRulesList                    50760
#define idhApplyRulesAll                50765
#define idhApplyRulesNone               50770
#define idhApplyDescription             50775
#define idhApplyFolder                  50780
#define idhApplySubfolder               50785
#define idhBrowseApplyFolder            50790
#define idhApplyNow                     50795

// For Views Manager dialog
#define idlvViewsList                   128
#define idbNewView                      129
#define idbModifyView                   130
#define idbRenameView                   131
#define idbCopyView                     132
#define idbDeleteView                   133
#define idbDefaultView                  134
#define idredtViewDescription           135
#define idhNewView                      50860
#define idhModifyView                   50865
#define idhCopyView                     50870
#define idhRemoveView                   50875
#define idhApplyView                    50880
#define idhViewDescription              50885

// For Exceptions List
#define idcExceptionsWAB                128
#define idlvExceptions                  129
#define idcAddException                 130
#define idcRemoveException              131
#define idcModifyException              132

// For Exception Editor
#define idedtException                  128

// For the multiple criteria editor
#define idcCriteriaEdit                 128
#define idcCriteriaAdd                  129
#define idcCriteriaAddrBook             130
#define idcCriteriaRemove               131
#define idcCriteriaOptions              132
#define idcCriteriaList                 150
#define idcCriteriaContains             151
#define idcCriteriaNotCont              152

// For the Apply View dialog
#define idcViewCurrent                  128
#define idcViewAll                      129

#endif // !__RULESDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\strconst.h ===
/*----------------------------------------------------------------------------
    strconst.h
        Non-localizable String constant definitions

 ----------------------------------------------------------------------------*/

//////////////////////////// WARNING: PLEASE READ ///////////////////////////
//
// string values that are no longer used are commented out.
// for reg key strings, the commented out keys should not be reused unless
// we can be totally sure that the key value is being persisted the same
// way as before.  when in doubt, use a different key.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _STRCONST_H
#define _STRCONST_H

#ifdef DEFINE_STRING_CONSTANTS
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#else
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#define STR_REG_PATH_FLAT           "Software\\Microsoft\\Outlook Express"
#define STR_REG_PATH_ROOT           "Software\\Microsoft\\Outlook Express\\5.0"
#define STR_REG_PATH_ROOT_V1        "Software\\Microsoft\\Internet Mail and News"
#define STR_REG_PATH_IE             "Software\\Microsoft\\Internet Explorer"
#define STR_REG_PATH_EMAIL          "Software\\Microsoft\\Email"
#define STR_REG_PATH_NS             "Software\\Netscape"
#define STR_REG_PATH_CLIENTS        "Software\\Clients"
#define STR_REG_PATH_EXPLORER       STR_REG_WIN_ROOT "\\Explorer"
#define STR_FILE_PATH_MAINEXE       "msimn.exe"
#define STR_REG_PATH_IMN            "Internet Mail and News"
#define STR_REG_WAB_FLAT            "Software\\Microsoft\\WAB"
#define STR_REG_WAB_ROOT            STR_REG_WAB_FLAT "\\5.0"
#define STR_REG_IAM_FLAT            "Software\\Microsoft\\Internet Account Manager"
#define STR_REG_WIN_ROOT            "Software\\Microsoft\\Windows\\CurrentVersion"
#define STR_REG_PATH_POLICY         "Software\\Policies\\Microsoft\\Outlook Express"

STR_GLOBAL(c_szIMN,                 STR_REG_PATH_IMN);
STR_GLOBAL(c_szMOE,                 "Outlook Express");
STR_GLOBAL(c_szOutlook,             "Microsoft Outlook");
STR_GLOBAL(c_szNT,                  "Microsoft(R) Windows NT(TM) Operating System");
STR_GLOBAL(c_szMail,                "mail");
STR_GLOBAL(c_szNews,                "news");
STR_GLOBAL(c_szSigs,                "signatures");
STR_GLOBAL(c_szCLSID,               "CLSID");
STR_GLOBAL(c_szNewsCommand,         "\"%s\\" STR_FILE_PATH_MAINEXE "\" /newsurl:%%1");
STR_GLOBAL(c_szOutNewsCommand,      "\"%s\\" STR_FILE_PATH_MAINEXE "\" /outnews /newsurl:%%1");
STR_GLOBAL(c_szMailCommand,         "\"%s\\" STR_FILE_PATH_MAINEXE "\" /mailurl:%%1");
STR_GLOBAL(c_szIMNMailPath,         "Software\\Microsoft\\" STR_REG_PATH_IMN "\\Mail");
STR_GLOBAL(c_szOutlookHotWizHost,    "Outlook HotWizHost");

STR_GLOBAL(c_szRegRoot,             STR_REG_PATH_ROOT);
STR_GLOBAL(c_szRegFlat,             STR_REG_PATH_FLAT);
STR_GLOBAL(c_szInboxRulesPath,      "\\Mail\\Inbox Rules");
STR_GLOBAL(c_szRegRootSubscribe,    STR_REG_PATH_ROOT "\\News\\Subscribe");

STR_GLOBAL(c_szRegRoot_V1,          STR_REG_PATH_ROOT_V1);
STR_GLOBAL(c_szInboxRulesPath_V1,   STR_REG_PATH_ROOT_V1 "\\Mail\\Inbox Rules");

STR_GLOBAL(c_szEnvHostClientPath,   STR_REG_PATH_CLIENTS "\\EnvelopeHost");

STR_GLOBAL(c_szRegOutNews,          "\\Software\\Microsoft\\Office\\8.0\\Outlook\\General");
STR_GLOBAL(c_szRegOutNewsDefault,   "Outlook Newsreader");
STR_GLOBAL(c_szProtocolPath,        STR_REG_PATH_CLIENTS "\\%s\\%s\\Protocols");

STR_GLOBAL(c_szRegIEWebSearch,      STR_REG_WIN_ROOT "\\Explorer\\FindExtensions\\Static\\WebSearch");
STR_GLOBAL(c_szInstallRoot,         "InstallRoot");
STR_GLOBAL(c_szExchangeSetup,       "Software\\Microsoft\\Exchange\\Setup");
STR_GLOBAL(c_szServices,            "Services");
STR_GLOBAL(c_szMAPIRunOnce,         "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
STR_GLOBAL(c_szMAPIRunOnceEntry,    "OE5_0");
STR_GLOBAL(c_szFixMAPI,             "fixmapi.exe");

// new reg paths (relative to outlook express reg root)
STR_GLOBAL(c_szRegJunkMailOn,       "bhgcc");
STR_GLOBAL(c_szRegRTLRichEditHACK,  "rtlreh");
STR_GLOBAL(c_szRegPathNews,         "News");
STR_GLOBAL(c_szRegPathMail,         "Mail");
STR_GLOBAL(c_szRegPathRSList,       "Recent Stationery List");
STR_GLOBAL(c_szRegPathRSWideList,   "Recent Stationery Wide List");
STR_GLOBAL(c_szRegPathColumns,      "Columns");
STR_GLOBAL(c_szRegPathDontShowDlgs, "Dont Show Dialogs");
STR_GLOBAL(c_szRegPathIMAP,         "IMAP");
STR_GLOBAL(c_szRegPathHTTP,         "HTTP");
STR_GLOBAL(c_szRegPathInboxRules,   "Mail\\Inbox Rules");
STR_GLOBAL(c_szRegPathGroupFilters, "News\\Group Filters");
STR_GLOBAL(c_szRegPathSmartLog,     "SmartLog");

STR_GLOBAL(c_szRegPathNoteMail,     "MailNote");
STR_GLOBAL(c_szRegPathNoteNews,     "NewNote");


STR_GLOBAL(c_szRegOpen,             "\\shell\\open\\command");

STR_GLOBAL(c_szRegPathClients,      "Software\\Clients");
STR_GLOBAL(c_szRegPathSpecificClient,"Software\\Clients\\%s\\%s");

STR_GLOBAL(c_szAppPaths,            STR_REG_WIN_ROOT "\\App Paths");
STR_GLOBAL(c_szRegPath,             "Path");
STR_GLOBAL(c_szMainExe,             STR_FILE_PATH_MAINEXE);
STR_GLOBAL(c_szReadme,              "readme.txt");
STR_GLOBAL(c_szIexploreExe,         "iexplore.exe");

STR_GLOBAL(c_szWabRoot,             STR_REG_WAB_FLAT);
STR_GLOBAL(c_szWabFileName,         STR_REG_WAB_FLAT "\\WAB4\\Wab File Name");
STR_GLOBAL(c_szRoamingHive,         "Outlook_Express_Roaming");

STR_GLOBAL(c_szRegFolders,          STR_REG_WIN_ROOT "\\Explorer\\Shell Folders");
STR_GLOBAL(c_szValueAppData,        "AppData");
STR_GLOBAL(c_szValueVersion,        "Version");

STR_GLOBAL(c_szRegStoreRootDir,     "Store Root");
STR_GLOBAL(c_szRegStoreRootDir_V1,  "Store Root v1.0");
STR_GLOBAL(c_szRegDllPath,          "DLLPath");
STR_GLOBAL(c_szMSIMN,               "MSIMN");
STR_GLOBAL(c_szRegRegressStore,     "Regress Store");
STR_GLOBAL(c_szStoreMigratedToOE5,  "StoreMigratedV5");
STR_GLOBAL(c_szConvertedToDBX,      "ConvertedToDBX");
STR_GLOBAL(c_szNewStoreDir,         "New Store Folder");
STR_GLOBAL(c_szMoveStore,           "MoveStore");

STR_GLOBAL(c_szRegDisableHotmail,   "Disable Hotmail");
STR_GLOBAL(c_szRegValNoModifyAccts, "No modify accts");

// Secret key for another user agent
STR_GLOBAL(c_szAgent,   "User String");

// Prefixes for URLs
STR_GLOBAL(c_szURLNews,             "news");
STR_GLOBAL(c_szURLNNTP,             "nntp");
STR_GLOBAL(c_szURLSnews,            "snews");
STR_GLOBAL(c_szURLMailTo,           "mailto");
STR_GLOBAL(c_szURLNetNews,          "netnews");

#define c_szRegNewsURL              c_szURLNews
#define c_szRegNNTPURL              c_szURLNNTP
#define c_szRegMailtoURL            c_szURLMailTo

STR_GLOBAL(c_szPathFileFmt,         "%s\\%s");
STR_GLOBAL(c_szFoldersFile,         "Folders.dbx");
STR_GLOBAL(c_szPop3UidlFile,        "Pop3uidl.dbx");
STR_GLOBAL(c_szOfflineFile,         "Offline.dbx");

// Stationery
STR_GLOBAL(c_szRegStationery,           "SOFTWARE\\Microsoft\\Shared Tools\\Stationery");
STR_GLOBAL_WIDE(c_wszNotepad,           "Notepad.exe");
STR_GLOBAL_WIDE(c_wszValueStationery,   "Stationery Folder");

STR_GLOBAL(c_szRegDefSig,           "Default Signature");
STR_GLOBAL(c_szSigName,             "name");
STR_GLOBAL(c_szSigType,             "type");
STR_GLOBAL(c_szSigText,             "text");
STR_GLOBAL(c_szSigFile,             "file");

// general purpose string constants
STR_GLOBAL(g_szEllipsis,            "...");
STR_GLOBAL(g_szSpace,               " ");
STR_GLOBAL(g_szNewline,             "\n");
STR_GLOBAL(g_szCRLF,                "\r\n");
STR_GLOBAL(g_szCRLF2,               "\r\n\r\n");
STR_GLOBAL(g_szComma,               ",");
STR_GLOBAL(g_szAsterisk,            "*");
STR_GLOBAL(g_szPercent,             "%");
STR_GLOBAL(g_szCurrentDir,          ".");
STR_GLOBAL(g_szParentDir,           "..");
STR_GLOBAL(c_szYes,                 "yes");
STR_GLOBAL(c_szEmpty,               "");
STR_GLOBAL(g_szBackSlash,           "\\");
STR_GLOBAL(g_szQuote,               "\'");
STR_GLOBAL(g_szCommaSpace,          ", ");
STR_GLOBAL(c_szSpaceDashSpace,      " - ");
STR_GLOBAL(c_szDelimiters,          " ,\t;");
STR_GLOBAL(c_szOETopLevel,          "OETLWindow");
STR_GLOBAL(c_szSemiColonSpace,      "; ");
STR_GLOBAL(c_szAt,                  "@");
STR_GLOBAL_WIDE(c_wszEmpty,         "");
STR_GLOBAL_WIDE(g_wszComma,         ",");
STR_GLOBAL_WIDE(g_wszSpace,         " ");
STR_GLOBAL_WIDE(g_wszCRLF,          "\r\n");

//
// registry stuff:
//
STR_GLOBAL(CFSTR_HTML,              "Microsoft Outlook Express HTML Format");
STR_GLOBAL(CFSTR_INETMSG,           "Internet Message (rfc822/rfc1522)");
STR_GLOBAL(CFSTR_ATHENAMAILMESSAGES,"Athena Mail Messages");
STR_GLOBAL(CFSTR_ATHENAMAILFOLDERS, "Athena Mail Folders");
STR_GLOBAL(CFSTR_ATHENAIMAPMESSAGES,"Athena IMAP Messages");
STR_GLOBAL(CFSTR_ATHENACACHEMESSAGES, "Athena Cached Messages");
STR_GLOBAL(CFSTR_OEFOLDER,          "Outlook Express Folder");
STR_GLOBAL(CFSTR_OEMESSAGES,        "Outlook Express Messages");
STR_GLOBAL(CFSTR_OESHORTCUT,        "Outlook Express Shortcut");

// reg keys

STR_GLOBAL(c_szTrident,             "\\Trident");
STR_GLOBAL(c_szTridentIntl,         "\\Trident\\International");
STR_GLOBAL(c_szRegTrident,          STR_REG_PATH_ROOT "\\Trident");               
STR_GLOBAL(c_szRegInternational,    STR_REG_PATH_ROOT "\\Trident\\International");
STR_GLOBAL(c_szRegTriSettings,      STR_REG_PATH_ROOT "\\Trident\\Settings");
STR_GLOBAL(c_szRegTriMain,          STR_REG_PATH_ROOT "\\Trident\\Main");

STR_GLOBAL(c_szRegClientPath,       "shell\\open\\command");
STR_GLOBAL(c_szRegStartPageKey,     "Software\\Microsoft\\Internet Explorer\\Main");
STR_GLOBAL(c_szRegStartPage,        "Start Page");
STR_GLOBAL(c_szRegSmapiDefault,     "SMapi");

STR_GLOBAL(c_szInetAcctMgrRegKey,   STR_REG_IAM_FLAT);

STR_GLOBAL(c_szHTTPMailServiceRoot, "Software\\Microsoft\\Internet Domains");
STR_GLOBAL(c_szHTTPMailEnabled,     "HTTP Mail Enabled");
STR_GLOBAL(c_szHTTPMailServer,      "HTTP Mail Server");
STR_GLOBAL(c_szHTTPMailServiceName, "Friendly Name");
STR_GLOBAL(c_szHTTPMailSignUp,      "SignUp URL");
STR_GLOBAL(c_szHTTPMailConfig,      "Config URL");
STR_GLOBAL(c_szHTTPMailAcctNumber,  "Account Number");
STR_GLOBAL(c_szHTTPMailDomainMSN,   "MSN.COM");
STR_GLOBAL(c_szHTTPMailUseWizard,   "UseWizard");

// reg values
STR_GLOBAL(c_szRegValIMNFontSize,   "IMNFontSize");

// URL Substitution strings
STR_GLOBAL(c_szUrlSubPRD,           "OutlookExpress");
STR_GLOBAL(c_szUrlSubPVER,          "6.0");

// Group Fitlers and Inbox Rules Values
STR_GLOBAL(c_szRulesConfigDirty,    "RulesConfigDirty");
STR_GLOBAL(c_szDisabled,            "Disabled");
STR_GLOBAL(c_szCC,                  "CC");
STR_GLOBAL(c_szTo,                  "To");
STR_GLOBAL(c_szFrom,                "From");
STR_GLOBAL(c_szSubject,             "Subject");
STR_GLOBAL(c_szActionV1,            "Action");
STR_GLOBAL(c_szActions,             "Actions");
STR_GLOBAL(c_szFolderV1,            "Folder");
#ifdef DEBUG
STR_GLOBAL(c_szMoveV1,              "Move");
#endif
STR_GLOBAL(c_szMoveToFolder,        "Move To Folder");
STR_GLOBAL(c_szMoveToHfolder,       "Move To Handle");
STR_GLOBAL(c_szCopyToFolder,        "Copy To Folder");
STR_GLOBAL(c_szCopyToHfolder,       "Copy To Handle");
STR_GLOBAL(c_szFilterOnSize,        "Filter On Size");
STR_GLOBAL(c_szFilterByAccount,     "Filter By Account");
STR_GLOBAL(c_szFilterSize,          "Size");
STR_GLOBAL(c_szFilterAllMessages,   "All Messages");
STR_GLOBAL(c_szForwardTo,           "Forward To");
STR_GLOBAL(c_szReplyWithFile,       "Reply With File");
STR_GLOBAL(c_szFilterOnDate,        "Filter On Date");
STR_GLOBAL(c_szFilterDays,          "Days");
STR_GLOBAL(c_szFilterServer,        "Server");
STR_GLOBAL(c_szFilterGroup,         "Group");
STR_GLOBAL(c_szDisabledReason,      "Disabled Reason");

// common values
//
STR_GLOBAL(c_szMarkPreviewAsRead,   "MarkPreviewAsRead");               // OPT_MARKASREAD
STR_GLOBAL(c_szRegIndentChar,       "Indent Char");                     // OPT_INDENT
STR_GLOBAL(c_szRegAlwaysSuggest,    "SpellDontAlwaysSuggest");          // OPT_SPELLALWAYSSUGGEST
STR_GLOBAL(c_szRegCheckOnSend,      "SpellCheckOnSend");                // OPT_SPELLCHECKONSEND
STR_GLOBAL(c_szRegCheckOnType,      "SpellCheckOnType");                // OPT_SPELLCHECKONTYPE
STR_GLOBAL(c_szRegIgnoreUpper,      "SpellIgnoreUpper");                // OPT_SPELLIGNOREUPPER
STR_GLOBAL(c_szRegIgnoreDBCS,       "SpellDontIgnoreDBCS");             // OPT_SPELLIGNOREDBCS
STR_GLOBAL(c_szRegIgnoreNumbers,    "SpellIgnoreNumbers");              // OPT_SPELLIGNORENUMBER
STR_GLOBAL(c_szRegIgnoreProtect,    "SpellDontIgnoreProtect");          // OPT_SPELLIGNOREPROTECT
STR_GLOBAL(c_szRegIgnoreURL,        "SpellIgnoreURLs");
STR_GLOBAL(c_szRegDigSign,          "Digitally Sign Messages");         // OPT_*_DIGSIGNMESSAGES
STR_GLOBAL(c_szRegEncrypt,          "Encrypt Messages");                // OPT_*_ENCRYPTMESSAGES

#ifdef SMIME_V3
STR_GLOBAL(c_szRegUseLabels,        "Security Label");                  // OPT_USE_LABELS
STR_GLOBAL(c_szRegPolSize,          "Policy size");                     // OPT_POLICYNAME_SIZE
STR_GLOBAL(c_szRegPolData,          "Policy data");                     // OPT_POLICYNAME_DATA
STR_GLOBAL(c_szRegHasClass,         "Classifications");                 // OPT_HAS_CLASSIFICAT
STR_GLOBAL(c_szRegClassData,        "Classifications data");            // OPT_CLASSIFICAT_DATA
STR_GLOBAL(c_szRegPrivSize,         "PrivacyMark size");                // OPT_PRIVACYMARK_SIZE
STR_GLOBAL(c_szRegPrivData,         "PrivacyMark data");                // OPT_PRIVACYMARK_DATA
STR_GLOBAL(c_szRegCategize,         "Category size");                   // OPT_CATEGORY_SIZE
STR_GLOBAL(c_szRegCategData,        "Category data");                   // OPT_CATEGORY_DATA
STR_GLOBAL(c_szRegUseSecRec,        "Security Receipts");               // OPT_SECREC_USE
STR_GLOBAL(c_szRegVerifySecRec,     "Verify Security Receipt");         // OPT_SECREC_VERIFY
STR_GLOBAL(c_szSendSecMDN,          "Send Security Receipt");           // OPT_MDN_SEC_RECEIPT
STR_GLOBAL(c_szRegEncryptSecRec,    "Encrypt Security Receipt");        // OPT_SECREC_ENCRYPT
#endif // SMIME_V3

STR_GLOBAL(c_szRegIncludeCert,      "Include Certificate");             // OPT_*_INCLUDECERT
STR_GLOBAL(c_szRegDefEncryptSymcaps, "Encryption SymCaps");             // OPT_MAIL_DEFENCRYPTSYMCAPS
STR_GLOBAL(c_szRegDialupConnection, "StartConnection");                 // OPT_DIALUP_CONNECTION
STR_GLOBAL(c_szRegWarnSwitch,       "SwitchConnectionPrompt");          // OPT_DIALUP_WARN_SWITCH
STR_GLOBAL(c_szRegHangupDone,       "Hangup After Spool");              // OPT_DIALUP_HANGUP_DONE
STR_GLOBAL(c_szRegDialupLastStart,  "Last Startup Connection");         // OPT_DIALUP_LAST_SART
STR_GLOBAL(c_szRegDefaultConnection, "InternetProfile");                // OPT_DEFAULT_CONNECTION
STR_GLOBAL(c_szRegLaunchInbox,      "Launch Inbox");                    // OPT_LAUNCH_INBOX
//STR_GLOBAL(c_szRegSmallIconsPath,   STR_REG_PATH_EXPLORER "\\SmallIcons");
STR_GLOBAL(c_szRegSmallIconsValue,  "SmallIcons");
STR_GLOBAL(c_szRegSmtpUseIpForHelo, "UseIPForSMTPHELO");                // OPT_SMTPUSEIPFORHELO
STR_GLOBAL(c_szRegExpandUnread,     "Expand Unread");                   // OPT_EXPAND_UNREAD
STR_GLOBAL(c_szRegHangupNoDial,     "Hangup Without Dial 5.0");         // OPT_DIALUP_HANGUP_WITHOUT_DIAL
STR_GLOBAL(c_szRegBodyBarPath,      "BodyBarPath");
STR_GLOBAL(c_szFrontPagePath,       "FrontPagePath");
STR_GLOBAL(c_szRegHelpUrl,          "HelpUrl");
STR_GLOBAL(c_szShowEnvelopes,       "ShowEnvHosts");
STR_GLOBAL(c_szShowBcc,             "ShowBcc");
STR_GLOBAL(c_szSourceEditColoring,  "Show Source Edit Color");
STR_GLOBAL(c_szDefConnPath,         "RemoteAccess");
STR_GLOBAL(c_szEnableAutoDialPath,  STR_REG_WIN_ROOT "\\Internet Settings");
STR_GLOBAL(c_RegKeyEnableAutoDial,  "EnableAutodial");
STR_GLOBAL(c_szRegCheckedAccounts,  "Accounts Checked");

STR_GLOBAL(c_szIncompleteMailAcct,  "Incomplete Mail");
STR_GLOBAL(c_szIncompleteNewsAcct,  "Incomplete News");
STR_GLOBAL(c_szEnableHTTPMail,      "HTTP Mail Enabled");

// IE Link Color
STR_GLOBAL(c_szIESettingsPath,      STR_REG_PATH_IE "\\Settings");
STR_GLOBAL(c_szLinkColorIE,         "Anchor Color");
STR_GLOBAL(c_szLinkVisitedColorIE,  "Anchor Color Visited");

// NS Link Color
STR_GLOBAL(c_szNSSettingsPath,      STR_REG_PATH_NS "\\Netscape Navigator\\Settings");
STR_GLOBAL(c_szLinkColorNS,         "Link Color");
STR_GLOBAL(c_szLinkVisitedColorNS,  "Followed Link Color");

// shared keys
STR_GLOBAL(c_szRasConnDetails,      "RAS Connection Details"); // OPT_RASCONNDETAILS
STR_GLOBAL(c_szRegIncludeMsg,       "Include Reply Msg"); // OPT_INCLUDEMSG, OPT_INCLUDEARTICLE
STR_GLOBAL(c_szOptnSaveInSentItems, "SaveInSentItems"); // OPT_SAVESENTITEMS, OPT_SAVESENTARTICLES
STR_GLOBAL(c_szRegShowHybrid,       "ShowHybridView");  // OPT_MAILHYBRIDVIEW, OPT_NEWSHYBRIDVIEW
STR_GLOBAL(c_szRegShowBtnBar,       "ShowButtonBar");   // OPT_MAILSHOWBTNBAR, OPT_NEWSSHOWBTNBAR
STR_GLOBAL(c_szRegNotePos,          "NotePos");         // OPT_MAILNOTEPOS, OPT_NEWSNOTEPOS
STR_GLOBAL(c_szRegNotePosEx,        "NotePosEx");       // OPT_MAILNOTEPOSEX
STR_GLOBAL(c_szRegSplitHorzPct,     "SplitHorzPct");    // OPT_MAILCYSPLIT, OPT_NEWSCYSPLIT
STR_GLOBAL(c_szRegSplitVertPct,     "SplitVertPct");    // OPT_MAILCXSPLIT, OPT_NEWSCXSPLIT
STR_GLOBAL(c_szRegSplitDir,         "SplitDir");        // OPT_MAILSPLITDIR, OPT_NEWSSPLITDIR
STR_GLOBAL(c_szShowFormatBar,       "ShowFormatBar");   // OPT_SHOWFMTBAR
STR_GLOBAL(c_szShowToolbar,         "ShowToolBar");     // OPT_SHOWTOOLBAR
STR_GLOBAL(c_szShowStatusbar,       "ShowStatusBar");   // OPT_SHOWSTATUSBAR
STR_GLOBAL(c_szAttachViewStyle,     "AttachViewStyle"); // OPT_ATTACH_VIEW_STYLE
STR_GLOBAL(c_szRegSigType,          "Signature Type");  // OPT_MAILSIGTYPE, OPT_NEWSSIGTYPE
STR_GLOBAL(c_szRegSigText,          "Signature Text");  // OPT_MAILSIGTEXT, OPT_NEWSSIGTEXT
STR_GLOBAL(c_szRegSigFile,          "Signature File");  // OPT_MAILSIGFILE, OPT_NEWSSIGFILE
STR_GLOBAL(c_szRegAttachVCard,      "Attach VCard");  // OPT_MAILSIGFILE, OPT_NEWSSIGFILE
STR_GLOBAL(c_szRegVCardName,        "VCard Display Name");  // OPT_MAILSIGFILE, OPT_NEWSSIGFILE
STR_GLOBAL(c_szRegSendInlineImages, "Send Pictures With Document"); //OPT_MAIL_SENDINLINEIMAGES, OPT_NEWS_SENDINLINEIMAGES
STR_GLOBAL(c_szRegCoolbarLayout,    "Layout");
STR_GLOBAL(c_szRegToolbar,          "Saved Toolbar Settings");        // changed from Tools to reset
STR_GLOBAL(c_szRegToolbarText,      "Toolbar Text");
STR_GLOBAL(c_szRegToolbarIconSize,   "Toolbar Icon Size");
STR_GLOBAL(c_szRegMailReadToolbar,  "Read Mail Toolbar Settings");
STR_GLOBAL(c_szRegMailSendToolbar,  "Send Mail Toolbar Settings");
STR_GLOBAL(c_szRegNewsReadToolbar,  "Read News Toolbar Settings");
STR_GLOBAL(c_szRegNewsSendToolbar,  "Read Mail Toolbar Settings");

STR_GLOBAL(c_szRegToolbarVersion,   "Saved Toolbar Settings Version");
STR_GLOBAL(c_szShowToolbarIEAK,     "ShowToolbarIEAK");     //Bug# 67503
STR_GLOBAL(c_szShowTree,            "Tree");     // changed from ShowTree to reset
STR_GLOBAL(c_szShowBodyBar,         "ShowBodyBar");
STR_GLOBAL(c_szBodyBarPos,          "BodyBarPos");
STR_GLOBAL(c_szRegExpungeFolder,    "ExpungeFolders");
STR_GLOBAL(c_szRegHideFolderBar,    "HideFolderBar");
STR_GLOBAL(c_szShowStatus,          "ShowStatus");
STR_GLOBAL(c_szTreeWidth,           "TreeWidth");
STR_GLOBAL(c_szBrowserPos,          "BrowserPos");
STR_GLOBAL(c_szRegSpoolerDlgPos,    "SpoolerDlgPos");   // OPT_SPOOLERDLGPOS
STR_GLOBAL(c_szRegSpoolerTack,      "SpoolerTack");     // OPT_SPOOLERTACK
STR_GLOBAL(c_szRegAutoImageInline,  "Automatically Inline Images");  // OPT_AUTO_IMAGE_INLINE
STR_GLOBAL(c_szRegReplyInOrigFmt,   "Reply To Messages In Original Format");
STR_GLOBAL(c_szRegFontColor,        "Font Color");
STR_GLOBAL(c_szRegFontFace,         "Font Name");
STR_GLOBAL(c_szRegFontSize,         "Font Size");
STR_GLOBAL(c_szRegFontUnderline,    "Font Underline");
STR_GLOBAL(c_szRegFontBold,         "Font Bold");
STR_GLOBAL(c_szRegFontItalic,       "Font Italic");
STR_GLOBAL(c_szRegUseStationery,    "Compose Use Stationery");
STR_GLOBAL(c_szRegStationeryName,   "Stationery Name");
STR_GLOBAL(c_szRegStationeryNameW,  "Wide Stationery Name");
STR_GLOBAL(c_szRegStatNameConverted,"Stationery Name Converted");
STR_GLOBAL(c_szRegIndentReply,      "Indent Reply Text");
STR_GLOBAL(c_szRegHardCodedHdrs,    "Use US Reply Headers");
STR_GLOBAL(c_szRegRtlMsgDir,        "Use RTL Direction");
STR_GLOBAL(c_szIncDefEncode,        "Encode incoming messages");
STR_GLOBAL(c_szRegDialDuringPoll,   "Dial During Poll");            // OPT_DIAL_DURING_POLL
STR_GLOBAL(c_szRegUseAutoComplete,  "Use AutoComplete");
STR_GLOBAL(c_szLastMsg,             "Preview Message");             // OPT_LAST_MESSAGE
STR_GLOBAL(c_szFindPos,             "FindPos");                     // OPT_FINDER_POS
STR_GLOBAL(c_szTestMode,            "TestMode");                    // OPT_TEST_MODE
STR_GLOBAL(c_szDumpFile,            "DumpFile");                    // OPT_DUMP_FILE
STR_GLOBAL(c_szNoSplash,            "NoSplash");                    // OPT_NO_SPLASH
STR_GLOBAL(c_szSigFlags,            "Signature Flags");             // OPT_SIGNATURE_FLAGS
STR_GLOBAL(c_szDefaultCodePage,     "Default_CodePage");
STR_GLOBAL(c_szDefaultEncoding,     "Default_InternetEncoding");
STR_GLOBAL(c_szNoPreview,           "No preview");                  //OPT_NOPREVIEW
STR_GLOBAL(c_szSaveAttachPath,      "Save Attachment Path");
STR_GLOBAL(c_szRegMsgListTips,      "Message List Tips");           // OPT_MESSAGE_LIST_TIPS
STR_GLOBAL(c_szRegSecReadPlainText, "Read in Plain Text only");    // OPT_READ_IN_TEXT_ONLY
STR_GLOBAL(c_szHideMessenger,       "Hide Messenger");
STR_GLOBAL(c_szRegAppSend,          "Warn on Mapi Send");           // OPT_SECURITY_MAPI_SEND
STR_GLOBAL(c_szRegAppSendLocked,    "Warn on Mapi Send Locked");           // OPT_SECURITY_MAPI_SEND_LOCKED
STR_GLOBAL(c_szRegSafeAttachments,  "Safe Attachments");            // OPT_SECURITY_ATTACHMENT
STR_GLOBAL(c_szRegSafeAttachmentsLocked, "Safe Attachments Locked");       // OPT_SECURITY_ATTACHMENT_LOCKED

// mail values
STR_GLOBAL(c_szOptNewMailSound,     "PlaySoundOnNewMail"); // OPT_NEWMAILSOUND
STR_GLOBAL(c_szPurgeWaste,          "Delete Wastebasket On Exit"); // OPT_PURGEWASTE
STR_GLOBAL(c_szRegPollForMail,      "Poll For Mail");   // OPT_POLLFORMAIL
STR_GLOBAL(c_szNeedWelcomeMsg,      "Welcome Message"); // OPT_NEEDWELCOMEMSG
STR_GLOBAL(c_szMailShowHeaderInfo,  "Show Header Info"); // OPT_MAILSHOWHEADERINFO
STR_GLOBAL(c_szRegMailEmptySubj,    "Mail Empty Subject Warning");
STR_GLOBAL(c_szRegNewsEmptySubj,    "News Empty Subject Warning");
STR_GLOBAL(c_szAutoAddToWABOnReply,  "Auto Add Replies To WAB");
STR_GLOBAL(c_szMigrationPerformed,  "Migration Done");
STR_GLOBAL(c_szDSDigSigHelp,        "Digital Signature Help");
STR_GLOBAL(c_szDSEncryptHelp,       "Encryption Help");
STR_GLOBAL(c_szOpaqueSigning,       "Opaque Signing");
STR_GLOBAL(c_szRevokeCheck,         "Revocation checking");
STR_GLOBAL(c_szShowDeleted,         "Show Deleted Messages");
STR_GLOBAL(c_szShowReplies,         "Show Replies To My Messages");
STR_GLOBAL(c_szAutoAddSendersCertToWAB, "Auto Add Senders Cert To WAB");
STR_GLOBAL(c_szViewSrcTabs,         "Show Source Editing");
STR_GLOBAL(c_szEncryptWarnBits,     "Encryption Warning Bits");      // OPT_MAIL_ENCRYPT_WARN_BITS
STR_GLOBAL(c_szSenderName,          "Sender Name");
STR_GLOBAL(c_szDefMailAccount,      "Default Mail Account");
STR_GLOBAL(c_szSMTPDispName,        "SMTP Display Name");

STR_GLOBAL(c_szDontEncryptForSelf,  "Dont Encrypt For Self");
STR_GLOBAL(c_szWindowTitle,         "WindowTitle");             // for branding
STR_GLOBAL(c_szWelcomeHtm,          "WelcomeHtmFile");          // for branding
STR_GLOBAL(c_szWelcomeName,         "WelcomeName");             // for branding
STR_GLOBAL(c_szWelcomeEmail,        "WelcomeEmail");            // for branding

// news values
STR_GLOBAL(c_szCacheDelMsgDays,     "Cache Delete Message Days"); // OPT_CACHEDELETEMSGS
STR_GLOBAL(c_szCacheRead,           "Cache Read Messages"); // OPT_CACHEREAD
STR_GLOBAL(c_szCacheCompactPer,     "Cache Compact Percent"); // OPT_CACHECOMPACTPER
STR_GLOBAL(c_szRegDownload,         "Download at a time"); // OPT_DOWNLOADCHUNKS
STR_GLOBAL(c_szRegAutoExpand,       "Auto Expand Threads"); // OPT_AUTOEXPAND
STR_GLOBAL(c_szRegNotifyNewGroups,  "New group notification"); // OPT_NOTIFYGROUPS
STR_GLOBAL(c_szRegMarkAllRead,      "Mark Read on Exit"); // OPT_MARKALLREAD
STR_GLOBAL(c_szRegViewFiltering,    "News Filter");
STR_GLOBAL(c_szRegLocalFilter,      "Mail Filter");
STR_GLOBAL(c_szRegFindFilter,       "Find Filter");
STR_GLOBAL(c_szRegIMAPFilter,       "IMAP Filter");
STR_GLOBAL(c_szRegThreadArticles,   "ThreadArticles");
STR_GLOBAL(c_szRegFindThread,       "FindThread");
STR_GLOBAL(c_szRegNewsDlgPos,       "News Dialog Position");
STR_GLOBAL(c_szRegNewsDlgColumns,   "News Dialog Columns");
STR_GLOBAL(c_szNewsShowHeaderInfo,  "Show Header Info"); // OPT_NEWSSHOWHEADERINFO
STR_GLOBAL(c_szRegNewsNoteAdvRead,  "Show Advanced Read");
STR_GLOBAL(c_szRegNewsNoteAdvSend,  "Show Advanced Send");
STR_GLOBAL(c_szRegMailNoteAdvRead,  "Show Adv Mail Read");
STR_GLOBAL(c_szRegMailNoteAdvSend,  "Show Adv Mail Send");
STR_GLOBAL(c_szRegNewsModerator,    "Moderator");
STR_GLOBAL(c_szRegNewsControlHeader,"Controller");
STR_GLOBAL(c_szRegNewsFillPreview,  "Auto Fill Preview");
STR_GLOBAL(c_szRegMailColsIn,       "Mail Column Info (In)");
STR_GLOBAL(c_szRegMailColsOut,      "Mail Column Info (Out)");
STR_GLOBAL(c_szRegNewsCols,         "News Column Info");
STR_GLOBAL(c_szRegFindPopCols,      "Find Pop Column Info");
STR_GLOBAL(c_szRegFindNewsCols,     "Find News Column Info");
STR_GLOBAL(c_szRegFolderNewsCols,   "Folder News Column Info");
STR_GLOBAL(c_szRegFolderMailCols,   "Folder Mail Column Info");
STR_GLOBAL(c_szRegIMAPCols,         "IMAP Column Info");
STR_GLOBAL(c_szRegIMAPColsOut,      "IMAP Column Info (Out)");
STR_GLOBAL(c_szRegAccountNewsCols,  "News Account Column Info");
STR_GLOBAL(c_szRegAccountIMAPCols,  "IMAP Account Column Info");
STR_GLOBAL(c_szRegLocalStoreCols,   "Local Store Column Info");
STR_GLOBAL(c_szRegNewsSubCols,      "News Sub Column Info");
STR_GLOBAL(c_szRegImapSubCols,      "IMAP Sub Column Info");
STR_GLOBAL(c_szRegOfflineCols,      "Offline Column Info");
STR_GLOBAL(c_szRegHTTPMailCols,     "HTTPMail Column Info");
STR_GLOBAL(c_szRegHTTPMailSubCols,  "HTTPMail Sub Column Info");
STR_GLOBAL(c_szRegHTTPMailAccountCols,"HTTPMail Account Column Info");
STR_GLOBAL(c_szRegHTTPMailColsOut,  "HTTPMail Column Info (Out)");
STR_GLOBAL(c_szQuoteChars,          ">|:");
STR_GLOBAL(c_szDSHtmlToPlain,       "Html to Plain Warning");
STR_GLOBAL(c_szDSSendMail,          "Send Mail Warning");
STR_GLOBAL(c_szDSSendNews,          "Send News Warning");
STR_GLOBAL(c_szDSReplyNews,         "Reply to News Warning");
STR_GLOBAL(c_szDSCancelNews,        "Cancel News Warning");
STR_GLOBAL(c_szDSHTMLNewsWarning,   "HTML News Warning");
STR_GLOBAL(c_szDSUseMailCertInNews, "Use Mail Cert In News");
STR_GLOBAL(c_szDSChangeNewsServer,  "Warn Change News Server");
STR_GLOBAL(c_szRegSendImmediate,    "Send Mail Immediately");
STR_GLOBAL(c_szRegAskSubscribe,     "Ask Subscribe");
STR_GLOBAL(c_szPosterKeyword,       "poster");
STR_GLOBAL(c_szRegManyMsgWarning,   "Open Messages Warning");
STR_GLOBAL(c_szRegDLDlgPos,         "Download Dialog Position");
STR_GLOBAL(c_szSpecFldrBase,        "special folders");
STR_GLOBAL(c_szDSPostInOutbox,      "Post in Outbox");
STR_GLOBAL(c_szDSSavedInSavedItems, "Saved in Saved Items");
STR_GLOBAL(c_szDSGroupFilters,      "Group Filters Warning");
STR_GLOBAL(c_szRegTooMuchQuoted,    "Too Much Quoted Warning");
STR_GLOBAL(c_szRegWarnDeleteThread, "Delete Thread Warning");
STR_GLOBAL(c_szRegUnsubscribe,      "Unsubscribe Warning");
STR_GLOBAL(c_szRegHide,             "Hide Warning");
STR_GLOBAL(c_szNoCheckDefault,      "No Check Default");
STR_GLOBAL(c_szOERunning,           "Running");
STR_GLOBAL(c_szRegGodMode,          "GodMode");
STR_GLOBAL(c_szDSABDelete,          "Address Book Delete Warning");
STR_GLOBAL(c_szRegFindHistory,      "Find History");
STR_GLOBAL(c_szRegOutlookBar,       "Outlook Bar Settings");
STR_GLOBAL(c_szRegOutlookBarNewsOnly, "Outlook Bar Settings News Only");
STR_GLOBAL(c_szRegShowOutlookBar,   "Show Outlook Bar");
STR_GLOBAL(c_szRegNavPaneWidth,     "Nav Pane Width");
STR_GLOBAL(c_szRegNavPaneSplit,     "Nav Pane Split");
STR_GLOBAL(c_szRegShowContacts,     "Show Contacts");
STR_GLOBAL(c_szRegCheckMailOnStart, "Check Mail on Startup");
STR_GLOBAL(c_szRegBackgroundCompact,"Background Compaction");
STR_GLOBAL(c_szRegFilterJunk,       "Filter Junk");
STR_GLOBAL(c_szRegFilterAdult,      "Filter Adult");
STR_GLOBAL(c_szRegJunkPct,          "Junk Percent");
STR_GLOBAL(c_szRegDeleteJunk,       "Delete Junk");
STR_GLOBAL(c_szRegDeleteJunkDays,   "Delete Junk Days");
STR_GLOBAL(c_szRegColumnHidden,     "Column Hidden Warning");
STR_GLOBAL(c_szBASort,              "Contact Pane Sorting");
STR_GLOBAL(c_szRegWatchedColor,     "Watched Message Color");
STR_GLOBAL(c_szExceptionsWAB,       "Check WAB for Exceptions");
STR_GLOBAL(c_szBLAutoLogon,         "Messenger Auto logon");
STR_GLOBAL(c_szRegSearchBodies,     "Search Message Bodies");
STR_GLOBAL(c_szRegSubjectThreading, "Subject Threading");
STR_GLOBAL(c_szRegGlobalView,       "Global View");

// Spelling values
// Non-localizable string constants, meant to be READ-ONLY
#ifdef WIN32
STR_GLOBAL(c_szRegSpellLangID,          "SpellLangID");
STR_GLOBAL(c_szRegSpellKeyDef,          "Spelling\\%s\\Normal");
STR_GLOBAL(c_szRegSpellKeyDefRoot,      "SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Spelling");
STR_GLOBAL(c_szRegSpellKeyCustom,       "Custom Dictionaries");
STR_GLOBAL(c_szRegSpellProfile,         "SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\");
STR_GLOBAL(c_szRegSpellPath,            "Engine");
STR_GLOBAL(c_szRegSpellPathLex,         "Dictionary");
STR_GLOBAL(c_szRegSpellPathDict,        "1");
STR_GLOBAL(c_szSpellOffice9ProofPath,   "Microsoft\\Proof\\");
STR_GLOBAL(c_szRegSharedTools,          "SOFTWARE\\Microsoft\\Shared Tools\\");
STR_GLOBAL(c_szRegSharedToolsPath,      "SharedFilesDir");
#else
STR_GLOBAL(c_szRegSpellKeyDef,      "Spelling %s,0");
STR_GLOBAL(c_szRegSpellKeyCustom,   "Custom Dict 1");
STR_GLOBAL(c_szRegSpellProfile,     "MS Proofing Tools");
#endif
STR_GLOBAL(c_szRegDefCustomDict,    "\\msapps\\proof\\custom.dic");
STR_GLOBAL(c_szRegDICHandlerKEY,    ".DIC");
STR_GLOBAL(c_szRegDICHandlerDefault,"txtfile");
STR_GLOBAL(c_szRegSecurityZone,     "Email Security Zone");
STR_GLOBAL(c_szRegSecurityZoneLocked, "Security Zone Locked");

// Coolbar Branding
STR_GLOBAL(c_szRegKeyCoolbar,       STR_REG_PATH_IE "\\Toolbar");
STR_GLOBAL(c_szRegKeyIEMain,        STR_REG_PATH_IE "\\Main");
STR_GLOBAL(c_szValueLargeBitmap,    "BigBitmap");
STR_GLOBAL(c_szValueSmallBitmap,    "SmallBitmap");
STR_GLOBAL(c_szValueBrandBitmap,    "BrandBitmap");
STR_GLOBAL(c_szValueBrandHeight,    "BrandHeight");
STR_GLOBAL(c_szValueBrandLeadIn,    "BrandLeadIn");
STR_GLOBAL(c_szValueSmBrandBitmap,  "SmBrandBitmap");
STR_GLOBAL(c_szValueSmBrandHeight,  "SmBrandHeight");
STR_GLOBAL(c_szValueSmBrandLeadIn,  "SmBrandLeadIn");
STR_GLOBAL(c_szValueBackBitmap,     "BackBitmap");
STR_GLOBAL(c_szValueBackBitmapIE5,  "BackBitmapIE5");

// ------------------------------------------------------
// ADM supported values
// ------------------------------------------------------
STR_GLOBAL(c_szBlockAttachments,    "BlockExeAttachments");

// ------------------------------------------------------
// Account Manager Registry Keys
// ------------------------------------------------------
STR_GLOBAL(c_szMigrated,                "Migrated");

// ------------------------------------------------------
// S/MIME things
// ------------------------------------------------------
STR_GLOBAL(c_szWABCertStore,    "AddressBook");
STR_GLOBAL(c_szCACertStore,     "CA");
STR_GLOBAL(c_szMyCertStore,     "My");

// ------------------------------------------------------
// Mail Consts (sbailey)
// ------------------------------------------------------
STR_GLOBAL(c_szSMTP,                     "SMTP");
STR_GLOBAL(c_szAccount,                  "Account");
STR_GLOBAL(c_szPop3LogFile,              "Log File (POP3)");
STR_GLOBAL(c_szSmtpLogFile,              "Log File (SMTP)");
STR_GLOBAL(c_szLogSmtp,                  "Log SMTP (0/1)");
STR_GLOBAL(c_szLogPop3,                  "Log POP3 (0/1)");
STR_GLOBAL(c_szLog,                      "Log");
STR_GLOBAL(c_szPop3Uidl,                 "pop3uidl");
STR_GLOBAL(c_szDefaultSmtpLog,           "Smtp.log");
STR_GLOBAL(c_szDefaultPop3Log,           "Pop3.log");
STR_GLOBAL_ANSI(c_szPrefixRE,            "Re: ");
STR_GLOBAL_ANSI(c_szPrefixFW,            "Fw: ");
STR_GLOBAL(c_szRegImap4LogFile,          "Log File (IMAP4)");
STR_GLOBAL(c_szRegLogImap4,              "Log IMAP4 (0/1)");
STR_GLOBAL(c_szDefaultImap4Log,          "Imap4.log");
STR_GLOBAL(c_szRegLogHTTPMail,           "Log HTTPMail (0/1)");
STR_GLOBAL(c_szRegHTTPMailLogFile,       "Log File (HTTPMAIL)");
STR_GLOBAL(c_szDefaultHTTPMailLog,       "HTTPMail.log");
STR_GLOBAL_WIDE(c_wszSMTP,               "SMTP");

// ------------------------------------------------------

// class names
// Important!!! Office 2000 HARDCODED some of these class names 
// for using with pluggable UI.
// Please, do not modify these names without 150% confidence.
STR_GLOBAL(c_szFolderWndClass,          "FolderWndClass");
STR_GLOBAL(c_szBlockingPaintsClass,     "Ath_PaintBlocker");
STR_GLOBAL(c_szFolderViewClass,         "FolderViewer");
STR_GLOBAL(c_szCacheNotifyWndClass,     "CacheNotifyWindow");
STR_GLOBAL(c_szBrowserWndClass,         "Outlook Express Browser Class");
STR_GLOBAL(c_szAccountViewWndClass,     "Outlook Express AcctView Class");
STR_GLOBAL(c_szIMAPSyncCFSMWndClass,    "Outlook Express IMAP CFSM Class");
STR_GLOBAL_WIDE(c_wszNoteWndClass,      "ATH_Note");
STR_GLOBAL_WIDE(c_wszMEDocHostWndClass, "ME_DocHost");
STR_GLOBAL_WIDE(c_wszDocHostWndClass,   "Ath_DocHost");

// new mail sound stuff
STR_GLOBAL(s_szMailSndKey,          "MailBeep");
STR_GLOBAL(s_szTimeGetTime,         "timeGetTime");

// file extensions
STR_GLOBAL(c_szSubFileExt,          ".sub");
STR_GLOBAL(c_szGrpFileExt,          ".dat");
STR_GLOBAL(c_szDbxExt,              ".dbx");
STR_GLOBAL(c_szMigrationExe,        "oemig50.exe");
STR_GLOBAL(c_szEmlExt,              ".eml");
STR_GLOBAL(c_szNwsExt,              ".nws");
STR_GLOBAL(c_szLogExt,              ".log");
STR_GLOBAL(c_szWabExt,              ".wab");
STR_GLOBAL(c_szWabBack1,            ".wa~");
STR_GLOBAL(c_szWabBack2,            ".w~b");

STR_GLOBAL_WIDE(c_wszEmlExt,        ".eml");
STR_GLOBAL_WIDE(c_wszNwsExt,        ".nws");

STR_GLOBAL(c_szExeExt,              ".exe");
STR_GLOBAL(c_szHtmExt,              ".htm");
STR_GLOBAL(c_szHtmlExt,             ".html");
STR_GLOBAL(c_szTxtExt,              ".txt");

// file names
STR_GLOBAL(c_szGrpFileName,         "grplist.dat");
STR_GLOBAL(c_szSubFileName,         "sublist.dat");
STR_GLOBAL(c_szNewsLogFile,         "inetnews.log");
STR_GLOBAL(c_szWabMigExe,           "wabmig.exe");
STR_GLOBAL(c_szInetcfgDll,          "inetcfg.dll");
STR_GLOBAL(c_szCheckConnWiz,        "CheckConnectionWizard");

// Help file names
STR_GLOBAL(c_szCtxHelpFile,         "msoe.hlp");
STR_GLOBAL(c_szCtxHelpFileHTML,     "%SYSTEMROOT%\\help\\msoe.chm>iedefault");
STR_GLOBAL(c_szCtxHelpFileHTMLCtx,  "%SYSTEMROOT%\\help\\msoe.chm>large_context");
STR_GLOBAL(c_szCtxHelpDefault,      "cool_mail.htm");
#define c_szMailHelpFile            c_szCtxHelpFile
#define c_szNewsHelpFile            c_szCtxHelpFile
#define c_szMailHelpFileHTML        c_szCtxHelpFileHTML
#define c_szNewsHelpFileHTML        c_szCtxHelpFileHTML

// formatting strings
STR_GLOBAL(c_szPathWildAllFmt,      "%s\\*.*");
STR_GLOBAL(c_szPathFileExtFmt,      "%s\\%s%s");
STR_GLOBAL(c_szStrNumFmt,           "%s (%d)");
STR_GLOBAL(c_szSpaceCatFmt,         "%s %s");
STR_GLOBAL_WIDE(c_wszNumberFmt,     "&%d %s");
STR_GLOBAL_WIDE(c_wszNumberFmt10,   "1&0 %s");
STR_GLOBAL_WIDE(c_wszPathWildExtFmt,"%s\\*%s");

STR_GLOBAL(c_szMailDir,             "Mail");
STR_GLOBAL(c_szNewsDir,             "News");
STR_GLOBAL(c_szImapDir,             "Imap");
STR_GLOBAL(c_szMailInitEvt,         "microsoft_thor_init_101469_mail");
STR_GLOBAL(c_szNotifyInfo,          "microsoft_thor_notifyinfo_");
STR_GLOBAL(c_szMailFolderNotify,    "microsoft_thor_folder_notifyinfo_");
STR_GLOBAL(c_szSharedFldInfo,       "microsoft_thor_shared_fld_info_");
STR_GLOBAL(c_szCacheFolderNotify,   "microsoft_thor_cache_notifyinfo_%s");
STR_GLOBAL(c_szStoreTempFilePrefix, "mbx");
STR_GLOBAL(c_szFolderDelNotify,     "microsoft_thor_folder_del");

// Needed for Simple MAPI support
STR_GLOBAL(c_szMAPI,                "MAPI");
STR_GLOBAL(c_szMailIni,             "Mail");
STR_GLOBAL(c_szMAPIDLL,             "MAPI32.DLL");
STR_GLOBAL(c_szMAPILogon,           "MAPILogon");
STR_GLOBAL(c_szMAPILogoff,          "MAPILogoff");
STR_GLOBAL(c_szMAPIFreeBuffer,      "MAPIFreeBuffer");
STR_GLOBAL(c_szMAPIResolveName,     "MAPIResolveName");
STR_GLOBAL(c_szMAPISendMail,        "MAPISendMail");

STR_GLOBAL(c_szImnimpDll,           "oeimport.dll");

STR_GLOBAL(c_szMAPIX,               "MAPIX");
STR_GLOBAL(c_szOne,                 "1");
STR_GLOBAL(c_szWinIni,              "WIN.INI");

// Needed for RAS support
// RAS DLL strings
STR_GLOBAL(szRasDll,                "RASAPI32.DLL");

//Needed for Mobility Pack support
STR_GLOBAL(szSensApiDll,           "SENSAPI.DLL");

//Needed for WinInet Apis
STR_GLOBAL(szWinInetDll,           "WININET.DLL");

STR_GLOBAL(c_szMAPIStub,            "mapistub.dll");

// RAS function strings
#ifdef UNICODE
STR_GLOBAL(szRasDial,               "RasDialW");
STR_GLOBAL(szRasEnumConnections,    "RasEnumConnectionsW");
STR_GLOBAL(szRasEnumEntries,        "RasEnumEntriesW");
STR_GLOBAL(szRasGetConnectStatus,   "RasGetConnectStatusW");
STR_GLOBAL(szRasGetErrorString,     "RasGetErrorStringW");
STR_GLOBAL(szRasHangup,             "RasHangUpW");
STR_GLOBAL(szRasSetEntryDialParams, "RasSetEntryDialParamsW");
STR_GLOBAL(szRasGetEntryDialParams, "RasGetEntryDialParamsW");
STR_GLOBAL(szRasGetEntryProperties, "RasGetEntryPropertiesW");
STR_GLOBAL(szRasEditPhonebookEntry, "RasEditPhonebookEntryW");
#else
STR_GLOBAL(szRasDial,               "RasDialA");
STR_GLOBAL(szRasEnumConnections,    "RasEnumConnectionsA");
STR_GLOBAL(szRasEnumEntries,        "RasEnumEntriesA");
STR_GLOBAL(szRasGetConnectStatus,   "RasGetConnectStatusA");
STR_GLOBAL(szRasGetErrorString,     "RasGetErrorStringA");
STR_GLOBAL(szRasHangup,             "RasHangUpA");
STR_GLOBAL(szRasSetEntryDialParams, "RasSetEntryDialParamsA");
STR_GLOBAL(szRasGetEntryDialParams, "RasGetEntryDialParamsA");
STR_GLOBAL(szRasGetEntryProperties, "RasGetEntryPropertiesA");
STR_GLOBAL(szRasEditPhonebookEntry, "RasEditPhonebookEntryA");
#endif

//Mobility Pack functions
#ifdef UNICODE
STR_GLOBAL(szIsDestinationReachable, "IsDestinationReachableW");
#else
STR_GLOBAL(szIsDestinationReachable, "IsDestinationReachableA");
#endif

STR_GLOBAL(szIsNetworkAlive, "IsNetworkAlive");

//WinInet Api strings
#ifdef UNICODE
STR_GLOBAL(szInternetGetConnectedStateEx, "InternetGetConnectedStateExW");
#else
STR_GLOBAL(szInternetGetConnectedStateEx, "InternetGetConnectedStateExA");
#endif

// -----------------------------------------------------
// V2 - New Options for messages and international stuff
// -----------------------------------------------------
STR_GLOBAL(c_szMsgSendHtml,         "Message Send HTML");
STR_GLOBAL(c_szMsgPlainMime,        "Message Plain Format MIME");
STR_GLOBAL(c_szMsgPlainEncoding,    "Message Plain Encoding Format");
STR_GLOBAL(c_szMsgHTMLEncoding,     "Message HTML Encoding Format");
STR_GLOBAL(c_szMsgPlainLineWrap,    "Message Plain Character Line Wrap");
STR_GLOBAL(c_szMsgHTMLLineWrap,     "Message HTML Character Line Wrap");
STR_GLOBAL(c_szMsgHTMLAllow8bit,    "Message HTML Allow 8bit in Header");
STR_GLOBAL(c_szMsgPlainAllow8bit,   "Message Plain Allow 8bit in Header");
STR_GLOBAL(c_szLangView,            "Language View");
STR_GLOBAL(c_szLangViewSetDefault,  "Language View Reset Default");

// -----------------------------------------------------
// V2 - international stuff ( charset map )
// -----------------------------------------------------
STR_GLOBAL(c_szCharsetMapPathOld,    STR_REG_PATH_EMAIL "\\CharsetMap");
STR_GLOBAL(c_szCharsetMapPath,       STR_REG_PATH_ROOT  "\\CharsetMap");  
STR_GLOBAL(c_szCharsetMapKey,        "Alternative");

// -----------------------------------------------------
// Tip of the day keys and options
// -----------------------------------------------------
STR_GLOBAL(c_szRegTipOfTheDay,      "Tip of the Day");

STR_GLOBAL(c_szInbox,               "Inbox");
STR_GLOBAL(c_szINBOX,               "INBOX");

// -----------------------------------------------------
// S/MIME UI screens
// -----------------------------------------------------
STR_GLOBAL(c_szDigSigHelpHTML,      "sighelp.htm");
STR_GLOBAL(c_szEncryptHelpHTML,     "enchelp.htm");
STR_GLOBAL(c_szSAndEHelpHTML,       "sandehlp.htm");

STR_GLOBAL(c_szMHTMLColon,          "mhtml:");
STR_GLOBAL(c_szMHTMLExt,            ".mhtml");
STR_GLOBAL(c_szFileUrl,             "file://");

STR_GLOBAL(c_szHTMLIDchkShowAgain,  "chkShowAgain");

// -----------------------------------------------------
// Command line switches
// -----------------------------------------------------
STR_GLOBAL_WIDE(c_wszSwitchMailURL,       "/mailurl:");
STR_GLOBAL_WIDE(c_wszSwitchNewsURL,       "/newsurl:");
STR_GLOBAL_WIDE(c_wszSwitchEml,           "/eml:");
STR_GLOBAL_WIDE(c_wszSwitchNws,           "/nws:");
STR_GLOBAL_WIDE(c_wszSwitchMail,          "/mail");
STR_GLOBAL_WIDE(c_wszSwitchDefClient,     "/defclient");
STR_GLOBAL_WIDE(c_wszSwitchNews,          "/news");
STR_GLOBAL_WIDE(c_wszSwitchNewsOnly,      "/newsonly");
STR_GLOBAL_WIDE(c_wszSwitchOutNews,       "/outnews");
STR_GLOBAL_WIDE(c_wszSwitchMailOnly,      "/mailonly");

STR_GLOBAL(c_szMailNewsDllOld,      "mailnews.dll");
STR_GLOBAL(c_szMsimnuiDll,          "msimnui.dll");
STR_GLOBAL(c_szMailNewsExe,         "msimn.exe");
STR_GLOBAL(c_szUrlDll,              "url.dll");
STR_GLOBAL(c_szMailNewsDll,         "MAILNEWS.DLL");
STR_GLOBAL(c_szMailNewsTxt,         "MAILNEWS.TXT");
STR_GLOBAL(c_szMailNewsInf,         "MAILNEWS.INF");
STR_GLOBAL(c_szMailNewsHlp,         "MAILNEWS.HLP");
STR_GLOBAL(c_szMailNewsCnt,         "MAILNEWS.CNT");
STR_GLOBAL(c_szImnImpDll,           "IMNIMP.DLL");
STR_GLOBAL(c_szUninstallKey,        STR_REG_WIN_ROOT "\\Uninstall\\InternetMailNews");
STR_GLOBAL(c_szNewWABKey,           STR_REG_WAB_FLAT "\\WAB4");
STR_GLOBAL(c_szFirstRunValue,       "FirstRun");

// --------------------------------------------------------------------------
// OE Resource DLL name
// --------------------------------------------------------------------------
STR_GLOBAL(c_szLangDll,             "MSOERES.DLL");
STR_GLOBAL(c_szInetcommDll,         "INETCOMM.DLL");
STR_GLOBAL(c_szMsoert2Dll,          "MSOERT2.DLL");
STR_GLOBAL(c_szMsoeAcctDll,         "MSOEACCT.DLL");

// --------------------------------------------------------------------------
// New Rules Stuff
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRules,               "Rules");
STR_GLOBAL(c_szRulesMailBeta2,      "Mail\\Rules");
STR_GLOBAL(c_szRulesMail,           "Rules\\Mail");
STR_GLOBAL(c_szRulesNews,           "Rules\\News");
STR_GLOBAL(c_szRulesFilter,         "Rules\\Filter");
STR_GLOBAL(c_szRulesSenders,        "Rules\\Block Senders");
STR_GLOBAL(c_szRulesJunkMail,       "Rules\\Junk Mail");
#define c_szRulesVersion            c_szValueVersion
STR_GLOBAL(c_szRulesOrder,          "Order");
STR_GLOBAL(c_szRuleName,            "Name");
STR_GLOBAL(c_szRuleEnabled,         "Enabled");
STR_GLOBAL(c_szRuleCriteria,        "Criteria");
STR_GLOBAL(c_szRuleActions,         "Actions");
STR_GLOBAL(c_szRuleMarkStart,       "%M");
STR_GLOBAL(c_szRuleMarkEnd,         "%m");
STR_GLOBAL_WIDE(c_wszRuleMarkStart, "%M");
STR_GLOBAL_WIDE(c_wszRuleMarkEnd,   "%m");
STR_GLOBAL(c_szCriteriaOrder,       "Order");
STR_GLOBAL(c_szCriteriaType,        "Type");
STR_GLOBAL(c_szCriteriaFlags,       "Flags");
STR_GLOBAL(c_szCriteriaValueType,   "ValueType");
STR_GLOBAL(c_szCriteriaValue,       "Value");
STR_GLOBAL(c_szCriteriaLogic,       "Logic");
STR_GLOBAL(c_szActionsOrder,        "Order");
STR_GLOBAL(c_szActionsValueType,    "ValueType");
STR_GLOBAL(c_szActionsFlags,        "Flags");
STR_GLOBAL(c_szActionsType,         "Type");
STR_GLOBAL(c_szActionsValue,        "Value");
STR_GLOBAL(c_szFolderIdChange,      "FolderIdChange"); 
STR_GLOBAL(c_szJunkDll,             "OEJUNK.DLL");
STR_GLOBAL(c_szHrCreateJunkFilter,  "HrCreateJunkFilter");
STR_GLOBAL(c_szJunkFile,            "JUNKMAIL.LKO");
STR_GLOBAL(c_szMRUList,             "MRU List");
STR_GLOBAL(c_szRulesFilterMRU,      "Rules\\Filter\\MRU List");

// --------------------------------------------------------------------------
// Exception List
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRulesExcpts,         "Exceptions");
#define c_szExcptVersion            c_szValueVersion
STR_GLOBAL(c_szExcptFlags,          "Flags");
STR_GLOBAL(c_szException,           "Exception");

// --------------------------------------------------------------------------
// Block Senders
// --------------------------------------------------------------------------
STR_GLOBAL(c_szSenders,             "Block Senders");
STR_GLOBAL(c_szSendersMail,         "Block Senders\\Mail");
STR_GLOBAL(c_szSendersNews,         "Block Senders\\News");
#define c_szSendersVersion          c_szValueVersion
STR_GLOBAL(c_szSendersValue,        "Value");
STR_GLOBAL(c_szSendersFlags,        "Flags");

// --------------------------------------------------------------------------
// Info Column
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegInfoColumn,       "Left Pane");
STR_GLOBAL(c_szRegICBand,           "Band %d");
STR_GLOBAL(c_szRegICBandID,         "ID");
STR_GLOBAL(c_szRegICBandSize,       "Size");
STR_GLOBAL(c_szRegICBandVisible,    "Visible");

//---------------------------------------------------------------------------
// Toolbar stuff
//---------------------------------------------------------------------------
STR_GLOBAL(c_szRegBrowserBands,      "Browser Bands");
STR_GLOBAL(c_szRegNoteBands,         "Note Bands");
STR_GLOBAL(c_szToolbarNotifications, "Toolbar Notifications");
STR_GLOBAL(c_szRegPrevToolbarText,   "PrevToolbarTextStyle");

//---------------------------------------------------------------------------
// HTML Error Pages
//---------------------------------------------------------------------------
STR_GLOBAL(c_szErrPage_NotDownloaded,   "notdown.htm");
STR_GLOBAL(c_szErrPage_Offline,         "msgoff.htm");
STR_GLOBAL(c_szErrPage_DiskFull,        "diskfull.htm");
STR_GLOBAL(c_szErrPage_GenFailure,      "genfail.htm");
STR_GLOBAL(c_szErrPage_MailBomb,        "mailbomb.htm");
STR_GLOBAL(c_szErrPage_Expired,         "expired.htm");
STR_GLOBAL(c_szErrPage_DownloadCanceled,"dlcancel.htm");
STR_GLOBAL(c_szErrPage_FldrFail,        "fldrfail.htm");
STR_GLOBAL(c_szErrPage_SMimeEncrypt,    "smime.htm");
STR_GLOBAL(c_szErrPage_SMimeLabel,      "denied.htm");

// --------------------------------------------------------------------------
// MultiUser
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegCU,               STR_REG_PATH_ROOT);
STR_GLOBAL(c_szUserDirPath,         "Application Data\\Microsoft\\Outlook Express\\User Data\\");
STR_GLOBAL(c_szUsername,            "Current Username");
STR_GLOBAL(c_szUserID,              "UserID");
STR_GLOBAL(c_szUsePassword,         "UsePassword");
STR_GLOBAL(c_szPassword,            "Password");
STR_GLOBAL(c_szTimestamp,           "Timestamp");
STR_GLOBAL(c_szShared,              "Shared");
STR_GLOBAL(c_szIAM,                 "\\Software\\Microsoft\\Internet Account Manager");
STR_GLOBAL(c_szCommon,              "Common");
STR_GLOBAL(c_szRegOE,               "Application Data");
STR_GLOBAL(c_szLastUserID,          "Last User ID");
STR_GLOBAL(c_szLastUserName,        "Last User Name");
STR_GLOBAL(c_szRegDefaultSettings,  STR_REG_PATH_ROOT "\\Default Settings");
STR_GLOBAL(c_szRegForcefulSettings, STR_REG_PATH_ROOT "\\Required Settings");
STR_GLOBAL(c_szRegPreConfigAccts,   STR_REG_IAM_FLAT "\\Preconfigured");
STR_GLOBAL(c_szRegDefaultAccts,     STR_REG_IAM_FLAT "\\Default");
STR_GLOBAL(c_szOEVerStamp,          "VerStamp");

// --------------------------------------------------------------------------
// HTTPMail
// --------------------------------------------------------------------------
// Tokens and strings used to build the OE HTTP user agent

STR_GLOBAL(c_szCompatible,          "compatible");
STR_GLOBAL(c_szEndUATokens,         "TmstmpExt)");
STR_GLOBAL(c_szOEUserAgent,         "Outlook-Express/6.0 (");
STR_GLOBAL(c_szBeginUATokens,       "");

STR_GLOBAL(c_szAcceptTypeRfc822,    "message/rfc822");
STR_GLOBAL(c_szAcceptTypeWildcard,  "*/*");

STR_GLOBAL(c_szTrue,                "true");
// Setup
STR_GLOBAL(c_szRegWABVerInfo,       STR_REG_WAB_FLAT  "\\Version Info");
STR_GLOBAL(c_szRegCurrVer,          "Current");
STR_GLOBAL(c_szRegInterimVer,       "Interim");
STR_GLOBAL(c_szRegPrevVer,          "Previous");

// Connection settings Migration
STR_GLOBAL(c_szIAMAccounts,          "Software\\Microsoft\\Internet Account Manager\\Accounts");
STR_GLOBAL(c_szConnectionType,       "Connection Type");
STR_GLOBAL(c_szConnSettingsMigrated, "ConnectionSettingsMigrated");

//Reg keys for Return Receipts
STR_GLOBAL(c_szRequestMDN,                      "RequestMDN");
STR_GLOBAL(c_szRequestMDNLocked,                "RequestMDNLocked");

STR_GLOBAL(c_szSendMDN,                         "SendMDN");
STR_GLOBAL(c_szSendMDNLocked,                   "SendMDNLocked");

STR_GLOBAL(c_szSendReceiptToList,               "SendReceiptToList");
STR_GLOBAL(c_szSendReceiptToListLocked,         "SendReceiptToListLocked");

//Strings for receipts

STR_GLOBAL(c_szMultiPartReport,                 "multipart/report");
STR_GLOBAL(c_szMessageDispNotification,         "message/disposition-notification");
STR_GLOBAL(c_szDispositionNotification,         "disposition-notification");

//Secure Return Receipts
STR_GLOBAL(c_szSecureRequestMDN,                "SecureRequestMDN");

//Strings for hardcoded english headers
STR_GLOBAL_WIDE(c_wszRe,                        "Re: ");
STR_GLOBAL_WIDE(c_wszFwd,                       "Fw: ");

#endif // _STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\wabp.h ===
#include <wab.h>

// A special little Opie hack
#define MAPI_REPLYTO  1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\inc\workoff.h ===
#ifndef      __WORKOFF_H
#define     __WORKOFF_H

#define     IDWorkOffline   100
#define     IDTryAgain      101

#define     IDHangup        105
#define     IDNoHangup      106
#endif //__WORKOFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\adbar.cpp ===
/*
 *    a d b a r. c p p
 *    
 *    Purpose:
 *        Implementation of CAdBar object. Derives from CBody to host the trident
 *        control.
 *
 *  History
 *      May '99: shaheedp - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997, 1998, 1999.
 */

#include <pch.hxx>
#include <wininet.h> // INTERNET_MAX_URL_LENGTH
#include <resource.h>
#include "strconst.h"
#include "xpcomm.h"
#include "adbar.h"
#include "goptions.h"
#include <inpobj.h>


static const TCHAR s_szAdBarWndClass[] = TEXT("ThorAdBarWndClass");

CAdBar::CAdBar()
{
    m_ptbSite = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_cSize = 65;
    m_dwAdBarPos = 0;
    m_pszUrl = NULL;
    m_fFirstPos = TRUE;
    m_fDragging = FALSE;
    m_cRef      = 1;
    m_pMehost   = NULL;
}

CAdBar::~CAdBar()
{
    if (m_ptbSite)
        m_ptbSite->Release();
    
    MemFree(m_pszUrl);
    if(m_pMehost)
        delete m_pMehost;
}

HRESULT CAdBar::HrInit(BSTR     bstr)
{
    HRESULT     hr = S_OK;

    IF_FAILEXIT(hr = HrBSTRToLPSZ(CP_ACP, bstr, &m_pszUrl));

exit:    
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    HRESULT     hr = S_OK;

    if(!lplpObj)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IDockingWindow))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IInputObject))
    {
        *lplpObj = (IInputObject *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *lplpObj = (IObjectWithSite *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else
    {
        if (m_pMehost)
        {
            hr = m_pMehost->QueryInterface(riid, lplpObj);
        }
        else
        {
            hr = E_FAIL;
        }

    }
exit:
    return hr;
}

ULONG CAdBar::AddRef()
{
    return (++m_cRef);
}

ULONG CAdBar::Release()
{
    ULONG      ulRet = 0;

    --m_cRef;
    ulRet = m_cRef;

    if (m_cRef == 0)
    {
        delete this;
    }

    return ulRet;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::GetWindow(HWND *phwnd)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->GetWindow(phwnd);

    return hr;

}

HRESULT CAdBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->ContextSensitiveHelp(fEnterMode);

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IDockingWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::ShowDW(BOOL fShow)
{

    // Make sure we have a site pointer first
    if (!m_ptbSite)
        {
        AssertSz(0, _T("CAdBar::ShowDW() - Can't show without calling SetSite() first."));
        return E_FAIL; 
        }

    if (m_hwnd==NULL && fShow==FALSE)   // noop
        return S_OK;

    if (!m_hwnd)
        {
        WNDCLASSEX  wc;
    
        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, s_szAdBarWndClass, &wc))
            {
            // We need to register the class
            wc.style            = 0;
            wc.lpfnWndProc      = CAdBar::ExtAdBarWndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            // If AdBar is nor resizable then show standard cursor
            wc.hCursor          = LoadCursor(NULL, IDC_ARROW);

            wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = s_szAdBarWndClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;
            
            if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
                return E_FAIL;
            }
        
        // Get the handle of the parent window
        if (FAILED(m_ptbSite->GetWindow(&m_hwndParent)))
            return E_FAIL;

        // Create the window
        m_hwnd = CreateWindowEx(0,
                                s_szAdBarWndClass,
                                NULL,
                                WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,
                                0,
                                0,
                                0,
                                0,
                                m_hwndParent,
                                NULL,
                                g_hInst,
                                (LPVOID)this);
        if (!m_hwnd)
            {
            AssertSz(0, _T("CAdBar::ShowDW() - Failed to create window."));
            return E_FAIL;
            }           
        }
    
    // Show or hide the window and resize the parent windows accordingly
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    ResizeBorderDW(NULL, NULL, FALSE);
    m_fFirstPos = (fShow ? m_fFirstPos : TRUE);
        
    return S_OK;
}

HRESULT CAdBar::CloseDW(DWORD dwReserved)
{
    if (m_pMehost)
    {
        m_pMehost->HrUnloadAll(NULL, 0);
        m_pMehost->HrClose();
    }
    return S_OK;
}

HRESULT CAdBar::ResizeBorderDW(LPCRECT prcBorder, IUnknown *punkToolbarSite, BOOL fReserved)
{
    RECT rcRequest = { 0, 0, 0, 0 };
    
    if (!m_ptbSite)
    {
        AssertSz(0, _T("CAdBar::ResizeBorderDW() - Can't resize without calling SetSite() first."));
        return E_FAIL; 
    }

    if (IsWindow(m_hwnd) && IsWindowVisible(m_hwnd))
    {
        RECT rcBorder;
        int cTop, cBottom;

        // Calculate position of AdBar window
        cBottom = GetAdBar_Bottom();

        if (!prcBorder)
        {
            // Find out how big our parent's border space is
            m_ptbSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
            prcBorder = &rcBorder;
        }

        if(!m_fFirstPos || (cBottom <= 0))
        {
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
            cBottom = rcRequest.bottom;

        }
        else
        {
            m_cSize = cBottom;    // set new value for m_cSize.
            cBottom  += GetSystemMetrics(SM_CYFRAME);
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
        }                                                                                                                                               


       SetWindowPos(m_hwnd, NULL, prcBorder->left, cTop,  
                     prcBorder->right - prcBorder->left, cBottom, 
                     SWP_NOACTIVATE|SWP_NOZORDER);

        m_fFirstPos = FALSE;            // AdBar window positioned

        // Set new value for AdBarPos
        m_dwAdBarPos = (DWORD) MAKELONG(cBottom - GetSystemMetrics(SM_CYFRAME), 0);
    }

    m_ptbSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);     
        
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObject
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrUIActivate(fActivate);

    return hr;
}

HRESULT CAdBar::HasFocusIO(void)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrHasFocus();

    return hr;
}    
        

HRESULT CAdBar::TranslateAcceleratorIO(LPMSG pMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrTranslateAccelerator(pMsg);

    return hr;
}    

////////////////////////////////////////////////////////////////////////
//
//  IObjectWithSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::SetSite(IUnknown* punkSite)
{
    // If we already have a site pointer, release it now
    if (m_ptbSite)
        {
        m_ptbSite->Release();
        m_ptbSite = NULL;
        }
    
    // If the caller provided a new site interface, get the IDockingWindowSite
    // and keep a pointer to it.
    if (punkSite)    
        {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, (void **)&m_ptbSite)))
            return E_FAIL;
        }
    
    return S_OK;    
}

HRESULT CAdBar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleInPlaceSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CAdBar::OnUIActivate()
{
    HRESULT     hr = E_FAIL;

    if (m_ptbSite)
        UnkOnFocusChangeIS(m_ptbSite, (IInputObject*)this, TRUE);

    if (m_pMehost)
        hr = m_pMehost->OnUIActivate();

    return hr;
}

HRESULT CAdBar::GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget)
{
    return (E_FAIL);
}

/////////////////////////////////////////////////////////////////////////////
//
// private routines
//
/////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CAdBar::ExtAdBarWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CAdBar *pbb;

    if (msg == WM_NCCREATE)
    {
        pbb = (CAdBar *)LPCREATESTRUCT(lp)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pbb);
    }
    else
    {
        pbb = (CAdBar *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    Assert(pbb);
    return pbb->AdBarWndProc(hwnd, msg, wp, lp);
}

LRESULT CAdBar::AdBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);

        case WM_NCDESTROY:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            m_hwnd = NULL;
            break;

        case WM_SETFOCUS:
        {
            HWND hwndBody;

            if (m_pMehost && SUCCEEDED(m_pMehost->HrGetWindow(&hwndBody)) && hwndBody && ((HWND)wParam) != hwndBody)
                SetFocus(hwndBody);
        }
            return 0;    
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL CAdBar::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    BOOL        fRet = FALSE;

    if (!m_pMehost)
        m_pMehost = new CMimeEditDocHost;

    if (!m_pMehost)
        goto exit;

    if (FAILED(m_pMehost->HrInit(hwnd, 0, NULL)))
        goto exit;

    // We don't care if this fails.
//    TraceResult(m_pMehost->HrEnableScrollBars(FALSE));

    if (FAILED(m_pMehost->HrShow(TRUE)))
        goto exit;

    if (m_pszUrl)
        m_pMehost->HrLoadURL(m_pszUrl);

    fRet = TRUE;

exit:
    return fRet;
}

void CAdBar::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rc;
    
    int  cyFrame = GetSystemMetrics(SM_CYFRAME);

    rc.left = 0;
    rc.top = cyFrame;
    rc.right = cxClient;
    rc.bottom = cyClient;

    if (m_pMehost)
        m_pMehost->HrSetSize(&rc);
}

HRESULT CAdBar::SetUrl(LPSTR pszUrl)
{
    HRESULT     hr            = S_OK;
    LPSTR       pszUrlBackup  = m_pszUrl;

    if (pszUrl && *pszUrl)
    {
        IF_NULLEXIT(m_pszUrl = PszDupA(pszUrl));

        if (m_pMehost)
            IF_FAILEXIT(hr = m_pMehost->HrLoadURL(m_pszUrl));
    }
    else
        hr = E_INVALIDARG;

exit:
    if (FAILED(hr))
    {
        m_pszUrl = pszUrlBackup;
    }
    else
    {
        MemFree(pszUrlBackup);
    }
    return hr;

}

BOOL CAdBar::fValidUrl()
{
    BOOL    fRet = FALSE;

    if (m_pszUrl && *m_pszUrl)
        fRet = TRUE;

    return fRet;
}

HRESULT HrProcessAdTokens(LPSTR    pszAdInfo, LPCSTR    pszToken,
                          LPSTR    pszretval, DWORD    cch,
                          DWORD    *pcchCount)
{
    LPSTR       lpSubString  = NULL;
    LPSTR       lpSubString1 = NULL;
    HRESULT     hr           = S_OK;
    DWORD       dwCount      = 0;

    *pszretval = 0;

    lpSubString = StrStr(pszAdInfo, pszToken);

    if (!lpSubString)
        IF_FAILEXIT(hr = E_FAIL);

    lpSubString = StrChr(lpSubString, '=');
    
    if (!lpSubString)
        IF_FAILEXIT(hr = E_FAIL);

    //Skip the equal sign
    ++lpSubString;

    SkipWhitespace(lpSubString, &dwCount);

    lpSubString += dwCount;

    lpSubString1 = lpSubString;

    lpSubString = StrChr(lpSubString, '*');
    if (!lpSubString)
    {

        //If we cannot find a * in it, we assume that this is the last token
        //and copy the entire field in it.
        lpSubString = lpSubString1 + strlen(lpSubString1) + 1;
    }

    if (((DWORD)(lpSubString - lpSubString1 + 1)) > cch)
    {
        IF_FAILEXIT(hr = E_FAIL);
    }

    *pcchCount = 0;
    while(lpSubString1 < lpSubString)
    {
        *pszretval++ = *lpSubString1++;
        (*pcchCount)++;
    }

    *pszretval = '\0';

    (*pcchCount)++; //To account for null

exit:
    return hr;

}

HRESULT HrEscapeOtherAdToken(LPSTR pszAdOther, LPSTR pszEncodedString, DWORD cch, DWORD *cchRetCount)
{
    CHAR     tempchar;
    DWORD    dwTempCount = 1; //Initializing with a null
    LPCSTR   pszTemp = pszAdOther;
    HRESULT  hr = S_OK;

    *cchRetCount = 0;

    while (tempchar = *pszTemp)
    {
        if ((tempchar == '=') || (tempchar == ' ') || (tempchar == '&'))
            dwTempCount += 3;
        else
            dwTempCount++;

        pszTemp++;
    }

    if (dwTempCount > cch)
    {
        IF_FAILEXIT(hr = E_FAIL);
    }

    //We have enough space
    while (tempchar = *pszAdOther)
    {
        if ((tempchar == '=') || (tempchar == '&') || (tempchar == ' '))
        {
            if (tempchar == '=')
            {
                pszTemp = c_szEqualSign;
            }
            else if (tempchar == '&')
            {
                pszTemp = c_szAmpersandSign;
            }
            else if (tempchar == ' ')
            {
                pszTemp = c_szSpaceSign;
            }
            StrCpyN(pszEncodedString, pszTemp, cch);
            pszEncodedString += 3;
        }
        else
        {
            *pszEncodedString++ = tempchar;
        }
        pszAdOther++;
    }

    *cchRetCount = dwTempCount;
    *pszEncodedString = 0;

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\addrobj.cpp ===
/*
 *  a d d r o b j . h
 *
 *
 *   Purpose:
 *      implements an Address object. An ole object representation for
 *      a resolved email address. Wraps a CAddress object
 *      also implements an IDataObj for drag-drop
 *
 *  Copyright (C) Microsoft Corp. 1993, 1994.
 *
 *  Owner: brettm
 *
 */

#include <pch.hxx>
#include <resource.h>
#include <addrobj.h>
#include <ourguid.h>    //addr object guid
#include <dragdrop.h>
#include <menuutil.h>
#include <wells.h>
#include <ipab.h>
#include <fonts.h>
#include <oleutil.h>
#include "menures.h"
#include "header.h"
#include "shlwapip.h"
#include "demand.h"

ASSERTDATA

/*
 * c o n s t a n t s
 */
enum
{
    iverbProperties=0,      //OLEIVERB_PRIMARY
    iverbAddToWAB=1,
    iverbFind=2,
    iverbBlockSender=3,
    iverbMax
};

#define CF_ADDROBJ              "Outlook Express Recipients"

/*
 * t y p e d e f s
 */

/*
 * m a c r o s
 */


/*
 * g l o b a l   d a t a 
 */

#pragma BEGIN_CODESPACE_DATA
static char szClipFormatAddrObj[] = CF_ADDROBJ;
#pragma END_CODESPACE_DATA

static FORMATETC rgformatetcADDROBJ[] =
{
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
};

enum 
{
    iFormatAddrObj=0, 
    iFormatText,
    iFormatUnicode,
    cformatetcADDROBJ
};

static BOOL     g_fInited=FALSE;


/*
 * p r o t o t y p e s
 */

HRESULT HrBuildSelectionWabal(HWND hwndRE, CHARRANGE *pchrg, LPWABAL *lplpWabal);
HRESULT HrBuildOneSelWabal(LPADRINFO lpAdrInfo, LPWABAL *lplpWabal);


/*
 * f u n c t i o n s
 */
BOOL FInitAddrObj(BOOL fInit)
{
    if(fInit&&g_fInited)
        return TRUE;

    if(!fInit)
    {
        //de-init stuff
        return TRUE;
    }

    // Register our clipboard formats
    rgformatetcADDROBJ[iFormatAddrObj].cfFormat =
                    (CLIPFORMAT) RegisterClipboardFormat(szClipFormatAddrObj);
    rgformatetcADDROBJ[iFormatText].cfFormat = CF_TEXT;
    rgformatetcADDROBJ[iFormatUnicode].cfFormat = CF_UNICODETEXT;
    
    return g_fInited=TRUE;
}




HRESULT CAddrObj::QueryInterface(REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = (void*)this;
    else if (IsEqualIID(riid, IID_IOleObject))
        *ppvObject = (void*)(IOleObject*)this;
    else if (IsEqualIID(riid, IID_IViewObject))
        *ppvObject = (void*)(IViewObject*)this;
    else if (IsEqualIID(riid, IID_IPersist))
        *ppvObject = (void*)(IPersist*)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObject = (void *)(IOleCommandTarget *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CAddrObj::AddRef(void)
{
    return ++m_cRef;
}

ULONG CAddrObj::Release(void)
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// IOleObject methods:
HRESULT CAddrObj::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    CAddrWellCB             *pawcb=0;
    IRichEditOleCallback    *prole=0;
    IOleInPlaceSite         *pIPS;
    
    m_hwndEdit = NULL;    
    ReleaseObj(m_lpoleclientsite);
    m_lpoleclientsite=0;

    if (!pClientSite)
        return NOERROR;

    // we do this so when we d-d between notes, read/send etc. the triple inherits the
    // properies of it's callbacks pab and underlining.
    if(!pClientSite->QueryInterface(IID_IRichEditOleCallback, (LPVOID *)&prole))
    {
        pawcb=(CAddrWellCB *)prole;
        m_fUnderline=pawcb->m_fUnderline;
        ReleaseObj(prole);
    }
    
    if(!pClientSite->QueryInterface(IID_IOleInPlaceSite, (LPVOID *)&pIPS))
    {
        pIPS->GetWindow(&m_hwndEdit);
        pIPS->Release();
    }

    pClientSite->AddRef();
    m_lpoleclientsite = pClientSite;
    return NOERROR;

}

HRESULT CAddrObj::GetClientSite(LPOLECLIENTSITE * ppClientSite)
{
    *ppClientSite = m_lpoleclientsite;
    if(m_lpoleclientsite)
        m_lpoleclientsite->AddRef();
    return NOERROR;
}

HRESULT CAddrObj::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    return NOERROR;
}

HRESULT CAddrObj::Close(DWORD dwSaveOption)
{
    return NOERROR;
}

HRESULT CAddrObj::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::GetClipboardData(DWORD dwReserved, LPDATAOBJECT * ppDataObject)
{
    HRESULT         hr;
    CAddrObjData    *pAddrObjData=0;
    LPWABAL         lpWabal=0;

    Assert(m_lpAdrInfo);

    hr=HrBuildOneSelWabal(m_lpAdrInfo, &lpWabal);
    if(FAILED(hr))
        goto cleanup;

    if(!(pAddrObjData = new CAddrObjData(lpWabal)))
    {
        hr=E_OUTOFMEMORY;
        goto cleanup;
    }

    hr=pAddrObjData->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

cleanup:
    ReleaseObj(lpWabal);
    ReleaseObj(pAddrObjData);
    return hr;
}


HRESULT CAddrObj::DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT         hr=0;
    HWND            hwndUI=GetParent(hwndParent);
    LPWAB           lpWab=0;
    int             idsErr=0;

    Assert(m_lpAdrInfo);

    hr=HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;

    switch(iVerb)
    {
        case iverbBlockSender:
            // hack. send the wm_command to the note to avoid dupe-code, also the note knows
            // if it's news or mail so the correct block sender verb can be applied
            SendMessage(GetTopMostParent(hwndUI), WM_COMMAND, MAKELONG(ID_BLOCK_SENDER, 0), 0);
            break;

        case iverbProperties:
            hr=lpWab->HrDetails(hwndUI, &m_lpAdrInfo);
            if(FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
                idsErr=idsErrAddrProps;
 
            m_padvisesink->OnViewChange(DVASPECT_CONTENT, -1);
            break;

        case iverbAddToWAB:
            if (m_lpAdrInfo->fDistList)
            {
                // $bug: 12298. don't try and add dist-lists
                idsErr=idsErrAddrDupe;
                hr = MAPI_E_COLLISION;
            }
            else
            {
                hr=lpWab->HrAddToWAB(hwndUI, m_lpAdrInfo);
                if(FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
                {
                    if(hr==MAPI_E_COLLISION)
                        idsErr=idsErrAddrDupe;
                    else
                        idsErr=idsErrAddToWAB;
                }
            }
            break;

        case iverbFind:
            hr = lpWab->HrFind(hwndUI, m_lpAdrInfo->lpwszAddress);
            if(FAILED(hr))
                idsErr = idsErrFindWAB;
            break;


        default:
            hr=OLEOBJ_S_INVALIDVERB;
            break;
    }

    if(idsErr)
        AthMessageBoxW(hwndUI, MAKEINTRESOURCEW(idsAthenaMail), 
            MAKEINTRESOURCEW(idsErr), NULL, MB_OK);

error:
    ReleaseObj(lpWab);
    return hr;

}

HRESULT CAddrObj::EnumVerbs(LPENUMOLEVERB * ppEnumOleVerb)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::Update()
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::IsUpToDate()
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::GetUserClassID(CLSID * pClsid)
{
    *pClsid = CLSID_AddrObject;
    return NOERROR;
}


HRESULT CAddrObj::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    WCHAR szWT[CCHMAX_STRINGRES];
    
    if (AthLoadStringW((dwFormOfType == USERCLASSTYPE_APPNAME ? idsAthena : idsRecipient),szWT, CCHMAX_STRINGRES))
    {
        *pszUserType = PszDupW(szWT);
    }
    else
    {
        *pszUserType = NULL;
    }

    return(NOERROR);
}

HRESULT CAddrObj::SetExtent(DWORD dwDrawAspect, LPSIZEL psizel)
{
    // The object's size is fixed
    return E_FAIL;
}

HFONT CAddrObj::_GetFont()
{
    HFONT           hFont=NULL;
    
    // try and get the message-font from the header, if this fails, fall back to the normal font
    if (m_hwndEdit)
        hFont = (HFONT)SendMessage(GetParent(m_hwndEdit), WM_HEADER_GETFONT, m_lpAdrInfo->fDistList, 0);
    
    if (!hFont)
        hFont = HGetSystemFont(m_lpAdrInfo->fDistList?FNT_SYS_ICON_BOLD:FNT_SYS_ICON);
    
    return hFont;
}

HRESULT CAddrObj::OnFontChange()
{
    IAdviseSink     *pAS;

    if (m_lpoleclientsite &&
        m_lpoleclientsite->QueryInterface(IID_IAdviseSink, (LPVOID *)&pAS)==S_OK)
    {
        pAS->OnViewChange(DVASPECT_CONTENT, -1);
        pAS->Release();
    }
    return S_OK;
}

 

HRESULT CAddrObj::GetExtent(DWORD dwDrawAspect, LPSIZEL psizel)
{
    HFONT           hfontOld=NULL;
    HDC             hdc;
    TEXTMETRIC      tm;
    LPWSTR          pwszName;
    SIZE            size;
    SIZEL           sizel;
    DWORD           cch, i;
    int             cx = 0, chcx;

    if (m_hwndEdit)
        hdc = GetWindowDC(m_hwndEdit);
    else
        hdc = GetWindowDC(NULL);

    if(!hdc)
        return E_OUTOFMEMORY;
            
    Assert(m_lpAdrInfo);

    hfontOld = SelectFont(hdc, _GetFont());

    pwszName = m_lpAdrInfo->lpwszDisplay;
    Assert(pwszName);

    GetTextExtentPoint32AthW(hdc, pwszName, lstrlenW(pwszName), &size, DT_NOPREFIX);    
    GetTextMetrics(hdc, &tm);

    sizel.cx = size.cx;
#ifndef DBCS
    sizel.cy = size.cy - tm.tmDescent;      // Same height as normal line (RAID11516 was +1)
#else
    sizel.cy = tm.tmAscent + 2;
#endif
    XformSizeInPixelsToHimetric(hdc, &sizel, psizel);

    if (hfontOld)
        SelectFont(hdc, hfontOld);

    if (m_hwndEdit)
        ReleaseDC(m_hwndEdit, hdc);
    else
        ReleaseDC(NULL, hdc);

    return NOERROR;
}

HRESULT CAddrObj::Advise (LPADVISESINK pAdvSink, DWORD * pdwConnection)
{
    if (m_poleadviseholder)
        return m_poleadviseholder->Advise(pAdvSink, pdwConnection);
    else
        return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CAddrObj::Unadvise(DWORD dwConnection)
{
    if (m_poleadviseholder)
        return m_poleadviseholder->Unadvise(dwConnection);
    else
        return E_FAIL;
}

HRESULT CAddrObj::EnumAdvise(LPENUMSTATDATA * ppenumAdvise)
{
    if(m_poleadviseholder)
        return m_poleadviseholder->EnumAdvise(ppenumAdvise);
    else
        return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CAddrObj::GetMiscStatus(DWORD dwAspect, DWORD * pdwStatus)
{
    *pdwStatus = 0;
    return NOERROR;
}

HRESULT CAddrObj::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    return E_NOTIMPL;
}


HRESULT CAddrObj::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    if (pguidCmdGroup == NULL)
        return OLECMDERR_E_UNKNOWNGROUP;

    if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        for (ULONG ul = 0; ul < cCmds; ul++)
        {
            rgCmds[ul].cmdf = 0;
            switch (rgCmds[ul].cmdID)
            {
                case ID_ADDROBJ_OLE_BLOCK_SENDER:
                    rgCmds[ul].cmdf = (m_lpAdrInfo->lRecipType == MAPI_ORIG) ? OLECMDF_ENABLED|OLECMDF_SUPPORTED : 0;
                    break;                    

                case ID_ADDROBJ_OLE_PROPERTIES:
                    rgCmds[ul].cmdf = OLECMDF_ENABLED|OLECMDF_SUPPORTED;
                    break;

                case ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK:
                case ID_ADDROBJ_OLE_FIND:
                    rgCmds[ul].cmdf = OLECMDF_SUPPORTED;
                    if (m_lpAdrInfo->lpwszAddress)
                        rgCmds[ul].cmdf |= OLECMDF_ENABLED;
                    break;
            }
        }                
        return S_OK;
    }
    else
        return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CAddrObj::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,   VARIANTARG *pvaOut)
{
    // we should use DoVerb for this
    return E_NOTIMPL;
}



// IViewObject methods:
HRESULT CAddrObj::Draw(DWORD dwDrawAspect, LONG lindex, void * pvAspect, 
                                DVTARGETDEVICE * ptd, HDC hicTargetDev, HDC hdcDraw, 
                                LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                                BOOL (CALLBACK * pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue)
{
    HFONT           hfontOld=NULL;
    RECT            rect;
    LPWSTR          pwszName;
    TEXTMETRIC      tm;
    HPEN            hPen,
                    hPenOld;
    COLORREF        hColor;
    Assert(m_lpAdrInfo);

    // Need to convert from RECTL to RECT
    rect.left = (INT) lprcBounds->left;
    rect.top = (INT) lprcBounds->top;
    rect.right = (INT) lprcBounds->right;
    rect.bottom = (INT) lprcBounds->bottom;

    hColor = GetSysColor(COLOR_WINDOWTEXT);
    if (m_fUnderline && m_lpAdrInfo->lpwszAddress == NULL && !m_lpAdrInfo->fDistList)
    {
        // if a compose-note, and there is no address then we show recipients with no email in red
        hColor = RGB(0xFF, 0, 0);
        if (GetSysColor(COLOR_WINDOW) == hColor)    // if background is RED, use WHITE
            hColor = RGB(0xFF, 0xFF, 0xFF);
    }

    hfontOld = SelectFont(hdcDraw, _GetFont());

    pwszName = m_lpAdrInfo->lpwszDisplay;
    SetTextAlign(hdcDraw, TA_BOTTOM);
    
    SetTextColor(hdcDraw, hColor);
    ExtTextOutWrapW(hdcDraw, rect.left, rect.bottom, 0, &rect, pwszName, lstrlenW(pwszName), NULL);

    if (hfontOld)
        SelectObject(hdcDraw, hfontOld);

    GetTextMetrics(hdcDraw, &tm);
    if (m_fUnderline)
    {
        // we want this underlined...
        hPen=CreatePen(PS_SOLID, 0, hColor);
        if(!hPen)
            return E_OUTOFMEMORY;
        
        hPenOld=(HPEN)SelectPen(hdcDraw, hPen);
        MoveToEx(hdcDraw, rect.left, rect.bottom - tm.tmDescent + 1, NULL);
        LineTo(hdcDraw, rect.right, rect.bottom - tm.tmDescent + 1);
        SelectPen(hdcDraw, hPenOld);
        DeleteObject(hPen);
    }
    return NOERROR;
}

HRESULT CAddrObj::GetColorSet(DWORD dwDrawAspect, 
                             LONG lindex, 
                             void *pvAspect, 
                             DVTARGETDEVICE *ptd, 
                             HDC hicTargetDev,
                             LPLOGPALETTE *ppColorSet)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::Freeze(DWORD dwDrawAspect, LONG lindex, void * pvAspect, DWORD * pdwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::Unfreeze(DWORD dwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CAddrObj::SetAdvise(DWORD aspects, DWORD advf, IAdviseSink * pAdvSnk)
{
    if(m_padvisesink)
        m_padvisesink->Release();

    if(pAdvSnk)
        pAdvSnk->AddRef();
    
    m_padvisesink = pAdvSnk;

    return NOERROR;
}

HRESULT CAddrObj::GetAdvise(DWORD * pAspects, DWORD * pAdvf, IAdviseSink ** ppAdvSnk)
{
    return E_NOTIMPL;
}



// IPersit methods:
HRESULT CAddrObj::GetClassID(CLSID *pClsID)
{
    *pClsID = CLSID_AddrObject;
    return NOERROR;
}



CAddrObj::CAddrObj()
{
    
    m_cRef=1;
    m_fUnderline=TRUE;
    m_lpoleclientsite = 0;
    m_pstg = 0;
    m_padvisesink = 0;
    CreateOleAdviseHolder(&m_poleadviseholder);
    // copy props
    m_lpAdrInfo = NULL;
}

HRESULT CAddrObj::HrSetAdrInfo(LPADRINFO lpAdrInfo)
{
    if(m_lpAdrInfo)
    {
        MemFree(m_lpAdrInfo);
        m_lpAdrInfo=0;
    }
    
    // has to have a valid address, or else be a distlist...
    Assert(lpAdrInfo->lpwszDisplay);
    Assert(lpAdrInfo->lpbEID);
    return HrDupeAddrInfo(lpAdrInfo, &m_lpAdrInfo);
}

HRESULT CAddrObj::HrGetAdrInfo(LPADRINFO *lplpAdrInfo)
{
    Assert(lplpAdrInfo);
    *lplpAdrInfo=m_lpAdrInfo;
    return NOERROR;
};


CAddrObj::~CAddrObj()
{
    ReleaseObj(m_lpoleclientsite);
    ReleaseObj(m_pstg);
    ReleaseObj(m_poleadviseholder);
    ReleaseObj(m_padvisesink);

    // this is our own copy, we must free it!
    if(m_lpAdrInfo)
        MemFree(m_lpAdrInfo);
}




/* 
 * I D a t a  O b j e c t  m e t h o d s:
 *
 * 
 *
 */
HRESULT CAddrObjData::GetData(FORMATETC * pformatetcIn, STGMEDIUM * pmedium)
{
    return HrGetDataHereOrThere(pformatetcIn, pmedium);
}

HRESULT CAddrObjData::GetDataHere(FORMATETC * pformatetc, STGMEDIUM *pmedium)
{
    return HrGetDataHereOrThere(pformatetc, pmedium);
}

HRESULT CAddrObjData::QueryGetData(FORMATETC * pformatetc )
{
    LONG        iformatetc;
    LPFORMATETC pformatetcT = rgformatetcADDROBJ;
    CLIPFORMAT  cfFormat    = pformatetc->cfFormat;
    DWORD       tymed       = pformatetc->tymed;

    for (iformatetc = 0; iformatetc < cformatetcADDROBJ;
                                ++iformatetc, ++pformatetcT)
    {
        // Stop searching if we have compatible formats and mediums
        if (pformatetcT->cfFormat == cfFormat &&
                    (pformatetcT->tymed & tymed))
            return NOERROR;
    }

    return ResultFromScode(S_FALSE);
}

HRESULT CAddrObjData::GetCanonicalFormatEtc(FORMATETC * pformatetcIn, FORMATETC * pFormatetcOut)
{
    return DATA_S_SAMEFORMATETC;
}

HRESULT CAddrObjData::SetData(FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

HRESULT CAddrObjData::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenumFormatEtc )
{
    return CreateEnumFormatEtc(this, cformatetcADDROBJ, NULL, rgformatetcADDROBJ, ppenumFormatEtc);
}

HRESULT CAddrObjData::DAdvise(FORMATETC * pformatetc, DWORD advf, IAdviseSink *pAdvSnk, DWORD * pdwConnection)
{
    return E_NOTIMPL;
}
HRESULT CAddrObjData::DUnadvise(DWORD dwConnection)
{
return E_NOTIMPL;
}

HRESULT CAddrObjData::EnumDAdvise(IEnumSTATDATA ** ppenumAdvise )
{
    return E_NOTIMPL;
}



HRESULT CAddrObjData::QueryInterface(REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = (void*)this;
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppvObject = (void*)(IDataObject*)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CAddrObjData::AddRef(void)
{
    return ++m_cRef;
}

ULONG CAddrObjData::Release(void)
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



HRESULT CAddrObjData::HrGetDataHereOrThere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    HRESULT         hr=NOERROR;
    BOOL            fFound;
    ADRINFO         adrInfo;
    ULONG           cb=0;
    LPBYTE          pDst, pBeg;
    int             cch = 0;
    
    Assert(m_lpWabal);
    
    if (pformatetcIn->cfFormat == rgformatetcADDROBJ[iFormatAddrObj].cfFormat)
    {
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->pUnkForRelease = NULL;
        return m_lpWabal->HrBuildHGlobal(&pmedium->hGlobal);
    }
    else if ((pformatetcIn->cfFormat != rgformatetcADDROBJ[iFormatText].cfFormat) &&
             (pformatetcIn->cfFormat != rgformatetcADDROBJ[iFormatUnicode].cfFormat))
    {
        return DATA_E_FORMATETC;
    }
        
    fFound=m_lpWabal->FGetFirst(&adrInfo);
    while(fFound)
    {
        Assert(adrInfo.lpwszDisplay);
        cb+=(lstrlenW(adrInfo.lpwszDisplay)+2)*sizeof(WCHAR);        // +2 for '; '
        if (adrInfo.lpwszAddress)
        {
            cb+=(lstrlenW(adrInfo.lpwszAddress)+3)*sizeof(WCHAR);        // +3 for ' <>'
        }
        fFound=m_lpWabal->FGetNext(&adrInfo);
    }
    cb+=sizeof(WCHAR);      // null term
    
    if  (pmedium->tymed == TYMED_NULL ||
        (pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal == NULL))
    {
        // This is easy, we can quit right after copying stuff
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);
        pmedium->pUnkForRelease = NULL;
    }
    else if (pmedium->tymed == TYMED_HGLOBAL && pmedium->hGlobal != NULL)
    {
        HGLOBAL hGlobal;
        // Caller wants us to fill his hGlobal
        // Realloc the destination to make sure there is enough room
        if (!(hGlobal = GlobalReAlloc(pmedium->hGlobal, cb, 0)))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pmedium->hGlobal = hGlobal;
    }
    else
        goto Cleanup;
    
    if (!pmedium->hGlobal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    cch = (cb/sizeof(WCHAR));
    pBeg = pDst = (LPBYTE)GlobalLock(pmedium->hGlobal);
    fFound=m_lpWabal->FGetFirst(&adrInfo);
    while(fFound)
    {
        ULONG cbItem = lstrlenW(adrInfo.lpwszDisplay) * sizeof(WCHAR);
        if (adrInfo.lpwszAddress)
        {
            cbItem += (lstrlenW(adrInfo.lpwszAddress) + 3) * sizeof(WCHAR);   //+3 " <>"
        }
        
        if (adrInfo.lpwszAddress)
        {
            wnsprintfW((LPWSTR)pDst, cch, L"%s <%s>", adrInfo.lpwszDisplay, adrInfo.lpwszAddress);
        }
        else
        {
            StrCpyNW((LPWSTR)pDst, adrInfo.lpwszDisplay, cch);
        }
 
        pDst+=cbItem;
        cch -= (cbItem/sizeof(WCHAR));
        
        fFound=m_lpWabal->FGetNext(&adrInfo);
        if(fFound)
        {
            // if more, add a '; '
            *((LPWSTR) pDst) = L';';
            pDst += sizeof(WCHAR);
            *((LPWSTR) pDst) = L' ';
            pDst += sizeof(WCHAR);
            *((LPWSTR) pDst) = L'\0';
            cch -= 2;
        }                
    }

    //From MSDN:
    //   CF_TEXT Specifies the standard American National Standards Institute (ANSI) text format.
    //The string needs to be ANSI...convert it.
    if(pformatetcIn->cfFormat == CF_TEXT)
    {
        WCHAR *pwszDup;
        int cCopied;

        IF_NULLEXIT(pwszDup = StrDupW((LPWSTR)pBeg));
        cCopied = WideCharToMultiByte(CP_ACP, 0, pwszDup, lstrlenW(pwszDup), (LPTSTR)pBeg, cb, NULL, NULL);
        pBeg[cCopied] = '\0';
        MemFree(pwszDup);
    }

    GlobalUnlock(pmedium->hGlobal);
  
exit:    
Cleanup:
    return hr;
}


CAddrObjData::CAddrObjData(LPWABAL lpWabal)
{ 
    m_cRef=1;
    Assert(lpWabal);
    
    m_lpWabal=lpWabal;
    if(lpWabal)
        lpWabal->AddRef();
};


CAddrObjData::~CAddrObjData()
{ 
    ReleaseObj(m_lpWabal);
};

CAddrWellCB::CAddrWellCB(BOOL fUnderline, BOOL fHasAddrObjs)
{
    m_cRef=1;
    m_hwndEdit = 0;
    m_fUnderline = fUnderline;
    m_fHasAddrObjs=fHasAddrObjs;
}

CAddrWellCB::~CAddrWellCB()
{
}


BOOL CAddrWellCB::FInit(HWND hwndEdit)
{
    // make sure addrobj's DD guid's are registered
    if(!FInitAddrObj(TRUE))
        return FALSE;

    if(!IsWindow(hwndEdit))
        return FALSE;
    
    m_hwndEdit = hwndEdit;
    return TRUE;
}


HRESULT CAddrWellCB::QueryInterface(REFIID riid, LPVOID FAR * lplpObj)
{
    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (void*)(IUnknown*)this;
    else if (IsEqualIID(riid, IID_IRichEditOleCallback))
        *lplpObj = (void*)(IRichEditOleCallback*)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CAddrWellCB::AddRef()
{
    return ++m_cRef;
}

ULONG CAddrWellCB::Release()
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    else
        return m_cRef;
}

HRESULT CAddrWellCB::GetNewStorage (LPSTORAGE FAR * ppstg)
{
    if (*ppstg)
        ppstg=NULL;
    
    AssertSz(FALSE, "this code should not get hit for OE");
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::GetInPlaceContext(   LPOLEINPLACEFRAME FAR * lplpFrame,
                                            LPOLEINPLACEUIWINDOW FAR * lplpDoc,
                                            LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::ShowContainerUI(BOOL fShow)
{
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::QueryInsertObject(LPCLSID lpclsid, 
                                       LPSTORAGE lpstg,
                                       LONG cp)
{
    if(!m_fHasAddrObjs)
        return E_NOTIMPL;

    if (IsEqualIID(*lpclsid, CLSID_AddrObject))
        return NOERROR;
    else
        return E_FAIL;
}

HRESULT CAddrWellCB::DeleteObject(LPOLEOBJECT lpoleobj)
{
    return NOERROR;
}


HRESULT CAddrWellCB::QueryAcceptData(LPDATAOBJECT   pdataobj,
                                     CLIPFORMAT FAR *pcfFormat, 
                                     DWORD          reco,
                                     BOOL           fReally, 
                                     HGLOBAL        hMetaPict)
{
    HRESULT         hr;
    STGMEDIUM       stgmedium;
    LPWABAL         lpWabal=0;
    ADRINFO         adrInfo;
    
    if(!m_fHasAddrObjs)
    {
        // of we're a regular callback, take TEXTONLY
        *pcfFormat=CF_TEXT;
        return NOERROR;
    }
    
    if (!*pcfFormat)
    {
        // default to text
        *pcfFormat = CF_TEXT;
        
        // Cool, it's one of ours...
        if(pdataobj->QueryGetData(&rgformatetcADDROBJ[iFormatAddrObj])==NOERROR)
            *pcfFormat = rgformatetcADDROBJ[iFormatAddrObj].cfFormat;
    }
    else
    {
        if (*pcfFormat != rgformatetcADDROBJ[iFormatAddrObj].cfFormat
            && *pcfFormat != rgformatetcADDROBJ[iFormatText].cfFormat)
            return DATA_E_FORMATETC;
    }
    
    if (*pcfFormat==CF_TEXT)  // let the richedit take care of text
        return NOERROR;
    
    // If I'm read-only, return Success and Richedit won't do anything
    if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
        return NOERROR;
    
    if (!fReally)   // return that we'll import it ourselves
        return ResultFromScode(S_FALSE);
    
    hr=pdataobj->GetData(&rgformatetcADDROBJ[iFormatAddrObj], &stgmedium);
    if(FAILED(hr))
        goto Cleanup;
    
    hr=HrCreateWabalObjectFromHGlobal(stgmedium.hGlobal, &lpWabal);
    if(FAILED(hr))
        goto Cleanup;
    
    if(lpWabal->FGetFirst(&adrInfo))
    {
        // don't add semi colon before first entry!
        HrAddRecipientToWell(m_hwndEdit, (LPADRINFO)&adrInfo);
        while(lpWabal->FGetNext(&adrInfo))
        {
            HdrSetRichEditText(m_hwndEdit, L"; ", TRUE);
            HrAddRecipientToWell(m_hwndEdit, (LPADRINFO)&adrInfo);
        }
    }
    
    // free the hglobal
    GlobalFree(stgmedium.hGlobal);
    ReleaseObj(lpWabal);
    hr = ResultFromScode(S_FALSE);
    
Cleanup:
    return hr;
}


HRESULT CAddrWellCB::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

HRESULT CAddrWellCB::GetClipboardData(CHARRANGE FAR * pchrg,
                                        DWORD reco,
                                        LPDATAOBJECT FAR * ppdataobj)
{
    HRESULT         hr;
    CAddrObjData    *lpAddrObjData=0;
    LPWABAL         lpWabal=0;
    ULONG           uSelType;

    if(!m_fHasAddrObjs)
        return E_NOTIMPL;

    Assert(ppdataobj);
    *ppdataobj=0;

    // Need to prevent cut on read only
    if (reco == RECO_CUT &&
        (GetWindowStyle(m_hwndEdit)&ES_READONLY))
        return E_NOTIMPL;


    // if there is only text in the selection, let the richedit take care of it!
    uSelType= (ULONG) SendMessage(m_hwndEdit, EM_SELECTIONTYPE, 0, 0);
    if(!(uSelType&SEL_OBJECT))
        return E_NOTIMPL;

    hr=HrBuildSelectionWabal(m_hwndEdit, pchrg, &lpWabal);
    if(FAILED(hr))
        return E_FAIL;
    
    // this will gobble up the pal so I don't want to free it
    if(!(lpAddrObjData= new CAddrObjData(lpWabal)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }
    
    hr=lpAddrObjData->QueryInterface(IID_IDataObject, (LPVOID *)ppdataobj);
    ReleaseObj(lpAddrObjData);

error:
    ReleaseObj(lpWabal);
    return hr;
}

HRESULT CAddrWellCB::GetDragDropEffect(BOOL fDrag, 
                                       DWORD grfKeyState,
                                       LPDWORD pdwEffect)
{
    if(!m_fHasAddrObjs)
        return E_NOTIMPL;

    if (fDrag)          // use the default
        return NOERROR;

    if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
        *pdwEffect = DROPEFFECT_NONE;
    else
    {
        if ((grfKeyState & MK_CONTROL) || !(*pdwEffect & DROPEFFECT_MOVE))
            *pdwEffect = DROPEFFECT_COPY;
        else 
            *pdwEffect = DROPEFFECT_MOVE;
    }
    return NOERROR;
}

HRESULT CAddrWellCB::GetContextMenu(WORD            seltype, 
                                    LPOLEOBJECT     pOleObject,
                                    CHARRANGE FAR   *pchrg,
                                    HMENU FAR       *phMenu)
{

    HMENU               hMenu=0;
    DWORD               dwFlags=0;
    IOleCommandTarget   *pCmdTarget;
    OLECMD              rgCmds[] = {
                                        {ID_ADDROBJ_OLE_FIND, 0},
                                        {ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK, 0},
                                        {ID_ADDROBJ_OLE_PROPERTIES, 0},
                                        {ID_ADDROBJ_OLE_BLOCK_SENDER, 0}};


    if (!(hMenu=LoadPopupMenu(IDR_ADDRESS_POPUP)))
        return E_OUTOFMEMORY;

    if (!m_fHasAddrObjs || pOleObject==NULL)
    {
        // if this RICHEDIT control does not care about ADDROBJECT or if there is
        // no addr object selected, then just return a 
        // regular cut|copy|paste menu
        
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_FIND, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_BLOCK_SENDER, MF_BYCOMMAND);
        
        RemoveMenu(hMenu, ID_SEPARATOR_1, MF_BYCOMMAND);
        
        RemoveMenu(hMenu, ID_SEPARATOR_3, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_ADDROBJ_OLE_PROPERTIES, MF_BYCOMMAND);
        
    }
    else
    {
        // if we get this far, then we have an ole object, make sure it's one we know
        // about if we're an addrobj well
#ifdef DEBUG        
        AssertValidAddrObject(pOleObject);
#endif
        
        // try and see if the object can handle the commands
        if (pOleObject->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
            if (pCmdTarget->QueryStatus(&CMDSETID_OutlookExpress, ARRAYSIZE(rgCmds), rgCmds, NULL)==S_OK)
            {
                for(ULONG ul=0; ul<sizeof(rgCmds)/sizeof(OLECMD); ul++)
                {
                    EnableMenuItem(hMenu, rgCmds[ul].cmdID, (rgCmds[ul].cmdf&OLECMDF_ENABLED ? MF_ENABLED: MF_GRAYED)|MF_BYCOMMAND);
                    if (!(rgCmds[ul].cmdf&OLECMDF_SUPPORTED))
                        RemoveMenu(hMenu, rgCmds[ul].cmdID, MF_BYCOMMAND);
                }
            }
            pCmdTarget->Release();
        }
        
        // if an Object has focus, then we show the commands before the separator
        // if there is an object in selction, remove SelectAll
        RemoveMenu(hMenu, ID_SEPARATOR_2, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_SELECT_ALL, MF_BYCOMMAND);
        
        if (SendMessage(m_hwndEdit, EM_SELECTIONTYPE, 0, 0) != SEL_OBJECT)
        {
            // multiple objects selected, let's grey out addrobj commands
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_PROPERTIES,        MF_GRAYED|MF_BYCOMMAND);
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK,  MF_GRAYED|MF_BYCOMMAND);
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_FIND,              MF_GRAYED|MF_BYCOMMAND);
            EnableMenuItem(hMenu, ID_ADDROBJ_OLE_BLOCK_SENDER,      MF_GRAYED|MF_BYCOMMAND);
        } 
    }
    
    // if we are a readonly edit, then remove cut and paste
    if (FReadOnlyEdit(m_hwndEdit))
    {
        // remove cut and past if readonly
        RemoveMenu(hMenu, ID_CUT, MF_BYCOMMAND);
        RemoveMenu(hMenu, ID_PASTE, MF_BYCOMMAND);
    }
    
    MenuUtil_SetPopupDefault(hMenu, ID_ADDROBJ_OLE_PROPERTIES);
    
    GetEditDisableFlags(m_hwndEdit, &dwFlags);
    EnableDisableEditMenu(hMenu, dwFlags);
    *phMenu=hMenu;
    return S_OK;
}



#ifdef DEBUG        
void AssertValidAddrObject(LPUNKNOWN pUnk)
{    
    BOOL        fValid=FALSE;
    LPOLEOBJECT pOleObject;
    CLSID       clsid;

    Assert(pUnk);
    if(!pUnk->QueryInterface(IID_IOleObject, (LPVOID *)&pOleObject))
    {
        if((pOleObject->GetUserClassID(&clsid)==NOERROR) &&
            IsEqualCLSID(clsid, CLSID_AddrObject))
            fValid=TRUE;
        ReleaseObj(pOleObject);
    }

    AssertSz(fValid, "WHOA! This is not an AddrObject!");
}
#endif


HRESULT HrBuildSelectionAddrInfoList(HWND hwndRE, CHARRANGE *pchrg, LPADRINFOLIST *lplpAdrInfoList)
{

    return NOERROR;
}

HRESULT HrBuildOneSelWabal(LPADRINFO lpAdrInfo, LPWABAL *lplpWabal)
{
    LPWABAL lpWabal=0;
    HRESULT hr;

    if(!lplpWabal)
        return E_INVALIDARG;

    hr=HrCreateWabalObject(&lpWabal);
    if(FAILED(hr)) 
        goto error;

    hr=lpWabal->HrAddEntry(lpAdrInfo);
    if(FAILED(hr)) 
        goto error;

    *lplpWabal=lpWabal;
    lpWabal->AddRef();
    
error:
    ReleaseObj(lpWabal);        
    return hr;
}



#define iswhite(_ch)   (_ch==' ' || _ch=='\t' || _ch=='\n' || _ch=='\r')


/*
 *    ScBuildSelectionAdrlist
 *    
 *    Purpose:
 *        This function will add all the resolved and unresolved
 *        names from the selection in an edit control to an ADRLIST
 *    
 *    Parameters:
 *        ppal            pointer to pointer to ADRLIST
 *        hwndEdit        hwnd of the edit control
 *        pchrg            CHARRANGE of the selection
 *    
 *    Returns:
 *        sc
 */
HRESULT HrBuildSelectionWabal(HWND hwndRE, CHARRANGE *pchrg, LPWABAL *lplpWabal)
{
    ULONG               iOb,
                        cOb,
                        cb,
                        cchBuf = 0,
                        cchSel;
    LPRICHEDITOLE       preole;
    REOBJECT            reobj = {0};
    LPWABAL             lpWabal = NULL;
    HRESULT             hr;
    WCHAR               rgch[cchUnresolvedMax];
    LPWSTR              pbStart = NULL,
                        pbSel;
    BOOL                fTruncated = FALSE;
    PHCI                phci;
    
    Assert(pchrg);
    cchSel = pchrg->cpMax-pchrg->cpMin;

    // Add all the resolved names (stored as OLE objects) from
    // hwndEdit to the ADRLIST
    reobj.cbStruct = sizeof(REOBJECT);
    
    if(!MemAlloc((LPVOID *)&pbStart, (cchSel+1)*sizeof(WCHAR)))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    pbSel = pbStart;
    
    hr=HrCreateWabalObject(&lpWabal);
    if(FAILED(hr))
        goto Cleanup;
    
    // if we're building a Wabal, there MUST be some object in the selection!
    Assert((SendMessage(hwndRE, EM_SELECTIONTYPE, 0, 0)&SEL_OBJECT));
    
    phci = (HCI*)GetWindowLongPtr(hwndRE, GWLP_USERDATA);
    AssertSz(phci, "How did we get a richedit without a phci???");
    
    preole = phci->preole;
    AssertSz(preole, "How did we get a phci without a preole???");
    
    // count up the number of objects in the selction, and the number of
    // bytes in them...
    cOb = preole->GetObjectCount();
    for (iOb = 0; iOb < cOb; iOb++)
    {
        hr=preole->GetObject(iOb, &reobj, REO_GETOBJ_POLEOBJ);
        if(FAILED(hr))
            goto Cleanup;
        
        if (reobj.cp >= pchrg->cpMax) // out of the selrange...
            break;
        
        if (reobj.cp >= pchrg->cpMin)
        {
            LPPERSIST   ppersist = NULL;
            LPADRINFO   lpAdrInfo = 0;
            
            if (FAILED(hr = reobj.poleobj->QueryInterface(IID_IPersist, (LPVOID *)&ppersist)))
                goto Cleanup;
            
            hr = ((CAddrObj *)ppersist)->HrGetAdrInfo(&lpAdrInfo);
            lpWabal->HrAddEntry(lpAdrInfo);

            ReleaseObj(ppersist);
            if(FAILED(hr))
                goto Cleanup;
        }
        ReleaseObj(reobj.poleobj);
        reobj.poleobj = NULL;
    }
    
    // walk the unresolved text, and parse it up into unresolved names...
    cb = HdrGetRichEditText(hwndRE, pbSel, cchSel, TRUE) + 1;
    //$ BUG - broken for Unicode
    
    // The algorithm below will strip spaces off of the
    // beginning and end of each name
    while (cb--)
    {
        if (*pbSel == L'\t')
            *pbSel = L' ';
        
        if ((*pbSel == L'\0') || (*pbSel == L';') || (*pbSel == L'\r'))
        {
            if(cchBuf)
            {
                LPWSTR psz = rgch + cchBuf - 1;
                while(cchBuf > 0)
                {
                    // Exchange #10168.
                    if((*psz == L' ') || (*psz == L'\t'))
                    {
                        cchBuf--;
                        psz--;
                    }
                    else
                        break;
                }    
            }
            
            if (cchBuf)
            {
                rgch[cchBuf] = L'\0';
                lpWabal->HrAddUnresolved(rgch, (ULONG)-1);
                cchBuf = 0;
            }
        }
        else
        {
            if (((*pbSel != L' ') && (*pbSel != L'\n') && (*pbSel != L'\r')) || cchBuf > 0)
            {
                if (cchBuf < cchUnresolvedMax - 1)
                    rgch[cchBuf++] = *pbSel;
                else
                    fTruncated = TRUE;
            }
        }
        ++pbSel;
    }
    
    
    *lplpWabal=lpWabal;
    lpWabal->AddRef();
    
Cleanup:
    MemFree(pbStart);

    ReleaseObj(lpWabal);
    ReleaseObj(reobj.poleobj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\adbar.h ===
#ifndef _ADBAR_H
#define _ADBAR_H

#include "mehost.h"

//Util functions used only in Ads
HRESULT HrEscapeOtherAdToken(LPSTR pszAdOther, LPSTR pszEncodedString, DWORD cch, DWORD *cchRetCount);
HRESULT HrProcessAdTokens(LPSTR    pszAdInfo, LPCSTR    pszToken, LPSTR    pszretval, DWORD    cch, DWORD    *pcchCount);

//Strings for Ads
const CHAR c_szAdPaneOn[]           = "On";
const CHAR c_szAdPaneOff[]          = "Off";
const CHAR c_szAdOther[]            = "Other";
const CHAR c_szRedirectAdUrl[]      = "http://services.msn.com/svcs/oe/ads.asp?Version=";
const CHAR c_szAdSvrFormat[]        = "&AdSvr=";
const CHAR c_szAdOtherFormat[]      = "&Other=";
const CHAR c_szAdRedirectFormat[]   = "%s%s%s%s%s%s";

const CHAR c_szAdPane[]             = "AdPane";
const CHAR c_szAdSvr[]              = "AdSvr";
const CHAR c_szEqualSign[]          = "%3d";
const CHAR c_szAmpersandSign[]      = "%20";
const CHAR c_szSpaceSign[]          = "%26";

//Constants used only for Ads
#define CCH_ADPANE_OFF               (sizeof(c_szAdPaneOff) / sizeof(*c_szAdPaneOff))
#define CCH_ADPANE_ON                (sizeof(c_szAdPaneOn) / sizeof(*c_szAdPaneOn))
#define CCH_REDIRECT_ADURL           (sizeof(c_szRedirectAdUrl) / sizeof(*c_szRedirectAdUrl))
#define CCH_ADSVR_TOKEN_FORMAT       (sizeof(c_szAdSvrFormat) / sizeof(*c_szAdSvrFormat))
#define CCH_OTHER_FORMAT             (sizeof(c_szAdOther) / sizeof(*c_szAdOther))
#define CCH_AD_OTHER_FORMAT          (sizeof(c_szAdOtherFormat) / sizeof(*c_szAdOtherFormat))

class CAdBar :
    public IDockingWindow,
    public IObjectWithSite,
    public IInputObject
{
public:
    CAdBar();
    virtual ~CAdBar();
        
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleWindow methods
    virtual STDMETHODIMP GetWindow(HWND *phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IDockingWindow
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    // IObjectWithSite
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    // IInputObject
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpmsg);

    // overrides of CBody
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget);

    HRESULT HrInit(BSTR     bstr);
    HRESULT SetUrl(LPSTR pszUrl);
    BOOL    fValidUrl();

	int		GetAdBar_Top()			{ return( (int) HIWORD(m_dwAdBarPos));}
	int		GetAdBar_Bottom()			{ return( (int) LOWORD(m_dwAdBarPos));}
	
protected:
    LRESULT AdBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static  LRESULT CALLBACK ExtAdBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);

private:
    IDockingWindowSite *m_ptbSite;
    HWND                m_hwnd;
    HWND                m_hwndParent;
    int                 m_cSize;
	DWORD				m_dwAdBarPos;
    LPSTR               m_pszUrl;
	BOOL				m_fFirstPos;
    BOOL                m_fDragging;
    ULONG               m_cRef;
    CMimeEditDocHost    *m_pMehost;
};

#endif // _ADBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\bodybar.h ===
#ifndef _BODYBAR_H
#define _BODYBAR_H

#include "mehost.h"

// for IBodyOptions
#include "ibodyopt.h"

class CBodyBar :
    public IDockingWindow,
    public IObjectWithSite,
    public IInputObject
{
public:
    CBodyBar();
    virtual ~CBodyBar();
        
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleWindow methods
    virtual STDMETHODIMP GetWindow(HWND *phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IDockingWindow
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    // IObjectWithSite
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    // IInputObject
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpmsg);

    // overrides of CBody
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget);

    HRESULT HrInit(LPBOOL pfShow);

	int		GetBodyBar_Top()			{ return( (int) HIWORD(m_dwBodyBarPos));}
	int		GetBodyBar_Bottom()			{ return( (int) LOWORD(m_dwBodyBarPos));}
	
protected:
    LRESULT BodyBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ExtBodyBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL    OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    void    OnSize(HWND hwnd, UINT state, int cxClient, int cyClient);
    void    OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void    OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void    OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);

private:
    IDockingWindowSite *m_ptbSite;
    HWND                m_hwnd;
    HWND                m_hwndParent;
    int                 m_cSize;
	DWORD				m_dwBodyBarPos;
    LPTSTR              m_pszURL;
	BOOL				m_fFirstPos;
    BOOL                m_fDragging;
    CMimeEditDocHost    *m_pMehost;
    ULONG               m_cRef;
};

#endif // _BODYBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\addrobj.h ===
/*
 *    a d d r o b j . h
 *
 *
 *     Purpose:
 *        implements an Address object. An ole object representation for
 *        a resolved email address. Wraps a CAddress object
 *      also implements an IDataObj for drag-drop
 *
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 *
 *  Owner: brettm
 *
 */

#ifndef _ADDROBJ_H
#define _ADDROBJ_H

#include <richedit.h>
#ifndef _RICHOLE_H                  // richole.h has no #ifdef around it...
#define _RICHOLE_H
#include <richole.h>
#endif

#include <addrlist.h>
#include <ipab.h>

BOOL    FInitAddrObj(BOOL fInit);        // called at init time

class CAddrObj :
    public IOleObject,
    public IViewObject,
    public IPersist,
    public IOleCommandTarget
{
public:

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IOleObject methods:
    HRESULT STDMETHODCALLTYPE SetClientSite(LPOLECLIENTSITE pClientSite);
    HRESULT STDMETHODCALLTYPE GetClientSite(LPOLECLIENTSITE * ppClientSite);
    HRESULT STDMETHODCALLTYPE SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    HRESULT STDMETHODCALLTYPE Close(DWORD dwSaveOption);
    HRESULT STDMETHODCALLTYPE SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk);
    HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk);
    HRESULT STDMETHODCALLTYPE InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved);
    HRESULT STDMETHODCALLTYPE GetClipboardData(DWORD dwReserved, LPDATAOBJECT * ppDataObject); 
    HRESULT STDMETHODCALLTYPE DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
    HRESULT STDMETHODCALLTYPE EnumVerbs(LPENUMOLEVERB * ppEnumOleVerb);
    HRESULT STDMETHODCALLTYPE Update();
    HRESULT STDMETHODCALLTYPE IsUpToDate();
    HRESULT STDMETHODCALLTYPE GetUserClassID(CLSID * pClsid);
    HRESULT STDMETHODCALLTYPE GetUserType(DWORD dwFormOfType, LPOLESTR * pszUserType);
    HRESULT STDMETHODCALLTYPE SetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    HRESULT STDMETHODCALLTYPE GetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    HRESULT STDMETHODCALLTYPE Advise (LPADVISESINK pAdvSink, DWORD * pdwConnection);
    HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwConnection);
    HRESULT STDMETHODCALLTYPE EnumAdvise(LPENUMSTATDATA * ppenumAdvise);
    HRESULT STDMETHODCALLTYPE GetMiscStatus(DWORD dwAspect, DWORD * pdwStatus);
    HRESULT STDMETHODCALLTYPE SetColorScheme(LPLOGPALETTE lpLogpal);


    // IViewObject methods:
    HRESULT STDMETHODCALLTYPE Draw(DWORD dwDrawAspect, LONG lindex, void * pvAspect, 
                                    DVTARGETDEVICE * ptd, HDC hicTargetDev, HDC hdcDraw, 
                                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                                    BOOL (CALLBACK * pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue);

    HRESULT STDMETHODCALLTYPE GetColorSet(DWORD dwDrawAspect, LONG lindex, void *pvAspect, 
                                            DVTARGETDEVICE *ptd, HDC hicTargetDev, LPLOGPALETTE *ppColorSet);
    HRESULT STDMETHODCALLTYPE Freeze(DWORD dwDrawAspect, LONG lindex, void * pvAspect, DWORD * pdwFreeze);
    HRESULT STDMETHODCALLTYPE Unfreeze(DWORD dwFreeze);
    HRESULT STDMETHODCALLTYPE SetAdvise(DWORD aspects, DWORD advf, IAdviseSink * pAdvSnk);
    HRESULT STDMETHODCALLTYPE GetAdvise(DWORD * pAspects, DWORD * pAdvf, IAdviseSink ** ppAdvSnk);

    // IPersit methods:
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    CAddrObj();
    ~CAddrObj();

    HRESULT HrSetAdrInfo(LPADRINFO lpAdrInfo);
    HRESULT HrGetAdrInfo(LPADRINFO *lplpAdrInfo); 

    HRESULT OnFontChange();

private:
    UINT                m_cRef;
    BOOL                m_fUnderline;           // Do we draw the underline?
    LPOLECLIENTSITE     m_lpoleclientsite;
    LPSTORAGE           m_pstg;                // Associated IStorage

    LPADVISESINK        m_padvisesink;
    LPOLEADVISEHOLDER   m_poleadviseholder;

    LPADRINFO           m_lpAdrInfo;
    
    HWND                m_hwndEdit; 

    HFONT _GetFont();
    
};

class CAddrObjData:
    public IDataObject
{
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IDataObject methods:
    HRESULT STDMETHODCALLTYPE GetData(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);
    HRESULT STDMETHODCALLTYPE GetDataHere(FORMATETC * pformatetc, STGMEDIUM *pmedium);
    HRESULT STDMETHODCALLTYPE QueryGetData(FORMATETC * pformatetc );
    HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(FORMATETC * pformatetcIn, FORMATETC * pFormatetcOut);
    HRESULT STDMETHODCALLTYPE SetData(FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease);
    HRESULT STDMETHODCALLTYPE EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenumFormatEtc );
    HRESULT STDMETHODCALLTYPE DAdvise(FORMATETC * pformatetc, DWORD advf, IAdviseSink *pAdvSnk, DWORD * pdwConnection);
    HRESULT STDMETHODCALLTYPE DUnadvise(DWORD dwConnection);
    HRESULT STDMETHODCALLTYPE EnumDAdvise(IEnumSTATDATA ** ppenumAdvise );

public:
    CAddrObjData(LPWABAL lpWabal);

private:
    HRESULT HrGetDataHereOrThere(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium);
    ~CAddrObjData();    

private:
    ULONG           m_cRef;
    LPWABAL         m_lpWabal;
};


// richedit callback used for addrwells

class CAddrWellCB:
    public IRichEditOleCallback
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // *** IRichEditOleCallback methods ***
    HRESULT STDMETHODCALLTYPE GetNewStorage (LPSTORAGE FAR *);
    HRESULT STDMETHODCALLTYPE GetInPlaceContext(LPOLEINPLACEFRAME FAR *,LPOLEINPLACEUIWINDOW FAR *,LPOLEINPLACEFRAMEINFO);
    HRESULT STDMETHODCALLTYPE ShowContainerUI(BOOL);
    HRESULT STDMETHODCALLTYPE QueryInsertObject(LPCLSID, LPSTORAGE,LONG);
    HRESULT STDMETHODCALLTYPE DeleteObject(LPOLEOBJECT);
    HRESULT STDMETHODCALLTYPE QueryAcceptData(  LPDATAOBJECT,CLIPFORMAT FAR *, DWORD,BOOL, HGLOBAL);
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);
    HRESULT STDMETHODCALLTYPE GetClipboardData(CHARRANGE FAR *, DWORD,LPDATAOBJECT FAR *);
    HRESULT STDMETHODCALLTYPE GetDragDropEffect(BOOL, DWORD,LPDWORD);
    HRESULT STDMETHODCALLTYPE GetContextMenu(WORD, LPOLEOBJECT,CHARRANGE FAR *,HMENU FAR *);
    BOOL FInit(HWND hwndEdit);
    
    CAddrWellCB(BOOL fUnderline, BOOL fHasAddrObjs);
    ~CAddrWellCB();

    BOOL        m_fUnderline;

private:
    ULONG       m_cRef;
    HWND        m_hwndEdit;
    BOOL        m_fHasAddrObjs;
};


#ifdef DEBUG
    void AssertValidAddrObject(LPUNKNOWN pUnk);
#endif

#endif // _ADDROBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\bodybar.cpp ===
/*
 *    b o d y b a r. c p p
 *    
 *    Purpose:
 *        Implementation of CBodyBar object. Derives from CBody to host the trident
 *        control.
 *
 *  History
 *      February '97: erican - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
 */

#include <pch.hxx>
#include <wininet.h> // INTERNET_MAX_URL_LENGTH
#include <resource.h>
#include "strconst.h"
#include "xpcomm.h"
#include "bodybar.h"
#include "goptions.h"
#include <inpobj.h>

static const TCHAR s_szBodyBarWndClass[] = TEXT("ThorBodyBarWndClass");

CBodyBar::CBodyBar()
{
    m_ptbSite = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_cSize = 50;
    m_dwBodyBarPos = 0;
    m_pszURL = NULL;
    m_fFirstPos = TRUE;
    m_fDragging = FALSE;
    m_pMehost   = NULL;
    m_cRef      = 1;
}

CBodyBar::~CBodyBar()
{
    if (m_ptbSite)
        m_ptbSite->Release();
    MemFree(m_pszURL);

    MemFree(m_pMehost);
}

HRESULT CBodyBar::HrInit(LPBOOL pfShow)
{
    HKEY    hkey;
    HRESULT hr    = NOERROR;
    BOOL    fShow = FALSE;

    if (AthUserOpenKey(NULL, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
        {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH + 1];
        DWORD cbData = sizeof(szURL);

        szURL[0] = 0;
        if (RegQueryValueEx(hkey, c_szRegBodyBarPath, NULL, NULL, (LPBYTE)szURL, &cbData) == ERROR_SUCCESS && *szURL)
            {
            m_pszURL = StringDup(szURL);
            if (!m_pszURL)
                hr = E_OUTOFMEMORY;
            else
                fShow = TRUE;
            }

        RegCloseKey(hkey);
        }

    m_dwBodyBarPos = DwGetOption(OPT_BODYBARPOS);

    *pfShow = fShow;
    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    HRESULT     hr = S_OK;

    if(!lplpObj)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IDockingWindow))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IInputObject))
    {
        *lplpObj = (IInputObject *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *lplpObj = (IObjectWithSite *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        *lplpObj = (IDockingWindow *)this;
        AddRef();
    }
    else
    {
        if (m_pMehost)
            hr = m_pMehost->QueryInterface(riid, lplpObj);
        else
            hr = E_FAIL;
    }

exit:
    return hr;
}

ULONG CBodyBar::AddRef()
{
    return (++m_cRef);
}

ULONG CBodyBar::Release()
{
    ULONG      ulRet = 0;

    --m_cRef;
    ulRet = m_cRef;

    if (m_cRef == 0)
    {
        delete this;
    }

    return ulRet;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::GetWindow(HWND *phwnd)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->GetWindow(phwnd);

    return hr;
}

HRESULT CBodyBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->ContextSensitiveHelp(fEnterMode);

    return hr;
}

////////////////////////////////////////////////////////////////////////
//
//  IDockingWindow
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::ShowDW(BOOL fShow)
{
    HRESULT     hr = S_OK;

    // Make sure we have a site pointer first
    if (!m_ptbSite)
    {
        AssertSz(0, _T("CBodyBar::ShowDW() - Can't show without calling SetSite() first."));
        hr = E_FAIL;
        goto exit;
    }

    if (m_hwnd==NULL && fShow==FALSE)   // noop
    {
        hr = S_OK;
        goto exit;
    }

    if (!m_hwnd)
    {
        WNDCLASSEX  wc;
    
        wc.cbSize = sizeof(WNDCLASSEX);
        if (!GetClassInfoEx(g_hInst, s_szBodyBarWndClass, &wc))
        {
            // We need to register the class
            wc.style            = 0;
            wc.lpfnWndProc      = CBodyBar::ExtBodyBarWndProc;
            wc.cbClsExtra       = 0;
            wc.cbWndExtra       = 0;
            wc.hInstance        = g_hInst;
            // If BodyBar is nor resizable then show standard cursor
            wc.hCursor          = LoadCursor(NULL, IDC_SIZENS);

            wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
            wc.lpszMenuName     = NULL;
            wc.lpszClassName    = s_szBodyBarWndClass;
            wc.hIcon            = NULL;
            wc.hIconSm          = NULL;
            
            if (RegisterClassEx(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            {
                hr = E_FAIL;
                goto exit;
            }
        }
        
        // Get the handle of the parent window
        IF_FAILEXIT(hr = m_ptbSite->GetWindow(&m_hwndParent));

        // Create the window
        m_hwnd = CreateWindowEx(0,
                                s_szBodyBarWndClass,
                                NULL,
                                WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN,
                                0,
                                0,
                                0,
                                0,
                                m_hwndParent,
                                NULL,
                                g_hInst,
                                (LPVOID)this);
        if (!m_hwnd)
        {
            AssertSz(0, _T("CBodyBar::ShowDW() - Failed to create window."));
            hr = E_FAIL;
            goto exit;
        }           
    }

    // Show or hide the window and resize the parent windows accordingly
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    ResizeBorderDW(NULL, NULL, FALSE);
    m_fFirstPos = (fShow ? m_fFirstPos : TRUE);

exit:    
    return hr;
}

HRESULT CBodyBar::CloseDW(DWORD dwReserved)
{
    // save BodyBar position, if BodyBar was not set from Extension
    SetOption(OPT_BODYBARPOS, &m_dwBodyBarPos, sizeof(m_dwBodyBarPos), NULL, 0);

    if (m_pMehost)
    {
        m_pMehost->HrUnloadAll(NULL, 0);

        m_pMehost->HrClose();
    }
    return S_OK;
}

HRESULT CBodyBar::ResizeBorderDW(LPCRECT prcBorder, IUnknown *punkToolbarSite, BOOL fReserved)
{
    RECT rcRequest = { 0, 0, 0, 0 };
    
    if (!m_ptbSite)
    {
        AssertSz(0, _T("CBodyBar::ResizeBorderDW() - Can't resize without calling SetSite() first."));
        return E_FAIL; 
    }

    if (IsWindow(m_hwnd) && IsWindowVisible(m_hwnd))
    {
        RECT rcBorder;
        int cTop, cBottom;

        // Calculate position of BodyBar window
        cBottom = GetBodyBar_Bottom();

        if (!prcBorder)
        {
            // Find out how big our parent's border space is
            m_ptbSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
            prcBorder = &rcBorder;
        }

        if(!m_fFirstPos || (cBottom <= 0))
        {
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
            cBottom = rcRequest.bottom;

        }
        else
        {
            m_cSize = cBottom;    // set new value for m_cSize.
            cBottom  += GetSystemMetrics(SM_CYFRAME);
            rcRequest.bottom = min(m_cSize + GetSystemMetrics(SM_CYFRAME), prcBorder->bottom - prcBorder->top);
            cTop = prcBorder->bottom - rcRequest.bottom;
        }                                                                                                                                               



        SetWindowPos(m_hwnd, NULL, prcBorder->left, cTop,  
                     prcBorder->right - prcBorder->left, cBottom, 
                     SWP_NOACTIVATE|SWP_NOZORDER/*|SWP_DRAWFRAME*/);


        m_fFirstPos = FALSE;            // BodyBar window positioned

        // Set new value for BodyBarPos
        m_dwBodyBarPos = (DWORD) MAKELONG(cBottom - GetSystemMetrics(SM_CYFRAME), 0);
    }
    
    m_ptbSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);     
        
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObject
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrUIActivate(fActivate);

    return hr;

}

HRESULT CBodyBar::HasFocusIO(void)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrHasFocus();

    return hr;
}    
        

HRESULT CBodyBar::TranslateAcceleratorIO(LPMSG pMsg)
{
    HRESULT     hr = E_FAIL;

    if (m_pMehost)
        hr = m_pMehost->HrTranslateAccelerator(pMsg);

    return hr;
}    

////////////////////////////////////////////////////////////////////////
//
//  IObjectWithSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::SetSite(IUnknown* punkSite)
{
    // If we already have a site pointer, release it now
    if (m_ptbSite)
        {
        m_ptbSite->Release();
        m_ptbSite = NULL;
        }
    
    // If the caller provided a new site interface, get the IDockingWindowSite
    // and keep a pointer to it.
    if (punkSite)    
        {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, (void **)&m_ptbSite)))
            return E_FAIL;
        }
    
    return S_OK;    
}

HRESULT CBodyBar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IOleInPlaceSite
//
////////////////////////////////////////////////////////////////////////
HRESULT CBodyBar::OnUIActivate()
{
    HRESULT     hr = E_FAIL;

    if (m_ptbSite)
        UnkOnFocusChangeIS(m_ptbSite, (IInputObject*)this, TRUE);

    if (m_pMehost)
        hr = m_pMehost->OnUIActivate();

    return hr;
}

HRESULT CBodyBar::GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget)
{
    return (E_FAIL);
}

/////////////////////////////////////////////////////////////////////////////
//
// private routines
//
/////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CBodyBar::ExtBodyBarWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CBodyBar *pbb;

    if (msg == WM_NCCREATE)
        {
        pbb = (CBodyBar *)LPCREATESTRUCT(lp)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pbb);
        }
    else
        {
        pbb = (CBodyBar *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
        }

    Assert(pbb);
    return pbb->BodyBarWndProc(hwnd, msg, wp, lp);
}

LRESULT CBodyBar::BodyBarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN,    OnLButtonDown);                
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,      OnMouseMove);                
        HANDLE_MSG(hwnd, WM_LBUTTONUP,      OnLButtonUp);                
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);

        case WM_NCDESTROY:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            m_hwnd = NULL;
            break;

        case WM_SETFOCUS:
        {
            HWND hwndBody;

            if (m_pMehost && SUCCEEDED(m_pMehost->HrGetWindow(&hwndBody)) && hwndBody && ((HWND)wParam) != hwndBody)
                SetFocus(hwndBody);
        }
            return 0;    
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL CBodyBar::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    BOOL        fRet = FALSE;

    if (!m_pMehost)
        m_pMehost = new CMimeEditDocHost;

    if (!m_pMehost)
        goto exit;

    if (FAILED(m_pMehost->HrInit(hwnd, 0, NULL)))
        goto exit;

    if (FAILED(m_pMehost->HrShow(TRUE)))
        goto exit;

    if (m_pszURL)
        m_pMehost->HrLoadURL(m_pszURL);

    fRet = TRUE;

exit:
    return fRet;
}

void CBodyBar::OnSize(HWND hwnd, UINT state, int cxClient, int cyClient)
{
    RECT rc;
    
    int  cyFrame = GetSystemMetrics(SM_CYFRAME);

    rc.left = 0;
    rc.top = cyFrame;
    rc.right = cxClient;
    rc.bottom = cyClient;

    if (m_pMehost)
        m_pMehost->HrSetSize(&rc);
}

void CBodyBar::OnLButtonDown(HWND hwnd, 
                              BOOL fDoubleClick, 
                              int  x, 
                              int  y, 
                              UINT keyFlags)
{
    // Capture the mouse
    SetCapture(m_hwnd);

    // Start dragging
    m_fDragging = TRUE;
}

void CBodyBar::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    POINT pt = {x, y};
    RECT rcClient;

    // If we're dragging, update the the window sizes
    if (m_fDragging)
    {
        GetClientRect(m_hwnd, &rcClient);

        // Make sure the tree is still a little bit visible
        if (rcClient.bottom - pt.y > 32)
        {
            m_cSize = rcClient.bottom - pt.y;
            ResizeBorderDW(0, 0, FALSE);
        }
    }

}

void CBodyBar::OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    if (m_fDragging)
    {
        ReleaseCapture();
        m_fDragging = FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\bodyutil.h ===
/*
 *    b o d y u t i l . h
 *    
 *    Purpose:
 *        Utility functions for body
 *
 *  History
 *      September '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _BODYUTIL_H
#define _BODYUTIL_H

interface IHTMLDocument2;
interface IHTMLElement;
interface IOleCommandTarget;

HRESULT HrCmdTgtUpdateToolbar(IOleCommandTarget *pCmdTarget, HWND hwndToolbar);
HRESULT HrConvertHTMLToPlainText(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf);
HRESULT HrCheckForFramesets(LPMIMEMESSAGE pMsg, BOOL fWarnUser);
HRESULT HrStripHTMLClipboardHeader(LPSTREAM pstm, BOOL *pfIsRealCFHTML);
HRESULT HrGetSetCheck(BOOL fSet, IHTMLElement *pElem, VARIANT_BOOL *pfValue);

struct URLSUB {
    LPCTSTR pszId;
    UINT    ids;    
};

HRESULT SubstituteURLs(IHTMLDocument2 *pDoc, const URLSUB *rgUrlSub, int cUrlSub);

#endif //_BODYUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\frntbody.cpp ===
/*
 *    f r n t b o d y . c p p
 *    
 *    Purpose:
 *        Implementation of CFrontBody object. Derives from CBody to host the trident
 *        control.
 *
 *  History
 *      April '97: erican - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
 */

#include <pch.hxx>
#include <wininet.h>
#include <resource.h>
#include "strconst.h"
#include "xpcomm.h"
#include "browser.h"
#include "frntbody.h"
#include <wininet.h>
#include <mshtml.h>
#include <goptions.h>
#include <thormsgs.h>
#include <spoolapi.h>
#include <notify.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "url.h"
#include "bodyutil.h"
#include "mimeutil.h"
#include "instance.h"
#include "storutil.h"
#include "demand.h"
#include "menures.h"
#include "multiusr.h"
#include "htmlhelp.h"
#include "shared.h"
#include "oetag.h"
#include "subscr.h"

#define IsBrowserMode() ( g_dwBrowserFlags & 0x07 )

CFrontBody::CFrontBody(FOLDERTYPE ftType, IAthenaBrowser *pBrowser) : CMimeEditDocHost( /*MEBF_NOSCROLL*/ 0)  //$27661: turn off noscroll
{

    if (pBrowser)
    {
        m_pBrowser = pBrowser;
        m_pBrowser->AddRef();
    }

    m_phlbc = NULL;
    m_hwndOwner = NULL;
    m_pTag = 0;
    m_fOEFrontPage = TRUE;
}

CFrontBody::~CFrontBody()
{
    if (m_pTag)
    {
        m_pTag->OnFrontPageClose();
        m_pTag->Release();
        m_pTag = NULL;
    }
    SafeRelease(m_pBrowser);
    SafeRelease(m_phlbc);
}

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////
HRESULT CFrontBody::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if (!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IHlinkFrame))
        {
        *lplpObj = (IHlinkFrame *)this;
        AddRef();
        return NOERROR;
        }

    if (IsEqualIID(riid, IID_IServiceProvider))
        {
        *lplpObj = (IServiceProvider *)this;
        AddRef();
        return NOERROR;
        }

    if (IsEqualIID(riid, IID_IElementBehaviorFactory))
        {
        *lplpObj = (IElementBehaviorFactory *)this;
        AddRef();
        return NOERROR;
        }

    return CMimeEditDocHost::QueryInterface(riid, lplpObj);
}

ULONG CFrontBody::AddRef()
{
    return CMimeEditDocHost::AddRef();
}

ULONG CFrontBody::Release()
{
    return CMimeEditDocHost::Release();
}


////////////////////////////////////////////////////////////////////////
//
//  IHlinkFrame
//
////////////////////////////////////////////////////////////////////////
HRESULT CFrontBody::SetBrowseContext(LPHLINKBROWSECONTEXT phlbc)
{
    ReplaceInterface(m_phlbc, phlbc);
    return NOERROR;
}

HRESULT CFrontBody::GetBrowseContext(LPHLINKBROWSECONTEXT  *pphlbc)
{
    if (pphlbc == NULL)
        return E_INVALIDARG;

    *pphlbc = m_phlbc;
    if (m_phlbc)
        m_phlbc->AddRef();
    return NOERROR;
}

static const struct {
    LPCWSTR pwszCmd;
    UINT    uCmd;
} s_rgCmdLookup[] = 
{
    { L"readMail",       ID_GO_INBOX },
    { L"newMessage",     ID_NEW_MSG_DEFAULT },
    { L"readNews",       ID_GO_NEWS },
    { L"subscribeNews",  ID_NEWSGROUPS },
    { L"addrBook",       ID_ADDRESS_BOOK },
    { L"findAddr",       ID_FIND_PEOPLE },
    { L"newNewsAccount", ID_CREATE_NEWS_ACCOUNT },
    { L"newMailAccount", ID_CREATE_MAIL_ACCOUNT },
    { L"help",           ID_HELP_CONTENTS},
    { L"newNewsMessage", ID_NEW_NEWS_MESSAGE},
    { L"newUser",        ID_NEW_IDENTITY},
    { L"switchUser",     ID_SWITCH_IDENTITY},
    { L"noop",           ID_NOOP},
    { L"findMessage",    ID_FIND_MESSAGE},
    { L"logoff",         ID_LOGOFF_IDENTITY},
    { L"manageUser",     ID_MANAGE_IDENTITIES},

};

HRESULT CFrontBody::Navigate(DWORD grfHLNF, LPBC pbc, LPBINDSTATUSCALLBACK pbsc, LPHLINK phlNavigate)
{ 
    HRESULT         hr;
    LPWSTR          pwszURL = NULL,
                    pwszCmd = NULL;
    HINSTANCE       hInst;
    WCHAR           wsz[CCHMAX_STRINGRES],
                    wszErr[CCHMAX_STRINGRES+INTERNET_MAX_URL_LENGTH+1];
    CStringParser   sp;

    IF_FAILEXIT(hr = phlNavigate->GetStringReference(HLINKGETREF_ABSOLUTE, &pwszURL, NULL));
    if (pwszURL)
    {
        if (!StrCmpNIW(pwszURL, L"oecmd:", 6))
        {
            pwszCmd = pwszURL + 6;
            for (int i = 0; i < ARRAYSIZE(s_rgCmdLookup); i++)
            {
                if (!StrCmpNIW(pwszCmd, s_rgCmdLookup[i].pwszCmd, lstrlenW(s_rgCmdLookup[i].pwszCmd)))
                {
                    switch (s_rgCmdLookup[i].uCmd)
                    {
                        case ID_HELP_CONTENTS:
                        {
                            LPSTR pszCmd = NULL;

                            pwszCmd += ARRAYSIZE(s_rgCmdLookup[i].pwszCmd);
                            IF_NULLEXIT(pszCmd = PszToANSI(CP_ACP, pwszCmd));

                            sp.Init(pszCmd, lstrlen(pszCmd), 0);
                            sp.ChParse("(");
                            sp.ChParse(")");
                            OEHtmlHelp(GetTopMostParent(m_hwnd), c_szCtxHelpFileHTML, HH_DISPLAY_TOPIC, (DWORD_PTR) (sp.CchValue() ? sp.PszValue() : NULL));
                            MemFree(pszCmd);
                            break;
                        }
                        
                        case ID_CREATE_MAIL_ACCOUNT:
                        case ID_CREATE_NEWS_ACCOUNT:
                            _CreateNewAccount(s_rgCmdLookup[i].uCmd == ID_CREATE_MAIL_ACCOUNT);
                            // handle account creation internally
                            break;
                        
                        default:
                            PostMessage(m_hwndOwner, WM_COMMAND, s_rgCmdLookup[i].uCmd, 0L);
                    }
                    
                    SetStatusText(NULL);
                    hr = S_OK;
                    goto exit;
                }
            }
            AssertSz(0, "Navigation request to unknown oecmd link");
            hr = E_FAIL;
        }
        else
        {
            LPSTR   pszURL = NULL;
            TCHAR   sz[CCHMAX_STRINGRES],
                    szErr[CCHMAX_STRINGRES+INTERNET_MAX_URL_LENGTH+1];

            IF_NULLEXIT(pszURL = PszToANSI(CP_ACP, pwszURL));

            hInst = ShellExecute(m_hwndOwner, NULL, pszURL, NULL, NULL, SW_SHOW);
            if (hInst <= (HINSTANCE)HINSTANCE_ERROR)
            {
                LoadString(g_hLocRes, idsErrURLExec, sz, ARRAYSIZE(sz));
                wnsprintf(szErr, ARRAYSIZE(szErr), sz, pszURL);
                
                // load title into wsz. We don't use AthMsgBox as our string maybe too long. AthMsgBox
                // will truncate at CCHMAX_STRINGRES.
                LoadString(g_hLocRes, idsAthena, sz, ARRAYSIZE(sz));
                MessageBox(m_hwndOwner, szErr, sz, MB_OK);
            }
            MemFree(pszURL);
        }
    }

exit:
    if (pwszURL)
        CoTaskMemFree(pwszURL);
    return hr;
}

HRESULT CFrontBody::OnNavigate(DWORD grfHLNF, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved)
{
    return E_NOTIMPL;
}

HRESULT CFrontBody::UpdateHlink(ULONG uHLID, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName)
{
    return E_NOTIMPL;
}
 
////////////////////////////////////////////////////////////////////////
//
//  IServiceProvider
//
////////////////////////////////////////////////////////////////////////
HRESULT CFrontBody::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, IID_IHlinkFrame))
        return QueryInterface(riid, ppvObject);

    if (IsEqualGUID(guidService, IID_IHlinkFrame))
        return QueryInterface(riid, ppvObject);

    if (IsEqualGUID(guidService, SID_SElementBehaviorFactory))
        return QueryInterface(riid, ppvObject);

    return E_NOINTERFACE;
}

////////////////////////////////////////////////////////////////////////
//
//  CDocHost
//
////////////////////////////////////////////////////////////////////////

void CFrontBody::OnDocumentReady()
{
    URLSUB rgUrlSub[] = { 
                        { "msnlink", idsHelpMSWebHome }
                        };

    // turn on link-tabbing for the front-page
    if (m_pCmdTarget)
    {
        VARIANTARG  va;

        va.vt = VT_BOOL;
        va.boolVal = VARIANT_TRUE;

        m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_TABLINKS, 0, &va, NULL);
    }

    // #42164
    // we defer-show the OE-front page via script. If an IEAK person overrides this
    // with a custom front-page, then we show as soon as we go document ready
    if (!m_fOEFrontPage)
        HrShow(TRUE);
    else
    {
        // if is is the std. OE page, then replace URL's
        SubstituteURLs(m_pDoc, rgUrlSub, ARRAYSIZE(rgUrlSub));
    }
}

////////////////////////////////////////////////////////////////////////
//
//  PUBLIC
//
////////////////////////////////////////////////////////////////////////

HRESULT CFrontBody::HrInit(HWND hwnd)
{
    m_hwndOwner = hwnd;
    return CMimeEditDocHost::HrInit(hwnd, IBOF_TABLINKS, NULL);
}

HRESULT CFrontBody::HrLoadPage()
{
    HRESULT             hr = S_OK;
    
    // bobn: brianv says we have to take this out...
    /*if (IsBrowserMode())
    {
        hr = HrLoadURL("res://msoeres.dll/example.eml");
        m_fOEFrontPage = FALSE;
        g_dwBrowserFlags = 0;
    }
    else*/
    {
        DWORD               cbData;
        TCHAR               szURL[INTERNET_MAX_URL_LENGTH + 1];
        TCHAR               *pszUrl;
        LPSTR               pszUrlFree=NULL;

        *szURL = 0;
        cbData = sizeof(szURL);
        AthUserGetValue(NULL, c_szFrontPagePath, NULL, (LPBYTE)szURL, &cbData);
        if (*szURL)
        {
            pszUrl = szURL;
            m_fOEFrontPage = FALSE;
        }
        else
        {
            pszUrlFree = PszAllocResUrl(g_dwAthenaMode & MODE_NEWSONLY ? "frntnews.htm" : "frntpage.htm");
            pszUrl = pszUrlFree;
        }

        hr = HrLoadURL(pszUrl);

        SafeMemFree(pszUrlFree);
    }
    return hr;
}



HRESULT CFrontBody::SetStatusText(LPCOLESTR pszW)
{
    WCHAR   wszRes[CCHMAX_STRINGRES];
    LPWSTR  pszStatusW=0;
    HRESULT hr;

    if (pszW && !StrCmpNIW(pszW, L"oecmd:", 6))
    {
        for (int i = 0; i < ARRAYSIZE(s_rgCmdLookup); i++)
        {
            if (!StrCmpNIW(pszW+6, s_rgCmdLookup[i].pwszCmd, lstrlenW(s_rgCmdLookup[i].pwszCmd)))
            {
                *wszRes = 0;
                LoadStringWrapW(g_hLocRes, MH(s_rgCmdLookup[i].uCmd), wszRes, ARRAYSIZE(wszRes));

                // If this fails, worse that happens is that the status text is nulled.
                pszStatusW = PszDupW(wszRes);
                pszW = pszStatusW;
                break;
            }
        }
    }

    hr = CMimeEditDocHost::SetStatusText(pszW);
    MemFree(pszStatusW);
    return hr;
}





HRESULT CFrontBody::_CreateNewAccount(BOOL fMail)
{
    IImnAccount     *pAcct=0,
                    *pAcctDef;
    FOLDERID        id;
    DWORD           dwServer=0;
    CHAR            rgch[CCHMAX_ACCOUNT_NAME];
    HRESULT         hr;
    DWORD           dwPropGet,
                    dwPropSet;

    // create a new account object
    hr = g_pAcctMan->CreateAccountObject(fMail ? ACCT_MAIL : ACCT_NEWS, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // If creating a new news account, try and use default-mail information. If creating a new mail account, try
    // and use default-news information (if any). We don't use def-mail for mail accounts as the front-page only shows 
    // links for account-creation if there are 0 accounts of that type. 
    if (g_pAcctMan->GetDefaultAccount(fMail ? ACCT_NEWS : ACCT_MAIL, &pAcctDef)==S_OK)
    {
        dwPropGet = fMail ? AP_NNTP_DISPLAY_NAME : AP_SMTP_DISPLAY_NAME;
        dwPropSet = fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME;        

        if (pAcctDef->GetPropSz(dwPropGet, rgch, ARRAYSIZE(rgch))==S_OK)
            pAcct->SetPropSz(dwPropSet, rgch);

        dwPropGet = fMail ? AP_NNTP_EMAIL_ADDRESS : AP_SMTP_EMAIL_ADDRESS;
        dwPropSet = fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS;        
        
        if (pAcctDef->GetPropSz(dwPropGet, rgch, ARRAYSIZE(rgch))==S_OK)
            pAcct->SetPropSz(dwPropSet, rgch);

        pAcctDef->Release();
    }
    
    // show the account wizard dialog and allow the user to setup properties
    hr = pAcct->DoWizard(m_hwndOwner, ACCT_WIZ_MIGRATE | ACCT_WIZ_INTERNETCONNECTION |
        ACCT_WIZ_HTTPMAIL | ACCT_WIZ_OE);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // find out what servers were added
    hr = pAcct->GetServerTypes(&dwServer);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // if we added a new news or IMAP account, ask the user if they want to see the subscription dialog
    if ( ((dwServer & SRV_IMAP) || (dwServer & SRV_NNTP)) && 
        IDYES == AthMessageBoxW(m_hwndOwner, MAKEINTRESOURCEW(idsAthena),
        dwServer & SRV_NNTP ? MAKEINTRESOURCEW(idsDisplayNewsSubDlg) : MAKEINTRESOURCEW(idsDisplayImapSubDlg),
        0, MB_ICONEXCLAMATION  | MB_YESNO))
    {
        // get the account-id
        hr = pAcct->GetPropSz(AP_ACCOUNT_ID, rgch, ARRAYSIZE(rgch));
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        // find the associated node in the store
        hr = g_pStore->FindServerId(rgch, &id);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto exit;
        }

        //The user wants to download the list of newsgroups, so if we are offline, go online
        if (g_pConMan)
            g_pConMan->SetGlobalOffline(FALSE);

        // finally, show the subscription dialog
        DoSubscriptionDialog(m_hwndOwner, dwServer & SRV_NNTP, id);
    }
    
    
exit:
    ReleaseObj(pAcct);
    return hr;
}

HRESULT CFrontBody::HrClose()
{
    if (m_pTag)
    {
        m_pTag->OnFrontPageClose();
        m_pTag->Release();
        m_pTag = NULL;
    }
    SafeRelease(m_pBrowser);
    return CMimeEditDocHost::HrClose();
}



HRESULT CFrontBody::FindBehavior(LPOLESTR pchBehavior, LPOLESTR pchBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior)
{
    HRESULT hr;

    if ((StrCmpIW(pchBehavior, L"APPLICATION")==0 && StrCmpIW(pchBehaviorUrl, L"#DEFAULT#APPLICATION")==0))
    {
        if (!m_pTag)
        {
            m_pTag = new COETag(m_pBrowser, this);
            if (!m_pTag)
                return E_OUTOFMEMORY;
        }

        return m_pTag->QueryInterface(IID_IElementBehavior, (LPVOID *)ppBehavior);
    }
    return E_FAIL;
}
 

HRESULT CFrontBody::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
    pInfo->dwDoubleClick    = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags          = DOCHOSTUIFLAG_DIV_BLOCKDEFAULT|DOCHOSTUIFLAG_OPENNEWWIN|
                              DOCHOSTUIFLAG_NO3DBORDER|DOCHOSTUIFLAG_CODEPAGELINKEDFONTS;

    //This sets the flags that match the browser's encoding
    fGetBrowserUrlEncoding(&pInfo->dwFlags);
    

    // bobn: brianv says we have to take this out...
    /*if (IsBrowserMode())
      pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;*/

    pInfo->pchHostCss       = PszDupW(L"OE\\:APPLICATION { behavior:url(#DEFAULT#APPLICATION) }");
    pInfo->pchHostNS        = PszDupW(L"OE");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\bodyutil.cpp ===
/*
 *    b o d y u t i l . c p p
 *    
 *    Purpose:
 *        utility functions for body
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "demand.h"
#include <resource.h>
#include "note.h"
#include "htmlstr.h"
#include "bodyutil.h"
#include "mshtmcid.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "oleutil.h"
#include "shlwapi.h"
#include "error.h"
#include "url.h"
#include "menures.h"

ASSERTDATA


/*
 *  t y p e d e f s
 */


/*
 *  m a c r o s
 */


/*
 *  c o n s t a n t s
 */


/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */
INT_PTR FrameWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


/*
 *  f u n c t i o n s
 */

HRESULT HrCmdTgtUpdateToolbar(LPOLECOMMANDTARGET pCmdTarget, HWND hwndToolbar)
{
    HRESULT hr;
    OLECMD  rgEditCmds[]={{OLECMDID_CUT, 0},
                          {OLECMDID_COPY, 0},
                          {OLECMDID_COPY, 0},
                          {OLECMDID_PASTE, 0},
                          {OLECMDID_SELECTALL, 0},
                          {OLECMDID_UNDO, 0},
                          {OLECMDID_REDO, 0}};

    int     rgids[]     ={  ID_CUT,
                            ID_NOTE_COPY,
                            ID_COPY,
                            ID_PASTE,
                            ID_SELECT_ALL,
                            ID_UNDO,
                            ID_REDO};    

    if (!pCmdTarget || !hwndToolbar)
        return E_INVALIDARG;
    
    hr=pCmdTarget->QueryStatus(NULL, sizeof(rgEditCmds)/sizeof(OLECMD), rgEditCmds, NULL);
    if (!FAILED(hr))
        {
        for(int i=0; i<sizeof(rgEditCmds)/sizeof(OLECMD); i++)
            SendMessage(hwndToolbar, TB_ENABLEBUTTON, rgids[i], MAKELONG(rgEditCmds[i].cmdf & OLECMDF_ENABLED,0));
        }   
    return hr;
}

HRESULT HrConvertHTMLToPlainText(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf)
{
    HRESULT     hr;
    LPUNKNOWN   pUnkTrident=0;
    LPSTREAM    pstmPlain=0;
    
    if (!ppstm)
        return E_INVALIDARG;

    hr = MimeEditDocumentFromStream(pstmHtml, IID_IUnknown, (LPVOID *)&pUnkTrident);
    if (FAILED(hr))
        goto error;

    hr = HrGetDataStream(pUnkTrident, cf, &pstmPlain);
    if (FAILED(hr))
        goto error;

    *ppstm = pstmPlain;
    pstmPlain->AddRef();

error:
    ReleaseObj(pUnkTrident);
    ReleaseObj(pstmPlain);
    return hr;
}





#define CCHMAX_FRAMESEARCH  4096

HRESULT HrCheckForFramesets(LPMIMEMESSAGE pMsg, BOOL fWarnUser)
{
    TCHAR       rgchHtml[CCHMAX_FRAMESEARCH + 1];
    TCHAR       rgchWarn[CCHMAX_STRINGRES];
    LPSTREAM    pstmHtml=0,
                pstmWarning=0;
    ULONG       cb=0;    
    HRESULT     hr=S_OK;
    HBODY       hBody;

    if (!pMsg)      // no work
        return S_OK;

    pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstmHtml, &hBody);

    if (pstmHtml==NULL)
        goto cleanup;

    HrRewindStream(pstmHtml);

    pstmHtml->Read(rgchHtml, CCHMAX_FRAMESEARCH, &cb);
    rgchHtml[cb]=0;

    if (!StrStrIA(rgchHtml, _TEXT("<FRAMESET")))
        goto cleanup;

    if (fWarnUser)
        {
        // if send current document or forwarding, then we give the user a chance
        if (DialogBox(g_hLocRes, MAKEINTRESOURCE(iddFrameWarning), g_hwndInit, FrameWarnDlgProc)==IDOK)
            {
            hr = S_READONLY;
            goto cleanup;
            }
        }

    // if the body contains a frameset tag, let's make this an attachment
    // and set the body to some warning
    hr = MimeOleCreateVirtualStream(&pstmWarning);
    if (FAILED(hr))
        goto cleanup;

    if (!LoadString(g_hLocRes, idsHtmlNoFrames, rgchWarn, ARRAYSIZE(rgchWarn)))
        {
        hr = E_OUTOFMEMORY;
        goto cleanup;
        }

    hr = pstmWarning->Write(rgchWarn, lstrlen(rgchWarn), NULL);
    if (FAILED(hr))
        goto cleanup;

    hr = pMsg->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstmWarning, NULL);
    if (FAILED(hr))
        goto cleanup;

    hr = pMsg->AttachObject(IID_IStream, pstmHtml, &hBody);
    if (FAILED(hr))
        goto cleanup;

    hr = MimeOleSetBodyPropA(pMsg, hBody, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, STR_MIME_TEXT_HTML);
    if (FAILED(hr))
        goto cleanup;

cleanup:
    ReleaseObj(pstmHtml);
    ReleaseObj(pstmWarning);
    return hr;
}



INT_PTR FrameWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_COMMAND)
        {
        int id = GET_WM_COMMAND_ID(wParam, lParam);

        if (id == IDOK || id  == IDCANCEL)
            {
            EndDialog(hwnd, id);
            return TRUE;
            }
        }
    return FALSE;
}


static const CHAR c_szStartHTML[] = "StartHTML:";

HRESULT HrStripHTMLClipboardHeader(LPSTREAM pstm, BOOL *pfIsRealCFHTML)
{
    CHAR    rgch[4096];
    LPSTR   lpsz;
    ULONG   cb,
            uPosRead,
            uPosWrite,
            cbNewSize;
    ULARGE_INTEGER  ui;
    HRESULT hr=S_OK;

    // scan the first 200 bytes for "StartHTML:" in the pre-block
    *rgch=0;
    pstm->Read(rgch, 200, &cb);
    rgch[cb] = 0;

    if (pfIsRealCFHTML)
        *pfIsRealCFHTML = FALSE;
    
    HrGetStreamSize(pstm, &cbNewSize);

    lpsz = StrStrIA(rgch, c_szStartHTML);
    if (!lpsz)
        return S_OK;

    cb = StrToIntA(lpsz + ARRAYSIZE(c_szStartHTML)-sizeof(CHAR));
    if (cb==0 || cb > cbNewSize)   // sanity check. Offset can't be bigger than the stream!
        return S_OK;

    if (pfIsRealCFHTML)
        *pfIsRealCFHTML = TRUE;

    // cb contains the offset of the HTML. Start shifting the data left
    uPosRead = cb;
    uPosWrite = 0;
    cbNewSize-=cb;  // calc new length of stream

    while(cb)
        {
        hr = HrStreamSeekSet(pstm, uPosRead);
        if (FAILED(hr))
            goto error;

        hr = pstm->Read(rgch, ARRAYSIZE(rgch), &cb);
        if (FAILED(hr))
            goto error;

        hr = HrStreamSeekSet(pstm, uPosWrite);
        if (FAILED(hr))
            goto error;

        hr = pstm->Write(rgch, cb, NULL);
        if (FAILED(hr))
            goto error;

        uPosRead+=cb;
        uPosWrite+=cb;
        }

    // force the new stream length
    ui.LowPart = cbNewSize;
    ui.HighPart = 0;
    
    hr = pstm->SetSize(ui);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}



HRESULT SubstituteURLs(IHTMLDocument2 *pDoc, const URLSUB *rgUrlSub, int cUrlSub)
{
    IHTMLElement        *pElem;
    IHTMLAnchorElement  *pAnchor;
    BSTR                 bstr;
    TCHAR                szURL[INTERNET_MAX_URL_LENGTH];
    int                  i;
    HRESULT              hr = S_OK;

    for (i = 0; i < cUrlSub; i++)
        {
        if (SUCCEEDED(hr = URLSubLoadStringA(rgUrlSub[i].ids, szURL, ARRAYSIZE(szURL), URLSUB_ALL, NULL)))
            {
            if (SUCCEEDED(hr = HrLPSZToBSTR(szURL, &bstr)))
                {
                if (SUCCEEDED(hr = HrGetElementImpl(pDoc, rgUrlSub[i].pszId, &pElem)))
                    {
                    if (SUCCEEDED(hr = pElem->QueryInterface(IID_IHTMLAnchorElement, (LPVOID*)&pAnchor)))
                        {
                        hr = pAnchor->put_href(bstr);
                        pAnchor->Release();
                        }
                    pElem->Release();
                    }
                SysFreeString(bstr);
                }
            }
        }
    return hr;
}

HRESULT HrGetSetCheck(BOOL fSet, IHTMLElement *pElem, VARIANT_BOOL *pfValue)
{
    HRESULT                     hr;
    IHTMLOptionButtonElement   *pCheck = NULL;

    Assert(pfValue);

    pElem->QueryInterface(IID_IHTMLOptionButtonElement, (LPVOID*)&pCheck);
    if (pCheck)
        {
        if (fSet)
            {
            hr = pCheck->put_checked(*pfValue);
            }
        else
            {
            hr = pCheck->get_checked(pfValue);
            }
        pCheck->Release();
        }
    else
        hr = E_FAIL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\frntbody.h ===
#ifndef _FRNTBODY_H
#define _FRNTBODY_H

// for IBodyOptions
#include "mehost.h"
#include "hlink.h"

interface INotify;
interface IAthenaBrowser;
class COETag;

class CFrontBody :
    public CMimeEditDocHost,
    public IHlinkFrame,
    public IServiceProvider,
    public IElementBehaviorFactory
{
public:
    CFrontBody(FOLDERTYPE ftType, IAthenaBrowser *pBrowser);
    virtual ~CFrontBody();
        
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IHlinkFrame
    virtual HRESULT STDMETHODCALLTYPE SetBrowseContext(LPHLINKBROWSECONTEXT phlbc);
    virtual HRESULT STDMETHODCALLTYPE GetBrowseContext(LPHLINKBROWSECONTEXT  *pphlbc);
    virtual HRESULT STDMETHODCALLTYPE Navigate(DWORD grfHLNF, LPBC pbc, LPBINDSTATUSCALLBACK pbsc, LPHLINK phlNavigate);
    virtual HRESULT STDMETHODCALLTYPE OnNavigate(DWORD grfHLNF, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved);
    virtual HRESULT STDMETHODCALLTYPE UpdateHlink(ULONG uHLID, LPMONIKER pmkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName);

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // IOleInPlaceFrame
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR pszW);

    // CDocHost overrides
    virtual void OnDocumentReady();
    virtual HRESULT STDMETHODCALLTYPE HrClose();

    // IElementBehaviorFactory
    virtual HRESULT STDMETHODCALLTYPE FindBehavior(LPOLESTR pchBehavior, LPOLESTR pchBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior);

    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);

    HRESULT HrInit(HWND hwnd);
    HRESULT HrLoadPage();

private:
    IAthenaBrowser      *m_pBrowser;
    LPHLINKBROWSECONTEXT m_phlbc;
    HWND                 m_hwndOwner;
    DWORD                m_dwAdvise;
    COETag              *m_pTag;
    BOOL                m_fOEFrontPage;

    HRESULT _CreateNewAccount(BOOL fMail);
};

#endif // _FRNTBODY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\header.cpp ===
//*************************************************
//     h e a d e r . c p p
//
//     Purpose:
//         implements Header UI for Read|SendNote
//
//     Owner:
//         brettm.
//
//   History:
//       July '95: Created
//
//     Copyright (C) Microsoft Corp. 1993, 1994.
//*************************************************

#include <pch.hxx>
#include <richedit.h>
#include <resource.h>
#include <thormsgs.h>
#include "oleutil.h"
#include "fonts.h"
#include "error.h"
#include "header.h"
#include "options.h"
#include "note.h"
#include "ipab.h"
#include "addrobj.h"
#include "hotlinks.h"
#include <mimeole.h>
#include <secutil.h>
#include <xpcomm.h>
#include "menuutil.h"
#include "shlwapi.h"
#include "envcid.h"
#include "ourguid.h"
#include "mimeutil.h"
#include "strconst.h"
#include "mailutil.h"
#include "regutil.h"
#include "spoolapi.h"
#include "init.h"
#include "instance.h"
#include "attman.h"
#include "envguid.h"
#include <inetcfg.h>        //ICW
#include <pickgrp.h>
#include "menures.h"
#include "storecb.h"
#include "mimeolep.h"
#include "multlang.h"
#include "mirror.h"
#include "seclabel.h"
#include "shlwapip.h"
#include "reutil.h"
#include <iert.h>
#include "msgprop.h"
#include "demand.h"

ASSERTDATA

extern UINT GetCurColorRes(void);

class CFieldSizeMgr : public CPrivateUnknown,
                      public IFontCacheNotify,
                      public IConnectionPoint
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // IFontCacheNotify
    HRESULT STDMETHODCALLTYPE OnPreFontChange(void);
    HRESULT STDMETHODCALLTYPE OnPostFontChange(void);

    // IConnectionPoint
    HRESULT STDMETHODCALLTYPE GetConnectionInterface(IID *pIID);        
    HRESULT STDMETHODCALLTYPE GetConnectionPointContainer(IConnectionPointContainer **ppCPC);
    HRESULT STDMETHODCALLTYPE Advise(IUnknown *pUnkSink, DWORD *pdwCookie);        
    HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwCookie);        
    HRESULT STDMETHODCALLTYPE EnumConnections(IEnumConnections **ppEnum);

    // CPrivateUnknown
    HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    int GetScalingFactor(void);
    void ResetGlobalSizes(void);
    HRESULT Init(void);

    // This one should only be called from headers' OnPostFontChange calls
    BOOL FontsChanged(void) {return m_fFontsChanged;}

    CFieldSizeMgr(IUnknown *pUnkOuter=NULL);
    ~CFieldSizeMgr();

private:
    IUnknownList       *m_pAdviseRegistry;
    CRITICAL_SECTION    m_rAdviseCritSect;
    BOOL                m_fFontsChanged;
    DWORD               m_dwFontNotify;
};

// **********************************************************
// ***** Debug stuff for handling painting and resizing *****
// **********************************************************
const int PAINTING_DEBUG_LEVEL = 4;
const int RESIZING_DEBUG_LEVEL = 8;
const int GEN_HEADER_DEBUG_LEVEL = 16;

#ifdef DEBUG 

class StackRegistry {
public:
    StackRegistry(LPSTR pszTitle, INT_PTR p1 = 0, INT_PTR p2 = 0, INT_PTR p3 = 0, INT_PTR p4 = 0, INT_PTR p5 = 0);
    ~StackRegistry();

private:
    int     m_StackLevel;
    CHAR    m_szTitle[256+1];

    static int      gm_cStackLevel;
    static int      gm_strLen;
    static LPSTR    gm_Indent;
};

int StackRegistry::gm_cStackLevel = 0;
LPSTR StackRegistry::gm_Indent = "------------------------------";
int StackRegistry::gm_strLen = lstrlen(gm_Indent);

StackRegistry::StackRegistry(LPSTR pszTitle, INT_PTR p1, INT_PTR p2, INT_PTR p3, INT_PTR p4, INT_PTR p5)
{
    gm_cStackLevel++;
    m_StackLevel = (gm_cStackLevel > gm_strLen) ? gm_strLen : gm_cStackLevel;
    StrCpyN(m_szTitle, pszTitle, ARRAYSIZE(m_szTitle));
    m_szTitle[256] = 0;

    if (1 == gm_cStackLevel)
        DOUTL(RESIZING_DEBUG_LEVEL, "\n*********** BEGIN TRACE ***********");
    
    DOUTL(RESIZING_DEBUG_LEVEL, "IN*** %s%s - %x, %x, %x, %x, %x", gm_Indent+gm_strLen-m_StackLevel, m_szTitle, p1, p2, p3, p4, p5);
}

StackRegistry::~StackRegistry()
{
    DOUTL(RESIZING_DEBUG_LEVEL, "OUT** %s%s", gm_Indent+gm_strLen-m_StackLevel, m_szTitle);

    if (1 == gm_cStackLevel)
        DOUTL(RESIZING_DEBUG_LEVEL, "************ END TRACE ************\n");
    
    gm_cStackLevel--;
    Assert(gm_cStackLevel >= 0);
}


#define STACK   StackRegistry stack

#else

// BUGBUG (neilbren) WIN64
// Figure out when __noop was introduced (MSC_VER ?) so we don't have to key off of WIN64
#define STACK   __noop

#endif

// ******************************
// ***** End of debug stuff *****
// ******************************


// c o n s t a n t s
const DWORD SETWINPOS_DEF_FLAGS = SWP_NOZORDER|SWP_NOACTIVATE;

#define GET_WM_COMMAND_ID(wp, lp)   LOWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp) (HWND)(lp)
#define GET_WM_COMMAND_CMD(wp, lp)  HIWORD(wp)
#define WC_ATHHEADER                wszHeaderWndClass
#define RGB_TRANSPARENT             RGB(255,0,255)
#define HDM_TESTQUERYPRI            (WM_USER + 1)
#define cxBorder                    (GetSystemMetrics(SM_CXBORDER))
#define cyBorder                    (GetSystemMetrics(SM_CYBORDER))

// HDRCB_VCARD must remain -1 and all others must be negative
enum {
    HDRCB_VCARD = -1,
    HDRCB_SIGNED = -2,
    HDRCB_ENCRYPT = -3,
    HDRCB_NO_BUTTON = -4
};

// WARNING::    This next macro is only to be used with g_rgBtnInd inside the CNoteHdr class.
//              Make sure that they match the entries in g_rgBtnInd
#define BUTTON_STATES               m_fDigSigned,   m_fEncrypted,   m_fVCard
#define BUTTON_USE_IN_COMPOSE       FALSE,          FALSE,          TRUE

static const DWORD g_rgBtnInd[] = {HDRCB_SIGNED, HDRCB_ENCRYPT, HDRCB_VCARD};

static const int cchMaxWab                  = 512;
static const int cxTBButton                 = 16;
static const int BUTTON_BUFFER              = 2;
static const int cxBtn                      = 16;
static const int cyBtn                      = cxBtn;
static const int cxFlags                    = 12;
static const int cyFlags                    = cxFlags;
static const int cxFlagsDelta               = cxFlags + 4;
static const int MAX_ATTACH_PIXEL_HEIGHT    = 50;
static const int ACCT_ENTRY_SIZE            = CCHMAX_ACCOUNT_NAME + CCHMAX_EMAIL_ADDRESS + 10;
static const int INVALID_PHCI_Y             = -1;
static const int cMaxRecipMenu              = (ID_ADD_RECIPIENT_LAST-ID_ADD_RECIPIENT_FIRST);
static const int NUM_COMBO_LINES            = 9;
static const int MAX_RICHEDIT_LINES         = 4;
static const int DEFER_WINDOW_SIZE          = MAX_HEADER_COMP + 1 + 1 + 1 + 5;   // +1=header window, +1=field resize, +1 toolbar
static const LPTSTR GRP_DELIMITERS          = " ,\t;\n\r";

#define c_wszEmpty L""
#define c_aszEmpty ""


// t y p e d e f s

typedef struct TIPLOOKUP_tag
{
    int idm;
    int ids;
} TIPLOOKUP;

typedef struct CMDMAPING_tag
{
    DWORD   cmdIdOffice,
            cmdIdOE;
} CMDMAPING;

typedef struct PERSISTHEADER_tag
{
    DWORD   cbSize;         // size so we can version the stuct
    DWORD   dwRes1,         // padding just in case...
            dwRes2;
} PERSISTHEADER;

#define cchMaxSubject               256

typedef struct WELLINIT_tag
{
    INT             idField;
    ULONG           uMAPI;
} WELLINIT, *PWELLINIT;


// s t a t i c   d a t a
static HIMAGELIST       g_himlStatus = 0,
                        g_himlBtns = 0,
                        g_himlSecurity = 0;

static TCHAR            g_szStatFlagged[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatLowPri[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatHighPri[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatWatched[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatIgnored[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatFormat1[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatFormat2[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatFormat3[cchHeaderMax+1] = c_aszEmpty,
                        g_szStatUnsafeAtt[cchHeaderMax+1] = c_aszEmpty;

static CFieldSizeMgr   *g_pFieldSizeMgr = NULL;
static WNDPROC          g_lpfnREWndProc = NULL;
static CHARFORMAT       g_cfHeader = {0};
static int              g_cyFont = 0,
                        g_cyLabelHeight = 0;

static char const       szButton[]="BUTTON";
static WCHAR const      wszHeaderWndClass[]=L"OE_Envelope";



// KEEP in ssync with c_rgTipLookup
const TBBUTTON    c_btnsOfficeEnvelope[]=
{ 
    {TBIMAGE_SEND_MAIL,         ID_SEND_NOW,            TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0,0}, 0, -1},
    __TOOLBAR_SEP__,
    { TBIMAGE_CHECK_NAMES,      ID_CHECK_NAMES,         TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0, 0}, 0, -1},
    { TBIMAGE_ADDRESS_BOOK,     ID_ADDRESS_BOOK,        TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0, 0}, 0, -1},
    __TOOLBAR_SEP__,
    {TBIMAGE_SET_PRIORITY,      ID_SET_PRIORITY,        TBSTATE_ENABLED,    TBSTYLE_DROPDOWN,   {0,0}, 0, -1},
    {TBIMAGE_INSERT_ATTACHMENT, ID_INSERT_ATTACHMENT,   TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0,0}, 0, -1},
    __TOOLBAR_SEP__,
    { TBIMAGE_ENVELOPE_BCC,     ID_ENV_BCC,             TBSTATE_ENABLED,    TBSTYLE_BUTTON,     {0,0}, 0, -1}
};

// KEEP in ssync with c_btnsOfficeEnvelope
const TIPLOOKUP     c_rgTipLookup[] = 
{
    {ID_SEND_NOW, idsSendMsgTT},
    {ID_CHECK_NAMES, idsCheckNamesTT},
    {ID_ADDRESS_BOOK, idsAddressBookTT},
    {ID_SET_PRIORITY, idsSetPriorityTT},
    {ID_INSERT_ATTACHMENT, idsInsertFileTT},
    {ID_ENV_BCC, idsEnvBccTT}
};

// Prototypes
HRESULT ParseFollowup(LPMIMEMESSAGE pMsg, LPTSTR* ppszGroups, BOOL* pfPoster);
DWORD HdrGetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD dwNumChars, BOOL fSelection);
void HdrSetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplace);

// i n l i n e s

void HdrSetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplace)
{
    if (!hwnd)
        return;

    PHCI phci = (HCI*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    AssertSz(phci, "We are calling HdrSetRichEditText on a non-richedit control");

    SetRichEditText(hwnd, pwchBuff, fReplace, phci->pDoc, (phci->dwFlags & HCF_READONLY));
}

DWORD HdrGetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD dwNumChars, BOOL fSelection)
{
    if (!hwnd)
        return 0;

    PHCI phci = (HCI*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    AssertSz(phci, "We are calling HdrSetRichEditText on a non-richedit control");

    return GetRichEditText(hwnd, pwchBuff, dwNumChars, fSelection, phci->pDoc);
}

inline void GetRealClientRect(HWND hwnd, RECT *prc)
{
    GetClientRect(hwnd, prc);
    AdjustWindowRectEx(prc, GetWindowLong(hwnd, GWL_STYLE), FALSE, GetWindowLong(hwnd, GWL_EXSTYLE));
}

inline int GetCtrlWidth(HWND hwnd)
{
    RECT rc;
    GetWindowRect(hwnd, &rc);
    return rc.right - rc.left;
}

inline int GetControlSize(BOOL fIncludeBorder, int cLines)
{
    int size = cLines * g_cyFont;

    // If borders, include the metrics
    if (fIncludeBorder)
        size += 7;

    return size;
}

inline int GetCtrlHeight(HWND hwnd)
{
    DWORD id = GetWindowLong(hwnd, GWL_ID);
    if (idFromCombo == id)
    {
        return GetControlSize(TRUE, 1);
    }
    else
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        return rc.bottom - rc.top;
    }
}

inline int GetStatusHeight(int cLines) {return ((cyBtn<g_cyFont)?GetControlSize(TRUE, cLines):((cyBtn-4)*cLines + 2*cyBorder + 6)); }
inline int CYOfStatusLine()     { return ((cyBtn<g_cyFont)?g_cyFont:(cyBtn - 4)); }
inline int ControlXBufferSize() { return 10 * cxBorder; }
inline int ControlYBufferSize() { return 4 * cyBorder; }
inline int PaddingOfLabels()    { return 2 * ControlXBufferSize(); }
inline int CXOfButtonToLabel()  { return 4*cxBorder + cxBtn; }

inline BOOL ButtonInLabels(int iBtn) { return (iBtn > HDRCB_VCARD); }
inline HFONT GetFont(BOOL fBold) { return HGetSystemFont(fBold?FNT_SYS_ICON_BOLD:FNT_SYS_ICON); }


static IMSGPRIORITY priLookup[3]=
{    IMSG_PRI_LOW,
    IMSG_PRI_NORMAL,
    IMSG_PRI_HIGH
};

#define HCI_ENTRY(flg,opt,ide,idb,idsl,idse,idst) \
    { \
        flg, opt, \
        ide, idb, \
        idsl, idse, idst, \
        NOFLAGS, TRUE, \
        NULL, NULL, \
        0, 0, 0, 0, \
        c_wszEmpty, c_wszEmpty \
    }

static int rgIDTabOrderMailSend[] =
{
    idFromCombo,        idADTo,             
    idADCc,             idADBCc,            
    idTXTSubject,       idwAttachWell
};

static HCI  rgMailHeaderSend[]=
{

    HCI_ENTRY(HCF_COMBO|HCF_ADVANCED|HCF_BORDER,
        0,
        idFromCombo,        0,
        idsFromField,       NULL,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_ADDRWELL|HCF_BORDER,
        0,
        idADTo,             idbtnTo,
        idsToField,         idsEmptyTo,
        idsTTRecipients),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_ADDRWELL|HCF_BORDER,
        0,
        idADCc,             idbtnCc,
        idsCcField,         idsEmptyCc,
        idsTTRecipients),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_ADDRWELL|HCF_ADVANCED|HCF_BORDER,
        0,
        idADBCc,            idbtnBCc,
        idsBCcField,        idsEmptyBCc,
        idsTTRecipients),

    HCI_ENTRY(HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubject,
        idsTTSubject),

    HCI_ENTRY(HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        idsTTAttachment),
};

static int rgIDTabOrderMailRead[] =
{
    idADFrom,           idTXTDate,
    idADTo,             idADCc,
    idTXTSubject,       idwAttachWell,
    idSecurity
};

static HCI  rgMailHeaderRead[]=
{
    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADDRWELL,
        0,
        idADFrom,           0,
        idsFromField,       idsNoFromField,
        NULL),

    HCI_ENTRY(HCF_READONLY,
        0,
        idTXTDate,          0,
        idsDateField,       NULL,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADDRWELL,
        0,
        idADTo,             0,
        idsToField,         idsNoCcOrTo,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADVANCED|HCF_ADDRWELL,
        0,
        idADCc,             0,
        idsCcField,         idsNoCcOrTo,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_USECHARSET,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubjectRO,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED,          // HCF_ADVANCED will hide it when empty
        0,
        idSecurity,         0,
        idsSecurityField,   NULL,
        NULL),
};

static int rgIDTabOrderNewsSend[] =
{
    idFromCombo,        idADNewsgroups,     
    idTXTFollowupTo,    idADCc,             
    idADReplyTo,        idTXTDistribution,  
    idTXTKeywords,      idTXTSubject,       
    idwAttachWell,      idADApproved,       
    idTxtControl
};

static HCI  rgNewsHeaderSend[]=
{
    HCI_ENTRY(HCF_COMBO|HCF_ADVANCED|HCF_BORDER,
        0,
        idFromCombo,        0,
        idsNewsServer,      NULL,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_HASBUTTON|HCF_NEWSPICK|HCF_BORDER,
        0,
        idADNewsgroups,     idbtnTo,
        idsNewsgroupsField, idsEmptyNewsgroups,
        idsTTNewsgroups),

    HCI_ENTRY(HCF_ADVANCED|HCF_HASBUTTON|HCF_NEWSPICK|HCF_MULTILINE|HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTFollowupTo,    idbtnFollowup,
        idsFollowupToField, idsEmptyFollowupTo,
        idsTTFollowup),

    HCI_ENTRY(HCF_MULTILINE|HCF_ADDRWELL|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_BORDER,
        0,
        idADCc,             idbtnCc,
        idsCcField,         idsEmptyCc,
        idsTTRecipients),

    HCI_ENTRY(HCF_ADVANCED|HCF_ADDRWELL|HCF_HASBUTTON|HCF_ADDRBOOK|HCF_BORDER,
        0,
        idADReplyTo,        idbtnReplyTo,
        idsReplyToField,    idsEmptyReplyTo,
        idsTTReplyTo),

    HCI_ENTRY(HCF_MULTILINE|HCF_ADVANCED|HCF_BORDER,
        0,
        idTXTDistribution,      0,
        idsDistributionField,   idsEmptyDistribution,
        idsTTDistribution),

    HCI_ENTRY(HCF_MULTILINE|HCF_ADVANCED|HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTKeywords,      0,
        idsKeywordsField,   idsEmptyKeywords,
        idsTTKeywords),

    HCI_ENTRY(HCF_USECHARSET|HCF_BORDER,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubject,
        idsTTSubject),

    HCI_ENTRY(HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        idsTTAttachment),

    HCI_ENTRY(HCF_ADVANCED|HCF_OPTIONAL,
        OPT_NEWSMODERATOR,
        idADApproved,       0,
        idsApprovedField,   idsEmptyApproved,
        idsTTApproved),

    HCI_ENTRY(HCF_ADVANCED|HCF_OPTIONAL,
        OPT_NEWSCONTROLHEADER,
        idTxtControl,       0,
        idsControlField,    idsEmptyControl,
        idsTTControl),

};

static int rgIDTabOrderNewsRead[] =
{
    idADFrom,           idADReplyTo,
    idTXTOrg,           idTXTDate,
    idADNewsgroups,     idTXTFollowupTo,
    idTXTDistribution,  idTXTKeywords,
    idTXTSubject,       idwAttachWell,
    idSecurity
};

static HCI  rgNewsHeaderRead[]=
{
    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADDRWELL,
        0,
        idADFrom,           0,
        idsFromField,       idsNoFromField,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED|HCF_ADDRWELL,
        0,
        idADReplyTo,        0,
        idsReplyToField,    idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED|HCF_USECHARSET,
        0,
        idTXTOrg,           0,
        idsOrgField,        idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY,
        0,
        idTXTDate,          0,
        idsDateField,       idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY,
        0,
        idADNewsgroups,     0,
        idsNewsgroupsField, idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED,
        0,
        idTXTFollowupTo,    0,
        idsFollowupToField, idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADVANCED,
        0,
        idTXTDistribution,      0,
        idsDistributionField,   idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_MULTILINE|HCF_READONLY|HCF_ADVANCED|HCF_USECHARSET,
        0,
        idTXTKeywords,      0,
        idsKeywordsField,   idsNotSpecified,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_USECHARSET,
        0,
        idTXTSubject,       0,
        idsSubjectField,    idsEmptySubjectRO,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_BORDER|HCF_ATTACH,
        0,
        idwAttachWell,      0,
        idsAttachment,      0,
        NULL),

    HCI_ENTRY(HCF_READONLY|HCF_ADVANCED,        
        0,
        idSecurity,         0,
        idsSecurityField,   NULL,
        NULL),
};


// p r o t o t y p e s
void _ValidateNewsgroups(LPWSTR pszGroups);
INT_PTR CALLBACK _PlainWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#ifdef DEBUG
void DEBUGHdrName(HWND hwnd);

void DEBUGDumpHdr(HWND hwnd, int cHdr, PHCI rgHCI)
{
    PHCI    phci;
    char    sz[cchHeaderMax+1];
    RECT    rc;
    HWND    hwndEdit;

#ifndef DEBUG_SIZINGCODE
    return;
#endif

    DOUTL(GEN_HEADER_DEBUG_LEVEL, "-----");

    for (int i=0; i<(int)cHdr; i++)
    {
        phci=&rgHCI[i];

        hwndEdit=GetDlgItem(hwnd, phci->idEdit);

        GetChildRect(hwnd, hwndEdit, &rc);
        DEBUGHdrName(hwndEdit);
        wnsprintf(sz, ARRAYSIZE(sz), "\tat:(%d,%d) \tsize:(%d,%d)\r\n", rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top);
        OutputDebugString(sz);
    }
    GetWindowRect(hwnd, &rc);
    DOUTL(GEN_HEADER_DEBUG_LEVEL, "HeaderSize: (%d,%d)\r\n-----", rc.right-rc.left, rc.bottom-rc.top);
}

void DEBUGHdrName(HWND hwnd)
{
    char    sz[cchHeaderMax+1];
    char    *psz=0;

    switch (GetDlgCtrlID(hwnd))
    {
        case idTXTSubject:
            psz="Subject";
            break;

        case idTXTOrg:
            psz="Org";
            break;

        case idADTo:
            psz="To";
            break;

        case idADCc:
            psz="Cc";
            break;

        case idADFrom:
            psz="From";
            break;

        case idTXTDate:
            psz="Date";
            break;

        case idTXTDistribution:
            psz="Distribution";
            break;

        case idADApproved:
            psz="Approved";
            break;

        case idADReplyTo:
            psz="ReplyTo";
            break;

        case idTXTKeywords:
            psz="Keywords";
            break;

        case idADNewsgroups:
            psz="NewsGroup";
            break;

        case idTXTFollowupTo:
            psz="FollowUp";
            break;

        default:
            psz="<Unknown>";
            break;
    }

    wnsprintf(sz, ARRAYSIZE(sz), "%s: ", psz);
    OutputDebugString(sz);
}
#endif

// FHeader_Init
//
// Purpose: called to init and de-init global header stuff, eg.
//          wndclasses, static data etc.
//
// Comments:
//    TODO: defer this initialisation
//
BOOL FHeader_Init(BOOL fInit)
{
    WNDCLASSW   wc={0};
    static      BOOL s_fInited=FALSE;
    BOOL        fSucceeded = TRUE;

    if (fInit)
    {
        if (s_fInited)
            goto exit;

        Assert(!g_pFieldSizeMgr);

        g_pFieldSizeMgr = new CFieldSizeMgr;
        if (!g_pFieldSizeMgr || FAILED(g_pFieldSizeMgr->Init()))
        {
            fSucceeded = FALSE;
            goto exit;
        }

        wc.style         = 0;
        wc.lpfnWndProc   = CNoteHdr::ExtCNoteHdrWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
        wc.lpszClassName = WC_ATHHEADER;

        if (!RegisterClassWrapW(&wc))
        {
            fSucceeded = FALSE;
            goto exit;
        }

        g_himlStatus=ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbHeaderStatus), cxFlags, 0, RGB_TRANSPARENT);
        if (!g_himlStatus)
        {
            fSucceeded = FALSE;
            goto exit;
        }

        g_himlBtns=ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbBtns), cxBtn, 0, RGB_TRANSPARENT);
        if (!g_himlBtns)
        {
            fSucceeded = FALSE;
            goto exit;
        }

        g_himlSecurity=ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbSecurity), cxBtn, 0, RGB_TRANSPARENT);
        if (!g_himlSecurity)
        {
            fSucceeded = FALSE;
            goto exit;
        }

        ImageList_SetBkColor(g_himlStatus, CLR_NONE);
        ImageList_SetBkColor(g_himlBtns, CLR_NONE);
        ImageList_SetBkColor(g_himlSecurity, CLR_NONE);

        AthLoadString(idsStatusFlagged, g_szStatFlagged, cchHeaderMax);
        AthLoadString(idsStatusLowPri, g_szStatLowPri, cchHeaderMax);
        AthLoadString(idsStatusHighPri, g_szStatHighPri, cchHeaderMax);
        AthLoadString(idsStatusWatched, g_szStatWatched, cchHeaderMax);
        AthLoadString(idsStatusIgnored, g_szStatIgnored, cchHeaderMax);
        AthLoadString(idsStatusFormat1, g_szStatFormat1, cchHeaderMax);
        AthLoadString(idsStatusFormat2, g_szStatFormat2, cchHeaderMax);
        AthLoadString(idsStatusFormat3, g_szStatFormat3, cchHeaderMax);        
        AthLoadString(idsStatusUnsafeAttach, g_szStatUnsafeAtt, cchHeaderMax);        

        s_fInited=TRUE;


    }
    // De-Init ******
    else
    {
        UnregisterClassWrapW(WC_ATHHEADER, g_hInst);
        if (g_himlStatus)
        {
            ImageList_Destroy(g_himlStatus);
            g_himlStatus = 0;
        }
        if (g_himlBtns)
        {
            ImageList_Destroy(g_himlBtns);
            g_himlBtns = 0;
        }
        if (g_himlSecurity)
        {
            ImageList_Destroy(g_himlSecurity);
            g_himlSecurity = 0;
        }
        s_fInited=FALSE;

        SafeRelease(g_pFieldSizeMgr);
    }

exit:
    if (!fSucceeded)
        SafeRelease(g_pFieldSizeMgr);

    return fSucceeded;
}


HRESULT CreateInstance_Envelope(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Locals
    HRESULT             hr=S_OK;
    CNoteHdr           *pNew=NULL;

    // Trace
    TraceCall("CreateInstance_Envelope");

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Invalid Arg
    Assert(NULL != ppUnknown && NULL == pUnkOuter);

    // Create
    IF_NULLEXIT(pNew = new CNoteHdr);

    // Return the Innter
    *ppUnknown = (IMsoEnvelope*) pNew;

    exit:
    // Done
    return hr;
}


CNoteHdr::CNoteHdr()
{
//    Not initialised
//    Member:                 Initialised In:
//    --------------------+---------------------------
//    m_wNoteType             Finit

    m_cRef = 1;
    m_cHCI = 0;
    m_cAccountIDs = 0;
    m_iCurrComboIndex = 0;

    m_hwnd = 0;
    m_hwndLastFocus = 0;
    m_hwndRebar = 0;

    m_pri = priNorm;    // default to Normal Pri
    m_cfAccept = CF_NULL;
    m_ntNote = OENA_COMPOSE;

    m_fMail = TRUE;
    m_fVCard = FALSE;
    m_fDirty = FALSE;
    m_fInSize = FALSE;
    m_fFlagged = FALSE;
    m_fAdvanced = FALSE;
    m_fResizing = FALSE;
    m_fUIActive = FALSE;
    m_fDigSigned = FALSE;
    m_fEncrypted = FALSE;
    m_fSkipLayout = TRUE;   // Skip layout until after load
    m_fSignTrusted = TRUE;
    m_fOfficeInit = FALSE;
    m_fStillLoading = TRUE;
    m_fEncryptionOK = TRUE;
    m_fHandleChange = TRUE;
    m_fAutoComplete = FALSE;
    m_fSendImmediate = FALSE;
    m_fVCardSave = !m_fVCard;
    m_fSecurityInited = FALSE;
    m_fAddressesChanged = FALSE;
    m_fForceEncryption = FALSE;
    m_fThisHeadDigSigned = FALSE;
    m_fThisHeadEncrypted = FALSE;
    m_fDropTargetRegister = FALSE;
    
    m_pMsg = NULL;
    m_lpWab = NULL;
    m_rgHCI = NULL;
    m_hwndTT = NULL;
    m_pTable = NULL;
    m_lpWabal = NULL;
    m_pszRefs = NULL;
    m_pMsgSend = NULL;
    m_hCharset = NULL;
    m_pAccount = NULL;
    m_hInitRef = NULL;
    m_lpAttMan = NULL;
    m_hwndParent = NULL;
    m_pAddrWells = NULL;
    m_hwndToolbar = NULL;
    m_pHeaderSite = NULL;
    m_pEnvelopeSite = NULL;
    m_pMsoComponentMgr = NULL;
    m_lpszSecurityField = NULL;
    m_ppAccountIDs = NULL;
    *m_szLastLang = 0;

    m_MarkType = MARK_MESSAGE_NORMALTHREAD;
    m_hwndOldCapture = NULL;
    m_dwCurrentBtn = HDRCB_NO_BUTTON;
    m_dwClickedBtn = HDRCB_NO_BUTTON;
    m_dwEffect = 0;
    m_cCapture = 0;
    m_dwDragType = 0;
    m_dwComponentMgrID = 0;
    m_dwIMEStartCount = 0;
    m_dwFontNotify = 0;

    m_dxTBOffset = 0;
    m_grfKeyState = 0;
    m_cxLeftMargin = 0;
    m_himl = NULL;
    m_fPoster = FALSE;

    ZeroMemory(&m_SecState, sizeof(m_SecState));
}

CNoteHdr::~CNoteHdr()
{
    Assert (m_pMsgSend==NULL);
    
    if (m_hwnd)
        DestroyWindow(m_hwnd);

    ReleaseObj(m_pTable);
    ReleaseObj(m_lpWabal);
    ReleaseObj(m_lpWab);
    SafeMemFree(m_pszRefs);
    ReleaseObj(m_pAccount);
    CleanupSECSTATE(&m_SecState);
    ReleaseObj(m_lpAttMan);
    ReleaseObj(m_pMsg);
    SafeMemFree(m_lpszSecurityField);
    
    if (m_pAddrWells)
        delete m_pAddrWells;

    if (m_himl)
        ImageList_Destroy(m_himl);

    if (m_fOfficeInit)
        HrOfficeInitialize(FALSE);

    if (m_cAccountIDs)
    {
        while (m_cAccountIDs--)
            SafeMemFree(m_ppAccountIDs[m_cAccountIDs]);
    }
    SafeMemFree(m_ppAccountIDs);
}


ULONG CNoteHdr::AddRef()
{
    return ++m_cRef;
}

ULONG CNoteHdr::Release()
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT CNoteHdr::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if (!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    else if (IsEqualIID(riid, IID_IHeader))
        *lplpObj = (LPVOID)(LPHEADER)this;

    else if (IsEqualIID(riid, IID_IMsoEnvelope))
        *lplpObj = (LPVOID)(IMsoEnvelope*)this;

    else if (IsEqualIID(riid, IID_IMsoComponent))
        *lplpObj = (LPVOID)(IMsoComponent*)this;

    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(LPPERSISTMIME)this;

    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IDropTarget))
        *lplpObj = (LPVOID)(IDropTarget*)this;

    else if (IsEqualIID(riid, IID_IFontCacheNotify))
        *lplpObj = (LPVOID)(IFontCacheNotify*)this;
    
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

// IOleCommandTarget
HRESULT CNoteHdr::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   ul;
    HWND    hwndFocus = GetFocus();
    DWORD   dwFlags = 0;
    BOOL    fFound = FALSE;

    if (!rgCmds)
        return E_INVALIDARG;

    for (int i=0; i<(int)m_cHCI; i++)
    {
        // if it's in our control-list and not a combobox
        if (hwndFocus == GetDlgItem(m_hwnd, m_rgHCI[i].idEdit) && 
            !(m_rgHCI[i].dwFlags & HCF_COMBO))
        {
            GetEditDisableFlags(hwndFocus, &dwFlags);
            fFound = TRUE;
            break;
        }
    }

    if (pguidCmdGroup == NULL)
    {
        for (ul=0;ul<cCmds; ul++)
        {
            switch (rgCmds[ul].cmdID)
            {

                case cmdidSend:
                case cmdidCheckNames:
                case cmdidAttach:
                case cmdidOptions:
                case cmdidSelectNames:
                case cmdidFocusTo:
                case cmdidFocusCc:
                case cmdidFocusSubject:
                    // office commands enabled if we have an env-site
                    rgCmds[ul].cmdf = m_pEnvelopeSite ? OLECMDF_ENABLED|OLECMDF_SUPPORTED : 0;
                    break;

                case OLECMDID_CUT:
                case OLECMDID_PASTE:
                case OLECMDID_COPY:
                case OLECMDID_UNDO:
                case OLECMDID_SELECTALL:
                    if (fFound)
                        HrQueryToolbarButtons(dwFlags, pguidCmdGroup, &rgCmds[ul]);
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
            }
        }

        return NOERROR;
    }
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        BOOL    fReadOnly = IsReadOnly(),
                fMailAndNotReadOnly = m_fMail && !fReadOnly;
        UINT    pri;

        GetPriority(&pri);

        for (ULONG ul = 0; ul < cCmds; ul++)
        {
            ULONG cmdID = rgCmds[ul].cmdID;
            if (0 != rgCmds[ul].cmdf)
                continue;

            switch (cmdID)
            {
                case ID_SELECT_RECIPIENTS:
                case ID_SELECT_NEWSGROUPS:
                case ID_INSERT_ATTACHMENT:
                    rgCmds[ul].cmdf = QS_ENABLED(!fReadOnly);
                    break;

                case ID_INSERT_CONTACT_INFO:
                    HrGetVCardState(&rgCmds[ul].cmdf);
                    break;

                case ID_ENCRYPT:
                    if(m_fForceEncryption)
                    {
                        if(!m_fDigSigned)
                            rgCmds[ul].cmdf = QS_ENABLECHECK(fMailAndNotReadOnly, m_fEncrypted);
                        else 
                            break;
                    }
                    else
                        rgCmds[ul].cmdf = QS_ENABLECHECK(fMailAndNotReadOnly, m_fEncrypted);
                    break;

                case ID_DIGITALLY_SIGN:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(!fReadOnly && 0 == (g_dwAthenaMode & MODE_NEWSONLY), m_fDigSigned);
                    break;

                case ID_SET_PRIORITY:
                case ID_POPUP_PRIORITY:
                    rgCmds[ul].cmdf = QS_ENABLED(fMailAndNotReadOnly);
                    break;

                case ID_PRIORITY_HIGH:
                case ID_PRIORITY_NORMAL:
                case ID_PRIORITY_LOW:
                    rgCmds[ul].cmdf = QS_ENABLERADIO(fMailAndNotReadOnly, (pri == UINT(ID_PRIORITY_LOW - cmdID)));
                    break;

                case ID_CHECK_NAMES:
                    rgCmds[ul].cmdf = QS_ENABLED(TRUE);
                    break;

                case ID_FULL_HEADERS:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(TRUE, m_fAdvanced);
                    break;

                case ID_CUT:
                case ID_COPY:
                case ID_NOTE_COPY:
                case ID_PASTE:
                case ID_UNDO:
                case ID_SELECT_ALL:
                    if (fFound)
                        HrQueryToolbarButtons(dwFlags, pguidCmdGroup, &rgCmds[ul]);
                    break;
            }
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_Envelope))
    {
        for (ul=0;ul<cCmds; ul++)
        {
            switch (rgCmds[ul].cmdID)
            {
                case MSOEENVCMDID_VCARD:
                    HrGetVCardState(&rgCmds[ul].cmdf);
                    break;

                case MSOEENVCMDID_DIGSIGN:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(!IsReadOnly(), m_fDigSigned);
                    break;

                case MSOEENVCMDID_ENCRYPT:
                    if(m_fForceEncryption)
                    {
                        if(!m_fDigSigned)
                            rgCmds[ul].cmdf = QS_ENABLECHECK(m_fMail && !IsReadOnly(), m_fEncrypted);
                        else 
                            break;
                    }
                    else
                        rgCmds[ul].cmdf = QS_ENABLECHECK(m_fMail && !IsReadOnly(), m_fEncrypted);
                    break;

                case MSOEENVCMDID_DIRTY:
                    {
                        BOOL fDirty;
                        fDirty = m_fDirty || (m_lpAttMan && m_lpAttMan->HrIsDirty()==S_OK);

                        if (fDirty)
                            rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                        else
                            rgCmds[ul].cmdf = 0;
                    }
                    break;

                case MSOEENVCMDID_SEND:
                case MSOEENVCMDID_CHECKNAMES:
                case MSOEENVCMDID_AUTOCOMPLETE:
                case MSOEENVCMDID_SETACTION:
                case MSOEENVCMDID_PRIORITY:
                    rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
            }
        }

        return NOERROR;
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}


// IOleCommandTarget
HRESULT CNoteHdr::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr = NOERROR;
    HWND        hwndFocus;
    UINT        msg = 0;
    WPARAM      wParam = 0;
    LPARAM      lParam = 0;
    BOOL        fOfficeCmd=FALSE;

    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
            case OLECMDID_CUT:              
                msg = WM_CUT; 
                break;
            
            case OLECMDID_PASTE:            
                msg = WM_PASTE; 
                break;

            case OLECMDID_COPY:             
                msg = WM_COPY; 
                break;

            case OLECMDID_UNDO:             
                msg = WM_UNDO; 
                break;

            case OLECMDID_SELECTALL:        
                msg = EM_SETSEL; 
                lParam = (LPARAM)(INT)-1; 
                break;

            case OLECMDID_CLEARSELECTION:   
                msg = WM_CLEAR; 
                break;

            default:
                hr = _ConvertOfficeCmdIDToOE(&nCmdID);
                if (hr==S_OK)
                {   //if sucess, nCmdId now points to an OE command
                    fOfficeCmd = TRUE;
                    goto oe_cmd;
                }
                else
                    hr = OLECMDERR_E_NOTSUPPORTED;
        }

        if (0 != msg)
        {
            hwndFocus = GetFocus();
            if (IsChild(m_hwnd, hwndFocus))
                SendMessage(hwndFocus, msg, wParam, lParam);
        }
        return hr;
    }
    else if (IsEqualGUID(*pguidCmdGroup, CGID_Envelope))
    {
oe_cmd:
        switch (nCmdID)
        {
            case MSOEENVCMDID_ATTACHFILE:
                if (m_lpAttMan)
                    m_lpAttMan->WMCommand(0, ID_INSERT_ATTACHMENT, NULL);
                break;
                
            case MSOEENVCMDID_FOCUSTO:
                ::SetFocus(GetDlgItem(m_hwnd, idADTo));
                break;

            case MSOEENVCMDID_FOCUSCC:
                ::SetFocus(GetDlgItem(m_hwnd, idADCc));
                break;

            case MSOEENVCMDID_FOCUSSUBJ:
                ::SetFocus(GetDlgItem(m_hwnd, idTXTSubject));
                break;

            case MSOEENVCMDID_SEND:
                if (MSOCMDEXECOPT_DONTPROMPTUSER == nCmdExecOpt)
                    m_fSendImmediate = TRUE;
                else
                    m_fSendImmediate = FALSE;

                hr = HrSend();
                break;

            case MSOEENVCMDID_NEWS:
                m_fMail = FALSE;
                break;

            case MSOEENVCMDID_CHECKNAMES:
                hr = HrCheckNames((MSOCMDEXECOPT_PROMPTUSER == nCmdExecOpt)? FALSE: TRUE, TRUE);
                if (!m_fMail)
                {
                    hr = HrCheckGroups(FALSE);
                    if (hrNoRecipients == hr)
                        hr = S_OK;
                }
                break;

            case MSOEENVCMDID_AUTOCOMPLETE:
                m_fAutoComplete = TRUE;
                break;

            case MSOEENVCMDID_VIEWCONTACTS:
                hr = HrViewContacts();
                break;

            case MSOEENVCMDID_DIGSIGN:
                hr = HrHandleSecurityIDMs(TRUE);
                break;
            case MSOEENVCMDID_ENCRYPT:
                hr = HrHandleSecurityIDMs(FALSE);
                break;

            case MSOEENVCMDID_SETACTION:
                if (pvaIn->vt == VT_I4)
                    m_ntNote = pvaIn->lVal;
                break;

            case MSOEENVCMDID_SELECTRECIPIENTS:
                hr = HrPickNames(0);
                break;

            case MSOEENVCMDID_ADDSENDER:
                hr = HrAddSender();
                break;

            case MSOEENVCMDID_ADDALLONTO:
                hr = HrAddAllOnToList();
                break;

            case MSOEENVCMDID_PICKNEWSGROUPS:
                if (!m_fMail)
                {
                    if (idTXTFollowupTo == GetWindowLong(GetFocus(), GWL_ID))
                        OnButtonClick(idbtnFollowup);
                    else
                        OnButtonClick(idbtnTo);
                }
                break;

            case MSOEENVCMDID_VCARD:
                m_fVCard = !m_fVCard;
                hr = HrOnOffVCard();
                break;

            case MSOEENVCMDID_DIRTY:
                _ClearDirtyFlag();
                break;

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
        }

        // suppress OE errors when running under office-envelope
        if (fOfficeCmd && hr != OLECMDERR_E_NOTSUPPORTED)
            hr = S_OK;
        
        return hr;
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}


BOOL CNoteHdr::IsReplyNote()
{
    return (m_ntNote==OENA_REPLYTOAUTHOR || m_ntNote==OENA_REPLYTONEWSGROUP || m_ntNote==OENA_REPLYALL);
}

//////////////////////////////////////////////////////////////////////////////
// IPersistMime::Load
// before calling this function, need to set m_ntNote by MSOEENVCMDID_SETACTION.
HRESULT CNoteHdr::Load(LPMIMEMESSAGE pMsg)
{
    HRESULT         hr=S_OK;
    HCHARSET        hCharset = NULL;
    PROPVARIANT     var;

    Assert(pMsg);
    if (!pMsg)
        return E_INVALIDARG;

    m_fStillLoading = TRUE;

    m_fSkipLayout = TRUE;

    m_fHandleChange = TRUE;

    ReplaceInterface(m_pMsg, pMsg);

    pMsg->GetCharset(&hCharset);

    // bug #43295
    // If we are in same codepages, we can pass FALSE to UpdateCharSetFont().
    // But if we are in the differnet codepages, we need to update font to
    // display the header (decoded) in the correct codepage.
    //    UpdateCharSetFonts(hCharset, FALSE);
    if (hCharset)
        HrUpdateCharSetFonts(hCharset, hCharset != m_hCharset);

    // If there is an account set in the message, make sure that we use it.
    var.vt = VT_LPSTR;
    if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
    {
        IImnAccount *pAcct = NULL;
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pAcct)))
        {
            HWND hwndCombo = GetDlgItem(m_hwnd, idFromCombo);
            if (hwndCombo)
            {
                int     cEntries = ComboBox_GetCount(hwndCombo);
                for (int i = 0; i < cEntries; i++)
                {
                    LPSTR idStr = (LPSTR)ComboBox_GetItemData(hwndCombo, i);
                    if (0 == lstrcmp(idStr, var.pszVal))
                    {
                        ComboBox_SetCurSel(hwndCombo, i);
                        m_iCurrComboIndex = i;
                        ReplaceInterface(m_pAccount, pAcct);
                        break;
                    }
                }
            }
            else 
                ReplaceInterface(m_pAccount, pAcct);

            pAcct->Release();
        }
        SafeMemFree(var.pszVal);
    }

    HrInitSecurity();
    HrUpdateSecurity(pMsg);

    // Modify subject if need to add a Fw: or a Re:
    if (m_ntNote==OENA_FORWARD || IsReplyNote())
        HrSetReplySubject(pMsg, OENA_FORWARD != m_ntNote);
    else
        HrSetupNote(pMsg);

    SetReferences(pMsg);    

    if (m_fMail)
        hr = HrSetMailRecipients(pMsg);
    else
        hr = HrSetNewsRecipients(pMsg);

    if (OENA_READ == m_ntNote)
        _SetEmptyFieldStrings();

    // Update fiels, which depends from language
    _UpdateTextFields(FALSE);
    
    // setup priority, default to normal if a reply
    if (!IsReplyNote())
        HrSetPri(pMsg);
    // on reply's auto add to the wab
    else
        HrAutoAddToWAB();

    HrClearUndoStack();

    m_fSkipLayout = FALSE;
    ReLayout();

    m_fDirty=FALSE;
    if (m_pHeaderSite)
        m_pHeaderSite->Update();

    return hr;
}

void CNoteHdr::_SetEmptyFieldStrings(void)
{
    PHCI        phci = m_rgHCI;

    AssertSz((OENA_READ == m_ntNote), "Should only get here in a read note.");

    // No longer want EN_CHANGE messages to be handled in the richedits. At this
    // point we will be setting text in the edits but don't want the phci->fEmpty 
    // to be set. That message causes the phci->fEmpty to be set.
    m_fHandleChange = FALSE;
    for (int i = 0; (ULONG)i < m_cHCI; i++, phci++)
        if (phci->fEmpty)
        {
            if (0 == (phci->dwFlags & (HCF_COMBO|HCF_ATTACH)))
                HdrSetRichEditText(GetDlgItem(m_hwnd, phci->idEdit), phci->szEmpty, FALSE);
            else
                SetWindowTextWrapW(GetDlgItem(m_hwnd, phci->idEdit), phci->szEmpty);
        }
}

HRESULT CNoteHdr::_AttachVCard(IMimeMessage *pMsg)
{
    HRESULT         hr = 0;
    LPWAB           lpWab = 0;
    TCHAR           szVCardName[MAX_PATH],
                    szTempDir[MAX_PATH], 
                    szVCardTempFile[MAX_PATH],
                    szVCFName[MAX_PATH];
    UINT            uFile=0;
    INT             iLen=0;
    LPTSTR          lptstr = NULL;
    LPSTREAM        pstmFile=NULL, 
                    pstmCopy=NULL;

    *szVCardName = 0;
    *szTempDir = 0;
    *szVCardTempFile = 0;
    *szVCFName = 0;

    if (m_lpAttMan && (S_OK == m_lpAttMan->HrCheckVCardExists(m_fMail)))
        goto error;

    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;

    GetOption(m_fMail?OPT_MAIL_VCARDNAME:OPT_NEWS_VCARDNAME, szVCardName, MAX_PATH);

    if(*szVCardName == '\0')
    {
        hr = E_FAIL;
        goto error;
    }

    GetTempPath(sizeof(szTempDir), szTempDir);

    uFile = GetTempFileName(szTempDir, "VCF", 0, szVCardTempFile);
    if (uFile == 0)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = lpWab->HrCreateVCardFile(szVCardName, szVCardTempFile);
    if(FAILED(hr))
        goto error;

    hr = OpenFileStream((LPSTR)szVCardTempFile, OPEN_EXISTING, GENERIC_READ, &pstmFile);
    if(FAILED(hr))
        goto error;

    hr = MimeOleCreateVirtualStream(&pstmCopy);
    if(FAILED(hr))
        goto error;

    hr = HrCopyStream(pstmFile, pstmCopy, NULL);
    if(FAILED(hr))
        goto error;

    wnsprintf(szVCFName, ARRAYSIZE(szVCFName), "%s%s", szVCardName, ".vcf");

    hr = pMsg->AttachFile(szVCFName, pstmCopy, FALSE);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pstmFile);
    ReleaseObj(pstmCopy);
    ReleaseObj(lpWab);

    DeleteFile(szVCardTempFile);
    return hr;
}

// IPersistMime::Save
HRESULT CNoteHdr::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    HRESULT         hr = NOERROR;
    BOOL            fSkipCheck = FALSE;

    Assert(m_lpWabal);

    // If sending, then previously did a CheckNames passing FALSE. If get here, 
    // then either all the names are resolved, or we are not sending so don't care
    // what error codes are returned.
    HrCheckNames(TRUE, FALSE);

    // RAID 41350. If the save fails after leaving the header, the header
    // recipients might be in a bad state. Make sure that they are resolved again 
    // after the save.
    m_fAddressesChanged = TRUE;

    // Is the security inited???
    if(dwFlags != 0)
        m_fSecurityInited = FALSE;

    // This call will check if the dialog has been shown or if we are not mime and
    // therefore should not show the dialog either.
    if (m_pHeaderSite)
        fSkipCheck = (S_OK != m_pHeaderSite->CheckCharsetConflict());

    if (fSkipCheck)
    {
        IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));

        // Ignore any charset conflict errors.
        hr = S_OK;
    }
    else
    {
        IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, TRUE));

        if (MIME_S_CHARSET_CONFLICT == hr)
        {
            int         ret;
            PROPVARIANT Variant;
            HCHARSET    hCharset;

            // Setup the Variant
            Variant.vt = VT_UI4;

            if (m_pEnvelopeSite && m_fShowedUnicodeDialog)
                ret = m_iUnicodeDialogResult;
            else
            {
                ret = IntlCharsetConflictDialogBox();

                if (m_pEnvelopeSite)
                {
                    m_fShowedUnicodeDialog = TRUE;
                    m_iUnicodeDialogResult = ret;
                }
            }

            // Save As Is...
            if (ret == IDOK)
            {
                IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));

                // User choose to send as is. Bail out and pretend no charset conflict
                hr = S_OK;
            }
            // Save as Unicode
            else if (ret == idcSendAsUnicode)
            {
                // User choose to send as Unicode (UTF8). set new charset and resnd
                hCharset = GetMimeCharsetFromCodePage(CP_UTF8);
                if (m_pHeaderSite)
                    m_pHeaderSite->ChangeCharset(hCharset);
                else
                {
                    pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
                    ChangeLanguage(m_pMsg);

                    // bobn [6/23/99] Raid 77019
                    // If we switch to unicode and we're a word note, we
                    // need to remember that we're unicode so that we
                    // will not have the body encoding out of sync with
                    // the header encoding
                    if (m_pEnvelopeSite)
                        m_hCharset = hCharset;
                }
                IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));

                Assert(MIME_S_CHARSET_CONFLICT != hr);
            }
            else
            {
                // return to edit mode and bail out
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }
        }
        else
        {
            IF_FAILEXIT(hr = _UnicodeSafeSave(pMsg, FALSE));
            Assert(MIME_S_CHARSET_CONFLICT != hr);
        }
    }

exit:

    return hr;
}

HRESULT CNoteHdr::_UnicodeSafeSave(IMimeMessage *pMsg, BOOL fCheckConflictOnly)
{
    HRESULT     hr = S_OK;
    UINT        cpID = 0;
    WCHAR       wsz[cchMaxSubject+1];
    PROPVARIANT rVariant;
    SYSTEMTIME  st;

    HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), wsz, ARRAYSIZE(wsz), FALSE);

    // All checks in here had better exit if get a MIME_S_CHARSET_CONFLICT
    if (fCheckConflictOnly)
    {
        HCHARSET        hCharSet;
        BOOL            fGetDefault = TRUE;

        // Get charset for header
        if (m_pHeaderSite)
        {
            if (SUCCEEDED(m_pHeaderSite->GetCharset(&hCharSet)))
            {
                cpID = CustomGetCPFromCharset(hCharSet, FALSE);
                fGetDefault = FALSE;
            }
        }

        // Get default charset if didn't get one from header
        if (fGetDefault)
        {
            pMsg->GetCharset(&hCharSet);
            cpID = CustomGetCPFromCharset(hCharSet, FALSE);
        }

        // If we are unicode, then there is no need to check because
        // we will always work, so exit.
        if (CP_UTF7 == cpID || CP_UTF8 == cpID || CP_UNICODE == cpID)
            goto exit;

        IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMsg, m_pAccount, m_lpWabal, m_fMail, cpID, TRUE));
        if (MIME_S_CHARSET_CONFLICT == hr)
            goto exit;

        IF_FAILEXIT(hr = HrSafeToEncodeToCP(wsz, cpID));
        if (MIME_S_CHARSET_CONFLICT == hr)
            goto exit;

        if (m_pszRefs)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(m_pszRefs, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        IF_FAILEXIT(hr = HrCheckDisplayNames(m_lpWabal, cpID));
        if (MIME_S_CHARSET_CONFLICT == hr)
            goto exit;

        if (m_lpAttMan)
        {
            IF_FAILEXIT(hr = m_lpAttMan->CheckAttachNameSafeWithCP(cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        if (!m_fMail)
        {
            IF_FAILEXIT(hr = HrNewsSave(pMsg, cpID, TRUE));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

// this checking produced a 4 bugs in OE 5.01 and 5.5 and I disaable it (YST)
#ifdef YST
        if (m_pEnvelopeSite)
        {
            IF_FAILEXIT(hr = _CheckMsoBodyCharsetConflict(cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }
#endif
    }
    else
    {
        // ************************
        // This portion only happens on save, so don't try to do for fCheckConflictOnly
        // Anything not in this section had better be mirrored in the fCheckConflictOnly block above

        IF_FAILEXIT(hr = HrSetAccountByAccount(pMsg, m_pAccount));

        if (m_fVCard)
        {
            HWND    hwndFocus=GetFocus();

            hr = _AttachVCard(pMsg);
            if (FAILED(hr))
            {
                if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(m_fMail?idsAthenaMail:idsAthenaNews),
                                  MAKEINTRESOURCEW(idsErrAttachVCard), NULL, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
                {
                    ::SetFocus(hwndFocus);
                    IF_FAILEXIT(hr);
                }
            }
        }

        // set the time
        rVariant.vt = VT_FILETIME;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &rVariant.filetime);
        pMsg->SetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);

        // Priority
        if (m_pri!=priNone)
        {
            rVariant.vt = VT_UI4;
            rVariant.ulVal = priLookup[m_pri];
            pMsg->SetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
        }

        IF_FAILEXIT(hr = HrSaveSecurity(pMsg));
        // end of save only portion.
        // *************************

        m_lpWabal->DeleteRecipType(MAPI_ORIG);
        IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMsg, m_pAccount, m_lpWabal, m_fMail, 0, FALSE));
        IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, wsz));

        if (m_pszRefs)
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, m_pszRefs));

        // This must be called after HrSaveSecurity
        IF_FAILEXIT(hr = HrSetWabalOnMsg(pMsg, m_lpWabal));

        if (m_lpAttMan)
            IF_FAILEXIT(hr = m_lpAttMan->Save(pMsg, 0));

        if (!m_fMail)
            IF_FAILEXIT(hr = HrNewsSave(pMsg, cpID, FALSE));
    }

exit:
    return hr;
}

// IPersist::GetClassID
HRESULT CNoteHdr::GetClassID(CLSID *pClsID)
{
    //TODO:
    *pClsID = CLSID_OEEnvelope;
    return NOERROR;
}


//////////////////////////////////////////////////////////////////////////////
// IHeader::SetRect
HRESULT CNoteHdr::SetRect(LPRECT prc)
{
    MoveWindow(m_hwnd, prc->left, prc->top, prc->right-prc->left, prc->bottom - prc->top, TRUE);
    return NOERROR;
}


// IHeader::GetRect
HRESULT CNoteHdr::GetRect(LPRECT prcView)
{
    GetRealClientRect(m_hwnd, prcView);
    return NOERROR;
}



// IHeader::Init
HRESULT CNoteHdr::Init(IHeaderSite* pHeaderSite, HWND hwndParent)
{
    if (pHeaderSite==NULL || hwndParent==NULL)
        return E_INVALIDARG;

    m_pHeaderSite = pHeaderSite;
    m_pHeaderSite->AddRef();
    m_hwndParent = hwndParent;

    return HrInit(NULL);
}


// IHeader::SetPriority
HRESULT CNoteHdr::SetPriority(UINT pri)
{
    RECT rc;

    if ((UINT)m_pri != pri)
    {
        m_pri = pri;

        InvalidateStatus();
        ReLayout();

        SetDirtyFlag();
    }

    return NOERROR;
}


// IHeader::GetPriority
HRESULT CNoteHdr::GetPriority(UINT* ppri)
{
    *ppri = m_pri;
    return NOERROR;
}

// Update fiels, which depends from language
void CNoteHdr::_UpdateTextFields(BOOL fSetWabal)
{
    LPWSTR  lpszOrg = NULL,
            lpszSubj = NULL,
            lpszKeywords = NULL;

    if (IsReadOnly())
    {
        // if it's a readnote, reload the header that depend on a charset
        MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &lpszSubj);
        MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_KEYWORDS), NOFLAGS, &lpszKeywords);
        MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_ORG), NOFLAGS, &lpszOrg);

        if(lpszOrg)
        {
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTOrg), lpszOrg, FALSE);
            MemFree(lpszOrg);
        }

        if(lpszKeywords)
        {
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), lpszKeywords, FALSE);
            MemFree(lpszKeywords);
        }

        if(lpszSubj)
        {
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), lpszSubj, FALSE);
            MemFree(lpszSubj);
        }

        if (fSetWabal)
        {
            LPWABAL lpWabal = NULL;

            Assert(m_hwnd);
            Assert(m_pMsg);
            Assert(m_lpWabal);            

            if (SUCCEEDED(HrGetWabalFromMsg(m_pMsg, &lpWabal)))
            {
                ReplaceInterface(m_lpWabal, lpWabal);

                if (SUCCEEDED(m_pAddrWells->HrSetWabal(m_lpWabal)))
                {
                    m_lpWabal->HrResolveNames(NULL, FALSE);
                    m_pAddrWells->HrDisplayWells(m_hwnd);
                }
            }
            ReleaseObj(lpWabal);
        }

        m_fDirty = FALSE; // don't make dirty if a readnote
    }
}

// IHeader::ChangeLanguage
HRESULT CNoteHdr::ChangeLanguage(LPMIMEMESSAGE pMsg)
{
    HCHARSET    hCharset=NULL;

    if (!pMsg)
        return E_INVALIDARG;

    pMsg->GetCharset(&hCharset);

     // Update fields, which depends from language
    _UpdateTextFields(TRUE);

    // update the fonts scripts etc
    HrUpdateCharSetFonts(hCharset, TRUE);
    
    // notify the addr wells that the font need to change
    m_pAddrWells->OnFontChange();
    return S_OK;
}




HRESULT CNoteHdr::OnPreFontChange()
{
    HWND        hwndFrom=GetDlgItem(m_hwnd, idFromCombo);

    if (hwndFrom)
        SendMessage(hwndFrom, WM_SETFONT, 0, 0);
    return S_OK;
}

HRESULT CNoteHdr::OnPostFontChange()
{
    ULONG       cxNewLeftMargin = _GetLeftMargin();
    HWND        hwndFrom=GetDlgItem(m_hwnd, idFromCombo);
    HFONT       hFont;
    HWND        hwndBlock = HwndStartBlockingPaints(m_hwnd);
    BOOL        fLayout=FALSE;

    if (g_pFieldSizeMgr->FontsChanged() || (m_cxLeftMargin != cxNewLeftMargin))
    {
        m_cxLeftMargin = cxNewLeftMargin;
        fLayout=TRUE;
    }

    // update the fonts
    ChangeLanguage(m_pMsg);

    // update the account combo
    if (hwndFrom && 
        g_lpIFontCache &&
        g_lpIFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
        SendMessage(hwndFrom, WM_SETFONT, (WPARAM)hFont, 0);

    if (fLayout)
        ReLayout();

    if (hwndBlock)
        StopBlockingPaints(hwndBlock);

    return S_OK;
}


// IHeader::GetTitle
HRESULT CNoteHdr::GetTitle(LPWSTR pwszTitle, ULONG cch)
{
    // Locals
    static WCHAR    s_wszNoteTitle[cchHeaderMax+1] = L"";
    static DWORD    s_cLenTitle = 0;
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = 0;
    HRESULT         hr = S_OK;   
    LPWSTR          pwszLang = NULL;
    BOOL            fWinNT = g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;

    if (pwszTitle==NULL || cch==0)
        return E_INVALIDARG;

    if (*s_wszNoteTitle == L'\0')
    {
        if (fWinNT)
        {
            AthLoadStringW(idsNoteLangTitle, s_wszNoteTitle, ARRAYSIZE(s_wszNoteTitle));

            // -4 for the %1 and %2 that will be replaced
            s_cLenTitle = lstrlenW(s_wszNoteTitle) - 4; 
        }
        else
        {
            AthLoadStringW(idsNoteLangTitle9x, s_wszNoteTitle, ARRAYSIZE(s_wszNoteTitle));

            // -2 for the %s that will be replaced
            s_cLenTitle = lstrlenW(s_wszNoteTitle) - 2; 
        }
    }

    if (m_hCharset)
    {
        MimeOleGetCharsetInfo(m_hCharset,&CsetInfo);
        uiCodePage = CsetInfo.cpiWindows;
    }

    if (uiCodePage == 0 || uiCodePage == GetACP())
    {
        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), pwszTitle, cch-1, FALSE);
        if (0 == *pwszTitle)
            AthLoadStringW((OENA_READ == m_ntNote) ? idsNoSubject : idsNewNote, pwszTitle, cch-1);

        ConvertTabsToSpacesW(pwszTitle);
    }
    else
    {
        AssertSz(cch > (ARRAYSIZE(CsetInfo.szName) + s_cLenTitle), "Won't fit language. Get bigger cch!!!");

        // if no lang pack then s_szLastLang is empty and we need to try to restore message header
        IF_NULLEXIT(pwszLang = PszToUnicode(CP_ACP, *m_szLastLang ? m_szLastLang : CsetInfo.szName));

        if (fWinNT)
        {
            WCHAR   wszSubj[cchHeaderMax+1];
            DWORD   cchLang,
                    cchTotal,
                    cchSubj;
            LPSTR   pArgs[2];

            *wszSubj = 0;

            HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), wszSubj, ARRAYSIZE(wszSubj), FALSE);
            if (0 == *wszSubj)
                AthLoadStringW((OENA_READ == m_ntNote) ? idsNoSubject : idsNewNote, wszSubj, ARRAYSIZE(wszSubj));

            ConvertTabsToSpacesW(wszSubj);

            cchSubj = lstrlenW(wszSubj);
            cchLang = lstrlenW(pwszLang);
            cchTotal = s_cLenTitle + cchLang + cchSubj + 1;

            // If too big, truncate the subject, not language since
            // asserting that we have enough for language.
            if (cchTotal > cch)
            {
                cchSubj -= (cchTotal - cch);
                wszSubj[cchSubj] = L'\0';
            }

            pArgs[0] = (LPSTR)wszSubj;
            pArgs[1] = (LPSTR)pwszLang;
            *pwszTitle = L'\0';
            FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           s_wszNoteTitle,
                           0, 0,
                           pwszTitle,
                           cch,
                           (va_list*)pArgs);
        }
        else
        {
            wnsprintfW(pwszTitle, cch, s_wszNoteTitle, pwszLang);
        }
    }

exit:
    MemFree(pwszLang);
    return hr;
}


void CNoteHdr::_AddRecipTypeToMenu(HMENU hmenu)
{
    ADRINFO     adrInfo;
    WCHAR       wszDisp[256];
    ULONG       uPos=0;

    BOOL fFound = m_lpWabal->FGetFirst(&adrInfo);
    while (fFound && (uPos < cMaxRecipMenu))
    {
        if (adrInfo.lRecipType==MAPI_TO || adrInfo.lRecipType==MAPI_CC)
        {
            if(lstrlenW(adrInfo.lpwszDisplay) > 255)
            {
                StrCpyNW(wszDisp, adrInfo.lpwszDisplay, 255);
                wszDisp[255] = '\0';
            }
            else
            {
                StrCpyNW(wszDisp, adrInfo.lpwszDisplay, ARRAYSIZE(wszDisp));
            }

            AppendMenuWrapW(hmenu, MF_STRING , ID_ADD_RECIPIENT_FIRST+uPos, wszDisp);
            uPos++;
        }
        fFound = m_lpWabal->FGetNext(&adrInfo);
    }
}

// IHeader::UpdateRecipientMenu
HRESULT CNoteHdr::UpdateRecipientMenu(HMENU hmenu)
{
    HRESULT     hr = E_FAIL;
    BOOL        fSucceeded = TRUE;

    // destory current recipients
    while (fSucceeded)
        fSucceeded = DeleteMenu(hmenu, 2, MF_BYPOSITION);

    if (!m_lpWabal)
        return E_FAIL;

    // Add To: and Cc: people
    _AddRecipTypeToMenu(hmenu);

    return NOERROR;
}


// IHeader::SetInitFocus
HRESULT CNoteHdr::SetInitFocus(BOOL fSubject)
{
    if (m_rgHCI)
    {
        if (fSubject)
            ::SetFocus(GetDlgItem(m_hwnd, idTXTSubject));
        else
        {
            if (0 == (m_rgHCI[0].dwFlags & HCF_COMBO))
                ::SetFocus(GetDlgItem(m_hwnd, m_rgHCI[0].idEdit));
            else
                ::SetFocus(GetDlgItem(m_hwnd, m_rgHCI[1].idEdit));
        }
    }
    return NOERROR;
}


// IHeader::SetVCard
HRESULT CNoteHdr::SetVCard(BOOL fFresh)
{
    HRESULT     hr = NOERROR;
    TCHAR       szBuf[MAX_PATH];
    LPWAB       lpWab = NULL;
    ULONG       cbEID=0;
    LPENTRYID   lpEID = NULL;
    WORD        wVCard;

    if (m_ntNote == OENA_READ)
        wVCard = (m_lpAttMan->HrFVCard() == S_OK) ? VCardTRUE : VCardFALSE;
    else if (!fFresh) //not a fresh note.
        wVCard = VCardFALSE;
    else if (m_ntNote == OENA_FORWARD)
        wVCard = (m_lpAttMan->HrCheckVCardExists(m_fMail) == S_OK) ? VCardFALSE : VCardDONTKNOW;
    else
        wVCard = VCardDONTKNOW;

    if (wVCard != VCardDONTKNOW)
        m_fVCard = wVCard;
    else
    {
        hr = HrGetVCardName(szBuf, sizeof(szBuf));
        if (FAILED(hr)) // no vcard name selected
        {
            if (m_fMail)
                SetDwOption(OPT_MAIL_ATTACHVCARD, FALSE, NULL, 0);
            else
                SetDwOption(OPT_NEWS_ATTACHVCARD, FALSE, NULL, 0);
        }

        if (m_fMail)
            m_fVCard = (BOOL)DwGetOption(OPT_MAIL_ATTACHVCARD);
        else
            m_fVCard = (BOOL)DwGetOption(OPT_NEWS_ATTACHVCARD);
    }

    hr = HrOnOffVCard();
    if (FAILED(hr))
        goto error;

    error:
    ReleaseObj(lpWab);
    return hr;
}


// IHeader::IsSecured
HRESULT CNoteHdr::IsSecured()
{
    if (m_fDigSigned || m_fEncrypted)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CNoteHdr::IsHeadSigned()
{
    if (m_fDigSigned)
        return S_OK;
    else
        return S_FALSE;
}

// set ForvrEncryption  form policy module if fSet is TRUE
// if fSet is not set then returns S_FALSE if ForceEncryption was not set

HRESULT CNoteHdr::ForceEncryption(BOOL *fEncrypt, BOOL fSet)
{
    HRESULT hr = S_FALSE;
    if(fSet)
    {
        Assert(fEncrypt);
        if(m_fDigSigned)
        {
            if(*fEncrypt)
                m_fEncrypted = TRUE;

        }
        m_fForceEncryption = *fEncrypt;
        if(m_ntNote != OENA_READ)
            HrUpdateSecurity();
        hr = S_OK;
    }
    else if(m_fForceEncryption && m_fDigSigned)
    {
        m_fEncrypted = TRUE;
        hr = S_OK;
    }

    return(hr);
}

// IHeader::AddRecipient
HRESULT CNoteHdr::AddRecipient(int idOffset)
{
    BOOL        fFound;
    ULONG       uPos=0;
    ADRINFO     adrInfo;
    LPADRINFO   lpAdrInfo=0;
    LPWAB       lpWab;
    HRESULT     hr=E_FAIL;

    Assert(m_lpWabal);

    fFound = m_lpWabal->FGetFirst(&adrInfo);
    while (fFound &&
           (uPos < cMaxRecipMenu))
    {
        if (idOffset==-1  &&
            adrInfo.lRecipType==MAPI_ORIG)
        {
            lpAdrInfo=&adrInfo;
            break;
        }

        if (adrInfo.lRecipType==MAPI_TO || adrInfo.lRecipType==MAPI_CC)
        {
            if (idOffset==(int)uPos)
            {
                lpAdrInfo=&adrInfo;
                break;
            }
            uPos++;
        }
        fFound=m_lpWabal->FGetNext(&adrInfo);
    }

    if (lpAdrInfo &&
        !FAILED (HrCreateWabObject (&lpWab)))
    {
        hr=lpWab->HrAddToWAB(m_hwnd, lpAdrInfo);
        lpWab->Release ();
    }

    if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
    {
        if (hr==MAPI_E_COLLISION)
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddrDupe), NULL, MB_OK);
        else
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddToWAB), NULL, MB_OK);
    }

    return NOERROR;
}


// IHeader::OnDocumentReady
HRESULT CNoteHdr::OnDocumentReady(LPMIMEMESSAGE pMsg)
{
    HRESULT hr = S_OK;

    m_fStillLoading = FALSE;
    if (m_lpAttMan)
        hr = m_lpAttMan->Load(pMsg);

    return hr;
}


// IHeader::DropFiles
HRESULT CNoteHdr::DropFiles(HDROP hDrop, BOOL fMakeLinks)
{
    HRESULT hr = S_OK;
    if (m_lpAttMan)
        hr = m_lpAttMan->HrDropFiles(hDrop, fMakeLinks);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IMsoEnvelope:Init
HRESULT CNoteHdr::Init(IUnknown* punk, IMsoEnvelopeSite* pesit, DWORD grfInit)
{
    HRESULT         hr = S_OK;

    if (punk == NULL && pesit == NULL && grfInit == 0)
    {
        SafeRelease(m_pEnvelopeSite);
        hr = E_FAIL;
        goto Exit;
    }

    if (pesit==NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    ReplaceInterface(m_pEnvelopeSite, pesit);

    hr = HrInit(NULL);
    if (FAILED(hr))
        goto Exit;

    if (grfInit & ENV_INIT_FROMSTREAM)
    {
        IStream        *pstm = NULL;

        // no IStream to work with?
        if (!punk)
            return E_INVALIDARG;
        
        hr = punk->QueryInterface(IID_IStream, (LPVOID*)&pstm);
        if (!FAILED(hr))
        {
            hr = _LoadFromStream(pstm);
            pstm->Release();
        }
    }

    _SetButtonText(ID_SEND_NOW, MAKEINTRESOURCE((grfInit & ENV_INIT_DOCBEHAVIOR)?idsEnvSendCopy:idsEnvSend));
    
Exit:
    return hr;
}


// IMsoEnvelope::SetParent
// we create the envelope window here
HRESULT CNoteHdr::SetParent(HWND hwndParent)
{
    Assert (IsWindow(m_hwnd));

    ShowWindow(m_hwnd, hwndParent ? SW_SHOW : SW_HIDE);

    if (hwndParent)
    {
        _RegisterWithComponentMgr(TRUE);
        _RegisterAsDropTarget(TRUE);
        _RegisterWithFontCache(TRUE);
    }
    else
    {
        _RegisterWithComponentMgr(FALSE);
        _RegisterAsDropTarget(FALSE);
        _RegisterWithFontCache(FALSE);
    }

    m_hwndParent = hwndParent?hwndParent:g_hwndInit;
    ::SetParent(m_hwnd, m_hwndParent);

    if (hwndParent)
        ReLayout();

    return S_OK;
}

// IMsoEnvelope::Resize
HRESULT CNoteHdr::Resize(LPCRECT prc)
{
    MoveWindow(m_hwnd, prc->left, prc->top, prc->right - prc->left, prc->bottom - prc->top, TRUE);
    return NOERROR;
}

// IMsoEnvelope::Show
HRESULT CNoteHdr::Show(BOOL fShow)
{
    ShowWindow(m_hwnd, fShow ? SW_SHOW : SW_HIDE);
    return NOERROR;
}

// IMsoEnvelope::SetHelpMode
HRESULT CNoteHdr::SetHelpMode(BOOL fEnter)
{
    return NOERROR;
}

// IMsoEnvelope::Save
HRESULT CNoteHdr::Save(IStream* pstm, DWORD grfSave)
{
    HRESULT         hr = S_OK;
    IMimeMessage   *pMsg = NULL;
    PERSISTHEADER   rPersistHdr;

    if (pstm == NULL)
        return E_INVALIDARG;

    hr = WriteClassStm(pstm, CLSID_OEEnvelope);
    if (!FAILED(hr))
    {
        ZeroMemory(&rPersistHdr, sizeof(PERSISTHEADER));
        rPersistHdr.cbSize = sizeof(PERSISTHEADER);
        hr = pstm->Write(&rPersistHdr, sizeof(PERSISTHEADER), NULL);
        if (!FAILED(hr))
        {
            hr = HrCreateMessage(&pMsg);
            if (!FAILED(hr))
            {
                hr = Save(pMsg, 0);
                if (!FAILED(hr))
                    hr = pMsg->Save(pstm, FALSE);
        
                pMsg->Release();    
            }
        }
    }
    
    _ClearDirtyFlag();
    return hr;
}

// IMsoEnvelope::GetAttach
HRESULT CNoteHdr::GetAttach(const WCHAR* wszName,IStream** ppstm)
{
    return NOERROR;
}

HRESULT CNoteHdr::SetAttach(const WCHAR* wszName, const WCHAR *wszCID, IStream **ppstm, DWORD *pgrfAttach)
{
    IStream     *pstm=0;
    HBODY       hBody;
    LPWSTR      pszCntTypeW=NULL;
    HRESULT     hr;
    PROPVARIANT pv;

    if (!m_pMsgSend)
        return E_FAIL;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));

    IF_FAILEXIT(hr = m_pMsgSend->AttachURL(NULL, NULL, 0, pstm, NULL, &hBody));

    // strip off cid: header
    if (StrCmpNIW(wszCID, L"CID:", 4)==0)
        wszCID += 4;

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(m_pMsgSend, hBody, PIDTOSTR(PID_HDR_CNTID), 0, wszCID));

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(m_pMsgSend, hBody, PIDTOSTR(STR_ATT_FILENAME), 0, wszName));

    FindMimeFromData(NULL, wszName, NULL, NULL, NULL, 0, &pszCntTypeW, 0);
    pv.vt = pszCntTypeW ? VT_LPWSTR : VT_LPSTR;
    if (pszCntTypeW)
        pv.pwszVal = pszCntTypeW;
    else
        pv.pszVal = (LPSTR)STR_MIME_APPL_STREAM;        // if FindMimeFromData fails use application/octect-stream

    IF_FAILEXIT(hr = m_pMsgSend->SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &pv));

    *ppstm = pstm;
    pstm->AddRef();

exit:
    ReleaseObj(pstm);
    return hr;
}

// IMsoEnvelope::NewAttach
HRESULT CNoteHdr::NewAttach(const WCHAR* pwzName,DWORD grfAttach)
{
    return NOERROR;
}

// IMsoEnvelope::SetFocus
HRESULT CNoteHdr::SetFocus(DWORD grfFocus)
{
    if (!m_rgHCI)
        return S_OK;

    if (grfFocus & ENV_FOCUS_TAB)
    {
        // reverse tab in from word, focus on well if visible or subject
        if (IsWindowVisible(GetDlgItem(m_hwnd, idwAttachWell)))
            ::SetFocus(GetDlgItem(m_hwnd, idwAttachWell));
        else
            ::SetFocus(GetDlgItem(m_hwnd, idTXTSubject));
    }
        else if (grfFocus & ENV_FOCUS_INITIAL)
        SetInitFocus(FALSE);
    else if (grfFocus & ENV_FOCUS_RESTORE && m_hwndLastFocus)
        ::SetFocus(m_hwndLastFocus);

    return NOERROR;
}

// IMsoEnvelope::GetHeaderInfo
HRESULT CNoteHdr::GetHeaderInfo(ULONG dispid, DWORD grfHeader, void** pszData)
{
    HRESULT hr = E_FAIL;

    if (!pszData)
        return E_INVALIDARG;

    *pszData = NULL;
    if (dispid == dispidSubject)
        hr = HrGetFieldText((LPWSTR*)pszData, idTXTSubject);

    return hr;
}

// IMsoEnvelope::SetHeaderInfo
HRESULT CNoteHdr::SetHeaderInfo(ULONG dispid, const void *pv)
{
    HRESULT hr = S_OK;
    LPSTR   psz = NULL;

    switch (dispid)
    {
        case dispidSubject:
                HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), (LPWSTR)pv, FALSE);
            break;

        case dispidSendBtnText:
        {
            IF_NULLEXIT(psz = PszToANSI(GetACP(), (LPWSTR)pv));

            _SetButtonText(ID_SEND_NOW, psz);
            break;
        }
    }

exit:
    MemFree(psz);
    return NOERROR;
}

// IMsoEnvelope::IsDirty
HRESULT CNoteHdr::IsDirty()
{
    if (m_fDirty || (m_lpAttMan && (m_lpAttMan->HrIsDirty()==S_OK)))
        return S_OK;
    else
        return S_FALSE;
}

// IMsoEnvelope::GetLastError
HRESULT CNoteHdr::GetLastError(HRESULT hr, WCHAR __RPC_FAR *wszBuf, ULONG cchBuf)
{
    DWORD ids;

    switch (hr)
    {
        case E_NOTIMPL:
            ids = idsNYIGeneral;
            break;

        default:
            ids = idsGenericError;
    }

    AthLoadStringW(ids, wszBuf, cchBuf);

    return S_OK;
}

// IMsoEnvelope::DoDebug
HRESULT CNoteHdr::DoDebug(DWORD grfDebug)
{
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////
// IMsoComponent::FDebugMessage
BOOL CNoteHdr::FDebugMessage(HMSOINST hinst, UINT message, WPARAM wParam, LPARAM lParam)
{
    return TRUE;
}


// IMsoComponent::FPreTranslateMessage
BOOL CNoteHdr::FPreTranslateMessage(MSG *pMsg)
{
    HWND    hwnd;
    BOOL    fShift;

    // Invalid ARgs
    if (NULL == pMsg)
        return FALSE;

    // check if it's US, or one of our children
    if (pMsg->hwnd != m_hwnd && !IsChild(m_hwnd, pMsg->hwnd))
        return FALSE;

    if (pMsg->message == WM_KEYDOWN &&
        pMsg->wParam == VK_ESCAPE &&
        GetFocus() == m_hwndToolbar &&
        m_hwndLastFocus)
    {
        // when focus is inthe toolbar, we're not UIActive (cheaper than subclassing to catch WM_SETFOCUS\WM_KILLFOCUS
        // as toolbar doesn't send NM_SETFOCUS). So we special case ESCAPE to drop the focus from the toolbar
        ::SetFocus(m_hwndLastFocus);
        return TRUE;
    }

    // check to see if we are UIActive
    if (!m_fUIActive)
        return FALSE;

    // check and see if it's one of our accelerators
    if (::TranslateAcceleratorWrapW(m_hwnd, GetAcceleratorTable(), pMsg))
        return TRUE;
    
    // handle tab-key here
    if (pMsg->message == WM_KEYDOWN &&
        pMsg->wParam == VK_TAB)
    {
        fShift = ( GetKeyState(VK_SHIFT ) & 0x8000) != 0;

        if (!fShift && 
            (GetKeyState(VK_CONTROL) & 0x8000))
        {
            // ctrl-TAB means focus to the toolbar
            ::SetFocus(m_hwndToolbar);
            return TRUE;
        }

        hwnd = _GetNextDlgTabItem(m_hwnd, pMsg->hwnd, fShift);
        if (hwnd != NULL)
            ::SetFocus(hwnd);
        else
            if (m_pEnvelopeSite)
                m_pEnvelopeSite->SetFocus(TRUE);
        return TRUE;
    }

    // pass the accelerators to the envelopesite
    if (m_pEnvelopeSite && 
       (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST) &&
       m_pEnvelopeSite->TranslateAccelerators(pMsg)==S_OK)
        return TRUE;

    // see if it's a message for our child controls
    if (pMsg->message != WM_SYSCHAR &&
        IsDialogMessageWrapW(m_hwnd, pMsg))
        return TRUE;

    return FALSE;
}


// IMsoComponent::OnEnterState
void CNoteHdr::OnEnterState(ULONG uStateID, BOOL fEnter)
{
    return;
}


// IMsoComponent::OnAppActivate
void CNoteHdr::OnAppActivate(BOOL fActive, DWORD dwOtherThreadID)
{
    return;
}


// IMsoComponent::OnLoseActivation
void CNoteHdr::OnLoseActivation()
{
    return;
}


// IMsoComponent::OnActivationChange
void CNoteHdr::OnActivationChange(IMsoComponent *pic, BOOL fSameComponent, const MSOCRINFO *pcrinfo, BOOL fHostIsActivating, const MSOCHOSTINFO *pchostinfo, DWORD dwReserved)
{
    return;
}


// IMsoComponent::FDoIdle
BOOL CNoteHdr::FDoIdle(DWORD grfidlef)
{
    return FALSE;
}


// IMsoComponent::FContinueMessageLoop
BOOL CNoteHdr::FContinueMessageLoop(ULONG uReason, void *pvLoopData, MSG *pMsgPeeked)
{
    return FALSE;
}


// IMsoComponent::FQueryTerminate
BOOL CNoteHdr::FQueryTerminate(BOOL fPromptUser)
{
    return TRUE;
}


// IMsoComponent::Terminate
void CNoteHdr::Terminate()
{
    _RegisterWithComponentMgr(FALSE);
    if (m_hwnd)
        DestroyWindow(m_hwnd);
}

// IMsoComponent::HwndGetWindow
HWND CNoteHdr::HwndGetWindow(DWORD dwWhich, DWORD dwReserved)
{
    HWND hwnd = NULL;
    
    switch (dwWhich)
    {
        case msocWindowComponent:
        case msocWindowDlgOwner:
            hwnd = m_hwnd;
            break;

        case msocWindowFrameOwner:
            hwnd = GetParent(m_hwnd);
            break;

        case msocWindowFrameToplevel:
        {
            if (m_pEnvelopeSite)
                m_pEnvelopeSite->GetFrameWnd(&hwnd);
            return hwnd;
        }
    }
    return hwnd;
}


// HrUpdateCharSetFonts
//
// Purpose: Creates the controls on the header dialog
//          calculates and sets up all initial coordinates
//
//
// Comments:
//
HRESULT CNoteHdr::HrUpdateCharSetFonts(HCHARSET hCharset, BOOL fUpdateFields)
{
    PHCI            phci;
    HWND            hwnd;
    INT             iHC;
    TCHAR           sz[cchHeaderMax+1];
    BOOL            fDirty=m_fDirty;
    INETCSETINFO    rCharset;
    HRESULT         hr = E_FAIL;

    // Check Params
    Assert(hCharset);

    // No font cache, bummer
    if (!g_lpIFontCache)
        return E_FAIL;

    // Get Charset Information
    if (SUCCEEDED(MimeOleGetCharsetInfo(hCharset, &rCharset)))
    {
        HFONT hHeaderFont, hSystemFont;

        if ((m_hCharset != hCharset) || (0 == *m_szLastLang))
        {
            *m_szLastLang = 0;
            GetMimeCharsetForTitle(hCharset, NULL, m_szLastLang, ARRAYSIZE(m_szLastLang) - 1, IsReadOnly());
            // Save Charset
            m_hCharset = hCharset;
        }

        // If don't update fields, then just return
        if (!fUpdateFields)
            return S_OK;

        // Get charset charformat
        hHeaderFont = HGetCharSetFont(FNT_SYS_ICON, hCharset);

        hSystemFont = GetFont(FALSE);

        // Loop through header fields
        for (iHC=0; iHC<(int)m_cHCI; iHC++)
        {
            // Get info
            phci = &m_rgHCI[iHC];
            hwnd = GetDlgItem(m_hwnd, phci->idEdit);
            //Assert(hwndRE);
            if (!hwnd)
                continue;

            switch (phci->dwFlags & (HCF_COMBO|HCF_ATTACH))
            {
                case HCF_COMBO:
                case HCF_ATTACH:
                    SendMessage(hwnd, WM_SETFONT, (WPARAM)hSystemFont, MAKELPARAM(TRUE, 0));
                    break;

                // richedit
                // REVIEW: Why are we only doing a request resize when we have the USECHARSET flag set???
                case 0:
                    if (phci->dwFlags & HCF_USECHARSET)
                    {
                        SetFontOnRichEdit(hwnd, hHeaderFont);
                        SendMessage(hwnd, EM_REQUESTRESIZE, 0, 0);
                    }
                    else
                    {
                        SetFontOnRichEdit(hwnd, hSystemFont);
                    }
                    break;

                default:
                    AssertSz(FALSE, "How did we get something that is combo and attach???");
                    break;
            }
        }
        // Don't let this make the note dirty
        if (fDirty)
            SetDirtyFlag();
        else
            m_fDirty=FALSE;

        hr = S_OK;
    }

    return hr;
}

//
// WMCreate
//
// Purpose: Creates the controls on the header dialog
//          calculates and sets up all initial coordinates
//
//
// Comments:
//
BOOL CNoteHdr::WMCreate()
{
    HWND            hwnd;
    LONG            lStyleFlags,
                    lExStyleFlags,
                    lMask;
    int             cy,
                    cx,
                    cxButtons = ControlXBufferSize();
    HFONT           hFont;
    TOOLINFO        ti;
    PHCI            phci;
    RECT            rc;
    CAddrWellCB    *pawcb;
    CHARFORMAT      cfHeaderCset;
    HRESULT         hr;
    LPCWSTR         pwszTitle = NULL;
    BOOL            fSubjectField;

    Assert(g_cyFont);     // should have been setup already

    if (m_pEnvelopeSite)
    {
        // if we are the office-envelope, create a toolbar
        if (_CreateEnvToolbar())
            return FALSE;
    }

    cy = ControlYBufferSize() + m_dxTBOffset;
    cx = 0;

    if (S_OK != HrInitFieldList())
        return FALSE;

    //BROKEN: using system charformat here as not CSET info with MIMEOLE
    // Get charset for cset
    {
        hFont = GetFont(FALSE);
        if (hFont != 0)
        {
            hr = FontToCharformat(hFont, &g_cfHeader);
        }

        hFont = HGetCharSetFont(FNT_SYS_ICON, m_hCharset);
        if (hFont != 0)
        {
            hr = FontToCharformat(hFont, &cfHeaderCset);
            if (FAILED(hr))
                CopyMemory (&cfHeaderCset, &g_cfHeader, sizeof (CHARFORMAT));
        }
        else
            CopyMemory (&cfHeaderCset, &g_cfHeader, sizeof (CHARFORMAT));
        hFont = GetFont(FALSE);

    }

    // ~~~~ Do we need to be calling this with WrapW???
    // Create a tooltip, if it doesn't already exist:
    m_hwndTT=CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL, 0,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT,
                            m_hwnd, (HMENU) NULL, g_hInst, NULL);
    if (!m_hwndTT)
        return FALSE;

    ti.cbSize=sizeof(TOOLINFO);
    ti.hwnd=m_hwnd;
    ti.hinst=g_hLocRes;
    ti.uFlags=TTF_IDISHWND|TTF_SUBCLASS;

    m_lpAttMan = new CAttMan();
    if (!m_lpAttMan)
        return FALSE;

    if (m_lpAttMan->HrInit(m_hwnd, m_ntNote==OENA_READ, m_ntNote==OENA_FORWARD, !DwGetOption(OPT_SECURITY_ATTACHMENT)))
        return FALSE;

    for (int iHC=0; iHC<(int)m_cHCI; iHC++)
    {
        phci=&m_rgHCI[iHC];
        BOOL fIsCombo = (HCF_COMBO & phci->dwFlags);
        BOOL fNeedsBorder = (phci->dwFlags & HCF_BORDER);
        int  cyCtrlSize;


        // if header is optional, check setting
        if ((phci->dwFlags & HCF_OPTIONAL) &&
            !DwGetOption(phci->dwOpt))
            continue;

        if (phci->dwFlags & HCF_ATTACH)
        {
            // if we're not readonly, register ourselves as a drop target...
            if (!(phci->dwFlags & HCF_READONLY))
            {
                hr = _RegisterAsDropTarget(TRUE);
                if (FAILED(hr))
                    return FALSE;
            }
            continue;
        }

        phci->height = GetControlSize(fNeedsBorder, 1);

        // Richedit
        if (!fIsCombo)
        {
            pwszTitle = GetREClassStringW();
            cyCtrlSize = phci->height;
            lStyleFlags = WS_CHILD|WS_TABSTOP|WS_VISIBLE|ES_SAVESEL;

            lMask=ENM_KEYEVENTS|ENM_CHANGE|ENM_SELCHANGE|ENM_REQUESTRESIZE;

            if (phci->dwFlags & HCF_MULTILINE)
            {
                //lStyleFlags |= ES_MULTILINE|ES_WANTRETURN|WS_VSCROLL|ES_AUTOVSCROLL;
                lStyleFlags |= ES_MULTILINE|WS_VSCROLL|ES_AUTOVSCROLL;
            }
            else
                lStyleFlags |= ES_AUTOHSCROLL;
        }
        // Combo Box
        else
        {
            pwszTitle = L"ComboBox";
            cyCtrlSize = GetControlSize(fNeedsBorder, NUM_COMBO_LINES);
            lStyleFlags = WS_CHILD|WS_TABSTOP|WS_VISIBLE|WS_VSCROLL|
                        CBS_DROPDOWNLIST|CBS_HASSTRINGS|CBS_SORT;
        }
            
        if (phci->dwFlags & HCF_READONLY)
            lStyleFlags|=ES_READONLY;

        GetClientRect(m_hwnd, &rc);

        lExStyleFlags = fNeedsBorder ? WS_EX_NOPARENTNOTIFY|WS_EX_CLIENTEDGE : WS_EX_NOPARENTNOTIFY;

        // @hack [dhaws] {55073} Do RTL mirroring only in special richedit versions.
        fSubjectField = (idsSubjectField == phci->idsLabel);
        RichEditRTLMirroring(m_hwnd, fSubjectField, &lExStyleFlags, TRUE);

        // Regardless of mirroring, BiDi-Dates should be displayed RTL
        if(((phci->idsLabel == idsDateField) && IsBiDiCalendar()))
            lExStyleFlags |= WS_EX_RTLREADING;
        hwnd = CreateWindowExWrapW(lExStyleFlags,
                                   pwszTitle,
                                   NULL,
                                   lStyleFlags,
                                   cx, cy, rc.right, cyCtrlSize,
                                   m_hwnd,
                                   (HMENU)IntToPtr(phci->idEdit),
                                   g_hInst, 0 );                                
        if (!hwnd)
            return FALSE;

        RichEditRTLMirroring(m_hwnd, fSubjectField, &lExStyleFlags, FALSE);

        if (0 == (phci->dwFlags & HCF_BORDER))
        {
            SendMessage(hwnd, EM_SETBKGNDCOLOR, WPARAM(FALSE), LPARAM(GetSysColor(COLOR_BTNFACE)));
        }

        ti.uId = (UINT_PTR)hwnd;
        ti.lpszText = (LPTSTR)IntToPtr(phci->idsTT);
        SendMessage(m_hwndTT, TTM_ADDTOOL, 0, (LPARAM) &ti);

        // hang a pointer into the phci off each control
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)phci);

        if (!fIsCombo)
        {
            LPRICHEDITOLE   preole = NULL;
            ITextDocument  *pDoc = NULL;

            SideAssert(SendMessage(hwnd, EM_GETOLEINTERFACE, NULL, (LPARAM)&preole));
            phci->preole = preole;
            Assert(preole);

            if (SUCCEEDED(preole->QueryInterface(IID_ITextDocument, (LPVOID*)&pDoc)))
                phci->pDoc = pDoc;
            // This only happens with richedit 1.0
            else
                phci->pDoc = NULL;

            // Set edit charformat
            if (phci->dwFlags & HCF_USECHARSET)
                SendMessage(hwnd, EM_SETCHARFORMAT, 0, (LPARAM)&cfHeaderCset);
            else
                SendMessage(hwnd, EM_SETCHARFORMAT, 0, (LPARAM)&g_cfHeader);            

            if ((pawcb = new CAddrWellCB(!(phci->dwFlags&HCF_READONLY), phci->dwFlags&HCF_ADDRWELL)))
            {
                if (pawcb->FInit(hwnd))
                    SendMessage(hwnd, EM_SETOLECALLBACK, 0, (LPARAM)(IRichEditOleCallback *)pawcb);
                ReleaseObj(pawcb);
            }

            SendMessage(hwnd, EM_SETEVENTMASK, 0, lMask);
            g_lpfnREWndProc=(WNDPROC)SetWindowLongPtrAthW(hwnd, GWLP_WNDPROC, (LPARAM)EditSubClassProc);
        }
        else
        {
            CHAR                szAccount[CCHMAX_ACCOUNT_NAME];
            CHAR                szAcctID[CCHMAX_ACCOUNT_NAME];
            CHAR                szDefault[CCHMAX_ACCOUNT_NAME];
            CHAR                szEmailAddress[CCHMAX_EMAIL_ADDRESS];
            CHAR                szEntry[ACCT_ENTRY_SIZE];
            CHAR                szDefaultEntry[ACCT_ENTRY_SIZE];
            IImnEnumAccounts   *pEnum=NULL;
            IImnAccount        *pAccount=NULL;
            int                 i = 0;
            DWORD               cAccounts = 0;
            LPSTR              *ppszAcctIDs;

            *szDefault = 0;
            *szDefaultEntry = 0;

            // If default account isn't setup, this might fail, but doesn't matter.
            g_pAcctMan->GetDefaultAccountName(m_fMail?ACCT_MAIL:ACCT_NEWS, szDefault, ARRAYSIZE(szDefault));

            hr = g_pAcctMan->Enumerate(m_fMail?SRV_MAIL:SRV_NNTP, &pEnum);

            if (SUCCEEDED(hr))
                hr = pEnum->GetCount(&cAccounts);

            if (SUCCEEDED(hr) && cAccounts)
            {
                if (!MemAlloc((void**)&m_ppAccountIDs, cAccounts*sizeof(LPSTR)))
                    hr = E_OUTOFMEMORY;
            }


            if (SUCCEEDED(hr))
            {
                *szDefaultEntry = 0;
                ppszAcctIDs = m_ppAccountIDs;
                while(SUCCEEDED(pEnum->GetNext(&pAccount)))
                {
                    *szAccount = 0;
                    *szEmailAddress = 0;

                    pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount));
                    if (m_fMail)
                    {
                        pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress));
                        wnsprintf(szEntry, ARRAYSIZE(szEntry), "%s    (%s)", szEmailAddress, szAccount);
                    }
                    else
                    {
                        StrCpyN(szEntry, szAccount, ARRAYSIZE(szEntry));
                    }

                    i = ComboBox_InsertString(hwnd, -1, szEntry);
                    if (i != CB_ERR)
                    {
                        if (0 == lstrcmpi(szDefault, szAccount))
                        {
                            StrCpyN(szDefaultEntry, szEntry, ARRAYSIZE(szDefaultEntry));
                        }

                        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szAcctID, ARRAYSIZE(szAcctID))))
                        {
                            DWORD cchSize = (lstrlen(szAcctID) + 1);
                            if (MemAlloc((void**)ppszAcctIDs, cchSize * sizeof(CHAR)))
                            {
                                StrCpyN(*ppszAcctIDs, szAcctID, cchSize);
                            }
                            else
                            {
                                *ppszAcctIDs = NULL;
                            }
                        }
                        else
                            *ppszAcctIDs = NULL;

                        SendMessage(hwnd, CB_SETITEMDATA, WPARAM(i), LPARAM(*ppszAcctIDs));
                        ppszAcctIDs++;
                        m_cAccountIDs++;
                    }
                    // Release Account
                    SafeRelease(pAccount);
                }
                AssertSz(m_cAccountIDs == cAccounts, "Why isn't num Ds = num accts?");

                SafeRelease(pEnum);
                AssertSz(!pAccount, "The last account didn't get freed.");

                if (0 != *szDefaultEntry)
                {
                    ComboBox_SelectString(hwnd, -1, szDefaultEntry);
                    m_iCurrComboIndex = ComboBox_GetCurSel(hwnd);
                }
                else 
                {
                    ComboBox_SetCurSel(hwnd, 0);
                    m_iCurrComboIndex = 0;
                }

                if (SUCCEEDED(HrGetAccountInHeader(&pAccount)))
                {
                    ReplaceInterface(m_pAccount, pAccount);
                    ReleaseObj(pAccount);
                }

                SendMessage(hwnd, WM_SETFONT, WPARAM(hFont), MAKELONG(TRUE,0));
            }
        }
    }

    _RegisterWithFontCache(TRUE);

    HrOnOffVCard();
    ReLayout();
    return PostWMCreate();  // allow subclass to setup the controls once created...
}


//
// HeaderWndProc
//
// Purpose: Main WNDPROC for header dialog
//
// Comments:
//

LRESULT CALLBACK CNoteHdr::ExtCNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CNoteHdr    *pnh = NULL;

    if (msg==WM_NCCREATE)
    {
        SetWndThisPtrOnCreate(hwnd, lParam);
        pnh=(CNoteHdr *)GetWndThisPtr(hwnd);
        if (!pnh)
            return -1;

        pnh->m_hwnd=hwnd;
        return pnh->WMCreate();
    }

    pnh = (CNoteHdr *)GetWndThisPtr(hwnd);
    if (pnh)
        return pnh->CNoteHdrWndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

void CNoteHdr::RelayToolTip(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    MSG     Msg;

    if (m_hwndTT != NULL)
    {
        Msg.lParam=lParam;
        Msg.wParam=wParam;
        Msg.message=msg;
        Msg.hwnd=hwnd;
        SendMessage(m_hwndTT, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &Msg);
    }
}

LRESULT CALLBACK CNoteHdr::CNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    POINT   pt;
    int     newWidth;
    RECT    rc;
    HFONT   hFont=NULL;

    switch (msg)
    {
        case WM_HEADER_GETFONT:
            // update cached fornt for addrobj's
            if (g_lpIFontCache)
                g_lpIFontCache->GetFont(wParam ? FNT_SYS_ICON_BOLD:FNT_SYS_ICON, m_hCharset, &hFont);
            return (LRESULT)hFont;

        case  HDM_TESTQUERYPRI:
            // hack for test team to query header's priority...
            return m_pri;

        case WM_DESTROY:
            OnDestroy();
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;

        case WM_CTLCOLORBTN:
            // make sure the buttons backgrounds are window-color so the ownerdraw
            // imagelists paint transparent OK
            return (LPARAM)GetSysColorBrush(COLOR_WINDOWFRAME);

        case WM_CONTEXTMENU:
            if (m_lpAttMan && m_lpAttMan->WMContextMenu(hwnd, msg, wParam, lParam))
                return 0;
            break;

        case WM_MOUSEMOVE:
            {
                DWORD newButton = GetButtonUnderMouse(LOWORD(lParam), HIWORD(lParam));
                if ((HDRCB_NO_BUTTON == m_dwClickedBtn) || 
                    (HDRCB_NO_BUTTON == newButton) ||
                    (m_dwClickedBtn == newButton))
                if (newButton != m_dwCurrentBtn)
                {
                    DOUTL(PAINTING_DEBUG_LEVEL, "Old button: %d, New Button: %d", m_dwCurrentBtn, newButton);

                    if (HDRCB_NO_BUTTON == newButton)
                    {
                        DOUTL(PAINTING_DEBUG_LEVEL, "Leaving right button framing.");
                        // Need to clear old button.
                        InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);

                        HeaderRelease(FALSE);                
                    }
                    else
                    {
                        DOUTL(PAINTING_DEBUG_LEVEL, "Framing button.");
                        if (HDRCB_NO_BUTTON == m_dwCurrentBtn)
                            HeaderCapture();
                        else
                            InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);

                        GetButtonRect(newButton, &m_rcCurrentBtn);
                        InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);
                    }

                    m_dwCurrentBtn = newButton;
                }
                RelayToolTip(hwnd, msg, wParam, lParam);
                break;
            }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            {
                RECT    rc;
                int x = LOWORD(lParam),
                    y = HIWORD(lParam);

                HeaderCapture();

                m_dwClickedBtn = GetButtonUnderMouse(x, y);
                if (m_dwClickedBtn != HDRCB_NO_BUTTON)
                {
                    GetButtonRect(m_dwClickedBtn, &rc);
                    InvalidateRect(m_hwnd, &rc, FALSE);
                }

                RelayToolTip(hwnd, msg, wParam, lParam);

                break;
            }
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            {
                int x = LOWORD(lParam),
                    y = HIWORD(lParam);
                DWORD iBtn = GetButtonUnderMouse(x, y);

                RelayToolTip(hwnd, msg, wParam, lParam);

                if (m_dwClickedBtn == iBtn)
                    HandleButtonClicks(x, y, iBtn);
                m_dwClickedBtn = HDRCB_NO_BUTTON;
                HeaderRelease(FALSE);                
                break;
            }

        case WM_PAINT:
            WMPaint();
            break;

        case WM_SYSCOLORCHANGE:
            if (m_himl)
            {
                // remap the toolbar bitmap into the new color scheme
                ImageList_Destroy(m_himl);
                SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, NULL);
                m_himl = LoadMappedToolbarBitmap(g_hLocRes, (fIsWhistler() ? ((GetCurColorRes() > 24) ? idb32SmBrowserHot : idbSmBrowserHot): idbNWSmBrowserHot), cxTBButton);
        
                SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_himl);
            }
            
            UpdateRebarBandColors(m_hwndRebar);
            // fall thro'

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            SendMessage(m_hwndRebar, msg, wParam, lParam);
            break;

        case WM_ERASEBKGND:
            return 1;

        case WM_SIZE:
        {
            STACK("WM_SIZE (width, heigth)", LOWORD(lParam), HIWORD(lParam));

            if (m_fResizing)
                break;

            m_fResizing = TRUE;

            newWidth = LOWORD(lParam);

            SetPosOfControls(newWidth, FALSE);

            if (m_hwndRebar)
            {
                GetClientRect(m_hwndRebar, &rc);

                // resize the width of the toolbar
                if(rc.right != newWidth)
                    SetWindowPos(m_hwndRebar, NULL, 0, 0, newWidth, 30, SETWINPOS_DEF_FLAGS|SWP_NOMOVE);
            }
            
            AssertSz(m_fResizing, "Someone re-entered me!!! Why is m_fResizing already false??");
            m_fResizing = FALSE;
            break;
        }

        case WM_CLOSE:
            //prevent alt-f4
            return 0;

        case WM_COMMAND:
            WMCommand(GET_WM_COMMAND_HWND(wParam, lParam),
                      GET_WM_COMMAND_ID(wParam, lParam),
                      GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case WM_NOTIFY:
            return WMNotify(wParam, lParam);
    }
    return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}


void CNoteHdr::HeaderCapture()
{
    if (0 == m_cCapture)
        m_hwndOldCapture = SetCapture(m_hwnd);
    m_cCapture++;
}

void CNoteHdr::HeaderRelease(BOOL fForce)
{
    if (0 == m_cCapture)
        return;

    if (fForce)
        m_cCapture = 0;
    else
        m_cCapture--;

    if (0 == m_cCapture)
    {
        ReleaseCapture();
        if (NULL != m_hwndOldCapture)
        {
            DOUTL(PAINTING_DEBUG_LEVEL, "Restoring old mouse events capture.");
            SetCapture(m_hwndOldCapture);
            m_hwndOldCapture = NULL;
        }
    }
}


BOOL CNoteHdr::WMNotify(WPARAM wParam, LPARAM lParam)
{
    HWND            hwnd=m_hwnd;
    int             idCtl=(int)wParam;
    LPNMHDR         pnmh=(LPNMHDR)lParam;
    TBNOTIFY       *ptbn;
    LPTOOLTIPTEXT   lpttt;
    int             i;

    if (m_lpAttMan->WMNotify((int) wParam, pnmh))
        return TRUE;

    switch (pnmh->code)
    {
        case RBN_CHEVRONPUSHED:
            {                    
                ITrackShellMenu* ptsm;                   
                CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER, IID_ITrackShellMenu, 
                    (LPVOID*)&ptsm);
                if (!ptsm)
                    break;

                ptsm->Initialize(0, 0, 0, SMINIT_TOPLEVEL|SMINIT_VERTICAL);
            
                LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnmh;                                        
                ptsm->SetObscured(m_hwndToolbar, NULL, SMSET_TOP);
            
                MapWindowPoints(m_hwndRebar, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);                  
                POINTL pt = {pnmch->rc.left, pnmch->rc.right};                   
                ptsm->Popup(m_hwndRebar, &pt, (RECTL*)&pnmch->rc, MPPF_BOTTOM);            
                ptsm->Release();                  
                break;      
            }

        case EN_MSGFILTER:
            {
                // if we get a control-tab, then richedit snags this and inserts a
                // tab char, we hook the wm_keydown and never pass to richedit
                if (((MSGFILTER *)pnmh)->msg == WM_KEYDOWN &&
                    ((MSGFILTER *)pnmh)->wParam == VK_TAB && 
                    (GetKeyState(VK_CONTROL) & 0x8000))
                    return TRUE;
                break;
            }

        case ATTN_RESIZEPARENT:
            {
                RECT rc;

                GetClientRect(m_hwnd, &rc);
                SetPosOfControls(rc.right, TRUE);
                return TRUE;
            }

        case EN_REQUESTRESIZE:
            {
                REQRESIZE  *presize=(REQRESIZE *)lParam;
                HWND        hwndEdit = presize->nmhdr.hwndFrom;

                STACK("EN_REQUESTRESIZE (hwnd, width, heigth)", (DWORD_PTR)(presize->nmhdr.hwndFrom), presize->rc.right - presize->rc.left, presize->rc.bottom - presize->rc.top);

                if (S_FALSE != HrUpdateCachedHeight(hwndEdit, &presize->rc) && !m_fResizing)
                {
                    RECT rc;
                    DWORD   dwMask = (DWORD) SendMessage(hwndEdit, EM_GETEVENTMASK, 0, 0);

                    SendMessage(hwndEdit, EM_SETEVENTMASK, 0, dwMask & (~ENM_REQUESTRESIZE));

                    STACK("EN_REQUESTRESIZE after GrowControls");
                    
                    GetClientRect(m_hwnd, &rc);
                    SetPosOfControls(rc.right, FALSE);

                    SendMessage(hwndEdit, EM_SETEVENTMASK, 0, dwMask);
                }

                return TRUE;
            }

        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // UIActivate/Deactivate for attachment manager
            if (m_lpAttMan && pnmh->hwndFrom == m_lpAttMan->Hwnd())
                _UIActivate(pnmh->code == NM_SETFOCUS, pnmh->hwndFrom);
            break;

        case EN_SELCHANGE:
            {
                PHCI    phci=(PHCI)GetWndThisPtr(pnmh->hwndFrom);
                if (phci)
                    phci->dwACFlags &= ~AC_SELECTION;
                
                // update office toolbars if running as envelope
                if(m_pEnvelopeSite)
                    m_pEnvelopeSite->DirtyToolbars();

                // on a sel change, forward a note updatetoolbar to update the
                // cut|copy|paste buttons
                if (m_pHeaderSite)
                    m_pHeaderSite->Update();
                return TRUE;
            }

        case TTN_NEEDTEXT:
            // we use TTN_NEEDTEXT to show toolbar tips as we have different tips than toolbar-labels
            // because on the office-envelope toolbar only 2 buttons (send and bcc) have text next to the
            // buttons
            lpttt = (LPTOOLTIPTEXT) pnmh;
            lpttt->hinst = NULL;
            lpttt->lpszText = 0;
            
            for (i=0; i< ARRAYSIZE(c_rgTipLookup); i++)
            {
                if (c_rgTipLookup[i].idm == (int)lpttt->hdr.idFrom)
                {
                    lpttt->hinst = g_hLocRes;
                    lpttt->lpszText = MAKEINTRESOURCE(c_rgTipLookup[i].ids);
                    break;
                }
            }
            break;

        case TBN_DROPDOWN:
            {
                ptbn = (TBNOTIFY *)lParam;

                if (ptbn->iItem == ID_SET_PRIORITY)
                {
                    HMENU hMenuPopup;
                    UINT i;
                    hMenuPopup = LoadPopupMenu(IDR_PRIORITY_POPUP);

                    if (hMenuPopup != NULL)
                    {
                        for (i = 0; i < 3; i++)
                            CheckMenuItem(hMenuPopup, i, MF_UNCHECKED | MF_BYPOSITION);
                        GetPriority(&i);
                        Assert(i != priNone);
                        CheckMenuItem(hMenuPopup, 2 - i, MF_CHECKED | MF_BYPOSITION);

                        DoToolbarDropdown(hwnd, (LPNMHDR) lParam, hMenuPopup);

                        DestroyMenu(hMenuPopup);
                    }
                }
                break;
            }
    }
    return FALSE;
}

HRESULT CNoteHdr::WMCommand(HWND hwndCmd, int id, WORD wCmd)
{
    HWND    hwnd=m_hwnd;
    int     i;
    UINT    pri;

    if (m_lpAttMan && m_lpAttMan->WMCommand(hwndCmd, id, wCmd))
        return S_OK;

    for (i=0; i<(int)m_cHCI; i++)
        if (m_rgHCI[i].idEdit==id)
        {
            switch (wCmd)
            {
                case EN_CHANGE:
                    {
                        if (m_fHandleChange)
                        {
                            BOOL    fEmpty;
                            PHCI    phci = (PHCI)GetWndThisPtr(hwndCmd);
                            char    sz[cchHeaderMax+1];
                            DWORD   dwMask = 0;

                            RichEditProtectENChange(hwndCmd, &dwMask, TRUE);

                            Assert(phci);
                            fEmpty = (0 == GetRichEditTextLen(hwndCmd));

                            // if it has no text, see if it has object...
                            if (fEmpty && phci->preole)
                                fEmpty = (fEmpty && (0 == phci->preole->GetObjectCount()));

                            if (phci->dwFlags & HCF_ADDRWELL)
                                m_fAddressesChanged = TRUE;

                            phci->fEmpty = fEmpty;
                            SetDirtyFlag();

                            if (m_fAutoComplete && (m_rgHCI[i].dwFlags & HCF_ADDRWELL) && !IsReadOnly())
                            {
                                if (NULL == m_pTable)
                                {
                                    if (NULL == m_lpWab)
                                        HrCreateWabObject(&m_lpWab);
                                    if (m_lpWab)
                                        m_lpWab->HrGetPABTable(&m_pTable);
                                }
                                if (m_pTable)
                                    HrAutoComplete(hwndCmd, &m_rgHCI[i]);
                            }
                            RichEditProtectENChange(hwndCmd, &dwMask, FALSE);
                        }
                    }
                    return S_OK;

                case CBN_SELCHANGE:
                {
                    IImnAccount    *pAcct = NULL;

                    if (!m_fMail)
                    {
                        int     newIndex = ComboBox_GetCurSel(hwndCmd);
                        HWND    hwndNews = GetDlgItem(m_hwnd, idADNewsgroups);

                        // Don't need to warn if going to same account, or if there are no newgroups listed.
                        if ((newIndex != m_iCurrComboIndex) && (0 < GetWindowTextLength(hwndNews)))
                        {
                            if (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, c_szDSChangeNewsServer, MAKEINTRESOURCE(idsAthena), 
                                                              MAKEINTRESOURCE(idsChangeNewsServer), MB_OKCANCEL))
                            {
                                ComboBox_SetCurSel(hwndCmd, m_iCurrComboIndex);
                                return S_OK;
                            }
                            else
                                HdrSetRichEditText(hwndNews, c_wszEmpty, FALSE);
                        }
                        m_iCurrComboIndex = newIndex;
                    }
                    if (SUCCEEDED(HrGetAccountInHeader(&pAcct)))
                        ReplaceInterface(m_pAccount, pAcct);
                    ReleaseObj(pAcct);

                    return S_OK;
                }

                case CBN_SETFOCUS:
                case EN_SETFOCUS:
                    _UIActivate(TRUE, hwndCmd);
                    return S_OK;

                case CBN_KILLFOCUS:
                case EN_KILLFOCUS:
                    _UIActivate(FALSE, hwndCmd);
                    return S_OK;
            }
            return S_FALSE;
        }

    switch (id)
    {
        case ID_PRIORITY_LOW:
            SetPriority(priLow);
            return S_OK;

        case ID_PRIORITY_NORMAL:
            SetPriority(priNorm);
            return S_OK;

        case ID_PRIORITY_HIGH:
            SetPriority(priHigh);
            return S_OK;

        case ID_SET_PRIORITY:
            GetPriority(&pri);
            pri++;
            if (pri > priHigh)
                pri = priLow;
            SetPriority(pri);
            return S_OK;

        case ID_SELECT_ALL:
            {
                HWND hwndFocus=GetFocus();

                if (GetParent(hwndFocus)==m_hwnd)
                {
                    // only if it's one of our kids..
                    Edit_SetSel(hwndFocus, 0, -1);
                    return S_OK;
                }
            }
            break;

        case ID_CUT:
            if (FDoCutCopyPaste(WM_CUT))
                return S_OK;
            break;

        case ID_NOTE_COPY:
        case ID_COPY:
            if (FDoCutCopyPaste(WM_COPY))
                return S_OK;
            break;

        case ID_PASTE:
            if (FDoCutCopyPaste(WM_PASTE))
                return S_OK;
            break;

        case ID_DELETE_VCARD:
            m_fVCard = FALSE;
            SetDirtyFlag();
            HrOnOffVCard();
            return S_OK;

        case ID_OPEN_VCARD:
            HrShowVCardProperties(m_hwnd);
            return S_OK;

        case ID_DIGITALLY_SIGN:
        case ID_ENCRYPT:
            HrHandleSecurityIDMs(ID_DIGITALLY_SIGN == id);
            return S_OK;

        case ID_ADDRESS_BOOK:
            HrViewContacts();
            return S_OK;

            //this is for office use only
        case ID_CHECK_NAMES:
            HrCheckNames(FALSE, TRUE);
            return S_OK;

            //this is for office use only
        case ID_ENV_BCC:
            if (m_pEnvelopeSite)
            {
                ShowAdvancedHeaders(!m_fAdvanced);

                SetDwOption(OPT_MAILNOTEADVSEND, !!m_fAdvanced, NULL, NULL);

                // ~~~~ m_pHeaderSite is mutually exclusive to m_pEnvelopeSite
                //if (m_pHeaderSite)
                //    m_pHeaderSite->Update();

                return S_OK;
            }
            break;

        case ID_MESSAGE_OPTS:
            ShowEnvOptions();
            return S_OK;

        case ID_SAVE_ATTACHMENTS:
        case ID_NOTE_SAVE_ATTACHMENTS:
            if (m_pHeaderSite)
                m_pHeaderSite->SaveAttachment();

            return S_OK;

        // These next two should only be handled by the header if in the envelope
        case ID_SEND_MESSAGE:
        case ID_SEND_NOW:
            if (m_pEnvelopeSite)
            {
                m_fShowedUnicodeDialog = FALSE;
                m_iUnicodeDialogResult = 0;

                HrSend();
                return S_OK;
            }

        default:
            if (id>=ID_ADDROBJ_OLE_FIRST && id <=ID_ADDROBJ_OLE_LAST)
            {
                DoNoteOleVerb(id-ID_ADDROBJ_OLE_FIRST);
                return S_OK;
            }
    }

    return S_FALSE;
}

HRESULT CNoteHdr::HrAutoComplete(HWND hwnd, PHCI pHCI)
{
    CHARRANGE   chrg, chrgCaret;
    LPWSTR      pszPartial, pszSemiColon, pszComma;
    INT         i, j, len, iTextLen;
    LPWSTR      pszBuf=0;
    WCHAR       szFound[cchMaxWab+1];
    WCHAR       sz;
    HRESULT     hr = NOERROR;

    STACK("HrAutoComplete");

    *szFound = 0;

    // If the IME is open, bail out
    if (0 < m_dwIMEStartCount)
        return hr;

    if (NULL==hwnd || NULL==m_pTable || NULL==pHCI)
        return hr;

    if (pHCI->dwACFlags&AC_IGNORE)
        return hr;

    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrgCaret);
    if (chrgCaret.cpMin != chrgCaret.cpMax)
        return hr;

    if (S_OK != HrGetFieldText(&pszBuf, hwnd))
        return hr;

    sz = pszBuf[chrgCaret.cpMin];
    if (!(sz==0x0000 || sz==L' ' || sz==L';'|| sz==L',' || sz==L'\r'))
        goto cleanup;

    DOUTL(64, "HrAutoComplete- Didn't exit early");

    pszBuf[chrgCaret.cpMin] = 0x0000;
    pszSemiColon = StrRChrIW(pszBuf, &pszBuf[lstrlenW(pszBuf)], L';');
    pszComma = StrRChrIW(pszBuf, &pszBuf[lstrlenW(pszBuf)], L',');
    if (pszComma >= pszSemiColon)
        pszPartial = pszComma;
    else
        pszPartial = pszSemiColon;

    if (!pszPartial)
        pszPartial = pszBuf;
    else
        pszPartial++;    

    //skip spaces and returns... 
    while (*pszPartial==L' ' || *pszPartial==L'\r' || *pszPartial==L'\n')
        pszPartial++;

    if (NULL == *pszPartial)
        goto cleanup;
    
    //Certain richedits put in 0xfffc for an object, if our text is only that, it's no good
    if (*pszPartial==0xfffc && pszPartial[1]==0x0000)
        goto cleanup;

    len = lstrlenW(pszPartial);
    m_lpWab->SearchPABTable(m_pTable, pszPartial, szFound, ARRAYSIZE(szFound));

    if (*szFound != 0)
    {
        chrg.cpMin = chrgCaret.cpMin;
        chrg.cpMax = chrg.cpMin + lstrlenW(szFound) - len;
        if (chrg.cpMin < chrg.cpMax)
        {
            RichEditExSetSel(hwnd, &chrgCaret);
            HdrSetRichEditText(hwnd, szFound + len, TRUE);
            SendMessage(hwnd, EM_SETMODIFY, (WPARAM)(UINT)TRUE, 0);
            RichEditExSetSel(hwnd, &chrg);
            pHCI->dwACFlags |= AC_SELECTION;
        }
    }

cleanup:
    MemFree(pszBuf);
    return hr;
}



void CNoteHdr::WMPaint()
{
    PAINTSTRUCT ps;
    HDC         hdc,
                hdcMem;
    RECT        rc;
    PHCI        phci = m_rgHCI;
    HBITMAP     hbmMem;

    int         idc, 
                cxHeader,
                cyHeader,
                cxLabel = ControlXBufferSize(), 
                cyStatus,
                cyLeftButtonOffset = BUTTON_BUFFER,
                cxLabelWithBtn = cxLabel + CXOfButtonToLabel();
    char        sz[cchHeaderMax+1];
    int         cStatusBarLines = 0;
    BOOL        fBold;
    HWND        hwnd;

    if (!m_hwnd)
        return;

    STACK("WMPaint");

    if (m_fFlagged || (priLow == m_pri) || (priHigh == m_pri) || (MARK_MESSAGE_NORMALTHREAD != m_MarkType))
        cStatusBarLines++;
    
    if (m_lpAttMan->GetUnsafeAttachCount())
        cStatusBarLines++;

    hdc = BeginPaint(m_hwnd, &ps);

    // **************** Init the background bitmap ****************
    hdcMem = CreateCompatibleDC(hdc);
    idc = SaveDC(hdcMem);

    GetClientRect(m_hwnd, &rc);
    cxHeader = rc.right;
    cyHeader = rc.bottom;

    hbmMem = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);
    SelectObject(hdcMem, (HGDIOBJ)hbmMem);

    // **************** Clear the rect *****************
    FillRect(hdcMem, &rc, GetSysColorBrush(COLOR_BTNFACE));

    // **************** Setup the HDC ******************
    fBold = IsReadOnly();
    SetBkColor(hdcMem, GetSysColor(COLOR_BTNFACE));  // colour of header window
    SetBkMode(hdcMem, TRANSPARENT);
    SetTextColor(hdcMem, GetSysColor(COLOR_BTNTEXT));
    SelectObject(hdcMem, GetFont(fBold));

    // **************** Paint the left labels and buttons **************
    // Center the buttons images
    if (g_cyFont > cyBtn)
        cyLeftButtonOffset += ((g_cyFont - cyBtn) / 2);

    for (int i = 0; (ULONG)i < m_cHCI; i++, phci++)
    {
        if (S_OK == HrFShowHeader(phci))
        {
            if (HCF_HASBUTTON & phci->dwFlags)
            {
                TextOutW(hdcMem, cxLabelWithBtn, phci->cy + BUTTON_BUFFER, phci->sz, phci->strlen);
                ImageList_Draw(g_himlBtns, (HCF_ADDRBOOK & phci->dwFlags)?0:1, hdcMem, cxLabel, phci->cy + cyLeftButtonOffset, ILD_NORMAL);
            }
            else
                TextOutW(hdcMem, cxLabel, (HCF_BORDER & phci->dwFlags)? phci->cy + BUTTON_BUFFER: phci->cy, phci->sz, phci->strlen);
        }
    }

    // **************** Paint the status bar as needed *******************
    if (cStatusBarLines > 0)
    {
        int     cxStatusBtn = ControlXBufferSize() + 1,     // 1 added for the border
                cyStatusBtn = m_dxTBOffset + cyBorder + 1,  // 1 added for the border
                cyStatusBmp = cyStatusBtn,
                cNumButtons = 0;
        LPTSTR  pszTitles[3]={0};

        // Center the buttons images
        if (g_cyFont > cyBtn)
            cyStatusBmp += ((g_cyFont - cyBtn) / 2);

        // Fill the dark rect
        rc.top = m_dxTBOffset;
        rc.bottom = m_dxTBOffset + GetStatusHeight(cStatusBarLines);
        FillRect(hdcMem, &rc, GetSysColorBrush(COLOR_BTNSHADOW));
        InflateRect(&rc, -1, -1);
        FillRect(hdcMem, &rc, GetSysColorBrush(COLOR_INFOBK));

        // Set up the DC for the rest of the status bar
        SetBkColor(hdcMem, GetSysColor(COLOR_INFOBK));  // colour of header window
        SetTextColor(hdcMem, GetSysColor(COLOR_INFOTEXT));
        SelectObject(hdcMem, GetFont(FALSE));

        // Draw icons in status bar
        if (priLow == m_pri)
        {
            ImageList_Draw(g_himlStatus, 1, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatLowPri;
        }
        else if (priHigh == m_pri)
        {
            ImageList_Draw(g_himlStatus, 0, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatHighPri;
        }

        if (MARK_MESSAGE_WATCH == m_MarkType)
        {
            ImageList_Draw(g_himlStatus, 4, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatWatched;
        }
        else if (MARK_MESSAGE_IGNORE == m_MarkType)
        {
            ImageList_Draw(g_himlStatus, 5, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatIgnored;
        }

        if (m_fFlagged)
        {
            ImageList_Draw(g_himlStatus, 2, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
            pszTitles[cNumButtons++] = g_szStatFlagged;
        }

        if (m_lpAttMan->GetUnsafeAttachCount())
        {
            ImageList_Draw(g_himlStatus, 6, hdcMem, cxStatusBtn, cyStatusBmp+2, ILD_NORMAL);
            cxStatusBtn += cxFlagsDelta;
        }

        if (cNumButtons > 0)
        {
            char    szHeaderString[cchHeaderMax*4+1];

            // Add an additional pixel for the text.
            cyStatusBtn++;
            switch (cNumButtons)
            {
                case 1:
                {
                    wnsprintf(szHeaderString, ARRAYSIZE(szHeaderString), g_szStatFormat1, pszTitles[0]);
                    TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
                    break;
                }
                case 2:
                {
                    wnsprintf(szHeaderString, ARRAYSIZE(szHeaderString), g_szStatFormat2, pszTitles[0], pszTitles[1]);
                    TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
                    break;
                }
                case 3:
                {
                    wnsprintf(szHeaderString, ARRAYSIZE(szHeaderString), g_szStatFormat3, pszTitles[0], pszTitles[1], pszTitles[2]);
                    TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
                    break;
                }
            }
            cyStatusBtn += CYOfStatusLine() - 1;
        }

        if (m_lpAttMan->GetUnsafeAttachCount())
        {
            char    szHeaderString[cchHeaderMax*4+1];

            // Add an additional pixel for the text.
            cyStatusBtn++;
            wnsprintf(szHeaderString, ARRAYSIZE(szHeaderString), g_szStatUnsafeAtt, m_lpAttMan->GetUnsafeAttachList());
            TextOut(hdcMem, cxStatusBtn, cyStatusBtn, szHeaderString, lstrlen(szHeaderString));    
        }
    }

    // ************ Draw the right side buttons **************
    if (m_fDigSigned || m_fEncrypted || m_fVCard)
    {
        int width = GetRightMargin(TRUE),
            cx = cxHeader - (ControlXBufferSize() + cxBtn),
            cy = BeginYPos() + BUTTON_BUFFER,
            yDiff = cyBtn + ControlYBufferSize() + 2*BUTTON_BUFFER;

        if (m_fDigSigned)
        {
            ImageList_Draw(g_himlSecurity, m_fSignTrusted?0:2, hdcMem, cx, cy, ILD_NORMAL);
            cy += yDiff;
        }

        if (m_fEncrypted)
        {
            ImageList_Draw(g_himlSecurity, m_fEncryptionOK?1:3, hdcMem, cx, cy, ILD_NORMAL);
            cy += yDiff;
        }

        if (m_fVCard)
        {
            ImageList_Draw(g_himlBtns, 2, hdcMem, cx, cy, ILD_NORMAL);
        }
    }

    // Draw active button edge
    if (HDRCB_NO_BUTTON != m_dwCurrentBtn)
    {
        DOUTL(PAINTING_DEBUG_LEVEL, "Framing button %d: (%d, %d) to (%d, %d)", 
                m_dwCurrentBtn, m_rcCurrentBtn.left, m_rcCurrentBtn.top, m_rcCurrentBtn.right, m_rcCurrentBtn.bottom);
        if (HDRCB_NO_BUTTON == m_dwClickedBtn)
            DrawEdge(hdcMem, &m_rcCurrentBtn, BDR_RAISEDINNER, BF_TOPRIGHT | BF_BOTTOMLEFT);
        else
            DrawEdge(hdcMem, &m_rcCurrentBtn, BDR_SUNKENINNER, BF_TOPRIGHT | BF_BOTTOMLEFT);
    }

    BitBlt(hdc, 0, 0, cxHeader, cyHeader, hdcMem, 0, 0, SRCCOPY);

    RestoreDC(hdcMem, idc);

    DeleteObject(hbmMem);
    DeleteDC(hdcMem);

    EndPaint(m_hwnd, &ps);
}


HRESULT CNoteHdr::HrFillToolbarColor(HDC hdc)
{
    HRESULT hr = NOERROR;
    RECT    rc;

    if (!m_hwndToolbar)
        return hr;

    GetRealClientRect(m_hwndToolbar, &rc);
    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    return hr;
}


HRESULT CNoteHdr::HrGetVCardName(LPTSTR pszName, DWORD cch)
{
    HRESULT hr = E_FAIL;

    if (pszName == NULL || cch==0)
        goto error;

    *pszName = 0;
    if (m_fMail)
        GetOption(OPT_MAIL_VCARDNAME, pszName, cch);
    else
        GetOption(OPT_NEWS_VCARDNAME, pszName, cch);

    if (*pszName != 0)
        hr = NOERROR;

    error:
    return hr;
}

// turn on or off the vcard stamp.
HRESULT CNoteHdr::HrOnOffVCard()
{
    HRESULT     hr = NOERROR;
    RECT        rc;
    TOOLINFO    ti = {0};

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = 0;
    ti.uId = idVCardStamp;
    ti.hinst=g_hLocRes;
    ti.hwnd = m_hwnd;

    if (m_fVCardSave == m_fVCard)
        return hr;
    else
        m_fVCardSave = m_fVCard;

    if (m_fVCard)
    {
        ti.lpszText = (LPTSTR)idsTTVCardStamp;

        SendMessage(m_hwndTT, TTM_ADDTOOL, 0, (LPARAM) &ti);
    }
    else
        SendMessage(m_hwndTT, TTM_DELTOOL, 0, (LPARAM) &ti);

    InvalidateRightMargin(0);
    ReLayout();

    return hr;
}

HRESULT CNoteHdr::HrGetVCardState(ULONG* pCmdf)
{
    TCHAR       szBuf[MAX_PATH];
    HRESULT     hr;

    // if OLECMDF_LATCHED is on, insert vcard menu should be checked.
    if (m_fVCard)
        *pCmdf |= OLECMDF_LATCHED;

    hr = HrGetVCardName(szBuf, sizeof(szBuf));
    if (FAILED(hr)) // no vcard name selected
    {
        *pCmdf &= ~OLECMDF_ENABLED;
        *pCmdf &= ~OLECMDF_LATCHED;
    }
    else
        *pCmdf |= OLECMDF_ENABLED;

    return NOERROR;
}


HRESULT CNoteHdr::HrShowVCardCtxtMenu(int x, int y)
{
    HMENU   hPopup=0;
    HRESULT hr = E_FAIL;
    POINT   pt;

    if (!m_fVCard)
        goto exit;

    // Pop up the context menu.
    hPopup = LoadPopupMenu(IDR_VCARD_POPUP);
    if (!hPopup)
        goto exit;

    if (IsReadOnly())
        EnableMenuItem(hPopup, ID_DELETE_VCARD, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);

    pt.x = x;
    pt.y = y;
    ClientToScreen(m_hwnd, &pt);
    TrackPopupMenuEx( hPopup, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                      pt.x, pt.y, m_hwnd, NULL);

    hr = NOERROR;

    exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return hr;
}

HRESULT CNoteHdr::HrShowVCardProperties(HWND hwnd)
{
    HRESULT         hr = NOERROR;
    LPWAB           lpWab = NULL;
    TCHAR           szName[MAX_PATH] = {0};
    UINT            cb = 0;

    if (IsReadOnly() && m_lpAttMan)
        return m_lpAttMan->HrShowVCardProp();

    //else
    //    return E_FAIL;

    hr = HrGetVCardName(szName, sizeof(szName));
    if (FAILED(hr))
        goto error;

    hr = HrCreateWabObject(&lpWab);
    if (FAILED(hr))
        goto error;

    //load names into the combobox from personal address book
    hr = lpWab->HrEditEntry(hwnd, szName, ARRAYSIZE(szName));
    if (FAILED(hr))
        goto error;

    error:
    if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrVCardProperties),
                      NULL, MB_OK | MB_ICONEXCLAMATION);

    ReleaseObj(lpWab);
    return hr;
}


LRESULT CALLBACK CNoteHdr::IMESubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PHCI phci)
{
    CNoteHdr   *pnh = NULL;
    HWND        hwndParent = GetParent(hwnd);

    STACK("IMESubClassProc");

    if (IsWindow(hwndParent))
    {
        // Get the header class of the header window
        pnh = (CNoteHdr *)GetWndThisPtr(hwndParent);

        switch (msg)
        {
            case WM_IME_STARTCOMPOSITION:
                DOUTL(64, "WM_IME_STARTCOMPOSITION");
                pnh->m_dwIMEStartCount++;
                break;

            case WM_IME_ENDCOMPOSITION:
                DOUTL(64, "WM_IME_ENDCOMPOSITION");

                // Make sure we don't go negative.
                if (0 < pnh->m_dwIMEStartCount)
                {
                    pnh->m_dwIMEStartCount--;
                }
                else
                {
                    AssertSz(FALSE, "We just received an extra WM_IME_ENDCOMPOSITION");
                    DOUTL(64, "WM_IME_ENDCOMPOSITION, not expected");
                }
                break;
        }
    }

    // Defer to the default window proc
    return CallWindowProcWrapW(g_lpfnREWndProc, hwnd, msg, wParam, lParam);
}

// bug #28379
// this is a hack to work around RichEd32 4.0 above bug in which
// it did not syncronize the keyboard change in the child windows.
// we use these global variable to keep track which keyboard
// is using now.
static HKL g_hCurrentKeyboardHandle = NULL ;
static BOOL g_fBiDiSystem = (BOOL) GetSystemMetrics(SM_MIDEASTENABLED);
static TCHAR g_chLastPressed = 0;
LRESULT CALLBACK CNoteHdr::EditSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    int         idcKeep;
    PHCI        phci;
    LRESULT     lRet;
    CHARRANGE   chrg;

    phci=(PHCI)GetWndThisPtr(hwnd);
    Assert(phci);
    Assert(g_lpfnREWndProc);


    if (phci && (phci->dwFlags&HCF_ADDRWELL))
    {
        switch (msg)
        {
            case WM_IME_STARTCOMPOSITION:
            case WM_IME_ENDCOMPOSITION:
                return IMESubClassProc(hwnd, msg, wParam, lParam, phci);

            case WM_CUT:
                // if cutting a selection, make sure we don't autocomplete when we get the en_change
                goto cut;

            case WM_KEYDOWN:
                if (VK_BACK==wParam ||
                    VK_DELETE==wParam ||
                    ((GetKeyState(VK_CONTROL)&0x8000) && ('x'==wParam || 'X'==wParam)))
                {
                    // if deleting a selection, make sure we don't autocomplete when we get the en_change
                    cut:
                    phci->dwACFlags |= AC_IGNORE;
                    lRet = CallWindowProcWrapW(g_lpfnREWndProc, hwnd, msg, wParam, lParam);
                    phci->dwACFlags &= ~AC_IGNORE;
                    return lRet;
                }
                else if (phci->dwACFlags&AC_SELECTION && (VK_RETURN==wParam))
                {
                    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrg);
                    if (chrg.cpMin < chrg.cpMax)
                    {
                        chrg.cpMin = chrg.cpMax;
                        SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&chrg);
                        HdrSetRichEditText(hwnd, (',' == wParam) ? L", ": L"; ", TRUE);
                        return 0;
                    }
                }

                // bobn: brianv says we have to take this out...
                /*if ((g_dwBrowserFlags == 3) && (GetKeyState(VK_CONTROL)&0x8000) && (GetKeyState(VK_SHIFT)&0x8000))
                {
                    switch(wParam) {
                        case 'R':
                            g_chLastPressed = (g_chLastPressed == 0) ? 'R' : 0;
                            break;
                        case 'O':
                            g_chLastPressed = (g_chLastPressed == 'R') ? 'O' : 0;
                            break;
                        case 'C':
                            g_chLastPressed = (g_chLastPressed == 'O') ? 'C' : 0;
                            break;
                        case 'K':
                            if (g_chLastPressed == 'C')
                                g_dwBrowserFlags |= 4;
                            g_chLastPressed = 0;
                            break;
                    }
                }*/
                break;

            case WM_CHAR:
                // VK_RETURN is no longer sent as a WM_CHAR so we place it in the
                // WM_KEYDOWN. RAID 75444
                if (phci->dwACFlags&AC_SELECTION && (wParam==',' || wParam==';'))
                {
                    SendMessage(hwnd, EM_EXGETSEL, 0, (LPARAM)&chrg);
                    if (chrg.cpMin < chrg.cpMax)
                    {
                        chrg.cpMin = chrg.cpMax;
                        SendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&chrg);
                        HdrSetRichEditText(hwnd, (wParam==',') ? L", ": L"; ", TRUE);
                        return 0;
                    }
                }
                break;

          case WM_SETFOCUS:
          if(g_fBiDiSystem)
          {
              HKL hklUS = NULL;
              GetUSKeyboardLayout(&hklUS);
              ActivateKeyboardLayout(hklUS, 0);
          }   
          break;
                
        }
    }

    // bug #28379
    // this is a hack to work around RichEd32 4.0 above bug in which
    // it did not syncronize the keyboard change in the child windows.
    // we use these global variable to keep track which keyboard
    // is using now.

    //a-msadek; bug# 45709
    // BiDi richedit uses WM_INPUTLANGCHANGE to determine reading order
    // This will make it confused causing Latin text displayed flipped
    if(!g_fBiDiSystem)
    {
        if (msg == WM_INPUTLANGCHANGE )
        {
            if ( g_hCurrentKeyboardHandle &&
                 g_hCurrentKeyboardHandle != (HKL) lParam )
                ActivateKeyboardLayout(g_hCurrentKeyboardHandle, 0 );
        }
        if (msg == WM_INPUTLANGCHANGEREQUEST )
            g_hCurrentKeyboardHandle = (HKL) lParam ;
    }

    // dispatch subject off to regular edit wndproc, and to & cc off to the RE wnd proc.
    return CallWindowProcWrapW(g_lpfnREWndProc, hwnd, msg, wParam, lParam);
}

void GetUSKeyboardLayout(HKL *phkl)
{
    UINT cNumkeyboards = 0, i;
    HKL* phKeyboadList = NULL;
    HKL hKeyboardUS = NULL;
    // Let's check how many keyboard the system has
    cNumkeyboards = GetKeyboardLayoutList(0, phKeyboadList);

    phKeyboadList = (HKL*)LocalAlloc(LPTR, cNumkeyboards * sizeof(HKL));  
    cNumkeyboards = GetKeyboardLayoutList(cNumkeyboards, phKeyboadList);

    for (i = 0; i < cNumkeyboards; i++)
    {
        LANGID LangID = PRIMARYLANGID(LANGIDFROMLCID(LOWORD(phKeyboadList[i])));
        if(LangID == LANG_ENGLISH)
        {
            *phkl = phKeyboadList[i];
            break;
        }
    }
   if(phKeyboadList)
   {
       LocalFree((HLOCAL)phKeyboadList);
   }
}

HRESULT CNoteHdr::HrUpdateTooltipPos()
{
    TOOLINFO    ti;

    if (m_hwndTT)
    {
/*        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hwnd;
        ti.uId = idStamp;
        ::SetRect(&ti.rect, m_ptStamp.x, m_ptStamp.y, m_ptStamp.x + cxStamp, m_ptStamp.y + cyStamp);
        SendMessage(m_hwndTT, TTM_NEWTOOLRECT, 0, (LPARAM) &ti);

        if (m_fVCard)
        {
            ti.uFlags = 0;
            ti.uId = idVCardStamp;
            ti.lpszText = (LPTSTR) idsTTVCardStamp;
            if (m_pri!=priNone) //mail
                ::SetRect(&ti.rect, m_ptStamp.x, m_ptStamp.y*2+cyStamp, m_ptStamp.x + cxStamp, 2*(m_ptStamp.y+cyStamp));
            else // news
                ::SetRect(&ti.rect, m_ptStamp.x, m_ptStamp.y, m_ptStamp.x + cxStamp, m_ptStamp.y + cyStamp);

            SendMessage(m_hwndTT, TTM_NEWTOOLRECT, 0, (LPARAM) &ti);
        }*/

    }
    return NOERROR;
}

HRESULT CNoteHdr::HrInit(IMimeMessage *pMsg)
{
    HWND    hwnd;
    HRESULT hr=S_OK;

    if (m_hwnd) // already running
        return S_OK;

    if (!FInitRichEdit(TRUE))
        return E_FAIL;

    if (!m_pEnvelopeSite)
    {
        Assert(m_hwndParent);
        hwnd=CreateWindowExWrapW(   WS_EX_CONTROLPARENT|WS_EX_NOPARENTNOTIFY,
                                    WC_ATHHEADER,
                                    NULL,
                                    WS_VISIBLE|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_CHILD,
                                    0,0,0,0,
                                    m_hwndParent,
                                    (HMENU)idcNoteHdr,
                                    g_hInst, (LPVOID)this );
    }
    else
    {
        Assert(!m_hwnd);

        hr = HrOfficeInitialize(TRUE);
        if (FAILED(hr))
            goto error;

        m_hwndParent = g_hwndInit;

        hwnd=CreateWindowExWrapW(WS_EX_CONTROLPARENT|WS_EX_NOPARENTNOTIFY,
                                 WC_ATHHEADER,
                                 NULL,
                                 WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_CHILD,
                                 0,0,0,0,
                                 m_hwndParent,
                                 (HMENU)idcNoteHdr,
                                 g_hInst, (LPVOID)this);

        if (!hwnd)
        {
            hr = E_FAIL;
            goto error;
        }

        m_ntNote = OENA_COMPOSE;
        m_fMail = TRUE;

        if (pMsg)
            hr = Load(pMsg);
        else
            hr = HrOfficeLoad();
        if (FAILED(hr))
            goto error;
    }


    if (!hwnd)
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    m_hwnd = hwnd;
    m_fDirty=FALSE;

    error:
    return hr;
}


HRESULT CNoteHdr::HrOfficeInitialize(BOOL fInit)
{
    HRESULT             hr = E_FAIL;
    
    if (fInit)
    {
        hr = CoIncrementInit("CNoteHdr::HrOfficeInitialize", MSOEAPI_START_COMOBJECT, NULL, &m_hInitRef);
        if (FAILED(hr))
            return hr;

        if (!FHeader_Init(TRUE))
            return E_FAIL;

        m_fAutoComplete = TRUE;
        m_fDirty=FALSE;

        hr = _RegisterWithComponentMgr(TRUE);
        if (FAILED(hr))
            return E_FAIL;
        
        m_fOfficeInit = TRUE;
    }
    else
    {
        if (m_hInitRef)
            CoDecrementInit("CNoteHdr::HrOfficeInitialize", &m_hInitRef);

    }

    return NOERROR;
}


void CNoteHdr::OnNCDestroy()
{
    if (m_rgHCI)
    {
        MemFree(m_rgHCI);
        m_rgHCI = NULL;
        m_cHCI = 0;
    }

    _RegisterAsDropTarget(FALSE);
    _RegisterWithFontCache(FALSE);

    SafeRelease(m_pHeaderSite);
    SafeRelease(m_pEnvelopeSite);

    m_hwnd = NULL;
}

void CNoteHdr::OnDestroy()
{
    HrFreeFieldList();

    if (m_lpAttMan)
        m_lpAttMan->HrClose();

    // release office interfaces if we get torn down
    _RegisterWithComponentMgr(FALSE);
}


HRESULT CNoteHdr::ShowAdvancedHeaders(BOOL fShow)
{
    if (!!m_fAdvanced != fShow)
    {
        m_fAdvanced=fShow;

        ReLayout();

        if (m_hwndToolbar)
            SendMessage(m_hwndToolbar, TB_CHECKBUTTON, ID_ENV_BCC, MAKELONG(!!m_fAdvanced, 0));
    }

    return S_OK;
}


HRESULT CNoteHdr::HrFShowHeader(PHCI phci)
{
    Assert(phci);

    if (phci->dwFlags & HCF_COMBO)
    {
        if (m_cAccountIDs < 2)
            return S_FALSE;
        else
            return S_OK;
    }

    if (phci->dwFlags & HCF_ATTACH)
    {
        if (!m_fStillLoading)
        {
            ULONG cAttMan = 0;
            HrGetAttachCount(&cAttMan);

            if (cAttMan)
                return S_OK;
        }
        return S_FALSE;
    }

    if (phci->dwFlags & HCF_ADVANCED)
    {
        if (IsReadOnly())
        {
            // If it is a read note and CC is empty, don't show
            if (phci->fEmpty)
                return S_FALSE;
        }
        else
            // If is a send note and not suppose to show adv headers, don't show
            if (!m_fAdvanced)
                return S_FALSE;
    }

    if ((phci->dwFlags & HCF_OPTIONAL) && !DwGetOption(phci->dwOpt))
        return S_FALSE;

    if (phci->dwFlags & HCF_HIDDEN)
        return S_FALSE;

    return S_OK;
}

// =================================================================================
// SzGetDisplaySec
//      returns the security enhancements and state of such for this message
// Params:
//      OUT pidsLabel - if non-NULL, will contain the ids for the field name
// Returns:
//      a built string giving information about the signature and/or encryption
// =================================================================================
LPWSTR  CNoteHdr::SzGetDisplaySec(LPMIMEMESSAGE pMsg, int *pidsLabel)
{
    WCHAR       szResource[CCHMAX_STRINGRES];
    LPWSTR      lpszLabel = NULL;
    DWORD       cchSecurityField = 0;
    
    if (m_lpszSecurityField)
    {
        MemFree(m_lpszSecurityField);
        m_lpszSecurityField = NULL;
    }
    
    // check label first.
    if ((m_ntNote == OENA_READ) && pMsg)
    {
        HrGetLabelString(pMsg, &lpszLabel);
    }
   
    
    if (pidsLabel)
        *pidsLabel=idsSecurityField;

    UINT labelLen = 1;
    if(lpszLabel)
    {
        //Bug #101350 - lstrlenW will AV (and handle it) if passed a NULL
        labelLen += lstrlenW(lpszLabel);
    }
    
    // need to build string
    cchSecurityField = (2 * CCHMAX_STRINGRES + labelLen);
    if (!MemAlloc((LPVOID *)&m_lpszSecurityField, (cchSecurityField *sizeof(WCHAR))))
        return NULL;
    
    *m_lpszSecurityField = L'\0';

    // Example: "Digitally signed - signature unverifiable; Encrypted - Certificate is trusted"
    
    if (MST_SIGN_MASK & m_SecState.type)
    {
        AthLoadStringW(idsSecurityLineDigSign, szResource, ARRAYSIZE(szResource));
        StrCpyNW(m_lpszSecurityField, szResource, cchSecurityField);
        
        if (IsSignTrusted(&m_SecState))
            AthLoadStringW(idsSecurityLineSignGood, szResource, ARRAYSIZE(szResource));
        else if (MSV_BADSIGNATURE & m_SecState.ro_msg_validity)
            AthLoadStringW(idsSecurityLineSignBad, szResource, ARRAYSIZE(szResource));
        else if ((MSV_UNVERIFIABLE & m_SecState.ro_msg_validity) ||
            (MSV_MALFORMEDSIG & m_SecState.ro_msg_validity))
            AthLoadStringW(idsSecurityLineSignUnsure, szResource, ARRAYSIZE(szResource));
        
        else if ((ATHSEC_NOTRUSTWRONGADDR & m_SecState.user_validity) &&
            ((m_SecState.user_validity & ~ATHSEC_NOTRUSTWRONGADDR) == ATHSEC_TRUSTED) &&
            (! m_SecState.ro_msg_validity))
        {
            AthLoadStringW(idsSecurityLineSignPreProblem, szResource, ARRAYSIZE(szResource));
            StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
            AthLoadStringW(idsSecurityLineSignMismatch, szResource, ARRAYSIZE(szResource));
        }
        
        else if (((ATHSEC_TRUSTED != m_SecState.user_validity) && m_SecState.fHaveCert) ||
            (MSV_EXPIRED_SIGNINGCERT & m_SecState.ro_msg_validity))
        {
            AthLoadStringW(idsSecurityLineSignPreProblem, szResource, ARRAYSIZE(szResource));
            
            if (ATHSEC_TRUSTED != m_SecState.user_validity)
            {
                int nNotTrust = 0;
                
                StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
                
                // ignore revokedness for now
                if (ATHSEC_NOTRUSTUNKNOWN & m_SecState.user_validity)
                {
                    AthLoadStringW(idsSecurityLineSignUntrusted, szResource, ARRAYSIZE(szResource));
                }
                else if(ATHSEC_NOTRUSTREVOKED & m_SecState.user_validity)
                {
                    AthLoadStringW(idsSecurityLineSignRevoked, szResource, ARRAYSIZE(szResource));
                    nNotTrust = 1;
                }
                else if(ATHSEC_NOTRUSTOTHER & m_SecState.user_validity)
                {
                    AthLoadStringW(idsSecurityLineSignOthers, szResource, ARRAYSIZE(szResource));
                    nNotTrust = 1;
                }
                else if(m_SecState.user_validity & ATHSEC_NOTRUSTWRONGADDR)
                {
                    AthLoadStringW(idsSecurityLineSignMismatch, szResource, ARRAYSIZE(szResource));
                    nNotTrust = 1;
                }
                else // if(!(m_SecState.user_validity & ATHSEC_NOTRUSTNOTTRUSTED))
                    AthLoadStringW(idsSecurityLineSignDistrusted, szResource, ARRAYSIZE(szResource));
                
                if((m_SecState.user_validity & ATHSEC_NOTRUSTNOTTRUSTED) && nNotTrust)
                {
                    StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
                    AthLoadStringW(idsSecurityLineListStr, szResource, ARRAYSIZE(szResource));
                    StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
                    AthLoadStringW(idsSecurityLineSignDistrusted, szResource, ARRAYSIZE(szResource));
                }
                
                if (MSV_EXPIRED_SIGNINGCERT & m_SecState.ro_msg_validity)
                {
                    StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
                    AthLoadStringW(idsSecurityLineListStr, szResource, ARRAYSIZE(szResource));
                }
            }
            if (MSV_EXPIRED_SIGNINGCERT & m_SecState.ro_msg_validity)
            {
                StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
                AthLoadStringW(idsSecurityLineSignExpired, szResource, ARRAYSIZE(szResource));
            }
        }
        else
        {
            AthLoadStringW(idsSecurityLineSignUnsure, szResource, ARRAYSIZE(szResource));
        }
        StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
        
        if (MST_ENCRYPT_MASK & m_SecState.type)
        {
            AthLoadStringW(idsSecurityLineBreakStr, szResource, ARRAYSIZE(szResource));
            StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
        }
    }
    
    if (MST_ENCRYPT_MASK & m_SecState.type)
    {
        AthLoadStringW(idsSecurityLineEncryption, szResource, ARRAYSIZE(szResource));
        StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
        
        if (MSV_OK == (m_SecState.ro_msg_validity & MSV_ENCRYPT_MASK))
            AthLoadStringW(idsSecurityLineEncGood, szResource, ARRAYSIZE(szResource));
        else if (MSV_CANTDECRYPT & m_SecState.ro_msg_validity)
            AthLoadStringW(idsSecurityLineEncBad, szResource, ARRAYSIZE(szResource));
        else if (MSV_ENC_FOR_EXPIREDCERT & m_SecState.ro_msg_validity)
            AthLoadStringW(idsSecurityLineEncExpired, szResource, ARRAYSIZE(szResource));
        else
        {
            DOUTL(DOUTL_CRYPT, "CRYPT: bad encrypt state in SzGetDisplaySec");
            szResource[0] = _T('\000');
        }
        StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
    }
    
    if(lpszLabel != NULL)
    {
        AthLoadStringW(idsSecurityLineBreakStr, szResource, ARRAYSIZE(szResource));
        StrCatBuffW(m_lpszSecurityField, szResource, cchSecurityField);
        StrCatBuffW(m_lpszSecurityField, lpszLabel, cchSecurityField);
        MemFree(lpszLabel);
    }
    return m_lpszSecurityField;
}


HRESULT CNoteHdr::HrClearUndoStack()
{
    int     iHC;
    HWND    hwndRE;

    for (iHC=0; iHC<(int)m_cHCI; iHC++)
    {
        if (hwndRE = GetDlgItem(m_hwnd, m_rgHCI[iHC].idEdit))
            SendMessage(hwndRE, EM_EMPTYUNDOBUFFER, 0, 0);
    }

    return S_OK;
}

// There are some cases where we don't wan't the resolve name to
// be skipped. For example, a resolve name during a save will set
// m_fAddressesChanged to be false. That is fine, except it doesn't
// underline the addresses. So when the user tries to resolve the name
// by doing the resolve name command, the name will appear not to 
// be resolved. In this case, we don't want the next call to HrCheckNames
// to be skipped.
HRESULT CNoteHdr::HrCheckNames(BOOL fSilent, BOOL fSetCheckedFlag)
{
    HRESULT     hr;

    if (!m_fAddressesChanged)
        return S_OK;

    if (m_fPoster && (OENA_READ != m_ntNote))
    {
        //We need to setmodify the cc field.
        //We need to do this because this field is not typed in by the user.
        Edit_SetModify(GetDlgItem(m_hwnd, idADCc), TRUE);
    }

    hr = m_pAddrWells->HrCheckNames(m_hwnd, fSilent ? CNF_DONTRESOLVE : 0);
    if (SUCCEEDED(hr))
    {
        if (m_lpWabal == NULL)
            hr = hrNoRecipients;
        else
        {
            ADRINFO AdrInfo;
            if (!m_lpWabal->FGetFirst(&AdrInfo))
                hr = hrNoRecipients;
        }

        if (SUCCEEDED(hr) && fSetCheckedFlag)
            m_fAddressesChanged = FALSE;
    }    
    return hr;
}

HRESULT CNoteHdr::HrCheckGroups(BOOL fPosting)
{
    HRESULT     hr = S_OK;
    BOOL        fFailed = FALSE;
    ULONG       cReplyTo=0;
    ADRINFO     adrInfo;
    BOOL        fOneOrMoreNames = FALSE;
    BOOL        fMoreNames = FALSE;
    TCHAR       szAcctID[CCHMAX_ACCOUNT_NAME];
    FOLDERID    idServer = FOLDERID_INVALID;

    if (!m_pAccount)
        return E_FAIL;

    m_pAccount->GetPropSz(AP_ACCOUNT_ID, szAcctID, sizeof(szAcctID));
    // find the parent folder id of the account
    hr = g_pStore->FindServerId(szAcctID, &idServer);
    if (FAILED(hr))
        return hr;

    // check the group names...
    hr = ResolveGroupNames(m_hwnd, idADNewsgroups, idServer, FALSE, &fMoreNames);
    fOneOrMoreNames = fMoreNames;
    fFailed = FAILED(hr);

    // Check followup names
    hr = ResolveGroupNames(m_hwnd, idTXTFollowupTo, idServer, TRUE, &fMoreNames);
    fOneOrMoreNames = (fOneOrMoreNames || fMoreNames);
    fFailed = fFailed || FAILED(hr);

    if (!fOneOrMoreNames)
        return hrNoRecipients;

    if (fPosting)
    {
        // make sure there is only one reply-to person, in the wabal
        if (m_lpWabal->FGetFirst(&adrInfo))
            do
                if (adrInfo.lRecipType == MAPI_REPLYTO)
                    cReplyTo++;
            while (m_lpWabal->FGetNext(&adrInfo));

        if (cReplyTo>1)
        {
            // this is not cool. Don't allow then to post...
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsErrOnlyOneReplyTo), NULL, MB_OK);
            return hrTooManyReplyTo;
        }
    }

    if (fPosting && fFailed)
    {
        if (IDYES == AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsIgnoreResolveError), 0, MB_ICONEXCLAMATION |MB_YESNO))
            hr = S_OK;
        else
            hr = MAPI_E_USER_CANCEL;
    }

    return hr;
}


HRESULT CNoteHdr::ResolveGroupNames(HWND hwnd, int idField, FOLDERID idServer, BOOL fPosterAllowed, BOOL *fOneOrMoreNames)
{
    HRESULT hr = S_OK;
    FOLDERINFO  Folder;
    int nResolvedNames = 0;

    AssertSz((idServer != FOLDERID_INVALID), TEXT("ResolveGroupNames: [ARGS] No account folder"));
    
    // Now loop through the group names and see if they all exist.  First make
    // a copy of the string since strtok is destructive.
    LPWSTR  pwszBuffer = NULL;
    LPSTR   pszBuffer = NULL;
    DWORD   dwType;
    LONG    lIndex,
            cchBufLen,
            lIter = 0;
    TCHAR   szPrompt[CCHMAX_STRINGRES];
    LPTSTR  psz = NULL, 
            pszTok = NULL, 
            pszToken = NULL;

    // HrGetFieldText will return S_FALSE if no text
    hr = HrGetFieldText(&pwszBuffer, idField);
    if (S_OK != hr)
        return hr;

    IF_NULLEXIT(pszBuffer = PszToANSI(GetACP(), pwszBuffer));

    psz = pszBuffer;
    // Check group name
    while (*psz && IsSpace(psz))
        psz = CharNext(psz);

    if(!(*psz))
    {
        hr = S_FALSE;
        goto exit;
    }
    else
        psz = NULL;

    pszTok = pszBuffer;
    pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    while (NULL != pszToken)
    {
        if (!fPosterAllowed ||
            (fPosterAllowed && 0 != lstrcmpi(pszToken, c_szPosterKeyword)))
        {
            ZeroMemory(&Folder, sizeof(Folder));
    
            // See if the Folder Already Exists
            Folder.idParent = idServer;
            Folder.pszName = (LPSTR)pszToken;

            // Try to find in the index
            if (DB_S_FOUND == g_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                // Check to see if this newsgroup allows posting.
                if (Folder.dwFlags & FOLDER_NOPOSTING)
                {
                    psz = AthLoadString(idsErrNewsgroupNoPosting, 0, 0);
                    wnsprintf(szPrompt, ARRAYSIZE(szPrompt), psz, pszToken, pszToken);
                    AthFreeString(psz);

                    AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthenaNews), szPrompt,
                                  0, MB_ICONSTOP | MB_OK);
                    hr = E_FAIL;
                }

                if (Folder.dwFlags & FOLDER_BLOCKED)
                {
                    psz = AthLoadString(idsErrNewsgroupBlocked, 0, 0);
                    wnsprintf(szPrompt, ARRAYSIZE(szPrompt), psz, pszToken, pszToken);
                    AthFreeString(psz);

                    AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthenaNews), szPrompt,
                                  0, MB_ICONSTOP | MB_OK);
                    hr = E_FAIL;
                }
                else
                    nResolvedNames++;


                // Free
                g_pStore->FreeRecord(&Folder);
            }
            else
            {
                psz = AthLoadString(idsErrCantResolveGroup, 0, 0);
                wnsprintf(szPrompt, ARRAYSIZE(szPrompt), psz, pszToken);
                AthFreeString(psz);
                AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthenaNews), szPrompt, 0,
                              MB_ICONSTOP | MB_OK);
                hr = E_FAIL;
            }

        }

        pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    }

exit:
    MemFree(pszBuffer);
    MemFree(pwszBuffer);
    
    *fOneOrMoreNames = ((nResolvedNames > 0) ? TRUE : FALSE);
    return (hr);
}


HRESULT CNoteHdr::HrGetFieldText(LPWSTR* ppszText, int idHdrCtrl)
{
    HWND hwnd = GetDlgItem(m_hwnd, idHdrCtrl);

    return HrGetFieldText(ppszText, hwnd);
}

HRESULT CNoteHdr::HrGetFieldText(LPWSTR* ppszText, HWND hwnd)
{
    DWORD cch;

    cch = GetRichEditTextLen(hwnd) + 1;
    if (1 == cch)
        return (S_FALSE);

    if (!MemAlloc((LPVOID*) ppszText, cch * sizeof(WCHAR)))
        return (E_OUTOFMEMORY);

    HdrGetRichEditText(hwnd, *ppszText, cch, FALSE);

    return (S_OK);
}

HRESULT CNoteHdr::HrAddSender()
{
    ULONG       uPos=0;
    ADRINFO     adrInfo;
    LPADRINFO   lpAdrInfo=0;
    LPWAB       lpWab;
    HRESULT     hr=E_FAIL;

    if (m_lpWabal->FGetFirst(&adrInfo))
        do
            if (adrInfo.lRecipType==MAPI_ORIG)
            {
                lpAdrInfo=&adrInfo;
                break;
            }
        while (m_lpWabal->FGetNext(&adrInfo));

    if (lpAdrInfo &&
        !FAILED (HrCreateWabObject (&lpWab)))
    {
        hr=lpWab->HrAddToWAB(m_hwnd, lpAdrInfo);
        lpWab->Release ();
    }

    if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
    {
        if (hr==MAPI_E_COLLISION)
            AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddrDupe), NULL, MB_OK);
        else
            AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddToWAB), NULL, MB_OK);
    }
    return NOERROR;
}

HRESULT CNoteHdr::HrAddAllOnToList()
{
    ADRINFO     adrInfo;
    LPWAB       lpWab;
    HRESULT     hr = S_OK;

    if (m_lpWabal->FGetFirst(&adrInfo))
    {
        hr = HrCreateWabObject(&lpWab);
        if (SUCCEEDED(hr))
        {
            do
            {
                if (MAPI_TO == adrInfo.lRecipType)
                {
                    hr = lpWab->HrAddToWAB(m_hwnd, &adrInfo);
                    if (MAPI_E_COLLISION == hr)
                    {
                        hr = S_OK;
                        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddrDupe), NULL, MB_OK);
                    }
                }
            } while (SUCCEEDED(hr) && m_lpWabal->FGetNext(&adrInfo));
        }
        lpWab->Release();
    }

    if (FAILED(hr) && (MAPI_E_USER_CANCEL != hr))
        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrAddToWAB), NULL, MB_OK);

    return hr;
}


HRESULT CNoteHdr::HrInitFieldList()
{
    PHCI        pHCI, pLoopHCI;
    INT         size;
    BOOL        fReadOnly = IsReadOnly();

    if (m_fMail)
    {
        if (fReadOnly)
        {
            pHCI = rgMailHeaderRead;
            size = sizeof(rgMailHeaderRead);
        }
        else
        {
            pHCI = rgMailHeaderSend;
            size = sizeof(rgMailHeaderSend);
        }

    }
    else
    {
        if (fReadOnly)
        {
            pHCI = rgNewsHeaderRead;
            size = sizeof(rgNewsHeaderRead);
        }
        else
        {
            pHCI = rgNewsHeaderSend;
            size = sizeof(rgNewsHeaderSend);
        }
    }

    // Setup the labels
    pLoopHCI = pHCI;
    m_cHCI = size/sizeof(HCI);

    for (ULONG i = 0; i < m_cHCI; i++, pLoopHCI++)
    {
        if (0 == pLoopHCI->strlen)
        {
            AthLoadStringW(pLoopHCI->idsLabel, pLoopHCI->sz, cchHeaderMax+1);
            pLoopHCI->strlen = lstrlenW(pLoopHCI->sz);
        }
        if ((0 == pLoopHCI->strlenEmpty) && (0 != pLoopHCI->idsEmpty))
        {
            AthLoadStringW(pLoopHCI->idsEmpty, pLoopHCI->szEmpty, cchHeaderMax+1);
            pLoopHCI->strlenEmpty = lstrlenW(pLoopHCI->szEmpty);
        }
    }

    if (NULL != MemAlloc((LPVOID *)&m_rgHCI, size))
        CopyMemory(m_rgHCI, pHCI, size);
    else
        return E_OUTOFMEMORY;

    m_cxLeftMargin = _GetLeftMargin();

    return S_OK;
}

int CNoteHdr::_GetLeftMargin()
{
    PHCI        pLoopHCI = m_rgHCI;
    INT         size;
    int         cxButtons = ControlXBufferSize();
    HDC         hdc = GetDC(m_hwnd);
    HFONT       hfontOld;
    ULONG       cxEditMarginCur = 0,
                cxEditMaxMargin = 0;
    SIZE        rSize;
    BOOL        fReadOnly = IsReadOnly();

    // Setup the labels
    hfontOld=(HFONT)SelectObject(hdc, GetFont(fReadOnly));

    for (ULONG i = 0; i < m_cHCI; i++, pLoopHCI++)
    {
        AssertSz(pLoopHCI->strlen, "Haven't set the strings yet.");

        GetTextExtentPoint32AthW(hdc, pLoopHCI->sz, pLoopHCI->strlen, &rSize, NOFLAGS);
        cxEditMarginCur = rSize.cx + PaddingOfLabels();
        if (pLoopHCI->dwFlags & HCF_HASBUTTON)
            cxEditMarginCur += CXOfButtonToLabel();

        if (cxEditMarginCur > cxEditMaxMargin)
            cxEditMaxMargin = cxEditMarginCur;
    }
    SelectObject(hdc, hfontOld);
    ReleaseDC(m_hwnd, hdc);

    return cxEditMaxMargin;
}

HRESULT CNoteHdr::HrFreeFieldList()
{
    if (m_rgHCI)
    {
        for (int i=0; i<(int)m_cHCI; i++)
        {
            // You must free the pDoc before the preole or fault! (RICHED 2.0)
            SafeRelease(m_rgHCI[i].pDoc);
            SafeRelease(m_rgHCI[i].preole);
        }
    }
    return NOERROR;
}

static WELLINIT  rgWellInitMail[]=
{
    {idADTo, MAPI_TO},
    {idADCc, MAPI_CC},
    {idADFrom, MAPI_ORIG},
    {idADBCc, MAPI_BCC}
};

static WELLINIT rgWellInitNews[]=
{
    {idADFrom, MAPI_ORIG},
    {idADCc, MAPI_TO},
    {idADReplyTo, MAPI_REPLYTO}
};

BOOL CNoteHdr::PostWMCreate()
{
    HWND    hwnd;
    HWND    hwndWells[4];
    ULONG   ulRecipType[4];
    ULONG   cWells=0;
    PWELLINIT   pWI;
    INT     size;
    INT     i;

    if (hwnd=GetDlgItem(m_hwnd, idTXTSubject))
        SendMessage(hwnd, EM_LIMITTEXT,cchMaxSubject,0);

    if (m_fMail)
    {
        pWI = rgWellInitMail;
        size = ARRAYSIZE(rgWellInitMail);
    }
    else
    {
        pWI = rgWellInitNews;
        size = ARRAYSIZE(rgWellInitNews);
    }

    for (i=0; i<size; i++)
    {
        hwnd = GetDlgItem(m_hwnd, pWI[i].idField);
        if (hwnd)
        {
            hwndWells[cWells] = hwnd;
            ulRecipType[cWells++] = pWI[i].uMAPI;
        }
    }

    AssertSz(!m_pAddrWells, "Who called PostWMCreate??????");
    m_pAddrWells = new CAddrWells;

    if (!m_pAddrWells || FAILED(m_pAddrWells->HrInit(cWells, hwndWells, ulRecipType)))
        return FALSE;

    return TRUE;
}


HRESULT CNoteHdr::HrSetMailRecipients(LPMIMEMESSAGE pMsg)
{
    ADRINFO             rAdrInfo;
    HRESULT             hr = NOERROR;
    IImnEnumAccounts   *pEnumAccounts = NULL;
    LPWABAL             lpWabal = NULL;
    BOOL                fAdvanced = FALSE;

    AssertSz(OENA_REPLYTONEWSGROUP != m_ntNote, "Shouldn't get a REPLYTONEWSGROUP in a mail note.");

    SafeRelease(m_lpWabal);

    // Set initial state of wabals to use
    switch (m_ntNote)
    {
        case OENA_READ:
        case OENA_WEBPAGE:
        case OENA_STATIONERY:
            IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &m_lpWabal));
            break;

        case OENA_COMPOSE:
        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYALL:
            IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &lpWabal));
            IF_FAILEXIT(hr = HrCreateWabalObject(&m_lpWabal));
            break;

        case OENA_FORWARD:
        case OENA_FORWARDBYATTACH:
            IF_FAILEXIT(hr = HrCreateWabalObject(&m_lpWabal));
            break;
    }

    // Actually set recipients now.            
    switch (m_ntNote)
    {
        case OENA_COMPOSE:
        {
#pragma prefast(suppress:11, "noise")
            BOOL fMoreIterations = lpWabal->FGetFirst(&rAdrInfo);
            while (fMoreIterations)
            {
                if (rAdrInfo.lRecipType != MAPI_ORIG)
                {
                    hr = m_lpWabal->HrAddEntry(&rAdrInfo);
                    if (FAILED(hr))
                        break;
                }
                fMoreIterations = lpWabal->FGetNext(&rAdrInfo);
            }
            break;
        }

        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYALL:
        {
            BOOL    fNeedOriginatorItems = TRUE;
            BOOL    fMoreIterations;

            // Add items to To: line from the ReplyTo Field
            fMoreIterations = lpWabal->FGetFirst (&rAdrInfo);
            while (fMoreIterations)
            {
                if (rAdrInfo.lRecipType==MAPI_REPLYTO)
                {
                    Assert (rAdrInfo.lpwszAddress);

                    fNeedOriginatorItems = FALSE;
                    rAdrInfo.lRecipType=MAPI_TO;
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                }

                fMoreIterations = lpWabal->FGetNext (&rAdrInfo);
            }

            // If we don't need to add the MAPI_ORIG and we are not trying to reply to all, then we are done
            if (!fNeedOriginatorItems && (OENA_REPLYALL != m_ntNote))
                break;

            // Raid-35976: Unable to open message window with no accounts configured
            // Get an SMTP account enumerator
            Assert(g_pAcctMan);
            if (g_pAcctMan && (OENA_REPLYALL == m_ntNote))
                g_pAcctMan->Enumerate(SRV_SMTP|SRV_HTTPMAIL, &pEnumAccounts);

            // Add the following items to the To line 
            // 1) If there were no ReplyTo items, then fill from the Orig field
            // 2) If is ReplyToAll, then fill from the To and CC line
            fMoreIterations = lpWabal->FGetFirst (&rAdrInfo);
            while (fMoreIterations)
            {
                // No replyto people were added, and this is a MAPI_ORIG
                if (fNeedOriginatorItems && rAdrInfo.lRecipType == MAPI_ORIG)
                {
                    rAdrInfo.lRecipType=MAPI_TO;
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                }

                // pEnumAccounts will only be set if ReplyToAll
                // If ReplyToAll, then add the CC and To line entries to the To field
                else if (pEnumAccounts && (rAdrInfo.lRecipType == MAPI_TO || rAdrInfo.lRecipType == MAPI_CC))
                {
                    BOOL            fIsSendersAccount = FALSE;
                    TCHAR           szEmailAddress[CCHMAX_EMAIL_ADDRESS];

                    Assert (rAdrInfo.lpwszAddress);

                    pEnumAccounts->Reset();

                    // See if rAdrInfo.lpszAddress exist as one of the user's Send Email Addresses
                    while (!fIsSendersAccount)
                    {
                        IImnAccount    *pAccount = NULL;
                        hr = pEnumAccounts->GetNext(&pAccount);
                        if (hr == E_EnumFinished || FAILED(hr))
                            break;

                        if (SUCCEEDED(pAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmailAddress, ARRAYSIZE(szEmailAddress))))
                        {
                            LPWSTR pwszAddress = NULL;
                            IF_NULLEXIT(pwszAddress = PszToUnicode(CP_ACP, szEmailAddress));
                            if (0 == StrCmpIW(rAdrInfo.lpwszAddress, pwszAddress))
                                fIsSendersAccount = TRUE;
                            MemFree(pwszAddress);
                        }
                        pAccount->Release();
                    }

                    // Reset hr
                    hr = S_OK;

                    // Add the account if it isn't from the sender
                    if (!fIsSendersAccount)
                    {
                        if (0 != StrCmpW(rAdrInfo.lpwszAddress, L"Undisclosed Recipients"))
                        {
                            // only include recipient on ReplyAll if it's not the sender...
                            IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                        }
                    }
                }
                fMoreIterations = lpWabal->FGetNext(&rAdrInfo);
            }
        }
    }

    Assert (m_lpWabal);

    // For the send note case, make sure that resolved addresses are valid.
    // If display name and email address are the same, UnresolveOneOffs() will clear
    // the email address to force a real resolve.
    if (OENA_COMPOSE == m_ntNote || OENA_WEBPAGE == m_ntNote || OENA_STATIONERY == m_ntNote)
        m_lpWabal->UnresolveOneOffs();

    m_lpWabal->HrResolveNames(NULL, FALSE);

    Assert(m_pAddrWells);
    m_pAddrWells->HrSetWabal(m_lpWabal);
    m_pAddrWells->HrDisplayWells(m_hwnd);

    if (OENA_READ == m_ntNote)
        fAdvanced = DwGetOption(OPT_MAILNOTEADVREAD);
    else
    {
        fAdvanced = DwGetOption(OPT_MAILNOTEADVSEND);

        // Need to make sure that if we are in a compose note, that we check to see
        // if we added a bcc without setting the advanced headers. If this is the case,
        // then show the advanced headers for this note.
        if (!fAdvanced && (0 < GetRichEditTextLen(GetDlgItem(m_hwnd, idADBCc))))
            fAdvanced = TRUE;
    }
    // BUG: 31217: showadvanced has to be the last thing we call after modifying the
    // well contents
    ShowAdvancedHeaders(fAdvanced);

exit:
    // Cleanup
    ReleaseObj(lpWabal);
    ReleaseObj(pEnumAccounts);
    return hr;
}


HRESULT CNoteHdr::HrSetupNote(LPMIMEMESSAGE pMsg)
{
    HWND        hwnd;
    WCHAR       wsz[cchMaxSubject+1];
    LPWSTR      psz = NULL;
    PROPVARIANT rVariant;
    HRESULT     hr = NOERROR;

    if (!pMsg)
        return E_INVALIDARG;

    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &psz);
    HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), psz, FALSE);

    *wsz=0;
    rVariant.vt = VT_FILETIME;
    pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);
    AthFileTimeToDateTimeW(&rVariant.filetime, wsz, ARRAYSIZE(wsz), DTM_LONGDATE|DTM_NOSECONDS);

    HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTDate), wsz, FALSE);

    MemFree(psz);
    return hr;
}


HRESULT CNoteHdr::HrSetPri(LPMIMEMESSAGE pMsg)
{
    UINT            pri=priNorm;
    PROPVARIANT     rVariant;

    Assert(pMsg);

    rVariant.vt = VT_UI4;
    if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant)))
    {
        if (rVariant.ulVal == IMSG_PRI_HIGH)
            pri=priHigh;
        else if (rVariant.ulVal == IMSG_PRI_LOW)
            pri=priLow;
    }

    return SetPriority(pri);
}


HRESULT CNoteHdr::HrAutoAddToWAB()
{
    LPWAB   lpWab=0;
    LPWABAL lpWabal=0;
    HRESULT hr;
    ADRINFO adrInfo;

    if (!m_lpWabal)
        return S_OK;

    if (!DwGetOption(OPT_MAIL_AUTOADDTOWABONREPLY))
        return S_OK;

    IF_FAILEXIT(hr=HrCreateWabObject(&lpWab));

    // when this is called, m_lpWabal contains everyone on the to: and cc: line
    // for a reply/reply all. We will add all these people to the WAB, ignoring any
    // clashes or failures
    // Add Sender if email and displayname are not the same.
    // if so then there's no username so little point in adding.

    if (m_lpWabal->FGetFirst(&adrInfo))
        do
        {
            // IE5.#2568: we now just add to the WAB regardless of
            // email and dispname being the same.
            // if (lstrcmp(adrInfo.lpszDisplay, adrInfo.lpszAddress)!=0)
            lpWab->HrAddNewEntry(adrInfo.lpwszDisplay, adrInfo.lpwszAddress);
        }
        while (m_lpWabal->FGetNext(&adrInfo));

exit:
    ReleaseObj(lpWab);
    return hr;
}


HRESULT CNoteHdr::HrOfficeLoad()
{
    HRESULT         hr = NOERROR;

    m_fSkipLayout = FALSE;

    if (!m_hCharset)
    {
        if (g_hDefaultCharsetForMail==NULL) 
            ReadSendMailDefaultCharset();

        m_hCharset = g_hDefaultCharsetForMail;        
    }
    
    if (m_hCharset)
        HrUpdateCharSetFonts(m_hCharset, FALSE);

    SafeRelease(m_lpWabal);

    hr = HrCreateWabalObject(&m_lpWabal);
    if (SUCCEEDED(hr))
    {
        Assert(m_pAddrWells);
        m_pAddrWells->HrSetWabal(m_lpWabal);

        ShowAdvancedHeaders(DwGetOption(OPT_MAILNOTEADVSEND));

        m_fStillLoading = FALSE;
    }

    return hr;
}


void CNoteHdr::SetReferences(LPMIMEMESSAGE pMsg)
{
    LPWSTR lpszRefs = 0;

    SafeMemFree(m_pszRefs);
    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &lpszRefs);

    switch (m_ntNote)
    {
        case OENA_REPLYALL:
        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        {
            LPWSTR lpszMsgId = 0;

            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpszMsgId);

            if (lpszMsgId)
                HrCreateReferences(lpszRefs, lpszMsgId, &m_pszRefs);

            SafeMimeOleFree(lpszMsgId);
            break;
        }

        case OENA_READ:
        case OENA_WEBPAGE:
        case OENA_STATIONERY:
        case OENA_COMPOSE:
            // hold on to the reference line for a send-note, so we can repersist if saving in drafts
            if (lpszRefs)
                m_pszRefs = PszDupW(lpszRefs);
            break;

        default:
            break;
    }

    SafeMimeOleFree(lpszRefs);
}

HRESULT CNoteHdr::HrSetNewsRecipients(LPMIMEMESSAGE pMsg)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwszNewsgroups = 0,
                pwszCC = 0,
                pwszSetNewsgroups = 0;
    TCHAR       szApproved[CCHMAX_EMAIL_ADDRESS];
    HWND        hwnd;

    AssertSz(OENA_REPLYTOAUTHOR != m_ntNote,    "Shouldn't get a REPLYTOAUTHOR in a news note.");
    AssertSz(OENA_FORWARD != m_ntNote,          "Shouldn't get a FORWARD in a news note.");
    AssertSz(OENA_FORWARDBYATTACH != m_ntNote,  "Shouldn't get a FORWARDBYATTACH in a news note.");

    *szApproved = 0;
    if (m_pAccount && DwGetOption(OPT_NEWSMODERATOR))
    {
        if (FAILED(m_pAccount->GetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szApproved, ARRAYSIZE(szApproved))) || (0 == *szApproved))
            m_pAccount->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szApproved, ARRAYSIZE(szApproved));
    }

    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &pwszNewsgroups);

    switch (m_ntNote)
    {
        case OENA_READ:
        {
            LPWSTR lpszOrg = 0;
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_ORG), NOFLAGS, &lpszOrg);
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTOrg), lpszOrg, FALSE);
            SafeMimeOleFree(lpszOrg);
        }
        // Fall through


        case OENA_WEBPAGE:
        case OENA_STATIONERY:
        case OENA_COMPOSE:
        {
            LPWSTR  lpszFollowup = 0,
                    lpszDist = 0,
                    lpszKeywords = 0;

            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FOLLOWUPTO), NOFLAGS, &lpszFollowup);
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_DISTRIB), NOFLAGS, &lpszDist);
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_KEYWORDS), NOFLAGS, &lpszKeywords);

            pwszSetNewsgroups = pwszNewsgroups;

            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTFollowupTo), lpszFollowup, FALSE);
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTDistribution), lpszDist, FALSE);
            HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), lpszKeywords, FALSE);

            MemFree(lpszFollowup);
            MemFree(lpszDist);
            MemFree(lpszKeywords);
            break;
        }

        case OENA_REPLYALL:
        case OENA_REPLYTONEWSGROUP:
        {
            LPSTR   pszGroupsFree = 0;

            if (SUCCEEDED(ParseFollowup(pMsg, &pszGroupsFree, &m_fPoster)))
            {
                if (pszGroupsFree)
                {
                    SafeMemFree(pwszNewsgroups);

                    IF_NULLEXIT(pwszNewsgroups = PszToUnicode(CP_ACP, pszGroupsFree));
                }

                pwszSetNewsgroups = pwszNewsgroups;
            }
            else
                pwszSetNewsgroups = pwszNewsgroups;
            Assert(pwszSetNewsgroups);

            if ((OENA_REPLYALL == m_ntNote) || m_fPoster)
            {
                MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REPLYTO), NOFLAGS, &pwszCC);
                if (!pwszCC)
                    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &pwszCC);
            }
            break;
        }
    }

    // set common fields
    HdrSetRichEditText(GetDlgItem(m_hwnd, idADNewsgroups), pwszSetNewsgroups, FALSE);

    // set read note / send note specific fields
    if (OENA_READ != m_ntNote)
        SetDlgItemText(m_hwnd, idADApproved, szApproved);

    // set up the recipients
    hr = HrSetNewsWabal(pMsg, pwszCC);

    // BUG: 31217: showadvanced has to be the last thing we call after modifying the
    // well contents
    ShowAdvancedHeaders(DwGetOption(m_ntNote == OENA_READ ? OPT_NEWSNOTEADVREAD : OPT_NEWSNOTEADVSEND));

exit:
    MemFree(pwszNewsgroups);
    MemFree(pwszCC);
   return hr;
}


HRESULT CNoteHdr::FullHeadersShowing(void)
{
    return m_fAdvanced ? S_OK : S_FALSE;
}


HRESULT CNoteHdr::HrNewsSave(LPMIMEMESSAGE pMsg, CODEPAGEID cpID, BOOL fCheckConflictOnly)
{
    HRESULT         hr = S_OK;
    WCHAR           wsz[256];
    WCHAR          *pwszTrim;
    BOOL            fSenderOk = FALSE,
                    fSetMessageAcct = TRUE;
    PROPVARIANT     rVariant;
    SYSTEMTIME      st;
    HWND            hwnd;
    PROPVARIANT     rUserData;
    BOOL            fConflict = FALSE;

    if (fCheckConflictOnly)
    {
        HdrGetRichEditText(GetDlgItem(m_hwnd, idADNewsgroups), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTFollowupTo), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTDistribution), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }

        if (hwnd = GetDlgItem(m_hwnd, idADApproved))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }
        }

        if (hwnd = GetDlgItem(m_hwnd, idTxtControl))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwszTrim, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }
        }
    }
    else
    {
        // ************************
        // This portion only happens on save, so don't try to do for fCheckConflictOnly
        // Anything not in this section had better be mirrored in the fCheckConflictOnly block above

        // Place any ascii only stuff here.

        // end of save only portion.
        // *************************
        HdrGetRichEditText(GetDlgItem(m_hwnd, idADNewsgroups), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            // Bug #22455 - Make sure we strip spaces etc from between newsgroups
            _ValidateNewsgroups(pwszTrim);
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, pwszTrim));
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTFollowupTo), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FOLLOWUPTO), NOFLAGS, pwszTrim));
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTDistribution), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_DISTRIB), NOFLAGS, pwszTrim));
        }

        HdrGetRichEditText(GetDlgItem(m_hwnd, idTXTKeywords), wsz, ARRAYSIZE(wsz), FALSE);
        pwszTrim = strtrimW(wsz);
        if (*pwszTrim)
        {
            IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_KEYWORDS), NOFLAGS, pwszTrim));
        }

        if (hwnd = GetDlgItem(m_hwnd, idADApproved))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_APPROVED), NOFLAGS, pwszTrim));
            }
        }

        if (hwnd = GetDlgItem(m_hwnd, idTxtControl))
        {
            HdrGetRichEditText(hwnd, wsz, ARRAYSIZE(wsz), FALSE);
            pwszTrim = strtrimW(wsz);
            if (*pwszTrim)
            {
                IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_CONTROL), NOFLAGS, pwszTrim));
            }
        }
    }

exit:
    return hr;
}


HRESULT CNoteHdr::HrSetNewsWabal(LPMIMEMESSAGE pMsg, LPWSTR     pwszCC)
{
    HRESULT         hr              = S_OK;
    LPWABAL         lpWabal         = NULL;
    ADDRESSLIST     addrList        = { 0 };
    LPWSTR          pwszEmail       = NULL;
    IMimeMessageW   *pMsgW          = NULL;

    SafeRelease(m_lpWabal);

    if (OENA_READ == m_ntNote)
    {
        // for a read note, just take the wabal from the message
        IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &m_lpWabal));
    }
    else
    {
        TCHAR   szReplyAddr[CCHMAX_EMAIL_ADDRESS];
        TCHAR   szEmailAddr[CCHMAX_EMAIL_ADDRESS];

        // for a compose note, or a reply note we need to do some munging, so create a new wabal
        IF_FAILEXIT(hr = HrCreateWabalObject(&m_lpWabal));

        if (OENA_COMPOSE == m_ntNote)
        {
            ADRINFO rAdrInfo;

            IF_FAILEXIT(hr = HrGetWabalFromMsg(pMsg, &lpWabal));

            // just copy everything except From: and ReplyTo: because we'll add those later
            if (lpWabal->FGetFirst(&rAdrInfo))
            {
                do
                {
                    if (rAdrInfo.lRecipType != MAPI_ORIG && rAdrInfo.lRecipType != MAPI_REPLYTO)
                        IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(&rAdrInfo));
                }
                while (lpWabal->FGetNext(&rAdrInfo));
            }
        }

        // add replyto if necessary
        if (m_pAccount)
        {
            if (SUCCEEDED(m_pAccount->GetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, szReplyAddr, ARRAYSIZE(szReplyAddr))) &&
                *szReplyAddr &&
                SUCCEEDED(m_pAccount->GetPropSz(AP_NNTP_EMAIL_ADDRESS, szEmailAddr, ARRAYSIZE(szEmailAddr))) &&
                lstrcmpi(szReplyAddr, szEmailAddr))
            {
                TCHAR szName[CCHMAX_DISPLAY_NAME];
                if (SUCCEEDED(m_pAccount->GetPropSz(AP_NNTP_DISPLAY_NAME, szName, ARRAYSIZE(szName))))
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntryA(szName, szReplyAddr, MAPI_REPLYTO));
                else
                    IF_FAILEXIT(hr = m_lpWabal->HrAddEntryA(szReplyAddr, szReplyAddr, MAPI_REPLYTO));
            }
        }

        //Bug# 79066
        if ((OENA_REPLYALL == m_ntNote) || m_fPoster)
        {
            if (FAILED(MimeOleParseRfc822AddressW(IAT_REPLYTO, pwszCC, &addrList)))
            {
                IF_FAILEXIT(hr = MimeOleParseRfc822AddressW(IAT_FROM, pwszCC, &addrList));
            }

            IF_NULLEXIT(pwszEmail = PszToUnicode(CP_ACP, addrList.prgAdr->pszEmail));
            IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(addrList.prgAdr->pszFriendlyW, pwszEmail, MAPI_TO));

        }
    }

    // For the send note case, make sure that resolved addresses are valid.
    // If display name and email address are the same, UnresolveOneOffs() will clear
    // the email address to force a real resolve.
    if ((OENA_COMPOSE == m_ntNote) || (OENA_WEBPAGE == m_ntNote) || OENA_STATIONERY == m_ntNote)
        m_lpWabal->UnresolveOneOffs();

    m_lpWabal->HrResolveNames(NULL, FALSE);

    Assert(m_pAddrWells);
    if (SUCCEEDED(hr = m_pAddrWells->HrSetWabal(m_lpWabal)))
        hr = m_pAddrWells->HrDisplayWells(m_hwnd);

exit:
    if (g_pMoleAlloc)
    {
        if (addrList.cAdrs)
            g_pMoleAlloc->FreeAddressList(&addrList);
    }

    ReleaseObj(lpWabal);
    MemFree(pwszEmail);
    ReleaseObj(pMsgW);
    return hr;
}


HRESULT CNoteHdr::HrSetReplySubject(LPMIMEMESSAGE pMsg, BOOL fReply)
{
    WCHAR   szNewSubject[cchMaxSubject+1];
    LPWSTR  pszNorm = NULL;
    int     cchPrefix;
    LPCWSTR lpwReFwd = NULL; 

    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &pszNorm);

    if (!!DwGetOption(OPT_HARDCODEDHDRS))
    {
        //Use english strings and not from resources
        lpwReFwd = fReply ? c_wszRe : c_wszFwd;

        StrCpyNW(szNewSubject, lpwReFwd, cchMaxSubject);
    }
    else
    {
        // pull in the new prefix from resource...
        AthLoadStringW(fReply?idsPrefixReply:idsPrefixForward, szNewSubject, cchMaxSubject);
    }

    cchPrefix = lstrlenW(szNewSubject);
    Assert(cchPrefix);
    if (pszNorm)
    {
        StrCpyNW(szNewSubject+cchPrefix, pszNorm, min(lstrlenW(pszNorm), cchMaxSubject-cchPrefix)+1);
        SafeMimeOleFree(pszNorm);
    }
    HdrSetRichEditText(GetDlgItem(m_hwnd, idTXTSubject), szNewSubject, FALSE);

    return NOERROR;
}

#define FIsDelimiter(_ch) (_ch==L';' || _ch==L',' || _ch==L' ' || _ch==L'\r' || _ch==L'\n' || _ch == L'\t')

void _ValidateNewsgroups(LPWSTR pszGroups)
{
    LPWSTR pszDst = pszGroups;
    BOOL   fInGroup = FALSE;
    WCHAR  ch;

    Assert(pszGroups);

    while (ch = *pszGroups++)
    {
        if (FIsDelimiter(ch))
        {
            if (fInGroup)
            {
                while ((ch = *pszGroups) && FIsDelimiter(ch))
                    pszGroups++;
                if (ch)
                    *pszDst++ = L',';
                fInGroup = FALSE;
            }
        }
        else
        {
            *pszDst++ = ch;
            fInGroup = TRUE;
        }
    }
    *pszDst = 0;
}


HRESULT CNoteHdr::HrQueryToolbarButtons(DWORD dwFlags, const GUID *pguidCmdGroup, OLECMD* pOleCmd)
{
    pOleCmd->cmdf = 0;

    if (NULL == pguidCmdGroup)
    {
        switch (pOleCmd->cmdID)
        {
            case OLECMDID_CUT:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSelAndIsRW);
                break;

            case OLECMDID_PASTE:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfPaste);
                break;

            case OLECMDID_SELECTALL:
                pOleCmd->cmdf = QS_ENABLED(TRUE);
                break;

            case OLECMDID_COPY:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSel);
                break;

            case OLECMDID_UNDO:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfUndo);
                break;
        }
    }
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        switch (pOleCmd->cmdID)
        {
            case ID_CUT:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSelAndIsRW);
                break;

            case ID_PASTE:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfPaste);
                break;

            case ID_SELECT_ALL:
                pOleCmd->cmdf = QS_ENABLED(TRUE);
                break;

            case ID_NOTE_COPY:
            case ID_COPY:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfEditHasSel);
                break;

            case ID_UNDO:
                pOleCmd->cmdf = QS_ENABLED(dwFlags&edfUndo);
                break;
        }
    }

    return NOERROR;
}


void CNoteHdr::OnButtonClick(int idBtn)
{
    UINT cch;
    LPTSTR pszGroups;
    //CPickGroupDlg* ppgd;

    switch (idBtn)
    {
        case idbtnTo:
            if (m_fMail)
                HrPickNames(0);
            else
                HrPickGroups(idADNewsgroups, FALSE);
            break;

        case idbtnFollowup:
            HrPickGroups(idTXTFollowupTo, TRUE);
            break;

        case idbtnCc:
            if (m_fMail)
                HrPickNames(1);
            else
                HrPickNames(0);
            break;

        case idbtnBCc:
            HrPickNames(2);
            break;

        case idbtnReplyTo:
            HrPickNames(1);
            break;
    }
}

void CNoteHdr::HrPickGroups(int idWell, BOOL fFollowUpTo)
{
    UINT            cch;
    DWORD           cServer = 0;
    HWND            hwnd;
    LPSTR           pszGroups=NULL;
    LPWSTR          pwszGroups=NULL;
    CPickGroupDlg  *ppgd;
    CHAR            szAccount[CCHMAX_ACCOUNT_NAME];

    g_pAcctMan->GetAccountCount(ACCT_NEWS, &cServer);

    // BUGBUG Sometimes m_pAccount is an IMAP server, so we want to also
    // test that we have at least one news server.  This is a known problem
    // that was punted a long time ago.
    if (!m_pAccount || !cServer)
    {
        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrConfigureServer), NULL, MB_OK);
        return;
    }

    hwnd = GetDlgItem(m_hwnd, idWell);
    if (S_OK == HrGetFieldText(&pwszGroups, hwnd))
    {
        // Since this function doesn't fail, just make sure that we
        // don't do anything funky when PszToANSI and PszToUnicode fails.
        pszGroups = PszToANSI(GetACP(), pwszGroups);
    }

    ppgd = new CPickGroupDlg;
    if (ppgd)
    {
        FOLDERID idServer = FOLDERID_INVALID;
        m_pAccount->GetPropSz(AP_ACCOUNT_ID, szAccount, sizeof(szAccount));

        // find the parent folder id of the account
        if (SUCCEEDED(g_pStore->FindServerId(szAccount, &idServer)) && 
                      ppgd->FCreate(m_hwnd, idServer, &pszGroups, fFollowUpTo) &&
                      pszGroups)
        {
            SafeMemFree(pwszGroups);
            pwszGroups = PszToUnicode(CP_ACP, pszGroups);
            HdrSetRichEditText(hwnd, pwszGroups != NULL ? pwszGroups : c_wszEmpty, FALSE);
        }

        ppgd->Release();
    }

    MemFree(pwszGroups);
    MemFree(pszGroups);
}

HRESULT CNoteHdr::HrPickNames(int iwell)
{
    HRESULT hr = NOERROR;

    if (IsReadOnly())
        return hr;

    Assert(m_lpWabal);
    Assert(m_pAddrWells);

    //We need to setmodify so that it is marked as dirty. In a normal case, 
    //the user would have typed in and hence set modify would have happenned automatically
    if (m_fPoster)
    {
        Edit_SetModify(GetDlgItem(m_hwnd, idADCc), TRUE);
    }

    hr=m_pAddrWells->HrSelectNames(m_hwnd, iwell, m_fMail?FALSE:TRUE);
    if (SUCCEEDED(hr))
    {
        // Check to see if need to show advanced headers.
        if (0 < GetRichEditTextLen(GetDlgItem(m_hwnd, idADBCc)))
            ShowAdvancedHeaders(TRUE);
    }
    else if (hr!=MAPI_E_USER_CANCEL)
        AthMessageBoxW (m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrPickNames), NULL, MB_OK);

    return hr;
}

HRESULT CNoteHdr::HrGetAccountInHeader(IImnAccount **ppAcct)
{
    HRESULT         hr = E_FAIL;
    IImnAccount    *pAcct = NULL;
    ULONG           cAccount = 0;
    HWND            hwndCombo = GetDlgItem(m_hwnd, idFromCombo);

    // If the combo box is being used then get the account info from it.
    if (SUCCEEDED(g_pAcctMan->GetAccountCount(m_fMail?ACCT_MAIL:ACCT_NEWS, &cAccount)) && 
            (cAccount > 1) && hwndCombo)
    {
        LPSTR   szAcctID = NULL;
        ULONG   i = ComboBox_GetCurSel(hwndCombo);

        szAcctID = (LPSTR)SendMessage(hwndCombo, CB_GETITEMDATA, WPARAM(i), 0);
        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctID, &pAcct);
    }

    // Get default account from MsgSite
    if (FAILED(hr) && m_pHeaderSite)
    {
        IOEMsgSite *pMsgSite = NULL;
        IServiceProvider *pServ = NULL;

        hr = m_pHeaderSite->QueryInterface(IID_IServiceProvider, (LPVOID*)&pServ);
        if (SUCCEEDED(hr))
        {
            hr = pServ->QueryService(IID_IOEMsgSite, IID_IOEMsgSite, (LPVOID*)&pMsgSite);
            pServ->Release();
        }
        if (SUCCEEDED(hr))
        {
            hr = pMsgSite->GetDefaultAccount(m_fMail?ACCT_MAIL:ACCT_NEWS, &pAcct);
            pMsgSite->Release();
        }
    }

    // Get global default.  Used in failure case and in Envelope (WordMail, etc) case
    if (FAILED(hr))
        hr = g_pAcctMan->GetDefaultAccount(m_fMail?ACCT_MAIL:ACCT_NEWS, &pAcct);

    if (SUCCEEDED(hr))
    {
        AssertSz(pAcct, "How is it that we succeeded, yet we don't have an account???");
        ReplaceInterface((*ppAcct), pAcct);
    }
    else if (E_FAIL == hr)
        hr = HR_E_COULDNOTFINDACCOUNT;

    ReleaseObj(pAcct);

    return hr;
}

HRESULT CNoteHdr::HrFillMessage(IMimeMessage *pMsg)
{
    IUnknown       *punk;
    IPersistMime   *pPM = NULL;
    HRESULT         hr;

    if (m_pEnvelopeSite)
        punk = m_pEnvelopeSite;
    else
        punk = m_pHeaderSite;

    AssertSz(punk, "You need either a HeaderSite or an EnvelopeSite");

    hr = punk->QueryInterface(IID_IPersistMime, (LPVOID*)&pPM);
    if (SUCCEEDED(hr))
    {
        hr = pPM->Save(pMsg, 0);
        ReleaseObj(pPM);

        if (hr == MAPI_E_USER_CANCEL)
            goto Exit;
    }
    else
    // If can't get a IPersistMime, need to fake the save through the m_pEnvelopeSite
    // The only time the QI for IPersistMime doesn't work is if you have an m_pEnvelopeSite
    // that doesn't support IPersistMime. If you have a m_pHeaderSite, QI should always work.
    {
        LPSTREAM    pstm;
        HBODY       hBodyHtml = 0;

        AssertSz(m_pEnvelopeSite, "If the QI didn't work, then must be an envelope site.");

        // We need to select the charset before we save the message
        pMsg->SetCharset(m_hCharset, CSET_APPLY_ALL);

        hr = Save(pMsg, 0);
        if (FAILED(hr))
            goto Exit;

        // Word will call our GetAttach function during this call to GetBody so save m_pMsgSend
        // so that we can inline attaches that Word sends to us.
        m_pMsgSend = pMsg;

        if (SUCCEEDED(_GetMsoBody(ENV_BODY_HTML, &pstm)))
        {
            pMsg->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pstm, &hBodyHtml);
            pstm->Release();
        }
        
        if (SUCCEEDED(_GetMsoBody(ENV_BODY_TEXT, &pstm)))
        {
            pMsg->SetTextBody(TXT_PLAIN, IET_INETCSET, hBodyHtml, pstm, NULL);
            pstm->Release();
        }

        m_pMsgSend = NULL;
    }

    Exit:
    return hr;
}

HRESULT CNoteHdr::_GetMsoBody(ULONG uBody, LPSTREAM *ppstm)
{
    LPSTREAM    pstm=NULL;
    HRESULT     hr;

    *ppstm = NULL;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));
    IF_FAILEXIT(hr = m_pEnvelopeSite->GetBody(pstm, uCodePageFromCharset(m_hCharset), uBody));

    *ppstm = pstm;
    pstm = NULL;

exit:
    ReleaseObj(pstm);
    return hr;
}

#ifdef YST
// this check produced a 4 bugs in OE 5.01 and 5.5 and I disaable it (YST)
HRESULT CNoteHdr::_CheckMsoBodyCharsetConflict(CODEPAGEID cpID)
{
    HRESULT     hr = S_OK;
    LPSTREAM    pstm = NULL;
    BSTR        bstrText = NULL;
    ULONG       cbToRead = 0, 
                cbRead = 0;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));

    hr = m_pEnvelopeSite->GetBody(pstm, CP_UNICODE, ENV_BODY_TEXT);

    // bobn; Raid 81900; 6/30/99
    // Excel (and powerpoint?) don't have a text body.
    // Check that there is an HTML body and we can have
    // it in unicode.
    if(FAILED(hr))
        IF_FAILEXIT(hr = m_pEnvelopeSite->GetBody(pstm, CP_UNICODE, ENV_BODY_HTML));

    IF_FAILEXIT(hr = HrIStreamToBSTR(CP_UNICODE, pstm, &bstrText));

    hr = HrSafeToEncodeToCP((LPWSTR)bstrText, cpID);

exit:
    SysFreeString(bstrText);
    ReleaseObj(pstm);
    return hr;
}
#endif //YST

HRESULT CNoteHdr::HrCheckSendInfo()
{
    HRESULT hr;
    BOOL    fOneOrMoreGroups = FALSE,
            fOneOrMoreNames = FALSE;

    hr = HrCheckNames(FALSE, TRUE);
    if (FAILED(hr))
    {
        if ((MAPI_E_USER_CANCEL != hr) && (hrNoRecipients != hr))
            hr = hrBadRecipients;

        if (hrNoRecipients != hr)
            goto Exit;
    }
    else
        fOneOrMoreNames = TRUE;

    // If we didn't find any email recipients, don't need to check if valid.
    if (SUCCEEDED(hr) && m_lpWabal)
        hr = m_lpWabal->IsValidForSending();

    // Only check groups if:
    // 1- Have succeeded to this point or didn't have any email recipients
    // 2- In a news header
    if ((SUCCEEDED(hr) || (hrNoRecipients == hr)) && !m_fMail)
    {
        hr = HrCheckGroups(TRUE);
        if (SUCCEEDED(hr))
            fOneOrMoreGroups = TRUE;
    }

    if (FAILED(hr))
        goto Exit;

    hr = HrCheckSubject(!fOneOrMoreGroups);
    if (FAILED(hr))
        goto Exit;

    // TODO:
    if (m_pHeaderSite && m_pHeaderSite->IsHTML() == S_OK)
    {
        // if a HTML message, then let's make sure there's no plain-text recipients
        if (fOneOrMoreNames)
        {
            hr = HrIsCoolToSendHTML();
            if (hr == S_FALSE && m_pHeaderSite)
                // send plain-text only...
                m_pHeaderSite->SetHTML(FALSE);
        }

        if (fOneOrMoreGroups && 
            (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, c_szDSHTMLNewsWarning, MAKEINTRESOURCE(idsAthena), 
                                              MAKEINTRESOURCE(idsErrHTMLInNewsIsBad), MB_OKCANCEL)))
            hr = MAPI_E_USER_CANCEL;
    }

Exit:
    return hr;
}

HRESULT CNoteHdr::HrSend(void)
{
    HRESULT             hr;
    IMimeMessage       *pMsg = NULL;
    IOEMsgSite         *pMsgSite = NULL;    

    if (m_pEnvelopeSite)
    {
        // With the envelope site, must check to see if things set up at this point to use mail
        hr = ProcessICW(m_hwnd, FOLDER_LOCAL, TRUE);
        if (hr == S_FALSE)
            // user cancelled out of config wizard so we can't continue
            hr = MAPI_E_USER_CANCEL;
        if (FAILED(hr))
            goto error;
        m_fSendImmediate = TRUE;
    }

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto error;

    // The only case where this will happen is if no accounts are configured. Just to make
    // sure, call the ICW and then try to get the default account.
    if (!m_pAccount)
    {
        hr = ProcessICW(m_hwnd, m_fMail ? FOLDER_LOCAL : FOLDER_NEWS, TRUE);
        if (FAILED(hr))
            goto error;

        if (FAILED(g_pAcctMan->GetDefaultAccount(m_fMail?ACCT_MAIL:ACCT_NEWS, &m_pAccount)))
        {
            hr = HR_E_COULDNOTFINDACCOUNT;
            goto error;
        }
    }

    hr = HrCheckSendInfo();
    if (FAILED(hr))
        goto error;

    // Does IPersistMime save stuff
    hr = HrFillMessage(pMsg);
    if (FAILED(hr))
        goto error;

    if (m_pHeaderSite)
    {
        IOEMsgSite *pMsgSite = NULL;
        IServiceProvider *pServ = NULL;

        hr = m_pHeaderSite->QueryInterface(IID_IServiceProvider, (LPVOID*)&pServ);
        if (SUCCEEDED(hr))
        {
            hr = pServ->QueryService(IID_IOEMsgSite, IID_IOEMsgSite, (LPVOID*)&pMsgSite);
            pServ->Release();
        }
        if (SUCCEEDED(hr))
        {
            if (!m_fMail && IsReplyNote() && !DwGetDontShowAgain(c_szDSReplyNews))
            {
                LRESULT id  =   DoDontShowMeAgainDlg(m_hwnd, c_szDSReplyNews,
                        MAKEINTRESOURCE(idsPostNews),
                        MAKEINTRESOURCE(idsReplyToNewsGroup),
                        MB_YESNO);
                if (IDNO == id || IDCANCEL == id)
                    hr = hrUserCancel; 
                else 
                    hr = pMsgSite->SendToOutbox(pMsg, m_fSendImmediate, m_pHeaderSite);
            }
            else
            {
                hr = pMsgSite->SendToOutbox(pMsg, m_fSendImmediate, m_pHeaderSite);
            }
            pMsgSite->Release();
        }
    }
    // We are in office Envelope
    else
    {
        COEMsgSite *pMsgSite = NULL;
        CStoreCB   *pCB = NULL;

        pMsgSite = new COEMsgSite();
        if (!pMsgSite)
            hr = E_OUTOFMEMORY;

        pCB = new CStoreCB;
        if (!pCB)
            hr = E_OUTOFMEMORY;

        if (SUCCEEDED(hr))
            hr = pCB->Initialize(m_hwndParent, MAKEINTRESOURCE(idsSendingToOutbox), TRUE);

        if (SUCCEEDED(hr))
        {
            INIT_MSGSITE_STRUCT rInitStruct;

            rInitStruct.dwInitType = OEMSIT_MSG;
            rInitStruct.folderID = FOLDERID_INVALID;
            rInitStruct.pMsg = pMsg;

            hr = pMsgSite->Init(&rInitStruct);
        }

        if (SUCCEEDED(hr))
            hr = pMsgSite->SetStoreCallback(pCB);

        if (SUCCEEDED(hr))
        {
            hr = pMsgSite->SendToOutbox(pMsg, m_fSendImmediate, m_pHeaderSite);
            if (E_PENDING == hr)
                hr = pCB->Block();

            pCB->Close();
        }

        if (SUCCEEDED(hr))
        {
            m_pEnvelopeSite->CloseNote(ENV_CLOSE_SEND);
            ShowWindow(m_hwnd, SW_HIDE);
        }

        if (pMsgSite)
        {
            pMsgSite->Close();
            pMsgSite->Release();
        }

        ReleaseObj(pCB);
    }

    error:
    if (FAILED(hr))
    {
        int idsErr = -1;
        m_fSecurityInited = FALSE;

        switch (hr)
        {
            case hrNoRecipients:        
                if(!m_fMail)
                    hr = HR_E_POST_WITHOUT_NEWS;  // idsErr = idsErrPostWithoutNewsgroup; 
                break;

            case HR_E_COULDNOTFINDACCOUNT:      
                if(!m_fMail)
                    hr  = HR_E_CONFIGURE_SERVER; //idsErr = idsErrConfigureServer; 
                break;

            case HR_E_ATHSEC_FAILED:
            case hrUserCancel:
            case MAPI_E_USER_CANCEL:    
                idsErr = 0; 
                break;

            case HR_E_ATHSEC_NOCERTTOSIGN:
            case MIME_E_SECURITY_NOSIGNINGCERT:
                idsErr = 0; 
                if(DialogBoxParam(g_hLocRes, 
                            MAKEINTRESOURCE(iddErrSecurityNoSigningCert), m_hwnd, 
                            ErrSecurityNoSigningCertDlgProc, NULL) == idGetDigitalIDs)
                    GetDigitalIDs(m_pAccount);
                break;
            
            default:                    
                // idsErr = m_fMail?idsErrSendMail:NULL; // ~~~ Should we have a default for news?
                break;
        }

        if (idsErr != 0)
        {
            AthErrorMessageW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrSendMail), hr);
            if ((hr == hrNoRecipients) || (hr == HR_E_POST_WITHOUT_NEWS))
                SetInitFocus(FALSE);
        }
    }


    ReleaseObj(pMsg);
    return hr;
}

HRESULT CNoteHdr::HrCheckSubject(BOOL fMail)
{
    HWND    hwnd;

    if ((hwnd=GetDlgItem(m_hwnd, idTXTSubject)) && GetRichEditTextLen(hwnd)==0)
    {
        if (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, fMail?c_szRegMailEmptySubj:c_szRegNewsEmptySubj,
                                             MAKEINTRESOURCE(idsAthena),
                                             MAKEINTRESOURCE(fMail?idsWarnMailEmptySubj:idsWarnNewsEmptySubj),
                                             MB_OKCANCEL))
        {
            ::SetFocus(hwnd);
            return MAPI_E_USER_CANCEL;
        }
    }
    return NOERROR;
}

HRESULT CNoteHdr::HrIsCoolToSendHTML()
{
    HRESULT     hr=S_OK;
    ADRINFO     adrInfo;
    BOOL        fPlainText=FALSE;
    int         id;

    // check for plaintext people
    if (m_lpWabal->FGetFirst(&adrInfo))
    {
        do
        {
            if (adrInfo.fPlainText)
            {
                fPlainText=TRUE;
                break;
            }
        }
        while (m_lpWabal->FGetNext(&adrInfo));
    }

    if (fPlainText)
    {
        id = (int) DialogBox(g_hLocRes, MAKEINTRESOURCE(iddPlainRecipWarning), m_hwnd, _PlainWarnDlgProc);
        if (id == IDNO)
            return S_FALSE;
        else
            if (id == IDCANCEL)
            return MAPI_E_USER_CANCEL;
        else
            return S_OK;
    }
    return hr;
}



INT_PTR CALLBACK _PlainWarnDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int id;

    switch (msg)
    {
        case WM_INITDIALOG:
            CenterDialog(hwnd);
            return TRUE;

        case WM_COMMAND:
            id = GET_WM_COMMAND_ID(wParam, lParam);
            if (id == IDYES || id == IDNO || id == IDCANCEL)
            {
                EndDialog(hwnd, id);
                break;
            }
    }
    return FALSE;
}


static HACCEL   g_hAccelMailSend=0;

// This should only get called from the envelope as a send note
HACCEL CNoteHdr::GetAcceleratorTable()
{
    Assert(!IsReadOnly());
    Assert(m_pEnvelopeSite);

    if (!g_hAccelMailSend)
        g_hAccelMailSend = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_SEND_HDR_ACCEL));

    return g_hAccelMailSend;
}

HRESULT CNoteHdr::HrInitSecurityOptions(LPMIMEMESSAGE pMsg, ULONG ulSecurityType)
{
    HRESULT hr;

    if (!m_fSecurityInited)
    {
        if (SUCCEEDED(hr = ::HrInitSecurityOptions(pMsg, ulSecurityType)))
            m_fSecurityInited = TRUE;
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT CNoteHdr::HrHandleSecurityIDMs(BOOL fDigSign)
{
    IMimeBody  *pBody;
    PROPVARIANT var;
    HRESULT     hr;

    if (fDigSign)
        m_fDigSigned = !m_fDigSigned;
    else
        m_fEncrypted = !m_fEncrypted;

    if(m_fForceEncryption && m_fDigSigned)
        m_fEncrypted = TRUE;

    hr = HrUpdateSecurity();

    return hr;
}


HRESULT CNoteHdr::HrInitSecurity()
{
    HRESULT hr = S_OK;

    // Constructor set these flags to false so don't need to handle else case
    if (OENA_READ != m_ntNote && m_fMail)
    {
        m_fDigSigned = DwGetOption(OPT_MAIL_DIGSIGNMESSAGES);
        m_fEncrypted = DwGetOption(OPT_MAIL_ENCRYPTMESSAGES);
    }

    return hr;
}


HRESULT CNoteHdr::HrUpdateSecurity(LPMIMEMESSAGE pMsg)
{
    RECT        rc;
    HRESULT     hr = NOERROR;
    LPWSTR      psz = NULL;
    HWND        hEdit;
    
    switch (m_ntNote)
    {
    case OENA_READ:
    case OENA_REPLYTOAUTHOR:
    case OENA_REPLYTONEWSGROUP:
    case OENA_REPLYALL:
    case OENA_FORWARD:
    case OENA_FORWARDBYATTACH:
        
        if (pMsg)
        {
            CleanupSECSTATE(&m_SecState);
            HrGetSecurityState(pMsg, &m_SecState, NULL);
            
            m_fDigSigned = IsSigned(m_SecState.type);
            m_fEncrypted = IsEncrypted(m_SecState.type);
            
            // RAID 12243. Added these two flags for broken and untrusted messages
            if(m_ntNote == OENA_READ)
            {
                m_fSignTrusted = IsSignTrusted(&m_SecState);
                m_fEncryptionOK = IsEncryptionOK(&m_SecState);
            }
        }       
        break;
        
    case OENA_COMPOSE:
        if (pMsg)
        {
            // Make certain that the highest security of (current message, option defaults) is applied.
            //
            CleanupSECSTATE(&m_SecState);
            HrGetSecurityState(pMsg, &m_SecState, NULL);
            
            if (! m_fDigSigned)
            {
                m_fDigSigned = IsSigned(m_SecState.type);
            }
            if (! m_fEncrypted)
            {
                m_fEncrypted = IsEncrypted(m_SecState.type);
            }
        }
        break;
        
    default:            // do nothing
        break;        
    }
    hEdit = GetDlgItem(m_hwnd, idSecurity);
    if (hEdit)
    {
        PHCI phci = (HCI*)GetWindowLongPtr(hEdit, GWLP_USERDATA);
        // BUG 17788: need to set the text even if it is null
        // since that will delete old security line text.
        psz = SzGetDisplaySec(pMsg, NULL);
        
        HdrSetRichEditText(hEdit, psz, FALSE);
        
        phci->fEmpty = (0 == *psz);
    }
    
    m_fThisHeadDigSigned = m_fDigSigned;
    m_fThisHeadEncrypted = m_fEncrypted;

//    if(!m_fDigSigned)
//        m_fForceEncryption = FALSE;
    
    InvalidateRightMargin(0);
    ReLayout();
    
    if (m_pHeaderSite)
        m_pHeaderSite->Update();
    
    if (m_hwndToolbar)
    {
        Assert(m_pEnvelopeSite);
        if (m_fDigSigned)
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_DIGITALLY_SIGN, MAKELONG(TBSTATE_ENABLED | TBSTATE_PRESSED, 0));
        else
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_DIGITALLY_SIGN, MAKELONG(TBSTATE_ENABLED, 0));

        if(m_fForceEncryption && m_fDigSigned)
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_ENCRYPT, MAKELONG(TBSTATE_PRESSED, 0));
        else if (m_fEncrypted)
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_ENCRYPT, MAKELONG(TBSTATE_ENABLED | TBSTATE_PRESSED, 0));
        else
            SendMessage(m_hwndToolbar, TB_SETSTATE, ID_ENCRYPT, MAKELONG(TBSTATE_ENABLED, 0));
    }
    
    return hr;
}


HRESULT CNoteHdr::HrSaveSecurity(LPMIMEMESSAGE pMsg)
{
    HRESULT     hr;
    ULONG       ulSecurityType = MST_CLASS_SMIME_V1;

    if (m_fDigSigned)
        ulSecurityType |= ((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);
    else
        ulSecurityType &= ~((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);


    if (m_fEncrypted)
        ulSecurityType |= MST_THIS_ENCRYPT;
    else
        ulSecurityType &= ~MST_THIS_ENCRYPT;

    hr = HrInitSecurityOptions(pMsg, ulSecurityType);

    return hr;
}


BOOL CNoteHdr::IsReadOnly()
{
    if (m_ntNote==OENA_READ)
        return TRUE;
    else
        return FALSE;
}


HRESULT CNoteHdr::HrViewContacts()
{
    LPWAB   lpWab;

    if (!FAILED (HrCreateWabObject (&lpWab)))
    {
        // launch wab in modal-mode if a) container is modal or b) running as office envelope
        lpWab->HrBrowse (m_hwnd, m_fOfficeInit ? TRUE : (m_pHeaderSite ? (m_pHeaderSite->IsModal() == S_OK) : FALSE));
        lpWab->Release ();
    }
    else
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsGeneralWabError), NULL, MB_OK);

    return NOERROR;
}

BOOL CNoteHdr::FDoCutCopyPaste(int wmCmd)
{
    HWND hwndFocus=GetFocus();

    // only if it's one of our kids..
    if (GetParent(hwndFocus)==m_hwnd)
    {
        SendMessage(hwndFocus, wmCmd, 0, 0);
        return TRUE;
    }

    return FALSE;
}

HRESULT CNoteHdr::GetTabStopArray(HWND *rgTSArray, int *pcArrayCount)
{
    Assert(rgTSArray);
    Assert(pcArrayCount);

    int *array;
    int cCount;
    if (m_fMail)
    {
        if (IsReadOnly())
        {
            array = rgIDTabOrderMailRead;
            cCount = sizeof(rgIDTabOrderMailRead)/sizeof(int);
        }
        else
        {
            array = rgIDTabOrderMailSend;
            cCount = sizeof(rgIDTabOrderMailSend)/sizeof(int);
        }
    }
    else
    {
        if (IsReadOnly())
        {
            array = rgIDTabOrderNewsRead;
            cCount = sizeof(rgIDTabOrderNewsRead)/sizeof(int);
        }
        else
        {
            array = rgIDTabOrderNewsSend;
            cCount = sizeof(rgIDTabOrderNewsSend)/sizeof(int);
        }
    }

    AssertSz(cCount <= *pcArrayCount, "Do you need to change MAX_HEADER_COMP in note.h?");
    for (int i = 0; i < cCount; i++)
        *rgTSArray++ = GetDlgItem(m_hwnd, *array++);

    *pcArrayCount = cCount;

    return S_OK;
}


HRESULT CNoteHdr::SetFlagState(MARK_TYPE markType)
{
    BOOL fDoRelayout = FALSE;
    switch (markType)
    {
        case MARK_MESSAGE_FLAGGED:
        case MARK_MESSAGE_UNFLAGGED:
        {
            BOOL fFlagged = (MARK_MESSAGE_FLAGGED == markType);
            if (m_fFlagged != fFlagged)
            {
                fDoRelayout = TRUE;
                m_fFlagged = fFlagged;
            }
            break;
        }

        case MARK_MESSAGE_WATCH: 
        case MARK_MESSAGE_IGNORE: 
        case MARK_MESSAGE_NORMALTHREAD:
            if (m_MarkType != markType)
            {
                fDoRelayout = TRUE;
                m_MarkType = markType;
            }
            break;
    }

    if (fDoRelayout)
    {
        InvalidateStatus();
        ReLayout();

        if (m_pHeaderSite)
            m_pHeaderSite->Update();
    }
    return S_OK;
}


HRESULT CNoteHdr::ShowEnvOptions()
{
    nyi("Header options are not implemented yet.");
    return S_OK;
}

void CNoteHdr::ReLayout()
{
    RECT rc; 

    if (m_fSkipLayout)
        return;

    GetClientRect(m_hwnd, &rc);
    SetPosOfControls(rc.right, TRUE);

    InvalidateRect(m_hwnd, &rc, TRUE);
    DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
}

//IDropTarget
HRESULT CNoteHdr::DragEnter(LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    LPENUMFORMATETC penum = NULL;
    HRESULT         hr;
    FORMATETC       fmt;
    ULONG           ulCount = 0;

    if (m_lpAttMan->HrIsDragSource() == S_OK)
    {
        *pdwEffect=DROPEFFECT_NONE;
        return S_OK;
    }

    if (!pdwEffect || !pDataObj)
        return E_INVALIDARG;

    m_dwEffect = DROPEFFECT_NONE;

    // lets get the enumerator from the IDataObject, and see if the format we take is
    // available
    hr = pDataObj->EnumFormatEtc(DATADIR_GET, &penum);

    if (SUCCEEDED(hr) && penum)
    {
        hr = penum->Reset();
        while (SUCCEEDED(hr=penum->Next(1, &fmt, &ulCount)) && ulCount)
        {
            if ( fmt.cfFormat==CF_HDROP || 
                 fmt.cfFormat==CF_FILEDESCRIPTORA || 
                 fmt.cfFormat==CF_FILEDESCRIPTORW)
            {
                // we take either a CF_FILEDESCRIPTOR from the shell, or a CF_HDROP...

                //by default, or a move if the shift key is down
                if ( (*pdwEffect) & DROPEFFECT_COPY )
                    m_dwEffect = DROPEFFECT_COPY;

                if ( ((*pdwEffect) & DROPEFFECT_MOVE) &&
                     (grfKeyState & MK_SHIFT))
                    m_dwEffect=DROPEFFECT_MOVE;

                // IE3 gives us a link
                // if ONLY link is specified, default to a copy
                if (*pdwEffect == DROPEFFECT_LINK)
                    m_dwEffect=DROPEFFECT_LINK;

                m_cfAccept=fmt.cfFormat;
                if (m_cfAccept==CF_FILEDESCRIPTORW)   // this is the richest format we take, if we find one of these, no point looking any
                    break;                            // further...
            }
        }
    }

    ReleaseObj(penum);
    *pdwEffect    = m_dwEffect;
    m_grfKeyState = grfKeyState;
    return S_OK;
}


HRESULT CNoteHdr::DragOver(DWORD grfKeyState,POINTL pt, DWORD *pdwEffect)
{
    if (m_lpAttMan->HrIsDragSource() == S_OK)
    {
        *pdwEffect=DROPEFFECT_NONE;
        return S_OK;
    }

    if ( m_dwEffect == DROPEFFECT_NONE) // we're not taking drops at all...
    {
        *pdwEffect = m_dwEffect;
        return NOERROR;
    }

    // Cool, we've accepted the drag this far... now we
    // have to watch to see if it turns into a copy or move...
    // as before, take the copy as default or move if the
    // shft key is down
    if ((*pdwEffect)&DROPEFFECT_COPY)
        m_dwEffect=DROPEFFECT_COPY;

    if (((*pdwEffect)&DROPEFFECT_MOVE)&&
        (grfKeyState&MK_SHIFT))
        m_dwEffect=DROPEFFECT_MOVE;

    if (*pdwEffect==DROPEFFECT_LINK) // if it's link ONLY, like IE3 gives, then fine...
        m_dwEffect=DROPEFFECT_LINK;

    *pdwEffect &= m_dwEffect;
    m_grfKeyState=grfKeyState;

    return NOERROR;
}


HRESULT CNoteHdr::DragLeave()
{
    return NOERROR;
}


HRESULT CNoteHdr::Drop(LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT         hr    = E_FAIL;
    FORMATETC       fmte    = {m_cfAccept, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM       medium;

    *pdwEffect = m_dwEffect;

    if ( m_dwEffect != DROPEFFECT_NONE )
    {
        // If this is us sourcing the drag, just bail. We may want to save the
        // points of the icons.
        //
        if (m_lpAttMan->HrIsDragSource() == S_OK)
        {
            *pdwEffect=DROPEFFECT_NONE;
            return S_OK;
        }

        if ( (m_grfKeyState & MK_RBUTTON) &&
             m_lpAttMan->HrGetRequiredAction(pdwEffect, pt))
            return E_FAIL;


        if (pDataObj &&
            SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
        {

            if (m_cfAccept==CF_HDROP)
            {
                HDROP hdrop=(HDROP)GlobalLock(medium.hGlobal);

                hr=m_lpAttMan->HrDropFiles(hdrop, (*pdwEffect)&DROPEFFECT_LINK);

                GlobalUnlock(medium.hGlobal);
            }
            else
                if (m_cfAccept==CF_FILEDESCRIPTORA || m_cfAccept==CF_FILEDESCRIPTORW)
            {
                // all file descriptors are copy|more, link makes no sense, as they are are
                // memory object, ie. non-existent in fat.
                hr=m_lpAttMan->HrDropFileDescriptor(pDataObj, FALSE);
            }
#ifdef DEBUG
            else
                AssertSz(0, "how did this clipformat get accepted??");
#endif

            if (medium.pUnkForRelease)
                medium.pUnkForRelease->Release();
            else
                GlobalFree(medium.hGlobal);
        }
    }
    return hr;
}

HRESULT CNoteHdr::HrGetAttachCount(ULONG *pcAttach)
{
    return m_lpAttMan->HrGetAttachCount(pcAttach);
}

HRESULT CNoteHdr::HrIsDragSource()
{
    return m_lpAttMan->HrIsDragSource();
}


HRESULT CNoteHdr::UnloadAll()
{
    if (m_lpAttMan)
    {
        m_lpAttMan->HrUnload();
        m_lpAttMan->HrClearDirtyFlag();
    }

    for (int i=0; i<(int)m_cHCI; i++)
    {
        if (0 == (m_rgHCI[i].dwFlags & HCF_ATTACH))
        {
            if (0 == (m_rgHCI[i].dwFlags & HCF_COMBO))
                HdrSetRichEditText(GetDlgItem(m_hwnd, m_rgHCI[i].idEdit), c_wszEmpty, FALSE);
            else
                SetWindowText(GetDlgItem(m_hwnd, m_rgHCI[i].idEdit), "");
        }
    }

    m_fDirty = FALSE;
    m_pri = priNorm;
    return S_OK;
}

void CNoteHdr::SetDirtyFlag()
{
    if (!m_fStillLoading)
    {
        m_fDirty = TRUE;
        if (m_pEnvelopeSite)
            m_pEnvelopeSite->OnPropChange(dispidSomething);
    }
}

void CNoteHdr::SetPosOfControls(int headerWidth, BOOL fChangeVisibleStates)
{
    int         cx,
                cy,
                cyDirty,
                cyLabelDirty,
                oldWidth = 0,
                windowPosFlags = SETWINPOS_DEF_FLAGS,
                editWidth = headerWidth - m_cxLeftMargin - GetRightMargin(FALSE);
    RECT        rc;
    HWND        hwnd;
    PHCI        phci = m_rgHCI;
    BOOL        fRePosition = FALSE;

    if ((headerWidth < 5) || (m_fSkipLayout))
        return; 

    STACK("SetPosOfControls (header width, edit width)", headerWidth, editWidth);

    // size the dialog
    GetClientRect(m_hwnd, &rc);
    cyDirty = rc.bottom;
    cyLabelDirty = rc.bottom;

    if (fChangeVisibleStates)
        windowPosFlags |= SWP_SHOWWINDOW;

    cy = BeginYPos();

    for (int i=0; i<(int)m_cHCI; i++, phci++)
    {
        hwnd = GetDlgItem(m_hwnd, phci->idEdit);
        if (hwnd)
        {
            if (S_OK == HrFShowHeader(phci))
            {
                int     newLabelCY = (phci->dwFlags & HCF_BORDER) ? cy + 2*cyBorder : cy;
                BOOL    fLabelMoved = FALSE;
                if (phci->cy != cy)
                {
                    int smcy = ((INVALID_PHCI_Y != phci->cy) && (phci->cy < cy)) ? phci->cy : cy;
                    if (cyLabelDirty > smcy)
                        cyLabelDirty = smcy;
                    phci->cy = cy;
                    fLabelMoved = TRUE;
                }

                // Is an attachment
                if (HCF_ATTACH & phci->dwFlags)
                {
                    DWORD   cyAttMan = 0;
                    RECT    rc;

                    m_lpAttMan->HrGetHeight(editWidth, &cyAttMan);
                    if (cyAttMan > MAX_ATTACH_PIXEL_HEIGHT)
                        cyAttMan = MAX_ATTACH_PIXEL_HEIGHT;

                    cyAttMan += 4*cyBorder;

                    cyDirty = cy;

                    rc.left = m_cxLeftMargin;
                    rc.right = m_cxLeftMargin + editWidth;
                    rc.top = cy;
                    rc.bottom = cy + cyAttMan;

                    m_lpAttMan->HrSetSize(&rc);

                    if ((cyAttMan != (DWORD)phci->height) && (cyDirty > cy))
                        cyDirty = cy;

                    AssertSz(cyAttMan != 0, "Setting this to zero would be a bummer...");
                    phci->height = cyAttMan;

                    cy += cyAttMan + ControlYBufferSize();
                }
                // Is either an edit or combo
                else
                {
                    int     newHeight = phci->height,
                            ctrlHeight = GetCtrlHeight(hwnd);

                    oldWidth = GetCtrlWidth(hwnd); 

                    if (HCF_COMBO & phci->dwFlags)
                    {
                        if (ctrlHeight != newHeight)
                        {
                            fRePosition = TRUE;
                            phci->height = ctrlHeight;
                            newHeight = GetControlSize(TRUE, NUM_COMBO_LINES);
                        }
                        else
                        {
                            fRePosition = fRePosition || fLabelMoved || (oldWidth != editWidth);
                            if (fRePosition)
                                newHeight = GetControlSize(TRUE, NUM_COMBO_LINES);
                        }
                    }
                    else
                    {
                        fRePosition = fRePosition || fLabelMoved || (oldWidth != editWidth) || (ctrlHeight != newHeight);
                    }

                    if (fRePosition)
                    {
                        SetWindowPos(hwnd, NULL, m_cxLeftMargin, cy, editWidth, newHeight, windowPosFlags);

                        // RAID 81136: The above SetWindowPos might change the width in such a way
                        // that the height now needs to change. We detect this condition below and
                        // cause another resize to handle the needed height change. This, of course,
                        // is only valid with the richedits.
                        if ((newHeight != phci->height) && (0 == (HCF_COMBO & phci->dwFlags)))
                        {
                            SetWindowPos(hwnd, NULL, m_cxLeftMargin, cy, editWidth, phci->height, windowPosFlags);
                        }
                        if (cyDirty > cy)
                            cyDirty = cy;
                        if (fLabelMoved)
                            InvalidateRect(hwnd, NULL, FALSE);
                    }
                    cy += phci->height + ControlYBufferSize();
                }
            }
            else
            {
                phci->cy = INVALID_PHCI_Y;
                if (fChangeVisibleStates)
                    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_HIDEWINDOW);
            }
        }
    }

    DOUTL(RESIZING_DEBUG_LEVEL, "STATE resizing header (headerwidth=%d, cy=%d)", headerWidth, cy);

    // don't send a poschanging, as we did all the work here, plus invalidation...
    SetWindowPos(m_hwnd, NULL, NULL, NULL, headerWidth, cy, 
                SETWINPOS_DEF_FLAGS|SWP_NOMOVE|SWP_DRAWFRAME|SWP_FRAMECHANGED);

    // notify the parent to resize the note...
    if (m_pHeaderSite)
        m_pHeaderSite->Resize();

    if (m_pEnvelopeSite)
    {
        m_pEnvelopeSite->RequestResize(&cy);
    }

    GetRealClientRect(m_hwnd, &rc);

    // Dirty the labels region
    if (rc.bottom != cyLabelDirty)
    {
        rc.top = cyLabelDirty;
        rc.right = m_cxLeftMargin;
        rc.left = 0;
        InvalidateRect(m_hwnd, &rc, TRUE);
        DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
    }

    // Dirty the right margin if needed.
    if (editWidth != oldWidth)
    {
        int rightMargin = (editWidth > oldWidth) ? editWidth - oldWidth : 0;

        InvalidateRightMargin(rightMargin);
    }


#ifdef DEBUG
    DEBUGDumpHdr(m_hwnd, m_cHCI, m_rgHCI);
#endif

}

void CNoteHdr::InvalidateRightMargin(int additionalWidth)
{
    RECT rc;
    GetClientRect(m_hwnd, &rc);

    rc.left = rc.right - GetRightMargin(TRUE) - additionalWidth;

    InvalidateRect(m_hwnd, &rc, TRUE);
    DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
}


HRESULT CNoteHdr::HrUpdateCachedHeight(HWND hwndEdit, RECT *prc)
{
    int         cyGrow,
                cLines = (int) SendMessage(hwndEdit, EM_GETLINECOUNT, 0, 0);
    BOOL        fIncludeEdges = WS_EX_CLIENTEDGE & GetWindowLong(hwndEdit, GWL_EXSTYLE);
    PHCI        phci = (HCI*)GetWindowLongPtr(hwndEdit, GWLP_USERDATA);

    if (prc->bottom < 0 || prc->top < 0)
        return S_FALSE;

    STACK("HrUpdateCachedHeight. Desired lines", cLines);

    // Only allow between 1 and MAX_RICHEDIT_LINES lines
    if (cLines < 1)
        cLines = 1;
    else if (cLines > MAX_RICHEDIT_LINES)
        cLines = MAX_RICHEDIT_LINES;

    DOUTL(RESIZING_DEBUG_LEVEL, "STATE Actual lines=%d", cLines);

    // Figure out how many pixels cLines lines is
    cyGrow = GetControlSize(fIncludeEdges, cLines);

    // If these are different, then change is needed
    if (cyGrow != GetCtrlHeight(hwndEdit))
        phci->height = cyGrow;
    else
        return S_FALSE;


    return S_OK;
}


void CNoteHdr::ShowControls()
{
    PHCI    phci = m_rgHCI;

    STACK("ShowControls");

    for (int i=0; i<(int)m_cHCI; i++, phci++)
    {
        HWND hwnd; 
        BOOL fHide;    

        fHide = (S_FALSE == HrFShowHeader(phci));

        hwnd = GetDlgItem(m_hwnd, phci->idEdit);
        if (hwnd)
            ShowWindow(hwnd, fHide?SW_HIDE:SW_SHOW);
    }
}

int CNoteHdr::GetRightMargin(BOOL fMax)
{
    int margin = ControlXBufferSize();

    if (fMax || m_fDigSigned || m_fEncrypted || m_fVCard)
        margin += margin + cxBtn;

    return margin;
}

// prc is in and out
DWORD CNoteHdr::GetButtonUnderMouse(int x, int y)
{
    int     resultButton = HDRCB_NO_BUTTON;
    PHCI    phci = m_rgHCI;

    // Is it in the labels?
    if ((x > int(ControlXBufferSize() - BUTTON_BUFFER)) && (x < int(m_cxLeftMargin - ControlXBufferSize() + BUTTON_BUFFER)))
    {
        for (int i=0; i<(int)m_cHCI; i++, phci++)
        {
            // Only check labels that have buttons that are showing
            if ((0 != (phci->dwFlags & HCF_HASBUTTON)) && (INVALID_PHCI_Y != phci->cy))
            {
                if (y < (phci->cy))
                    break;

                if (y < (phci->cy + 2*BUTTON_BUFFER + g_cyLabelHeight))
                {
                    resultButton = i;
                    break;
                }
            }
        }
    }
    else
    // Is one of the right side buttons?
    {
        int     width = GetCtrlWidth(m_hwnd),
                xBuffSize = ControlXBufferSize(),
                yBuffSize = ControlYBufferSize();

        // Are we in the correct x range?
        if ((x > (width - (xBuffSize + cxBtn + BUTTON_BUFFER))) && (x < width - xBuffSize + BUTTON_BUFFER))
        {
            BOOL    rgBtnStates[] = {BUTTON_STATES};
            BOOL    rgUseButton[] =  {BUTTON_USE_IN_COMPOSE};
            BOOL    fReadOnly = IsReadOnly();
            int     cy = BeginYPos();

            for (int i = 0; i < ARRAYSIZE(rgBtnStates); i++)
            {
                if (rgBtnStates[i])
                {
                    if (y < cy)
                        break;

                    if (y < (cy + cyBtn + 2*BUTTON_BUFFER))
                    {
                        if (fReadOnly || rgUseButton[i])
                            resultButton = g_rgBtnInd[i];
                        break;
                    }
                
                    cy += cyBtn + 2*BUTTON_BUFFER + yBuffSize;
                }
            }
        }
    }

    return resultButton;
}

void CNoteHdr::GetButtonRect(DWORD iBtn, RECT *prc)
{
    // Do we already have the rect?
    if (iBtn == m_dwCurrentBtn)
    {
        CopyRect(prc, &m_rcCurrentBtn);
        return;
    }

    // Buttons on the left hand side of the header
    if (ButtonInLabels(iBtn))
    {
        AssertSz(iBtn < m_cHCI, "We are about to access an invalid element...");
        int cyBegin = BeginYPos();

        prc->top = m_rgHCI[iBtn].cy;
        prc->bottom = m_rgHCI[iBtn].cy + g_cyLabelHeight + 2*BUTTON_BUFFER;
        prc->left = ControlXBufferSize() - BUTTON_BUFFER;
        prc->right = (m_cxLeftMargin - ControlXBufferSize()) + BUTTON_BUFFER;

        DOUTL(PAINTING_DEBUG_LEVEL, "STATE Set New Button Frame for button (btn:%d):(%d,%d) to (%d,%d)", 
                    iBtn, prc->left, prc->top, prc->right, prc->bottom);
    }
    // Buttons on the right hand side.
    else
    {
        RECT    rc;
        int     cx = GetCtrlWidth(m_hwnd) - (ControlXBufferSize() + cxBtn),
                cy = BeginYPos(),
                yBuffSize = cyBtn + ControlYBufferSize() + 2*BUTTON_BUFFER;

        BOOL rgBtnStates[] = {BUTTON_STATES};

        prc->left = cx - BUTTON_BUFFER;
        prc->right = cx + cxBtn + BUTTON_BUFFER;
        for (int i = 0; i < ARRAYSIZE(rgBtnStates); i++)
        {
            if (g_rgBtnInd[i] == iBtn)
            {
                prc->top = cy;
                prc->bottom = cy + cyBtn + 2*BUTTON_BUFFER;
                DOUTL(PAINTING_DEBUG_LEVEL, "STATE Set New Button Frame for button (btn:%d):(%d,%d) to (%d,%d)", 
                            iBtn, prc->left, prc->top, prc->right, prc->bottom);
                return;
            }
            else if (rgBtnStates[i])
                cy += yBuffSize;
        }
    }
}

int CNoteHdr::BeginYPos()
{
    int beginBuffer = m_dxTBOffset;
    int cLines = 0;

    if (m_fFlagged || (priLow == m_pri) || (priHigh == m_pri) || (MARK_MESSAGE_NORMALTHREAD != m_MarkType))
        cLines++;
    
    if (m_lpAttMan->GetUnsafeAttachCount())
        cLines++;

    if (cLines)
        beginBuffer += GetStatusHeight(cLines) + g_cyFont/2;

    return beginBuffer;
}

void CNoteHdr::HandleButtonClicks(int x, int y, int iBtn)
{
    m_dwCurrentBtn = HDRCB_NO_BUTTON;
    m_dwClickedBtn = HDRCB_NO_BUTTON;
    HeaderRelease(TRUE);                
    InvalidateRect(m_hwnd, &m_rcCurrentBtn, FALSE);
    
    if (HDRCB_NO_BUTTON == iBtn)
        return;
    
    switch (iBtn)
    {
    case HDRCB_VCARD:
        HrShowVCardCtxtMenu(x, y);
        break;
        
    case HDRCB_SIGNED:
    case HDRCB_ENCRYPT:
        {
            HrShowSecurityProperty(m_hwnd, m_pMsg);
            break;
        }
        
        // This is an index into the labels
    default:
        OnButtonClick(m_rgHCI[iBtn].idBtn);
        break;
    }
}

void CNoteHdr::InvalidateStatus()
{
    RECT rc;
    GetClientRect(m_hwnd, &rc);

    rc.bottom = BeginYPos();

    InvalidateRect(m_hwnd, &rc, TRUE);
    DOUTL(PAINTING_DEBUG_LEVEL, "STATE Invalidating:(%d,%d) for (%d,%d)", rc.left, rc.top, rc.right, rc.bottom);
}




HRESULT CNoteHdr::_CreateEnvToolbar()
{
    UINT            i;
    RECT            rc;
    TCHAR           szRes[CCHMAX_STRINGRES];
    REBARBANDINFO   rbbi;
    POINT           ptIdeal = {0};

    // ~~~~ Do we need to do a WrapW here????
    // create REBAR so we can show toolbar chevrons
    m_hwndRebar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                        WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                        WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                        0, 0, 100, 136, m_hwnd, NULL, g_hInst, NULL);

    if (!m_hwndRebar)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndRebar, RB_SETTEXTCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNTEXT));
    SendMessage(m_hwndRebar, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));
    //SendMessage(m_hwndRebar, RB_SETEXTENDEDSTYLE, RBS_EX_OFFICE9, RBS_EX_OFFICE9);
    SendMessage(m_hwndRebar, CCM_SETVERSION, COMCTL32_VERSION, 0);

    // ~~~~ Do we need to do a WrapW here????
    m_hwndToolbar = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                        WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE|CCS_NOPARENTALIGN|CCS_NODIVIDER|
                        TBSTYLE_TOOLTIPS|TBSTYLE_FLAT|TBSTYLE_LIST,
                        0, 0, 0, 0, m_hwndRebar, NULL, 
                        g_hInst, NULL);

    if (!m_hwndToolbar)
        return E_OUTOFMEMORY;

    // set style on toolbar
    SendMessage(m_hwndToolbar, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DRAWDDARROWS);

    SendMessage(m_hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_hwndToolbar, TB_ADDBUTTONS, (WPARAM)ARRAYSIZE(c_btnsOfficeEnvelope), (LPARAM)c_btnsOfficeEnvelope);

    // set the normal imagelist, office toolbar has ONE only as it's always in Color
    m_himl = LoadMappedToolbarBitmap(g_hLocRes, (fIsWhistler() ? ((GetCurColorRes() > 24) ? idb32SmBrowserHot : idbSmBrowserHot): idbNWSmBrowserHot), cxTBButton);
    if (!m_himl)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_himl);
    SendMessage(m_hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(cxTBButton, cxTBButton));

    // Add text to the Bcc btn. The Send btn is taken care of in the Init
    _SetButtonText(ID_ENV_BCC, MAKEINTRESOURCE(idsEnvBcc));

    GetClientRect(m_hwndToolbar, &rc);

    // get the IDEALSIZE of the toolbar
    SendMessage(m_hwndToolbar, TB_GETIDEALSIZE, FALSE, (LPARAM)&ptIdeal);

    // insert a band
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_SIZE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE | RBBIM_STYLE;
    rbbi.fStyle     = RBBS_USECHEVRON;
    rbbi.cx         = 0;
    rbbi.hwndChild  = m_hwndToolbar;
    rbbi.cxMinChild = 0;
    rbbi.cyMinChild = rc.bottom;
    rbbi.cxIdeal    = ptIdeal.x;

    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT)-1, (LPARAM)(LPREBARBANDINFO)&rbbi);

    // set the toolbar offset
    m_dxTBOffset = rc.bottom;
    return S_OK;
}



HRESULT CNoteHdr::_LoadFromStream(IStream *pstm)
{
    HRESULT         hr;
    IMimeMessage    *pMsg;
    IStream         *pstmTmp,
                    *pstmMsg;
    PERSISTHEADER   rPersist;
    ULONG           cbRead;
    CLSID           clsid;

    if (pstm == NULL)
        return E_INVALIDARG;

    HrRewindStream(pstm);

    // make sure it's our GUID
    if (ReadClassStm(pstm, &clsid)!=S_OK ||
        !IsEqualCLSID(clsid, CLSID_OEEnvelope))
        return E_FAIL;

    // make sure the persistent header is the correct version
    hr = pstm->Read(&rPersist, sizeof(PERSISTHEADER), &cbRead);
    if (hr != S_OK || cbRead != sizeof(PERSISTHEADER) || rPersist.cbSize != sizeof(PERSISTHEADER))
        return E_FAIL;

    // read the message
    hr = HrCreateMessage(&pMsg);
    if (!FAILED(hr))
    {
        hr = MimeOleCreateVirtualStream(&pstmMsg);
        if (!FAILED(hr))
        {
            // MimeOle always rewinds the stream we give it, so we have to copy the 
            // message from our persistent stream into another stream
            hr = HrCopyStream(pstm, pstmMsg, NULL);
            if (!FAILED(hr))
            {
                hr = pMsg->Load(pstmMsg);
                if (!FAILED(hr))
                {
                    hr = Load(pMsg);
                    if (!FAILED(hr))
                    {
                        // BUG: as we use an empty message to persist data for office envelope and empty mime-body can be
                        // considers a text/plain body part. We need to make sure we mark this as RENDERED before loading
                        // any attachments
                        if (pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pstmTmp, NULL)==S_OK)
                            pstmTmp->Release();

                        hr = OnDocumentReady(pMsg);
                    }
                }    
            }
            pstmMsg->Release();
        }
        pMsg->Release();
    }
    return hr;
}

HRESULT CNoteHdr::_SetButtonText(int idmCmd, LPSTR pszText)
{
    TBBUTTONINFO    tbi;
    TCHAR           szRes[CCHMAX_STRINGRES];

    ZeroMemory(&tbi, sizeof(TBBUTTONINFO));
    tbi.cbSize = sizeof(TBBUTTONINFO);
    tbi.dwMask = TBIF_TEXT | TBIF_STYLE;
    tbi.fsStyle = TBSTYLE_BUTTON | TBSTYLE_AUTOSIZE;

    if (IS_INTRESOURCE(pszText))
        {
        // its a string resource id
        LoadString(g_hLocRes, PtrToUlong(pszText), szRes, sizeof(szRes));
        pszText = szRes;
        }

    tbi.pszText = pszText;
    tbi.cchText = lstrlen(pszText);
    SendMessage(m_hwndToolbar, TB_SETBUTTONINFO, idmCmd, (LPARAM) &tbi);
    return S_OK;
}

HRESULT CNoteHdr::_ConvertOfficeCmdIDToOE(LPDWORD pdwCmdId)
{
    static const CMDMAPING   rgCmdMap[] = 
    {   {cmdidSend,             MSOEENVCMDID_SEND},
        {cmdidCheckNames,       MSOEENVCMDID_CHECKNAMES},
        {cmdidAttach,           MSOEENVCMDID_ATTACHFILE},
        {cmdidSelectNames,      MSOEENVCMDID_SELECTRECIPIENTS},
        {cmdidFocusTo,          MSOEENVCMDID_FOCUSTO},
        {cmdidFocusCc,          MSOEENVCMDID_FOCUSCC},
        {cmdidFocusSubject,     MSOEENVCMDID_FOCUSSUBJ}
    };

    for (int i=0; i<ARRAYSIZE(rgCmdMap); i++)
        if (rgCmdMap[i].cmdIdOffice == *pdwCmdId)
        {
            *pdwCmdId = rgCmdMap[i].cmdIdOE;
            return S_OK;
        }

        return E_FAIL;
}


HRESULT CNoteHdr::_UIActivate(BOOL fActive, HWND hwndFocus)
{
    m_fUIActive = fActive;
    if (fActive)
    {
        if (m_pHeaderSite)
            m_pHeaderSite->OnUIActivate();

        if (m_pMsoComponentMgr)
            m_pMsoComponentMgr->FOnComponentActivate(m_dwComponentMgrID);

        if (m_pEnvelopeSite)
        {
            m_pEnvelopeSite->OnEnvSetFocus();
            m_pEnvelopeSite->DirtyToolbars();
        }

    }
    else
    {
        // store focus if decativating
        m_hwndLastFocus = hwndFocus;
        if (m_pHeaderSite)
            m_pHeaderSite->OnUIDeactivate(FALSE);
    }
    return S_OK;
}



HWND CNoteHdr::_GetNextDlgTabItem(HWND hwndDlg, HWND hwndFocus, BOOL fShift)
{
    int     i,
            j,
            idFocus = GetDlgCtrlID(hwndFocus),
            iFocus;
    LONG    lStyle;
    HWND    hwnd;

    // find current pos
    for (i=0; i<ARRAYSIZE(rgIDTabOrderMailSend); i++)
    {
        if (rgIDTabOrderMailSend[i] == idFocus)
            break;
    }

    // i now points to the current control's index
    if (fShift)
    {
        // backwards
        for (j=i-1; j>=0; j--)
        {
            hwnd = GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            AssertSz(hwnd, "something broke");
            if (hwnd)
            {
                lStyle = GetWindowLong(hwnd, GWL_STYLE);
                if ((lStyle & WS_VISIBLE) &&
                    (lStyle & WS_TABSTOP) &&
                    !(lStyle & WS_DISABLED))
                    return GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            }
        }
    }
    else
    {
        // forwards tab
        for (j=i+1; j<ARRAYSIZE(rgIDTabOrderMailSend); j++)
        {
            hwnd = GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            AssertSz(hwnd, "something broke");
            if (hwnd)
            {
                lStyle = GetWindowLong(hwnd, GWL_STYLE);
                if ((lStyle & WS_VISIBLE) &&
                    (lStyle & WS_TABSTOP) &&
                    !(lStyle & WS_DISABLED))
                    return GetDlgItem(hwndDlg, rgIDTabOrderMailSend[j]);
            }
        }
    }
    // not found
    return NULL;
}



HRESULT CNoteHdr::_ClearDirtyFlag()
{
    m_fDirty = FALSE;
    if (m_lpAttMan)
        m_lpAttMan->HrClearDirtyFlag();

    return S_OK;
}

HRESULT CNoteHdr::_RegisterAsDropTarget(BOOL fOn)
{
    HRESULT     hr=S_OK;

    if (fOn)
    {
        // already registered
        if (!m_fDropTargetRegister)
        {
            hr = CoLockObjectExternal((LPDROPTARGET)this, TRUE, FALSE);
            if (FAILED(hr))
                goto error;

            hr = RegisterDragDrop(m_hwnd, (LPDROPTARGET)this);
            if (FAILED(hr))
                goto error;

            m_fDropTargetRegister=TRUE;
        }
    }
    else
    {
        // nothing to do
        if (m_fDropTargetRegister)
        {
            RevokeDragDrop(m_hwnd);
            CoLockObjectExternal((LPUNKNOWN)(LPDROPTARGET)this, FALSE, TRUE);
            m_fDropTargetRegister = FALSE;    
        }
    }

error:
    return hr;
}


HRESULT CNoteHdr::_RegisterWithFontCache(BOOL fOn)
{
    Assert(g_pFieldSizeMgr);

    if (fOn)
    {
        if (0 == m_dwFontNotify)
            g_pFieldSizeMgr->Advise((IUnknown*)(IFontCacheNotify*)this, &m_dwFontNotify);
    }
    else
    {
        if (m_dwFontNotify)
        {
            g_pFieldSizeMgr->Unadvise(m_dwFontNotify);
            m_dwFontNotify = NULL;
        }
    }

    return S_OK;
}


HRESULT CNoteHdr::_RegisterWithComponentMgr(BOOL fOn)
{
    MSOCRINFO           crinfo;
    IServiceProvider    *pSP;

    if (fOn)
    {
        // not registered, so get a component msgr interface and register ourselves
        if (m_pMsoComponentMgr == NULL)
        {
            // negotiate an component msgr from the host
            if (m_pEnvelopeSite &&
                m_pEnvelopeSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
            {
                pSP->QueryService(IID_IMsoComponentManager, IID_IMsoComponentManager, (LPVOID *)&m_pMsoComponentMgr);
                pSP->Release();
            }

            // if not host-provided, try and obtain from LoadLibrary on office dll
            if (!m_pMsoComponentMgr &&
                FAILED(MsoFGetComponentManager(&m_pMsoComponentMgr)))
                return E_FAIL;
        
            Assert (m_pMsoComponentMgr);
            crinfo.cbSize = sizeof(MSOCRINFO);
            crinfo.uIdleTimeInterval = 3000;
            crinfo.grfcrf = msocrfPreTranslateAll;
            crinfo.grfcadvf = msocadvfRedrawOff;

            if (!m_pMsoComponentMgr->FRegisterComponent((IMsoComponent*) this, &crinfo, &m_dwComponentMgrID))
                return E_FAIL;
        }
    }
    else
    {
        if (m_pMsoComponentMgr)
        {
            m_pMsoComponentMgr->FRevokeComponent(m_dwComponentMgrID);
            m_pMsoComponentMgr->Release();
            m_pMsoComponentMgr = NULL;
            m_dwComponentMgrID = 0;
        }
    }

    return S_OK;
}

HRESULT ParseFollowup(LPMIMEMESSAGE pMsg, LPTSTR* ppszGroups, BOOL* pfPoster)
{
    LPTSTR      pszToken, pszTok;
    BOOL        fFirst = TRUE,
                fPoster = FALSE;
    int         cchFollowup;
    LPSTR       lpszFollowup=0;
    ADDRESSLIST addrList={0};
    HRESULT     hr = S_OK;

    *ppszGroups = NULL;

    if (!pMsg)
        return E_INVALIDARG;

    if (FAILED(MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FOLLOWUPTO), NOFLAGS, &lpszFollowup)))
        return E_FAIL;

    cchFollowup = lstrlen(lpszFollowup) + 1;
    if (!MemAlloc((LPVOID*) ppszGroups, sizeof(TCHAR) * cchFollowup))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    **ppszGroups = 0;
    
    // WARNING: we about to trash lpszFollowup with strtok...

    // Walk through the string parsing out the tokens
    pszTok = lpszFollowup;
    pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    while (NULL != pszToken)
    {
        // Want to add all items except Poster (c_szPosterKeyword)
        if (0 == lstrcmpi(pszToken, c_szPosterKeyword))
            fPoster = TRUE;
        else
        {
            if (!fFirst)
            {
                StrCatBuff(*ppszGroups, g_szComma, cchFollowup);
            }
            else
                fFirst = FALSE;
            StrCatBuff(*ppszGroups, pszToken, cchFollowup);
        }
        pszToken = StrTokEx(&pszTok, GRP_DELIMITERS);
    }

    *pfPoster = fPoster;

exit:    
    SafeMimeOleFree(lpszFollowup);

    if (**ppszGroups == 0)
    {
        MemFree(*ppszGroups);
        *ppszGroups = NULL;
    }

    return hr;
}

//***************************************************
CFieldSizeMgr::CFieldSizeMgr(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    TraceCall("CFieldSizeMgr::CFieldSizeMgr");

    m_pAdviseRegistry = NULL;
    m_fFontsChanged = FALSE;
    m_dwFontNotify = 0;
    InitializeCriticalSection(&m_rAdviseCritSect);
}

//***************************************************
CFieldSizeMgr::~CFieldSizeMgr()
{
    IConnectionPoint   *pCP = NULL;

    TraceCall("CFieldSizeMgr::~CFieldSizeMgr");

    EnterCriticalSection(&m_rAdviseCritSect);

    if (m_pAdviseRegistry)
        m_pAdviseRegistry->Release();

    LeaveCriticalSection(&m_rAdviseCritSect);    

    if (g_lpIFontCache)
    {
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID*)&pCP)))
        {
            pCP->Unadvise(m_dwFontNotify);    
            pCP->Release();
        }
    }

    DeleteCriticalSection(&m_rAdviseCritSect);
}


//***************************************************
HRESULT CFieldSizeMgr::OnPreFontChange(void)
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    TraceCall("CFieldSizeMgr::OnPreFontChange");

    EnterCriticalSection(&m_rAdviseCritSect);
    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (SUCCEEDED(pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)))
        {
            pCurr->OnPreFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
    LeaveCriticalSection(&m_rAdviseCritSect);    

    return S_OK;
}

//***************************************************
HRESULT CFieldSizeMgr::OnPostFontChange(void)
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    TraceCall("CFieldSizeMgr::OnPostFontChange");

    ResetGlobalSizes();

    EnterCriticalSection(&m_rAdviseCritSect);
    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (SUCCEEDED(pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)))
        {
            pCurr->OnPostFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
    LeaveCriticalSection(&m_rAdviseCritSect);    

    return S_OK;
}

//***************************************************
HRESULT CFieldSizeMgr::GetConnectionInterface(IID *pIID)        
{
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFieldSizeMgr::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    *ppCPC = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFieldSizeMgr::EnumConnections(IEnumConnections **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFieldSizeMgr::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    TraceCall("CFieldSizeMgr::Advise");

    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->AddItem(pUnkSink, pdwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
HRESULT CFieldSizeMgr::Unadvise(DWORD dwCookie)
{
    TraceCall("CFieldSizeMgr::Unadvise");

    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->RemoveItem(dwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
int CFieldSizeMgr::GetScalingFactor(void)
{
    int iScaling = 100;
    UINT cp;

    cp = GetACP();
    if((932 == cp) || (936 == cp) || (950 == cp) || (949 == cp) || (((1255 == cp) || (1256 == cp)) && (VER_PLATFORM_WIN32_NT != g_OSInfo.dwPlatformId)))
        iScaling = 115;

    return iScaling;
}

//***************************************************
void CFieldSizeMgr::ResetGlobalSizes(void)
{
    HDC         hdc;
    HFONT       hfontOld,
                hfont;
    TEXTMETRIC  tm;

    int         oldcyFont = g_cyFont,
                oldLabelHeight = g_cyLabelHeight,
                cyScaledFont;

    TraceCall("CFieldSizeMgr::ResetGlobalSizes");

    // calc height of edit, based on font we're going to put in it...
    hdc=GetDC(NULL);
    hfont = GetFont(FALSE);
    hfontOld=(HFONT)SelectObject(hdc, hfont); // Hopefully charset fonts are about the same size ???!!!

    g_cfHeader.cbSize = sizeof(CHARFORMAT);
    FontToCharformat(hfont, &g_cfHeader);

    GetTextMetrics(hdc, &tm);

    DOUTL(16, "tmHeight=%d  tmAscent=%d  tmDescent=%d  tmInternalLeading=%d  tmExternalLeading=%d\n", 
            tm.tmHeight, tm.tmAscent, tm.tmDescent, tm.tmInternalLeading, tm.tmExternalLeading);

    SelectObject(hdc, hfontOld);

    cyScaledFont = (tm.tmHeight + tm.tmExternalLeading) * GetScalingFactor();
    if((cyScaledFont%100) >= 50) 
        cyScaledFont  += 100;
    g_cyFont = (cyScaledFont / 100);
    g_cyLabelHeight = (g_cyFont < cyBtn) ? cyBtn : g_cyFont;

    DOUTL(GEN_HEADER_DEBUG_LEVEL,"cyFont=%d", g_cyFont);
    ReleaseDC(NULL, hdc);

    m_fFontsChanged = ((oldcyFont != g_cyFont) || (oldLabelHeight != g_cyLabelHeight));
}

//***************************************************
HRESULT CFieldSizeMgr::Init(void)
{
    HRESULT hr = S_OK;
    IConnectionPoint   *pCP = NULL;

    TraceCall("CFieldSizeMgr::Init");

    ResetGlobalSizes();

    EnterCriticalSection(&m_rAdviseCritSect);

    IF_FAILEXIT(hr = IUnknownList_CreateInstance(&m_pAdviseRegistry));
    IF_FAILEXIT(hr = m_pAdviseRegistry->Init(NULL, 0, 0));

    // We don't want to fail if the font cache is not created. That just means
    // that the fonts won't be changed.
    if (g_lpIFontCache)
    {
        IF_FAILEXIT(hr = g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID*)&pCP));
        IF_FAILEXIT(hr = pCP->Advise((IUnknown*)(IFontCacheNotify*)this, &m_dwFontNotify));    
    }

exit:
    ReleaseObj(pCP);
    LeaveCriticalSection(&m_rAdviseCritSect);

    return hr;
}

//***************************************************
HRESULT CFieldSizeMgr::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CFieldSizeMgr::PrivateQueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IFontCacheNotify))
        *lplpObj = (LPVOID)(IFontCacheNotify *)this;
    else if (IsEqualIID(riid, IID_IConnectionPoint))
        *lplpObj = (LPVOID)(IConnectionPoint *)this;
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\ibodyobj.h ===
#ifndef _IBODYOBJ_H
#define _IBODYOBJ_H

#include "statbar.h"
#include "mimeole.h"

#ifndef __IBodyObj_FWD_DEFINED__
#define __IBodyObj_FWD_DEFINED__
typedef interface IBodyObj IBodyObj;
#endif 	/* __IBodyObj_FWD_DEFINED__ */

// HrInit flags
enum
{
    IBOF_PRINT               =0x01,
    IBOF_USEMARKREAD         =0x02,       // if msg is UNREAD, activates mark as read rules
    IBOF_TABLINKS            =0x04,        
    IBOF_NOSCROLL            =0x08,
    IBOF_DISPLAYTO           =0x10
};

// HrLoad flags
enum
{
    BLF_PRESERVESERVICE     =0x01,      // uses ULA_PRESERVESERVICE
};

// HrUnloadAll flags
enum
{
    ULA_PRESERVESERVICE     =0x01,      // skips SetService(NULL)
};

// HrSave flags
enum
{
    BSF_HTML                =0x00000001,
    BSF_FIXUPURLS           =0x00000002
};


enum
{
    // Used with SMIME
    MEHC_BTN_OPEN = 0x00000001,     // This if from the error screen to the message
    MEHC_BTN_CERT,                  // This opens the cert
    MEHC_BTN_TRUST,                 // This opens the trusts
    MEHC_BTN_CONTINUE,              // Goes from opening screen to either error or main message

    // Used with HTML errors
    MEHC_CMD_CONNECT,               // Try to reconnect to the server
    MEHC_CMD_DOWNLOAD,              // Try to download message again

    // Used with Mark As Read
    MEHC_CMD_MARK_AS_READ,          // Should mark as read now if haven't done it

    MEHC_UIACTIVATE,                // Notifies the view we have the focus

    MEHC_CMD_PROCESS_RECEIPT,       // Tells the view to process for receipts

    MEHC_CMD_PROCESS_RECEIPT_IF_NOT_SIGNED, //Tells the view to process for reciepts if the msg is not signed
    
    MEHC_MAX
};

interface IMimeEditEventSink : public IUnknown 
{
    // Return S_OK if handled, Return S_FALSE if want MEHost to handle event
    virtual HRESULT STDMETHODCALLTYPE EventOccurred(DWORD cmdID, IMimeMessage *pMessage) PURE;
};



typedef  void (CALLBACK * PFNMARKASREAD)(DWORD);
typedef  HRESULT (CALLBACK * PFNNOSECUI)(DWORD);

interface IBodyOptions;

interface IBodyObj2 : public IUnknown
    {
    public:
        // Basic functions
        virtual HRESULT STDMETHODCALLTYPE HrUpdateFormatBar() PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrClearFormatting() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrInit(HWND hwndParent, DWORD dwFlags, IBodyOptions *pBodyOptions) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrClose() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrResetDocument() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetStatusBar(CStatusBar *pStatus) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrUpdateToolbar(HWND hwndToolbar) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrShow(BOOL fVisible) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrOnInitMenuPopup(HMENU hmenuPopup, UINT uID) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMDrawMenuItem(HWND hwnd, LPDRAWITEMSTRUCT pdis) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMMeasureMenuItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrWMCommand(HWND hwnd, int id, WORD wCmd) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrGetWindow(HWND *pHwnd) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetSize(LPRECT prc) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrSetNoSecUICallback(DWORD dwCookie, PFNNOSECUI pfnNoSecUI) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetDragSource(BOOL fIsSource) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrTranslateAccelerator(LPMSG lpMsg) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrUIActivate(BOOL fActivate) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetUIActivate() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrFrameActivate(BOOL fActivate) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrHasFocus() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetBkGrndPicture(LPTSTR pszPicture) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetTabStopArray(HWND *rgTSArray, int *pcArrayCount) PURE;
        virtual HRESULT STDMETHODCALLTYPE PublicFilterDataObject(IDataObject *pDO, IDataObject **ppDORet) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSaveAttachment() PURE;
        virtual HRESULT STDMETHODCALLTYPE SetEventSink(IMimeEditEventSink *pEventSink) PURE;
        virtual HRESULT STDMETHODCALLTYPE LoadHtmlErrorPage(LPCSTR pszURL) PURE;

        // MimeEdit Command Set functions
        virtual HRESULT STDMETHODCALLTYPE HrSpellCheck(BOOL fSuppressDoneMsg) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrIsDirty(BOOL *pfDirty) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetDirtyFlag(BOOL fDirty) PURE;                
        virtual HRESULT STDMETHODCALLTYPE HrIsEmpty(BOOL *pfEmpty) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrUnloadAll(UINT idsDefaultBody, DWORD dwFlags) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetStyle(DWORD dwStyle) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrGetStyle(DWORD *pdwStyle) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrEnableHTMLMode(BOOL fOn) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrDowngradeToPlainText() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetText(LPSTR lpsz) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrPerformROT13Encoding() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrInsertTextFile(LPSTR lpsz) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrInsertTextFileFromDialog() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrViewSource(DWORD dwViewType) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetPreviewFormat(LPSTR lpsz) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetEditMode(BOOL fOn) PURE;        
        virtual HRESULT STDMETHODCALLTYPE HrIsEditMode(BOOL *pfOn) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSetCharset(HCHARSET hCharset) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrGetCharset(HCHARSET *phCharset) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrSaveAsStationery(LPWSTR pwszFile) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrApplyStationery(LPWSTR pwszFile) PURE;
        virtual HRESULT STDMETHODCALLTYPE HrHandsOffStorage() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrRefresh() PURE;
        virtual HRESULT STDMETHODCALLTYPE HrScrollPage() PURE;
        virtual HRESULT STDMETHODCALLTYPE UpdateBackAndStyleMenus(HMENU hmenu) PURE;
    };


#endif  //_IBODYOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mailfldr.cpp ===
/*
 *	m a i l f l d r . c p p
 *	
 *	Purpose:
 *		
 *	
 *	Copyright (C) Microsoft Corp. 1993, 1994.
 */

#include "pch.hxx"
#include "resource.h"
#include "error.h"
#include <strconst.h>
#include "oeschema.h"
#include "demand.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mailfldr.h ===
/*
 *	m a i l f l d r . h
 *	
 *	Purpose:
 *		manages mail folder object, sync's access to store
 *	
 *	Copyright (C) Microsoft Corp. 1993, 1994.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\header.h ===
#ifndef _HEADER_H
#define _HEADER_H


#include <richedit.h>
#ifndef _RICHOLE_H //hack as richole.h has no #ifdef around it
#define _RICHOLE_H
#include <richole.h>
#endif


#include <mimeole.h>
#include <wells.h>
#include <addrobj.h>
#include "iheader.h"
#include <envelope.h>
#include <mso.h>
#include "secutil.h"
#include "tom.h"
#include "reutil.h"

//
// Forwards
//
interface IImnAccount;

class CAttMan;
//
// Structures and other defintions
//

enum
{   // templates for types of note (defines header layout)
    NT_SENDNOTE=0,
    NT_READNOTE,
    NT_NOTECOUNT
};

enum
{
    VCardFALSE=0,
    VCardTRUE,
    VCardDONTKNOW
};

BOOL FHeader_Init(BOOL fInit);
HRESULT CreateInstance_Envelope(IUnknown* pUnkOuter,  IUnknown** ppUnknown);

void HdrSetRichEditText(HWND hwnd, LPWSTR pwchBuff, BOOL fReplace);
DWORD HdrGetRichEditText(HWND hwnd, LPWSTR pwchBuff, DWORD dwNumChars, BOOL fSelection);


// enumeration of icons in the button image list
enum
{
    iimlHdrAddrRolodex=0,
    iimlHdrNewsRolodex,
    //iimlHdrNext,
};


enum    // HCINFO.dwFlags
{
    HCF_MULTILINE   =0x0001,
    HCF_READONLY    =0x0002,
    HCF_HASBUTTON   =0x0004,
    HCF_ADVANCED    =0x0008,
    HCF_ADDRWELL    =0x0010,
    HCF_USECHARSET  =0x0020,
    HCF_OPTIONAL    =0x0040,
    HCF_HIDDEN      =0x0080,
    HCF_COMBO       =0x0100,
    HCF_BORDER      =0x0200,
    HCF_ATTACH      =0x0400,
    HCF_ADDRBOOK    =0x0800,
    HCF_NEWSPICK    =0x1000,
};

enum
{
    AC_IGNORE       =0x01,
    AC_SELECTION    =0x02
};

// header control info structure
typedef struct tagHCI
{
    DWORD           dwFlags,
                    dwOpt;                      // valid if HCF_OPTIONAL
    int             idEdit,                     // id of well
                    idBtn,                      // id of button (if 
                    idsLabel,                   // id used for label of well
                    idsEmpty,                   // id of string used for empty well
                    idsTT;                      // string for tooltip of the well

    DWORD           dwACFlags;                  // valid if HCF_ADDRWELL
    BOOL            fEmpty;                     // state info

    LPRICHEDITOLE   preole;                     // oleinterface; MUST ZeroInit
    ITextDocument  *pDoc;                       // RichEdit interface for text document
    int             cy,                         // y pos of the control (and hence the label)
                    height,                     // y size of control (used when growing control)
                    strlen,                     // strlen of label
                    strlenEmpty;                // strlen of the empty string
    WCHAR           sz[cchHeaderMax+1],         // string for label
                    szEmpty[cchHeaderMax+1];    // string for empty state
} HCI, *PHCI;

class CNoteHdr :
    public IPersistMime,
    public IOleCommandTarget,
    public IHeader,
    public IMsoEnvelope,
    public IMsoComponent,
    public IDropTarget,
    public IFontCacheNotify
{
public:
    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IPersistMime
    HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE);
    HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE, DWORD);
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IHeader
    HRESULT STDMETHODCALLTYPE Init(IHeaderSite* pHeaderSite, HWND hwndParent);
    HRESULT STDMETHODCALLTYPE SetRect(LPRECT);
    HRESULT STDMETHODCALLTYPE GetRect(LPRECT);
    HRESULT STDMETHODCALLTYPE SetPriority(UINT pri);
    HRESULT STDMETHODCALLTYPE GetPriority(UINT* ppri);
    HRESULT STDMETHODCALLTYPE ShowAdvancedHeaders(BOOL fOn);
    HRESULT STDMETHODCALLTYPE FullHeadersShowing(void);
    HRESULT STDMETHODCALLTYPE ChangeLanguage(LPMIMEMESSAGE pMsg);
    HRESULT STDMETHODCALLTYPE GetTitle(LPWSTR lpszTitle, ULONG cch);
    HRESULT STDMETHODCALLTYPE UpdateRecipientMenu(HMENU hmenu);
    HRESULT STDMETHODCALLTYPE SetInitFocus(BOOL fSubject);
    HRESULT STDMETHODCALLTYPE SetVCard(BOOL fFresh);
    HRESULT STDMETHODCALLTYPE IsSecured();
    HRESULT STDMETHODCALLTYPE IsHeadSigned();
    HRESULT STDMETHODCALLTYPE ForceEncryption(BOOL *fEncrypt, BOOL fSet);
    HRESULT STDMETHODCALLTYPE AddRecipient(int idOffset);
    HRESULT STDMETHODCALLTYPE GetTabStopArray(HWND *rgTSArray, int *pcArrayCount);
    HRESULT STDMETHODCALLTYPE SetFlagState(MARK_TYPE markType);
    HRESULT STDMETHODCALLTYPE WMCommand(HWND, int, WORD);
    HRESULT STDMETHODCALLTYPE OnDocumentReady(LPMIMEMESSAGE pMsg);
    HRESULT STDMETHODCALLTYPE DropFiles(HDROP hDrop, BOOL fMakeLinks);
    HRESULT STDMETHODCALLTYPE HrGetAttachCount(ULONG *pcAttMan);
    HRESULT STDMETHODCALLTYPE HrIsDragSource();
    HRESULT STDMETHODCALLTYPE HrGetAccountInHeader(IImnAccount **ppAcct);

    // IDropTarget
    HRESULT STDMETHODCALLTYPE DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragLeave(void);
    HRESULT STDMETHODCALLTYPE Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IMsoEnvelope
    HRESULT STDMETHODCALLTYPE Init(IUnknown* punk, IMsoEnvelopeSite* pesit, DWORD grfInit);
    HRESULT STDMETHODCALLTYPE SetParent(HWND hwndParent);
    HRESULT STDMETHODCALLTYPE Resize(LPCRECT prc);
    HRESULT STDMETHODCALLTYPE Show(BOOL fShow);
    HRESULT STDMETHODCALLTYPE SetHelpMode(BOOL fEnter);
    HRESULT STDMETHODCALLTYPE Save(IStream* pstm, DWORD grfSave);
    HRESULT STDMETHODCALLTYPE GetAttach(const WCHAR* wszName,IStream** ppstm);
    HRESULT STDMETHODCALLTYPE SetAttach(const WCHAR* wszName,const WCHAR* szFile,IStream** ppstm,DWORD* pgrfAttach);
    HRESULT STDMETHODCALLTYPE NewAttach(const WCHAR* pwzName,DWORD grfAttach);
    HRESULT STDMETHODCALLTYPE SetFocus(DWORD grfFocus);
    HRESULT STDMETHODCALLTYPE GetHeaderInfo(ULONG dispid, DWORD grfHeader, void **ppv);
    HRESULT STDMETHODCALLTYPE SetHeaderInfo(ULONG dispid, const void *pv);
        
    HRESULT STDMETHODCALLTYPE IsDirty();
    HRESULT STDMETHODCALLTYPE GetLastError(HRESULT hr, WCHAR __RPC_FAR *wszBuf, ULONG cchBuf);
    HRESULT STDMETHODCALLTYPE DoDebug(DWORD grfDebug);

    // IMsoComponent
    BOOL STDMETHODCALLTYPE FDebugMessage(HMSOINST, UINT, WPARAM, LPARAM);
    BOOL STDMETHODCALLTYPE FPreTranslateMessage(MSG *);
    void STDMETHODCALLTYPE OnEnterState(ULONG, BOOL);
    void STDMETHODCALLTYPE OnAppActivate(BOOL, DWORD);
    void STDMETHODCALLTYPE OnLoseActivation();
    void STDMETHODCALLTYPE OnActivationChange(IMsoComponent *, BOOL, const MSOCRINFO *, BOOL, const MSOCHOSTINFO *, DWORD);
    BOOL STDMETHODCALLTYPE FDoIdle(DWORD grfidlef);
    BOOL STDMETHODCALLTYPE FContinueMessageLoop(ULONG, void *, MSG *);
    BOOL STDMETHODCALLTYPE FQueryTerminate(BOOL);
    void STDMETHODCALLTYPE Terminate();
    HWND STDMETHODCALLTYPE HwndGetWindow(DWORD, DWORD);

    // IFontCacheNotify
    HRESULT STDMETHODCALLTYPE OnPreFontChange(void);
    HRESULT STDMETHODCALLTYPE OnPostFontChange(void);

    static LRESULT EXPORT_16 CALLBACK ExtCNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT EXPORT_16 CALLBACK EditSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT EXPORT_16 CALLBACK BtnSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT EXPORT_16 CALLBACK IMESubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, PHCI phci);

    CNoteHdr();
    virtual ~CNoteHdr();

private:
    ULONG           m_cRef,
                    m_cHCI,
                    m_cAccountIDs,
                    m_cxLeftMargin;
    BOOL            m_fSendImmediate,//as opposed to sendlater.
                    m_fAdvanced,
                    m_fInSize,
                    m_fDirty,
                    m_fVCard,
                    m_fVCardSave,
                    m_fAutoComplete,
                    m_fMail,
                    m_fSecurityInited,
                    m_fThisHeadDigSigned,
                    m_fThisHeadEncrypted,
                    m_fSignTrusted,
                    m_fEncryptionOK,
                    m_fDigSigned,
                    m_fEncrypted,
                    m_fFlagged,
                    m_fOfficeInit,
                    m_fUIActive,
                    m_fResizing,
                    m_fHandleChange,
                    m_fAddressesChanged,
                    m_fForceEncryption,
                    m_fSkipLayout,
                    m_fStillLoading,
                    m_fDropTargetRegister,
                    m_fShowedUnicodeDialog;
    HWND            m_hwndToolbar,
                    m_hwnd,
                    m_hwndParent,
                    m_hwndTT,
                    m_hwndLastFocus,
                    m_hwndRebar;
    UINT            m_ntNote;
	DWORD           m_dwComponentMgrID,
                    m_dwFontNotify,
                    m_dwIMEStartCount;
    RECT            m_rcCurrentBtn;
    HWND            m_hwndOldCapture;
    WORD            m_wNoteType;
    INT             m_dxTBOffset;
    int             m_pri,
                    m_iCurrComboIndex,
                    m_iUnicodeDialogResult;
    LPSTR          *m_ppAccountIDs;
    LPWSTR          m_lpszSecurityField,
                    m_pszRefs;
    TCHAR           m_szLastLang[cchHeaderMax+1];
    PHCI            m_rgHCI;
    CAddrWells     *m_pAddrWells;
    LPWABAL         m_lpWabal;
    SECSTATE        m_SecState;
    HCHARSET        m_hCharset;
    LPMAPITABLE     m_pTable;
    LPWAB           m_lpWab;
    CAttMan        *m_lpAttMan;
    MARK_TYPE       m_MarkType;

    CLIPFORMAT      m_cfAccept;
    DWORD           m_dwDragType,
                    m_grfKeyState,
                    m_dwCurrentBtn,
                    m_dwClickedBtn,
                    m_cCapture,
                    m_dwEffect;


    IHeaderSite            *m_pHeaderSite; // valid if athena hosts header
    IMsoEnvelopeSite       *m_pEnvelopeSite; // valid if Office hosts header
    IImnAccount            *m_pAccount;
    HINITREF                m_hInitRef;     // Application reference count
    IMsoComponentManager   *m_pMsoComponentMgr;
    IMimeMessage           *m_pMsgSend,
                           *m_pMsg;
    HIMAGELIST              m_himl;
    BOOL                    m_fPoster;
private:
    LRESULT CALLBACK CNoteHdrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL IsReplyNote();
    BOOL WMCreate();
    BOOL WMNotify(WPARAM wParam, LPARAM lParam);
    void WMPaint();
    void OnDestroy();
    void OnNCDestroy();
    BOOL PostWMCreate();
    void OnButtonClick(int idBtn);
    void SetReferences(LPMIMEMESSAGE pMsg);
    void HrPickGroups(int idWell, BOOL fFollowUpTo);

    // VCard
    HRESULT HrShowVCardProperties(HWND hwnd);
    HRESULT HrShowVCardCtxtMenu(int x, int y);
    HRESULT HrGetVCardName(LPTSTR pszName, DWORD cch);
    HRESULT HrOnOffVCard();
    HRESULT _AttachVCard(IMimeMessage *pMsg);

    HRESULT HrInit(IMimeMessage *pMsg);
    HRESULT HrFShowHeader(PHCI phci);
    HRESULT HrAutoComplete(HWND hwnd, PHCI pHCI);
    HRESULT HrUpdateCharSetFonts(HCHARSET hCharset, BOOL fUpdateFields);
    HRESULT HrInitFieldList();
    HRESULT HrFreeFieldList();
    HRESULT HrCheckNames(BOOL fSilent, BOOL fSetCheckedFlag);
    HRESULT HrClearUndoStack();
    HRESULT HrNewsSave(LPMIMEMESSAGE pMsg, CODEPAGEID cpID, BOOL fCheckConflictOnly);
    HRESULT HrCopyNonRecipientHeaders(LPMIMEMESSAGE pMsg);
    HRESULT HrOfficeLoad();
    HRESULT HrAutoAddToWAB();
    HRESULT HrSetPri(LPMIMEMESSAGE pMsg);
    HRESULT HrSetupNote(LPMIMEMESSAGE pMsg);
    HRESULT HrSetMailRecipients(LPMIMEMESSAGE pMsg);
    HRESULT HrSetNewsRecipients(LPMIMEMESSAGE pMsg);
    HRESULT HrSetNewsWabal(LPMIMEMESSAGE pMsg, LPWSTR   pwszCC);
    HRESULT HrSetReplySubject(LPMIMEMESSAGE pMsg, BOOL fReply);
    HRESULT HrQueryToolbarButtons(DWORD dwFlags, const GUID *pguidCmdGroup, OLECMD* pOleCmd);
    HRESULT HrGetFieldText(LPWSTR* ppszText, int idHdrCtrl);
    HRESULT HrGetFieldText(LPWSTR* ppszText, HWND hwnd);
    HRESULT ResolveGroupNames(HWND hwnd, int idField, FOLDERID idServer, BOOL fPosterAllowed, BOOL *fOneOrMoreNames);
    HRESULT HrAddSender();
    HRESULT HrAddAllOnToList();
    HRESULT HrCheckGroups(BOOL fPosting);
    HRESULT HrSend();
    HRESULT HrIsCoolToSendHTML();
    HRESULT HrCheckSubject(BOOL fMail);
    HRESULT HrCheckSendInfo();
    HRESULT HrFillMessage(IMimeMessage *pMsg);
    HRESULT HrPickNames(int iwell);
    HRESULT HrUpdateCachedHeight(HWND hwndEdit, RECT *prc);
    HRESULT HrUpdateTooltipPos();
    HRESULT HrOfficeInitialize(BOOL fInit);
    HRESULT HrGetVCardState(ULONG* pCmdf);
    HRESULT HrFillToolbarColor(HDC hdc);
    HRESULT HrViewContacts();

    void    HeaderCapture();
    void    HeaderRelease(BOOL fForce);
    void    ShowControls();
    void    RelayToolTip(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    void    SetPosOfControls(int headerWidth, BOOL fChangeVisibleStates);
    void    SetDirtyFlag();
    int     GetRightMargin(BOOL fMax);
    BOOL    IsReadOnly();


    // security
    HRESULT HrInitSecurityOptions(LPMIMEMESSAGE pMsg, ULONG ulSecurityType);
    HRESULT HrInitSecurity();
    HRESULT HrHandleSecurityIDMs(BOOL fDigsign);
    HRESULT HrSaveSecurity(LPMIMEMESSAGE pMsg);
    HRESULT HrUpdateSecurity(LPMIMEMESSAGE pMsg=NULL);

    LPWSTR  SzGetDisplaySec(LPMIMEMESSAGE pMsg, int *pidsLabel);
    HACCEL  GetAcceleratorTable();
    BOOL    FDoCutCopyPaste(int wmCmd);

    HRESULT ShowEnvOptions();
    void    ReLayout();
    HRESULT UnloadAll();
    void    InvalidateRightMargin(int additionalWidth);
    void    InvalidateStatus();
    DWORD   GetButtonUnderMouse(int x, int y);
    void    GetButtonRect(DWORD iBtn, RECT *prc);
    int     BeginYPos();
    void    HandleButtonClicks(int x, int y, int iBtn);
    void    _UpdateTextFields(BOOL fSetWabal);
    void    _SetEmptyFieldStrings(void);
    void    _AddRecipTypeToMenu(HMENU hmenu);
    HRESULT _CreateEnvToolbar();
    HRESULT _LoadFromStream(IStream *pstm);
    HRESULT _SetButtonText(int idmCmd, LPSTR pszText);
    HRESULT _ConvertOfficeCmdIDToOE(LPDWORD pdwCmdId);
    HRESULT _UIActivate(BOOL fActive, HWND hwndFocus);
    HWND _GetNextDlgTabItem(HWND hwndDlg, HWND hwndFocus, BOOL fShift);
    HRESULT _HandsOffComponentMgr();    
    int _GetLeftMargin();
    HIMAGELIST _CreateToolbarBitmap(int idb, int cx);
    HRESULT _ClearDirtyFlag();
    HRESULT _RegisterAsDropTarget(BOOL fOn);
    HRESULT _RegisterWithFontCache(BOOL fOn);
    HRESULT _RegisterWithComponentMgr(BOOL fOn);
    HRESULT _GetMsoBody(ULONG uBody, LPSTREAM *ppstm);
#ifdef YST
    HRESULT _CheckMsoBodyCharsetConflict(CODEPAGEID cpID);
#endif
    HRESULT _UnicodeSafeSave(IMimeMessage *pMsg, BOOL fCheckConflictOnly);
};

void GetUSKeyboardLayout(HKL *phkl);

// note header WM_COMMAND parent notifications
#define NHD_FIRST           0
#define NHD_SIZECHANGE      (NHD_FIRST + 1)

#endif //_HEADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\imsgsite.h ===
#ifndef __IMSGSITE_H__
#define __IMSGSITE_H__

interface IListSelector;
interface IHeaderSite;

// Message Flags
enum {
    OEMF_REPLIED            = 0x00000001, 
    OEMF_FORWARDED          = 0x00000002,
    OEMF_FLAGGED            = 0x00000004,
    OEMF_DISABLE_SECUI      = 0x00000008,
};

// Message Status Flags
enum {
    // Flags saying what functions are available 0x00000XXX
    OEMSF_CAN_DELETE        = 0x00000001,
    OEMSF_CAN_PREV          = 0x00000002,
    OEMSF_CAN_NEXT          = 0x00000004,
    OEMSF_CAN_COPY          = 0x00000008,
    OEMSF_CAN_MOVE          = 0x00000010,
    OEMSF_CAN_SAVE          = 0x00000020,
    OEMSF_CAN_MARK          = 0x00000040,

    // Flags from message and Folder   0x00XXX000
    OEMSF_SEC_UI_ENABLED    = 0x00001000,
    OEMSF_THREADING_ENABLED = 0x00002000,
    OEMSF_UNSENT            = 0x00004000,
    OEMSF_BASEISNEWS        = 0x00008000,
    OEMSF_RULESNOTENABLED   = 0x00010000,
    OEMSF_UNREAD            = 0x00020000,

    //Flags for return receipts
    OEMSF_MDN_REQUEST       = 0x00040000,
    OEMSF_SIGNED            = 0x00080000,

    // Origin flags    0xXX000000
    OEMSF_FROM_STORE        = 0x01000000,
    OEMSF_FROM_FAT          = 0x02000000,
    OEMSF_FROM_MSG          = 0x04000000,
    OEMSF_VIRGIN            = 0x08000000,
};

// Flags used when calling DoNextPrev
enum {
    // These flags will be ignored if doing previous
    OENF_UNREAD             = 0x00000001,      // get next unread
    OENF_THREAD             = 0x00000002,      // get next thread

    // Don't know if need these or want to use them. Keep them here for now.
    OENF_SKIPMAIL           = 0x00000004,      // skip over mail messages
    OENF_SKIPNEWS           = 0x00000008,      // skip over news messages
};

// Notifications used with Notify
enum {
    OEMSN_UPDATE_PREVIEW    = 0x00000001,
    OEMSN_TOGGLE_READRCPT_REQ,
    OEMSN_PROCESS_READRCPT_REQ,
    OEMSN_PROCESS_RCPT_IF_NOT_SIGNED,
};


// Flags used when saving message
enum {
    OESF_UNSENT             = 0x00000001,
    OESF_READ               = 0x00000002,
    OESF_SAVE_IN_ORIG_FOLDER= 0x00000004,
    OESF_FORCE_LOCAL_DRAFT  = 0x00000008,
};

// Flags when getting message
enum {
    OEGM_ORIGINAL           = 0x00000001,
    OEGM_AS_ATTACH          = 0x00000002,
};

// Message Site init type
enum {
    OEMSIT_MSG_TABLE = 1,
    OEMSIT_STORE,
    OEMSIT_FAT,
    OEMSIT_MSG,
    OEMSIT_VIRGIN,
};

typedef struct tagINIT_BY_STORE {
    MESSAGEID       msgID; 
} INIT_BY_STORE;

typedef struct tagINIT_BY_TABLE {
    IMessageTable  *pMsgTable; 
    IListSelector  *pListSelect;
    ROWINDEX        rowIndex; 
} INIT_BY_TABLE;

typedef struct tagINIT_MSGSITE_STRUCT {
    DWORD               dwInitType;
    FOLDERID            folderID;
    union
        {
        INIT_BY_TABLE   initTable;
        INIT_BY_STORE   initStore;
        LPWSTR          pwszFile;
        IMimeMessage   *pMsg;
        };
} INIT_MSGSITE_STRUCT, *LPINIT_MSGSITE_STRUCT;

interface IOEMsgSite : public IUnknown 
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Init(
            /* [in] */ INIT_MSGSITE_STRUCT *pInitStruct) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetStatusFlags(
            /* [out] */ DWORD *dwStatusFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetFolderID(
            /* [out] */ FOLDERID *folderID) PURE;

        virtual HRESULT STDMETHODCALLTYPE Delete(
            /* [in] */  DELETEMESSAGEFLAGS dwFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE DoNextPrev(
            /* [in] */ BOOL fNext,
            /* [in] */ DWORD dwFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE DoCopyMoveToFolder(
            /* [in] */ BOOL fCopy,
            /* [in] */ IMimeMessage *pMsg,
            /* [in] */ BOOL fUnSent) PURE;

        virtual HRESULT STDMETHODCALLTYPE Save(
            /* [in] */ IMimeMessage *pMsg,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IImnAccount *pAcct) PURE;

        virtual HRESULT STDMETHODCALLTYPE SendToOutbox(
            /* [in] */ IMimeMessage *pMsg,
            /* [in] */ BOOL fSendImmediate
#ifdef SMIME_V3
            , /* [in] */ IHeaderSite *pHeaderSite
#endif // SMIME_V3
            ) PURE;

        virtual HRESULT STDMETHODCALLTYPE MarkMessage(
            /* [in] */ MARK_TYPE dwType,
            /* [in] */ APPLYCHILDRENTYPE dwApplyType) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetMessageFlags(
            /* [out] */ MESSAGEFLAGS *pdwFlags) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount(
            /* [in] */  ACCTTYPE acctType,
            /* [out] */ IImnAccount **ppAcct) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetMessage(
            /* [out] */ IMimeMessage **ppMsg,
            /* [out] */ BOOL *fJustHeader,
            /* [in] */  DWORD dwMessageFlags,
            /* [out] */ HRESULT *phr) PURE;

        virtual HRESULT STDMETHODCALLTYPE Close(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetStoreCallback(
            /* [in] */ IStoreCallback *pStoreCB) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetLocation(
            /* [out] */ LPWSTR rgwchLocation,
            DWORD cchSize) PURE;

        virtual HRESULT STDMETHODCALLTYPE SwitchLanguage(
            /* [in] */ HCHARSET hOldCharset,
            /* [in] */ HCHARSET hNewCharset) PURE;

        // ptyNewOp will be either SOT_INVALID or 
        // the new final state for the OnComplete in the note
        virtual HRESULT STDMETHODCALLTYPE OnComplete(
            /* [in] */ STOREOPERATIONTYPE tyOperation, 
            /* [in] */ HRESULT hrComplete,
            /* [out] */ STOREOPERATIONTYPE *ptyNewOp) PURE;

        virtual HRESULT STDMETHODCALLTYPE UpdateCallbackInfo(
            /* [in] */ LPSTOREOPERATIONINFO pOpInfo) PURE;

        virtual HRESULT STDMETHODCALLTYPE Notify(
            /* [in] */ DWORD dwNotifyID) PURE;

};

enum {
    OENA_READ = 0, 
    OENA_COMPOSE,

    OENA_REPLYTOAUTHOR, 
    OENA_REPLYTONEWSGROUP, 
    OENA_REPLYALL, 

    OENA_FORWARD, 
    OENA_FORWARDBYATTACH, 

    OENA_WEBPAGE,
    OENA_STATIONERY,
    OENA_MAX,
};

// Note Creation Flags
enum{
    // Used to say creating a news note. Will now be used to 
    // say what is the default set of wells to create in header.
    // This will also be used to say that this is a newsnote for now
    OENCF_NEWSFIRST             = 0x00000001,
    OENCF_NEWSONLY              = 0x00000002,
    OENCF_SENDIMMEDIATE         = 0x00000004,
    OENCF_NOSTATIONERY          = 0x00000008,
    OENCF_NOSIGNATURE           = 0x00000010,
    OENCF_MODAL                 = 0x00000020,
    OENCF_USESTATIONERYFONT     = 0x00000040,
};

interface IOENote : public IUnknown {
    // Init will automatically load message from pMsgSite
    STDMETHOD(Init) (DWORD dwAction, DWORD dwCreateFlags, RECT *prc, HWND hwnd, 
                     INIT_MSGSITE_STRUCT *pInitStruct, IOEMsgSite *pMsgSite,
                     IUnknown *punkPump) PURE;
    STDMETHOD(Show) (void) PURE;
    virtual HRESULT(ToggleToolbar) (void) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\ibodyopt.h ===
#ifndef _IBODYOPT_H
#define _IBODYOPT_H

#include <unknwn.h>

/*
 * IBodyOptions
 *
 * this interface is implemented by clients of IBodyObj. It is used to provide instance-specific options to 
 * the body. Thus the body does not need to know about internal Athena options. They can be provided by the client
 * this will ease moving the body object out into an activeX control at some later date, reducing dependancy on the body.
 * also the body doesn't need to know the difference between a news message and mail message who have different settings
 *
 * The RootStream builder will call back into the body options to ask for various options as it is building the HTML
 * only the host knows what mode the UI is in and sets the options accordingly.
 *
 * NB: implementors, must implement all of the members.
 */


enum 
{
    BOPTF_COMPOSEFONT           = 0x00000001,
    BOPTF_QUOTECHAR             = 0x00000002,
    BOPTF_REPLYTICKCOLOR        = 0x00000004
};

typedef struct BODYOPTINFO_tag
{
    DWORD   dwMask;

    DWORD   dwReplyTickColor;
    TCHAR   rgchComposeFont[LF_FACESIZE + 50];
    TCHAR   chQuote;
} BODYOPTINFO, *LPBODYOPTINFO;

interface IBodyOptions : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE SignatureEnabled(BOOL fAuto) PURE;
        // pdwSigOptions == SIGOPT_ from rootstm.h        
        virtual HRESULT STDMETHODCALLTYPE GetSignature(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetMarkAsReadTime(LPDWORD pdwSecs) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetFlags(LPDWORD pdwFlags) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetInfo(BODYOPTINFO *pBOI) PURE;
        virtual HRESULT STDMETHODCALLTYPE GetAccount(IImnAccount **ppAcct) PURE;
};

// IID_IBodyOptions:: {9D39DE30-4E3D-11d0-A5A5-00C04FD61319}
DEFINE_GUID(IID_IBodyOptions, 0x9d39de30, 0x4e3d, 0x11d0, 0xa5, 0xa5, 0x0, 0xc0, 0x4f, 0xd6, 0x13, 0x19);


enum    // Flags for HrGetFlags
{
    BOPT_INCLUDEMSG             = 0x00000001,   // include the message when building the rootstream
    BOPT_HTML                   = 0x00000002,   // set if HTML is enabled
    BOPT_AUTOINLINE             = 0x00000004,   // set if images can be auto-inlined
    BOPT_SENDIMAGES             = 0x00000008,   // set if images to packaged as MTHML at sendtime
    BOPT_AUTOTEXT               = 0x00000010,   // set for compose notes, if some form of autotext needs to be inserted at the caret
    BOPT_NOFONTTAG              = 0x00000020,   // set if we don't want compose font tags emitted, ie. use the stationery default
    BOPT_BLOCKQUOTE             = 0x00000040,   // block quote the text after inserting it.
    BOPT_SENDEXTERNALS          = 0x00000080,   // set is external URL are to be packed
    BOPT_SPELLINGOREORIGINAL    = 0x00000100,   // set if ignore original text in reply&forward.
    BOPT_SECURITYUIENABLED      = 0x00000200,   // set if message should use security UI if message is secure
    BOPT_FROMSTORE              = 0x00000400,   // set if the message is from the store
    BOPT_USEREPLYHEADER         = 0x00000800,   // set if should use a reply header
    BOPT_MAIL                   = 0x00001000,   // set if body is mail (instead of news)
    BOPT_REPLYORFORWARD         = 0x00002000,   // set if action is replay or forward
    BOPT_MULTI_MSGS_SELECTED    = 0x00004000,   // set if there are more than one messages selected
    BOPT_UNREAD                 = 0x00008000,   // set if the msg is not read as of yet
    BOPT_FROM_NOTE              = 0x00010000,   // set if need to mark immediate (as is the case with the note)
    BOPT_SIGNED                 = 0x00020000,   // set if the message is signed
};

enum        // flags for keeping track of the header type
{
    HDRSTYLE_NONE=0,        // no reply header
    HDRSTYLE_NEWS,          // news-style reply header: "On <date>, <author> wrote:"
    HDRSTYLE_MAIL           // MSMail-style reply header
};

enum        // flags for pdwSigOptions in HrGetSignature
{
    SIGOPT_PLAIN    = 0x00000000,   // signature is plain-text, needs conversion.
    SIGOPT_TOP      = 0x00000001,   // signature at the top of the document (default)
    SIGOPT_PREFIX   = 0x00000002,   // use signature prefix ("-- ") only a std for news
    SIGOPT_BOTTOM   = 0x00000004,   // signature at the bottom of document
    SIGOPT_CLOSING  = 0x00000008,   // news messages, close themselves with a '-----' at the end
    SIGOPT_HTML     = 0x00000010    // signature is in HTML already
};

#endif  //_IBODYOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\iheader.h ===
#ifndef __IHEADER_H__
#define __IHEADER_H__

#ifndef __IHeader_INTERFACE_DEFINED__
#define __IHeader_INTERFACE_DEFINED__
typedef interface IHeader IHeader;
#endif

#ifndef __IHeaderSite_INTERFACE_DEFINED__
#define __IHeaderSite_INTERFACE_DEFINED__
typedef interface IHeaderSite IHeaderSite;
#endif

typedef IHeader __RPC_FAR *LPHEADER;
typedef IHeaderSite __RPC_FAR *LPHEADERSITE;

EXTERN_C const IID IID_IHeader;
EXTERN_C const IID IID_IHeaderSite;

#define cchHeaderMax                256

enum
{
    priNone=-1,
    priLow=0,
    priNorm,
    priHigh
};


interface IHeader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRect(
            /* [in] */ LPRECT prc) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetRect(
            /* [in] */ LPRECT prc) PURE;

        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IHeaderSite* pHeaderSite,
            /* [in] */ HWND hwndParent) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetPriority(
            /* [in] */ UINT pri) PURE;

        virtual HRESULT STDMETHODCALLTYPE ShowAdvancedHeaders(
            /* [in] */ BOOL fOn) PURE;

        virtual HRESULT STDMETHODCALLTYPE FullHeadersShowing(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE ChangeLanguage(
            /* [in] */ LPMIMEMESSAGE pMsg) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetTitle(
            /* [in] */ LPWSTR lpszTitle,
            /* [in] */ ULONG cch) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetPriority(
            /* [in] */ UINT* ppri) PURE;

        virtual HRESULT STDMETHODCALLTYPE UpdateRecipientMenu(
            /* [in] */ HMENU hmenu) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetInitFocus(
            /* [in] */ BOOL fSubject) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetVCard(
            /* [in] */ BOOL fFresh) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsSecured(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsHeadSigned(void) PURE;
        virtual HRESULT STDMETHODCALLTYPE ForceEncryption(BOOL *fEncrypt, BOOL fSet) PURE;

        virtual HRESULT STDMETHODCALLTYPE AddRecipient(
            /* [in] */ int idOffset) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetTabStopArray(
            /* [out] */ HWND *rgTSArray,
            /* [in, out] */ int *piArrayCount) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetFlagState(
            /* [in] */ MARK_TYPE markType) PURE;

        virtual HRESULT STDMETHODCALLTYPE WMCommand(HWND, int, WORD) PURE;

        virtual HRESULT STDMETHODCALLTYPE OnDocumentReady(
            /* [in] */ LPMIMEMESSAGE pMsg) PURE;

        virtual HRESULT STDMETHODCALLTYPE DropFiles(HDROP hDrop, BOOL) PURE;

        virtual HRESULT STDMETHODCALLTYPE HrGetAttachCount(
            /* [out] */ ULONG *pcAttMan) PURE;

        virtual HRESULT STDMETHODCALLTYPE HrIsDragSource() PURE;

        virtual HRESULT STDMETHODCALLTYPE HrGetAccountInHeader(
            /* [out] */ IImnAccount **ppAcct) PURE;
    };

interface IHeaderSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Resize(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE Update(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE OnUIActivate(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(
            /* [in] */ BOOL fUndoable) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsHTML(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE SetHTML(
           /* [in] */ BOOL fHTML) PURE;

        virtual HRESULT STDMETHODCALLTYPE SaveAttachment(void) PURE;

        virtual HRESULT STDMETHODCALLTYPE IsModal() PURE;
        virtual HRESULT STDMETHODCALLTYPE CheckCharsetConflict() PURE;

        virtual HRESULT STDMETHODCALLTYPE ChangeCharset(HCHARSET hCharset) PURE;

        virtual HRESULT STDMETHODCALLTYPE GetCharset(HCHARSET *phCharset) PURE;

#ifdef SMIME_V3
        virtual HRESULT STDMETHODCALLTYPE GetLabelFromNote(
            /*[out]*/  PSMIME_SECURITY_LABEL *plabel) PURE;
        virtual HRESULT STDMETHODCALLTYPE IsSecReceiptRequest(void) PURE;
        virtual HRESULT STDMETHODCALLTYPE IsForceEncryption(void) PURE;
#endif // SMIME_V3
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\imailcmn.h ===
// ------------------------------------------------------------------------------------
// IMAILCMN.H
// ------------------------------------------------------------------------------------
#ifndef __IMAILCMN_H
#define __IMAILCMN_H

// ------------------------------------------------------------------------------------
// INETMAILERROR
// ------------------------------------------------------------------------------------
typedef struct tagINETMAILERROR {
    DWORD               dwErrorNumber;                  // Error Number
    HRESULT             hrError;                        // HRESULT of error
    LPTSTR              pszServer;                      // Server
    LPTSTR              pszAccount;                     // Account
    LPTSTR              pszMessage;                     // Actual error message
    LPTSTR              pszUserName;                    // User Name
    LPTSTR              pszProtocol;                    // protocol smtp or pop3
    LPTSTR              pszDetails;                     // Details message
    DWORD               dwPort;                         // Port
    BOOL                fSecure;                        // Secure ssl conneciton
} INETMAILERROR, *LPINETMAILERROR;

// ------------------------------------------------------------------------------------
// InetMail Flags
// ------------------------------------------------------------------------------------
#define IM_SENDMAIL     FLAG01
#define IM_RECVMAIL     FLAG02
#define IM_BACKGROUND   FLAG03
#define IM_NOERRORS     FLAG04
#define IM_POP3NOSKIP   FLAG05

// ------------------------------------------------------------------------------------
// InetMail Delivery Notifications
// ------------------------------------------------------------------------------------
typedef enum tagDELIVERTY {
    DELIVERY_CONNECTING,
    DELIVERY_CHECKING,
    DELIVERY_SENDING,
    DELIVERY_RECEIVING,
    DELIVERY_COMPLETE,       // lParam == n new messages
    DELIVERY_FAILURE
} DELIVERY;

// ------------------------------------------------------------------------------------
// Prototypes
// ------------------------------------------------------------------------------------
HRESULT InetMail_HrInit(VOID);
HRESULT InetMail_HrDeliverNow(HWND hwndView, LPTSTR pszAccount, DWORD dwFlags); // See flags above
HRESULT InetMail_HrFlushOutbox(VOID);
HRESULT InetMail_HrRegisterView(HWND hwndView, BOOL fRegister);
VOID    InetMail_RemoveNewMailNotify(VOID);
HRESULT InetMail_HrClose(VOID);
BOOL CALLBACK InetMailErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif // __IMAILCMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mailopt.h ===
/*
 *	m a i l o p t . h
 *	
 *  Purpose: Contains defines and prototypes for the mail options prop sheet.
 */

#ifndef __MAILOPT_H
#define __MAILOPT_H

#include "optdlg.h"

#define IDC_SOUND_CHECK             1000
#define IDC_PREVIEW_CHECK           1001
#define IDC_AUTOCHECK_CHECK         1002
#define IDC_AUTOCHECK_EDIT          1003
#define IDC_EMPTY_CHECK             1004
#define IDC_AUTOCHECK_SPIN          1005
#define IDC_SAVE_CHECK              1006
#define IDC_CHECK3                  1008
#define IDC_INDENT_CHECK            1010
#define IDC_INDENT_COMBO            1011
#define IDC_MIME_RADIO              1013
#define IDC_UUENCODE_RADIO          1014
#define IDC_ENCODE_COMBO            1015
#define IDC_BREAK_CHECK             1016
#define IDC_BREAK_EDIT              1017
#define IDC_BREAK_SPIN              1018
#define IDC_NOSIG_RADIO             1020
#define IDC_TEXT_RADIO              1021
#define IDC_FILE_RADIO              1022
#define IDC_TEXT_EDIT               1023
#define IDC_FILE_EDIT               1024
#define IDC_BROWSE_BUTTON           1025
#define IDC_ADVANCED_BUTTON         1026
#define IDC_INCLUDE_CHECK           1027
#define IDC_AUTOSIGNATURE_CHECK     1029
#define IDC_MARKASREAD_EDIT         1030
#define IDC_MARKASREAD_SPIN         1031
#define IDC_MAILTIMEOUT_SLIDER      1033
#define IDC_MAILTIMEOUT_STATIC      1034
#define IDC_SENDIMMEDIATE_CHECK     1036
#define IDC_SIGREPLY_CHECK          1037
#define IDC_MAILWRAP_EDIT           1038
#define IDC_MAILWRAP_SPIN           1039
#define IDC_8BIT_HEADER             1040
#define IDC_MAILWRAP_TEXT1          1041
#define IDC_MAILWRAP_TEXT2          1042
#define idcStaticOrFwd              1047
#define idcStaticReplying           1048
#define IDC_AUTOWAB_CHECK           1049

#define IDC_SIGN_CHECK              1052
#define IDC_ENCRYPT_CHECK           1053
#define IDC_ADVSETTINGS_BUTTON      1054
#define IDC_CERT_COMBO              1055
#define IDC_INCLUDECERT_CHECK       1056
#define IDC_ENCRYPT_COMBO           1057

#define IDC_FONTSETTINGS            1060

#endif  // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mapiutil.h ===
#ifndef _MAPIUTIL_H
#define _MAPIUTIL_H

const DWORD MSGTYPE_REPLY = 2;
const DWORD MSGTYPE_FWD   = 5;
const DWORD MSGTYPE_CC    = 4;

void NewsUtil_FreeMAPI(void);
HRESULT NewsUtil_ReFwdByMapi(HWND hwnd, LPMIMEMESSAGE pMsg, DWORD msgtype);
HRESULT NewsUtil_QuoteBodyText(LPMIMEMESSAGE pMsg, LPSTREAM pStreamIn,
                               LPSTREAM* ppStreamOut, BOOL fInsertDesc, BOOL fQP, LPCSTR pszFrom);
HRESULT NewsUtil_LoadMAPI(HWND hwnd);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mailutil.h ===
// ----------------------------------------------------------------------------------------------------------
// M A I L U T I L . H
// ----------------------------------------------------------------------------------------------------------
#ifndef __MAILUTIL_H
#define __MAILUTIL_H

// ----------------------------------------------------------------------------------------------------------
// Depend On
// ----------------------------------------------------------------------------------------------------------
//#include "gennote.h"

// ----------------------------------------------------------------------------------------------------------
// To create a folder
// ----------------------------------------------------------------------------------------------------------
void MailUtil_DoFolderDialog(HWND hwndParent, FOLDERID idFolder);

#define RenameFolderDlg(_hwnd, _idFolder)  MailUtil_DoFolderDialog(_hwnd, _idFolder);

HRESULT MailUtil_OnImportExportAddressBook(HWND hwnd, BOOL fImport);

HRESULT HrSendWebPage(HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, IUnknown *pUnkPump);
HRESULT HrSendWebPageDirect(LPWSTR pwszURL, HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, 
                            BOOL fIncludeSig, IUnknown *pUnkPump, IMimeMessage  *pMsg);

HRESULT HrSaveMessageInFolder(HWND hwnd, IMessageFolder *pfldr, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges);
HRESULT HrSaveMessageInFolder(HWND hwnd, FOLDERID idFolder, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid);
HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, IMessageFolder *pfldr, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges);
HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, FOLDERID idFolder, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid);

HRESULT HrSendMailToOutBox(HWND hwndOwner, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail = TRUE);
HRESULT SendMailToOutBox(IStoreCallback *pStoreCB, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail);

HRESULT HrSetSenderInfoUtil(IMimeMessage *pMsg, IImnAccount *pAccount, LPWABAL lpWabal, BOOL fMail, CODEPAGEID cpID, BOOL fCheckConflictOnly);

HRESULT HrCreateReferences(LPWSTR pszOrigRefs, LPWSTR pszNewRef, LPWSTR *ppszRefs);

#endif // __MAILUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mapiutil.cpp ===
#include "pch.hxx"
#include "note.h"
#include "header.h"
#include "envcid.h"
#include "envguid.h"
#include "bodyutil.h"
#include "oleutil.h"
#include "acctutil.h"
#include "menures.h"
#include "instance.h"
#include "inetcfg.h"
#include "ipab.h"
#include "msgprop.h"
#include "mlang.h"
#include "shlwapip.h" 
#include "demand.h"
#include <ruleutil.h>
#include "instance.h"
#include "mapiutil.h"
#include <mapi.h>



LHANDLE g_lhSession = 0;



//
//  FUNCTION:   NewsUtil_ReFwdByMapi
//
//  PURPOSE:    Allows the caller to reply to the specified message via Simple
//              MAPI instead of Athena Mail.
//
//  PARAMETERS:
//      hwnd     - Handle of the window to display UI over.
//      pNewsMsg - Pointer to the news message to reply/forward to
//      fReply   - TRUE if we should reply, FALSE to forward.
//
//  RETURN VALUE:
//      HRESULT.
//
HRESULT NewsUtil_ReFwdByMapi(HWND hwnd, LPMIMEMESSAGE pMsg, DWORD msgtype)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMAPIFREEBUFFER    pfnMAPIFreeBuffer;
    LPMAPIRESOLVENAME   pfnMAPIResolveName;
    LPMAPISENDMAIL      pfnMAPISendMail;
    MapiMessage         mm;
    MapiFileDesc        *pFileDesc=NULL;
    MapiRecipDesc       *pRecips=NULL;
    ULONG               uAttach;
    ULONG               cAttach=0;
    HBODY               *rghAttach=NULL;
    LPSTR               pszReply=NULL;
    LPSTR               pszSubject=NULL;
    LPSTR               pszFrom=NULL;
    LPSTR               pszTo=NULL;
    LPSTR               pszFile=NULL;
    LPSTR               pszFull=NULL;
    LPSTR               pszDisplay=NULL;
    LPSTR               pszAddr=NULL;
    ADDRESSLIST         addrList={0};
    HBODY               hBody;
    BOOL                fQP;
    TCHAR               szNewSubject[256];
    LPWSTR              pwsz=NULL;
    ULONG               cchRead;
    LPSTREAM            pBodyStream=NULL;
    LPSTREAM            pQuotedStream=NULL;
    INT                 cch;
    DWORD               cbUnicode;
    CHAR                szTempPath[MAX_PATH];
    LPMIMEBODY          pBody=NULL;
    MapiFileDesc       *pCur;

    // Trace
    TraceCall("NewsUtil_ReFwdByMapi");

    // Initialize
    ZeroMemory(&mm, sizeof(mm));

    // Load the MAPI DLL.  If we don't succeed, then we can't continue
    IF_FAILEXIT(hr = NewsUtil_LoadMAPI(hwnd));

    // pfnMAPIFreeBuffer
    pfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(g_hlibMAPI, c_szMAPIFreeBuffer);
    if (NULL == pfnMAPIFreeBuffer)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // pfnMAPIResolveName
    pfnMAPIResolveName = (LPMAPIRESOLVENAME) GetProcAddress(g_hlibMAPI, c_szMAPIResolveName);
    if (NULL == pfnMAPIResolveName)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // pfnMAPISendMail
    pfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress(g_hlibMAPI, c_szMAPISendMail);
    if (NULL == pfnMAPISendMail)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // From
    if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &pwsz)))
    {
        IF_NULLEXIT(pszFrom = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // Reply-To
    if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REPLYTO), NOFLAGS, &pwsz)))
    {
        IF_NULLEXIT(pszReply = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // To
    if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, &pwsz)))
    {
        IF_NULLEXIT(pszTo = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // If this is a reply or forward, we need to get the normalized subject.  Otherwise, we just get the regular subject.
    if (MSGTYPE_REPLY == msgtype || MSGTYPE_FWD == msgtype)
    {
        // Normalized Subject
        if (FAILED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &pwsz)))
            pwsz = NULL;
    }

    // Subject
    else if (FAILED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwsz)))
        pwsz = NULL;

    // Convert to ansi
    if (pwsz)
    {
        IF_NULLEXIT(pszSubject = PszToANSI(CP_ACP, pwsz));
        SafeMemFree(pwsz);
    }

    // Attempt to generate a reciepent list for MAPI if we're replying or CC'ing.
    if (msgtype == MSGTYPE_REPLY || msgtype == MSGTYPE_CC)
    {
        // Figure out which address to use
        if (msgtype == MSGTYPE_REPLY)
        {
            // If there's a reply-to field on the message, then use that
            if (pszReply)
                pszFull = pszReply;
            else
                // Otherwise, we'll use the address in the from header
                pszFull = pszFrom;
        }

        // Who to address to
        else
            pszFull = pszTo;

        // Bug #24587 - Use IAT_TO instead of IAT_UNKNOWN.
        if (MimeOleParseRfc822Address(IAT_TO, IET_DECODED, pszFull, &addrList)==S_OK)
        {
            UINT i;
            lpMapiRecipDesc paRecips,pCurrent;
            DWORD cchSizeName = 128;
            DWORD cchSizeAddress = 128;

            // we arbitrarily chose 128 as typical for EIDSize and address string lengths
            int cAlloc = (sizeof(MapiRecipDesc) + (sizeof(TCHAR) * cchSizeName) + 128) * addrList.cAdrs;
            int cUsed = sizeof(MapiRecipDesc) * addrList.cAdrs;
            LPBYTE pVal = NULL;

            IF_FAILEXIT(hr = HrAlloc((LPVOID *)&paRecips, cAlloc));
            pCurrent = paRecips;
            pVal = (LPBYTE)pCurrent + sizeof(MapiRecipDesc) * addrList.cAdrs;

            // More than one address
            for (i=0; i < addrList.cAdrs ;i++)
            {
                int cBytes;

                // free Safe Friendly Name (not used here, but was allocated)
                SafeMemFree(addrList.prgAdr[i].pszFriendly);
                addrList.prgAdr[i].pszFriendly = NULL;

                // Save E-mail address
                pszAddr = addrList.prgAdr[i].pszEmail;
                addrList.prgAdr[i].pszEmail = NULL;

                // Resolve Name
                if ((cUsed < cAlloc) && SUCCESS_SUCCESS == pfnMAPIResolveName(g_lhSession, (ULONG_PTR) hwnd, pszAddr, MAPI_DIALOG, 0, &pRecips))
                {
                    pRecips->ulRecipClass = MAPI_TO;

                    // copy pRecip
                    pCurrent->ulReserved = pRecips->ulReserved;
                    pCurrent->ulRecipClass = pRecips->ulRecipClass;
                    pCurrent->ulEIDSize = pRecips->ulEIDSize;

                    do {
                    if (pRecips->lpszName)
                    {
                        cBytes = (lstrlen(pRecips->lpszName)+1)*sizeof(TCHAR);
                        cUsed += cBytes;
                        if (cUsed > cAlloc)
                            break;
                        pCurrent->lpszName = (LPTSTR)pVal;
                        StrCpyN(pCurrent->lpszName, pRecips->lpszName, cchSizeName);
                        pVal += cBytes;
                    }
                    else
                    {
                        pCurrent->lpszName = NULL;
                    }

                    if (pRecips->lpszAddress)
                    {
                        cBytes = (lstrlen(pRecips->lpszAddress)+1)*sizeof(TCHAR);
                        cUsed += cBytes;
                        if (cUsed > cAlloc)
                            break;
                        pCurrent->lpszAddress = (LPTSTR)pVal;
                        StrCpyN(pCurrent->lpszAddress, pRecips->lpszAddress, cchSizeAddress);
                        pVal += cBytes;
                    }
                    else
                    {
                        pCurrent->lpszAddress = NULL;
                    }

                    if (pRecips->ulEIDSize)
                    {
                        cUsed += pRecips->ulEIDSize;
                        if (cUsed > cAlloc)
                            break;
                        pCurrent->lpEntryID = pVal;
                        CopyMemory(pCurrent->lpEntryID, pRecips->lpEntryID, (size_t)pRecips->ulEIDSize);
                        pVal += pRecips->ulEIDSize;
                    }
                    else
                    {
                        pCurrent->lpEntryID = NULL;
                    }

                    pCurrent++;
                    mm.nRecipCount++;
                    } while (FALSE);

                    // Free recips
                    (*pfnMAPIFreeBuffer)((LPVOID)pRecips);
                    pRecips = NULL;
                }

                SafeMemFree(pszAddr);
                pszAddr = NULL;
            }
            mm.lpRecips = paRecips;

            // Free the Address List
            g_pMoleAlloc->FreeAddressList(&addrList);
        }
    }

    // If this is a reply or forward, then create a normalized subject
    if (msgtype == MSGTYPE_REPLY || msgtype == MSGTYPE_FWD)
    {
        // Pull in the new prefix from resource...
        if (msgtype == MSGTYPE_REPLY)
        {
            StrCpyN(szNewSubject, c_szPrefixRE, ARRAYSIZE(szNewSubject));
        }
        else
        {
            StrCpyN(szNewSubject, c_szPrefixFW, ARRAYSIZE(szNewSubject));
        }

        // If we have a pszSubject
        if (pszSubject)
        {
            // Get Length
            cch = lstrlen(szNewSubject);

            // Append the Subject
            StrCpyN(szNewSubject + cch, pszSubject, ARRAYSIZE(szNewSubject) - cch - 1);
        }

        // Set the Subject
        mm.lpszSubject = szNewSubject;
    }

    // Don't append anything
    else
    {
        // If this is a CC, then just use the regular subject field
        mm.lpszSubject = pszSubject;
    }

    // Set the note text.
    // If this is a fwd as attachment, there won't be a body, don't use IF_FAILEXIT
    if(SUCCEEDED(pMsg->GetTextBody(TXT_PLAIN, IET_UNICODE, &pBodyStream, &hBody)))
    {
        // Convert from unicode to CP_ACP - WARNING: HrStreamToByte allocates 10 extra bytes so I can slam in a L'\0'
        IF_FAILEXIT(hr = HrStreamToByte(pBodyStream, (LPBYTE *)&pwsz, &cbUnicode));

        // Store null
        pwsz[cbUnicode / sizeof(WCHAR)] = L'\0';

        // Convert to ANSI
        IF_NULLEXIT(mm.lpszNoteText = PszToANSI(CP_ACP, pwsz));

        // Release pBodyStream
        SafeRelease(pBodyStream);

        // Bug #24159 - We need to quote forwards as well as replies
        if (DwGetOption(OPT_INCLUDEMSG) && (msgtype == MSGTYPE_REPLY || msgtype == MSGTYPE_FWD))
        {
            // Create a new stream
            IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pBodyStream));

            // Dump mm.lpszNoteText into pBodyStream
            IF_FAILEXIT(hr = pBodyStream->Write(mm.lpszNoteText, lstrlen(mm.lpszNoteText), NULL));

            // Commit
            IF_FAILEXIT(hr = pBodyStream->Commit(STGC_DEFAULT));

            // Rewind
            IF_FAILEXIT(hr = HrRewindStream(pBodyStream));

            // QP
            fQP = HrHasEncodedBodyParts(pMsg, 1, &hBody)==S_OK;

            // Quote the body text
            NewsUtil_QuoteBodyText(pMsg, pBodyStream, &pQuotedStream, TRUE, fQP, pszFrom ? pszFrom : c_szEmpty);

            // Free
            SafeMemFree(mm.lpszNoteText);

            // Dup
            IF_FAILEXIT(hr = HrStreamToByte(pQuotedStream, (LPBYTE *)&mm.lpszNoteText, &cchRead));

            // Null Term
            *(mm.lpszNoteText + cchRead) = '\0';
        }
    }

    // If this is a reply, then we don't include any attachments, otherwise we do.
    if (msgtype != MSGTYPE_REPLY)
    {
        // Get Attachment Count
        IF_FAILEXIT(hr = pMsg->GetAttachments(&cAttach, &rghAttach));

        // Ar there attachments
        if (cAttach)
        {
            // Get the temp file path so we have a place to store temp files.
            GetTempPath(ARRAYSIZE(szTempPath), szTempPath);

            // Create the MapiFileDesc array.
            IF_FAILEXIT(hr = HrAlloc((LPVOID*) &pFileDesc, sizeof(MapiFileDesc) * cAttach));

            // Zero It
            ZeroMemory(pFileDesc, sizeof(MapiFileDesc) * cAttach);

            // Set Current
            pCur = pFileDesc;

            // Loop
            for (uAttach = 0; uAttach < cAttach; uAttach++)
            {
                // Get a temp file name
                IF_FAILEXIT(hr = HrAlloc((LPVOID *)&(pCur->lpszPathName), sizeof(TCHAR) * MAX_PATH));

                // Create temp filename
                GetTempFileName(szTempPath, "NAB", 0, pCur->lpszPathName);

                // Bind to the body
                IF_FAILEXIT(hr = pMsg->BindToObject(rghAttach[uAttach], IID_IMimeBody, (LPVOID *)&pBody));

                // Safe It
                IF_FAILEXIT(hr = pBody->SaveToFile(IET_INETCSET, pCur->lpszPathName));

                // Release
                SafeRelease(pBody);

                // Get the filename
                if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, rghAttach[uAttach], STR_ATT_GENFNAME, NOFLAGS, &pwsz)))
                {
                    IF_NULLEXIT(pszFile = PszToANSI(CP_ACP, pwsz));
                    SafeMemFree(pwsz);
                }
                
                // Set up the MAPI attachment list
                pCur->ulReserved = 0;
                pCur->flFlags = 0;
                pCur->nPosition = (ULONG) -1;
                pCur->lpszFileName = pszFile;
                pCur->lpFileType = NULL;

                // Increment
                pCur++;

                // Don't Free It
                pszFile = NULL;
            }

            mm.nFileCount = cAttach;
            mm.lpFiles = pFileDesc;
        }
    }

    // Finally send this off to MAPI for sending.  If we're doing a CC, we try not to use UI
    IF_FAILEXIT(hr = (HRESULT) pfnMAPISendMail(g_lhSession, (ULONG_PTR)hwnd, &mm, (msgtype == MSGTYPE_CC) ? 0 : MAPI_DIALOG, 0));

exit:
    // If we have a file description
    if (pFileDesc)
    {
        // Walk through the attachments
        for (uAttach=0; uAttach<cAttach; uAttach++)
        {
            // Free It
            MemFree(pFileDesc[uAttach].lpszFileName);

            // If we have a file path
            if (pFileDesc[uAttach].lpszPathName)
            {
                // Delete the file
                DeleteFile(pFileDesc[uAttach].lpszPathName);

                // Free It
                MemFree(pFileDesc[uAttach].lpszPathName);
            }
        }

        // Free It
        MemFree(pFileDesc);
    }

    // Free recips
    if (pRecips)
        (*pfnMAPIFreeBuffer)((LPVOID)pRecips);

    // Cleanup
    SafeMemFree(mm.lpRecips);
    SafeMemFree(pszAddr);
    SafeMemFree(pszDisplay);
    SafeMemFree(mm.lpszNoteText);
    SafeMemFree(pwsz);
    SafeMemFree(pszReply);
    SafeMemFree(pszSubject);
    SafeMemFree(pszFrom);
    SafeMemFree(rghAttach);
    SafeMemFree(pszTo);
    SafeRelease(pQuotedStream);
    SafeRelease(pBodyStream);
    SafeRelease(pBody);

    // If we logged on to MAPI, we must log off
    NewsUtil_FreeMAPI();

    return(hr);
}

    //
//  FUNCTION:   NewsUtil_LoadMAPI()
//
//  PURPOSE:    Takes care of checking to see if Simple MAPI is available, and
//              if so loads the library and logs the user on.  If successful,
//              then the global variable g_hlibMAPI is set to the library for
//              MAPI.
//
HRESULT NewsUtil_LoadMAPI(HWND hwnd)
    {
    LPMAPILOGON pfnMAPILogon;
    HRESULT     hr = E_FAIL;

    // Load mapi32 dll if we haven't already
    if (!g_hlibMAPI)
    {            

        // Check to see if Simple MAPI is available
        if (1 != GetProfileInt(c_szMailIni, c_szMAPI, 0))
            {
            // Bug #17561 - Need to tell the user they can't send mail without
            //              a mail client.
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                          MAKEINTRESOURCEW(idsErrNoMailInstalled), 0, MB_OK | MB_ICONSTOP);
            return (E_FAIL);
            }

        g_hlibMAPI = (HMODULE) LoadLibrary(c_szMAPIDLL);
        if (!g_hlibMAPI)
            {
            // Bug #17561 - Need to tell the user they can't send mail without
            //              a mail client.
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaNews),
                          MAKEINTRESOURCEW(idsErrNoMailInstalled), 0, MB_OK | MB_ICONSTOP);
            return (E_FAIL);
            }
    }

    // Get the entry point for MAPILogon and the other APIs we'll use.
    pfnMAPILogon = (LPMAPILOGON) GetProcAddress(g_hlibMAPI, c_szMAPILogon);
    if (!pfnMAPILogon)
        {
        AssertSz(pfnMAPILogon, TEXT("Couldn't find the MAPILogon() API"));
        goto error;
        }

    // Attempt to log on.
    // Bug #17558 - Can't used the FAILED() macro to check the success of this
    //              one, MAPI is not returning HRESULTs, just numbers.
    if (SUCCESS_SUCCESS != (hr = pfnMAPILogon(NULL, NULL, NULL, MAPI_LOGON_UI, 0, &g_lhSession)))
        {
        // AssertSz(FALSE, TEXT("Failed call to MAPILogon()"));
        goto error;
        }

    return (S_OK);

error:
    if (g_hlibMAPI)
        {
        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = 0;
        }
    g_lhSession = 0;

    return (hr);
    }


//
//  FUNCTION:   NewsUtil_FreeMAPI()
//
//  PURPOSE:    Frees the Simple MAPI library if it was previous library and
//              also logs the user off from the current MAPI session.
//
void NewsUtil_FreeMAPI(void)
    {
    LPMAPILOGOFF pfnMAPILogoff;

    if (!g_hlibMAPI)
        return;
    pfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress(g_hlibMAPI, c_szMAPILogoff);

    if (g_lhSession)
        pfnMAPILogoff(g_lhSession, NULL, 0, 0);
    g_lhSession = 0;
    }

//
//  FUNCTION:   NewsUtil_QuoteBodyText()
//
//  PURPOSE:    Takes a body text stream (ASCII plain text) and copies the
//              text to a separate outbound stream while prepending the
//              current quote character (">") to the beginning of each line.
//
//  PARAMETERS:
//      pMsg        - Pointer to the message being replied to.  We use this
//                    to add the "On 1/1/96, B.L. Opie Bailey wrote..."
//      pStreamIn   - Pointer to the inbound body stream to quote.
//      ppStreamOut - Pointer to where the new quoted stream will return.
//      fInsertDesc - TRUE if we should insert the "On 1/1/96 ..." line.
//      fQP         - we now pass a flag to say if it's QP or not as there's no
//                    function on the message object
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
const DWORD c_cBufferSize = 1024;
HRESULT NewsUtil_QuoteBodyText(LPMIMEMESSAGE pMsg, LPSTREAM pStreamIn,
                               LPSTREAM* ppStreamOut, BOOL fInsertDesc, BOOL fQP, LPCSTR pszFrom)
    {
    HRESULT hr = S_OK;
    ULONG   cbRead;
    LPTSTR  pch;
    TCHAR   szQuoteChar;
    LPSTR   lpszMsgId=0;

    szQuoteChar = (TCHAR)DwGetOption(OPT_NEWSINDENT);

    // Validate the inbound stream.
    if (!pStreamIn)
        {
        AssertSz(pStreamIn, TEXT("NewsUtil_QuoteBodyText - Need an inbound stream to process."));
        return (E_INVALIDARG);
        }

    // Create our outbound stream.
    if (FAILED(MimeOleCreateVirtualStream(ppStreamOut)))
        {
        AssertSz(FALSE, TEXT("NewsUtil_QuoteBodyText - Failed to allocate memory."));
        return (E_OUTOFMEMORY);
        }

    // Create a buffer to read into and parse etc.
    LPTSTR pszBuffer;
    if (!MemAlloc((LPVOID*) &pszBuffer, c_cBufferSize * sizeof(TCHAR)))
        {
        (*ppStreamOut)->Release();
        AssertSz(FALSE, TEXT("NewsUtil_QuoteBodyText - Failed to allocate memory."));
        return (E_OUTOFMEMORY);
        }

    ZeroMemory(pszBuffer, c_cBufferSize * sizeof(TCHAR));

    MimeOleGetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpszMsgId);

    if (lpszMsgId == NULL)
        lpszMsgId = (LPSTR)c_szEmpty;

    if (fQP)
        {
        // If the text has some quoted printable stuff in it, then we don't want
        // to introduce hard line breaks.  Instead we just prefix the stream with
        // the normal desc stuff and end it with a suitable line.

        // Add the quote line.
        LPTSTR pszStringRes;
        int ids = 0;

        if (fInsertDesc)
            {
            pszStringRes = AthLoadString(idsReplyTextPrefix, 0, 0);
            wnsprintf(pszBuffer, c_cBufferSize, pszStringRes, pszFrom, lpszMsgId);
            AthFreeString(pszStringRes);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF2, lstrlen(g_szCRLF2), NULL);
            (*ppStreamOut)->Write((LPVOID) pszBuffer, lstrlen(pszBuffer), NULL);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF, lstrlen(g_szCRLF), NULL);
            }

        while (TRUE)
            {
            // Read a buffer from the input and write it to the output.
            hr = pStreamIn->Read((LPVOID) pszBuffer, c_cBufferSize - 2, &cbRead);
            if (FAILED(hr))
                goto exit;
            if (cbRead == 0)
                break;

            (*ppStreamOut)->Write((LPVOID) pszBuffer, cbRead, NULL);
            }

        // Write the trailing comment.
        pszStringRes = AthLoadString(idsReplyTextAppend, 0, 0);
        (*ppStreamOut)->Write((LPVOID) pszStringRes, lstrlen(pszStringRes), NULL);
        AthFreeString(pszStringRes);
        }
    else
        {
        if (fInsertDesc)
            {
            // Add the quote line.
            LPTSTR pszStringRes;
            int ids = 0;

            pszStringRes = AthLoadString(idsReplyTextPrefix, 0, 0);
            wnsprintf(pszBuffer, c_cBufferSize, pszStringRes, pszFrom, lpszMsgId);
            AthFreeString(pszStringRes);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF2, lstrlen(g_szCRLF2), NULL);
            (*ppStreamOut)->Write((LPVOID) pszBuffer, lstrlen(pszBuffer), NULL);
            (*ppStreamOut)->Write((LPVOID) g_szCRLF, lstrlen(g_szCRLF), NULL);
            }

        // Write the first quote char to the new stream.
        // Bug #26297 - Still go through this bs even if no quote char is necessary
        //              to make sure we get the attribution line right.
        if (szQuoteChar != INDENTCHAR_NONE)
            {
            (*ppStreamOut)->Write((const LPVOID) &szQuoteChar,
                                  sizeof(TCHAR), NULL);
            (*ppStreamOut)->Write((const LPVOID) g_szSpace, sizeof(TCHAR), NULL);
            }

        // Now start the reading and parsing.
        // NOTE - Right now all we're doing is adding a quote char to the beginning
        //        of each line.  We're not trying to wrap lines or re-wrap previously
        //        quoted areas. - SteveSer
        while (TRUE)
            {
            hr = pStreamIn->Read((LPVOID) pszBuffer, c_cBufferSize - 2, &cbRead);
            if (FAILED(hr))
                goto exit;
            if (cbRead == 0)
                break;

            pch = pszBuffer;
            // Make sure the buffer is NULL terminated
            *(pch + cbRead) = 0;

            // Now run through the stream.  Whenever we find a line break, we
            // insert a quote char after the line break.
            while (*pch)
                {
                (*ppStreamOut)->Write((const LPVOID) pch,
                                      (ULONG)((IsDBCSLeadByte(*pch) ? 2 * sizeof(TCHAR) : sizeof(TCHAR))),
                                      NULL);
                if (*pch == *g_szNewline)
                    {
                    // Bug #26297 - Still go through this bs even if no quote char is necessary
                    //              to make sure we get the attribution line right.
                    if (szQuoteChar != INDENTCHAR_NONE)
                        {
                        (*ppStreamOut)->Write((const LPVOID) &szQuoteChar,
                                              sizeof(TCHAR), NULL);
                        (*ppStreamOut)->Write((const LPVOID) g_szSpace, sizeof(TCHAR),
                                              NULL);
                        }
                    }

                pch = CharNext(pch);

                // Do some checking to see if we're at the end of a buffer.
                if (IsDBCSLeadByte(*(pch)) && (0 == *(pch + 1)))
                    {
                    // Here's a little special case.  If we have one byte left in
                    // the buffer, and that byte happens to be the first byte in
                    // a DBCS character, we need to write that byte now, then move
                    // the pointer to the end of the buffer so the next character
                    // get's read off the next stream OK.
                    (*ppStreamOut)->Write((const LPVOID) pch, sizeof(TCHAR), NULL);
                    pch++;
                    }
                }
            }
        }

exit:
    if (pszBuffer)
        MemFree(pszBuffer);

    if (lpszMsgId != c_szEmpty)
        SafeMimeOleFree(lpszMsgId);
    return (hr);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mailutil.cpp ===
// ----------------------------------------------------------------------------------------------------------
// M A I L U T I L . C P P
// ----------------------------------------------------------------------------------------------------------
#include "pch.hxx"
#include "demand.h"
#include "resource.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "strconst.h"
#include "url.h"
#include "mailutil.h"
#include <spoolapi.h>
#include <fonts.h>
#include "instance.h"
#include "pop3task.h"
#include <ntverp.h>
#include "msgfldr.h"
#include "storutil.h"
#include "note.h"
#include "shlwapip.h"
#include <iert.h>
#include "storecb.h"
#include "conman.h"
#include "multiusr.h"
#include "ipab.h"
#include "secutil.h"

// ----------------------------------------------------------------------------------------------------------
// Folder Dialog Info
// ----------------------------------------------------------------------------------------------------------
typedef struct FLDRDLG_tag
{
    FOLDERID        idFolder;
    BOOL            fPending;
    CStoreDlgCB    *pCallback;
} FLDRDLG, *PFLDRDLG;

// ----------------------------------------------------------------------------------------------------------
// Prototypes
// ----------------------------------------------------------------------------------------------------------
INT_PTR CALLBACK MailUtil_FldrDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WebPageDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT HrDlgCreateWebPage(HWND hwndDlg);


// ----------------------------------------------------------------------------------------------------------
// DoFolderDialog
// ----------------------------------------------------------------------------------------------------------
void MailUtil_DoFolderDialog(HWND hwndParent, FOLDERID idFolder)
{
    FLDRDLG fdlg;

    fdlg.idFolder = idFolder;
    fdlg.fPending = FALSE;
    fdlg.pCallback = new CStoreDlgCB;
    if (fdlg.pCallback == NULL)
        // TODO: an error message might be nice
        return;

    DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddNewFolder), hwndParent, MailUtil_FldrDlgProc, (LPARAM)&fdlg);

    fdlg.pCallback->Release();
}

// ----------------------------------------------------------------------------------------------------------
// FldrDlgProc
// ----------------------------------------------------------------------------------------------------------
INT_PTR CALLBACK MailUtil_FldrDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PFLDRDLG        pfdlg;
    TCHAR           sz[CCHMAX_STRINGRES];
    HWND            hwndT;
    HRESULT         hr;
    WORD            id;
    FOLDERINFO      Folder;

    Assert(CCHMAX_STRINGRES > CCHMAX_FOLDER_NAME);

    switch(msg)
        {
        case WM_INITDIALOG:
            pfdlg = (PFLDRDLG)lParam;
            Assert(pfdlg != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pfdlg);

            hwndT = GetDlgItem(hwnd, idtxtFolderName);
            Assert(hwndT != NULL);
            SetIntlFont(hwndT);
            SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_FOLDER_NAME, 0);

            LoadString(g_hLocRes, idsRenameFolderTitle, sz, ARRAYSIZE(sz));
            SetWindowText(hwnd, sz);

            hr = g_pStore->GetFolderInfo(pfdlg->idFolder, &Folder);
            if (!FAILED(hr))
                {
                SetWindowText(hwndT, Folder.pszName);
                g_pStore->FreeRecord(&Folder);
                }

            pfdlg->pCallback->Initialize(hwnd);

            SendMessage(hwndT, EM_SETSEL, 0, -1);

            CenterDialog(hwnd);
            return(TRUE);

        case WM_STORE_COMPLETE:
            pfdlg = (PFLDRDLG)GetDlgThisPtr(hwnd);

            Assert(pfdlg->fPending);
            pfdlg->fPending = FALSE;

            hr = pfdlg->pCallback->GetResult();
            if (hr == S_FALSE)
            {
                EndDialog(hwnd, IDCANCEL);
            }
            else if (FAILED(hr))
            {
                // No need to put up error dialog, CStoreDlgCB already did this on failed OnComplete

                /*
                AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                    MAKEINTRESOURCEW(idsErrRenameFld), hr);
                */
                hwndT = GetDlgItem(hwnd, idtxtFolderName);
                SendMessage(hwndT, EM_SETSEL, 0, -1);
                SetFocus(hwndT);
            }
            else
            {
                EndDialog(hwnd, IDOK);
            }
            break;

        case WM_COMMAND:
            pfdlg = (PFLDRDLG)GetDlgThisPtr(hwnd);

            id=GET_WM_COMMAND_ID(wParam, lParam);

            if (id == IDOK)
            {
                if (pfdlg->fPending)
                    break;

                pfdlg->pCallback->Reset();

                hwndT = GetDlgItem(hwnd, idtxtFolderName);
                GetWindowText(hwndT, sz, ARRAYSIZE(sz));

                hr = g_pStore->RenameFolder(pfdlg->idFolder, sz, NOFLAGS, (IStoreCallback *)pfdlg->pCallback);
                if (hr == E_PENDING)
                {
                    pfdlg->fPending = TRUE;
                }
                else if (FAILED(hr))
                {
                    AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsErrRenameFld), hr);
                    SendMessage(hwndT, EM_SETSEL, 0, -1);
                    SetFocus(hwndT);
                }
                else
                {
                    EndDialog(hwnd, IDOK);
                }
            }
            else if (id==IDCANCEL)
            {
                if (pfdlg->fPending)
                    pfdlg->pCallback->Cancel();
                else
                    EndDialog(hwnd, IDCANCEL);
            }
            break;
        }
    return FALSE;
}

//
//  FUNCTION:   MailUtil_OnImportAddressBook()
//
//  PURPOSE:    Calls the WAB migration code to handle import/export.
//
//  PARAMETERS:
//      <in> fImport - TRUE if we should import, FALSE to export.
//
HRESULT MailUtil_OnImportExportAddressBook(HWND hwnd, BOOL fImport)
{
    OFSTRUCT of;
    HFILE hfile;
    TCHAR szParam[255];  
    LPTSTR lpParam = fImport ? _T("/import") : _T("/export");

    StrCpyN(szParam, lpParam, ARRAYSIZE(szParam));
    //MU_GetCurrentUserInfo(szParam+13, ARRAYSIZE(szParam) - 13, NULL, 0);

    hfile = OpenFile((TCHAR *)c_szWabMigExe, &of, OF_EXIST);
    if (hfile == HFILE_ERROR)
        return(E_FAIL);


    ShellExecute(hwnd, _T("Open"), of.szPathName, szParam, NULL, SW_SHOWNORMAL);

    return(S_OK);
}

HRESULT HrSendWebPageDirect(LPWSTR pwszUrl, HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, 
                            BOOL fIncludeSig, IUnknown *pUnkPump, IMimeMessage  *pMsg)
{
    HRESULT                 hr;
    LPSTREAM                pstm=NULL;
    HCURSOR                 hcur=0;
    INIT_MSGSITE_STRUCT     initStruct;
    DWORD                   dwCreateFlags = OENCF_SENDIMMEDIATE|OENCF_USESTATIONERYFONT;
    HCHARSET                hCharset;
    ENCODINGTYPE            ietEncoding = IET_DECODED;
    BOOL                    fLittleEndian;
    LPSTR                   pszCharset = NULL;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (!pMsg)
    {
        //We were not passed pMessage, so we need to create one.
        IF_FAILEXIT(hr = HrCreateMessage(&pMsg));
    }
    else
    {
        pMsg->AddRef();
    }

    IF_FAILEXIT(hr = HrCreateBasedWebPage(pwszUrl, &pstm));

    if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
    {
        if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        ietEncoding = IET_UNICODE;
    }
    else if((S_OK == GetHtmlCharset(pstm, &pszCharset)) && pszCharset)
    {
        if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        ietEncoding = IET_INETCSET;
    }

    IF_FAILEXIT(hr = pMsg->SetTextBody(TXT_HTML, ietEncoding, NULL, pstm, NULL));

    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.pMsg = pMsg;
    initStruct.folderID = folderID;

    if (!fIncludeSig)
        dwCreateFlags |= OENCF_NOSIGNATURE;

    if (fModal)
        dwCreateFlags |= OENCF_MODAL;

    if (!fMail)
        dwCreateFlags |= OENCF_NEWSFIRST;

    IF_FAILEXIT(hr = CreateAndShowNote(OENA_STATIONERY, dwCreateFlags, &initStruct, hwnd, pUnkPump));

exit:
    if (hcur)
        SetCursor(hcur);

    ReleaseObj(pMsg);
    ReleaseObj(pstm);
    return hr;
}

HRESULT HrSendWebPage(HWND hwnd, BOOL fModal, BOOL fMail, FOLDERID folderID, IUnknown *pUnkPump)
{
    HRESULT                 hr;
    LPMIMEMESSAGE           pMsg=0;
    LPSTREAM                pstm=0;
    INIT_MSGSITE_STRUCT     initStruct;
    DWORD                   dwCreateFlags = OENCF_SENDIMMEDIATE;
    LPSTR                   pszCharset;
    HCHARSET                hCharset;
    BOOL                    fLittleEndian;
    ENCODINGTYPE            ietEncoding=IET_INETCSET;

    if(DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddWebPage), hwnd, WebPageDlgProc, (LPARAM)&pstm)==IDCANCEL)
        return NOERROR;

    hr=HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto error;

    // [SBAILEY]: Raid 23209: OE: File/Send Web Page sends all pages as Latin-1 even if they aren't
    if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
    {
        if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        ietEncoding = IET_UNICODE;
    }

    else if (SUCCEEDED(GetHtmlCharset(pstm, &pszCharset)))
    {
        if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
        {
            pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
        }

        MemFree(pszCharset);
    }

    hr=pMsg->SetTextBody(TXT_HTML, ietEncoding, NULL, pstm, NULL);
    if (FAILED(hr))
        goto error;

    if (fModal)
        dwCreateFlags |= OENCF_MODAL;

    if (!fMail)
        dwCreateFlags |= OENCF_NEWSFIRST;

    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.pMsg = pMsg;
    initStruct.folderID = folderID;

    hr = CreateAndShowNote(OENA_WEBPAGE, dwCreateFlags, &initStruct, hwnd, pUnkPump);

error:
    ReleaseObj(pMsg);
    ReleaseObj(pstm);
    return hr;
}

static const HELPMAP g_rgCtxMapWebPage[] = {
    {idTxtWebPage, 50210},
    {0, 0}
};

INT_PTR CALLBACK WebPageDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            int     iTxtLength;
            HWND    hwndEdit = GetDlgItem(hwnd, idTxtWebPage);

            Assert(hwndEdit);
            Assert(lParam!= NULL);

            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)lParam);
            SendDlgItemMessage(hwnd, idTxtWebPage, EM_LIMITTEXT, MAX_PATH-1, NULL);

            SetFocus(hwndEdit);
            SHAutoComplete(hwndEdit, SHACF_URLALL); 
            CenterDialog(hwnd);
            return FALSE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgCtxMapWebPage);

        case WM_COMMAND:
        {
            int     id = GET_WM_COMMAND_ID(wParam, lParam);
            HWND    hwndEdit = GetDlgItem(hwnd, idTxtWebPage);

            switch(id)
            {
                case IDOK:
                    if (FAILED(HrDlgCreateWebPage(hwnd)))
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                            MAKEINTRESOURCEW(idsErrSendWebPageUrl), NULL, MB_OK);
                        SendMessage(hwndEdit, EM_SETSEL, 0, -1);
                        SetFocus(hwndEdit);
                        return 0;
                    }

                    // fall thro'
                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            }
        }
    }
    return FALSE;
}

static const CHAR  c_wszHTTP[]  = "http://";
HRESULT HrDlgCreateWebPage(HWND hwndDlg)
{
    WCHAR               wszUrl[MAX_PATH+1],
                        wszUrlCanon[MAX_PATH + 10 + 1];
    DWORD               cCanon = ARRAYSIZE(wszUrlCanon);
    LPSTREAM           *ppstm = NULL;
    HRESULT             hr = E_FAIL;
    HCURSOR             hcur=0;

    *wszUrlCanon = 0;

    ppstm = (LPSTREAM *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    if(!GetWindowTextWrapW(GetDlgItem(hwndDlg, idTxtWebPage), wszUrl, ARRAYSIZE(wszUrl)))
        goto exit;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    IF_FAILEXIT(hr = UrlApplySchemeW(wszUrl, wszUrlCanon, &cCanon, URL_APPLY_DEFAULT|URL_APPLY_GUESSSCHEME|URL_APPLY_GUESSFILE));

    // If UrlApplyScheme returns S_FALSE, then it thought that the original works just fine, so use original
    IF_FAILEXIT(hr = HrCreateBasedWebPage((S_FALSE == hr) ? wszUrl : wszUrlCanon, ppstm));

exit:
    if (hcur)
        SetCursor(hcur);
    return hr;
}

HRESULT HrSaveMessageInFolder(HWND hwnd, IMessageFolder *pfldr, LPMIMEMESSAGE pMsg, 
    MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges)
{
    CStoreCB *pCB;
    HRESULT hr;

    Assert(pfldr != NULL);

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsSavingToFolder), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = SaveMessageInFolder((IStoreCallback *)pCB, pfldr, pMsg, dwFlags, pNewMsgid, fSaveChanges);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, IMessageFolder *pfldr, 
    LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid, BOOL fSaveChanges)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrWarnings=S_OK;
    MESSAGEID           msgid;

    // Trace
    TraceCall("HrSaveMessageInFolder");

    // Invalid Args
    if (pMsg == NULL || pfldr == NULL)
        return TraceResult(E_INVALIDARG);

    // Don't save changes, then clear the dirty bit
    if (FALSE == fSaveChanges) 
        MimeOleClearDirtyTree(pMsg);

    // Save the message
    IF_FAILEXIT(hr = pMsg->Commit(0));

    // Insert the Message
    hr = pfldr->SaveMessage(pNewMsgid, SAVE_MESSAGE_GENID, dwFlags, 0, pMsg, pStoreCB);

exit:
    // Done
    return (hr == S_OK ? hrWarnings : hr);
}

HRESULT SaveMessageInFolder(IStoreCallback *pStoreCB, FOLDERID idFolder, LPMIMEMESSAGE pMsg, 
    MESSAGEFLAGS dwFlags, MESSAGEID *pNewMsgid)
{
    // Locals
    HRESULT         hr;

    IMessageFolder *pfldr=NULL;

    // Open the Folder..
    hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pfldr);
    if (SUCCEEDED(hr))
    {
        hr = SaveMessageInFolder(pStoreCB, pfldr, pMsg, dwFlags, pNewMsgid, TRUE);
        pfldr->Release();
    }

    return hr;
}

HRESULT HrSaveMessageInFolder(HWND hwnd, FOLDERID idFolder, LPMIMEMESSAGE pMsg, MESSAGEFLAGS dwFlags, 
    MESSAGEID *pNewMsgid)
{
    // Locals
    HRESULT         hr;

    IMessageFolder *pfldr=NULL;

    // Open the Folder..
    hr = g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pfldr);
    if (SUCCEEDED(hr))
    {
        hr = HrSaveMessageInFolder(hwnd, pfldr, pMsg, dwFlags, pNewMsgid, TRUE);
        pfldr->Release();
    }

    return hr;
}

HRESULT HrSendMailToOutBox(HWND hwndOwner, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail)
{
    CStoreCB *pCB;
    HRESULT hr;

    pCB = new CStoreCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(hwndOwner, MAKEINTRESOURCE(idsSendingToOutbox), TRUE);
    if (SUCCEEDED(hr))
    {
        hr = SendMailToOutBox((IStoreCallback *)pCB, pMsg, fSendImmediate, fNoUI, fMail);
        if (hr == E_PENDING)
            hr = pCB->Block();

        pCB->Close();
    }

    pCB->Release();

    return(hr);    
}

HRESULT SendMailToOutBox(IStoreCallback *pStoreCB, LPMIMEMESSAGE pMsg, BOOL fSendImmediate, BOOL fNoUI, BOOL fMail)
{
    HRESULT     hr;
    FOLDERINFO  Outbox;
    const TCHAR c_szXMailerAndNewsReader[] = "Microsoft Outlook Express " VER_PRODUCTVERSION_STR;
    DWORD       dwSendFlags = fMail ? ARF_SUBMITTED|ARF_UNSENT : ARF_SUBMITTED|ARF_UNSENT|ARF_NEWSMSG;
    HWND        hwnd = 0;
    BOOL        fSecure = IsSecure(pMsg);

    Assert(pStoreCB);
    pStoreCB->GetParentWindow(0, &hwnd);

    hr = g_pStore->GetSpecialFolderInfo(FOLDERID_LOCAL_STORE, FOLDER_OUTBOX, &Outbox);
    if (FAILED(hr))
        return hr;

    // make sure we never send mail with the X-Unsent header on it.
    pMsg->DeleteBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT));

    if (fMail)
    {
        // pound the X-Mailer prop always for anyone going' thro' our spooler.
        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XMAILER), NOFLAGS, c_szXMailerAndNewsReader);
    }
    else
    {
        DWORD dwLines;
        TCHAR rgch[12];
        HrComputeLineCount(pMsg, &dwLines);
        wnsprintf(rgch, ARRAYSIZE(rgch), "%d", dwLines);
        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_LINES), NOFLAGS, rgch);
        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XNEWSRDR), NOFLAGS, c_szXMailerAndNewsReader);
    }

    hr = SaveMessageInFolder(pStoreCB, Outbox.idFolder, pMsg, dwSendFlags, NULL);
    if (FAILED(hr))
        goto error;

    // if immediate send is required, tell the spooler to pick up next cycle
    // or start a cycle...
    if (fSendImmediate)
    {
        Assert(g_pSpooler);
        if (fMail)
            g_pSpooler->StartDelivery(hwnd, NULL, FOLDERID_INVALID,
                DELIVER_BACKGROUND | DELIVER_QUEUE | DELIVER_MAIL_SEND | DELIVER_NOSKIP);
        else
        {
            PROPVARIANT         var;

            var.vt = VT_LPSTR;
            hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
            if (FAILED(hr))
                var.pszVal = NULL;

            if (S_OK == g_pConMan->CanConnect(var.pszVal))
                g_pSpooler->StartDelivery(hwnd, var.pszVal, FOLDERID_INVALID,
                    DELIVER_BACKGROUND | DELIVER_NOSKIP | DELIVER_NEWS_SEND);
            else
            {
                // Warn the user that this message is going to live in their
                // outbox for all of eternity
                DoDontShowMeAgainDlg(hwnd, c_szDSPostInOutbox, 
                            MAKEINTRESOURCE(idsPostNewsMsg), 
                            MAKEINTRESOURCE(idsPostInOutbox), 
                            MB_OK);
                hr = S_FALSE;
            }
            SafeMemFree(var.pszVal);
        }
    }
    else if (!fNoUI)
    {
        HWND hwnd = 0;
        pStoreCB->GetParentWindow(0, &hwnd);

        AssertSz(hwnd, "How did we not get an hwnd???");

        // warn the user, before we close if it will be stacked in the outbox.
        DoDontShowMeAgainDlg(hwnd, fMail?c_szDSSendMail:c_szDSSendNews, 
                    MAKEINTRESOURCE(fMail?idsSendMail:idsPostNews), 
                    MAKEINTRESOURCE(fMail?idsMailInOutbox:idsPostInOutbox), 
                    MB_OK);
    }

error:
    // Cleanup
    g_pStore->FreeRecord(&Outbox);
    return hr;
}

HRESULT HrSetSenderInfoUtil(IMimeMessage *pMsg, IImnAccount *pAccount, LPWABAL lpWabal, BOOL fMail, CODEPAGEID cpID, BOOL fCheckConflictOnly)
{
    HRESULT hr = S_OK;

    // Don't set any info if no account.
    if (pAccount)
    {
        char    szEMail[CCHMAX_EMAIL_ADDRESS] = "";
        char    szName[CCHMAX_DISPLAY_NAME] = "";
        char    szOrg[CCHMAX_ORG_NAME] = "";
        BOOL    fUseEmailAsName = FALSE;
        DWORD   propID;

        if (fCheckConflictOnly)
        {
            hr = S_OK;
            propID = fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szName, ARRAYSIZE(szName))) && *szName)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCPA(szName, CP_ACP, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }

            propID = fMail ? AP_SMTP_ORG_NAME : AP_NNTP_ORG_NAME;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szOrg, ARRAYSIZE(szOrg))) && *szOrg)
            {
                IF_FAILEXIT(hr = HrSafeToEncodeToCPA(szOrg, CP_ACP, cpID));
                if (MIME_S_CHARSET_CONFLICT == hr)
                    goto exit;
            }
        }
        else
        {
            hr = hrNoSender;
            lpWabal->DeleteRecipType(MAPI_REPLYTO);

            propID = fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szEMail, ARRAYSIZE(szEMail))) && *szEMail)
            {
                propID = fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME;
                // we've got enough to post
                if (FAILED(pAccount->GetPropSz(propID, szName, ARRAYSIZE(szName))) && *szName)
                    fUseEmailAsName = TRUE;

                IF_FAILEXIT(hr = lpWabal->HrAddEntryA(fUseEmailAsName?szEMail:szName, szEMail, MAPI_ORIG));
            }

            propID = fMail ? AP_SMTP_REPLY_EMAIL_ADDRESS : AP_NNTP_REPLY_EMAIL_ADDRESS;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szEMail, ARRAYSIZE(szEMail))) && *szEMail)
                IF_FAILEXIT(hr = lpWabal->HrAddEntryA((*szName)?szName:szEMail, szEMail, MAPI_REPLYTO));

            propID = fMail ? AP_SMTP_ORG_NAME : AP_NNTP_ORG_NAME;
            if (SUCCEEDED(pAccount->GetPropSz(propID, szOrg, ARRAYSIZE(szOrg))) && *szOrg)
            {
                MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_ORG), NOFLAGS, szOrg);
            }
        }
    }

exit:
    return hr;
}

// This function takes an existing refererences line and appends a new
// references to the end removing any references necessary.
// NOTE these SHOULD be char and not TCHAR.
HRESULT HrCreateReferences(LPWSTR pszOrigRefs, LPWSTR pszNewRef,
                           LPWSTR *ppszRefs)
{
    UINT     cch,
             cchOrig,
             cchNew;

    // Validate the arguements
    if (!pszNewRef || !*pszNewRef)
    {
        AssertSz(FALSE, TEXT("pszNewRef cannot be empty."));
        return (E_INVALIDARG);
    }

    // Figure out how long the new references line must be
    cchNew = lstrlenW(pszNewRef);

    // It's possible not to have original references if this is the first
    // reply to an article.
    if (pszOrigRefs && *pszOrigRefs)
        cchOrig = lstrlenW(pszOrigRefs);
    else
        cchOrig = 0;

    cch = cchNew + cchOrig + 1; // extra is for the separator space

    if (!MemAlloc((LPVOID*) ppszRefs, (cch + 1)*sizeof(WCHAR)))
        return (E_OUTOFMEMORY);

    // The line length should be < 1000 chars. If it is, this is simple
    if (cch <= 1000)
    {
        if (pszOrigRefs)
            wnsprintfW(*ppszRefs, cch+1, L"%s %s", pszOrigRefs, pszNewRef);
        else
            StrCpyNW(*ppszRefs, pszNewRef, cch+1);
    }

    // Since cch > 1000, we have some extra work to do.
    // We need to remove some references. The Son-of-1036 recommends to leave
    // the first and last three. Unless the IDs are greater than 255, we will 
    // be able to do at least this. Otherwise, we will dump as many ids as 
    // needed to get below the 1000 char limit. 

    // For each ID removed, the Son-of-1036 says that we must add 3 spaces in
    // place of the removed ID.
    else
    {
        UINT    cchMaxWithoutNewRef,        // Max length that the orig size can be
                cchNewOrigSize = cchOrig;   // Size of orig after deletion. Always shows final size
        LPWSTR  pszNew = *ppszRefs, 
                pszOld = pszOrigRefs;
        BOOL    fCopiedFirstValidID = FALSE;

        *pszNew = 0;

        // Make sure the new ID is not too long. If it is, discard it.
        if (cchNew > 255)
        {
            cchNew = 0;
            cchMaxWithoutNewRef = 1000;
        }
        else
            cchMaxWithoutNewRef = 1000 - cchNew - 1; // the space between

        // parse the old string looking for ids
        // Son-of-1036 says that we must try to keep the first and the most recent
        // three IDs. So we will copy in the first valid ID and then follow a FIFO
        // algorithm until we can fit the rest of the IDs into the 1000 char limit
        while (pszOld && *pszOld)
        {
            // Is what is left from the original string too big for the left over buffer?
            if (cchNewOrigSize >= cchMaxWithoutNewRef)
            {
                UINT    cchEntryLen = 0;    // Size of particular entry ID.

                // If this is the first ID, make sure we copy into the buffer as we 
                // get length, as well, add the additional spaces required when any 
                // deletion will be happening. Since we only delete directly after 
                // the first valid ID, add the required 3 spaces now
                if (!fCopiedFirstValidID)
                {
                    while (*pszOld && *pszOld != L' ')
                    {
                        *pszNew++ = *pszOld++;
                        cchEntryLen++;
                    }
                    *pszNew++ = L' ';
                    *pszNew++ = L' ';
                    *pszNew++ = L' ';
                    cchNewOrigSize += 3;
                    cchEntryLen += 3;
                }
                // If this in not the first ID, then just skip over it.
                else
                {
                    while (*pszOld && *pszOld != L' ')
                    {
                        pszOld++;
                        cchEntryLen++;
                    }
                }

                // Skip over whitespace in old references between IDs that
                // we are deleting anyway.
                while (*pszOld == L' ')
                {
                    pszOld++;
                    cchNewOrigSize--;
                }

                // If we already did the first, or the current one is invalid
                // we need to do some fix up with sizes. And in the case that
                // we copied one that is not valid, we need to reset the pointer
                // as well as reset the size.
                if (fCopiedFirstValidID || (cchEntryLen > 255))
                {
                    cchNewOrigSize -= cchEntryLen;

                    // Did we copy an invalid ID?
                    if (!fCopiedFirstValidID)
                        pszNew -= cchEntryLen;
                }

                // If we haven't copied the first one in yet and this
                // ID is valid, then remember that we have at this
                // point copied the first valid ID.
                if (!fCopiedFirstValidID && (cchEntryLen <= 255))
                    fCopiedFirstValidID = TRUE;
            }
            else
            {
                // Since we now have a orig string that will fit in the max allowed, 
                // just rip through the rest of the orig string and copy.
                while (*pszOld)
                    *pszNew++ = *pszOld++;
            }
        }

        // At this point, pszNew should be pointing the the char directly after
        // the last digit. If we add a new reference, then we need to add a space.
        // If we don't add a new reference, then we need to null terminate the string.
        if (cchNew)
        {
            // With this assignment, we can end up with 4 spaces in a row if we 
            // deleted all references after the first valid one was copied. The
            // son-of-1036 only specifies minimum of 3 spaces when deleting, so
            // we will be OK with that, especially since the only way to get into
            // this situation is by forcing the references line into a strange state.
            *pszNew++ = L' ';
            pszOld = pszNewRef;
            while (*pszOld)
                *pszNew++ = *pszOld++;
        }

        // NULL terminate the string of references.
        *pszNew = 0;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mehost.h ===
#ifndef __MEHOST_H
#define __MEHOST_H

#include "ibodyobj.h"
#include "mshtmhst.h"
#include "secutil.h"

// WM_NOTIFY messages sent to the parent
#define BDN_FIRST               (9000)
#define BDN_HEADERDBLCLK        (BDN_FIRST + 1)
#define BDN_DOWNLOADCOMPLETE    (BDN_FIRST + 2)
#define BDN_MARKASSECURE        (BDN_FIRST + 3)

#define MAX_DATA_MESSAGES       3
#define C_RGBCOLORS 16

extern const DWORD rgrgbColors16[C_RGBCOLORS];

class CMimeEditDocHost:
    public IOleInPlaceFrame,
    public IOleInPlaceSite,
    public IOleClientSite,
    public IOleControlSite,
    public IOleDocumentSite,
    public IOleCommandTarget,
    public IBodyObj2,
    public IDocHostUIHandler,
    public IPropertyNotifySink,
    public IPersistMime,
    public IDispatch
{
public:
    // IUnknown methods
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleWindow methods
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // IOleInPlaceUIWindow methods
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR);

    // IOleInPlaceFrame methods
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);

    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

    // IOleControlSite
    virtual HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
    virtual HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
    virtual HRESULT STDMETHODCALLTYPE GetExtendedControl(LPDISPATCH *ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *lpMsg,DWORD grfModifiers);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    virtual HRESULT STDMETHODCALLTYPE ShowPropertyFrame(void);

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IBodyObj2
    virtual HRESULT STDMETHODCALLTYPE HrUpdateFormatBar();
    virtual HRESULT STDMETHODCALLTYPE HrClearFormatting();
    virtual HRESULT STDMETHODCALLTYPE HrInit(HWND hwndParent, DWORD dwFlags, IBodyOptions *pBodyOptions);
    virtual HRESULT STDMETHODCALLTYPE HrClose();
    virtual HRESULT STDMETHODCALLTYPE HrResetDocument();
    virtual HRESULT STDMETHODCALLTYPE HrSetStatusBar(CStatusBar *pStatus);
    virtual HRESULT STDMETHODCALLTYPE HrUpdateToolbar(HWND hwndToolbar);
    virtual HRESULT STDMETHODCALLTYPE HrShow(BOOL fVisible);
    virtual HRESULT STDMETHODCALLTYPE HrOnInitMenuPopup(HMENU hmenuPopup, UINT uID);
    virtual HRESULT STDMETHODCALLTYPE HrWMMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam);
    virtual HRESULT STDMETHODCALLTYPE HrWMDrawMenuItem(HWND hwnd, LPDRAWITEMSTRUCT pdis);
    virtual HRESULT STDMETHODCALLTYPE HrWMMeasureMenuItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis);
    virtual HRESULT STDMETHODCALLTYPE HrWMCommand(HWND hwnd, int id, WORD wCmd);
    virtual HRESULT STDMETHODCALLTYPE HrGetWindow(HWND *pHwnd);
    virtual HRESULT STDMETHODCALLTYPE HrSetSize(LPRECT prc);
    virtual HRESULT STDMETHODCALLTYPE HrSetNoSecUICallback(DWORD dwCookie, PFNNOSECUI pfnNoSecUI);
    virtual HRESULT STDMETHODCALLTYPE HrSetDragSource(BOOL fIsSource);
    virtual HRESULT STDMETHODCALLTYPE HrTranslateAccelerator(LPMSG lpMsg);
    virtual HRESULT STDMETHODCALLTYPE HrUIActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE HrSetUIActivate();
    virtual HRESULT STDMETHODCALLTYPE HrFrameActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE HrHasFocus();
    virtual HRESULT STDMETHODCALLTYPE HrSetBkGrndPicture(LPTSTR pszPicture);
    virtual HRESULT STDMETHODCALLTYPE GetTabStopArray(HWND *rgTSArray, int *pcArrayCount);
    virtual HRESULT STDMETHODCALLTYPE PublicFilterDataObject(IDataObject *pDO, IDataObject **ppDORet);
    virtual HRESULT STDMETHODCALLTYPE HrSaveAttachment();
    virtual HRESULT STDMETHODCALLTYPE SetEventSink(IMimeEditEventSink *pEventSink);
    virtual HRESULT STDMETHODCALLTYPE LoadHtmlErrorPage(LPCSTR pszURL);

    virtual HRESULT STDMETHODCALLTYPE HrSpellCheck(BOOL fSuppressDoneMsg);
    virtual HRESULT STDMETHODCALLTYPE HrIsDirty(BOOL *pfDirty);
    virtual HRESULT STDMETHODCALLTYPE HrSetDirtyFlag(BOOL fDirty);
    virtual HRESULT STDMETHODCALLTYPE HrIsEmpty(BOOL *pfEmpty);
    virtual HRESULT STDMETHODCALLTYPE HrUnloadAll(UINT idsDefaultBody, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE HrSetStyle(DWORD dwStyle);
    virtual HRESULT STDMETHODCALLTYPE HrGetStyle(DWORD *pdwStyle);
    virtual HRESULT STDMETHODCALLTYPE HrEnableHTMLMode(BOOL fOn);
    virtual HRESULT STDMETHODCALLTYPE HrDowngradeToPlainText();
    virtual HRESULT STDMETHODCALLTYPE HrSetText(LPSTR lpsz);
    virtual HRESULT STDMETHODCALLTYPE HrPerformROT13Encoding();
    virtual HRESULT STDMETHODCALLTYPE HrInsertTextFile(LPSTR lpsz);
    virtual HRESULT STDMETHODCALLTYPE HrInsertTextFileFromDialog();
    virtual HRESULT STDMETHODCALLTYPE HrViewSource(DWORD dwViewType);
    virtual HRESULT STDMETHODCALLTYPE HrSetPreviewFormat(LPSTR lpsz);
    virtual HRESULT STDMETHODCALLTYPE HrSetEditMode(BOOL fOn);
    virtual HRESULT STDMETHODCALLTYPE HrIsEditMode(BOOL *pfOn);
    virtual HRESULT STDMETHODCALLTYPE HrSetCharset(HCHARSET hCharset);
    virtual HRESULT STDMETHODCALLTYPE HrGetCharset(HCHARSET *phCharset);
    virtual HRESULT STDMETHODCALLTYPE HrSaveAsStationery(LPWSTR pwszFile);
    virtual HRESULT STDMETHODCALLTYPE HrApplyStationery(LPWSTR pwszFile);
    virtual HRESULT STDMETHODCALLTYPE HrHandsOffStorage();
    virtual HRESULT STDMETHODCALLTYPE HrRefresh();
    virtual HRESULT STDMETHODCALLTYPE HrScrollPage();
    virtual HRESULT STDMETHODCALLTYPE UpdateBackAndStyleMenus(HMENU hmenu);


    // IDocHostUIHandler methods
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu(
                DWORD dwID, 
                POINT *ppt, 
                IUnknown *pcmdtReserved, 
                IDispatch *pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI(
                DWORD dwID, 
                IOleInPlaceActiveObject *pActiveObject, 
                IOleCommandTarget *pCommandTarget, 
                IOleInPlaceFrame *pFrame,
                IOleInPlaceUIWindow *pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI();
    virtual HRESULT STDMETHODCALLTYPE UpdateUI();
    //This function is already listed above
    //virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDispatch);
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject( IDataObject *pDO, IDataObject **ppDORet);

    // IPropertyNotifySink
    virtual HRESULT STDMETHODCALLTYPE OnChanged(DISPID dispid);
    virtual HRESULT STDMETHODCALLTYPE OnRequestEdit (DISPID dispid);

    // IPersistMime
    virtual HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE pMsg);
    virtual HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE pMsg, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IDispatch methods
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);

    CMimeEditDocHost(DWORD dwBorderFlags = MEBF_OUTERCLIENTEDGE);
    virtual ~CMimeEditDocHost();
    
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    virtual void OnDocumentReady();

    HRESULT CreateDocObj(LPCLSID pCLSID);
    HRESULT CloseDocObj();

    virtual HRESULT HrLoadURL(LPCSTR pszURL);
    virtual HRESULT HrEnableScrollBars(BOOL fEnable);

    // statics
    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    static HRESULT HrMEDocHost_Init(BOOL fInit);

protected:
    HWND                        m_hwnd,
                                m_hwndDocObj;
    DWORD                       m_dwBorderFlags,
                                m_dwStyle,
                                m_dwHTMLNotifyCookie;
    BOOL                        m_fDownloading              : 1,
                                m_fUIActive                 : 1,
                                m_fMarkedRead               : 1,
                                m_fBlockingOnSMime          : 1,
                                m_fIsEncrypted              : 1,
                                m_fIsSigned                 : 1,
                                m_fSignTrusted              : 1,
                                m_fEncryptionOK             : 1,
                                m_fRegisteredForDocEvents   : 1,
                                m_fShowingErrorPage         : 1,
                                m_fFixedFont                : 1,
                                m_fSecDispInfo              : 1,
                                m_fSecureReceipt            : 1;
    CStatusBar                 *m_pStatus;
    IBodyOptions               *m_pBodyOptions;
    IHTMLDocument2             *m_pDoc;
    IUnknown                   *m_pUnkService;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
    LPOLEOBJECT                 m_lpOleObj;
    LPOLECOMMANDTARGET          m_pCmdTarget;
    LPPERSISTMIME               m_pPrstMime;
    LPOLEDOCUMENTVIEW           m_pDocView;
    LPMIMEMESSAGE               m_pMsg,
                                m_pSecureMessage,
                                m_pSecurityErrorScreen;
    IMimeEditEventSink         *m_pEventSink;

    virtual HRESULT OnUpdateCommands();
    virtual HRESULT HrPasteToAttachment();
    virtual void WMSize(int x, int y);
    virtual void OnWMSize(LPRECT prc){};
    virtual BOOL WMCommand(HWND, int, WORD);
    virtual BOOL WMNotify(int idFrom, NMHDR *pnmh);
    virtual HRESULT HrPostInit();
    virtual HRESULT HrSubWMCreate() {Assert(FALSE); return NOERROR;}
    virtual HRESULT HrOnDocObjCreate();
    BOOL WMCreate(HWND hwnd);
    void WMNCDestroy();
    HRESULT HrMarkAsRead();
    void OnWMTimer();

    HRESULT HandleButtonClicks(BSTR bstr);
    HRESULT DoHtmlBtnOpen(void); 
    HRESULT DoHtmlBtnCertTrust(DWORD cmdID);
    HRESULT DoHtmlBtnContinue(void);
    HRESULT InternalLoad(IMimeMessage *pMsg);
    HRESULT LoadSecurely(IMimeMessage *pMsg, SECSTATE *pSecState);
    HRESULT ViewCertificate(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg);
    HRESULT EditTrust(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg);

    HRESULT RegisterForHTMLDocEvents(BOOL fOn);

    HRESULT ExecCommand(const GUID *guid, DWORD cmd);
    HRESULT ExecGetBool(const GUID *guid, DWORD cmd, BOOL *pfValue);
    HRESULT ExecSetBool(const GUID *guid, DWORD cmd, BOOL fValue);
    HRESULT ExecGetI4(const GUID *guid, DWORD cmd, DWORD *pdwValue);
    HRESULT ExecSetI4(const GUID *guid, DWORD cmd, DWORD dwValue);
    HRESULT ExecGetI8(const GUID *guid, DWORD cmd, ULONGLONG *pullValue);
    HRESULT ExecSetI8(const GUID *guid, DWORD cmd, ULONGLONG ullValue);
    HRESULT ExecGetText(const GUID *guid, DWORD cmd, LPSTR *ppsz);
    HRESULT ExecSetText(const GUID *guid, DWORD cmd, LPSTR psz);
    HRESULT ExecGetTextW(const GUID *guid, DWORD cmd, LPWSTR *ppwsz);
    HRESULT ExecSetTextW(const GUID *guid, DWORD cmd, LPWSTR pwsz);

    HRESULT Show();
    HRESULT HrRegisterLoadNotify(BOOL fRegister);
    HRESULT HrRegisterNotify(BOOL fRegister, LPCTSTR szElement, REFIID riidSink, IUnknown *pUnkSink, DWORD *pdwCookie);
    HRESULT HrAddToFavorites(BSTR bstrDescr, BSTR bstrURL);
    HRESULT HrAddToWab(BSTR bstr);
    HRESULT HrGetElement(LPCTSTR pszName, IHTMLElement **ppElem);

private:
    ULONG           m_cRef;
    DWORD           m_dwDocStyle;
    HMENU           m_hmenuColor,
                    m_hmenuStyle;

    HRESULT HrPrint(BOOL fPrompt);
    HRESULT HrBackgroundImage();
    HRESULT HrBackgroundSound();

    void UpdateInsertMenu(HMENU hmenu);
    void UpdateEditMenu(HMENU hmenu);
    void UpdateViewMenu(HMENU hmenu);
    void EnableStandardCmd(UINT idm, LPBOOL pbEnable);

    HRESULT HrInsertSignature(int id);
    HRESULT HrCheckColor();
    HRESULT CreateDocView();

    HRESULT OnCreate(HWND hwnd);
    HRESULT OnNCDestroy();
    HRESULT OnDestroy();
    void OnReadyStateChanged();
    HRESULT HrIsHTMLMode();
    HRESULT CycleSrcTabs(BOOL fFwd);

    HRESULT QuerySingleMimeEditCmd(ULONG uCmd, ULONG *pcmf);
    HRESULT QuerySingleFormsCmd(ULONG uCmd, ULONG *pcmf);
    HRESULT QuerySingleStdCmd(ULONG uCmd, ULONG *pcmf);
};


typedef CMimeEditDocHost MIMEEDITDOCHOST;
typedef MIMEEDITDOCHOST *LPMIMEEDITDOCHOST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\mehost.cpp ===
#include "pch.hxx"
#include <docobj.h>
#include "dllmain.h"
#include "strconst.h"
#include "msoert.h"
#include "mimeole.h"
#include "mehost.h"
#include "oleutil.h"
#include "ibodyopt.h"
#include "resource.h"
#include "mshtmcid.h"
#include "thormsgs.h"
#include "msoeprop.h"
#include "goptions.h"
#include "bodyutil.h"
#include "mimeutil.h"
#include "ourguid.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "ipab.h"
#include "statnery.h"
#include "options.h"
#include "sigs.h"
#include "fonts.h"
#include "url.h"
#include "secutil.h"
#include "sechtml.h"
#include "mimeolep.h"
#include "menuutil.h"
#include "htmlhelp.h"
#include "msgprop.h"
#include "demand.h"
#include <mshtmdid.h>
#include "menures.h"
#include "multiusr.h"
#include "fontnsc.h"

const int   idTimerMarkAsRead   = 100;
const TCHAR c_szSigPrefix[]     = "\r\n-- \r\n";

#define MAKEINDEX(b, l) (((DWORD)l & 0x00ffffff) | ((DWORD)b << 24))
#define GETINDEX(m) (((m & 0xff000000) >> 24) & 0x000000ff)

ASSERTDATA
static const WCHAR  c_wszMailTo[]  = L"mailto:",
                    c_wszHttp[]  = L"http://",
                    c_wszFile[]  = L"file://";

const DWORD rgrgbColors16[16] = {
    RGB(  0,   0, 0),     // "BLACK"},
    RGB(128,   0, 0),     // "MAROON"},
    RGB(  0, 128, 0),     // "GREEN"},
    RGB(128, 128, 0),     // "OLIVE"},
    RGB(  0,   0, 128),   // "NAVY"},
    RGB(128,   0, 128),   // "PURPLE"},
    RGB(  0, 128, 128),   // "TEAL"},
    RGB(128, 128, 128),   // "GREY"},
    RGB(192, 192, 192),   // "SILVER"},
    RGB(255,   0, 0),     // "RED"},
    RGB(  0, 255, 0),     // "LIME"},
    RGB(255, 255, 0),     // "YELLOW"},
    RGB(  0,   0, 255),   // "BLUE"},
    RGB(255,   0, 255),   // "FUSCHIA"},
    RGB(  0, 255, 255),   // "AQUA"},
    RGB(255, 255, 255)    // "WHITE"}
};

INT_PTR CALLBACK BkImageDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int                 id;
    LPWSTR              pwszURL;
    HWND                hwndCombo = GetDlgItem(hwnd, idTxtBkImage);
    LRESULT             lr=0;
    HRESULT             hr;

    pwszURL = (LPWSTR)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(msg)
    {
        case WM_INITDIALOG:
            Assert(lParam!= NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)lParam);
            SetIntlFont(hwndCombo);
            SendDlgItemMessage(hwnd, idTxtBkImage, EM_LIMITTEXT, MAX_PATH-1, NULL);
            SetFocus(hwndCombo);
            pwszURL = (LPWSTR)lParam;

            HrFillStationeryCombo(hwndCombo, TRUE, pwszURL);
            StripStationeryDir(pwszURL);
            SetWindowTextWrapW(hwndCombo, pwszURL);
            SendMessage(GetWindow(hwndCombo, GW_CHILD), EM_SETSEL, 0, -1);
            CenterDialog(hwnd);
            return FALSE;

        case WM_COMMAND:
            switch(id=GET_WM_COMMAND_ID(wParam, lParam))
            {
                case idBrowsePicture:
                    HrBrowsePicture(hwnd, GetDlgItem(hwnd, idTxtBkImage));
                    break;

                case IDOK:
                    Assert(pwszURL);
                    SendMessageWrapW(hwndCombo, CB_GETLBTEXT, (WPARAM)(SendMessage(hwndCombo, CB_GETCURSEL, 0, 0)), (LPARAM)(pwszURL));

                    // fall thro'
                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            }
    }
    return FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost
//
//  Synopsis:
//
//---------------------------------------------------------------
CMimeEditDocHost::CMimeEditDocHost(DWORD dwBorderFlags)
{
    m_hwnd = 0; 
    m_hwndDocObj = 0; 

    m_cRef = 1; 

    m_dwStyle = 0;
    m_dwHTMLNotifyCookie = 0; 
    m_dwBorderFlags = dwBorderFlags; 
    m_dwDocStyle = MESTYLE_NOHEADER; 

    m_fUIActive = FALSE; 
    m_fIsSigned = FALSE;
    m_fFixedFont = FALSE;
    m_fMarkedRead = FALSE; 
    m_fSignTrusted = TRUE; 
    m_fIsEncrypted = FALSE; 
    m_fSecDispInfo = FALSE;
    m_fSecureReceipt = FALSE;
    m_fEncryptionOK = TRUE; 
    m_fBlockingOnSMime = FALSE; 
    m_fShowingErrorPage = FALSE;
    m_fRegisteredForDocEvents = FALSE; 

    m_pDoc = NULL; 
    m_pMsg = NULL; 
    m_pStatus = NULL;
    m_pDocView = NULL;
    m_lpOleObj = NULL; 
    m_pPrstMime = NULL; 
    m_pCmdTarget = NULL; 
    m_hmenuColor = NULL; 
    m_hmenuStyle = NULL; 
    m_pEventSink = NULL; 
    m_pUnkService = NULL;
    m_pBodyOptions = NULL; 
    m_pSecureMessage = NULL; 
    m_pInPlaceActiveObj = NULL; 
    m_pSecurityErrorScreen = NULL;
}

//+---------------------------------------------------------------
//
//  Member:
//
//  Synopsis:
//
//---------------------------------------------------------------
CMimeEditDocHost::~CMimeEditDocHost()
{
    // These should all get feed up when we get a WM_DESTROY and close the docobj
    Assert(m_lpOleObj==NULL);
    Assert(m_pDocView==NULL);
    Assert(m_pInPlaceActiveObj==NULL);
    Assert(m_pCmdTarget==NULL);
    Assert(m_pPrstMime==NULL);
    Assert(m_pMsg==NULL);
    Assert(m_pSecurityErrorScreen==NULL);
    Assert(m_pSecureMessage==NULL);

    if(m_hmenuColor)
        DestroyMenu(m_hmenuColor);

    if(m_hmenuStyle)
        DestroyMenu(m_hmenuStyle);

}

//+---------------------------------------------------------------
//
//  Member:     AddRef
//
//  Synopsis:
//
//---------------------------------------------------------------
ULONG CMimeEditDocHost::AddRef()
{
    TraceCall("CMimeEditDocHost::AddRef");

    //TraceInfo(_MSG("CMimeEditDocHost::AddRef: cRef==%d", m_cRef+1));
    return ++m_cRef;
}

//+---------------------------------------------------------------
//
//  Member:     Release
//
//  Synopsis:
//
//---------------------------------------------------------------
ULONG CMimeEditDocHost::Release()
{
    TraceCall("CMimeEditDocHost::Release");

    //TraceInfo(_MSG("CMimeEditDocHost::Release: cRef==%d", m_cRef-1));
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


//+---------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CMimeEditDocHost::QueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *lplpObj = (LPVOID)(IOleInPlaceUIWindow *)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *lplpObj = (LPVOID)(LPOLEINPLACESITE)this;

    else if (IsEqualIID(riid, IID_IOleClientSite))
        *lplpObj = (LPVOID)(LPOLECLIENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleControlSite))
        *lplpObj = (LPVOID)(IOleControlSite *)this;

    else if (IsEqualIID(riid, IID_IAdviseSink))
        *lplpObj = (LPVOID)(LPADVISESINK)this;

    else if (IsEqualIID(riid, IID_IOleDocumentSite))
        *lplpObj = (LPVOID)(LPOLEDOCUMENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IDocHostUIHandler))
        *lplpObj = (LPVOID)(IDocHostUIHandler*)this;

    else if (IsEqualIID(riid, IID_IBodyObj2))
        *lplpObj = (LPVOID)(IBodyObj2*)this;

    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(IPersistMime*)this;

    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch*)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     ExtWndProc
//
//  Synopsis:
//
//---------------------------------------------------------------
LRESULT CALLBACK CMimeEditDocHost::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMimeEditDocHost *pDocHost;

    if (WM_CREATE == msg)
    {
        pDocHost = (CMimeEditDocHost *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pDocHost)
            return -1;

        if(FAILED(pDocHost->OnCreate(hwnd)))
            return -1;
    }
    pDocHost = (CMimeEditDocHost *)GetWndThisPtr(hwnd);
    if(pDocHost)
        return pDocHost->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member:     WndProc
//
//  Synopsis:
//
//---------------------------------------------------------------
LRESULT CMimeEditDocHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_PAINT:
            if (!m_lpOleObj)
            {
                HDC         hdc;
                PAINTSTRUCT ps;
                RECT        rc;
                HBRUSH      hBrush;

                GetClientRect(m_hwnd, &rc);
                hdc = BeginPaint(hwnd, &ps);
                hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
                PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
                SelectBrush(hdc, hBrush);
                EndPaint(hwnd, &ps);
                return 0;
            }

        case WM_COMMAND:
            if(WMCommand(   GET_WM_COMMAND_HWND(wParam, lParam),
                            GET_WM_COMMAND_ID(wParam, lParam),
                            GET_WM_COMMAND_CMD(wParam, lParam)))
                return 0;
            break;

        case WM_SETFOCUS:
            return OnFocus(TRUE);

        case WM_KILLFOCUS:
            return OnFocus(FALSE);

        case WM_NOTIFY:
            return WMNotify((int) wParam, (NMHDR *)lParam);

        case WM_SIZE:
            WMSize(LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_CLOSE:
            return 0;   // prevent alt-f4's

        case WM_NCDESTROY:
            WMNCDestroy();
            break;

        case WM_TIMER:
            if (wParam == idTimerMarkAsRead)
            {
                OnWMTimer();
                return 0;
            }
            break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
           if (m_hwndDocObj)
                return SendMessage(m_hwndDocObj, msg, wParam, lParam);
            break;
    }

    return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

BOOL CMimeEditDocHost::WMCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)this);
    AddRef();

    return SUCCEEDED(HrSubWMCreate())?TRUE:FALSE;
}

void CMimeEditDocHost::WMNCDestroy()
{
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
}


//+---------------------------------------------------------------
//
//  Member:     OnNCDestroy
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnNCDestroy()
{
    TraceCall("CMimeEditDocHost::OnNCDestroy");
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnDestroy
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnDestroy()
{
    TraceCall("CMimeEditDocHost::OnDestroy");

    return CloseDocObj();
}


//+---------------------------------------------------------------
//
//  Member:     OnCreate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnCreate(HWND hwnd)
{
    TraceCall("CMimeEditDocHost::OnCreate");

    m_hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)this);
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CreateDocObj
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CreateDocObj(LPCLSID pCLSID)
{
    HRESULT hr=NOERROR;

    TraceCall("CMimeEditDocHost::CreateDocObj");

    if(!pCLSID)
        return E_INVALIDARG;

    Assert(!m_lpOleObj);
    Assert(!m_pDocView);
    Assert(!m_pCmdTarget);

    hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                        IID_IOleObject, (LPVOID *)&m_lpOleObj);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->SetClientSite((LPOLECLIENTSITE)this);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pCmdTarget);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IPersistMime, (LPVOID *)&m_pPrstMime);
    if (FAILED(hr))
        goto error;

    hr = HrInitNew(m_lpOleObj);

error:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     Show
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::Show()
{
    RECT    rc;
    HRESULT hr;

    TraceCall("CMimeEditDocHost::Show");

    GetClientRect(m_hwnd, &rc);

    hr=m_lpOleObj->DoVerb(OLEIVERB_SHOW, NULL, (LPOLECLIENTSITE)this, 0, m_hwnd, &rc);
    if(FAILED(hr))
        goto error;
error:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     CloseDocObj
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CloseDocObj()
{
    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    RegisterForHTMLDocEvents(FALSE);

    SafeRelease(m_pCmdTarget);
    SafeRelease(m_pPrstMime);
    SafeRelease(m_pInPlaceActiveObj);
    SafeRelease(m_pDoc);
    SafeRelease(m_pMsg);
    SafeRelease(m_pSecureMessage);
    SafeRelease(m_pSecurityErrorScreen);
    SafeRelease(m_pEventSink);
    SafeRelease(m_pStatus);

    if(m_pDocView)
    {
        m_pDocView->UIActivate(FALSE);
        m_pDocView->CloseView(0);
        m_pDocView->SetInPlaceSite(NULL);
        m_pDocView->Release();
        m_pDocView=NULL;
    }

    if (m_lpOleObj)
    {
        // deactivate the docobj
        if (!FAILED(m_lpOleObj->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&pInPlaceObj)))
        {
            pInPlaceObj->InPlaceDeactivate();
            pInPlaceObj->Release();
        }

        // close the ole object, but blow off changes as we have either extracted
        // them ourselves or don't care.
        m_lpOleObj->Close(OLECLOSE_NOSAVE);
#ifdef DEBUG
        ULONG   uRef;
        uRef=
#endif
        m_lpOleObj->Release();
        m_lpOleObj=NULL;
        AssertSz(uRef==0, "We leaked a docobject!");
    }

    m_fUIActive=FALSE;
    return NOERROR;
}

// Close DocObj
HRESULT CMimeEditDocHost::HrResetDocument()
{
    CloseDocObj();
    CreateDocObj((LPCLSID)&CLSID_MimeEdit);
    CreateDocView();
    return(S_OK);
}

// *** IOleWindow ***

//+---------------------------------------------------------------
//
//  Member:     GetWindow
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetWindow(HWND *phwnd)
{
    TraceCall("CMimeEditDocHost::GetWindow");
    *phwnd=m_hwnd;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     ContextSensitiveHelp
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CMimeEditDocHost::ContextSensitiveHelp");
    return E_NOTIMPL;
}

// *** IOleInPlaceUIWindow methods ***
//+---------------------------------------------------------------
//
//  Member:     GetBorder
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetBorder(LPRECT lprectBorder)
{
    TraceCall("CMimeEditDocHost::GetBorder");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestBorderSpace
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    TraceCall("CMimeEditDocHost::RequestBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetBorderSpace
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceUIWindow::SetBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetActiveObject
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceUIWindow::SetActiveObject");

    ReplaceInterface(m_pInPlaceActiveObj, pActiveObject);
    return S_OK;
}

    // *** IOleInPlaceFrame methods ***

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::InsertMenus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS)
{
    TraceCall("CMimeEditDocHost::InsertMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::SetMenu
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetMenu(HMENU, HOLEMENU, HWND)
{
    TraceCall("CMimeEditDocHost::SetMenu");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::RemoveMenus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::RemoveMenus(HMENU)
{
    TraceCall("CMimeEditDocHost::RemoveMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CMimeEditDocHost::SetStatusText
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SetStatusText(LPCOLESTR pszW)
{
    TCHAR   rgch[CCHMAX_STRINGRES];

    TraceCall("CMimeEditDocHost::SetStatusText");

    if(!m_pStatus)
        return E_NOTIMPL;

    *rgch=0;
    if(pszW && WideCharToMultiByte(CP_ACP, 0, pszW, -1, rgch, ARRAYSIZE(rgch), NULL, NULL))
        m_pStatus->ShowSimpleText(rgch);

    if(*rgch==0)
        m_pStatus->HideSimpleText();

    DOUTL(64, "IOleInPlaceFrame::SetStatusText:'%s'", rgch);
    return NOERROR;
}

HRESULT CMimeEditDocHost::TranslateAccelerator(LPMSG, WORD)
{
    return E_NOTIMPL;
}


// **** IOleInPlaceSite methods ****

//+---------------------------------------------------------------
//
//  Member:     CanInPlaceActivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CanInPlaceActivate()
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::CanInPlaceActivate");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceActivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnInPlaceActivate()
{
    LPOLEINPLACEACTIVEOBJECT    pInPlaceActive;

    TraceCall("CMimeEditDocHost::OnInPlaceActivate");

    Assert(m_lpOleObj);

    if (m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pInPlaceActive)==S_OK)
    {
        SideAssert((pInPlaceActive->GetWindow(&m_hwndDocObj)==NOERROR)&& IsWindow(m_hwndDocObj));
        pInPlaceActive->Release();
    }

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIActivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnUIActivate()
{
    TraceCall("CMimeEditDocHost::OnUIActivate");
    m_fUIActive=TRUE;

    // Notify our parent that we're the one with the focus now.
    if (m_pEventSink)
        m_pEventSink->EventOccurred(MEHC_UIACTIVATE, NULL);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     GetWindowContext
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetWindowContext( IOleInPlaceFrame    **ppFrame,
                                    IOleInPlaceUIWindow **ppDoc,
                                    LPRECT              lprcPosRect,
                                    LPRECT              lprcClipRect,
                                    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::GetWindowContext");

    *ppFrame = (LPOLEINPLACEFRAME)this;
    AddRef();
    *ppDoc = NULL;

    GetClientRect(m_hwnd, lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     Scroll
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::Scroll(SIZE scrollExtent)
{
    // the docobject consumes the entireview, so scroll requests
    // are meaningless. Return NOERROR to indicate that they're scolled
    // into view.
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::Scroll");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIDeactivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnUIDeactivate(BOOL fUndoable)
{
    TraceCall("CMimeEditDocHost::OnUIDeactivate");
    m_fUIActive=FALSE;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceDeactivate
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnInPlaceDeactivate()
{
    TraceCall("CMimeEditDocHost::OnInPlaceDeactivate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     DiscardUndoState
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::DiscardUndoState()
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::DiscardUndoState");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     DeactivateAndUndo
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::DeactivateAndUndo()
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::DeactivateAndUndo");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnPosRectChange
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnPosRectChange(LPCRECT lprcPosRect)
{
    TraceCall("CMimeEditDocHost::IOleInPlaceSite::OnPosRectChange");
    return E_NOTIMPL;
}


// IOleClientSite methods.

//+---------------------------------------------------------------
//
//  Member:     SaveObject
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::SaveObject()
{
    TraceCall("CMimeEditDocHost::IOleClientSite::SaveObject");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMoniker
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppmnk)
{
    TraceCall("CMimeEditDocHost::IOleClientSite::GetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetContainer
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetContainer(LPOLECONTAINER *ppCont)
{
    TraceCall("CMimeEditDocHost::IOleClientSite::GetContainer");
    if(ppCont)
        *ppCont=NULL;
    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member:     ShowObject
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ShowObject()
{
    // always shown.
    // $TODO: do we need to restore the browser here if it is
    // minimised?
    TraceCall("CMimeEditDocHost::IOleClientSite::ShowObject");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnShowWindow
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnShowWindow(BOOL fShow)
{
    TraceCall("CMimeEditDocHost::IOleClientSite::OnShowWindow");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestNewObjectLayout
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::RequestNewObjectLayout()
{
    TraceCall("CMimeEditDocHost::IOleClientSite::RequestNewObjectLayout");
    return E_NOTIMPL;
}

// IOleDocumentSite

//+---------------------------------------------------------------
//
//  Member:     ActivateMe
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ActivateMe(LPOLEDOCUMENTVIEW pViewToActivate)
{
    TraceCall("CMimeEditDocHost::IOleDocumentSite::ActivateMe");
    return CreateDocView();
}


//+---------------------------------------------------------------
//
//  Member:     CreateDocView
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::CreateDocView()
{
    HRESULT             hr;
    LPOLEDOCUMENT       pOleDoc=NULL;
    IServiceProvider    *pSP;

    TraceCall("CMimeEditDocHost::CreateDocView");
    AssertSz(!m_pDocView, "why is this still set??");
    AssertSz(m_lpOleObj, "uh? no docobject at this point?");

    hr=OleRun(m_lpOleObj);
    if(FAILED(hr))
        goto Exit;

    hr=m_lpOleObj->QueryInterface(IID_IOleDocument, (LPVOID*)&pOleDoc);
    if(FAILED(hr))
        goto Exit;

    hr=pOleDoc->CreateView(this, NULL,0,&m_pDocView);
    if(FAILED(hr))
        goto CleanUp;

    hr=m_pDocView->SetInPlaceSite(this);
    if(FAILED(hr))
        goto CleanUp;

    hr=m_pDocView->Show(TRUE);
    if(FAILED(hr))
        goto CleanUp;

    hr = m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP);
    if (!FAILED(hr))
    {
        hr = pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&m_pDoc);
        pSP->Release();
    }

CleanUp:
    pOleDoc->Release();
Exit:
    return hr;
}

// This must be greater than the most number of IDs that will ever be passed down
// to MimeEdit for any one group within the CMDSETID_OutlookExpress portion of 
// QueryStatus below
const DWORD MAX_MIMEEDIT_CMDS = 20;

// I know this is totally cheesy, but...
// These next macros rely upon variables within the CMDSETID_OutlookExpress
// portion of QueryStatus
#define INC_FORMS(id)       _IncrementCmdList(pCmd, rgCmdForms, rgpCmdForms, &cCmdForms, id)
#define INC_STD(id)         _IncrementCmdList(pCmd, rgCmdStd, rgpCmdStd, &cCmdStd, id)
#define INC_MIMEEDIT(id)    _IncrementCmdList(pCmd, rgCmdMimeEdit, rgpCmdMimeEdit, &cCmdMimeEdit, id)

inline void _IncrementCmdList(OLECMD *pCurCmd, OLECMD *pInCmdList, OLECMD **ppOutCmdList, DWORD *pdwIndex, DWORD cmdID)
{
    DWORD dwIndex = *pdwIndex;
    AssertSz(dwIndex < MAX_MIMEEDIT_CMDS, "Need to increment MAX_MIMEEDIT_CMDS");
    pInCmdList[dwIndex].cmdID = cmdID;
    pInCmdList[dwIndex].cmdf = 0;
    ppOutCmdList[dwIndex] = pCurCmd;
    dwIndex++;
    *pdwIndex = dwIndex;
}

//+---------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    TraceCall("CMimeEditDocHost::CMimeEditDocHost::QueryStatus");

    HRESULT     hr = OLECMDERR_E_UNKNOWNGROUP;
    OLECMD     *pCmd = rgCmds;

    if (!rgCmds)
        return E_INVALIDARG;

    if (NULL == pguidCmdGroup)
    {
        // TraceInfo("IOleCmdTarget::QueryStatus - std group");

        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            if (0 != pCmd->cmdf)
                continue;
            switch (pCmd->cmdID)
            {
                case OLECMDID_UPDATECOMMANDS:
                case OLECMDID_SETPROGRESSPOS:
                case OLECMDID_SETPROGRESSTEXT:
                    pCmd->cmdf = MSOCMDF_ENABLED;
                    break;
            }
        }
        hr = S_OK;
    }

// Will be used when sending down command IDs
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        ULONG   ulTab = MEST_EDIT;

        DWORD   cCmdForms = 0,
                cCmdStd = 0,
                cCmdMimeEdit = 0;

        OLECMD  rgCmdForms[MAX_MIMEEDIT_CMDS],
                rgCmdStd[MAX_MIMEEDIT_CMDS],
                rgCmdMimeEdit[MAX_MIMEEDIT_CMDS],
               *rgpCmdForms[MAX_MIMEEDIT_CMDS],
               *rgpCmdStd[MAX_MIMEEDIT_CMDS],
               *rgpCmdMimeEdit[MAX_MIMEEDIT_CMDS];

        BOOL    fHtml,
                fActiveAndHtml,
                fEditMode = FALSE,
                fFormatMenu = FALSE;

        HrIsEditMode(&fEditMode);
        if (!fEditMode && m_pMsg)
        {
            DWORD dwFlags = 0;
            m_pMsg->GetFlags(&dwFlags);
            fHtml = (dwFlags & IMF_HTML);
        }
        else
            fHtml = (S_OK == HrIsHTMLMode());

        fActiveAndHtml = fHtml && m_fUIActive;

        ExecGetI4(&CMDSETID_MimeEdit, MECMDID_SETSOURCETAB, &ulTab);

        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            ULONG cmdID = pCmd->cmdID;
            if (0 != pCmd->cmdf)
                continue;

            switch (cmdID)
            {
                case ID_REPLY:
                case ID_REPLY_ALL:
                case ID_REPLY_GROUP:
                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                    // If we have the sec UI showing then the reply, etc shouldn't work. We don't care
                    // here in MimeEdit if is isn't displayed. We can allow the other components to
                    // decide what happens in that case.
                    if(m_fSecDispInfo || m_fShowingErrorPage)
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;
                    
                case ID_FONTS_LARGEST:
                case ID_FONTS_LARGE:
                case ID_FONTS_MEDIUM:
                case ID_FONTS_SMALL:
                case ID_FONTS_SMALLEST:
                    INC_FORMS(IDM_BASELINEFONT1 + (cmdID - ID_FONTS_SMALLEST));
                    break;

                case ID_FONTS_FIXED:
                    pCmd->cmdf = QS_ENABLECHECK(!fHtml, m_fFixedFont);
                    break;

                case ID_FIND_TEXT:
                    // For some reason, trident always marks this enabled, but if we are in the
                    // browser and the list view has focus, then the Exec won't work even though 
                    // the QueryStatus returns enabled. Therefore, only enable this if active

                    // Once trident has fixed there problem here, we can enable calling into trident
                    // See RAID 13727
                    //INC_STD(OLECMDID_FIND);
                    pCmd->cmdf = QS_ENABLED(m_fUIActive);
                    break;
                
                case ID_PRINT:
                case ID_PRINT_NOW:
                    if (IsWindowVisible(m_hwnd))
                        INC_STD(OLECMDID_PRINT);
                    
                    break;

                case ID_POPUP_FONTS:
                case ID_VIEW_MSG_SOURCE:
                case ID_VIEW_SOURCE:
                    pCmd->cmdf = QS_ENABLED(TRUE);
                    break;

                // This should be disabled if mail
                case ID_UNSCRAMBLE:
                {
                    DWORD dwFlags = 0;
                    if (m_fSecDispInfo || m_fShowingErrorPage)
                    {
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    }
                    else
                    {
                        m_pBodyOptions->GetFlags(&dwFlags);
                        pCmd->cmdf = QS_ENABLED((0 == (dwFlags & BOPT_MAIL)) && !fEditMode);
                    }
                    break;
                }

                case ID_SAVE_STATIONERY:
                case ID_NOTE_SAVE_STATIONERY:
                {
                    DWORD dwFlags = 0;
                    m_pBodyOptions->GetFlags(&dwFlags);
                    
                    pCmd->cmdf = QS_ENABLED(fHtml && IsWindowVisible(m_hwnd) &&
                                (0 == (BOPT_MULTI_MSGS_SELECTED & dwFlags)) && !m_fShowingErrorPage);
                    break;
                }

                // This should only be enabled if have attachments
                case ID_SAVE_ATTACHMENTS:
                case ID_NOTE_SAVE_ATTACHMENTS:
                {
                    DWORD dwFlags = 0;
                    m_pBodyOptions->GetFlags(&dwFlags);
                    
                    if (IsWindowVisible(m_hwnd) && (0 == (BOPT_MULTI_MSGS_SELECTED & dwFlags)))
                        INC_MIMEEDIT(MECMDID_SAVEATTACHMENTS);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;
                }

                // We only care what happens with these if we are not in the edit tab. If not in the
                // edit tab, then disable these menu items.
                case ID_MOVE_TO_FOLDER:
                case ID_COPY_TO_FOLDER:
                case ID_NOTE_MOVE_TO_FOLDER:
                case ID_NOTE_COPY_TO_FOLDER:
                case ID_FORMATTING_TOOLBAR:
                case ID_POPUP_LANGUAGE:
                case ID_POPUP_LANGUAGE_DEFERRED:
                    if (ulTab != MEST_EDIT)
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_SPELLING:
                    INC_STD(OLECMDID_SPELL); 
                    break;

                case ID_CUT:
                    INC_STD(OLECMDID_CUT); 
                    break;

                case ID_NOTE_COPY:
                case ID_COPY:
                    INC_STD(OLECMDID_COPY); 
                    break;

                case ID_PASTE:
                    INC_STD(OLECMDID_PASTE); 
                    break;

                case ID_SELECT_ALL:
                    INC_STD(OLECMDID_SELECTALL); 
                    break;

                case ID_UNDO:
                    INC_STD(OLECMDID_UNDO); 
                    break;

                case ID_REDO:
                    INC_STD(OLECMDID_REDO); 
                    break;

                case ID_SOURCE_EDIT:
                    INC_MIMEEDIT(MECMDID_SHOWSOURCETABS); 
                    break;

                case ID_DOCDIR_LTR:
                    INC_FORMS(IDM_DIRLTR); 
                    break;

                case ID_DOCDIR_RTL:
                    INC_FORMS(IDM_DIRRTL); 
                    break;

                case ID_INDENT_INCREASE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_INDENT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_INDENT_DECREASE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_OUTDENT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_FONTS_DIALOG:       
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_FONT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_FORMAT_SETTINGS:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_BLOCKFMT); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_INSERT_TEXT:                
                    if (m_fUIActive)
                        INC_MIMEEDIT(MECMDID_INSERTTEXTFILE); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_FORMAT_PARADLG:
                    if (m_fUIActive)
                        INC_MIMEEDIT(MECMDID_FORMATPARAGRAPH);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_POPUP_STYLE:
                    pCmd->cmdf = QS_ENABLED(fActiveAndHtml && (ulTab == MEST_EDIT));
                    break;

                case ID_BACKGROUND_PICTURE:
                case ID_BACKGROUND_SOUND:
                case ID_POPUP_BACKGROUND_COLOR:
                case ID_POPUP_STATIONERY:
                case ID_POPUP_BACKGROUND:
                    pCmd->cmdf = QS_ENABLED(fHtml && (ulTab == MEST_EDIT));
                    break;

                case ID_INSERT_PICTURE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_IMAGE);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_INSERT_LINE:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_HORIZONTALLINE); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_UNLINK:    
                    if (fActiveAndHtml)
                        INC_FORMS(IDM_UNLINK); 
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                case ID_EDIT_LINK:
                    pCmd->cmdf = QS_ENABLED(fActiveAndHtml);
                    break;

                case ID_INSERT_SIGNATURE:
                    if (m_fUIActive && (ulTab == MEST_EDIT) && m_pBodyOptions && (S_OK == m_pBodyOptions->SignatureEnabled(FALSE)))
                        INC_MIMEEDIT(MECMDID_INSERTHTML);
                    else
                        pCmd->cmdf = QS_ENABLED(FALSE);
                    break;

                default:
                    if ((ID_FORMAT_FIRST <= cmdID) && (ID_FORMAT_LAST >= cmdID))
                        pCmd->cmdf = QS_ENABLED(TRUE);
                    break;
            }
        }
        if (cCmdForms)
        {
            DOUTL(8, "cCmdForms = %d", cCmdForms);
            if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, cCmdForms, rgCmdForms, NULL))
            {
                OLECMD     *pCmds = rgCmdForms,
                          **ppCmdsToReturn = rgpCmdForms;

                for (DWORD i = 0; i < cCmdForms; i++, pCmds++, ppCmdsToReturn++)
                    (*ppCmdsToReturn)->cmdf = pCmds->cmdf;
            }
        }
        if (cCmdStd)
        {
            DOUTL(8, "cCmdStd = %d", cCmdStd);
            if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(NULL, cCmdStd, rgCmdStd, NULL))
            {
                OLECMD     *pCmds = rgCmdStd,
                          **ppCmdsToReturn = rgpCmdStd;

                for (DWORD i = 0; i < cCmdStd; i++, pCmds++, ppCmdsToReturn++)
                    (*ppCmdsToReturn)->cmdf = pCmds->cmdf;
            }
        }
        if (cCmdMimeEdit)
        {
            DOUTL(8, "cCmdMimeEdit = %d", cCmdMimeEdit);
            if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_MimeEdit, cCmdMimeEdit, rgCmdMimeEdit, NULL))
            {
                OLECMD     *pCmds = rgCmdMimeEdit,
                          **ppCmdsToReturn = rgpCmdMimeEdit;

                for (DWORD i = 0; i < cCmdMimeEdit; i++, pCmds++, ppCmdsToReturn++)
                    (*ppCmdsToReturn)->cmdf = pCmds->cmdf;
            }
        }

        hr = S_OK;
    }

    else if (IsEqualGUID(CMDSETID_MimeEditHost, *pguidCmdGroup))
    {
        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            if (0 != pCmd->cmdf)
                continue;
            switch (pCmd->cmdID)
            {
                case MEHOSTCMDID_SAVEATTACH_PATH:
                case MEHOSTCMDID_UNSAFEATTACHMENTS:
                case MEHOSTCMDID_SECURITY_ZONE:
                case MEHOSTCMDID_SIGNATURE_ENABLED:
                case MEHOSTCMDID_SIGNATURE_OPTIONS:
                case MEHOSTCMDID_SIGNATURE:
                case MEHOSTCMDID_HEADER_TYPE:
                case MEHOSTCMDID_FLAGS:
                case MEHOSTCMDID_QUOTE_CHAR:
                case MEHOSTCMDID_REPLY_TICK_COLOR:
                case MEHOSTCMDID_COMPOSE_FONT:
                case MEHOSTCMDID_ADD_TO_ADDRESSBOOK:
                case MEHOSTCMDID_ADD_TO_FAVORITES:
                case MEHOSTCMDID_ONPARSECOMPLETE:
                case MEHOSTCMDID_FONTCACHE:
                case MEHOSTCMDID_BORDERFLAGS:
                    pCmd->cmdf = QS_ENABLED(TRUE);
                    break;
            }
        }
        hr = S_OK;
    }

    else if (IsEqualGUID(CMDSETID_OESecurity, *pguidCmdGroup))
    {
        for (ULONG ul = 0; ul < cCmds; ul++, pCmd++)
        {
            if (0 != pCmd->cmdf)
                continue;
            switch (pCmd->cmdID)
            {
                case OECSECCMD_ENCRYPTED:
                {
                    pCmd->cmdf = OLECMDF_SUPPORTED;
                    if (m_fIsEncrypted)
                    {
                        if(m_fSecDispInfo)
                            pCmd->cmdf |= OLECMDF_INVISIBLE;
                        else if (m_fEncryptionOK)
                            pCmd->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                        pCmd->cmdf |= OLECMDF_INVISIBLE;
                    break;
                }
                case OECSECCMD_SIGNED:
                {
                    pCmd->cmdf = OLECMDF_SUPPORTED;
                    if (m_fIsSigned)
                    {
                        if(m_fSecDispInfo)
                            pCmd->cmdf |= OLECMDF_INVISIBLE;
                        else if (m_fSignTrusted)
                            pCmd->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                        pCmd->cmdf |= OLECMDF_INVISIBLE;
                    break;
                }
            }
        }
        hr = S_OK;
    }

    TraceInfoAssert(OLECMDERR_E_UNKNOWNGROUP != hr, "IOleCmdTarget::QueryStatus - unknown group");
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TCHAR   rgch[MAX_PATH];
    HRESULT hr = S_OK;

    TraceCall("CMimeEditDocHost::Exec");

    if (NULL == pguidCmdGroup)
    {
        switch(nCmdID)
        {
            case OLECMDID_UPDATECOMMANDS:
                OnUpdateCommands();
                break;

            case OLECMDID_SETPROGRESSPOS:
                // when done downloading trident now hits us with a
                // setprogresspos == -1 to indicate we should remove the "Done"
                if (pvaIn->lVal == -1)
                    SetStatusText(NULL);
                break;

            case OLECMDID_SETPROGRESSTEXT:
                if(pvaIn->vt == (VT_BSTR))
                    SetStatusText((LPCOLESTR)pvaIn->bstrVal);
                break;

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
        }
    }

// Will be used when sending down command IDs
    else if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        // TraceInfo("IOleCmdTarget::QueryStatus - std group");

        hr = HrWMCommand(m_hwnd, nCmdID, 0);
    }

    else if (IsEqualGUID(CMDSETID_Forms3, *pguidCmdGroup))
    {
        if (nCmdID == IDM_PARSECOMPLETE)
            // add code here to call download complete when 916 comes out.
            OnDocumentReady();
        else if (nCmdID == IDM_DIRRTL)
            return m_pCmdTarget ? m_pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut) : E_FAIL;
        else
            hr = OLECMDERR_E_NOTSUPPORTED;

    }
    else if (IsEqualGUID(CMDSETID_MimeEdit, *pguidCmdGroup))
    {
        return m_pCmdTarget ? m_pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut) : E_FAIL;
    }
    else if (IsEqualGUID(CMDSETID_MimeEditHost, *pguidCmdGroup))
    {
        BOOL fCommandHandled = FALSE;
        // CFrontPage doesn't initialize an m_pBodyOptions
        if (m_pBodyOptions)
        {
            fCommandHandled = TRUE;
            switch (nCmdID)
            {
                case MEHOSTCMDID_SOURCEEDIT_FLAGS:
                    if (pvaOut)
                    {
                        pvaOut->vt = VT_I4;
                        pvaOut->lVal = 0;
                        
                        if (DwGetOption(OPT_SOURCE_EDIT_COLORING))
                            pvaOut->lVal |= MESRCFLAGS_COLOR;
                    } else
                        hr = E_INVALIDARG;
                    break;

                case MEHOSTCMDID_SAVEATTACH_PATH:
                {
                    if (pvaIn && pvaIn->vt == VT_BSTR && pvaIn->bstrVal)
                    {
                        if (WideCharToMultiByte(CP_ACP, 0, pvaIn->bstrVal, -1, rgch, ARRAYSIZE(rgch), NULL, NULL))
                            SetOption(OPT_SAVEATTACH_PATH, rgch, MAX_PATH, NULL, 0);
                    }
                    else if (pvaOut)
                    {
                        pvaOut->vt = VT_BSTR;
                        GetOption(OPT_SAVEATTACH_PATH, rgch, MAX_PATH);
                        hr = HrLPSZToBSTR(rgch, &pvaOut->bstrVal);
                    } else
                        hr = E_INVALIDARG;
                    break;
                }

                case MEHOSTCMDID_UNSAFEATTACHMENTS:
                    if (pvaOut)
                    {
                        BOOL fEditMode = FALSE;

                        pvaOut->vt = VT_I4;
                        HrIsEditMode(&fEditMode);
                        if (fEditMode)      // allow open/save during edit/compose
                            pvaOut->lVal = 0;
                        else
                            pvaOut->lVal = DwGetOption(OPT_SECURITY_ATTACHMENT);
                    } else
                        hr = E_INVALIDARG;
                    break;

                case MEHOSTCMDID_SECURITY_ZONE:
                    if (pvaOut)
                    {
                        pvaOut->vt = VT_I4;
#ifdef FORCE_UNTRUSTED
                        pvaOut->lVal = URLZONE_UNTRUSTED;
#else // FORCE_UNTRUSTED
                        if (DwGetOption(OPT_READ_IN_TEXT_ONLY))
                        {
                            // In text mode, never let scripts run.
                            pvaOut->lVal = URLZONE_UNTRUSTED;
                        }
                        else
                        {
                            pvaOut->lVal = DwGetOption(OPT_SECURITYZONE);
                        }
#endif // FORCE_UNTRUSTED
                    } else
                        hr = E_INVALIDARG;
                    break;

                case MEHOSTCMDID_SIGNATURE_ENABLED:
                {
                    Assert(pvaIn);
                    Assert(V_VT(pvaIn) == VT_I4);
                    hr = m_pBodyOptions->SignatureEnabled((V_I4(pvaIn) == MESIG_AUTO) ? TRUE : FALSE);
                    break;
                }

                case MEHOSTCMDID_SIGNATURE_OPTIONS:
                {
                    DWORD   outFlags = 0,
                            fBodyFlags = 0;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    m_pBodyOptions->GetSignature(NULL, &fBodyFlags, NULL);
                    if (fBodyFlags != 0)
                    {
                        outFlags = (fBodyFlags & SIGOPT_HTML) ? MESIGOPT_HTML : MESIGOPT_PLAIN;
                        if (fBodyFlags & SIGOPT_TOP)
                            outFlags |= MESIGOPT_TOP;
                        if (fBodyFlags & SIGOPT_PREFIX)
                            outFlags |= MESIGOPT_PREFIX;
                        if (fBodyFlags & SIGOPT_BOTTOM)
                            outFlags |= MESIGOPT_BOTTOM;
                    }
                    V_I4(pvaOut) = outFlags;
                    break;
                }

                case MEHOSTCMDID_SPELL_LANGUAGE:
                {
                    Assert(pvaOut);
                    pvaOut->vt = VT_BSTR;
                    
                    if (GetOption(OPT_SPELL_LANGID, rgch, ARRAYSIZE(rgch)))
                    {
                        hr = HrLPSZToBSTR(rgch, &pvaOut->bstrVal);
                    }
                    else
                        hr = E_FAIL;
                    break;
                }

                case MEHOSTCMDID_SPELL_OPTIONS:
                {
                    DWORD   outFlags = 0;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    if (DwGetOption(OPT_SPELLIGNORENUMBER))
                        outFlags |= MESPELLOPT_IGNORENUMBER;
                    if (DwGetOption(OPT_SPELLIGNOREUPPER))
                        outFlags |= MESPELLOPT_IGNOREUPPER;
                    if (DwGetOption(OPT_SPELLIGNOREDBCS))
                        outFlags |= MESPELLOPT_IGNOREDBCS;
                    if (DwGetOption(OPT_SPELLIGNOREPROTECT))
                        outFlags |= MESPELLOPT_IGNOREPROTECT;
                    if (DwGetOption(OPT_SPELLIGNOREURL))
                        outFlags |= MESPELLOPT_IGNOREURL;
                    if (DwGetOption(OPT_SPELLALWAYSSUGGEST))
                        outFlags |= MESPELLOPT_ALWAYSSUGGEST;
                    if (DwGetOption(OPT_SPELLCHECKONSEND))
                        outFlags |= MESPELLOPT_CHECKONSEND;
                    if (DwGetOption(OPT_SPELLCHECKONTYPE))
                        outFlags |= MESPELLOPT_CHECKONTYPE;

                    V_I4(pvaOut) = outFlags;
                    break;
                }

                case MEHOSTCMDID_SIGNATURE:
                {
                    DWORD fFlags;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_BSTR;
                    hr = m_pBodyOptions->GetSignature(NULL, &fFlags, &V_BSTR(pvaOut));
                    break;
                }

                case MEHOSTCMDID_HEADER_TYPE:
                {
                    DWORD dwFlags = 0;
                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    m_pBodyOptions->GetFlags(&dwFlags);
                    if (dwFlags & BOPT_USEREPLYHEADER)
                    {
                        if (dwFlags & BOPT_MAIL)
                        {
                            V_I4(pvaOut) = MEHEADER_MAIL; 
                            if (DwGetOption(OPT_HARDCODEDHDRS))
                                V_I4(pvaOut) |= MEHEADER_FORCE_ENGLISH;
                        }
                        else
                            V_I4(pvaOut) = MEHEADER_NEWS; 
                    }
                    else
                        V_I4(pvaOut) = MEHEADER_NONE; 
                    break;
                }

                case MEHOSTCMDID_FLAGS:
                {
                    DWORD   outFlags = 0,
                            fBodyFlags;

                    Assert(pvaOut);
                    V_VT(pvaOut) = VT_I4;
                    hr = m_pBodyOptions->GetFlags(&fBodyFlags);
                    if (SUCCEEDED(hr))
                    {
                        if (fBodyFlags & BOPT_INCLUDEMSG)
                            outFlags = MEO_FLAGS_INCLUDEMSG;
                        if ((fBodyFlags & BOPT_HTML) || m_fSecDispInfo)
                            outFlags |= MEO_FLAGS_HTML;

                        if (fBodyFlags & BOPT_AUTOINLINE &&
                            DwGetOption(OPT_AUTO_IMAGE_INLINE)!=AUTO_INLINE_OFF)
                        {
                            outFlags |= MEO_FLAGS_AUTOINLINE;
                            if (DwGetOption(OPT_AUTO_IMAGE_INLINE) == AUTO_INLINE_SLIDE)
                                outFlags |= MEO_FLAGS_SLIDESHOW;
                        }

                        if (fBodyFlags & BOPT_SENDIMAGES)
                            outFlags |= MEO_FLAGS_SENDIMAGES;
                        if (fBodyFlags & BOPT_AUTOTEXT)
                            outFlags |= MEO_FLAGS_AUTOTEXT;
                        if (fBodyFlags & BOPT_BLOCKQUOTE)
                            outFlags |= MEO_FLAGS_BLOCKQUOTE;
                        if (fBodyFlags & BOPT_SENDEXTERNALS)
                            outFlags |= MEO_FLAGS_SENDEXTERNALIMGSRC;
                        if (fBodyFlags & BOPT_SPELLINGOREORIGINAL)
                            outFlags |= MEO_FLAGS_DONTSPELLCHECKQUOTED;
                    }
                    V_I4(pvaOut) = outFlags;
                    break;
                }

                case MEHOSTCMDID_QUOTE_CHAR:
                {
                    BODYOPTINFO boi;
                    Assert(pvaOut);

                    boi.dwMask = BOPTF_QUOTECHAR;
                    hr = m_pBodyOptions->GetInfo(&boi);
                    V_VT(pvaOut) = VT_I4;
                    V_I4(pvaOut) = boi.chQuote;
                    break;
                }

                case MEHOSTCMDID_REPLY_TICK_COLOR:
                {
                    BODYOPTINFO boi;
                    Assert(pvaOut);

                    boi.dwMask = BOPTF_REPLYTICKCOLOR;
                    hr = m_pBodyOptions->GetInfo(&boi);
                    V_VT(pvaOut) = VT_I4;
                    V_I4(pvaOut) = boi.dwReplyTickColor;
                    break;
                }

                case MEHOSTCMDID_COMPOSE_FONT:
                {
                    BODYOPTINFO boi;
                    DWORD   fBodyFlags = 0;
                    Assert(pvaOut);

                    hr = m_pBodyOptions->GetFlags(&fBodyFlags);
                    if (SUCCEEDED(hr) && (fBodyFlags & BOPT_NOFONTTAG))
                    {
                        V_BSTR(pvaOut) = NULL;
                        break;
                    }

                    boi.dwMask = BOPTF_COMPOSEFONT;
                    hr = m_pBodyOptions->GetInfo(&boi);
                    if (SUCCEEDED(hr))
                    {
                        V_VT(pvaOut) = VT_BSTR;
                        hr = HrLPSZToBSTR(boi.rgchComposeFont, &V_BSTR(pvaOut));
                    }
                    break;
                }

                case MEHOSTCMDID_IS_READ_IN_TEXT_ONLY:
                {
                    if (VT_BOOL == pvaOut->vt)
                    {
                        if (m_fSecDispInfo || m_fShowingErrorPage || !DwGetOption(OPT_READ_IN_TEXT_ONLY))
                            pvaOut->boolVal = VARIANT_FALSE;
                        else
                            pvaOut->boolVal = VARIANT_TRUE;
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                    break;
                }

                case MEHOSTCMDID_HTML_HELP:
                {         
                    Assert(pvaOut);

                    V_VT(pvaOut) = VT_BOOL;
                    V_BOOL(pvaOut) = (m_fSecDispInfo || m_fShowingErrorPage)?VARIANT_TRUE:VARIANT_FALSE;
                    break;
                }

                default:
                    fCommandHandled = FALSE;
                    break;
            }
        }

        if (fCommandHandled)
            goto exit;

        switch (nCmdID)
        {
            case MEHOSTCMDID_ADD_TO_ADDRESSBOOK:
            {
                Assert(pvaIn);
                Assert(V_BSTR(pvaIn));
                hr = HrAddToWab(V_BSTR(pvaIn));
                break;
            }

            case MEHOSTCMDID_ADD_TO_FAVORITES:
            {
                BSTR bstrURL=0, bstrDescr=0;
                LONG l;

                Assert(pvaIn);
                
                l=0;
                IF_FAILEXIT(hr=SafeArrayGetElement(V_ARRAY(pvaIn), &l, &bstrDescr));
                l=1;
                IF_FAILEXIT(hr=SafeArrayGetElement(V_ARRAY(pvaIn), &l, &bstrURL));

                hr = HrAddToFavorites(bstrDescr, bstrURL);
                break;
            }

            case MEHOSTCMDID_SLIDESHOW_DELAY:
            {
                Assert(pvaOut);
                V_VT(pvaOut) = VT_I4;
                V_I4(pvaOut) = 3000;  //In milleseconds
                break;
            }

            case MEHOSTCMDID_ONPARSECOMPLETE:
            {
                if (!m_fBlockingOnSMime)
                    OnDocumentReady();
                break;
            }

            case MEHOSTCMDID_FONTCACHE:
            {
                Assert(pvaOut);
                if (g_lpIFontCache)
                {
                    V_VT(pvaOut) = VT_UNKNOWN;
                    V_UNKNOWN(pvaOut) = g_lpIFontCache;
                    g_lpIFontCache->AddRef();
                } else
                    hr = E_FAIL;
                break;
            }

            case MEHOSTCMDID_BORDERFLAGS:
            {
                Assert(pvaOut);
                V_VT(pvaOut) = VT_I4;
                V_I4(pvaOut) = m_dwBorderFlags;
                break;
            }

            // in the case where m_pBodyOptions is not initialized we're
            //  likely in a non-message window so just default to internet zone
            case MEHOSTCMDID_SECURITY_ZONE:
            {
                Assert(pvaOut);
                V_VT(pvaOut) = VT_I4;
                V_I4(pvaOut) = URLZONE_INTERNET;
                break;
            }

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
        }
    }
    else if (IsEqualGUID(CMDSETID_OESecurity, *pguidCmdGroup))
    {
        if ((OECSECCMD_ENCRYPTED == nCmdID) || (OECSECCMD_SIGNED == nCmdID))
        {
            if(m_pSecureMessage && (CheckSecReceipt(m_pSecureMessage) == S_OK))
            {
                hr = HrShowSecurityProperty(m_hwnd, m_pSecureMessage);
            }
            else
                hr = HrShowSecurityProperty(m_hwnd, m_pMsg);
        }

        else
            hr = OLECMDERR_E_NOTSUPPORTED;
    } else
        hr = OLECMDERR_E_NOTSUPPORTED;

exit:
    return hr;
}

HRESULT CMimeEditDocHost::HrAddToFavorites(BSTR bstrDescr, BSTR bstrURL)
{
    HRESULT     hr = E_FAIL;

    hr = AddUrlToFavorites(m_hwnd, bstrURL, bstrDescr, TRUE);
    if(FAILED(hr))
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrFavorites), NULL, MB_OK);        

    return (TraceResult(hr));
}

HRESULT CMimeEditDocHost::HrAddToWab(BSTR bstr)
{
    LPWAB           lpWab;
    HRESULT         hr;
    INT             idsErr=0;
    ADRINFO         AdrInfo;
    LPSTR           psz;

    hr = HrCreateWabObject(&lpWab);
    if (!FAILED(hr))
    {
        if (bstr)
        {
            ZeroMemory(&AdrInfo, sizeof(ADRINFO));
            AdrInfo.lpwszAddress = bstr;
            AdrInfo.lpwszDisplay = bstr;

            hr = lpWab->HrAddToWAB(m_hwnd, &AdrInfo);
            if (FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
            {
                if(hr==MAPI_E_COLLISION)
                    idsErr=idsErrAddrDupe;
                else
                    idsErr=idsErrAddToWAB;
            }

            if(idsErr)
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErr), NULL, MB_OK);
        }
        lpWab->Release();
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     WMSize
//
//  Synopsis:
//
//---------------------------------------------------------------
void CMimeEditDocHost::WMSize(int cxBody, int cyBody)
{
    RECT rc={0};

    TraceCall("CMimeEditDocHost::WMSize");

    if(m_pDocView)
    {
        rc.bottom=cyBody;
        rc.right=cxBody;

        m_pDocView->SetRect(&rc);
    }

    // notify the subclass of a wmsize
    OnWMSize(&rc);
}
// *** IOleControlSite ***

//+---------------------------------------------------------------
//
//  Member:     OnControlInfoChanged
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnControlInfoChanged()
{
    TraceCall("CMimeEditDocHost::OnControlInfoChanged");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     LockInPlaceActive
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::LockInPlaceActive(BOOL fLock)
{
    TraceCall("CMimeEditDocHost::LockInPlaceActive");
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     GetExtendedControl
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::GetExtendedControl(LPDISPATCH *ppDisp)
{
    TraceCall("CMimeEditDocHost::GetExtendedControl");

    if (ppDisp)
        *ppDisp=NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TransformCoords
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
{
    TraceCall("CMimeEditDocHost::TransformCoords");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
// Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
    TraceCall("CMimeEditDocHost::TranslateAccelerator");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnFocus
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnFocus(BOOL fGotFocus)
{
    HRESULT hr = S_OK;

    m_fUIActive = !!fGotFocus;
    if (m_pDocView)
        hr = m_pDocView->UIActivate(fGotFocus);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     ShowPropertyFrame
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::ShowPropertyFrame(void)
{
    TraceCall("CMimeEditDocHost::ShowPropertyFrame");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnUpdateCommands
//
//  Synopsis:
//
//---------------------------------------------------------------
HRESULT CMimeEditDocHost::OnUpdateCommands()
{
    TraceCall("CMimeEditDocHost::OnUpdateCommands");

    SendMessage(GetParent(m_hwnd), NWM_UPDATETOOLBAR, 0, 0);

    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::Load(LPMIMEMESSAGE pMsg)
{
    SECSTATE    secState = {0};
    DWORD       dw = 0;
    HRESULT     hr;

    m_fFixedFont = FALSE;

    RegisterForHTMLDocEvents(FALSE);

    m_fSecDispInfo = FALSE;      // reset flag
    m_fShowingErrorPage = FALSE;
    m_fSecureReceipt = FALSE;

    if(CheckSecReceipt(pMsg) == S_OK)
    {
        HrGetSecurityState(pMsg, &secState, NULL);
        m_fSecureReceipt = TRUE;
        m_fIsEncrypted = !!IsEncrypted(secState.type);
        m_fIsSigned = !!IsSigned(secState.type);
        m_fSignTrusted = !!IsSignTrusted(&secState);
        m_fEncryptionOK = !!IsEncryptionOK(&secState);
        hr = LoadSecurely(pMsg, &secState);
        CleanupSECSTATE(&secState);
    }
    else if (IsSecure(pMsg) && SUCCEEDED(HrGetSecurityState(pMsg, &secState, NULL)))
    {
        m_fIsEncrypted = !!IsEncrypted(secState.type);
        m_fIsSigned = !!IsSigned(secState.type);
        m_fSignTrusted = !!IsSignTrusted(&secState);
        m_fEncryptionOK = !!IsEncryptionOK(&secState);
        hr = LoadSecurely(pMsg, &secState);
        CleanupSECSTATE(&secState);
    }
    else
    {
        m_fIsEncrypted = FALSE;
        m_fIsSigned = FALSE;
        m_fSignTrusted = TRUE;
        m_fEncryptionOK = TRUE;
        hr = InternalLoad(pMsg);
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::InternalLoad(IMimeMessage *pMsg)
{
    SECSTATE    secState = {0};
    DWORD       dw = 0;
    HRESULT     hr;
    DWORD       dwBodyFlags = 0;
    BOOLEAN     fProcess = FALSE;

    ReplaceInterface(m_pMsg, pMsg);

    if(m_pBodyOptions)
    {
        m_pBodyOptions->GetFlags(&dwBodyFlags);
        
        m_fMarkedRead = (0 == (dwBodyFlags & BOPT_UNREAD));
        if (!m_fMarkedRead)
        {   
            if (!m_fSecDispInfo && !!(dwBodyFlags & BOPT_MAIL))
                fProcess = TRUE;

            if (dwBodyFlags & BOPT_FROM_NOTE)
            {
                //Since opening a message in a note, it should be marked as read immediately. 
                HrMarkAsRead();
            }
            else
            {
                // ReplaceInterface(m_pMsg, pMsg);

                if (m_pBodyOptions->GetMarkAsReadTime(&dw) == S_OK)
                {
                    if (dw == 0)
                        HrMarkAsRead();
                    else 
                    if (dw != OPTION_OFF)
                        SetTimer(m_hwnd, idTimerMarkAsRead, dw*1000, NULL);
                }
                else
                    HrMarkAsRead();
            }
        }
    }

    hr = m_pPrstMime->Load(m_pMsg);

    if ((fProcess) && !(dwBodyFlags & BOPT_FROM_NOTE) && SUCCEEDED(hr) && (m_pEventSink))
    {
        m_pEventSink->EventOccurred(MEHC_CMD_PROCESS_RECEIPT, m_pMsg);
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    DWORD       idsWarning;
    HRESULT     hr;

    Assert(m_pPrstMime);

    hr = m_pPrstMime->Save(pMsg, dwFlags);

    switch (hr)
    {
        case MIMEEDIT_E_CANNOTSAVEWHILESOURCEEDITING:
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrCannotSaveInSourceEdit), NULL, MB_OK|MB_ICONEXCLAMATION);
            hr = MAPI_E_USER_CANCEL;
            break;

        // brettm: for OE5 we no longer warn if trident is not readystate complete. In the case of active movie controls 
        // they never go readyState complete 'by design' as they never loaded the source url. The warning is annoying for 
        // msphone message forwarding. for images we check individual readystates anyway.
        //case MIMEEDIT_W_DOWNLOADNOTCOMPLETE:
        
        case MIMEEDIT_W_BADURLSNOTATTACHED:
            if (IDYES != AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrBadMHTMLLinks), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2))
                hr = MAPI_E_USER_CANCEL;
            break;

        case MIMEEDIT_E_CANNOTSAVEUNTILPARSECOMPLETE:
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrNotSaveUntilDownloadDone), NULL, MB_OK|MB_ICONEXCLAMATION);
            hr = MAPI_E_USER_CANCEL;
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::GetClassID(CLSID *pClsID)
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrOnDocObjCreate()
{
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetElement(LPCTSTR pszName, IHTMLElement **ppElem)
{
    return ::HrGetElementImpl(m_pDoc, pszName, ppElem);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSpellCheck(BOOL fSuppressDoneMsg)
{
    return m_pCmdTarget ? m_pCmdTarget->Exec(NULL, OLECMDID_SPELL,
        fSuppressDoneMsg ? OLECMDEXECOPT_DONTPROMPTUSER : OLECMDEXECOPT_PROMPTUSER , NULL, NULL) : E_FAIL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrPrint(BOOL fPrompt)
{
    VARIANTARG  va;
    HRESULT     hr;

    if (!m_pCmdTarget)
        return E_FAIL;

    va.vt = VT_BSTR;
    va.bstrVal = NULL;
    GetOEUserName(&va.bstrVal);
    hr = m_pCmdTarget->Exec(NULL, OLECMDID_PRINT, 
                                fPrompt ? OLECMDEXECOPT_PROMPTUSER : OLECMDEXECOPT_DONTPROMPTUSER, &va, NULL);

    SysFreeString(va.bstrVal);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsEmpty(BOOL *pfEmpty)
{
    return ExecGetBool(&CMDSETID_MimeEdit, MECMDID_EMPTY, pfEmpty);
}

// ********************************************
HRESULT CMimeEditDocHost::HrUnloadAll(UINT idsDefaultBody, DWORD dwFlags)
{
    TCHAR   rgch[CCHMAX_STRINGRES];

    KillTimer(m_hwnd, idTimerMarkAsRead);

    m_fIsEncrypted = FALSE;
    m_fIsSigned = FALSE;
    m_fSignTrusted = TRUE;
    m_fEncryptionOK = TRUE;

    HrInitNew(m_lpOleObj);

    if (idsDefaultBody)
    {
        LoadString(g_hLocRes, idsDefaultBody, rgch, ARRAYSIZE(rgch));
        HrSetText(rgch);
    }

    return S_OK;
}

// ********************************************
BOOL CMimeEditDocHost::WMCommand(HWND hwnd, int id, WORD wCmd)
{
    return SUCCEEDED(HrWMCommand(hwnd, id, wCmd));
}

// ********************************************
BOOL CMimeEditDocHost::WMNotify(int idFrom, NMHDR *pnmh)
{
    return FALSE;
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsDirty(BOOL *pfDirty)
{
    return ExecGetBool(&CMDSETID_MimeEdit, MECMDID_DIRTY, pfDirty);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetDirtyFlag(BOOL fDirty)
{
    return ExecSetBool(&CMDSETID_MimeEdit, MECMDID_DIRTY, fDirty);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetStyle(DWORD dwStyle)
{
    HRESULT hr = ExecSetI4(&CMDSETID_MimeEdit, MECMDID_STYLE, dwStyle);

    if (SUCCEEDED(hr))
        m_dwDocStyle = dwStyle;

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetStyle(DWORD *pdwStyle)
{
    *pdwStyle = m_dwDocStyle;
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrEnableHTMLMode(BOOL fOn)
{
    BOOL    fEdit=FALSE;

    m_fFixedFont = FALSE;

    // if turning HTML mode on, turn on the source tabs
    if (fOn && HrIsEditMode(&fEdit)==S_OK && fEdit)
        ExecSetBool(&CMDSETID_MimeEdit, MECMDID_SHOWSOURCETABS, DwGetOption(OPT_VIEWSOURCETABS));

    return ExecSetBool(&CMDSETID_MimeEdit, MECMDID_EDITHTML, fOn);
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsHTMLMode()
{
    ULONG   cmdf=0;
        
    QuerySingleMimeEditCmd(MECMDID_EDITHTML, &cmdf);
    return (cmdf & OLECMDF_LATCHED) ? S_OK :S_FALSE;
}

// ********************************************
HRESULT CMimeEditDocHost::HrDowngradeToPlainText()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_DOWNGRADEPLAINTEXT);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetText(LPSTR lpsz)
{
    TCHAR   rgch[CCHMAX_STRINGRES];

    RegisterForHTMLDocEvents(FALSE);
    m_fShowingErrorPage = TRUE;

    if (HIWORD(lpsz)==0)
    {
        LoadString(g_hLocRes, LOWORD(lpsz), rgch, ARRAYSIZE(rgch));
        lpsz = rgch;
    }
    return ExecSetText(&CMDSETID_MimeEdit, MECMDID_SETTEXT, lpsz);
}

// ********************************************
HRESULT CMimeEditDocHost::HrPerformROT13Encoding()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_ROT13);
}

// ********************************************
HRESULT CMimeEditDocHost::LoadHtmlErrorPage(LPCSTR pszURL)
{
    HRESULT hr;
    LPSTR   pszUrlFree=NULL;

    // if relative, wrap in our res:// handler
    pszUrlFree = PszAllocResUrl((LPSTR)pszURL);
    if (!pszUrlFree)
        return E_OUTOFMEMORY;

    hr = HrLoadURL(pszUrlFree);
    if (SUCCEEDED(hr))
        RegisterForHTMLDocEvents(TRUE);

    m_fIsEncrypted = FALSE;
    m_fIsSigned = FALSE;
    m_fSignTrusted = TRUE;
    m_fEncryptionOK = TRUE;
    m_fShowingErrorPage = TRUE;

    SafeMemFree(pszUrlFree);
    return hr;
}

// ********************************************
// Base assumes that is URL to MHTML
HRESULT CMimeEditDocHost::HrLoadURL(LPCSTR pszURL)
{
    BSTR                bstr = NULL;
    IMoniker           *pMoniker = NULL;
    IPersistMoniker    *pPrstMnkr = NULL;
    HRESULT hr;

    hr = HrLPSZToBSTR(pszURL, &bstr);
    if (FAILED(hr))
        goto error;

    hr = CreateURLMoniker(NULL, bstr, &pMoniker);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IPersistMoniker, (LPVOID*)&pPrstMnkr);
    if (FAILED(hr))
        goto error;

    hr = pPrstMnkr->Load(FALSE, pMoniker, NULL, 0);

error:
    SysFreeString(bstr);
    SafeRelease(pMoniker);
    SafeRelease(pPrstMnkr);

    return hr;
}


// ********************************************
HRESULT CMimeEditDocHost::HrInsertTextFile(LPSTR lpsz)
{
    return ExecSetText(&CMDSETID_MimeEdit, MECMDID_INSERTTEXTFILE, lpsz);
}

// ********************************************
HRESULT CMimeEditDocHost::HrInsertTextFileFromDialog()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_INSERTTEXTFILE);
}

// ********************************************
HRESULT CMimeEditDocHost::HrViewSource(DWORD dwViewType)
{
    return ExecSetI4(&CMDSETID_MimeEdit, MECMDID_VIEWSOURCE, dwViewType);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetPreviewFormat(LPSTR lpsz)
{
    BSTR bstr;
    VARIANTARG var;
    
    if (!m_pCmdTarget)
        return E_FAIL;

    HRESULT hr = HrLPSZToBSTR(lpsz, &bstr);
    if (FAILED(hr))
        goto Exit;

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;

    hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_PREVIEWFORMAT, OLECMDEXECOPT_DODEFAULT, &var, NULL);

    SysFreeString(bstr);
Exit:
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetEditMode(BOOL fOn)
{
    ExecSetBool(&CMDSETID_MimeEdit, MECMDID_EDITMODE, fOn);

    if (fOn && HrIsHTMLMode()==S_OK)
        ExecSetBool(&CMDSETID_MimeEdit, MECMDID_SHOWSOURCETABS, DwGetOption(OPT_VIEWSOURCETABS));
    
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrIsEditMode(BOOL *pfOn)
{
    return ExecGetBool(&CMDSETID_MimeEdit, MECMDID_EDITMODE, pfOn);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetCharset(HCHARSET hCharset)
{
    return ExecSetI8(&CMDSETID_MimeEdit, MECMDID_CHARSET, reinterpret_cast<ULONGLONG>(hCharset));
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetCharset(HCHARSET *phCharset)
{
    HRESULT     hr;
    ULONGLONG   ullCharset;
    
    hr = ExecGetI8(&CMDSETID_MimeEdit, MECMDID_CHARSET, &ullCharset);

    *phCharset = reinterpret_cast<HCHARSET>(ullCharset);
    
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSaveAsStationery(LPWSTR pwszFile)
{
    BSTR        bstr = NULL;
    VARIANTARG  varIn, 
                varOut;
    HRESULT     hr = S_OK;

    V_VT(&varOut) = VT_EMPTY;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    if (pwszFile)
    {
        IF_NULLEXIT(bstr = SysAllocString(pwszFile));
    }
    else
    {
        WCHAR wszPath[MAX_PATH];
        HrGetStationeryPath(wszPath);
        IF_NULLEXIT(bstr = SysAllocString(wszPath));
    }

    V_VT(&varIn) = VT_BSTR;
    V_BSTR(&varIn) = bstr;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_SAVEASSTATIONERY, OLECMDEXECOPT_DODEFAULT, &varIn, &varOut));

    if (V_VT(&varOut) == VT_BSTR)
    {
        IF_FAILEXIT(hr = HrAddToStationeryMRU(V_BSTR(&varOut)));
    }

exit:
    SysFreeString(bstr);
    if (VT_EMPTY != V_VT(&varOut))
        SysFreeString(V_BSTR(&varOut));

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrApplyStationery(LPWSTR pwszFile)
{
    IStream            *pstm = NULL;
    IHTMLDocument2     *pDoc = NULL;
    HRESULT             hr = S_OK;
    VARIANTARG          var;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    // Apply stationery
    // if no filename in buffer, means No Stationery was called
    if (*pwszFile)
    {
        // Don't need to deal with the unicode stream issue when 
        // returning from HrCreateBasedWebPage in this case. There
        // are only a few attributes that are saved when applying
        // stationery and the ones we care about seem OK right now.
        IF_FAILEXIT(hr = HrCreateBasedWebPage(pwszFile, &pstm));

        IF_FAILEXIT(hr = MimeEditDocumentFromStream(pstm, IID_IHTMLDocument2, (LPVOID*)&pDoc));
    }

    var.vt = VT_UNKNOWN;
    var.punkVal = pDoc;
    IF_FAILEXIT(hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_APPLYDOCUMENT, OLECMDEXECOPT_DODEFAULT, &var, NULL));

exit:
    ReleaseObj(pstm);
    ReleaseObj(pDoc);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrUpdateFormatBar()
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrClearFormatting()
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrMEDocHost_Init(BOOL fInit)
{
    WNDCLASSW    wc={0};

    if(fInit)
    {
        // RAID - 12563
        // We need to check to see if the class has been registered
        // already, because our DLL might get unloaded
        if (0 == GetClassInfoWrapW(g_hInst, c_wszMEDocHostWndClass, &wc))        // already regisered
        {
            wc.lpfnWndProc   = CMimeEditDocHost::ExtWndProc;
            wc.hInstance     = g_hInst;
            wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
            wc.lpszClassName = c_wszMEDocHostWndClass;
            wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
            wc.style = CS_DBLCLKS;

            if(!RegisterClassWrapW(&wc))
                return E_OUTOFMEMORY;
        }
    }
    else if (0 != GetClassInfoWrapW(g_hInst, c_wszMEDocHostWndClass, &wc))
        // don't need to enterCS for this, as it's the process going down.
        UnregisterClassWrapW(c_wszDocHostWndClass, g_hInst);

    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrPostInit()
{
    HRESULT hr = CreateDocObj((LPCLSID)&CLSID_MimeEdit);
    if (FAILED(hr))
        return hr;

    hr = Show();
    if(FAILED(hr))
        return hr;

    return HrOnDocObjCreate();
}

// ********************************************
HRESULT CMimeEditDocHost::HrInit(HWND hwndParent, DWORD dwFlags, IBodyOptions *pBodyOptions)
{
    HRESULT hr = S_OK;
    HWND    hwnd = 0;

    m_dwStyle=dwFlags;

    Assert(!m_pBodyOptions);
    if (pBodyOptions)
    {
        m_pBodyOptions = pBodyOptions;
        pBodyOptions->AddRef();
    }

    if(!IsWindow(hwndParent))
        IF_FAILEXIT(hr = E_INVALIDARG);

    IF_FAILEXIT(hr=HrMEDocHost_Init(TRUE));

    hwnd=CreateWindowExWrapW(WS_EX_NOPARENTNOTIFY,
                             c_wszMEDocHostWndClass, NULL,
                             WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_CHILD|WS_TABSTOP,
                             0,0,0,0, hwndParent,
                             (HMENU)idREBody, g_hInst, (LPVOID)this);
    IF_NULLEXIT(hwnd);

    IF_FAILEXIT(hr = HrCreateColorMenu(ID_FORMAT_COLOR1, &m_hmenuColor, FALSE));

    IF_FAILEXIT(hr = HrPostInit());

exit:
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrClose()
{
    // Don't call HrUnloadAll on close as it's redundant to
    // clear out the contents with an InitNew. We simply force the docobj
    // down with it current content
    SafeRelease(m_pBodyOptions);
    CloseDocObj();
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetStatusBar(CStatusBar *pStatus)
{
    SafeRelease(m_pStatus);
    m_pStatus=pStatus;
    if(pStatus)
        pStatus->AddRef();

    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrUpdateToolbar(HWND hwndToolbar)
{
    HRESULT hr=NOERROR;
    ULONG   cmdf=0;

    if(!IsWindow(hwndToolbar))
        return E_INVALIDARG;

    QuerySingleMimeEditCmd(MECMDID_INSERTHTML, &cmdf);

    if ((cmdf & OLECMDF_ENABLED) &&
        m_pBodyOptions &&
        m_pBodyOptions->SignatureEnabled(FALSE)==S_OK && m_fUIActive)
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_INSERT_SIGNATURE, MAKELONG(TRUE, 0));
    else
        SendMessage(hwndToolbar, TB_ENABLEBUTTON, ID_INSERT_SIGNATURE, 0);

    // if docobj has focus, query the command target to get info.
    if (m_fUIActive)
        hr=HrCmdTgtUpdateToolbar(m_pCmdTarget, hwndToolbar);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::GetTabStopArray(HWND *rgTSArray, int *pcArrayCount)
{
    Assert(rgTSArray);
    Assert(pcArrayCount);
    Assert(*pcArrayCount > 0);

    IOleWindow     *pWindow = NULL;
    HWND            hWnd;

    *pcArrayCount = 0;

    HRESULT hr = m_pDoc->QueryInterface(IID_IOleWindow, (LPVOID *)&pWindow);
    if (FAILED(hr))
        goto error;

    hr = pWindow->GetWindow(&hWnd);
    if (FAILED(hr))
        goto error;

    *rgTSArray = hWnd;
    *pcArrayCount = 1;

error:
    SafeRelease(pWindow);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrInsertSignature(int id)
{
    char        szID[MAXSIGID], *pszID;
    HRESULT     hr=S_OK;
    BSTR        bstr;
    DWORD       dwSigOpt;

    if (!m_pCmdTarget)
        return E_FAIL;

    Assert((ID_INSERT_SIGNATURE == id) || (id >= ID_SIGNATURE_FIRST && id <= ID_SIGNATURE_LAST));
    Assert(m_pBodyOptions);

    if(!m_pBodyOptions)
        return E_FAIL;

    if ((ID_INSERT_SIGNATURE == id) || FAILED(GetSigFromCmd(id, szID, ARRAYSIZE(szID))))
    {
        pszID = NULL;
    }
    else
    {
        pszID = szID;
    }

    if (m_pBodyOptions->SignatureEnabled(FALSE)==S_OK)
    {
        if (SUCCEEDED(hr = m_pBodyOptions->GetSignature(pszID, &dwSigOpt, &bstr)))
        {
            DWORD cmd;
            VARIANTARG var;

            if ((dwSigOpt & SIGOPT_PREFIX) && (0 == (dwSigOpt & SIGOPT_HTML)))
            {
                BSTR    bstrPrefix;
                if (HrLPSZToBSTR(c_szSigPrefix, &bstrPrefix)==S_OK)
                {
                    UINT    sigLen = lstrlenW(bstr),
                            preLen = lstrlenW(bstrPrefix);

                    // SysAllocStringLen includes one for the NULL
                    BSTR    bstrTempBuf = SysAllocStringLen(NULL, preLen + sigLen);
                    if (bstrTempBuf)
                    {
                        memcpy(bstrTempBuf, bstrPrefix, preLen*sizeof(*bstrPrefix));
                        memcpy((bstrTempBuf + preLen), bstr, sigLen*sizeof(*bstr));
                        bstrTempBuf[preLen + sigLen] = L'\0';
                        SysFreeString(bstr);
                        bstr = bstrTempBuf;
                    }
                    SysFreeString(bstrPrefix);
                }
            }

            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = bstr;

            cmd = dwSigOpt&SIGOPT_HTML ? MECMDID_INSERTHTML : MECMDID_INSERTTEXT;
            hr = m_pCmdTarget->Exec(&CMDSETID_MimeEdit, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL);

            SysFreeString(bstr);
        }
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrShow(BOOL fVisible)
{
    ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE);
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::ViewCertificate(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg)
{
    return CommonUI_ViewSigningCertificate(m_hwnd, pCert, hcMsg);
}

// ********************************************
HRESULT CMimeEditDocHost::EditTrust(PCCERT_CONTEXT pCert, HCERTSTORE hcMsg)
{
    return CommonUI_ViewSigningCertificateTrust(m_hwnd, pCert, hcMsg);
}

// ********************************************
HRESULT CMimeEditDocHost::UpdateBackAndStyleMenus(HMENU hmenu)
{
    MENUITEMINFO    miiBk;
    HMENU           hmenuTag=NULL;

    ZeroMemory(&miiBk, sizeof(miiBk));
    miiBk.cbSize=sizeof(miiBk);
    miiBk.fMask = MIIM_ID | MIIM_SUBMENU;
    if (GetMenuItemInfo(hmenu, ID_POPUP_BACKGROUND_COLOR, FALSE, &miiBk))
    {
        MENUITEMINFO    miiBkColor;

        HrCheckColor();
        ZeroMemory(&miiBkColor, sizeof(miiBkColor));
        miiBkColor.cbSize=sizeof(miiBkColor);
        miiBkColor.fMask = MIIM_SUBMENU;
        miiBkColor.hSubMenu = m_hmenuColor;
        SetMenuItemInfo(hmenu, ID_POPUP_BACKGROUND_COLOR, FALSE, &miiBkColor);
    }

    if (!m_hmenuStyle)
    {
        Assert(m_pDoc);
        HrCreateTridentMenu(m_pDoc, TM_TAGMENU, ID_FORMAT_FIRST, ID_FORMAT_FIRST - ID_FORMAT_LAST, &m_hmenuStyle);
        Assert(m_hmenuStyle);
    }

    if(m_hmenuStyle)
    {
        VARIANTARG  va;        
        MENUITEMINFO miiTag;

        HrCheckTridentMenu(m_pDoc, TM_TAGMENU, ID_FORMAT_FIRST, ID_FORMAT_LAST, m_hmenuStyle);

        ZeroMemory(&miiTag, sizeof(miiTag));
        miiTag.cbSize=sizeof(miiTag);
        miiTag.fMask = MIIM_SUBMENU;
        miiTag.hSubMenu = m_hmenuStyle;
        SetMenuItemInfo(hmenu, ID_POPUP_STYLE, FALSE, &miiTag);
    }
    return S_OK;
}

// ********************************************
void CMimeEditDocHost::UpdateInsertMenu(HMENU hmenu)
{
}

// ********************************************
void CMimeEditDocHost::UpdateEditMenu(HMENU hmenu)
{
}

// ********************************************
void CMimeEditDocHost::UpdateViewMenu(HMENU hmenu)
{
}

// ********************************************
HRESULT CMimeEditDocHost::HrOnInitMenuPopup(HMENU hmenuPopup, UINT uID)
{
    if (m_pCmdTarget)
    {
        switch (uID)
        {
            case ID_POPUP_FILE:
                break;

            case ID_POPUP_FORMAT:
                break;

            case ID_POPUP_LANGUAGE:
            {
                // Now Let's try to insert document direction menu if applicable
                VARIANTARG v = {0};
                HRESULT hr;
                hr = m_pCmdTarget->Exec(&CGID_ShellDocView,SHDVID_GETDOCDIRMENU, OLECMDEXECOPT_DODEFAULT, NULL, &v);
                if (S_OK == hr)
                {
                     MENUITEMINFOW mii;
                     HMENU hmenuDocDir = (HMENU)IntToPtr(v.lVal);
                     UINT uItemDir = 0, uItem = GetMenuItemCount(hmenuPopup);                 
                     WCHAR wszText[MAX_PATH];

                     ZeroMemory(&mii, sizeof(MENUITEMINFO));
                     mii.cbSize = sizeof(MENUITEMINFO);                     
                     mii.cbSize = sizeof(MENUITEMINFO);
                     mii.fMask = MIIM_TYPE;
                     mii.fType = MFT_SEPARATOR;

                     InsertMenuItemWrapW(hmenuPopup, (UINT)uItem, TRUE, &mii);
        
                     mii.fMask = MIIM_CHECKMARKS|MIIM_DATA|MIIM_ID|MIIM_STATE|MIIM_SUBMENU|MIIM_TYPE;
                     mii.fType = MFT_STRING;
                     mii.dwTypeData = wszText;
                     mii.cch = MAX_PATH;

                     while (GetMenuItemInfoWrapW(hmenuDocDir, uItemDir, TRUE, &mii))
                     {
                         mii.wID = ID_DOCDIR_LTR + uItemDir;
                         mii.fType |= MFT_RADIOCHECK;
                         mii.cch = ARRAYSIZE(wszText);
                         InsertMenuItemWrapW(hmenuPopup, (UINT)(uItemDir + uItem + 1), TRUE, &mii);
                         uItemDir++;
                     }
                }
            }
                break;    
            
            case ID_POPUP_INSERT:
                UpdateInsertMenu(hmenuPopup);
                break;

            case ID_POPUP_EDIT:
                UpdateEditMenu(hmenuPopup);
                break;

            case ID_POPUP_VIEW:
                UpdateViewMenu(hmenuPopup);
                break;

            case ID_POPUP_TOOLS:
                break;

        }
    }
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    TCHAR   szRes[CCHMAX_STRINGRES];

    if (!m_pStatus)
        return S_FALSE;

    if (LOWORD(wParam)>=ID_LANG_FIRST && LOWORD(wParam) <= ID_LANG_LAST)
    {
        m_pStatus->ShowSimpleText(MAKEINTRESOURCE(idsViewLanguageGeneralHelp));
        return S_OK;
    }

    if (LOWORD(wParam)>=ID_FORMAT_FIRST && LOWORD(wParam)<=ID_FORMAT_LAST)
    {
        // ~~~ did I choose the correct item for idsFmtTagGeneralHelp
        m_pStatus->ShowSimpleText(MAKEINTRESOURCE(ID_HELP_CONTENTS));
        return S_OK;
    }

    return S_FALSE;
}

// ********************************************
HRESULT CMimeEditDocHost::HrCheckColor()
{
    HRESULT     hr;
    INT         iFound = -1;
    DWORD       dwRGB;

    hr = ExecGetI4(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDCOLOR, &dwRGB);
    if (0 == dwRGB)
        iFound = 0;
    else
        iFound = GetColorIndex(dwRGB) - 1;

    CheckMenuRadioItem(m_hmenuColor, ID_FORMAT_COLOR1, ID_FORMAT_COLOR16, ID_FORMAT_COLOR1 + iFound, MF_BYCOMMAND);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMDrawMenuItem(HWND hwnd, LPDRAWITEMSTRUCT pdis)
{
    // There is a bug in win95 that will sign extend the ID so that the
    // hiword is filled with FFFF. Take the low word of the ID to work
    // around this.
    UINT    id = LOWORD(pdis->itemID);

    if (id >= ID_FORMAT_COLOR1 && id <=ID_FORMAT_COLOR16)
        Color_WMDrawItem(pdis, iColorMenu);

    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMMeasureMenuItem(HWND hwnd, LPMEASUREITEMSTRUCT pmis)
{
    HDC     hdc;
    UINT    id = pmis->itemID;

    if (id >= ID_FORMAT_COLOR1 && id <=ID_FORMAT_COLOR16)
    {
        hdc = GetDC(hwnd);
        if(hdc)
        {
            Color_WMMeasureItem(hdc, pmis, iColorMenu);
            ReleaseDC( hwnd, hdc );
        }
    }
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrBackgroundImage()
{
    WCHAR   wszURL[INTERNET_MAX_URL_LENGTH+10];
    LPWSTR  pwszBackName;
    HRESULT hr = S_OK;

    *wszURL = 0;
    hr = ExecGetTextW(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, &pwszBackName);
    // ~~~ MimeEdit returns E_FAIL if no image found. MimeEdit will change to return S_OK is this case
    // Once it is changed can delete these lines.
    if (E_FAIL == hr)
        hr = S_OK;

    IF_FAILEXIT(hr);

    if (pwszBackName != NULL)
        StrCpyNW(wszURL, pwszBackName, INTERNET_MAX_URL_LENGTH);

    if(DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddBkImage), m_hwnd, BkImageDlgProc, (LPARAM)wszURL)==IDCANCEL)
    {
        hr = S_OK;
        goto exit;
    }

    // nothing has been changed, so do nothing.
    if ((pwszBackName!=NULL && StrCmpIW(pwszBackName, wszURL)==0) ||
        // there is no background at all.
        (pwszBackName==NULL && lstrlenW(wszURL)==0))
        goto exit;

    InsertStationeryDir(wszURL);

    hr = ExecSetTextW(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, wszURL);

exit:
    MemFree(pwszBackName);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrWMCommand(HWND hwnd, int id, WORD wCmd)
{
    DWORD   dwStdCmd = 0,
            dwMECmd = 0,
            dwF3Cmd = 0;
    DWORD   dw;
    ULONG   cmdf;

    if(!m_pCmdTarget)
        return S_FALSE;

    // commands that don't care if we're UI Active

    if (id >= ID_FORMAT_COLOR1 && id <= ID_FORMAT_COLOR16)
    {
        int index = id - ID_FORMAT_COLOR1;
        ExecSetI4(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDCOLOR, rgrgbColors16[index]);
        return S_OK;
    }

    switch(id)
    {
        case ID_INSERT_TEXT:
            HrInsertTextFileFromDialog();
            return S_OK;

        case ID_SOURCE_EDIT:
            // toggle stat
            cmdf=0;
            QuerySingleMimeEditCmd(MECMDID_SHOWSOURCETABS, &cmdf);
            dw = !(cmdf & OLECMDF_LATCHED);
            SetDwOption(OPT_VIEWSOURCETABS, dw, 0, 0);
            ExecSetBool(&CMDSETID_MimeEdit, MECMDID_SHOWSOURCETABS, dw);
            return S_OK;

        case ID_SAVE_ATTACHMENTS:
        case ID_NOTE_SAVE_ATTACHMENTS:
            dwMECmd = MECMDID_SAVEATTACHMENTS;
            break;

        case ID_PRINT:
        case ID_PRINT_NOW:
            HrPrint(id == ID_PRINT);
            return S_OK;

        case ID_SAVE_STATIONERY:
        case ID_NOTE_SAVE_STATIONERY:
            HrSaveAsStationery(NULL);
            return S_OK;

        case ID_UNSCRAMBLE:
            HrPerformROT13Encoding();
            return S_OK;

        case ID_VIEW_MSG_SOURCE:
            HrViewSource(MECMD_VS_MESSAGE);
            return S_OK;

        case ID_VIEW_SOURCE:
            HrViewSource(MECMD_VS_HTML);
            return S_OK;

        case ID_BACKGROUND_SOUND:
            HrBackgroundSound();
            return S_OK;

        case ID_BACKGROUND_PICTURE:
            HrBackgroundImage();
            return S_OK;

        case ID_FIND_TEXT:
            dwStdCmd = OLECMDID_FIND;
            break;

        case ID_FONTS_DIALOG:
            dwMECmd = MECMDID_FORMATFONT;
            break;

        case ID_FORMAT_PARADLG:
            dwMECmd = MECMDID_FORMATPARAGRAPH;
            break;

        case ID_FONTS_LARGEST:
        case ID_FONTS_LARGE:
        case ID_FONTS_MEDIUM:
        case ID_FONTS_SMALL:
        case ID_FONTS_SMALLEST:
            dwF3Cmd = IDM_BASELINEFONT1 + id - ID_FONTS_SMALLEST;
            break;

        case ID_FONTS_FIXED:
            m_fFixedFont = !m_fFixedFont;
            if (m_fFixedFont)
                ExecSetBool(&CMDSETID_MimeEdit, MECMDID_DOWNGRADEPLAINTEXT, TRUE);
            else
                m_pPrstMime->Load(m_pMsg);
            return S_OK;

        case ID_DOCDIR_LTR:
            dwF3Cmd = IDM_DIRLTR;
            break;
        case ID_DOCDIR_RTL:
            dwF3Cmd = IDM_DIRRTL;
            break;
    }

    // commands that are only applicable to UI if we're UIActive
    if(m_fUIActive)
    {
        if ((ID_INSERT_SIGNATURE == id) || (id >= ID_SIGNATURE_FIRST && id <= ID_SIGNATURE_LAST))
        {
            HrInsertSignature(id);
            return S_OK;
        }

        if (id >= ID_FORMAT_FIRST && id <= ID_FORMAT_LAST)
        {
            TCHAR szBuf[MAX_PATH];
            *szBuf = 0;
            GetMenuString(m_hmenuStyle, id, szBuf, MAX_PATH, MF_BYCOMMAND);
            Assert(*szBuf);//should not be empty

            SideAssert(ExecSetText(&CMDSETID_Forms3, IDM_BLOCKFMT, szBuf) == S_OK);
            return S_OK;
        }

        switch(id)
        {
            case ID_PASTE:
                if(HrPasteToAttachment()!=S_OK)
                    dwStdCmd = OLECMDID_PASTE;
                break;

            case ID_EDIT_LINK:
                return m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_HYPERLINK, 
                        OLECMDEXECOPT_PROMPTUSER, NULL, NULL);

            case ID_SELECT_ALL: 
                dwStdCmd = OLECMDID_SELECTALL;
                break;

            case ID_CUT:        
                dwStdCmd = OLECMDID_CUT; 
                break;

            case ID_COPY:       
                dwStdCmd = OLECMDID_COPY;
                break;

            case ID_NOTE_COPY:  
                dwStdCmd = OLECMDID_COPY;
                break;

            case ID_UNDO:       
                dwStdCmd = OLECMDID_UNDO;
                break;

            case ID_REDO:       
                dwStdCmd = OLECMDID_REDO;
                break;

            case ID_UNLINK:             
                dwF3Cmd = IDM_UNLINK;
                break;

            case ID_INSERT_PICTURE:  
                dwF3Cmd = IDM_IMAGE; 
                break;

            case ID_INSERT_LINE:        
                dwF3Cmd = IDM_HORIZONTALLINE;
                break;

            case ID_INDENT_INCREASE:    
                dwF3Cmd = IDM_INDENT; 
                break;

            case ID_INDENT_DECREASE:  
                dwF3Cmd = IDM_OUTDENT;
                break;

        }
    }

    // Catch all standard group commands and execute them
    if (dwStdCmd)
    {
        ExecCommand(NULL, dwStdCmd);
        return S_OK;
    }

    // Catch all MimeEdit group commands and execute them
    else if (dwMECmd)
    {
        ExecCommand(&CMDSETID_MimeEdit, dwMECmd);
        return S_OK;
    }

    // Catch all Forms3 group commands and execute them
    else if (dwF3Cmd)
    {
        ExecCommand(&CMDSETID_Forms3, dwF3Cmd);
        return S_OK;
    }

    return OLECMDERR_E_NOTSUPPORTED;
}

// ********************************************
HRESULT CMimeEditDocHost::HrPasteToAttachment()
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrGetWindow(HWND *pHwnd)
{
    if(pHwnd==NULL)
        return E_INVALIDARG;

    *pHwnd=m_hwnd;
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetSize(LPRECT prc)
{
    SetWindowPos(m_hwnd, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOZORDER);
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::HrMarkAsRead()
{
    // ignore if already read
    if(!m_fMarkedRead && !m_fSecDispInfo)
    {
        if (m_pEventSink)
            m_pEventSink->EventOccurred(MEHC_CMD_MARK_AS_READ, NULL);
        m_fMarkedRead=TRUE;
    }

    return NOERROR;
}

// ********************************************
void CMimeEditDocHost::OnWMTimer()
{
    // user has been looking at the message for >2 secs,
    // mark message as read now.
    DOUTL(4, "MAR: Timer:: messages marked as read now");
    KillTimer(m_hwnd, idTimerMarkAsRead);
    HrMarkAsRead();
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetNoSecUICallback(DWORD dwCookie, PFNNOSECUI pfnNoSecUI)
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetDragSource(BOOL fIsSource)
{
    return E_NOTIMPL;
}

// ********************************************
HRESULT CMimeEditDocHost::HrTranslateAccelerator(LPMSG lpMsg)
{
    
    // this code will attempt to get ctrl-tab working in source-view
    // problem is we uideactivate trident and our host doesn't call our 
    // translateaccel is we're not uiactive. so we have to fudge activation.
    // I turned off for beta1
    if (lpMsg->message == WM_KEYDOWN && 
        (lpMsg->wParam == VK_TAB) &&
        (GetKeyState(VK_CONTROL)&0x8000))
        {
        // if showing the TAB's then control-tab should cycle them
        CycleSrcTabs(!(GetKeyState(VK_SHIFT)&0x8000));
        return S_OK;
        }

    if (!m_fUIActive || !m_pInPlaceActiveObj)
        return S_FALSE;

    return m_pInPlaceActiveObj->TranslateAccelerator(lpMsg);
}

// ********************************************
HRESULT CMimeEditDocHost::HrUIActivate(BOOL fActivate)
{
    HRESULT             hr=NOERROR;

    if (m_pDocView)
        hr = m_pDocView->UIActivate(fActivate);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetUIActivate()
{

    SetFocus(m_hwndDocObj);
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::HrFrameActivate(BOOL fActivate)
{
    IOleInPlaceActiveObject     *pIPAO;

    // we QI mimeedit to make sure we always pass it the frame activates so it can disable sound playing
    // we can't use m_pInPlaceObject as it's only sent when we're UIActive.
    if (m_lpOleObj &&
        m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pIPAO)==S_OK)
    {
        pIPAO->OnFrameWindowActivate(fActivate);
        pIPAO->Release();
    }
    return S_OK;        
}

// ********************************************
HRESULT CMimeEditDocHost::HrHasFocus()
{
    return m_fUIActive ? S_OK : S_FALSE;
}

// ********************************************
void CMimeEditDocHost::EnableStandardCmd(UINT idm, LPBOOL pbEnable)
{
    OLECMD  cmdEdit;

    Assert(pbEnable);

    cmdEdit.cmdf=0;

    switch(idm)
    {
        case ID_CUT:
            cmdEdit.cmdID = OLECMDID_CUT;
            break;

        case ID_NOTE_COPY:
        case ID_COPY:
            cmdEdit.cmdID = OLECMDID_COPY;
            break;

        case ID_PASTE:
            cmdEdit.cmdID = OLECMDID_PASTE;
            break;

        case ID_SELECT_ALL:
            cmdEdit.cmdID = OLECMDID_SELECTALL;
            break;

        case ID_UNDO:
            cmdEdit.cmdID = OLECMDID_UNDO;
            break;

        default:
            // Should never get here.
            Assert(FALSE);
    }

    if (m_pCmdTarget && SUCCEEDED(m_pCmdTarget->QueryStatus(NULL, 1, &cmdEdit, NULL)))
            *pbEnable = (cmdEdit.cmdf & OLECMDF_ENABLED);
}


// ********************************************
//  HrRegisterNotify:
//
//  Purpose:
//      Generic version of HrRegisterLoadNotify.  This allows
//      a client (like CSecMsgService) to give enough information
//      to become an event sink
//  Takes:
//      fRegister   - TRUE if we're calling Advise
//      szElement   - [OPTIONAL] if given, we'll get that IHTMLElement
//                    and use it for the IConnectionPointContainer
//      riidSink    - IID for the connection point to find
//      pUnkSink    - IUnknown of our sink object
//      pdwCookie   - [OUT] cookie needed for Unadvise
//  Returns:
//      Trident HRs.
//
HRESULT CMimeEditDocHost::HrRegisterNotify(
    BOOL        fRegister,
    LPCTSTR     szElement,
    REFIID      riidSink,
    IUnknown   *pUnkSink,
    DWORD      *pdwCookie)
{
    IConnectionPointContainer  *pCPContainer=0;
    IConnectionPoint           *pCP=0;
    IHTMLElement               *pElem=0;
    HRESULT                     hr;

    if (!m_pDoc || !pdwCookie)
        return E_POINTER;
    if (fRegister && !pUnkSink)
        return E_POINTER;

    if (szElement)
    {
        hr = HrGetElement(szElement, &pElem);
        if (SUCCEEDED(hr))
        {
            hr = pElem->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
            pElem->Release();
        }
    }
    else
    {
        hr = m_pDoc->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
    }
    if (FAILED(hr))
        goto error;

    hr = pCPContainer->FindConnectionPoint(riidSink, &pCP);
    pCPContainer->Release();
    if (FAILED(hr))
        goto error;

    if (fRegister)
    {
        Assert(*pdwCookie == 0);

        hr = pCP->Advise(pUnkSink, pdwCookie);
        if (FAILED(hr))
            goto error;
    }
    else if (*pdwCookie)
    {
        hr = pCP->Unadvise(*pdwCookie);
        *pdwCookie = NULL;
    }

error:
    ReleaseObj(pCP);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::RegisterForHTMLDocEvents(BOOL fOn)
{
    if (fOn == !!m_fRegisteredForDocEvents)
        return S_OK;

    m_fRegisteredForDocEvents = !!fOn;

    return HrRegisterNotify(fOn, NULL, DIID_HTMLDocumentEvents2, 
                fOn ? ((IUnknown *)(IDispatch *)this) : NULL, 
                &m_dwHTMLNotifyCookie);
}

// ********************************************
HRESULT CMimeEditDocHost::PublicFilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    IDocHostUIHandler   *pDHHand = NULL;
    IServiceProvider    *pSP = NULL;
    HRESULT             hr = S_OK;

    // RAID 12020. Need to get IDocHostUIHandler of the body obj
    hr = m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID*)&pSP);
    if (SUCCEEDED(hr))
    {
        hr = pSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID*)&pDHHand);
        if (SUCCEEDED(hr))
        {
            hr = pDHHand->FilterDataObject(pDO, ppDORet);
            pDHHand->Release();
        }
        pSP->Release();
    }

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::HrSaveAttachment()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_SAVEATTACHMENTS);
}

// ********************************************
HRESULT CMimeEditDocHost::HrSetBkGrndPicture(LPTSTR pszPicture)
{
    return ExecSetText(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, pszPicture);
}

// ********************************************
HRESULT CMimeEditDocHost::ShowContextMenu(
                DWORD dwID,
                POINT *ppt,
                IUnknown *pcmdtReserved,
                IDispatch *pdispReserved)
{
    return MIMEEDIT_E_DODEFAULT;
}
// ********************************************
HRESULT CMimeEditDocHost::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
                IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::HideUI()
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::UpdateUI()
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::EnableModeless(BOOL fActivate)
{
    // we don't have to support this, as any disable on a toplevel causes thread
    // windows to get disabled anyway
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::OnDocWindowActivate(BOOL fActivate)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::OnFrameWindowActivate(BOOL fActivate)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    TCHAR   szPath[MAX_PATH];
    // dupW uses CoTaskMemAlloc
    StrCpyN(szPath, MU_GetRegRoot(), ARRAYSIZE(szPath));
    StrCatBuff(szPath, c_szTrident, ARRAYSIZE(szPath));

    *pchKey = PszToUnicode(CP_ACP, szPath);
    if (szPath && !(*pchKey))
        return (TraceResult(E_OUTOFMEMORY));

    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    BOOL fEditModeOn = FALSE;
    if (FAILED(HrIsEditMode(&fEditModeOn)) || !fEditModeOn)
        return S_FALSE;

    *ppDropTarget = (IDropTarget*)SendMessage(GetParent(m_hwnd), NWM_GETDROPTARGET, (WPARAM)pDropTarget, 0);
    return NOERROR;
}

// ********************************************
HRESULT CMimeEditDocHost::GetExternal(IDispatch **ppDispatch)
{
    return QueryInterface(IID_IDispatch, (LPVOID *)ppDispatch);
}

// ********************************************
HRESULT CMimeEditDocHost::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::FilterDataObject( IDataObject *pDO, IDataObject **ppDORet)
{
    return MIMEEDIT_E_DODEFAULT;
}

// ********************************************
HRESULT CMimeEditDocHost::OnChanged(DISPID dispid)
{
    if (dispid == DISPID_READYSTATE)
        OnReadyStateChanged();
    return S_OK;
}

// ********************************************
HRESULT CMimeEditDocHost::OnRequestEdit (DISPID dispid)
{
    return S_OK;
}


// ********************************************
void CMimeEditDocHost::OnDocumentReady()
{
    NMHDR   nmhdr;

    // Bug 74697
    // Under certain circumstances, Darwin causes Trident to send us IDM_PARSECOMPLETE
    // when we don't even have a message.  To prevent spurious errors, bail out.
    if (!m_pMsg)
        return;

    if(m_fSecDispInfo)
    {
        VARIANTARG  va;

        if(!m_pCmdTarget)
            return;

        if(m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK &&
            va.lVal == MESTYLE_PREVIEW)
            return;

        ExecSetBool(&CMDSETID_MimeEdit, MECMDID_TABLINKS, TRUE);

        return;
    }

    nmhdr.hwndFrom = m_hwnd;
    nmhdr.idFrom = GetDlgCtrlID(m_hwnd);
    nmhdr.code = BDN_DOWNLOADCOMPLETE;
    SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetBool(const GUID *guid, DWORD cmd, BOOL *pfValue)
{
    VARIANTARG var;
    V_VT(&var) = VT_BOOL;

    if (!m_pCmdTarget)
        return E_FAIL;

    HRESULT hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var);
    if (SUCCEEDED(hr))
        *pfValue = (VARIANT_TRUE == V_BOOL(&var)) ? TRUE : FALSE;
    else
        *pfValue = FALSE;

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetBool(const GUID *guid, DWORD cmd, BOOL fValue)
{
    VARIANTARG var;

    if (!m_pCmdTarget)
        return E_FAIL;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = fValue ? VARIANT_TRUE : VARIANT_FALSE;

    return m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL);
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetI4(const GUID *guid, DWORD cmd, DWORD *pdwValue)
{
    VARIANTARG var;
    HRESULT hr;
    V_VT(&var) = VT_I4;

    hr = m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var) : E_FAIL;

    *pdwValue = (SUCCEEDED(hr) ? V_I4(&var) : 0);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetI4(const GUID *guid, DWORD cmd, DWORD dwValue)
{

    VARIANTARG var;
    V_VT(&var) = VT_I4;
    V_I4(&var) = dwValue;

    return  m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL) : E_FAIL;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetI8(const GUID *guid, DWORD cmd, ULONGLONG *pullValue)
{
    VARIANTARG var;
    HRESULT hr;
    V_VT(&var) = VT_I8;

    hr = m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var) : E_FAIL;

    *pullValue = (SUCCEEDED(hr) ? V_UNION(&var, ullVal) : 0);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetI8(const GUID *guid, DWORD cmd, ULONGLONG ullValue)
{

    VARIANTARG var;
    V_VT(&var) = VT_I8;
    V_UNION(&var, ullVal) = ullValue;

    return  m_pCmdTarget ? m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL) : E_FAIL;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetText(const GUID *guid, DWORD cmd, LPSTR psz)
{
    BSTR        bstr = NULL;
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);
    
    IF_FAILEXIT(hr = HrLPSZToBSTR(psz, &bstr));

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL));

exit:
    SysFreeString(bstr);
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecSetTextW(const GUID *guid, DWORD cmd, LPWSTR pwsz)
{
    BSTR        bstr = NULL;
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);
    
    IF_NULLEXIT(bstr = SysAllocString(pwsz));

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, &var, NULL));

exit:
    SysFreeString(bstr);

    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetText(const GUID *guid, DWORD cmd, LPSTR *ppsz)
{
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    *ppsz = NULL;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var));

    Assert(V_VT(&var) == VT_BSTR);
    hr = HrBSTRToLPSZ(CP_ACP, V_BSTR(&var), ppsz);
    SysFreeString(V_BSTR(&var));

    IF_FAILEXIT(hr);

exit:
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecGetTextW(const GUID *guid, DWORD cmd, LPWSTR *ppwsz)
{
    VARIANTARG  var;
    HRESULT     hr = S_OK;

    V_VT(&var) = VT_EMPTY;

    if (!m_pCmdTarget)
        IF_FAILEXIT(hr = E_FAIL);

    *ppwsz = NULL;

    IF_FAILEXIT(hr = m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, &var));

    Assert(V_VT(&var) == VT_BSTR);
    IF_NULLEXIT(*ppwsz = PszDupW(V_BSTR(&var)));

exit:
    if (VT_EMPTY != V_VT(&var))
        SysFreeString(V_BSTR(&var));
    return hr;
}

// ********************************************
HRESULT CMimeEditDocHost::ExecCommand(const GUID *guid, DWORD cmd)
{
    if (!m_pCmdTarget)
        return E_FAIL;

    return m_pCmdTarget->Exec(guid, cmd, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
}

// ********************************************
void CMimeEditDocHost::OnReadyStateChanged()
{
    // MimeEdit keeps track of state for us. Left
    // this in in case there is a need to have it
    // in the future.
}

HRESULT CMimeEditDocHost::HrHandsOffStorage()
{
    if (m_pMsg)
        m_pMsg->HandsOffStorage();
    if (m_pSecureMessage)
        m_pSecureMessage->HandsOffStorage();
    if (m_pSecurityErrorScreen)
        m_pSecurityErrorScreen->HandsOffStorage();
    return S_OK;
}

HRESULT CMimeEditDocHost::HrRefresh()
{
    if (m_pCmdTarget)
        ExecCommand(NULL, OLECMDID_REFRESH);

    return S_OK;
}


HRESULT CMimeEditDocHost::HrBackgroundSound()
{
    return ExecCommand(&CMDSETID_MimeEdit, MECMDID_INSERTBGSOUND);
}


HRESULT CMimeEditDocHost::QuerySingleMimeEditCmd(ULONG uCmd, ULONG *pcmdf)
{
    OLECMD  cmd={uCmd, 0};
        
    if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_MimeEdit, 1, &cmd, NULL))
    {
        *pcmdf = cmd.cmdf;
        return S_OK;
    }
    
    return E_FAIL;
}

HRESULT CMimeEditDocHost::QuerySingleFormsCmd(ULONG uCmd, ULONG *pcmdf)
{
    OLECMD  cmd={uCmd, 0};
        
    if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, 1, &cmd, NULL))
    {
        *pcmdf = cmd.cmdf;
        return S_OK;
    }
    
    return E_FAIL;
}

HRESULT CMimeEditDocHost::QuerySingleStdCmd(ULONG uCmd, ULONG *pcmdf)
{
    OLECMD  cmd={uCmd, 0};
        
    if (m_pCmdTarget && S_OK==m_pCmdTarget->QueryStatus(NULL, 1, &cmd, NULL))
    {
        *pcmdf = cmd.cmdf;
        return S_OK;
    }
    
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
//  IDispatch
//
/////////////////////////////////////////////////////////////////////////////

// This is a really lightweight IDispatch implementation.  We only expect
// to get invoked.  Trident will call IDispatch::Invoke with the dispID
// of the event that happened or property that changed.

STDMETHODIMP CMimeEditDocHost::GetIDsOfNames(
    REFIID      riid,
    OLECHAR **  rgszNames,
    UINT        cNames,
    LCID        lcid,
    DISPID *    rgDispId)
{
    if (cNames==1 && StrCmpIW(rgszNames[0], L"hotmail")==0)
    {
        rgDispId[0] = 666;
        return S_OK;
    }
    return E_NOTIMPL;
}

STDMETHODIMP CMimeEditDocHost::GetTypeInfo(
    UINT        /*iTInfo*/,
    LCID        /*lcid*/,
    ITypeInfo **ppTInfo)
{
    if (ppTInfo)
        *ppTInfo=NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CMimeEditDocHost::GetTypeInfoCount(UINT *pctinfo)
{
    if (pctinfo)
    {
        *pctinfo=0;
        return NOERROR;
    }
    else
        return E_POINTER;
}

STDMETHODIMP CMimeEditDocHost::Invoke(
    DISPID          dispIdMember,
    REFIID          /*riid*/,
    LCID            /*lcid*/,
    WORD            wFlags,
    DISPPARAMS FAR* /*pDispParams*/,
    VARIANT *       pVarResult,
    EXCEPINFO *     /*pExcepInfo*/,
    UINT *          /*puArgErr*/)
{
    IHTMLWindow2        *pWindow=0;
    IHTMLEventObj       *pEvent=0;
    IHTMLElement        *pElem=0;
    BSTR                bstr=0;
    HRESULT             hr=E_NOTIMPL;


    if (dispIdMember == 666 && 
        wFlags & DISPATCH_PROPERTYGET)
    {
        // hotmail on/off for welcome message
        pVarResult->vt = VT_BOOL;
        pVarResult->boolVal = HideHotmail() ? VARIANT_FALSE : VARIANT_TRUE;
        return S_OK;
    }
    // Currently we only care about the button clicks.
    if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONCLICK &&
        (wFlags & DISPATCH_METHOD))
    {
        // Order of events:
        // document gives us window gives us event object
        // the event object can tell us which button was clicked
        // event gives us source element gives us ID
        // a couple lstrcmps will tell us which one got hit
        if (!m_pDoc)
            return E_UNEXPECTED;

        m_pDoc->get_parentWindow(&pWindow);
        if (pWindow)
        {
            pWindow->get_event(&pEvent);
            if (pEvent)
            {
                pEvent->get_srcElement(&pElem);
                if (pElem)
                {
                    pElem->get_id(&bstr);
                    if (bstr)
                    {
                        hr = HandleButtonClicks(bstr);
                        SysFreeString(bstr);
                    }
                    pElem->Release();
                }
                pEvent->Release();
            }
            pWindow->Release();
        }
    }
    return hr;
}

HRESULT CMimeEditDocHost::SetEventSink(IMimeEditEventSink *pEventSink)
{
    ReplaceInterface(m_pEventSink, pEventSink);
    return S_OK;
}


typedef struct tagCOMMANDSTRUCT {
    WCHAR  *string;
    DWORD   id;
} COMMANDSTRUCT, *LPCOMMANDSTRUCT;

COMMANDSTRUCT rgszCmdStrings[] = 
{
    {L"btnOpen",        MEHC_BTN_OPEN},
    {L"btnCert",        MEHC_BTN_CERT},
    {L"btnTrust",       MEHC_BTN_TRUST},
    {L"btnContinue",    MEHC_BTN_CONTINUE},
    {L"cmdConnect",     MEHC_CMD_CONNECT},
    {L"cmdDownload",    MEHC_CMD_DOWNLOAD},
};

HRESULT CMimeEditDocHost::HandleButtonClicks(BSTR bstr)
{
    HRESULT         hr = S_OK;
    LPCOMMANDSTRUCT prg = rgszCmdStrings;
    DWORD           cmdID=0;
    BOOL            fFound = FALSE;

    Assert(bstr);

    for (int i = 0; i < ARRAYSIZE(rgszCmdStrings); i++, prg++)
    {
        if (!StrCmpW(prg->string, bstr))
        {
            cmdID = prg->id;
            fFound = TRUE;
            break;
        }
    }

    if (fFound)
    {
        // The notification needs to happen after the preview pane 
        // updates.  Since there's no notifications here that actually
        // return anything but S_FALSE I think this is pretty safe.
        //   -- From "The famous last words of Steve Serdy"
        switch (cmdID)
        {
            case MEHC_BTN_OPEN: 
                hr = DoHtmlBtnOpen(); 
                // Now we need update toolbar
                m_pEventSink->EventOccurred(cmdID, NULL);
                break;

            case MEHC_BTN_CERT:
            case MEHC_BTN_TRUST:
                hr = DoHtmlBtnCertTrust(cmdID);
                break;

            case MEHC_BTN_CONTINUE:
                hr = DoHtmlBtnContinue();
                break;

            default:
                hr = E_NOTIMPL;
        }

        if (m_pEventSink && (cmdID != MEHC_BTN_OPEN))
            hr = m_pEventSink->EventOccurred(cmdID, NULL);
    }

    return hr;
}

HRESULT CMimeEditDocHost::DoHtmlBtnOpen(void)
{
    IHTMLElement *  pElem = NULL;
    HRESULT hr;

    m_fSecDispInfo = FALSE;
    // this process is non-critical; don't save errors
    HrGetElementImpl(m_pDoc, c_szHTMLIDchkShowAgain, &pElem);
    if (pElem)
    {
        VARIANT_BOOL    boolVal;

        HrGetSetCheck(FALSE, pElem, &boolVal);
        SafeRelease(pElem);

        if (VARIANT_TRUE == boolVal)
        {
            NMHDR   nmhdr;

            nmhdr.hwndFrom=m_hwnd;
            nmhdr.idFrom=GetDlgCtrlID(m_hwnd);
            nmhdr.code=BDN_MARKASSECURE;
            SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
        }
    }

    AssertSz(m_pSecureMessage, "Secure message should be set at this point");
    hr = InternalLoad(m_pSecureMessage);
    SafeRelease(m_pSecureMessage);

    return hr;
}

HRESULT CMimeEditDocHost::DoHtmlBtnCertTrust(DWORD cmdID)
{
    IMimeBody      *pRoot = NULL;
    HRESULT         hr = S_OK;
    HBODY               hBody = NULL;
    SECSTATE            SecState ={0};

    if(FAILED(HrGetSecurityState(m_pSecureMessage, &SecState, &hBody)))
        return(hr);

    CleanupSECSTATE(&SecState);

    AssertSz(m_pSecureMessage, "Should have a secure message if getting Cert or Trust");
    hr = m_pSecureMessage->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pRoot);
    if (pRoot)
    {
        PROPVARIANT     var;
        HCERTSTORE      hcStore = NULL;

#ifdef _WIN64
        if (SUCCEEDED(pRoot->GetOption(OID_SECURITY_HCERTSTORE_64, &var)) && (var.vt == VT_UI8)) 
            hcStore = (HCERTSTORE)(var.pulVal);

        hr = pRoot->GetOption(OID_SECURITY_CERT_SIGNING_64, &var);
        if (SUCCEEDED(hr))
        {
            if ((PCCERT_CONTEXT)(var.pulVal)) 
            {
                if (MEHC_BTN_CERT == cmdID)
                    // View digital Cert was clicked
                    hr = ViewCertificate((PCCERT_CONTEXT)(var.pulVal), hcStore);
                else
                    // Edit Trust was clicked
                    hr = EditTrust((PCCERT_CONTEXT)(var.pulVal), hcStore);

                CertFreeCertificateContext((PCCERT_CONTEXT)(var.pulVal));
            }
        }
#else   // !_WIN64
        if (SUCCEEDED(pRoot->GetOption(OID_SECURITY_HCERTSTORE, &var)) && (var.vt == VT_UI4)) 
            hcStore = (HCERTSTORE)var.ulVal;
        hr = pRoot->GetOption(OID_SECURITY_CERT_SIGNING, &var);
        if (SUCCEEDED(hr))
        {
            if ((PCCERT_CONTEXT)var.ulVal) 
            {
                if (MEHC_BTN_CERT == cmdID)
                    // View digital Cert was clicked
                    hr = ViewCertificate((PCCERT_CONTEXT)var.ulVal, hcStore);
                else
                    // Edit Trust was clicked
                    hr = EditTrust((PCCERT_CONTEXT)var.ulVal, hcStore);

                CertFreeCertificateContext((PCCERT_CONTEXT )var.ulVal);
            }
        }
#endif  // _WIN64
        SafeRelease(pRoot);
        if (hcStore)
            CertCloseStore(hcStore, 0);
    }

    return hr;
}


HRESULT CMimeEditDocHost::HrScrollPage()
{
    IHTMLWindow2        *pWindow=0;
    IHTMLBodyElement    *pBody;
    IHTMLElement2       *pElem;
    LONG                cyClientHeight=0,
                        cyScrollTop=0,
                        cyScrollHeight=0;
    HRESULT             hr = E_FAIL;

    if (m_pDoc)
        m_pDoc->get_parentWindow(&pWindow);

    if (pWindow)
    {
        if (HrGetBodyElement(m_pDoc, &pBody)==S_OK)
        {
            if (pBody->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElem)==S_OK)
            {
                pElem->get_clientHeight(&cyClientHeight);
                pElem->get_scrollTop(&cyScrollTop);
                pElem->get_scrollHeight(&cyScrollHeight);

                if (!(cyScrollTop + cyClientHeight >= cyScrollHeight))
                {
                    pWindow->scrollBy(0, cyClientHeight);
                    hr = S_OK;
                }
                
                pElem->Release();
            }
            pBody->Release();
        }
        pWindow->Release();
    }
    return hr;
}



HRESULT CMimeEditDocHost::DoHtmlBtnContinue(void)
{
    HRESULT         hr;
    IHTMLElement   *pElem = NULL;

    // this process is non-critical; don't save errors
    HrGetElementImpl(m_pDoc, c_szHTMLIDchkShowAgain, &pElem);
    if (pElem)
    {
        VARIANT_BOOL boolVal;

        HrGetSetCheck(FALSE, pElem, &boolVal);
        if (VARIANT_TRUE == boolVal)
        {
            if (m_fIsSigned)
                SetDontShowAgain(1, c_szDSDigSigHelp);
            if (m_fIsEncrypted)
                SetDontShowAgain(1, c_szDSEncryptHelp);
        }

        pElem->Release();
    }

    if (m_pSecurityErrorScreen)
    {
        m_fSecDispInfo = TRUE;
        hr = InternalLoad(m_pSecurityErrorScreen);
        SafeRelease(m_pSecurityErrorScreen);
    }
    else
    {
        m_fSecDispInfo = FALSE;
        AssertSz(m_pSecureMessage, "Secure message should be set at this point.");
        hr = InternalLoad(m_pSecureMessage);
        RegisterForHTMLDocEvents(FALSE);
        SafeRelease(m_pSecureMessage);
    }

    return hr;
}

HRESULT CopySecurePropsToMessage(IMimeMessage *pDestMsg, IMimePropertySet *pPropSet)
{
    IMimePropertySet   *pNewProps = NULL;
    HRESULT             hr;

    hr = pDestMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pNewProps);
    if (SUCCEEDED(hr))
    {
        hr = pPropSet->CopyProps(0, NULL, pNewProps);
        pNewProps->Release();
    }
    return hr;
}

LPCSTR rgszHdrKeep[] = {
            PIDTOSTR(PID_HDR_NEWSGROUP),
            PIDTOSTR(PID_HDR_NEWSGROUPS),
            PIDTOSTR(PID_HDR_SUBJECT),
            PIDTOSTR(PID_HDR_FROM),
            PIDTOSTR(PID_HDR_APPARTO),
            PIDTOSTR(PID_HDR_DATE),
            PIDTOSTR(PID_HDR_REPLYTO),
            PIDTOSTR(PID_HDR_TO),
            PIDTOSTR(PID_HDR_CC),
            PIDTOSTR(PID_HDR_APPROVED),
            PIDTOSTR(PID_HDR_DISTRIB),
            PIDTOSTR(PID_HDR_KEYWORDS),
            PIDTOSTR(PID_HDR_ORG),
            PIDTOSTR(PID_HDR_XMSPRI),
            PIDTOSTR(PID_HDR_XPRI),
            PIDTOSTR(PID_HDR_COMMENT),
            PIDTOSTR(PID_HDR_SENDER)};

HRESULT CMimeEditDocHost::LoadSecurely(IMimeMessage *pMsg, SECSTATE *pSecState)
{
    HRESULT         hr=S_OK;
    BOOL            fNeedIntroScreen = FALSE,
                    fNeedErrorScreen = FALSE,
                    fRegisterDispatch = FALSE;
    LPCTSTR         szIntroResName=NULL;
    IMimeMessage   *pSecurityIntroScreen = NULL;
    DWORD           dwFlags = 0;

    // Since we are reloading, go ahead and free the original secure message if there is one.
    SafeRelease(m_pSecureMessage);
    SafeRelease(m_pSecurityErrorScreen);

    // N2 delete schema
    if (g_dwSecurityCheckedSchemaProp)
    {
        PROPVARIANT var;
        var.vt = VT_UI4;
        if (SUCCEEDED(pMsg->GetBodyProp(HBODY_ROOT, PIDTOSTR(g_dwSecurityCheckedSchemaProp), 0, &var)))
        {
            if (1 == var.lVal)
                goto LoadMessage;
        }
    }

    m_pBodyOptions->GetFlags(&dwFlags);

    if(!m_fSecureReceipt)
    {
        if (0 == (dwFlags & BOPT_SECURITYUIENABLED))
            goto LoadMessage;

        if (m_fIsSigned)
        {
            // don't need warning UI if the cert is trusted and the message is okay
            fNeedErrorScreen = (!m_fSignTrusted && !(dwFlags & BOPT_REPLYORFORWARD));

            // If sig is valid, we should update any certs and SMIMECapabilities in the address book.
            if (m_fSignTrusted && (DwGetOption(OPT_AUTO_ADD_SENDERS_CERT_TO_WAB))) 
            {
                FILETIME ftNull = {0};

                HrAddSenderCertToWab(NULL, pMsg, NULL, NULL, NULL, ftNull, WFF_CREATE);
            }

        // check for help UI
            szIntroResName = c_szDigSigHelpHTML;
            fNeedIntroScreen = ((0 == DwGetDontShowAgain(c_szDSDigSigHelp)) && !(dwFlags & BOPT_REPLYORFORWARD));
        }

        if (m_fIsEncrypted)
        {
            fNeedErrorScreen |= (!m_fEncryptionOK && !(dwFlags & BOPT_REPLYORFORWARD));

            // If want signed intro, don't need to test this one.
            if (!fNeedIntroScreen)
                fNeedIntroScreen = ((0 == DwGetDontShowAgain(c_szDSEncryptHelp)) && !(dwFlags & BOPT_REPLYORFORWARD));

            szIntroResName = (m_fIsSigned ? c_szSAndEHelpHTML : c_szEncryptHelpHTML);
        }
        
        // Bug 2557 - prevent error screen when secure reciept request
        if(pSecState->type & MST_RECEIPT_REQUEST)
            fNeedIntroScreen = FALSE;

        if (fNeedIntroScreen && szIntroResName)
        {
            // Since this is only for the opening screen, if things error, allow
            // the user to continue. In order to allow this, will use a temporary hr.
            HRESULT tempHR;
            IStream *pStm = NULL;

            tempHR = LoadResourceToHTMLStream(szIntroResName, &pStm);
            if (SUCCEEDED(tempHR))
                tempHR = HrCreateMessage(&pSecurityIntroScreen);
            if (SUCCEEDED(tempHR))
                tempHR = pSecurityIntroScreen->Load(pStm);

            ReleaseObj(pStm);

            // If there was an error, don't show the screen and NULL the var
            if (FAILED(tempHR))
                SafeRelease(pSecurityIntroScreen);
        }

        if (fNeedErrorScreen)
        {
            // If have problems here, must exit. Can't show message before showing
            // this error screen.
            IStream *pStm = NULL;

            // Disable check box if message not from the store.
            hr = HrOutputSecurityScript(&pStm, pSecState, (0 == (BOPT_FROMSTORE & dwFlags))); 

            if (SUCCEEDED(hr))
                hr = HrCreateMessage(&m_pSecurityErrorScreen);

            if (SUCCEEDED(hr))
                hr = m_pSecurityErrorScreen->Load(pStm);

            ReleaseObj(pStm);

            if (FAILED(hr))
                SafeRelease(m_pSecurityErrorScreen);
        }
    }
    else
    {
        IImnAccount * pAcct = NULL;
        TCHAR       *pszSubject = NULL;
        TCHAR       *pszFrom = NULL;
        FILETIME    ftSigningTime;
        FILETIME    ftSentTime;
        IStream *pStm = NULL;

        SECSTATE    secStateRec = {0};
//        DWORD       dw = 0;

        // Get account for receipt
        if(m_pBodyOptions->GetAccount(&pAcct) == S_OK)
        {
            // Find original meassage and get information from receipt and orig msg
            hr = HandleSecReceipt(pMsg, pAcct, m_hwnd, &pszSubject, &pszFrom, &ftSentTime, &ftSigningTime);
        }
        else
            hr = MIME_E_SECURITY_RECEIPT_CANTFINDSENTITEM;

            HrGetSecurityState(pMsg, &secStateRec, NULL);
            m_fSignTrusted = !!IsSignTrusted(&secStateRec);

            if(hr == S_OK)
                hr = HrOutputSecureReceipt(&pStm, pszSubject, pszFrom, &ftSentTime, &ftSigningTime, &secStateRec); 
            else if(hr == MIME_S_RECEIPT_FROMMYSELF)
                hr = HrOutputUserSecureReceipt(&pStm, pMsg); 
            else
                hr = HrOutputErrSecReceipt(&pStm, hr, &secStateRec); 

            // Display receipt
            if (SUCCEEDED(hr))
            {
                SafeRelease(m_pSecurityErrorScreen);
                hr = HrCreateMessage(&m_pSecurityErrorScreen);
            }

            
            if (SUCCEEDED(hr))
            {
#ifdef YST
                HBODY       hBody = 0;
                ReplaceInterface(m_pSecurityErrorScreen, pMsg);
                m_pSecurityErrorScreen->SetTextBody(TXT_HTML, IET_CURRENT, NULL, pStm, &hBody);
                HrRemoveAttachments(m_pSecurityErrorScreen, FALSE);
#endif // YST
                hr = m_pSecurityErrorScreen->Load(pStm);
            }

            ReleaseObj(pStm);

            if (FAILED(hr))
                SafeRelease(m_pSecurityErrorScreen);

            // If sig is valid, we should update any certs and SMIMECapabilities in the address book.
            if (m_fSignTrusted && (DwGetOption(OPT_AUTO_ADD_SENDERS_CERT_TO_WAB))) 
            {
                FILETIME ftNull = {0};

                HrAddSenderCertToWab(NULL, pMsg, NULL, NULL, NULL, ftNull, WFF_CREATE);
            }

            CleanupSECSTATE(&secStateRec);
            SafeMemFree(pszSubject);
            SafeMemFree(pszFrom);
            ReleaseObj(pAcct);
    }

    // Reset  m_pSecureMessage before continue
    if(m_pSecureMessage)
        SafeRelease(m_pSecureMessage);

    // If we didn't get any errors and we have some screens 
    // to add, copy props from original message into other screens
    if (SUCCEEDED(hr) && (m_pSecurityErrorScreen || pSecurityIntroScreen))
    {
        IMimePropertySet   *pPropSet = NULL;

        fRegisterDispatch = TRUE;
        ReplaceInterface(m_pSecureMessage, pMsg);

        // Move over the headers
        // If the bind fails, don't worry about it. Just means the headers won't be
        // visable until the normal message is loaded.
        if (SUCCEEDED(m_pSecureMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropSet)))
        {
            IMimePropertySet *pCopyProps = NULL;
            if (SUCCEEDED(pPropSet->Clone(&pCopyProps)))
            {
                if (SUCCEEDED(pCopyProps->DeleteExcept(ARRAYSIZE(rgszHdrKeep), rgszHdrKeep)))
                {
                    if (pSecurityIntroScreen)
                        CopySecurePropsToMessage(pSecurityIntroScreen, pCopyProps);
                    if (SUCCEEDED(hr) && m_pSecurityErrorScreen)
                        CopySecurePropsToMessage(m_pSecurityErrorScreen, pCopyProps);
                }                
                pCopyProps->Release();
            }
            pPropSet->Release();
        }

        // need to init the property
        //N8 talk to Opie about this schema thing.
        // I didn't understand the property concept when I did this.  It
        // works fine, but is too big a hammer for the job.
        if (SUCCEEDED(hr) && !g_dwSecurityCheckedSchemaProp)
        {
            IMimePropertySchema *pSchema = NULL;

            hr = MimeOleGetPropertySchema(&pSchema);
            if (SUCCEEDED(hr))
                hr = pSchema->RegisterProperty("Y-SecurityChecked", 0, 0, VT_LPSTR, &g_dwSecurityCheckedSchemaProp);
            if (pSchema)
                pSchema->Release();
        }
    }

LoadMessage:
    if(m_fSecureReceipt)
    {
            m_fSecDispInfo = FALSE;
            if(m_pSecurityErrorScreen)
                hr = InternalLoad(m_pSecurityErrorScreen);
            // Free all mems
            SafeRelease(m_pSecurityErrorScreen);
    }
    else if (SUCCEEDED(hr))
    {
        if (pSecurityIntroScreen)
        {
            m_fSecDispInfo = TRUE;
            hr = InternalLoad(pSecurityIntroScreen);
            SafeRelease(pSecurityIntroScreen);

        }
        else if (m_pSecurityErrorScreen)
        {
            m_fSecDispInfo = TRUE;
            hr = InternalLoad(m_pSecurityErrorScreen);
            SafeRelease(m_pSecurityErrorScreen);
        }
        else if (m_pSecureMessage)
        {
            m_fSecDispInfo = FALSE;
            hr = InternalLoad(m_pSecureMessage);
            SafeRelease(m_pSecureMessage);
        }
        else
        {
            m_fSecDispInfo = FALSE;
            Assert(!m_pSecurityErrorScreen && !pSecurityIntroScreen);
            hr = InternalLoad(pMsg);
        }
        if (fRegisterDispatch)
            RegisterForHTMLDocEvents(TRUE);

    }

    return hr;
}



HRESULT CMimeEditDocHost::CycleSrcTabs(BOOL fFwd)
{
    ExecSetI4(&CMDSETID_MimeEdit, MECMDID_SETSOURCETAB, fFwd ? MEST_NEXT : MEST_PREVIOUS);
    return S_OK;
}

HRESULT CMimeEditDocHost::HrEnableScrollBars(BOOL fEnable)
{
    HRESULT             hr          = S_OK;
    IHTMLBodyElement    *pBody      = NULL;
    BSTR                bstrValue   = NULL;

    if (m_pDoc)
    {
        IF_FAILEXIT(hr = m_pDoc->get_body((IHTMLElement**)&pBody));

        if (fEnable)
        {
            bstrValue = SysAllocString(L"yes");
        }
        else
        {
            bstrValue = SysAllocString(L"no");
        }

        hr = pBody->put_scroll(bstrValue);
    }

exit:

    ReleaseObj(pBody);
    SysFreeString(bstrValue);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\msgprop.cpp ===
/*
*    m s g p r o p . c p p
*
*    Purpose:
*        Implements propsheet for a msg
*
*    Owner:
*        brettm.
*
*  History:
*      Feb '95: Stolen from Capone Sources - brettm
*
*    Copyright (C) Microsoft Corp. 1993, 1994.
*/

#include <pch.hxx>
#ifdef WIN16
#include "mapi.h"
#endif
#include <resource.h>
#include <richedit.h>
#include "goptions.h"
#include "mimeole.h"
#include "mimeutil.h"
#include "msgprop.h"
#include "addrobj.h"
#include "mpropdlg.h"
#ifndef WIN16
#include "mapi.h"
#endif
#include "ipab.h"
#include <secutil.h>
#include <seclabel.h>
#include <certs.h>
#include <demand.h>
#include <strconst.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "instance.h"
#include "conman.h"
#include "shared.h"
#include "htmlhelp.h"


/*
* m a c r o s   and   c o n s t a n t s
*
*/
#define KILOBYTE 1024L

#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)

#ifdef WIN16
#ifndef GetLastError
#define GetLastError()  ((DWORD)-1)
#endif
#endif //!WIN16


#ifdef WIN16
#define SET_DIALOG_SECURITY(hwnd, value) SetProp32(hwnd, s_cszDlgSec, (LPVOID)value)
#define GET_DIALOG_SECURITY(hwnd)        GetProp32(hwnd, s_cszDlgSec)
#define CLEAR_DIALOG_SECURITY(hwnd)      RemoveProp32(hwnd, s_cszDlgSec);
#else
#define SET_DIALOG_SECURITY(hwnd, value) SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)value)
#define GET_DIALOG_SECURITY(hwnd)        GetWindowLongPtr(hwnd, DWLP_USER);
#define CLEAR_DIALOG_SECURITY(hwnd)      SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)NULL)
#endif



/*
* s t r u c t u r e s
*
*/

struct DLGSECURITYtag
{
    PCX509CERT      pSenderCert;
    PCCERT_CONTEXT  pEncSenderCert;
    PCCERT_CONTEXT  pEncryptionCert;
    THUMBBLOB       tbSenderThumbprint;
    BLOB            blSymCaps;
    FILETIME        ftSigningTime;
    HCERTSTORE      hcMsg;
};
typedef struct DLGSECURITYtag DLGSECURITY;
typedef DLGSECURITY *PDLGSECURITY;
typedef const DLGSECURITY *PCDLGSECURITY;

/*
* c l a s s e s
*
*/


class CMsgProps
{
public:
    CMsgProps();
    ~CMsgProps();
    
    HRESULT HrDoProps(PMSGPROP pmp);
    
    static INT_PTR CALLBACK GeneralPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK DetailsPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK SecurityPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK EncryptionPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
    void InitGeneralPage();
    void InitDetailsPage(HWND hwnd);
    void InitSecurityPage(HWND hwnd);
    
private:
    HIMAGELIST  m_himl;
    HWND        m_hwndGen;
    HWND        m_hwndGenSource;
    PMSGPROP    m_pmp;
};



// Function declarations ////////////////////////////////////////
// msg source dialog is modeless, so it can't be in the CProps dialog.

/*
* p r o t o t y p e s
*
*/
void SecurityOnWMCreate(HWND hwnd, LPARAM lParam);
INT_PTR CALLBACK ViewSecCertDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

/*
* f u n c t i o n s
*
*/


//
//  FUNCTION:   HrMsgProperties()
//
//  PURPOSE:    Displays the property sheet for the specified message.
//
//  PARAMETERS: 
//      [in] pmp - Information needed to identify the message.
//
HRESULT HrMsgProperties(PMSGPROP pmp)
{
    CMsgProps *pMsgProp = 0;
    HRESULT    hr;
    
    TraceCall("HrMsgProperties");

    // Create the property sheet object
    pMsgProp = new CMsgProps();
    if (!pMsgProp)
        return E_OUTOFMEMORY;
    
    // Tell the object to do it's thing.  This won't go away until the
    // property sheet is dismissed.
    hr = pMsgProp->HrDoProps(pmp);
    
    // Free the object
    if (pMsgProp)
        delete pMsgProp;
    
    return hr;
}


CMsgProps::CMsgProps()
{
    m_himl = 0;
    m_hwndGen = 0;
    m_hwndGenSource = 0;
    m_pmp = NULL;
}

CMsgProps::~CMsgProps()
{
}



//
//  FUNCTION:   CMsgProps::HrDoProps()
//
//  PURPOSE:    Initializes the structures used to create the prop sheet
//              and then displays the sheet.  
//
//  PARAMETERS: 
//      [in] pmp - Information needed to identify the message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMsgProps::HrDoProps(PMSGPROP pmp)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp[3];
    BOOL            fApply = FALSE;
    HRESULT         hr;
    LPTSTR          pszSubject = NULL;
    LPTSTR          pszFree = NULL;
    TCHAR           rgch[256] = "";
 
    TraceCall("CMsgProps::HrDoProps");
 
    // Zero init the prop sheet structures
    ZeroMemory(&psh, sizeof(psh));
    ZeroMemory(&psp, sizeof(psp));

    // Double check that we have the information we need to do this.
    if (pmp == NULL || (pmp->pMsg == NULL && pmp->pNoMsgData == NULL))
        return E_INVALIDARG;

    Assert(pmp->hwndParent);
    
    // Stash this pointer
    m_pmp = pmp;

    // Page zero is the general tab
    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags     = PSP_USETITLE;
    psp[0].hInstance   = g_hLocRes;
    psp[0].pszTemplate = MAKEINTRESOURCE(iddMsgProp_General);
    psp[0].pfnDlgProc  = GeneralPageProc;
    psp[0].pszTitle    = MAKEINTRESOURCE(idsPropPageGeneral);
    psp[0].lParam      = (LPARAM) this;

    // Increment the number of pages 
    psh.nPages++;
    
    // If the message is not unsent, then we also display the "Details" tab.
    if (!(pmp->dwFlags & ARF_UNSENT) || (pmp->dwFlags & ARF_SUBMITTED))
    {        
        psp[psh.nPages].dwSize      = sizeof(PROPSHEETPAGE);
        psp[psh.nPages].dwFlags     = PSP_USETITLE;
        psp[psh.nPages].hInstance   = g_hLocRes;
        psp[psh.nPages].pszTemplate = MAKEINTRESOURCE(iddMsgProp_Details);
        psp[psh.nPages].pfnDlgProc  = DetailsPageProc;
        psp[psh.nPages].pszTitle    = MAKEINTRESOURCE(idsPropPageDetails);
        psp[psh.nPages].lParam      = (LPARAM) this;

        // If the caller wanted this to be the first page the user
        // sees, set it to be the start page.
        if (MP_DETAILS == pmp->mpStartPage)
            psh.nStartPage = psh.nPages;

        // Increment the number of pages
        psh.nPages++;
    }
    
    // If the message is secure, add the security pages
    if (pmp->fSecure && (!(pmp->dwFlags & ARF_UNSENT) || (pmp->dwFlags & ARF_SUBMITTED)))
    {
        psp[psh.nPages].dwSize      = sizeof(PROPSHEETPAGE);
        psp[psh.nPages].dwFlags     = PSP_USETITLE;
        psp[psh.nPages].hInstance   = g_hLocRes;
        psp[psh.nPages].pszTemplate = MAKEINTRESOURCE(iddMsgProp_Security_Msg);
        psp[psh.nPages].pfnDlgProc  = SecurityPageProc;        
        psp[psh.nPages].pszTitle    = MAKEINTRESOURCE(idsPropPageSecurity);        
        psp[psh.nPages].lParam      = (LPARAM) this;

        // If the caller wanted this to be the first page the user
        // sees, set it to be the start page.
        if (MP_SECURITY == pmp->mpStartPage)
            psh.nStartPage = psh.nPages;        

        // Increment the number of pages
        psh.nPages++;
    }
    
    // Property sheet header information
    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_PROPSHEETPAGE | PSH_USEPAGELANG | ((fApply) ? 0 : PSH_NOAPPLYNOW);
    psh.hwndParent = pmp->hwndParent;
    psh.hInstance  = g_hLocRes;
    
    // The title of the property sheet is the same as the subject.  So now we
    // need to get the subject from either the message or message info.
    if (pmp->pMsg)
    {
        // Get the subject from the message
        if (SUCCEEDED(MimeOleGetBodyPropA(pmp->pMsg, HBODY_ROOT, 
                                          PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, 
                                          &pszSubject)))
        {
            // We'll need to free this string later
            pszFree = pszSubject;
        }
    }
    else
    {
        AssertSz(pmp->pNoMsgData, "CMsgProp::HrDoProps() - Need to provide either a Message or Message Info");
        pszSubject = (LPTSTR) pmp->pNoMsgData->pszSubject;
    }
    
    // If there was no subject on the message, set the title to be "No Subject"
    if (!pszSubject || !*pszSubject)
    {
        LoadString(g_hLocRes, idsNoSubject, rgch, sizeof(rgch));
        pszSubject = rgch;
    }

    // Clean up the subject string before we use it.  Tabs look like pretty bad.
    ConvertTabsToSpaces(pszSubject);

    // Set the subject as the property sheet title.
    psh.pszCaption = pszSubject;
    
    // Provide the array of pages.  The number was set along the way.
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    // Invoke the property sheet.
    PropertySheet(&psh);
    
    // If this is valid, then we need to free the string.
    SafeMemFree(pszFree);
    return (S_OK);
}


//
//  FUNCTION:   CMsgProps::GeneralPageProc()
//
//  PURPOSE:    Callback for the General tab dialog.
//
INT_PTR CALLBACK CMsgProps::GeneralPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMsgProps *pThis = 0;
    
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            // Grab the object's this pointer from the init info
            pThis = (CMsgProps *) ((PROPSHEETPAGE *)lParam)->lParam;

            // Stash the window handle for this dialog in the class
            pThis->m_hwndGen = hwnd;

            // Initialize the page
            pThis->InitGeneralPage();
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch(((NMHDR FAR *)lParam)->code)
            {
                // We're going to do the default thing for all of these notifications
                case PSN_APPLY:
                case PSN_KILLACTIVE:
                case PSN_SETACTIVE:
                {
                    SetDlgMsgResult(hwnd, WM_NOTIFY, FALSE);
                    return TRUE;
                }            
            }
            break;
        }
    }

    return FALSE;
}

enum
{
    freeSubject = 0,
    freeFrom,
    freeMax
};


//
//  FUNCTION:   CMsgProps::InitGeneralPage()
//
//  PURPOSE:    Set's the values for the "General" tab in the message
//              property sheet.
//
void CMsgProps::InitGeneralPage()
{
    HWND            hwnd;
    char            rgch[256],
                    rgchFmt[256];
    char            *psz = NULL;
    PROPVARIANT     rVariant;
    LPMIMEMESSAGE   pMsg = m_pmp->pMsg;
    IMSGPRIORITY    Pri = IMSG_PRI_NORMAL;
    int             ids;
    BOOL            fMime;
    LPSTR           rgszFree[freeMax]={0};
    WCHAR           wszDate[CCHMAX_STRINGRES];
        
    TraceCall("CMsgProps::InitGeneralPage");

    // [SBAILEY]: Raid-2440: ATTACH: Attachments field in Properties dialog innacurate when looked at from the listview.
    if (m_pmp->fFromListView)
    {
        // Too hard to get these counts write from the listview because to really compute the attachment
        // counts correctly, we have to render the message in trident. Since we are time contrained,
        // we are going to simply remove the attachement count from the listview message properties. But
        // since the counts are correct from message note properties, we will show the attachment counts from there.
        ShowWindow(GetDlgItem(m_hwndGen, IDC_ATTACHMENTS_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_ATTACHMENTS), SW_HIDE);
    }

    // If this is a news message, we hide the "Recieved:" and "Priority" fields
    if (m_pmp->type == MSGPROPTYPE_NEWS)
    {
        RECT rc, rcLabel;

        // Get the position of the priority field
        GetWindowRect(GetDlgItem(m_hwndGen, IDC_PRIORITY), &rc);
        MapWindowPoints(NULL, m_hwndGen, (LPPOINT) &rc, 2);

        // Get the position of the priority label
        GetWindowRect(GetDlgItem(m_hwndGen, IDC_PRIORITY_STATIC), &rcLabel);
        MapWindowPoints(NULL, m_hwndGen, (LPPOINT) &rcLabel, 2);

        // Hide the unused fields
        ShowWindow(GetDlgItem(m_hwndGen, IDC_PRIORITY_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_PRIORITY), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, idcStatic1), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_RECEIVED_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwndGen, IDC_RECEIVED), SW_HIDE);

        // Move the sent fields up to where the priority fields were
        SetWindowPos(GetDlgItem(m_hwndGen, IDC_SENT_STATIC), NULL, rcLabel.left, 
                     rcLabel.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        SetWindowPos(GetDlgItem(m_hwndGen, IDC_SENT), NULL, rc.left, rc.top, 0, 0, 
                     SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // Figure out the correct image for this message
    int idIcon;
    if (m_pmp->type == MSGPROPTYPE_MAIL)
    {
        if (m_pmp->dwFlags & ARF_UNSENT)
            idIcon = idiMsgPropUnSent;
        else
            idIcon = idiMsgPropSent;
    }
    else
    {
        if (m_pmp->dwFlags & ARF_UNSENT)
            idIcon = idiArtPropUnpost;
        else
            idIcon = idiArtPropPost;
    }

    // Set the image on the property sheet
    HICON hIcon = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idIcon));
    SendDlgItemMessage(m_hwndGen, IDC_FOLDER_IMAGE, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    // Subject
    if (pMsg)
    {
        // If we have a message object, then we need to get the subject from the message
        if (SUCCEEDED(MimeOleGetBodyPropA(pMsg, HBODY_ROOT,  PIDTOSTR(PID_HDR_SUBJECT), 
                                          NOFLAGS, &psz)))
        {
            // Make sure we free this later, eh?
            rgszFree[freeSubject] = psz;
        }
    }
    else
    {
        Assert(m_pmp->pNoMsgData);
        psz = (LPTSTR) m_pmp->pNoMsgData->pszSubject;
    }

    // If the message doesn't have a subject, then substitute "(No Subject)"
    if (!psz || !*psz)
    {
        LoadString(g_hLocRes, idsNoSubject, rgch, sizeof(rgch));
        psz = rgch;
    }
    
    // Set the subject on the dialog
    SetDlgItemText(m_hwndGen, IDC_MSGSUBJECT, psz);

    // From
    if (pMsg)
    {
        // Get the "From" line
        if (S_OK == pMsg->GetAddressFormat(IAT_FROM, AFT_DISPLAY_BOTH, &psz))
        {
            // We'll need to free this later
            rgszFree[freeFrom] = psz;
            
            // Set the name on the control
            SetDlgItemText(m_hwndGen, IDC_MSGFROM, psz);
        }
    }
    else
    {
        // Check to see if the caller provided this information
        if (m_pmp->pNoMsgData && m_pmp->pNoMsgData->pszFrom)
        {
            SetDlgItemText(m_hwndGen, IDC_MSGFROM, m_pmp->pNoMsgData->pszFrom);
        }
    }

    // Type (News or Mail)
    if (m_pmp->type == MSGPROPTYPE_MAIL)
        LoadString(g_hLocRes, idsMailMessage, rgch, ARRAYSIZE(rgch));
    else
        LoadString(g_hLocRes, idsNewsMessage, rgch, ARRAYSIZE(rgch));

    SetDlgItemText(m_hwndGen, IDC_TYPE, rgch);

    // Location
    if (m_pmp->dwFlags & ARF_UNSENT)
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
        SetDlgItemText(m_hwndGen, IDC_MSGFOLDER, rgch);
    }
    else
        SetDlgItemText(m_hwndGen, IDC_MSGFOLDER, m_pmp->szFolderName);

    // Size
    ULONG ulSize;
    if (pMsg)
    {
        pMsg->GetMessageSize(&ulSize, 0);
        if (0 == ulSize)
        {
            // see if the message has the userprop for uncached size
            rVariant.vt = VT_UI4;
            if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_UNCACHEDSIZE), 0, &rVariant)))
                ulSize = rVariant.ulVal;
        }
        AthFormatSizeK(ulSize, rgch, ARRAYSIZE(rgch));
    }
    else if (m_pmp->pNoMsgData && m_pmp->pNoMsgData->ulSize)
    {
        AthFormatSizeK(m_pmp->pNoMsgData->ulSize, rgch, ARRAYSIZE(rgch));
    }
    else
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
    }

    SetDlgItemText(m_hwndGen, IDC_MSGSIZE, rgch);

    // Attachments
    ULONG cAttachments = 0;
    if (pMsg)
    {
        GetAttachmentCount(pMsg, &cAttachments);
    }
    else if (m_pmp->pNoMsgData)
    {
        cAttachments = m_pmp->pNoMsgData->cAttachments;
        SetDlgItemInt(m_hwndGen, IDC_ATTACHMENTS, cAttachments, FALSE);
    }

    if (cAttachments)
    {
        SetDlgItemInt(m_hwndGen, IDC_ATTACHMENTS, cAttachments, FALSE);
    }
    else
    {
        LoadString(g_hLocRes, idsPropAttachNone, rgch, sizeof(rgch));
        SetDlgItemText(m_hwndGen, IDC_ATTACHMENTS, rgch);
    }

    // Priority
    // Get the priority from the message
    rVariant.vt = VT_UI4;
    Pri = IMSG_PRI_NORMAL;
    if (pMsg && SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant)))
        Pri = (IMSGPRIORITY) rVariant.ulVal;
    else
    {
        Assert(m_pmp->pNoMsgData);
        Pri = m_pmp->pNoMsgData->Pri;
    }
    
    // Map the priority to a string
    switch (Pri)
    {
        case IMSG_PRI_LOW:
            ids = idsPriLow;
            break;
        case IMSG_PRI_HIGH:
            ids = idsPriHigh;
            break;
        default:
            ids = idsPriNormal;
    }
    
    // Set the string on the dialog
    LoadString(g_hLocRes, ids, rgch, ARRAYSIZE(rgch));
    SetDlgItemText(m_hwndGen, IDC_PRIORITY, rgch);

    // Sent
    if (pMsg)
    {
        *wszDate = 0;
        rVariant.vt = VT_FILETIME;
        pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);
        AthFileTimeToDateTimeW(&rVariant.filetime, wszDate, ARRAYSIZE(wszDate), DTM_NOSECONDS);
        SetDlgItemTextWrapW(m_hwndGen, IDC_SENT, wszDate);
    }
    else if (m_pmp->dwFlags & ARF_UNSENT)
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
        SetDlgItemText(m_hwndGen, IDC_SENT, rgch);
    }
    else
    {
        SetDlgItemText(m_hwndGen, IDC_SENT, m_pmp->pNoMsgData->pszSent);
    }

    // Recieved
    if (pMsg)
    {        
        *wszDate = 0;
        rVariant.vt = VT_FILETIME;
        pMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant);
        AthFileTimeToDateTimeW(&rVariant.filetime, wszDate, ARRAYSIZE(wszDate), DTM_NOSECONDS);
        SetDlgItemTextWrapW(m_hwndGen, IDC_RECEIVED, wszDate);
    }
    else if (m_pmp->dwFlags & ARF_UNSENT)
    {
        LoadString(g_hLocRes, idsUnderComp, rgch, ARRAYSIZE(rgchFmt));
        SetDlgItemText(m_hwndGen, IDC_RECEIVED, rgch);
    }
    
    // Free the string table
    for (register int i=0; i < freeMax; i++)
        if (rgszFree[i])
            MemFree(rgszFree[i]);
}



void CMsgProps::InitDetailsPage(HWND hwnd)
{
    LPSTREAM    pstm;
    BODYOFFSETS rOffset;
    char        *psz;
    int         cch;
    
    Assert(m_pmp);
    Assert(m_pmp->pMsg);
    
    // fill in the headers...
    if(m_pmp->pMsg->GetMessageSource(&pstm, 0)==S_OK)
    {
        HrRewindStream(pstm);
        
        m_pmp->pMsg->GetBodyOffsets(HBODY_ROOT, &rOffset);
        
        cch=rOffset.cbBodyStart;
        if(MemAlloc((LPVOID *)&psz, cch+1))
        {
            if(!pstm->Read(psz, cch, NULL))
            {
                psz[cch]=0; // null term this
                SetDlgItemText(hwnd, idcTxtHeaders, psz);
            }
            MemFree(psz);
        }
        ReleaseObj(pstm);
    }
    else
        EnableWindow(GetDlgItem(hwnd, idbMsgSource), FALSE);
    
    if (!m_pmp->fSecure || !m_pmp->pSecureMsg)
        ShowWindow(GetDlgItem(hwnd, idbSecMsgSource), SW_HIDE);
}

INT_PTR CALLBACK CMsgProps::DetailsPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMsgProps   *pmprop=0;
    
    switch(msg)
    {
    case WM_INITDIALOG:
        pmprop=(CMsgProps *) ((PROPSHEETPAGE *)lParam)->lParam;
        SetDlgThisPtr(hwnd, (LPARAM)pmprop);
        
        Assert(pmprop);
        pmprop->InitDetailsPage(hwnd);
        return TRUE;
        
    case WM_COMMAND:
        pmprop=(CMsgProps *)GetDlgThisPtr(hwnd);
        if(GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            if (GET_WM_COMMAND_ID(wParam, lParam)==idbMsgSource)
            {
                MimeEditViewSource(pmprop->m_pmp->hwndParent, pmprop->m_pmp->pMsg);
                return(FALSE);
            }
            else if (GET_WM_COMMAND_ID(wParam, lParam)==idbSecMsgSource)
            {
                MimeEditViewSource(pmprop->m_pmp->hwndParent, pmprop->m_pmp->pSecureMsg);
                return(FALSE);
            }
        }
        else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_SETFOCUS) {
            if (GET_WM_COMMAND_ID(wParam, lParam) == idcTxtHeaders) {
                // Remove the selection!
                SendDlgItemMessage(hwnd, idcTxtHeaders, EM_SETSEL, -1, -1);
                // fall through to default processing.
            }
        }
        return TRUE;
        
    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
            pmprop=(CMsgProps *)GetDlgThisPtr(hwnd);
        case PSN_APPLY:
        case PSN_KILLACTIVE:
        case PSN_SETACTIVE:
            return TRUE;
            
        }
        break;

    case WM_CLOSE:
        {
            PostMessage(GetParent(hwnd), WM_CLOSE, 0, 0);
            break;
        }
        
    }
    return FALSE;
}


#ifdef WIN16
static const char  s_cszDlgSec[] = "PDLGSECUTIRY";
#endif

INT_PTR CALLBACK CMsgProps::SecurityPageProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PMSGPROP            pMsgProp = (PMSGPROP)0;
    DLGSECURITY         *pDlgSec;
    
    switch(msg)
    {
    case WM_INITDIALOG:
        {
            CMsgProps *pmprop;
            pmprop=(CMsgProps *) ((PROPSHEETPAGE *)lParam)->lParam;
            SetWndThisPtr(hwnd, (LPARAM)pmprop->m_pmp);
            if (pmprop)
                pmprop->InitSecurityPage(hwnd);
        }
        return TRUE;
        
    case WM_COMMAND:
        
        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case idcAddCert:
                pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
                pMsgProp = (PMSGPROP)GetWndThisPtr(hwnd);
                
                // Get thumbprint into WAB and cert into AddressBook CAPI store
                // cert goes to store first so CAPI details page can find it
                if (pDlgSec && pMsgProp)
                {
                    if (SUCCEEDED(HrAddSenderCertToWab(hwnd,
                        pMsgProp->pMsg,
                        pMsgProp->lpWabal,
                        &pDlgSec->tbSenderThumbprint,
                        &pDlgSec->blSymCaps,
                        pDlgSec->ftSigningTime,
                        WFF_CREATE | WFF_SHOWUI)))
                    {
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                            MAKEINTRESOURCEW(idsSenderCertAdded), NULL, MB_ICONINFORMATION | MB_OK);
                    }
                }
                return(FALSE);
                
            case idcVerifySig:
                pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
                
                if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pSenderCert, pDlgSec->hcMsg))
                    MessageBeep(MB_OK);
                return(FALSE);
                
            case idcViewCerts:
                pMsgProp = (PMSGPROP)GetWndThisPtr(hwnd);
                
                return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddMsgProp_Sec_ViewCert),
                    hwnd, ViewSecCertDlgProc, (LPARAM) (pMsgProp)) == IDOK);
                
            case idcCertHelp:
                OEHtmlHelp(hwnd, c_szCtxHelpFileHTMLCtx, HH_DISPLAY_TOPIC, (DWORD_PTR)(LPCSTR)"mail_overview_send_secure_messages.htm");
                return(FALSE);

            default:
                break;
            }
        }
        return TRUE;
        
    case WM_DESTROY:
        pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
        if (pDlgSec)
        {
            if (pDlgSec->pSenderCert)
                CertFreeCertificateContext(pDlgSec->pSenderCert);
            if (pDlgSec->pEncSenderCert)
                CertFreeCertificateContext(pDlgSec->pEncSenderCert);
            if (pDlgSec->pEncryptionCert)
                CertFreeCertificateContext(pDlgSec->pEncryptionCert);
            if (pDlgSec->tbSenderThumbprint.pBlobData)
                MemFree(pDlgSec->tbSenderThumbprint.pBlobData);
            if (pDlgSec->hcMsg) {
                if (! CertCloseStore(pDlgSec->hcMsg, 0)) {
                    DOUTL(DOUTL_CRYPT, "CertCloseStore (message store) failed");
                }
                pDlgSec->hcMsg = NULL;
            }
            
            MemFree(pDlgSec);
            
            CLEAR_DIALOG_SECURITY(hwnd);
        }
        return NULL;
        
    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_APPLY:
        case PSN_KILLACTIVE:
        case PSN_SETACTIVE:
            return TRUE;
            
        }
        break;
    }
    return FALSE;
}


void CMsgProps::InitSecurityPage(HWND hwnd)
{
    DWORD               cb;
    DWORD               i;
    HRESULT             hr;
    TCHAR               szYes[CCHMAX_STRINGRES/4],
        szNo[CCHMAX_STRINGRES/4],
        szMaybe[CCHMAX_STRINGRES/4],
        szNA[CCHMAX_STRINGRES/4];
    HWND                hwndCtrl;
    DLGSECURITY        *pDlgSec;
    IMimeBody          *pBody;
    PROPVARIANT         var;
    ULONG               secType, ulROVal;
    BOOL                fNoEncAlg = TRUE;
    LPTSTR              sz;
    LPMIMEMESSAGE       pMsg = m_pmp->pMsg;
    PCCERT_CONTEXT          pccert = NULL;
    TCHAR               szTmp[CCHMAX_STRINGRES];
    
    HBODY               hBody = NULL;
    SECSTATE            SecState ={0};
    
    // We need these to set the statics
    LoadString(g_hLocRes, idsOui, szYes, ARRAYSIZE(szYes));
    LoadString(g_hLocRes, idsNon, szNo, ARRAYSIZE(szNo));
    LoadString(g_hLocRes, idsMaybe, szMaybe, ARRAYSIZE(szMaybe));
    LoadString(g_hLocRes, idsNotApplicable, szNA, ARRAYSIZE(szNA));
    
    if(FAILED(HrGetSecurityState(m_pmp->pMsg, &SecState, &hBody)))
        return;

    CleanupSECSTATE(&SecState);
    if (FAILED(m_pmp->pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody)))
        return;
    
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_TYPE, &var)))
        secType = var.ulVal;
    
    // Set up storage for the other security info that
    // we care about
    if (MemAlloc((LPVOID *)&pDlgSec, sizeof(*pDlgSec)))
    {
        memset(pDlgSec, 0, sizeof(*pDlgSec));
#ifdef _WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
        {
            pDlgSec->hcMsg = (HCERTSTORE)(var.pulVal);     // Closed in WM_DESTROY
        }
        
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
        {
            // we don't have to dupe the pDlgSec cert because we won't free
            // the var's.
            pDlgSec->pSenderCert = (PCCERT_CONTEXT)(var.pulVal);
        }
#else   // !_WIN64
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
        {
            pDlgSec->hcMsg = (HCERTSTORE) var.ulVal;     // Closed in WM_DESTROY
        }
        
        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
        {
            // we don't have to dupe the pDlgSec cert because we won't free
            // the var's.
            pDlgSec->pSenderCert = (PCCERT_CONTEXT) var.ulVal;
        }
#endif  // _WIN64
        hr = GetSigningCert(m_pmp->pMsg, &pccert,
            &pDlgSec->tbSenderThumbprint, &pDlgSec->blSymCaps,
            &pDlgSec->ftSigningTime);
        if (FAILED(hr) && (hr != MIME_E_SECURITY_NOCERT))
        {
            SUCCEEDED(hr);
        }
    }
    
    SET_DIALOG_SECURITY(hwnd, (LPARAM)pDlgSec);
    
    // we use the same dlgproc for sent items and recd items
    // so use if statements to check for existance of all
    // non-common controls
    
    // set up the statics based on the message's info
    
    if(IsSigned(secType))
    {
        LPSTR szCertEmail = SzGetCertificateEmailAddress(pccert);
        SetDlgItemText(hwnd,  idcStaticDigSign, szCertEmail);
        MemFree(szCertEmail);
        SetDlgItemText(hwnd, idcStaticRevoked,
            (LPCTSTR)(((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline() && CheckCDPinCert(pMsg))
            ? szYes
            : szNo));
    }
    else
    {
        SetDlgItemText(hwnd,  idcStaticDigSign, szNA);
        SetDlgItemText(hwnd,  idcStaticRevoked, szNA);
    }
    
    
    SetDlgItemText(hwnd, idcStaticEncrypt,
        (LPCTSTR)(IsEncrypted(secType)
        ? szYes
        : szNo));
    
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_RO_MSG_VALIDITY, &var)))
        ulROVal = var.ulVal;
    else
        ulROVal = MSV_INVALID|MSV_UNVERIFIABLE;
    
#ifdef SMIME_V3
    if(!IsSMIME3Supported())
    {
        LoadString(g_hLocRes, idsRecUnknown, szTmp, ARRAYSIZE(szTmp));
        SendMessage(GetDlgItem(hwnd, idcRetRecReq), WM_SETTEXT, 0, LPARAM(LPCTSTR(szTmp)));
    }
    else
    {
        if(FPresentPolicyRegInfo()) 
        {   
            if ((hwndCtrl = GetDlgItem(hwnd, idcSecLabelText)) && IsSigned(secType))
            {
                LPWSTR pwStr = NULL;
                // Set Label text
                if((hr = HrGetLabelString(m_pmp->pMsg, &pwStr)) == S_OK)
                {
                    SetWindowTextWrapW(hwndCtrl, pwStr);
                    SafeMemFree(pwStr);
                }
                else
                    SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(SUCCEEDED(hr) ? szYes : szNo)));
            }
        }
        // Check receipt request
        if ((hwndCtrl = GetDlgItem(hwnd, idcRetRecReq)))
        {
            if (!IsSigned(secType))
                sz = szNA;
            else
            {
                PSMIME_RECEIPT      pSecReceipt = NULL; 
                if(CheckDecodedForReceipt(m_pmp->pMsg, &pSecReceipt) == S_OK)
                    sz = szNA;
                else
                    sz = (secType & MST_RECEIPT_REQUEST) ? szYes : szNo;
                SafeMemFree(pSecReceipt);
            }
            SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(sz)));
        }
    }
    
#endif // SMIME_V3    
    ////////
    // begin sign dependent block
    
    if (!IsSigned(secType))
        sz = szNA;
    
    if ((hwndCtrl = GetDlgItem(hwnd, idcStaticAlter)))
    {
        if (IsSigned(secType))
        {
            sz = (MSV_SIGNATURE_MASK & ulROVal)  
                ? (MSV_BADSIGNATURE & ulROVal)
                ? szNo
                : szMaybe
                : ((pccert != NULL) ? szYes : szMaybe);
        }
        SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(sz)));
    }
    
    if ((hwndCtrl = GetDlgItem(hwnd, idcStaticTrust)) &&
        SUCCEEDED(pBody->GetOption(OID_SECURITY_USER_VALIDITY, &var)))
    {
        if (IsSigned(secType))
        {
            sz = (ATHSEC_TRUSTSTATEMASK & var.ulVal)
                ? ((ATHSEC_NOTRUSTNOTTRUSTED & var.ulVal) || (ulROVal & MSV_EXPIRED_SIGNINGCERT))
                ? szNo
                : szMaybe
                : szYes;
        }
        SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(sz)));
        
    }
    
    if((hwndCtrl = GetDlgItem(hwnd, idcStaticRevStatus)) && IsSigned(secType))
    {
        if((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline() && CheckCDPinCert(pMsg))
        {
            if(var.ulVal & ATHSEC_NOTRUSTREVOKED)
                LoadString(g_hLocRes, idsWrnSecurityCertRevoked, szTmp, ARRAYSIZE(szTmp));
            else if(var.ulVal & ATHSEC_NOTRUSTREVFAIL)
                LoadString(g_hLocRes, idsWrnSecurityRevFail, szTmp, ARRAYSIZE(szTmp));
            else
                LoadString(g_hLocRes, idsOkSecurityCertRevoked, szTmp, ARRAYSIZE(szTmp));
        }
        else if((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline() && !CheckCDPinCert(pMsg))
            LoadString(g_hLocRes, idsWrnSecurityNoCDP, szTmp, ARRAYSIZE(szTmp));
        
        else if((DwGetOption(OPT_REVOKE_CHECK) != 0) && g_pConMan->IsGlobalOffline())
            LoadString(g_hLocRes, idsRevokationOffline, szTmp, ARRAYSIZE(szTmp));
        
        else if(DwGetOption(OPT_REVOKE_CHECK) == 0)
            LoadString(g_hLocRes, idsRevokationTurnedOff, szTmp, ARRAYSIZE(szTmp));
        
        SendMessage(hwndCtrl, WM_SETTEXT, 0, LPARAM(LPCTSTR(szTmp)));
    }
    
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_INCLUDED, &var)))
    {
        if (IsSigned(secType))
            sz = (var.boolVal == TRUE) ? szYes : szNo;
        SetDlgItemText(hwnd, idcStaticCertInc, LPCTSTR(sz));
    }
    
    // end signing dependent block
    ////////
    
    
    if (IsEncrypted(secType) && SUCCEEDED(pBody->GetOption(OID_SECURITY_ALG_BULK, &var)))
    {
        Assert(var.vt == VT_BLOB);
        if (var.vt == VT_BLOB && var.blob.cbSize && var.blob.pBlobData) 
        {
            LPCTSTR pszProtocol = NULL;
            
            // Convert the SYMCAPS blob to an "encrypted using" string
            if (SUCCEEDED(MimeOleAlgNameFromSMimeCap(var.blob.pBlobData, var.blob.cbSize,
                &pszProtocol))) 
            {     // Note: returns a static string.  Don't free it.
                if (pszProtocol) 
                {
                    SendMessage(GetDlgItem(hwnd, idcStaticEncAlg), WM_SETTEXT, 0, (LPARAM)pszProtocol);
                    fNoEncAlg = FALSE;
                }
            }
            // Free the data
            MemFree(var.blob.pBlobData);
        }
    }
    if (fNoEncAlg) 
    {
        SendMessage(GetDlgItem(hwnd, idcStaticEncAlg), WM_SETTEXT, 0,
            LPARAM(LPCTSTR(szNA)));
    }
    
    if (pccert != NULL)
        CertFreeCertificateContext(pccert);
    ReleaseObj(pBody);
    return;
}

INT_PTR CALLBACK ViewSecCertDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPMIMEMESSAGE       pMsg = NULL;
    IMimeBody          *pBody;
    PROPVARIANT         var;
    DLGSECURITY         *pDlgSec;
    ULONG               secType, ulROVal;
    HWND                hwndCtrl = NULL;
    PMSGPROP            pMsgProp = (PMSGPROP)0;
    HRESULT             hr = S_OK;
    TCHAR               szTmp[CCHMAX_STRINGRES];
    HBODY               hBody = NULL;
    HBODY               hInerBody = NULL;
    SECSTATE            SecState ={0};
    
    switch (message)
    {
    case WM_INITDIALOG:
        TCHAR               szNA[CCHMAX_STRINGRES/4];

        SetWndThisPtr(hwnd, lParam);
        CenterDialog(hwnd);
        pMsgProp =  (PMSGPROP) lParam;
        pMsg = pMsgProp->pMsg;
        
        LoadString(g_hLocRes, idsNotApplicable, szNA, ARRAYSIZE(szNA));

        if(FAILED(HrGetSecurityState(pMsgProp->pMsg, &SecState, &hBody)))
            return FALSE;

        if(FAILED(HrGetInnerLayer(pMsgProp->pMsg, &hInerBody)))
            return FALSE;

        if((!IsSignTrusted(&SecState) || !IsEncryptionOK(&SecState)) && (hBody != hInerBody))
            EnableWindow(GetDlgItem(hwnd, idcAddCert), FALSE);

        CleanupSECSTATE(&SecState);

        if (FAILED(pMsgProp->pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody)))
            return FALSE;

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_TYPE, &var)))
            secType = var.ulVal;
        
        // Set up storage for the other security info that
        // we care about
        if (MemAlloc((LPVOID *)&pDlgSec, sizeof(*pDlgSec)))
        {
            memset(pDlgSec, 0, sizeof(*pDlgSec));
#ifdef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
            {
                pDlgSec->hcMsg = (HCERTSTORE)(var.pulVal);     // Closed in WM_DESTROY
            }
            
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_64, &var)))
            {
                // we don't have to dupe the pDlgSec cert because we won't free
                // the var's.
                pDlgSec->pSenderCert = (PCCERT_CONTEXT)(var.pulVal);
            }
#else   // !_WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
            {
                pDlgSec->hcMsg = (HCERTSTORE) var.ulVal;     // Closed in WM_DESTROY
            }
            
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING, &var)))
            {
                // we don't have to dupe the pDlgSec cert because we won't free
                // the var's.
                pDlgSec->pSenderCert = (PCCERT_CONTEXT) var.ulVal;
            }
#endif  // _WIN64
            hr = GetSignerEncryptionCert(pMsgProp->pMsg, &pDlgSec->pEncSenderCert,
                &pDlgSec->tbSenderThumbprint, &pDlgSec->blSymCaps,
                &pDlgSec->ftSigningTime);
            if (FAILED(hr) && (hr != MIME_E_SECURITY_NOCERT))
            {
                SUCCEEDED(hr);
            }
        }
        if(IsEncrypted(secType))
        {
#ifdef _WIN64
            if (SUCCEEDED(hr = pBody->GetOption(OID_SECURITY_CERT_DECRYPTION_64, &var)))
            {
                Assert(VT_UI8 == var.vt);
                if ((PCCERT_CONTEXT)(var.pulVal))
                    pDlgSec->pEncryptionCert = (PCCERT_CONTEXT)(var.pulVal);
            }

#else // !_WIN64

            if (SUCCEEDED(hr = pBody->GetOption(OID_SECURITY_CERT_DECRYPTION, &var)))
            {
                Assert(VT_UI4 == var.vt);
                if (*(PCCERT_CONTEXT *)(&(var.uhVal)))
                    pDlgSec->pEncryptionCert = *(PCCERT_CONTEXT *)(&(var.uhVal));
            }
#endif // _WIN64
        }
        else
            pDlgSec->pEncryptionCert = NULL;

        SET_DIALOG_SECURITY(hwnd, (LPARAM)pDlgSec);

        if (pDlgSec->pEncSenderCert == NULL)
        {
            // Disable Add to Address Book button
            if ((hwndCtrl = GetDlgItem(hwnd, idcAddCert)))
                EnableWindow(hwndCtrl, FALSE);
            
            // Disable View sender's encrypt cert.
            if ((hwndCtrl = GetDlgItem(hwnd, idcSendersEncryptionCert)))
                EnableWindow(hwndCtrl, FALSE);

            LoadString(g_hLocRes, idsEncrCertNotIncluded, szTmp, ARRAYSIZE(szTmp));
            SetDlgItemText(hwnd, idcStaticSendersCert, LPCTSTR(szTmp));
        }            
            //
        if (pDlgSec->pSenderCert == NULL)
        {
            if ((hwndCtrl = GetDlgItem(hwnd, idcVerifySig)))
                EnableWindow(hwndCtrl, FALSE);

            LoadString(g_hLocRes, idsSignCertNotIncl, szTmp, ARRAYSIZE(szTmp));
            SetDlgItemText(hwnd, idcStaticSigningCert, LPCTSTR(szTmp));
        }
            
        if(pDlgSec->pEncryptionCert == NULL)
        {
            if ((hwndCtrl = GetDlgItem(hwnd, idcViewEncrytionCert)))
                EnableWindow(hwndCtrl, FALSE);
                
            if(IsEncrypted(secType))
                LoadString(g_hLocRes, idsEncrCertNotFoundOnPC, szTmp, ARRAYSIZE(szTmp));
            else
                LoadString(g_hLocRes, idsMsgWasNotEncrypted, szTmp, ARRAYSIZE(szTmp));
            SetDlgItemText(hwnd, idcStaticEncryptionCert, LPCTSTR(szTmp));
        }

        if(pDlgSec->blSymCaps.cbSize > 0)
        {
            // Convert the SYMCAPS blob to an "encrypted using" string
            LPCTSTR pszProtocol = NULL;
            if (SUCCEEDED(MimeOleAlgNameFromSMimeCap(pDlgSec->blSymCaps.pBlobData, pDlgSec->blSymCaps.cbSize,
                &pszProtocol))) 
            {     // Note: returns a static string.  Don't free it.
                if (pszProtocol) 
                    SetDlgItemText(hwnd, idcStaticEncryptAlgorithm, LPCTSTR(pszProtocol));
            }

        }
        else
            SetDlgItemText(hwnd, idcStaticEncryptAlgorithm, LPCTSTR(szNA));

            
        if(pBody)
            ReleaseObj(pBody);
        
        break;

    case WM_COMMAND:
        
        pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
        pMsgProp = (PMSGPROP)GetWndThisPtr(hwnd);
        pMsg = pMsgProp->pMsg;
        
        switch (LOWORD(wParam))
        {
        case idcAddCert:
            
            // Get thumbprint into WAB and cert into AddressBook CAPI store
            // cert goes to store first so CAPI details page can find it
            if (pDlgSec && pMsgProp)
            {
                if (SUCCEEDED(HrAddSenderCertToWab(hwnd,
                    pMsgProp->pMsg,
                    pMsgProp->lpWabal,
                    &pDlgSec->tbSenderThumbprint,
                    &pDlgSec->blSymCaps,
                    pDlgSec->ftSigningTime,
                    WFF_CREATE | WFF_SHOWUI)))
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail),
                        MAKEINTRESOURCEW(idsSenderCertAdded), NULL, MB_ICONINFORMATION | MB_OK);
                }
            }
            break;
            
        case idcVerifySig:
            if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pSenderCert, pDlgSec->hcMsg))
                MessageBeep(MB_OK);
            return(FALSE);
            
        case idcViewEncrytionCert:
            if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pEncryptionCert, pDlgSec->hcMsg))
                MessageBeep(MB_OK);
            return(FALSE);
            
        case idcSendersEncryptionCert:
            if (CommonUI_ViewSigningCertificate(hwnd, pDlgSec->pEncSenderCert, pDlgSec->hcMsg))
                MessageBeep(MB_OK);
            return(FALSE);
            
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            return(TRUE);
            
        }
        
        break; // wm_command
    case WM_CLOSE:
        SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
        return (TRUE);
            
    case WM_DESTROY:
        pDlgSec = (PDLGSECURITY)GET_DIALOG_SECURITY(hwnd);
        if (pDlgSec)
        {
            if (pDlgSec->pSenderCert)
                CertFreeCertificateContext(pDlgSec->pSenderCert);
            if (pDlgSec->pEncSenderCert)
                CertFreeCertificateContext(pDlgSec->pEncSenderCert);
            if (pDlgSec->pEncryptionCert)
                CertFreeCertificateContext(pDlgSec->pEncryptionCert);
            if (pDlgSec->tbSenderThumbprint.pBlobData)
                MemFree(pDlgSec->tbSenderThumbprint.pBlobData);
            if (pDlgSec->hcMsg) 
            {
                if (! CertCloseStore(pDlgSec->hcMsg, 0)) 
                {
                    DOUTL(DOUTL_CRYPT, "CertCloseStore (message store) failed");
                }
                pDlgSec->hcMsg = NULL;
            }
                
            MemFree(pDlgSec);
                
            CLEAR_DIALOG_SECURITY(hwnd);
        }
            
    } // message switch
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\msgprop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     msgprop.h
//
//  PURPOSE:    Types, structs, and functions for the Message Properties 
//              prop sheet.
//

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Forward Defines
//

interface IMimeMessage;
typedef DWORD MSGFLAGS;

class CWabal;
typedef CWabal *LPWABAL;

////////////////////////////////////////////////////////////////////////////
// New Types
//

// This is set in the MSGPROP structure to set which page in the propsheet
// is visible by default.
typedef enum tagMSGPAGE {
    MP_GENERAL = 0,
    MP_DETAILS,
    MP_SECURITY
} MSGPAGE;

// Tells the propsheet if the message that properties are being displayed for
// is news or mail.
typedef enum tagMSGPROPTYPE {
    MSGPROPTYPE_MAIL = 0,
    MSGPROPTYPE_NEWS,
    MSGPROPTYPE_MAX
} MSGPROPTYPE;

// This is used when a property sheet is to be invoked on a message that either
// is under composition or has not yet been downloaded.
typedef struct tagNOMSGDATA {
    LPCTSTR         pszSubject;
    LPCTSTR         pszFrom;
    LPCTSTR         pszSent;
    ULONG           ulSize;
    ULONG           cAttachments;
    IMSGPRIORITY    Pri;
} NOMSGDATA, *PNOMSGDATA;

// This structure defines the information needed to invoke the property 
// sheet.
typedef struct MSGPROP_tag
{
    // Basic fields necessary (Required)
    HWND            hwndParent;     // (Required) Handle of the window to parent the propsheet to
    MSGPROPTYPE     type;           // (Required) Type of message
    MSGPAGE         mpStartPage;    // (Required) Page to make visible initially
    BOOL            fSecure;        // (Required) If this is TRUE, lpWabal and pSecureMsg must be valid

    // Message Information
    MSGFLAGS        dwFlags;        // (Required) ARF_* flags
    LPCTSTR         szFolderName;   // (Optional) Folder or Newsgroup where the message is located
    IMimeMessage   *pMsg;           // (Optional) NULL for unsent sendnote
    PNOMSGDATA      pNoMsgData;     // (Optional) If pMsg is NULL, this must be valid

    // S/MIME goo
    LPWABAL         lpWabal;        // (Optional) 
    IMimeMessage   *pSecureMsg;     // (Optional) only valid if pNoMsgData is NULL and fSecure is TRUE

    // Hacks
    BOOL            fFromListView; 
} MSGPROP, *PMSGPROP;


/////////////////////////////////////////////////////////////////////////////
// Functions
//

HRESULT HrMsgProperties(PMSGPROP pmp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\msgsite.cpp ===
#include "pch.hxx"
#include "msgsite.h"
#include "secutil.h"
#include "mailutil.h"
#include "conman.h"
#include "newfldr.h"
#include "storutil.h"
#include "msoeobj.h"
#include "regutil.h"
#include "mapiutil.h"
#include "browser.h"
#include "receipts.h"
#include "shlwapip.h"
#include "msoert.h"

// ****************************************
COEMsgSite::COEMsgSite()
{
    m_pMsg = NULL; 
    m_pOrigMsg = NULL;
    m_pStoreCB = NULL;
    m_pMsgTable = NULL; 
    m_pListSelect = NULL;
    m_pCBMsgFolder = NULL;

    m_fCBCopy = FALSE;
    m_fCBSavedInDrafts = FALSE;
    m_fCBSaveInFolderAndDelOrig = FALSE;

    m_fGotNewID = FALSE;
    m_fHeaderOnly = FALSE;
    m_fValidMessage = FALSE;
    m_fNeedToLoadMsg = TRUE;
    m_fHaveCBMessageID = TRUE;
    m_fThreadingEnabled = FALSE;
    m_fReloadMessageFlag = TRUE;

    m_dwArfFlags = 0;
    m_dwMSAction = MSA_IDLE;
    m_dwCMFState = CMF_UNINITED;
    m_dwOrigFolderIsImap = OFIMAP_UNDEFINED;

    m_cRef = 1; 

    m_FolderID = FOLDERID_INVALID; 
    m_CBFolderID = FOLDERID_INVALID; 

    m_MessageID = 0;
    m_CBMessageID = 0;
    m_NewMessageID = 0;

    *m_rgwchFileName = 0;
    
    m_pFolderReleaseOnComplete = NULL;

    m_dwMDNFlags = 0;

    if (!!DwGetOption(OPT_MDN_SEND_REQUEST))
        m_dwMDNFlags |= MDN_REQUEST;

}

// ****************************************
COEMsgSite::~COEMsgSite()
{
    Assert(!m_pMsg);
    Assert(!m_pOrigMsg);
    Assert(!m_pMsgTable);
    Assert(!m_pStoreCB);
    Assert(!m_pListSelect);
    AssertSz(!m_pCBMsgFolder, "Who missed freeing this?");
    
    ReleaseObj(m_pFolderReleaseOnComplete);
}

// ****************************************
HRESULT COEMsgSite::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

// ****************************************
ULONG COEMsgSite::AddRef()
{
    return ++m_cRef;
}

// ****************************************
ULONG COEMsgSite::Release()
{
    if(--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// ****************************************
BOOL COEMsgSite::ThreadingEnabled(void)
{
    BOOL            fEnabled = FALSE;
    FOLDERSORTINFO  SortInfo;
    
    Assert(OEMSIT_MSG_TABLE == m_dwInitType);

    if (SUCCEEDED(m_pMsgTable->GetSortInfo(&SortInfo)))
        fEnabled = SortInfo.fThreaded;

    return fEnabled;
}

// ****************************************
HRESULT COEMsgSite::Init(INIT_MSGSITE_STRUCT *pInitStruct)
{
    // WARNING!!! pStoreCB will not have been setup by this point.
    // Use it in this function only if you are sure things will work.
    // For instance, the hwnd will not get setup yet so GetCallbackHwnd
    // will not work appropriatly.
    
    Assert(pInitStruct);

    HRESULT hr = S_OK;
    m_dwInitType = pInitStruct->dwInitType;
    m_fValidMessage = TRUE;

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
        {
            Assert (m_pMsgTable==NULL);
            
            ReplaceInterface(m_pMsgTable, pInitStruct->initTable.pMsgTable);
            if (m_pMsgTable)
                m_pMsgTable->ConnectionAddRef();
            
            ReplaceInterface(m_pListSelect, pInitStruct->initTable.pListSelect);
            hr = m_pMsgTable->GetRowMessageId(pInitStruct->initTable.rowIndex, &m_MessageID);
            if (FAILED(hr))
                break;

            m_FolderID = pInitStruct->folderID;
            m_fThreadingEnabled = ThreadingEnabled();
            break;
        }

        case OEMSIT_STORE:
            AssertSz(FALSE, "Can't init using the store...");
            hr = E_UNEXPECTED;
            break;

        case OEMSIT_FAT:
            StrCpyNW(m_rgwchFileName, pInitStruct->pwszFile, ARRAYSIZE(m_rgwchFileName));
            break;

        case OEMSIT_MSG:
            m_FolderID = pInitStruct->folderID;
            ReplaceInterface(m_pMsg, pInitStruct->pMsg);
            break;

        case OEMSIT_VIRGIN:
            m_FolderID = pInitStruct->folderID;
            break;

        default:
            hr = E_UNEXPECTED;
            break;
    }

/* ~~~ Took this out of mailnote.cpp HrInit(pcni) code. How do we get this to work???
   ~~~ It is suppose to notify us if a folder has been deleted. In that case, we would
   ~~~ need to convert the msgSite to a msg based msgsite.
    if (m_pMsgTable)
        m_pMsgTable->Advise(GetCallbackHwnd());
    if (FAILED(hr = CreateNotify(&m_pFldrDelNotify)) ||
        FAILED(hr = m_pFldrDelNotify->Initialize((TCHAR *)c_szFolderDelNotify)) ||
        FAILED(hr = m_pFldrDelNotify->Register(GetCallbackHwnd(), g_hwndInit, FALSE)))
        goto error;
*/

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetStatusFlags(DWORD *pdwFlags)
{
    DWORD dwNewFlags = OEMSF_CAN_COPY | OEMSF_CAN_SAVE;

    if (!!(m_dwMDNFlags & MDN_REQUEST))
    {
        dwNewFlags |= OEMSF_MDN_REQUEST;
    }

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
        case OEMSIT_STORE:
        {
            FOLDERTYPE folderType = GetFolderType(m_FolderID);
            dwNewFlags |= OEMSF_CAN_MARK | OEMSF_FROM_STORE;

            // GetMessageFlags is fairly intensive to be called as often as GetStatusFlags
            // is called. Since this flag really only matters at load time, we will only go
            // and get the value after a load from store. Otherwise, we will use the 
            // cached value from m_fSecUI.
            if (m_fReloadMessageFlag)
            {
                m_dwArfFlags = 0;

                GetMessageFlags(&m_dwArfFlags);
                m_fReloadMessageFlag = FALSE;
            }

            if (0 == (m_dwArfFlags & ARF_READ))
                dwNewFlags |= OEMSF_UNREAD;

            // If we came from a store and we are a new folder, then can't delete
            if (FOLDER_NEWS != folderType)
            {
                dwNewFlags |= OEMSF_CAN_MOVE;
                if (0 == (m_dwArfFlags & ARF_ENDANGERED))
                    dwNewFlags |= OEMSF_CAN_DELETE;

                if ((FOLDER_HTTPMAIL == folderType) || (FOLDER_IMAP == folderType))
                    dwNewFlags |= OEMSF_RULESNOTENABLED;
            }

            if (OEMSIT_MSG_TABLE == m_dwInitType)
            {
                dwNewFlags |= OEMSF_CAN_NEXT|OEMSF_CAN_PREV;

                if (m_fThreadingEnabled)
                    dwNewFlags |= OEMSF_THREADING_ENABLED;
            }

            if (m_dwArfFlags & ARF_UNSENT)
            {
                // If we are table based, need to do extra checking for IMAP message in find folder
                if (OEMSIT_MSG_TABLE == m_dwInitType)
                {
                    if (OFIMAP_UNDEFINED == m_dwOrigFolderIsImap)
                    {
                        FOLDERINFO  fi;
                        if (SUCCEEDED(g_pStore->GetFolderInfo(m_FolderID, &fi)))
                        {
                            // If is a find folder, check to see if message is IMAP
                            if (FOLDER_FINDRESULTS & (fi.dwFlags))
                            {
                                // Get original folder for this message (ie, not the find folder)
                                IMessageFolder *pMsgFolder = NULL;
                                if (SUCCEEDED(g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &pMsgFolder)))
                                {
                                    // If original folder type is IMAP, then don't set unsent flag
                                    FOLDERID folderID;
                                    if (SUCCEEDED(pMsgFolder->GetMessageFolderId(m_MessageID, &folderID)))
                                    {
                                        FOLDERTYPE origFolderType = GetFolderType(folderID);
                                        if (FOLDER_IMAP != origFolderType)
                                        {
                                            m_dwOrigFolderIsImap = OFIMAP_FALSE;
                                            dwNewFlags |= OEMSF_UNSENT;
                                        }
                                        else
                                            m_dwOrigFolderIsImap = OFIMAP_TRUE;
                                    }
                                    pMsgFolder->Release();
                                }
                            }
                            else
                                dwNewFlags |= OEMSF_UNSENT;
                            g_pStore->FreeRecord(&fi);
                        }
                    }
                    else
                        if (OFIMAP_FALSE == m_dwOrigFolderIsImap)
                            dwNewFlags |= OEMSF_UNSENT;
                }
                else
                    dwNewFlags |= OEMSF_UNSENT;
            }

            if (0 == (m_dwArfFlags & ARF_NOSECUI))
                dwNewFlags |= OEMSF_SEC_UI_ENABLED;

            if (m_dwArfFlags & ARF_NEWSMSG)
                dwNewFlags |= OEMSF_BASEISNEWS;

            break;
        }

        case OEMSIT_FAT:
            {
                LPWSTR  pwszUnsent = NULL,
                        pwszExt = PathFindExtensionW(m_rgwchFileName);

                dwNewFlags |= OEMSF_CAN_DELETE | OEMSF_CAN_MOVE | OEMSF_SEC_UI_ENABLED;
                dwNewFlags |= OEMSF_FROM_FAT;

                if (SUCCEEDED(MimeOleGetBodyPropW(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, &pwszUnsent)))
                {
                    if (FALSE == FIsEmptyW(pwszUnsent))
                        dwNewFlags |= OEMSF_UNSENT;
                    SafeMemFree(pwszUnsent);
                }

                if (0 == StrCmpW(pwszExt, c_wszNwsExt))
                    dwNewFlags |= OEMSF_BASEISNEWS;
                break;
            }

        case OEMSIT_MSG:
            dwNewFlags |= OEMSF_FROM_MSG;
            break;

        case OEMSIT_VIRGIN:
            dwNewFlags |= OEMSF_VIRGIN | OEMSF_UNSENT;
            break;
    }

    *pdwFlags = dwNewFlags;
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::DeleteFromStore(DELETEMESSAGEFLAGS dwFlags)
{
    HRESULT hr;

    AssertSz(!m_pCBMsgFolder, "Someone forgot to release this baby.");

    Assert(m_pStoreCB);

    hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &m_pCBMsgFolder);
    if (SUCCEEDED(hr))
    {
        MESSAGEIDLIST   list;
        FOLDERINFO      fi;

        list.cMsgs = 1;
        list.prgidMsg = &m_MessageID;

        hr = m_pCBMsgFolder->DeleteMessages(dwFlags, &list, NULL, m_pStoreCB);
        if (E_PENDING != hr)
            SafeRelease(m_pCBMsgFolder);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DeleteFromMsgTable(DELETEMESSAGEFLAGS dwFlags)
{
    HRESULT         hr;
    ROWINDEX        iRow = -1,
                    iNewRow = -1;

    AssertSz(m_pMsgTable, "How can you be OEMSIT_MSG_TABLE and not have a table");

    m_fGotNewID = FALSE;

    hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
    if (FAILED(hr))
        goto Exit;

    if (SUCCEEDED(m_pMsgTable->GetNextRow(iRow, GETNEXT_NEXT, ROWMSG_ALL, 0, &iNewRow)) && 
                SUCCEEDED(m_pMsgTable->GetRowMessageId(iNewRow, &m_NewMessageID)))
        m_fGotNewID = TRUE;

    hr = m_pMsgTable->DeleteRows(dwFlags, 1, &iRow, FALSE, m_pStoreCB);
    if (FAILED(hr) && (E_PENDING != hr))
        AthMessageBoxW(GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrDeleteMsg), NULL, MB_OK);

Exit:
    return hr;
}

// ****************************************
HRESULT COEMsgSite::Delete(DELETEMESSAGEFLAGS dwFlags)
{
    HRESULT hr;

    m_dwMSAction = MSA_DELETE;

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
            hr = DeleteFromMsgTable(dwFlags);
            break;

        case OEMSIT_STORE:
            hr = DeleteFromStore(dwFlags);
            m_fValidMessage = FALSE;
            break;

        case OEMSIT_FAT:
            DeleteFileWrapW(m_rgwchFileName);
            m_fValidMessage = FALSE;
            m_dwMSAction = MSA_IDLE;
            break;

        // With these two, there is nothing to delete.
        case OEMSIT_MSG:
        case OEMSIT_VIRGIN:
            hr = S_OK;
            break;

        default:
            AssertSz(FALSE, "Weren't prepared to handle this initType");
            hr = E_UNEXPECTED;
            break;
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoNextPrev(BOOL fNext, DWORD dwFlags)
{
    HRESULT hr;
    if (OEMSIT_MSG_TABLE == m_dwInitType)
    {
        ROWMESSAGETYPE  tyMsg;
        ROWINDEX        iRow = 0,
                        iNewRow = 0;
        MESSAGEID       idNewMark;
        GETNEXTFLAGS    dwNextFlags = 0;
        GETNEXTTYPE     tyDir = fNext?GETNEXT_NEXT:GETNEXT_PREVIOUS;

        AssertSz(m_pMsgTable, "How can you be OEMSIT_MSG_TABLE and not have a table");

        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
        if (FAILED(hr))
            goto Exit;

        if (dwFlags&OENF_SKIPMAIL)
            tyMsg = ROWMSG_MAIL;
        else if (dwFlags&OENF_SKIPNEWS)
            tyMsg = ROWMSG_NEWS;
        else
            tyMsg = ROWMSG_ALL;

        if (dwFlags&OENF_UNREAD)
            dwNextFlags |= GETNEXT_UNREAD;

        if (dwFlags&OENF_THREAD)
            dwNextFlags |= GETNEXT_THREAD;

        hr = m_pMsgTable->GetNextRow(iRow, tyDir, tyMsg, dwNextFlags, &iNewRow);
        if (FAILED(hr))
            goto Exit;

        hr = m_pMsgTable->GetRowMessageId(iNewRow, &idNewMark);
        if (FAILED(hr))
            goto Exit;

        if (m_pListSelect)
            m_pListSelect->SetActiveRow(iNewRow);

        m_MessageID = idNewMark;
        m_fNeedToLoadMsg = TRUE;
    }
    else
        hr = E_UNEXPECTED;

Exit:
    AssertSz(E_PENDING != hr, "COEMsgSite::DoNextPrev not setup to handle E_PENDING.");
    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromMsgToFldr(IMimeMessage *pMsg, BOOL fUnSent)
{
    HRESULT hr = E_UNEXPECTED;
    if (m_fCBCopy)
    {
        hr = m_pCBMsgFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, fUnSent?ARF_UNSENT:NOFLAGS, 0, pMsg, m_pStoreCB);

        if (SUCCEEDED(hr))
        {
            m_dwCMFState = CMF_MSG_TO_FOLDER;
            OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
        }
    }
    else
        AssertSz(FALSE, "Can't move a message based on a message. Only copy.");

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromStoreToFldr(BOOL fUnSent)
{
    HRESULT     hr;
    MESSAGEID   msgID = 0;

    hr = SaveMessageInFolder(m_pStoreCB, m_pCBMsgFolder, m_pMsg, fUnSent?ARF_UNSENT:NOFLAGS, &msgID, TRUE);

    if (SUCCEEDED(hr))
    {
        m_dwCMFState = CMF_STORE_TO_FOLDER;
        OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromTableToFldr(void)
{
    HRESULT hr;
    IMessageFolder *pSrcFolder = NULL;
    MESSAGEIDLIST   rMsgIDList;
    LPMESSAGEINFO   pMsgInfo;
    ROWINDEX        iRow, iNewRow;
    MESSAGEID       msgID;
    FOLDERID        folderID = 0;

    Assert(m_pStoreCB);

    m_fGotNewID = FALSE;

    if (m_pFolderReleaseOnComplete != NULL)
        return E_FAIL;

    hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &pSrcFolder);
    if (FAILED(hr))
        goto Exit;

    hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
    if (FAILED(hr))
        goto Exit;
     
    // If we are moving, then we need to get the next item in the list
    if (!m_fCBCopy && SUCCEEDED(m_pMsgTable->GetNextRow(iRow, GETNEXT_NEXT, ROWMSG_ALL, 0, &iNewRow)) &&
                  SUCCEEDED(m_pMsgTable->GetRowMessageId(iNewRow, &m_NewMessageID)))
        m_fGotNewID = TRUE;

    hr = m_pMsgTable->GetRow(iRow, &pMsgInfo);
    if (FAILED(hr))
        goto Exit;
         
    msgID = pMsgInfo->idMessage;
    m_pMsgTable->ReleaseRow(pMsgInfo);

    rMsgIDList.cAllocated = 0;
    rMsgIDList.cMsgs = 1;
    rMsgIDList.prgidMsg = &msgID;

    if (SUCCEEDED(m_pCBMsgFolder->GetFolderId(&folderID)))
    {
        m_CBFolderID = folderID;
        m_CBMessageID = msgID;
    }
    else
    {
        m_CBFolderID = FOLDERID_INVALID;
        m_dwInitType = OEMSIT_MSG;
    }

    hr = pSrcFolder->CopyMessages(m_pCBMsgFolder, m_fCBCopy?0:COPY_MESSAGE_MOVE, &rMsgIDList, NULL, NULL, m_pStoreCB);
    if (SUCCEEDED(hr))
    {
        m_dwCMFState = CMF_TABLE_TO_FOLDER;
        OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
    }

    if (hr == E_PENDING)
    {
        ReplaceInterface(m_pFolderReleaseOnComplete, pSrcFolder);
        SafeRelease(pSrcFolder);
    }

Exit:
    ReleaseObj(pSrcFolder);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveFromFATToFldr(BOOL fUnSent)
{
    IMimeMessage *pMsg = NULL;
    HRESULT hr = S_OK;

    // Need original message, because m_pMsg is without security...
    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        return hr;

    hr = HrLoadMsgFromFileW(pMsg, m_rgwchFileName);

    hr = SaveMessageInFolder(m_pStoreCB, m_pCBMsgFolder, pMsg, fUnSent?ARF_UNSENT:NOFLAGS, &m_CBMessageID, TRUE);
    if (SUCCEEDED(hr))
    {
        m_fHaveCBMessageID = TRUE;
        m_dwCMFState = CMF_FAT_TO_FOLDER;
        OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
    }

    SafeRelease(pMsg);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::DoCopyMoveToFolder(BOOL fCopy, IMimeMessage *pMsg, BOOL fUnSent)
{
    HRESULT hr;
    FOLDERID newFolderID;

    Assert(m_pStoreCB);

    AssertSz(NULL == m_pCBMsgFolder, "Someone forgot to release the folder");

    m_fCBCopy = fCopy;
    m_dwMSAction = MSA_COPYMOVE;

    hr = SelectFolderDialog(GetCallbackHwnd(), SFD_SELECTFOLDER, m_FolderID, 
                            FD_DISABLESERVERS | TREEVIEW_NONEWS | 
                            (m_fCBCopy?FD_COPYFLAGS:FD_MOVEFLAGS), 
                            MAKEINTRESOURCE(m_fCBCopy?idsCopy:idsMove),
                            MAKEINTRESOURCE(m_fCBCopy?idsCopyCaption:idsMoveCaption),
                            &newFolderID);

    // Only want to do the copy if:
    // 1- The new folder is not invalid
    // 2- Can open the needed folder
    if (SUCCEEDED(hr) && (newFolderID != FOLDERID_INVALID) && 
        SUCCEEDED(hr = g_pStore->OpenFolder(newFolderID, NULL, NOFLAGS, &m_pCBMsgFolder)))
    {
        if (pMsg)
            hr = DoCopyMoveFromMsgToFldr(pMsg, fUnSent);
        else
            switch (m_dwInitType)
            {
                case OEMSIT_MSG_TABLE:
                    hr = DoCopyMoveFromTableToFldr();
                    break;

                case OEMSIT_STORE:
                    hr = DoCopyMoveFromStoreToFldr(fUnSent);
                    break;

                case OEMSIT_FAT:
                    hr = DoCopyMoveFromFATToFldr(fUnSent);
                    break;

                case OEMSIT_VIRGIN:
                case OEMSIT_MSG:
                    hr = DoCopyMoveFromMsgToFldr(m_pMsg, fUnSent);
                    break;
            }
        if (E_PENDING != hr)
            SafeRelease(m_pCBMsgFolder);
    }

    if (FAILED(hr) && (E_PENDING != hr) && (hrUserCancel != hr))
        AthErrorMessageW(GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthenaNews), MAKEINTRESOURCEW(idsCantSaveMsg), hr);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::Save(IMimeMessage *pMsg, DWORD dwFlags, IImnAccount *pAcct)
{
    HRESULT         hr;
    WORD            wMessageFlags = 0;
    ACCTTYPE        acctType = ACCT_MAIL;

    AssertSz(!m_pCBMsgFolder, "Someone forgot to release this baby.");

    m_fCBSaveInFolderAndDelOrig = !!(dwFlags & OESF_SAVE_IN_ORIG_FOLDER);
    m_fCBSavedInDrafts = FALSE;

    m_dwMSAction = MSA_SAVE;

    pAcct->GetAccountType(&acctType);
    if (ACCT_NEWS == acctType)
        wMessageFlags |= ARF_NEWSMSG;

    if (dwFlags & OESF_UNSENT)
        wMessageFlags |= ARF_UNSENT;
    if (dwFlags & OESF_READ)
        wMessageFlags |= ARF_READ;
    
    // Decide if want to save to drafts or some other folder
    if ((OEMSIT_MSG_TABLE == m_dwInitType) && m_fCBSaveInFolderAndDelOrig)
    {
        m_CBFolderID = m_FolderID;
        hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &m_pCBMsgFolder);
    }
    else
    {
        FOLDERID    idStore;

        m_fCBSavedInDrafts = TRUE;

        // Find store ID of account in the header
        // If have problems getting the special folder on the server, then use
        // the local store drafts.
        if (dwFlags & OESF_FORCE_LOCAL_DRAFT)
            idStore = FOLDERID_LOCAL_STORE;
        else
        {
            IImnAccount *pSaveAcct = NULL;

            if (ACCT_NEWS == acctType)
                GetDefaultAccount(ACCT_MAIL, &pSaveAcct);
            else
                ReplaceInterface(pSaveAcct, pAcct);

            if (pSaveAcct)
            {
                DWORD dw = 0;
                CHAR szAcctId[CCHMAX_ACCOUNT_NAME];

                hr = pSaveAcct->GetPropSz(AP_ACCOUNT_ID, szAcctId, ARRAYSIZE(szAcctId));
                if (SUCCEEDED(hr))
                    hr = g_pStore->FindServerId(szAcctId, &idStore);

                pSaveAcct->Release();
            }
            else
                hr = E_FAIL;

            if (FAILED(hr))
                idStore = FOLDERID_LOCAL_STORE;
        }

        hr = g_pStore->OpenSpecialFolder(idStore, NULL, FOLDER_DRAFT, &m_pCBMsgFolder);

        // If failed opening special folder and we weren't trying local folders, try
        // using local folders now.
        if (FAILED(hr) && (idStore != FOLDERID_LOCAL_STORE))
            hr = g_pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, NULL, FOLDER_DRAFT, &m_pCBMsgFolder);

        if (SUCCEEDED(hr))
        {
            m_CBFolderID = FOLDERID_INVALID;
            m_pCBMsgFolder->GetFolderId(&m_CBFolderID);
        }
    }

    if (FAILED(hr))
        goto Exit;

    m_CBMessageID = m_MessageID;

    // Save message to the folder
    hr = SaveMessageInFolder(m_pStoreCB, m_pCBMsgFolder, pMsg, wMessageFlags, &m_CBMessageID, TRUE);
    if (SUCCEEDED(hr))
        m_fHaveCBMessageID = TRUE;
    else if (E_PENDING == hr)
    {
        ReplaceInterface(m_pMsg, pMsg);
        m_fHaveCBMessageID = FALSE;
    }

Exit:
    if (E_PENDING != hr)
        SafeRelease(m_pCBMsgFolder);
    if (FAILED(hr) && (hrUserCancel != hr) && (E_PENDING != hr))
    {
        int idsErr = ((MIME_E_URL_NOTFOUND == hr) ? idsErrSaveDownloadFail : idsCantSaveMsg);

        AthMessageBoxW(GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsCantSaveMsg), NULL, MB_OK);
    }
    return hr;
}

// ****************************************
// Use to split this function into one for news and one for mail. Don't think that 
// we need to do that anymore. If there is any difference, that should probably
// be moved into the message mangling phase. I can't see anything else that would
// be different.
#ifdef SMIME_V3
HRESULT COEMsgSite::SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail, IHeaderSite *pHeaderSite)
#else
HRESULT COEMsgSite::SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail)
#endif // SMIME_V3
{
    HRESULT         hr;

        // Figure out whether we need to request for MDNs. Doing it here skips processing it in smapi.
    if (fMail &&
        (!!(m_dwMDNFlags & MDN_REQUEST)) &&
        (!IsMDN(pMsg)))
    {
        LPWSTR pwsz = NULL;
       
        if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), NOFLAGS, &pwsz)))
        {
            MimeOleSetBodyPropW(pMsg, HBODY_ROOT, STR_HDR_DISP_NOTIFICATION_TO, NOFLAGS, pwsz);
            
            MemFree(pwsz);
        }
    }

    // Account should already be setup in the message by this time.
    if (IsSecure(pMsg))
#ifdef SMIME_V3
        hr = SendSecureMailToOutBox(m_pStoreCB, pMsg, fSendImmediately, FALSE, fMail, pHeaderSite);
#else
        hr = SendSecureMailToOutBox(m_pStoreCB, pMsg, fSendImmediately, FALSE, fMail);
#endif // SMIME_V3        
    else
        hr = SendMailToOutBox(m_pStoreCB, pMsg, fSendImmediately, FALSE, fMail);
    
    return hr;
}

// ****************************************
BOOL COEMsgSite::NeedToSendNews(IMimePropertySet *pPropSet)
{
    MIMEPROPINFO    mimePropInfo;

    AssertSz(pPropSet, "A property set needs to be passed in.");

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUPS), &mimePropInfo)))
        return TRUE;

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_FOLLOWUPTO), &mimePropInfo)))
        return TRUE;

    return FALSE;    
}

// ****************************************
BOOL COEMsgSite::NeedToSendMail(IMimePropertySet *pPropSet)
{
    MIMEPROPINFO    mimePropInfo;

    AssertSz(pPropSet, "A property set needs to be passed in.");

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_TO), &mimePropInfo)))
        return TRUE;

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_CC), &mimePropInfo)))
        return TRUE;

    if (SUCCEEDED(pPropSet->GetPropInfo(PIDTOSTR(PID_HDR_BCC), &mimePropInfo)))
        return TRUE;

    return FALSE;    
}

// ****************************************
HRESULT COEMsgSite::ClearHeaders(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet)
{
    HRESULT hr = S_OK;

    for (ULONG i = 0; i < cNames; i++)
        pPropSet->DeleteProp(*prgszName++);

    return S_OK;
}

// ****************************************
#ifdef SMIME_V3
HRESULT COEMsgSite::SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate, IHeaderSite *pHeaderSite)
#else
HRESULT COEMsgSite::SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate)
#endif // SMIME_V3
{
    HRESULT             hr;
    BOOL                fSendMail, 
                        fSendNews,
                        fSendBoth;
    IMimePropertySet   *pPropSet = NULL,
                       *pTempPropSet = NULL;
    PROPVARIANT         var;
    IImnAccount        *pAccount = NULL;
    ACCTTYPE            acctType;
    IMimeMessage       *pTempMsg = NULL;

    LPCSTR  rgszMailOnlyHeaders[] =
            {   
                PIDTOSTR(PID_HDR_TO),
                PIDTOSTR(PID_HDR_CC),
                PIDTOSTR(PID_HDR_BCC),
                PIDTOSTR(PID_HDR_XPRI),
                PIDTOSTR(PID_HDR_XMSPRI),
                PIDTOSTR(PID_HDR_APPARTO),
                PIDTOSTR(PID_HDR_COMMENT),
                PIDTOSTR(PID_HDR_SENDER),
                PIDTOSTR(PID_HDR_XMAILER),
                PIDTOSTR(PID_HDR_RECEIVED),
                PIDTOSTR(PID_HDR_DISP_NOTIFICATION_TO)
            };
    LPCSTR  rgszNewsOnlyHeaders[] =
            {
                PIDTOSTR(PID_HDR_NEWSGROUPS),
                PIDTOSTR(PID_HDR_PATH),
                PIDTOSTR(PID_HDR_FOLLOWUPTO),
                PIDTOSTR(PID_HDR_EXPIRES),
                PIDTOSTR(PID_HDR_REFS),
                PIDTOSTR(PID_HDR_DISTRIB),
                PIDTOSTR(PID_HDR_ORG),
                PIDTOSTR(PID_HDR_KEYWORDS),
                PIDTOSTR(PID_HDR_SUMMARY),
                PIDTOSTR(PID_HDR_APPROVED),
                PIDTOSTR(PID_HDR_LINES),
                PIDTOSTR(PID_HDR_XREF),
                PIDTOSTR(PID_HDR_CONTROL)
            };          

//  Common headers between mail and news that can be left where they are
//  PID_HDR_FROM     PID_HDR_DATE     PID_HDR_SUBJECT  PID_HDR_MESSAGEID
//  PID_HDR_REPLYTO  PID_HDR_CNTTYPE  PID_HDR_CNTXFER  PID_HDR_CNTDESC  
//  PID_HDR_CNTDISP  PID_HDR_CNTBASE  PID_HDR_CNTLOC   PID_HDR_CNTID    
//  PID_HDR_MIMEVER  PID_HDR_ENCODING PID_HDR_ENCRYPTED

    m_dwMSAction = MSA_SEND;

    hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropSet);
    if(FAILED(hr))
        return hr;

    fSendMail = NeedToSendMail(pPropSet);
    fSendNews = NeedToSendNews(pPropSet);
    fSendBoth = fSendMail && fSendNews;

    PropVariantInit(&var);

    if((!fSendMail) && (!fSendNews))
    {
        hr = hrNoRecipients;
        goto Exit;
    }

    var.vt = VT_LPSTR;
    hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
    if (FAILED(hr))
        goto Exit;

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pAccount);
    if (FAILED(hr))
        goto Exit;

    hr = pAccount->GetAccountType(&acctType);
    if (FAILED(hr))
        goto Exit;

    if (fSendBoth)
    {
        hr = HrDupeMsg(pMsg, &pTempMsg);
        if (FAILED(hr))
            goto Exit;

        hr = pTempMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pTempPropSet);
        if(FAILED(hr))
            return hr;

        hr = ClearHeaders(ARRAYSIZE(rgszMailOnlyHeaders), rgszMailOnlyHeaders, pPropSet);
        if (FAILED(hr))
            goto Exit;

        hr = ClearHeaders(ARRAYSIZE(rgszNewsOnlyHeaders), rgszNewsOnlyHeaders, pTempPropSet);
        if (FAILED(hr))
            goto Exit;
    }

    // If going to do both news and mail, then must send news first. The spooler will
    // block and say it is busy if we send mail first. If we send mail second, then
    // the spooler has a special flag that says when you are done being busy, send
    // any mail that you have in your outbox.
    if (fSendNews)
    {
        if (ACCT_MAIL == acctType)
        {
            IImnAccount *pTempAccount = NULL;
            if (SUCCEEDED(GetDefaultAccount(ACCT_NEWS, &pTempAccount)))
            {
                HrSetAccountByAccount(pMsg, pTempAccount);
                pTempAccount->Release();
            }
        }

#ifdef SMIME_V3
        hr = SendMsg(pMsg, fSendImmediate, FALSE, pHeaderSite);
#else
        hr = SendMsg(pMsg, fSendImmediate, FALSE);
#endif // SMIME_V3
        if (FAILED(hr) && (E_PENDING != hr))
            goto Exit;

        // Tell the user this is being sent to the server but might not appear
        // right away.
        if (fSendImmediate && !g_pConMan->IsGlobalOffline())
            DoDontShowMeAgainDlg(GetCallbackHwnd(), c_szDSSendNews,
                                MAKEINTRESOURCE(idsPostNews),
                                MAKEINTRESOURCE(idsPostSentToServer),
                                MB_OK);
        if (fSendBoth)
            pMsg = pTempMsg;
    }

    if (fSendMail)
    {
        if (ACCT_NEWS == acctType)
        {
            //If we are not the smapi client forward it to whoever it is.
            if (!FIsDefaultMailConfiged())
            {
                hr = NewsUtil_ReFwdByMapi(GetCallbackHwnd(), pMsg, MSGTYPE_CC);
                goto Exit;
            }

            IImnAccount *pTempAccount = NULL;
            if (SUCCEEDED(GetDefaultAccount(ACCT_MAIL, &pTempAccount)))
            {
                HrSetAccountByAccount(pMsg, pTempAccount);
                pTempAccount->Release();
            }
        }

#ifdef SMIME_V3
        hr = SendMsg(pMsg, fSendImmediate, TRUE, pHeaderSite);
#else
        hr = SendMsg(pMsg, fSendImmediate, TRUE);
#endif // SMIME_V3
    }


Exit:
    SafeMemFree(var.pszVal);
    ReleaseObj(pAccount);
    ReleaseObj(pPropSet);
    ReleaseObj(pTempPropSet);
    ReleaseObj(pTempMsg);
    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetLocation(LPWSTR rgwchLocation, DWORD cchSize)
{
    FOLDERINFO  fi;
    LPWSTR      pwszName = NULL;
    HRESULT     hr = S_OK;
    BOOL        fFreeFolder = FALSE;

    switch (m_dwInitType)
    {
        case OEMSIT_MSG_TABLE:
        case OEMSIT_STORE:
            if (SUCCEEDED(g_pStore->GetFolderInfo(m_FolderID, &fi)))
            {
                Assert(fi.pszName);
                fFreeFolder = TRUE;

                IF_NULLEXIT(pwszName = PszToUnicode(CP_ACP, fi.pszName));

                StrCpyNW(rgwchLocation, pwszName, cchSize);
            }
            else
                *rgwchLocation = 0;
            break;

        case OEMSIT_FAT:
            StrCpyNW(rgwchLocation, m_rgwchFileName, cchSize);
            break;

        case OEMSIT_MSG:
        case OEMSIT_VIRGIN:
            *rgwchLocation = 0;
            break;
    }

exit:
    if (fFreeFolder)
        g_pStore->FreeRecord(&fi);

    MemFree(pwszName);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::MarkMessage(MARK_TYPE dwType, APPLYCHILDRENTYPE dwApplyType)
{
    HRESULT hr = E_FAIL;
    if (OEMSIT_MSG_TABLE == m_dwInitType)
    {
        ROWINDEX iRow = 0;

        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
        if (SUCCEEDED(hr))
            hr = m_pMsgTable->Mark(&iRow, 1, dwApplyType, dwType, m_pStoreCB);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetMessageFlags(MESSAGEFLAGS *pdwFlags)
{
    HRESULT hr = S_OK;

    *pdwFlags = 0;

    if (!m_pMsgTable)
    {
        hr = E_FAIL;
        goto Exit;
    }

    if (OEMSIT_MSG_TABLE == m_dwInitType)
    {
        ROWINDEX iRow = 0;
        LPMESSAGEINFO pMsgInfo;

        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
        if (FAILED(hr))
            goto Exit;

        hr = m_pMsgTable->GetRow(iRow, &pMsgInfo); 
        if (FAILED(hr))
            goto Exit;
        
        *pdwFlags = pMsgInfo->dwFlags;
        m_pMsgTable->ReleaseRow(pMsgInfo);
    }

Exit:
    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetDefaultAccount(ACCTTYPE acctType, IImnAccount **ppAcct)
{
    HRESULT         hr = E_FAIL,
                    hr2;
    LPMESSAGEINFO   pMsgInfo = NULL;
    ROWINDEX        iRow;
    DWORD           dwFlags = 0;

    Assert(ppAcct);

    if(OEMSIT_MSG_TABLE == m_dwInitType)
    {
        if (ACCT_MAIL == acctType)
        {
            IF_FAILEXIT(GetMessageFlags(&dwFlags));
            if (!!(dwFlags & ARF_NEWSMSG))
                goto exit;
        }
        IF_FAILEXIT(hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow));
        IF_FAILEXIT(hr = m_pMsgTable->GetRow(iRow, &pMsgInfo));
        IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pMsgInfo->pszAcctId, ppAcct));  
    }

exit:
    if(FAILED(hr))
        hr = g_pAcctMan->GetDefaultAccount(acctType, ppAcct);

    if(pMsgInfo)
    {
        // We don't want to mask hr, so we'll just test an alternative HRESULT
        hr2 = m_pMsgTable->ReleaseRow(pMsgInfo);

        if(FAILED(hr2))
            TraceResult(hr2);
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromStore(void)
{
    HRESULT hr;
    IMessageFolder *pMsgFolder = NULL;

    hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &pMsgFolder);
    if (SUCCEEDED(hr))
    {
        IMimeMessage *pMsg = NULL;
        //Can only get into this state in a drafts message, so don't need worry about security
        hr = pMsgFolder->OpenMessage(m_MessageID, 0/* OPEN_MESSAGE_SECURE*/, &pMsg, NULL);
        if (SUCCEEDED(hr))
        {
            ReplaceInterface(m_pMsg, pMsg);
            pMsg->Release();
        }
        pMsgFolder->Release();
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromRow(IMimeMessage **ppMsg, ROWINDEX row)
{
    HRESULT         hr;
    LPMESSAGEINFO   pInfo;

    AssertSz(!(*ppMsg), "We create a message in this function.");

    hr = m_pMsgTable->GetRow(row, &pInfo);
    if (SUCCEEDED(hr))
    {
        m_dwMSAction = MSA_GET_MESSAGE;

        hr = CreateMessageFromInfo(pInfo, ppMsg, m_FolderID);
        m_fHeaderOnly = TRUE;

        // now we wait until the message has downloaded and reload in
        // OnComplete
        m_pMsgTable->ReleaseRow(pInfo);
    }
    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromTable(BOOL fGetOriginal, HRESULT *phr)
{
    IMimeMessage   *pMsg = NULL;
    BOOL            fOffline=FALSE;
    ROWINDEX        rowIndex = 0;
    HRESULT         hr,
                    tempHr = S_OK;

    hr = m_pMsgTable->GetRowIndex(m_MessageID, &rowIndex);
    if (FAILED(hr))
        goto Exit;
        
    m_fHeaderOnly = FALSE;
    hr = m_pMsgTable->OpenMessage(rowIndex, (fGetOriginal ? OPEN_MESSAGE_SECURE : 0), &pMsg, m_pStoreCB);
    if (FAILED(hr) || hr == STORE_S_ALREADYPENDING)
    {
        tempHr = hr;
        hr = LoadMessageFromRow(&pMsg, rowIndex);

        if (SUCCEEDED(hr))
        {
            switch (tempHr)
            {
                case E_NOT_ONLINE:
                    hr = HR_S_OFFLINE;
                    break;

                case STORE_S_ALREADYPENDING:
                case E_PENDING:
                {
                    LPMESSAGEINFO pmiMsgInfo;

                    // Save the MsgID of msg we're trying to load. This way if user quickly loads
                    // several msgs into note, we won't re-enter MSA_IDLE until the desired msg loads
                    if (SUCCEEDED(m_pMsgTable->GetRow(rowIndex, &pmiMsgInfo)))
                    {
                        m_MessageID = pmiMsgInfo->idMessage;
                        m_pMsgTable->ReleaseRow(pmiMsgInfo);
                    }
                    else
                        m_MessageID = 0; // This means show the next msg we get!

                    tempHr = S_OK;
                    break;
                }
            }
        }

        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        m_dwArfFlags = 0;
        GetMessageFlags(&m_dwArfFlags);
    }

    *phr = tempHr;
    ReplaceInterface(m_pMsg, pMsg);

Exit:
    ReleaseObj(pMsg);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::LoadMessageFromFAT(BOOL fGetOriginal, HRESULT *phr)
{
    IMimeMessage *pMsg = NULL;
    HRESULT hr;

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        return hr;

    //bobn: We need to make sure we know the default charset
    HGetDefaultCharset(NULL);

    hr = HrLoadMsgFromFileW(pMsg, m_rgwchFileName);
    if (SUCCEEDED(hr))
    {
        if(!fGetOriginal)
            *phr = HandleSecurity(NULL, pMsg);

        //if (SUCCEEDED(hr))
            ReplaceInterface(m_pMsg, pMsg);
    }

    SafeRelease(pMsg);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetFolderID(FOLDERID *folderID)
{
    Assert(folderID);
    *folderID = m_FolderID;
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::SetAccountInfo(void)
{
    HRESULT         hr = S_OK;
    FOLDERINFO      fi;
    PROPVARIANT     var;

    // Check to see if need an account in the message.
    var.vt = VT_LPSTR;
    if (FAILED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)) || !(var.pszVal))
    {
        if (FOLDERID_INVALID != m_FolderID)
        {
            hr = g_pStore->GetFolderInfo(m_FolderID, &fi);
            if (SUCCEEDED(hr))
            {
                // Set account based upon the folder ID passed down
                if (FOLDER_LOCAL != fi.tyFolder)
                {
                    char szAcctId[CCHMAX_ACCOUNT_NAME];
                    IImnAccount *pAcct = NULL;

                    if (SUCCEEDED(GetFolderAccountId(&fi, szAcctId, ARRAYSIZE(szAcctId))) && SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctId, &pAcct)))
                    {
                        HrSetAccountByAccount(m_pMsg, pAcct);
                        pAcct->Release();
                    }

                    // If not a server node, set the newgroup
                    if ((FOLDER_NEWS == fi.tyFolder) && (0 == (FOLDER_SERVER & fi.dwFlags)))
                        hr = MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, fi.pszName);
                }
                g_pStore->FreeRecord(&fi);
            }
        }
    }
    else
        SafeMemFree(var.pszVal);

    return hr;
}

// ****************************************
HRESULT COEMsgSite::CreateMsgWithAccountInfo(void)
{
    HRESULT     hr;

    SafeRelease(m_pMsg);
    hr = HrCreateMessage(&m_pMsg);
    if (SUCCEEDED(hr))
    {
        if(g_hDefaultCharsetForMail)
            m_pMsg->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
        hr = SetAccountInfo();
    }

    return hr;
}

// ****************************************
HRESULT COEMsgSite::GetMessage(IMimeMessage **ppMsg, BOOL *pfCompleteMsg, DWORD dwMessageFlags, HRESULT *phr)
{
    HRESULT hr = S_OK;
    BOOL    fGetOriginal = (OEGM_ORIGINAL & dwMessageFlags);

    if (!m_fValidMessage)
        return E_FAIL;

    *phr = S_OK;
    if (m_fNeedToLoadMsg || fGetOriginal)
    {
        switch (m_dwInitType)
        {
            case OEMSIT_MSG_TABLE:
                hr = LoadMessageFromTable(fGetOriginal, phr);
                break;

            case OEMSIT_STORE:
                hr = LoadMessageFromStore();
                break;

            case OEMSIT_FAT:
                hr = LoadMessageFromFAT(fGetOriginal, phr);
                break;

            case OEMSIT_MSG:
                hr = SetAccountInfo();
                break;

            case OEMSIT_VIRGIN:
                hr = CreateMsgWithAccountInfo();
                break;
        }
        m_fNeedToLoadMsg = FALSE;
    }

    if (SUCCEEDED(hr) && !m_fHeaderOnly && (OEGM_AS_ATTACH &dwMessageFlags))
    {
        IMimeMessage   *pMsgFwd = NULL;
        PROPVARIANT     var;

        hr = HrCreateMessage(&pMsgFwd);

        if (SUCCEEDED(hr))            
            hr = pMsgFwd->AttachObject(IID_IMimeMessage, (LPVOID)m_pMsg, NULL);

        var.vt = VT_LPSTR;
        if (SUCCEEDED(m_pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
        {
            pMsgFwd->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var);
        }

        if (SUCCEEDED(hr))
        {
            ReplaceInterface(m_pMsg, pMsgFwd);
            pMsgFwd->Release();
            m_dwInitType = OEMSIT_MSG;
        }
    }

    if (fGetOriginal)
        m_fReloadMessageFlag = TRUE;

    if (SUCCEEDED(hr))
    {
        ReplaceInterface((*ppMsg), m_pMsg);
        *pfCompleteMsg = !m_fHeaderOnly;

        m_fNeedToLoadMsg = !!m_fHeaderOnly;

        if (!m_pMsg)
            hr = E_FAIL;
    }

    return hr;
}

// *************************
BOOL COEMsgSite::FCanConnect()
{
    IImnAccount    *pAcct = NULL;
    HRESULT         hr;
    BOOL            fRet = TRUE;

    hr = GetDefaultAccount(ACCT_MAIL, &pAcct);
    if (SUCCEEDED(hr))
    {
        hr = g_pConMan->CanConnect(pAcct);
        pAcct->Release();
    }

    fRet = (S_OK == hr);

    return(fRet);
}

// ****************************************
HWND COEMsgSite::GetCallbackHwnd()
{
    HWND hwnd;

    Assert(m_pStoreCB);
    if (SUCCEEDED(m_pStoreCB->GetParentWindow(0, &hwnd)))
        return hwnd;
    return 0;
}

// ****************************************
HRESULT COEMsgSite::Close(void)
{
    SafeRelease(m_pMsg);
    SafeRelease(m_pOrigMsg);

    if (m_pMsgTable)
    {
        m_pMsgTable->ConnectionRelease();
        m_pMsgTable->Release();
        m_pMsgTable = NULL;
    }

    SafeRelease(m_pStoreCB);
    SafeRelease(m_pListSelect);
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::SetStoreCallback(IStoreCallback *pStoreCB)
{
    ReplaceInterface(m_pStoreCB, pStoreCB);
    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::SwitchLanguage(HCHARSET hOldCharset, HCHARSET hNewCharset)
{
    DWORD           dwCodePage = 0;
    INETCSETINFO    CsetInfo;
    BOOL            fSaveLang = TRUE;
    ROWINDEX        iRow = 0;
    HRESULT         hr = S_OK;

    if (OEMSIT_MSG_TABLE != m_dwInitType)
        goto Exit;
       
    if (FAILED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
        goto Exit;
        
#if 0
    if (SUCCEEDED(m_pMsgTable->GetLanguage(iRow, &dwCodePage)))
    {
        DWORD dwFlag ;

        m_pMsg->GetFlags(&dwFlag);

        // for tagged message only
        if ((dwFlag & IMF_CSETTAGGED) && !dwCodePage )
            fSaveLang = TRUE; // was !IntlCharsetMapLanguageCheck(hOldCharset, hNewCharset); We have
    }
#endif

    // save language change to message store
    if (fSaveLang)
    {
        MimeOleGetCharsetInfo(hNewCharset, &CsetInfo);
        dwCodePage = CsetInfo.cpiInternet;

        // Get index again incase user changed row during dialog
        if (FAILED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
            goto Exit;

        hr = m_pMsgTable->SetLanguage(1, &iRow, dwCodePage);
        if (FAILED(hr))
            AthMessageBoxW(  GetCallbackHwnd(), MAKEINTRESOURCEW(idsAthena), 
                            MAKEINTRESOURCEW((hr == hrIncomplete)?idsViewLangMimeDBBad:idsErrViewLanguage), 
                            NULL, MB_OK|MB_ICONEXCLAMATION);
    }

Exit:
    return hr;
}

// ****************************************
HRESULT COEMsgSite::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, STOREOPERATIONTYPE *ptyNewOp)
{
    // Action wasn't inited in MsgSite
    if (MSA_IDLE == m_dwMSAction)
        return S_OK;

    if (ptyNewOp)
        *ptyNewOp = SOT_INVALID;

    switch (tyOperation)
    {
        case SOT_GET_MESSAGE:
            HandleGetMessage(hrComplete);
            break;

        case SOT_DELETING_MESSAGES:
            HandleDelete(hrComplete);
            break;

        case SOT_PUT_MESSAGE:
            HandlePut(hrComplete, ptyNewOp);
            break;

        case SOT_COPYMOVE_MESSAGE:
            HandleCopyMove(hrComplete);
            SafeRelease(m_pFolderReleaseOnComplete);
            break;

#ifdef DEBUG
        default:
            AssertSz(!m_pCBMsgFolder, "How did we get here with a CBMsgFolder");
#endif
    }

    return S_OK;
}

// ****************************************
HRESULT COEMsgSite::UpdateCallbackInfo(LPSTOREOPERATIONINFO pOpInfo)
{
    if (pOpInfo->idMessage != MESSAGEID_INVALID)
    {
        m_fHaveCBMessageID = TRUE;
        m_CBMessageID = pOpInfo->idMessage;
    }
    return S_OK;
}

// ****************************************
// Need to handle MSA_SAVE, MSA_SEND, MSA_COPYMOVE
void COEMsgSite::HandlePut(HRESULT hr, STOREOPERATIONTYPE *ptyNewOp)
{
    // If is COPYMOVE, simply redirect to proper function
    if (MSA_COPYMOVE == m_dwMSAction)
    {
        HandleCopyMove(hr);
        if (ptyNewOp)
            *ptyNewOp = SOT_PUT_MESSAGE;
        return;
    }

    SafeRelease(m_pCBMsgFolder);
    if (FAILED(hr))
        goto Exit;

    switch (m_dwMSAction)
    {
        case MSA_SAVE:
        {
            // Decide whether need to delete old message or not
            switch (m_dwInitType)
            {
                case OEMSIT_MSG_TABLE:
                {
                    if (m_fCBSaveInFolderAndDelOrig)
                    {
                        ROWINDEX iRow = 0;
                        hr = m_pMsgTable->GetRowIndex(m_MessageID, &iRow);
                        if (SUCCEEDED(hr))
                            hr = m_pMsgTable->DeleteRows(
                                    DELETE_MESSAGE_NOTRASHCAN | 
                                    DELETE_MESSAGE_NOPROMPT | 
                                    DELETE_MESSAGE_MAYIGNORENOTRASH,
                                    1, &iRow, FALSE, m_pStoreCB);
                        if (SUCCEEDED(hr))
                            OnComplete(SOT_DELETING_MESSAGES, S_OK);
                        else if ((E_PENDING == hr) && ptyNewOp)
                            *ptyNewOp = SOT_DELETING_MESSAGES;
                    }
                    else
                    {

                        m_dwInitType = OEMSIT_STORE;
                        m_fThreadingEnabled = FALSE;
                        m_FolderID = m_CBFolderID;
                    }
                    m_MessageID = m_CBMessageID;
                    if (!m_fHaveCBMessageID)
                    {
                        m_dwInitType = OEMSIT_MSG;
                    }
                    break;
                }

                // Always delete since our message was in drafts and is being saved to drafts
                case OEMSIT_STORE:
                {
                    hr = DeleteFromStore(
                            DELETE_MESSAGE_NOTRASHCAN | 
                            DELETE_MESSAGE_NOPROMPT | 
                            DELETE_MESSAGE_MAYIGNORENOTRASH);
                    if ((E_PENDING == hr) && ptyNewOp)
                        *ptyNewOp = SOT_DELETING_MESSAGES;
                    else if (SUCCEEDED(hr))
                        OnComplete(SOT_DELETING_MESSAGES, S_OK);
                    break;
                }

                case OEMSIT_FAT:
                case OEMSIT_MSG:
                case OEMSIT_VIRGIN:
                    // This folder id should always be drafts.
                    m_FolderID = m_CBFolderID;
                    if ((FOLDERID_INVALID != m_FolderID) && m_fHaveCBMessageID)
                    {
                        m_MessageID = m_CBMessageID;
                        m_dwInitType = OEMSIT_STORE;
                        m_fThreadingEnabled = FALSE;
                    }
                    else
                        m_dwInitType = OEMSIT_MSG;

                    break;
            }
            if (m_fCBSavedInDrafts)
                DoDontShowMeAgainDlg(GetCallbackHwnd(), c_szDSSavedInSavedItems, 
                            MAKEINTRESOURCE(idsSavedMessage), 
                            MAKEINTRESOURCE(idsSavedInDrafts), 
                            MB_OK);

            break;
        }

        // Don't do anything with send. Just be happy that it worked.
        case MSA_SEND:
            break;

        default:
            AssertSz(FALSE, "Didn't expect to get PUT with other MsgSite action.");
    }


Exit:
    if (hr != E_PENDING)
        m_dwMSAction = MSA_IDLE;
}

void COEMsgSite::HandleGetMessage(HRESULT hr)
{
    if (SUCCEEDED(hr))
    {
        HRESULT tempHr;
        LoadMessageFromTable(TRUE, &tempHr);
        AssertSz(SUCCEEDED(tempHr), "If hr succeeded, tempHr should have as well.");

        m_fHeaderOnly = FALSE;
        Notify(OEMSN_UPDATE_PREVIEW);
        SetFocus(GetCallbackHwnd());
    }

    // Success or failure, we've loaded the target msg. Go to idle
    m_dwMSAction = MSA_IDLE;
}

HRESULT COEMsgSite::Notify(DWORD dwNotifyID)
{
    HRESULT     hr = S_OK;

    switch (dwNotifyID)
    {
        case OEMSN_UPDATE_PREVIEW:
        {
            if ((OEMSIT_MSG_TABLE == m_dwInitType) && (0 != m_MessageID))
            {
                ROWINDEX iRow = 0;
                if (SUCCEEDED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
                    m_pListSelect->SetActiveRow(iRow);
            }
            break;
        }

        case OEMSN_TOGGLE_READRCPT_REQ:
        {
            if (!!(m_dwMDNFlags & MDN_REQUEST))
            {
                m_dwMDNFlags = m_dwMDNFlags & (~MDN_REQUEST);
            }
            else
            {
                m_dwMDNFlags |= MDN_REQUEST;
            }
            break;
        }

        case OEMSN_PROCESS_READRCPT_REQ:
        {
            ROWINDEX    rowIndex = 0;

            if ((OEMSIT_MSG_TABLE == m_dwInitType) && (0 != m_MessageID))
            {

                IF_FAILEXIT(hr = m_pMsgTable->GetRowIndex(m_MessageID, &rowIndex));

                if (!(m_dwArfFlags & ARF_READ))
                {
                    IF_FAILEXIT(hr = ProcessReturnReceipts(m_pMsgTable, m_pStoreCB, rowIndex, READRECEIPT, m_FolderID, m_pMsg));
                }
            }
            break;
        }
    }

exit:

    return hr;
}

// ****************************************
// Need to handle MSA_DELETE, MSA_COPYMOVE, and MSA_SAVE
void COEMsgSite::HandleDelete(HRESULT hr)
{
    AssertSz((MSA_DELETE == m_dwMSAction) || (MSA_COPYMOVE == m_dwMSAction) || (MSA_SAVE == m_dwMSAction), 
                "Didn't expect to get DELETE with other MsgSite action.");

    SafeRelease(m_pCBMsgFolder);

    // If came from COPYMOVE, then don't do anything here.
    if (FAILED(hr))
        goto exit;

    if (MSA_COPYMOVE == m_dwMSAction)
    {
        m_FolderID = m_CBFolderID;
        m_MessageID = m_CBMessageID;
    }
    else if (MSA_SAVE == m_dwMSAction)
    {
        m_FolderID = m_CBFolderID;
        m_MessageID = m_CBMessageID;
        if (m_pListSelect && (OEMSIT_MSG_TABLE == m_dwInitType))
        {
            ROWINDEX iRow = 0;
            if (SUCCEEDED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
                m_pListSelect->SetActiveRow(iRow);
        }
    }

    // Then this must be a straight delete
    else
        switch (m_dwInitType)
        {
            case OEMSIT_MSG_TABLE:
                if (m_fGotNewID)
                {
                    m_MessageID = m_NewMessageID;
                    m_fNeedToLoadMsg = TRUE;
                    if (m_pListSelect)
                    {
                        ROWINDEX iRow = 0;
                        if (SUCCEEDED(m_pMsgTable->GetRowIndex(m_MessageID, &iRow)))
                            m_pListSelect->SetActiveRow(iRow);
                    }
                }
                else
                {
                    m_fValidMessage = FALSE;
                }
                break;

            // Do nothing if from store
            case OEMSIT_STORE:
                break;

        }

exit:
    
    // If doing copy move, I expect SOT_DELETING_MESSAGES to be called before SOT_COPYMOVE_MESSAGE
    m_dwMSAction = MSA_IDLE;
}

// ****************************************
// Need to handle MSA_COPYMOVE
void COEMsgSite::HandleCopyMove(HRESULT hr)
{

    AssertSz(MSA_COPYMOVE == m_dwMSAction, "Didn't expect to get COPYMOVE with other MsgSite action.");

    SafeRelease(m_pCBMsgFolder);

    if (FAILED(hr) || m_fCBCopy)
        goto Exit;

    switch (m_dwCMFState)
    {
        case CMF_MSG_TO_FOLDER:
            // Don't need to worry about anything
            break;

        case CMF_TABLE_TO_FOLDER:
        {
            // If we are moving and there is a valid bookmark to go to, then set up the note to have the next message
            if (m_fGotNewID)
            {
                m_MessageID = m_NewMessageID;
                m_fNeedToLoadMsg = TRUE;
            }
            else
                m_fValidMessage = FALSE;
            break;
        }

        case CMF_STORE_TO_FOLDER:
        {
            FOLDERID        folderID;
            MESSAGEIDLIST   rMsgIDList;

            Assert(m_pStoreCB);

            rMsgIDList.cAllocated = 0;
            rMsgIDList.cMsgs = 1;
            rMsgIDList.prgidMsg = &m_MessageID;
            hr = g_pStore->OpenFolder(m_FolderID, NULL, NOFLAGS, &m_pCBMsgFolder);
            if (FAILED(hr))
                goto Exit;

            // Don't really care if this works.
            hr = m_pCBMsgFolder->DeleteMessages(
                        DELETE_MESSAGE_NOTRASHCAN | 
                        DELETE_MESSAGE_NOPROMPT |
                        DELETE_MESSAGE_MAYIGNORENOTRASH, 
                        &rMsgIDList, NULL, m_pStoreCB);
            AssertSz(E_PENDING != hr, "Didn't expect E_PENDING here.")
            if (SUCCEEDED(hr))
                OnComplete(SOT_DELETING_MESSAGES, S_OK);

            break;
        }

        case CMF_FAT_TO_FOLDER:
        {
            DeleteFileWrapW(m_rgwchFileName);

            // Need to shut down the note.
            m_fValidMessage = FALSE;
            break;
        }
    }

Exit:
    // I expect SOT_DELETING_MESSAGES to be called before SOT_COPYMOVE_MESSAGE
    m_dwMSAction = MSA_IDLE;
    m_dwCMFState = CMF_UNINITED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\note.h ===
#ifndef _NOTE_H_
#define _NOTE_H_

#include "imsgsite.h"
#include "ibodyopt.h"
#include "iheader.h"
#include "statbar.h"
#include "ibodyobj.h"
#include "msgsite.h"
#include "options.h"
#include "acctutil.h"
#include "dllmain.h"
#include "tbbands.h"
#include "msident.h"
#include "storutil.h"

enum NOTEINITSTATE
{
    NIS_INIT = -1,
    NIS_NORMAL = 0,
    NIS_FIXFOCUS = 1
};

// As header, body and attman add additional items that should
// be included in the tab order, these items might need to 
// be increased
const int MAX_HEADER_COMP = 11;
const int MAX_BODY_COMP = 1;
const int MAX_ATTMAN_COMP = 1;

class COEMsgSite;
interface IBodyObj2;

class CNote : 
    public IOENote,
    public IBodyOptions,
    public IDropTarget,
    public IHeaderSite,
    public IPersistMime,
    public IServiceProvider,
    public IDockingWindowSite,
    public IMimeEditEventSink,
    public IIdentityChangeNotify,
    public IOleCommandTarget,
    public IStoreCallback,
    public ITimeoutCallback
{
public:
    CNote();
    ~CNote();

    // IUnknown
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    // IOENote
    virtual HRESULT STDMETHODCALLTYPE Init(DWORD action, DWORD dwCreateFlags, RECT *prc, HWND hwnd, 
                                           INIT_MSGSITE_STRUCT *pInitStruct, IOEMsgSite *pMsgSite, 
                                           IUnknown *punkPump);
    virtual HRESULT STDMETHODCALLTYPE Show(void);
    virtual HRESULT ToggleToolbar(void);

    // IBodyOptions
    virtual HRESULT STDMETHODCALLTYPE SignatureEnabled(BOOL fAuto);
    virtual HRESULT STDMETHODCALLTYPE GetSignature(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE GetMarkAsReadTime(LPDWORD pdwSecs);
    virtual HRESULT STDMETHODCALLTYPE GetFlags(LPDWORD pdwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetInfo(BODYOPTINFO *pBOI);
    virtual HRESULT STDMETHODCALLTYPE GetAccount(IImnAccount **ppAcct);

    // IHeaderSite
    virtual HRESULT STDMETHODCALLTYPE Resize(void);
    virtual HRESULT STDMETHODCALLTYPE Update(void);
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE IsHTML(void);
    virtual HRESULT STDMETHODCALLTYPE SetHTML(BOOL);
    virtual HRESULT STDMETHODCALLTYPE SaveAttachment(void);
    virtual HRESULT STDMETHODCALLTYPE IsModal();
    virtual HRESULT STDMETHODCALLTYPE CheckCharsetConflict();
    virtual HRESULT STDMETHODCALLTYPE ChangeCharset(HCHARSET hCharset);
    virtual HRESULT STDMETHODCALLTYPE GetCharset(HCHARSET *phCharset);
#ifdef SMIME_V3
    virtual HRESULT STDMETHODCALLTYPE GetLabelFromNote(PSMIME_SECURITY_LABEL *plabel);
    virtual HRESULT STDMETHODCALLTYPE IsSecReceiptRequest(void);
    virtual HRESULT STDMETHODCALLTYPE IsForceEncryption(void);
#endif

    // IPersistMime
    virtual HRESULT STDMETHODCALLTYPE IsDirty(void);
    virtual HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE);
    virtual HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE InitNew(void);
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    // IDropTarget methods
    HRESULT STDMETHODCALLTYPE DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT STDMETHODCALLTYPE DragLeave(void);
    HRESULT STDMETHODCALLTYPE Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IServiceProvider
    HRESULT STDMETHODCALLTYPE QueryService(REFGUID rsid, REFIID riid, void **ppvObj);

    // IMimeEditEventSink
    HRESULT STDMETHODCALLTYPE EventOccurred(DWORD cmdID, IMimeMessage *pMessage);

    // IIdentityChangeNotify
    HRESULT STDMETHODCALLTYPE QuerySwitchIdentities();
    HRESULT STDMETHODCALLTYPE SwitchIdentities();
    HRESULT STDMETHODCALLTYPE IdentityInformationChanged(DWORD dwType);

    // IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IDockingWindowSite (also IOleWindow)
    HRESULT STDMETHODCALLTYPE GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder);
    HRESULT STDMETHODCALLTYPE RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    HRESULT STDMETHODCALLTYPE SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);
    
    // IOleWindow methods
    HRESULT STDMETHODCALLTYPE GetWindow (HWND * lphwnd);
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode) {return E_NOTIMPL;};

    // IStoreCallback methods
    HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    // ITimeoutCallback
    HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

    HRESULT TranslateAccelerator(LPMSG lpmsg);
    static LRESULT EXPORT_16 CALLBACK ExtNoteWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT IsMenuMessage(MSG *lpmsg);

protected:
    BOOL IsFlagged(DWORD dwFlag = ARF_FLAGGED);
    BOOL FCanClose();
    BOOL IsReplyNote();
    BOOL DoProperties();
    BOOL WMCreate(HWND hwnd);

    void WMNCDestroy();
    void FormatSettings();
    void ToggleFormatbar();
    void ToggleStatusbar();
    void OnDocumentReady();
    void InitSendAndBccBtns();
    void DeferedLanguageMenu();
    void DisableSendNoteOnlyMenus();

    void WMSize(int, int, BOOL);
    void RemoveNewMailIcon(void);
    void SwitchLanguage(int idm);
    void SetProgressPct(INT iPct);
    void SetStatusText(LPSTR szBuf);
    void GetNoteMenu(HMENU *phmenu);
    void ShowErrorScreen(HRESULT hr);
    void WMGetMinMaxInfo(LPMINMAXINFO pmmi);
    void WMNotify(int idFrom, NMHDR *pnmhdr);
    void UpdateMsgOptions(LPMIMEMESSAGE pMsg);
    void ReloadMessageFromSite(BOOL fOriginal = FALSE);
    void ChangeReadToComposeIfUnsent(IMimeMessage *pMsg);
    void EnableNote(BOOL fEnable);
    HRESULT _SetPendingOp(STOREOPERATIONTYPE tyOperation);

    void _OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete) ;

    HRESULT InitBodyObj();
    HRESULT OnKillFocus();
    HRESULT UpdateTitle();
    HRESULT SaveMessage(DWORD dwSaveFlags);
    HRESULT SaveMessageAs();
    HRESULT ClearDirtyFlag();
    HRESULT CheckTabStopArrays();
    HRESULT CommitChangesInNote();
    HRESULT InitMenusAndToolbars();
    HRESULT SetComposeStationery();

    HRESULT HrSendMail(int idm);
    HRESULT OnSetFocus(HWND hwndFrom);
    HRESULT SetCharsetUnicodeIfNeeded(IMimeMessage *pMsg);
    HRESULT CycleThroughControls(BOOL fForward);
    HRESULT InitWindows(RECT *prc, HWND ownerHwnd);
    HRESULT WMCommand(HWND hwndCmd, int id, WORD wCmd);
    HRESULT MarkMessage(MARK_TYPE dwFlags, APPLYCHILDRENTYPE dwApplyType);
    HRESULT HeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn);

    LRESULT WMInitMenuPopup(HWND, HMENU, UINT);
    LRESULT OnDropDown(HWND hwnd, LPNMHDR lpnmh);
    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    LRESULT OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, UINT wID);
    LRESULT NoteDefWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    INT GetRequiredHdrHeight();
    HACCEL GetAcceleratorTable();
    int GetNextIndex(int index, BOOL fForward);
    LONG lTestHook(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BYTE    GetNoteType();
    void    ResizeChildren(int cxNote, int cyNote, int cy, BOOL fInternal);
    void    CheckAndForceEncryption(void);
private:
    CStatusBar         *m_pstatus;

    // Used to make sure that special pumps for note don't close while note is open.
    // This was initially for the finder.
    IUnknown           *m_punkPump; 

    IOEMsgSite         *m_pMsgSite;
    IHeader            *m_pHdr;
    IMimeMessage       *m_pMsg;
    IPersistMime       *m_pPrstMime;
    IBodyObj2          *m_pBodyObj2;
    IOleCommandTarget  *m_pCmdTargetHdr,
                       *m_pCmdTargetBody;
    IDropTarget        *m_pDropTargetHdr,
                       *m_pTridentDropTarget;
    IOperationCancel   *m_pCancel;

    HTMLOPT             m_rHtmlOpt;
    PLAINOPT            m_rPlainOpt;
    MARK_TYPE           m_dwCBMarkType;
    STOREOPERATIONTYPE  m_OrigOperationType;

    HCHARSET            m_hCharset;
    HBITMAP             m_hbmBack;
    HICON               m_hIcon;
    HCURSOR             m_hCursor;
    HTIMEOUT            m_hTimeout;

    LPACCTMENU          m_pAcctMenu,
                        m_pAcctLater;
    int                 m_cTabStopCount,
                        m_iIndexOfBody;
    NOTEINITSTATE       m_nisNoteState;
    CRITICAL_SECTION    m_csNoteState;
    HMENU               m_hmenuLanguage,
                        m_hmenuAccounts,
                        m_hmenuLater;
    ULONG               m_cRef, 
                        m_ulPct,
                        m_cAcctMenu,
                        m_cAcctLater;
    DWORD               m_dwNoteCreateFlags,
                        m_dwNoteAction,
                        m_dwMarkOnReplyForwardState,
                        m_dwIdentCookie;
    HWND                m_hwnd,
                        m_pTabStopArray[MAX_HEADER_COMP+MAX_BODY_COMP+MAX_ATTMAN_COMP],
                        m_hwndFocus,
                        m_hwndOwner,
                        m_hwndToolbar;
    BOOL                m_fHtml                 :1,     // Tells whether we are in html mode or not
                        m_fMail                 :1,     // This will be removed when the UI is combined
                        m_fReadNote             :1,     // Is this a read note?
                        m_fPackageImages        :1,     // Toggled per note. Use to be m_fSendImages
                        m_fUseStationeryFonts   :1,     // Keep fonts that are in the stationary
                        m_fToolbarVisible       :1,     // Is toolbar visible
                        m_fStatusbarVisible     :1,     // Is status bar visible
                        m_fFormatbarVisible     :1,     // Is the format bar visible
                        m_fHeaderUIActive       :1,     // Are we currently active?
                        m_fBypassDropTests      :1,     // Used to say drop not acceptable. Use to be m_fNoText
                        m_fCompleteMsg          :1,     // Is true if message contains all of message
                        m_fTabStopsSet          :1,     // Have the tab stops been set up???
                        m_fBodyContainsFrames   :1,     // Was previously m_fReadOnlyBody
                        m_fOriginallyWasRead    :1,     // Initial NoteAction was OENA_READ
                        m_fCBDestroyWindow      :1,     // Destroy window after callback complete
                        m_fCBCopy               :1,     // Used during callback complete to tell if copied or moved.
                        m_fFlagged              :1,     // Is message flagged
                        m_fFullHeaders          :1,     // Show full headers
                        m_fWindowDisabled       :1,     // Is the window disabled? 
                        m_fProgress             :1,
                        m_fOrgCmdWasDelete      :1,     // Delete from callback wasn't originally a save or move/copy
                        m_fCommitSave           :1,     // Used to say that when you save, you should call commit
                        m_fOnDocReadyHandled    :1,     // Used in the OnDocumentReady function.
                        m_fUseReplyHeaders      :1,     // Use reply headers
                        m_fHasBeenSaved         :1,     // Is this a message that has been saved (ie ID_SAVE)
                        m_fInternal             :1,     // used to enable/disable thread windows
                        m_fSecurityLabel        :1,     // used for security labels
                        m_fSecReceiptRequest    :1,     // used for security receipt request
                        m_fPreventConflictDlg   :1,     // make sure we only show charset conflictdlg once per save
                        m_fForceClose           :1;     // used when forcing a destory

    RECT                m_rcRebar;
    CBands             *m_pToolbarObj;
    HWND                m_hwndRebar;
    HMENU               m_hMenu;
    HWNDLIST            m_hlDisabled;
    DWORD               m_dwRequestMDNLocked;
#ifdef SMIME_V3
    PSMIME_SECURITY_LABEL m_pLabel;
#endif // SMIME_V3
};

BOOL Note_Init(BOOL);
HRESULT CreateOENote(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT CreateAndShowNote(DWORD dwAction, DWORD dwCreateFlags, INIT_MSGSITE_STRUCT *pInitStruct, 
                          HWND hwnd = 0, IUnknown *punk = NULL, RECT *prc = NULL, IOEMsgSite *pMsgSite = NULL);

void SetTlsGlobalActiveNote(CNote* pNote);
CNote* GetTlsGlobalActiveNote(void);
void InitTlsActiveNote();
void DeInitTlsActiveNote();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\note.cpp ===
#include "pch.hxx"
#include "note.h"
#include "header.h"
#include "envcid.h"
#include "envguid.h"
#include "bodyutil.h"
#include "sigs.h"
#include "mehost.h"
#include "conman.h"
#include "menuutil.h"
#include "url.h"
#include "fonts.h"
#include "multlang.h"
#include "statnery.h"
#include "spell.h"
#include "oleutil.h"
#include "htmlhelp.h"
#include "shared.h"
#include "acctutil.h"
#include "menures.h"
#include "instance.h"
#include "inetcfg.h"
#include "ipab.h"
#include "msgprop.h"
#include "finder.h"
#include "tbbands.h"
#include "demand.h"
#include "multiusr.h"
#include <ruleutil.h>
#include "instance.h"
#include "mapiutil.h"
#include "regutil.h"
#include "storecb.h"
#include "receipts.h"
#include "mirror.h"
#include "secutil.h"
#include "seclabel.h"
#include "shlwapip.h"
#include "mshtmcid.h"

#define cxRect(rc)  (rc.right - rc.left)
#define cyRect(rc)  (rc.bottom - rc.top)
#define cyMinEdit   30

enum {
    MORFS_UNKNOWN = 0,
    MORFS_CLEARING,
    MORFS_SETTING,
};

// Static Variables
static const TCHAR  c_szEditWebPage[] = "EditWebPages";

static DWORD        g_dwTlsActiveNote = 0xffffffff;
static HIMAGELIST   g_himlToolbar = 0;
static RECT         g_rcLastResize = {50,30,450,450};    // default size
static HACCEL       g_hAccelRead = 0,
                    g_hAccelSend = 0;

//Static Functions

void SetTlsGlobalActiveNote(CNote* pNote)
{
    SideAssert(0 != TlsSetValue(g_dwTlsActiveNote, pNote));
}

CNote* GetTlsGlobalActiveNote(void) 
{ 
    return (CNote*)TlsGetValue(g_dwTlsActiveNote); 
}

void InitTlsActiveNote()
{
    // Allocate a global TLS active note index
    g_dwTlsActiveNote = TlsAlloc();
    Assert(g_dwTlsActiveNote != 0xffffffff);
    SideAssert(0 != TlsSetValue(g_dwTlsActiveNote, NULL));
}

void DeInitTlsActiveNote()
{
    // Free the tls index
    TlsFree(g_dwTlsActiveNote);
    g_dwTlsActiveNote = 0xffffffff;
}

// *************************
HRESULT CreateOENote(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    TraceCall("CreateOENote");

    Assert(ppUnknown);

    *ppUnknown = NULL;

    // Create me
    CNote *pNew = new CNote();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IOENote *);

    // Done
    return S_OK;
}

// *************************
BOOL Note_Init(BOOL fInit)
{
    static BOOL     fInited=FALSE;
    WNDCLASSW       wc;

    DOUTL(4, "Note_Init: %d", (int)fInit);

    if(fInit)
    {
        if(fInited)
        {
            DOUTL(4, "Note_Init: already inited");
            return TRUE;
        }
        wc.style         = CS_BYTEALIGNWINDOW;
        wc.lpfnWndProc   = CNote::ExtNoteWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = g_hInst;
        wc.hIcon         = LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiMessageAtt));
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_wszNoteWndClass;

        if(!RegisterClassWrapW(&wc))
            return FALSE;

        if(!FHeader_Init(TRUE))
            return FALSE;

        fInited=TRUE;
        DOUTL(4, "Note_Init: success");

        return TRUE;
    }
    else
    {
        // save back to registry
        UnregisterClassWrapW(c_wszNoteWndClass, g_hInst);
        if(g_himlToolbar)
        {
            ImageList_Destroy(g_himlToolbar);
            g_himlToolbar=0;
        }

        FHeader_Init(FALSE);

        fInited=FALSE;
        DOUTL(4, "Note_Init: deinit OK");
        return TRUE;
    }
}

HRESULT _HrBlockSender(RULE_TYPE typeRule, IMimeMessage * pMsg, HWND hwnd)
{
    HRESULT         hr = S_OK;
    ADDRESSPROPS    rSender = {0};
    CHAR            szRes[CCHMAX_STRINGRES];
    LPSTR           pszResult = NULL;

    // Check incoming params
    if ((NULL == pMsg) || (NULL == hwnd))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get the address to add
    rSender.dwProps = IAP_EMAIL;
    hr = pMsg->GetSender(&rSender);
    if (FAILED(hr))
    {
        goto exit;
    }
        
    Assert(ISFLAGSET(rSender.dwProps, IAP_EMAIL));
    if ((NULL == rSender.pszEmail) || ('\0' == rSender.pszEmail[0]))
    {
        goto exit;
    }

    // Add the sender to the list
    hr = RuleUtil_HrAddBlockSender(typeRule, rSender.pszEmail);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Load the template string
    AthLoadString(idsSenderAdded, szRes, sizeof(szRes));

    // Allocate the space to hold the final string
    DWORD cchSize = (lstrlen(szRes) + lstrlen(rSender.pszEmail) + 1);
    hr = HrAlloc((VOID **) &pszResult, sizeof(*pszResult) * cchSize);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Build up the warning string
    wnsprintf(pszResult, cchSize, szRes, rSender.pszEmail);

    // Show the success dialog
    AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), pszResult, NULL, MB_OK | MB_ICONINFORMATION);

    // Set the return value
    hr = S_OK;

exit:
    SafeMemFree(pszResult);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSenderError), NULL, MB_OK | MB_ICONERROR);
    }
    return hr;
}

// *************************
LRESULT CALLBACK CNote::ExtNoteWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CNote *pNote=0;

    if(msg==WM_CREATE)
    {
        pNote=(CNote*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(pNote && pNote->WMCreate(hwnd))
            return 0;
        else
            return -1;
    }

    pNote = (CNote*)GetWndThisPtr(hwnd);
    if(pNote)
    {
        return pNote->WndProc(hwnd, msg, wParam, lParam);
    }
    else
        return DefWindowProcWrapW(hwnd, msg, wParam, lParam);
}

// *************************
CNote::CNote()
{
    // Initialized in Init:
    //      m_rHtmlOpt
    //      m_rPlainOpt
    // Set before used:
    //      m_pTabStopArray

    CoIncrementInit("CNote", MSOEAPI_START_SHOWERRORS, NULL, NULL);
    m_punkPump = NULL;
    m_pHdr = NULL; 
    m_pMsg = NULL; 
    m_pCancel = NULL;
    m_pstatus = NULL;
    m_pMsgSite = NULL; 
    m_pPrstMime = NULL;
    m_pBodyObj2 = NULL; 
    m_pCmdTargetHdr = NULL; 
    m_pCmdTargetBody = NULL;
    m_pDropTargetHdr = NULL; 
    m_pTridentDropTarget = NULL;
    m_pToolbarObj = NULL;

    m_hwnd = 0; 
    m_hMenu = 0;
    m_hIcon = 0;
    m_hbmBack = 0; 
    m_hCursor = 0;
    m_hCharset = 0; 
    m_hTimeout = 0;
    m_hwndRebar = 0;
    m_hwndFocus = 0; 
    m_hwndOwner = 0; 
    m_hmenuLater = 0;
    m_hwndToolbar = 0; 
    m_hmenuAccounts = 0; 
    m_hmenuLanguage = 0; 

    m_dwNoteAction = 0; 
    m_dwIdentCookie = 0;
    m_dwNoteCreateFlags = 0; 
    m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
    m_dwCBMarkType = MARK_MAX;
    m_OrigOperationType = SOT_INVALID;

    m_fHtml = TRUE; 
    m_fMail = TRUE; 
    m_fCBCopy = FALSE;
    m_fReadNote = FALSE; 
    m_fProgress = FALSE;
    m_fCommitSave = TRUE;
    m_fTabStopsSet = FALSE; 
    m_fCompleteMsg = FALSE; 
    m_fHasBeenSaved = FALSE;
    m_fPackageImages = TRUE; 
    m_fWindowDisabled = FALSE;
    m_fHeaderUIActive = FALSE; 
    m_fOrgCmdWasDelete = FALSE;
    m_fUseReplyHeaders = FALSE;
    m_fCBDestroyWindow = FALSE;
    m_fBypassDropTests = FALSE; 
    m_fOnDocReadyHandled = FALSE;
    m_fOriginallyWasRead = FALSE;
    m_fUseStationeryFonts = FALSE; 
    m_fBodyContainsFrames = FALSE; 
    m_fPreventConflictDlg = FALSE;
    m_fInternal = FALSE;
    m_fForceClose = FALSE;

    m_pLabel = NULL;
    if(FPresentPolicyRegInfo() && IsSMIME3Supported())
    {
        m_fSecurityLabel = !!DwGetOption(OPT_USE_LABELS);
        HrGetOELabel(&m_pLabel);
    }
    else
        m_fSecurityLabel = FALSE;

    if(IsSMIME3Supported())
    {
        m_fSecReceiptRequest = !!DwGetOption(OPT_SECREC_USE);
    }
    else
        m_fSecReceiptRequest = FALSE;

    m_ulPct = 0;
    m_iIndexOfBody = -1;    

    m_cRef = 1; 
    m_cAcctMenu = 0; 
    m_cAcctLater = 0; 
    m_cTabStopCount = 0; 

    m_fStatusbarVisible = !!DwGetOption(OPT_SHOW_NOTE_STATUSBAR);
    m_fFormatbarVisible = !!DwGetOption(OPT_SHOW_NOTE_FMTBAR);
    
    InitializeCriticalSection(&m_csNoteState);
    m_nisNoteState = NIS_INIT;

    if (!g_hAccelRead)
        g_hAccelRead = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_READ_NOTE_ACCEL));
    if (!g_hAccelSend)
        g_hAccelSend = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(IDA_SEND_NOTE_ACCEL));

    ZeroMemory(&m_hlDisabled, sizeof(HWNDLIST));

    m_dwRequestMDNLocked = GetLockKeyValue(c_szRequestMDNLocked);    
}

// *************************
CNote::~CNote()
{
    if (0 != m_hmenuLanguage)
    {
        // unload global MIME language codepage data
        DeinitMultiLanguage();
        DestroyMenu(m_hmenuLanguage);
    }

    if (m_hMenu != NULL)
        DestroyMenu(m_hMenu);

    if (m_hIcon)
        DestroyIcon(m_hIcon);

    if (m_hbmBack)
        DeleteObject(m_hbmBack);

    // sometimes we get a setfocus in our processing of DestroyWindow
    // this causes a WM_ACTIVATE to the note without a corresponding
    // WM_DEACTIVATE. if at the time the note dies, the global note ptr
    // has our this ptr in it, null it out to be safe.
    if (this == GetTlsGlobalActiveNote())
    {
        Assert(!(m_dwNoteCreateFlags & OENCF_MODAL));
        SetTlsGlobalActiveNote(NULL);
    }

    SafeMemFree(m_pLabel);

    ReleaseObj(m_pMsg);
    ReleaseObj(m_pHdr);
    ReleaseObj(m_pstatus);
    ReleaseObj(m_pCancel);
    ReleaseObj(m_pMsgSite);
    ReleaseObj(m_punkPump);
    ReleaseObj(m_pPrstMime);
    ReleaseObj(m_pBodyObj2);
    ReleaseObj(m_pCmdTargetHdr);
    ReleaseObj(m_pCmdTargetBody);
    ReleaseObj(m_pDropTargetHdr);
    ReleaseObj(m_pTridentDropTarget);

    SafeRelease(m_pToolbarObj);    

    CallbackCloseTimeout(&m_hTimeout);
    
    DeleteCriticalSection(&m_csNoteState);
    CoDecrementInit("CNote", NULL);    
}

// *************************
ULONG CNote::AddRef()
{
    return ++m_cRef;
}

// *************************
ULONG CNote::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// *************************
HRESULT CNote::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    HRESULT hr;

    if(!ppvObj)
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = ((IUnknown *)(IOENote *)this);
    else if(IsEqualIID(riid, IID_IOENote))
        *ppvObj = (IOENote *)this;
    else if (IsEqualIID(riid, IID_IBodyOptions))
        *ppvObj = (IBodyOptions *)this;
    else if(IsEqualIID(riid, IID_IDropTarget))
        *ppvObj = (IDropTarget *)this;
    else if (IsEqualIID(riid, IID_IHeaderSite))
        *ppvObj = (IHeaderSite *)this;
    else if(IsEqualIID(riid, IID_IPersistMime))
        *ppvObj = (IPersistMime *)this;
    else if(IsEqualIID(riid, IID_IServiceProvider))
        *ppvObj = (IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IDockingWindowSite))
        *ppvObj = (IDockingWindowSite*)this;
    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (IIdentityChangeNotify*)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (IOleCommandTarget*)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (ITimeoutCallback *) this;
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    hr = NOERROR;

exit:
    return hr;
}

// *************************
HRESULT CNote::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (!rgCmds)
        return E_INVALIDARG;
    if (!pguidCmdGroup)
        return hr;

    // We are closing down
    if (!m_pMsgSite)
        return E_UNEXPECTED;

    if (m_pCmdTargetHdr)
        m_pCmdTargetHdr->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
        
    if (m_pCmdTargetBody)
        m_pCmdTargetBody->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);
    
    MenuUtil_NewMessageIDsQueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText, m_fMail);

    if (IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
    {
        DWORD   dwStatusFlags = 0;
        BOOL    fCompleteMsg = !!m_fCompleteMsg;
        BOOL    fHtmlSettingsOK = m_fHtml && !m_fBodyContainsFrames;

        m_pMsgSite->GetStatusFlags(&dwStatusFlags);

        for (ULONG ul = 0; ul < cCmds; ul++)
        {
            ULONG cmdID = rgCmds[ul].cmdID;

            // There are certain cases that need to be overridden even if the earlier
            // components enabled or disabled them. They are in this switch statement.
            switch (cmdID)
            {
                // Until trident allows printing in edit mode, don't allow this. RAID 35635
                case ID_PRINT:
                case ID_PRINT_NOW:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && m_fReadNote);
                    continue;
            }

            if (0 != rgCmds[ul].cmdf)
                continue;

            switch (cmdID)
            {
                case ID_POPUP_LANGUAGE:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg);
                    break;

                case ID_NOTE_SAVE_AS:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg || !m_fReadNote);
                    break;

                case ID_WORK_OFFLINE:
                    rgCmds[ul].cmdf = QS_CHECKED(g_pConMan->IsGlobalOffline());
                    break;

                case ID_CREATE_RULE_FROM_MESSAGE:
                case ID_BLOCK_SENDER:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && !m_fBodyContainsFrames && (0 == (OEMSF_RULESNOTENABLED & dwStatusFlags)));
                    break;

                case ID_REPLY:
                case ID_REPLY_ALL:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && !m_fBodyContainsFrames && fCompleteMsg);
                    break;

                case ID_REPLY_GROUP:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && !m_fBodyContainsFrames && !m_fMail && fCompleteMsg);
                    break;

                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fReadNote && fCompleteMsg);
                    break;

                case ID_UNSCRAMBLE:
                    rgCmds[ul].cmdf = QS_ENABLED(!m_fMail && m_fReadNote);
                    break;
                    
                case ID_POPUP_FORMAT:
                case ID_INSERT_SIGNATURE:
                    rgCmds[ul].cmdf = QS_ENABLED(!m_fBodyContainsFrames);
                    break;

                case ID_NOTE_COPY_TO_FOLDER:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && (OEMSF_CAN_COPY & dwStatusFlags));
                    break;

                // Can move message if is readnote, or compose note where the message was store based.
                case ID_NOTE_MOVE_TO_FOLDER:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && (OEMSF_CAN_MOVE & dwStatusFlags) && (m_fReadNote || (OENA_COMPOSE == m_dwNoteAction)));
                    break;

                case ID_NOTE_DELETE:
                    // We should be able to delete anything that msgsite says we can delete 
                    // so long as we are a read note, or we are a drafts message.
                    rgCmds[ul].cmdf = QS_ENABLED((OEMSF_CAN_DELETE & dwStatusFlags) && (m_fReadNote || (OENA_COMPOSE == m_dwNoteAction)));
                    break;

                case ID_REDO:
                    rgCmds[ul].cmdf = QS_ENABLED(m_fHeaderUIActive);
                    break;

                case ID_SAVE:
                    rgCmds[ul].cmdf = QS_ENABLED(fCompleteMsg && (OEMSF_CAN_SAVE & dwStatusFlags) && (m_fOnDocReadyHandled || !m_fReadNote));
                    break;

                case ID_NEXT_UNREAD_MESSAGE:
                case ID_NEXT_MESSAGE:
                    rgCmds[ul].cmdf = QS_ENABLED(OEMSF_CAN_NEXT & dwStatusFlags);
                    break;

                case ID_POPUP_NEXT:
                    rgCmds[ul].cmdf = QS_ENABLED((OEMSF_CAN_PREV & dwStatusFlags) || (OEMSF_CAN_NEXT & dwStatusFlags));
                    break;

                case ID_MARK_THREAD_READ:
                    rgCmds[ul].cmdf = QS_ENABLED(OEMSF_THREADING_ENABLED & dwStatusFlags);
                    break;

                case ID_NEXT_UNREAD_THREAD:
                    rgCmds[ul].cmdf = QS_ENABLED((OEMSF_THREADING_ENABLED & dwStatusFlags) && (OEMSF_CAN_NEXT & dwStatusFlags));
                    break;

                case ID_PREVIOUS:
                    rgCmds[ul].cmdf = QS_ENABLED(OEMSF_CAN_PREV & dwStatusFlags);
                    break;

                case ID_FORMAT_COLOR:
                case ID_FORMAT_COLOR1:
                case ID_FORMAT_COLOR2:
                case ID_FORMAT_COLOR3:
                case ID_FORMAT_COLOR4:
                case ID_FORMAT_COLOR5:
                case ID_FORMAT_COLOR6:
                case ID_FORMAT_COLOR7:
                case ID_FORMAT_COLOR8:
                case ID_FORMAT_COLOR9:
                case ID_FORMAT_COLOR10:
                case ID_FORMAT_COLOR11:
                case ID_FORMAT_COLOR12:
                case ID_FORMAT_COLOR13:
                case ID_FORMAT_COLOR14:
                case ID_FORMAT_COLOR15:
                case ID_FORMAT_COLOR16:
                case ID_BACK_COLOR_AUTO:
                case ID_FORMAT_COLORAUTO:
                case ID_POPUP_BACKGROUND:
                    rgCmds[ul].cmdf = QS_ENABLED(fHtmlSettingsOK);
                    break;

                case ID_FORMATTING_TOOLBAR:
                    rgCmds[ul].cmdf = QS_ENABLECHECK((m_fHtml && !m_fBodyContainsFrames), m_fFormatbarVisible);
                    break;

                case ID_SHOW_TOOLBAR:
                    rgCmds[ul].cmdf = QS_CHECKED(m_fToolbarVisible);
                    break;

                case ID_STATUS_BAR:
                    rgCmds[ul].cmdf = QS_CHECKED(m_fStatusbarVisible);
                    break;

                case ID_SEND_OBJECTS:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(fHtmlSettingsOK, m_fPackageImages);
                    break;

                case ID_RICH_TEXT:
                    rgCmds[ul].cmdf = QS_RADIOED(m_fHtml);
                    break;

                case ID_PLAIN_TEXT:
                    rgCmds[ul].cmdf = QS_RADIOED(!m_fHtml);
                    break;

                case ID_FLAG_MESSAGE:
                    rgCmds[ul].cmdf = QS_ENABLECHECK(OEMSF_CAN_MARK & dwStatusFlags, IsFlagged());
                    break;

                case ID_WATCH_THREAD:
                    rgCmds[ul].cmdf = QS_CHECKED(IsFlagged(ARF_WATCH));
                    break;

                case ID_IGNORE_THREAD:
                    rgCmds[ul].cmdf = QS_CHECKED(IsFlagged(ARF_IGNORE));
                    break;

                case ID_POPUP_NEW:
                case ID_NOTE_PROPERTIES:
                case ID_CLOSE:
                case ID_POPUP_FIND:
                case ID_POPUP_LANGUAGE_DEFERRED:
                case ID_POPUP_FONTS:
                case ID_ADDRESS_BOOK:
                case ID_POPUP_ADDRESS_BOOK:
                case ID_ADD_SENDER:
                case ID_ADD_ALL_TO:
                case ID_POPUP_TOOLBAR:
                case ID_CUSTOMIZE:

                // Help Menus
                case ID_HELP_CONTENTS:
                case ID_README:
                case ID_POPUP_MSWEB:
                case ID_MSWEB_FREE_STUFF:
                case ID_MSWEB_PRODUCT_NEWS:
                case ID_MSWEB_FAQ:
                case ID_MSWEB_SUPPORT:
                case ID_MSWEB_FEEDBACK:
                case ID_MSWEB_BEST:
                case ID_MSWEB_SEARCH:
                case ID_MSWEB_HOME:
                case ID_MSWEB_HOTMAIL:
                case ID_ABOUT:

                case ID_FIND_MESSAGE:
                case ID_FIND_PEOPLE:
                case ID_FIND_TEXT:
                case ID_SELECT_ALL:
                case ID_POPUP_LANGUAGE_MORE:
                case ID_SEND_NOW:
                case ID_SEND_LATER:
                case ID_SEND_MESSAGE:
                case ID_SEND_DEFAULT:
                    rgCmds[ul].cmdf = QS_ENABLED(TRUE);
                    break;

                case ID_REQUEST_READRCPT:
                    if (m_fMail)
                    {
                        rgCmds[ul].cmdf = QS_CHECKFORLATCH(!m_dwRequestMDNLocked, 
                                                         !!(dwStatusFlags & OEMSF_MDN_REQUEST));
                    }
                    else
                    {
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);
                    }
                    break;
                case ID_INCLUDE_LABEL:
                    if(m_pHdr->IsHeadSigned() == S_OK)
                        rgCmds[ul].cmdf = QS_CHECKED(m_fSecurityLabel);
                    else
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);

                    break;

                case ID_LABEL_SETTINGS:
                    if(m_pHdr->IsHeadSigned() == S_OK)
                        rgCmds[ul].cmdf = QS_ENABLED(m_fSecurityLabel);
                    else
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);

                    break;

                case ID_SEC_RECEIPT_REQUEST:
                    if(m_pHdr->IsHeadSigned() == S_OK)
                        rgCmds[ul].cmdf = QS_CHECKED(m_fSecReceiptRequest);
                    else
                        rgCmds[ul].cmdf = QS_ENABLED(FALSE);

                default:
                    if ((ID_LANG_FIRST <= cmdID) && (ID_LANG_LAST >= cmdID))
                    {
                        rgCmds[ul].cmdf = OLECMDF_SUPPORTED | SetMimeLanguageCheckMark(CustomGetCPFromCharset(m_hCharset, m_fReadNote), cmdID - ID_LANG_FIRST);
                    }

                    if (((ID_ADD_RECIPIENT_FIRST <= cmdID) && (ID_ADD_RECIPIENT_LAST >= cmdID)) ||
                        ((ID_APPLY_STATIONERY_0 <= cmdID) && (ID_APPLY_STATIONERY_NONE >= cmdID)))
                        rgCmds[ul].cmdf = QS_ENABLED(TRUE);
                    else if ((ID_SIGNATURE_FIRST <= cmdID) && (ID_SIGNATURE_LAST >= cmdID))
                        rgCmds[ul].cmdf = QS_ENABLED(!m_fBodyContainsFrames);
                    break;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// *************************
HRESULT CNote::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,  VARIANTARG *pvaOut)
{
    return E_NOTIMPL;
}

// *************************
HRESULT CNote::ClearDirtyFlag()
{
    m_pBodyObj2->HrSetDirtyFlag(FALSE);

    HeaderExecCommand(MSOEENVCMDID_DIRTY, MSOCMDEXECOPT_DODEFAULT, NULL);
    return S_OK;
}

// *************************
HRESULT CNote::IsDirty(void)
{
    OLECMD  rgCmd[] = {{MSOEENVCMDID_DIRTY, 0}};
    BOOL    fBodyDirty = FALSE;

    m_pBodyObj2->HrIsDirty(&fBodyDirty);
    if (fBodyDirty)
        return S_OK;

    if (m_pCmdTargetHdr)
        m_pCmdTargetHdr->QueryStatus(&CGID_Envelope, 1, rgCmd, NULL);

    return (0 != (rgCmd[0].cmdf&OLECMDF_ENABLED)) ? S_OK : S_FALSE;
}

// *************************
HRESULT CNote::Load(LPMIMEMESSAGE pMsg)
{
    HRESULT         hr;
    VARIANTARG      var;
    IPersistMime   *pPMHdr=0;
    BOOL fWarnUser = (OENA_WEBPAGE == m_dwNoteAction ) || 
                     (OENA_COMPOSE == m_dwNoteAction ) || 
                     (OENA_STATIONERY == m_dwNoteAction ) || 
                     (OENA_FORWARD == m_dwNoteAction);

    if (!m_pHdr)
        return E_FAIL;

    // OnDocumentReady will get call on the CheckForFramesets function.
    // Don't want that document ready to matter. Set this flag to true so
    // the doc ready doesn't do anything. Once the check is done, we will
    // set this flag to false again.
    m_fOnDocReadyHandled = TRUE;

    // If not a read note and contains frames, need to see what user wants to do 
    if (!m_fReadNote)
    {
        hr = HrCheckForFramesets(pMsg, fWarnUser);
        if (FAILED(hr))
            goto Exit;

        if (hr == S_READONLY)
            m_fBodyContainsFrames = TRUE;
    }

    ReplaceInterface(m_pMsg, pMsg);

    // The next OnDocumentReady should be run.
    m_fOnDocReadyHandled = FALSE;

    hr = m_pHdr->QueryInterface(IID_IPersistMime, (LPVOID*)&pPMHdr);
    if (FAILED(hr))
        return hr;

    hr = pPMHdr->Load(pMsg);
    if (FAILED(hr))
        goto Exit;

    m_pHdr->SetFlagState(IsFlagged(ARF_FLAGGED) ? MARK_MESSAGE_FLAGGED : MARK_MESSAGE_UNFLAGGED);

    if (IsFlagged(ARF_WATCH))
        m_pHdr->SetFlagState(MARK_MESSAGE_WATCH);
    else if (IsFlagged(ARF_IGNORE))
        m_pHdr->SetFlagState(MARK_MESSAGE_IGNORE);
    else
        m_pHdr->SetFlagState(MARK_MESSAGE_NORMALTHREAD);

    if (m_fCompleteMsg)
        hr = m_pPrstMime->Load(pMsg);

    CheckAndForceEncryption();

Exit:
    if (FAILED(hr))
        // ~~~ This should eventually be an html error message
        m_pBodyObj2->HrUnloadAll(idsErrHtmlBodyFailedToLoad, NULL);

    ReleaseObj(pPMHdr);
    return hr;
}


// *************************
void CNote::CheckAndForceEncryption()
{
    BOOL fCheck = FALSE;
    if(m_fSecurityLabel && m_pLabel)
    {
        DWORD dwFlags;
        if (SUCCEEDED(HrGetPolicyFlags(m_pLabel->pszObjIdSecurityPolicy, &dwFlags)))
        {   
            if(dwFlags & SMIME_POLICY_MODULE_FORCE_ENCRYPTION)
                fCheck = TRUE;
        }
    }
    m_pHdr->ForceEncryption(&fCheck, TRUE);
}

// *************************
HRESULT CNote::SetCharsetUnicodeIfNeeded(IMimeMessage *pMsg)
{
    HRESULT         hr = S_OK;
    VARIANTARG      va;
    PROPVARIANT     Variant;
    int             ret;
    HCHARSET        hCharSet;
    UINT            cpID = 0;

    // Call dialog only if sending a mime message
    // See raid 8436 or 79339 in the IE/OE 5 database. We can't send
    // unicode encoding unless we are a mime message.
    if (m_fHtml || m_rPlainOpt.fMime)
    {

        m_fPreventConflictDlg = FALSE;

        if (SUCCEEDED(GetCharset(&hCharSet)))
        {
            cpID = CustomGetCPFromCharset(hCharSet, FALSE);
        }
        else
        {
            pMsg->GetCharset(&hCharSet);
            cpID = CustomGetCPFromCharset(hCharSet, FALSE);
        }

        // Check to see if have chars that don't work in encoding
        va.vt = VT_UI4;
        va.ulVal = cpID;
        IF_FAILEXIT(hr = m_pCmdTargetBody->Exec(&CMDSETID_MimeEdit, MECMDID_CANENCODETEXT, 0, &va, NULL));

        if (MIME_S_CHARSET_CONFLICT == hr)
        {
            // Don't let header call conflict dialog again
            m_fPreventConflictDlg = TRUE;

            ret = IntlCharsetConflictDialogBox();
            if (idcSendAsUnicode == ret)
            {
                // User choose to send as Unicode (UTF8). set new charset and resnd
                hCharSet = GetMimeCharsetFromCodePage(CP_UTF8);
                ChangeCharset(hCharSet);
            }
            else if (IDOK != ret)
            {
                // return to edit mode and bail out
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }
        }
    }
    else
        // Since we are not mime, don't show dialog ever.
        m_fPreventConflictDlg = TRUE;

exit:
    return hr;
}

// *************************
HRESULT CNote::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    HRESULT         hr;
    IPersistMime*   pPersistMimeHdr=0;
    DWORD           dwHtmlFlags = PMS_TEXT;

    if(!m_pHdr)
        IF_FAILEXIT(hr = E_FAIL);

    IF_FAILEXIT(hr = SetCharsetUnicodeIfNeeded(pMsg));

    IF_FAILEXIT(hr = m_pHdr->QueryInterface(IID_IPersistMime, (LPVOID*)&pPersistMimeHdr));

    IF_FAILEXIT(hr = pPersistMimeHdr->Save(pMsg, TRUE));

    if (m_fHtml)
        dwHtmlFlags |= PMS_HTML;

    IF_FAILEXIT(hr = m_pPrstMime->Save(pMsg, dwHtmlFlags));

    UpdateMsgOptions(pMsg);

    // During a send, don't want to commit at this time. m_fCommitSave
    // is set to false during a send.
    if (m_fCommitSave)
    {
        hr = pMsg->Commit(0);
        // temporary hack for #27823
        if((hr == MIME_E_SECURITY_NOSIGNINGCERT) || 
           (hr == MIME_E_SECURITY_ENCRYPTNOSENDERCERT) ||
           (hr == MIME_E_SECURITY_CERTERROR) ||
           (hr == MIME_E_SECURITY_NOCERT) )  // too early for this error
            hr = S_OK;
    }

exit:
    ReleaseObj(pPersistMimeHdr);
    return hr;
}

// *************************
HRESULT CNote::InitNew(void)
{
    return E_NOTIMPL;
}

// *************************
HRESULT CNote::GetClassID(CLSID *pClsID)
{
    return NOERROR;
}

// *************************
HRESULT CNote::SignatureEnabled(BOOL fAuto)
{
    int     cSig;
    HRESULT hr;
    DWORD   dwSigFlag;
    
    if (m_fBodyContainsFrames || m_fReadNote || (OENA_WEBPAGE == m_dwNoteAction))
        return S_FALSE;
    if (FAILED(g_pSigMgr->GetSignatureCount(&cSig)) || (0 == cSig))
        return S_FALSE;

    if (!fAuto)     // for non-auto scenario's it's cool to insert a sig, as there is one.
        return S_OK;

    // From this point down, we are only talking about insertion upon creation

    if (OENCF_NOSIGNATURE & m_dwNoteCreateFlags)
        return S_FALSE;

    dwSigFlag = DwGetOption(OPT_SIGNATURE_FLAGS);

    // if its a sendnote: check autonew. for automatically appending the signature. We only append on a virgin sendnote or a stationery sendnote.
    // as if it's been saved to the store, the signature is already there.
    // if in a reply or forward, then check for auto-reply.
    switch (m_dwNoteAction)
    {
        // If it is a compose note, make sure it wasn't from the store or file system, that it doesn't have any
        // body parts, and that the sig flag is set
        case OENA_COMPOSE:
        {
            Assert(m_pMsgSite);
            if (m_pMsgSite)
                hr = (!m_fOriginallyWasRead && (S_FALSE == HrHasBodyParts(m_pMsg)) && (dwSigFlag & SIGFLAG_AUTONEW)) ? S_OK : S_FALSE;
            else
                hr = S_FALSE;
            break;
        }

        // For stationery, check sig flag
        case OENA_STATIONERY:
        {
            hr = (dwSigFlag & SIGFLAG_AUTONEW) ? S_OK : S_FALSE;
            break;
        }

        // Check sig flag
        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        case OENA_REPLYALL:
        case OENA_FORWARD:
        case OENA_FORWARDBYATTACH:
        {
            hr = (dwSigFlag & SIGFLAG_AUTOREPLY) ? S_OK : S_FALSE;
            break;
        }

        default:
            AssertSz(FALSE, "Bad note action type for signature");
            hr = S_FALSE;
    }

    return hr;
}

// *************************
HRESULT CNote::GetSignature(LPCSTR szSigID, LPDWORD pdwSigOptions, BSTR *pbstr)
{
    HRESULT hr;
    IImnAccount *pAcct = NULL;
    GETSIGINFO si;

    if (m_fBodyContainsFrames)
        return E_NOTIMPL;

    hr = m_pHdr->HrGetAccountInHeader(&pAcct);
    if (FAILED(hr))
        return hr;

    si.szSigID = szSigID;
    si.pAcct = pAcct;
    si.hwnd = m_hwnd;
    si.fHtmlOk = m_fHtml;
    si.fMail = m_fMail;
    si.uCodePage = GetACP();

    hr = HrGetMailNewsSignature(&si, pdwSigOptions, pbstr);
    ReleaseObj(pAcct);
    return hr;
}

// *************************
HRESULT CNote::GetMarkAsReadTime(LPDWORD pdwSecs)
{
    // Notes don't care about mark as read timers, only Views
    return E_NOTIMPL;
}

// *************************
HRESULT CNote::GetFlags(LPDWORD pdwFlags)
{
    DWORD dwMsgSiteFlags = 0;

    if (!pdwFlags)
        return E_INVALIDARG;

    *pdwFlags= BOPT_FROM_NOTE;   

    Assert(m_pMsgSite);
    if (m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwMsgSiteFlags);

    // if a readnote, we can auto-inline attachments
    if (m_fReadNote)
        *pdwFlags |= BOPT_AUTOINLINE;

    // set HTML flag
    if (m_fHtml)
        *pdwFlags |= BOPT_HTML;
    else
        *pdwFlags |= BOPT_NOFONTTAG;

    if (IsReplyNote())
    {
        // If block quote option is ON, and is HTML messages
        if (m_fHtml && DwGetOption(m_fMail?OPT_MAIL_MSG_HTML_INDENT_REPLY:OPT_NEWS_MSG_HTML_INDENT_REPLY))
            *pdwFlags |= BOPT_BLOCKQUOTE;

        // Set this in all cases except where we are a reply note and the INCLUDEMSG is not set
        if (DwGetOption(OPT_INCLUDEMSG))
            *pdwFlags |= BOPT_INCLUDEMSG;
    }
    else
        *pdwFlags |= BOPT_INCLUDEMSG;

    // If is reply or forward...
    if (IsReplyNote() || (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction) )
    {
        *pdwFlags |= BOPT_REPLYORFORWARD;
        // ... and spell ignore is set
        if(DwGetOption(OPT_SPELLIGNOREPROTECT))
            *pdwFlags |= BOPT_SPELLINGOREORIGINAL;
    }

    // If not a read note, or a compose note that started as a compose note (ie one that was previously saved)
    if (!m_fReadNote && !m_fOriginallyWasRead)
        *pdwFlags |= BOPT_AUTOTEXT;

    if (!m_fReadNote && m_fPackageImages)
        *pdwFlags |= BOPT_SENDIMAGES;

    // ugh. OK, this is big-time sleazy. We found a security hole in SP1. To
    // plug this we need to at reply and forward time
    // mark incoming images etc as NOSEND=1 links. We do this for all messages
    // EXCEPT stationery or webpages
    if ((OENA_STATIONERY == m_dwNoteAction) || (OENA_WEBPAGE == m_dwNoteAction))
        *pdwFlags |= BOPT_SENDEXTERNALS;

    if (m_fUseStationeryFonts)
        *pdwFlags |= BOPT_NOFONTTAG;

    if (m_fReadNote && (dwMsgSiteFlags & OEMSF_SEC_UI_ENABLED))
        *pdwFlags |= BOPT_SECURITYUIENABLED;

    if (dwMsgSiteFlags & OEMSF_FROM_STORE)
        *pdwFlags |= BOPT_FROMSTORE;

    if (dwMsgSiteFlags & OEMSF_UNREAD)
        *pdwFlags |= BOPT_UNREAD;

    if (!m_fBodyContainsFrames && m_fUseReplyHeaders)
        *pdwFlags |= BOPT_USEREPLYHEADER;

    if (m_fMail)
        *pdwFlags |= BOPT_MAIL;

    return S_OK;
}

// *************************
HRESULT CNote::GetInfo(BODYOPTINFO *pBOI)
{
    HRESULT hr = S_OK;

    if (m_fBodyContainsFrames)
        return E_NOTIMPL;

    if (pBOI->dwMask & BOPTF_QUOTECHAR)
    {
        pBOI->chQuote = NULL;

        // we allow quote char in plain-text mode only
        if (!m_fHtml && (IsReplyNote() || (OENA_FORWARD == m_dwNoteAction)))
            pBOI->chQuote =(CHAR)DwGetOption(m_fMail?OPT_MAILINDENT:OPT_NEWSINDENT);
    }

    if (pBOI->dwMask & BOPTF_REPLYTICKCOLOR)
        pBOI->dwReplyTickColor = DwGetOption(m_fMail?OPT_MAIL_FONTCOLOR:OPT_NEWS_FONTCOLOR);

    if (pBOI->dwMask & BOPTF_COMPOSEFONT)
        hr = HrGetComposeFontString(pBOI->rgchComposeFont, ARRAYSIZE(pBOI->rgchComposeFont), m_fMail);

    return hr;
}

HRESULT CNote::GetAccount(IImnAccount **ppAcct)
{
    HRESULT hr = S_OK;
#ifdef YST
    FOLDERINFO      fi;
    FOLDERID FolderID;
    hr = m_pMsgSite->GetFolderID(&FolderID);
    if (FOLDERID_INVALID != FolderID)
    {
        hr = g_pStore->GetFolderInfo(FolderID, &fi);
        if (SUCCEEDED(hr))
        {
            // Set account based upon the folder ID passed down
            if (FOLDER_LOCAL != fi.tyFolder)
            {
                char szAcctId[CCHMAX_ACCOUNT_NAME];

                hr = GetFolderAccountId(&fi, szAcctId, ARRAYSIZE(szAcctId)); 
                if (SUCCEEDED(hr))
                    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctId, ppAcct);
            }
            else
                hr = m_pMsgSite->GetCurrentAccount(ppAcct);
            g_pStore->FreeRecord(&fi);
        }
    }
    else
        hr = E_FAIL;
#endif // 0

    hr = m_pHdr->HrGetAccountInHeader(ppAcct);

    return(hr);
}

// *************************
void CNote::WMSize(int cxNote, int cyNote, BOOL fInternal)
{
    RECT        rc;
    int         cy = 0;

    // assume the header autosizes itself..., unless an internal size requires we recalc...
    if(fInternal)
    {
        // if the size is coming from the header... figure out the current size
        // of the note... as cxNote and cyNote are bogus at this point...
        GetClientRect(m_hwnd, &rc);
        cxNote = cxRect(rc);
        cyNote = cyRect(rc);
    }

    if (m_pToolbarObj)
    {
        //Ideally we should be calling ResizeBorderDW. But 
        HWND rebarHwnd = m_hwndRebar;

        m_pToolbarObj->ResizeBorderDW(&rc, (IUnknown*)(IDockingWindowSite*)this, 0);
        GetWindowRect(GetParent(rebarHwnd), &rc);
        cy += cyRect(rc);
    }

    
    ResizeChildren(cxNote, cyNote, cy, fInternal);
}

void CNote::ResizeChildren(int cxNote, int cyNote, int cy, BOOL fInternal)
{
    int     cyBottom;
    RECT    rc; 
    int     cyStatus = 0;
    static  int cxBorder = 0,
                cyBorder = 0;

    if(!cxBorder || !cyBorder)
    {
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        cxBorder = GetSystemMetrics(SM_CXBORDER);
    }

    // size the header
    GetClientRect(m_hwnd, &rc);

    // remember the actual bottom
    cyBottom = rc.bottom;
    cy += 4;

    InflateRect(&rc, -1, -1);
    rc.bottom = GetRequiredHdrHeight();
    rc.top = cy;
    rc.bottom += rc.top;
    if(!fInternal && m_pHdr)
        m_pHdr->SetRect(&rc);


    // WARNING: the header may resize itself during a size, due to an edit
    //          growing
    cy += GetRequiredHdrHeight()+2;

    cy += cyBorder; 

    if (m_pstatus)
    {
        m_pstatus->OnSize(cxNote, cyNote);
        m_pstatus->GetHeight(&cyStatus);
    }

    rc.top = cy;
    rc.bottom = cyBottom-cyBorder; // edit has a minimum size, clip if if gets too tight...

    rc.bottom -= cyStatus;

    if (m_pBodyObj2)
        m_pBodyObj2->HrSetSize(&rc);

}

// *************************
BOOL CNote::IsReplyNote()
{
    return ((OENA_REPLYTOAUTHOR == m_dwNoteAction) || (OENA_REPLYTONEWSGROUP == m_dwNoteAction) || (OENA_REPLYALL == m_dwNoteAction));
}

// *************************
HRESULT CNote::Resize(void)
{
    WMSize(0, 0, TRUE);
    return S_OK;
}

// *************************
HRESULT CNote::UpdateTitle()
{
    HRESULT     hr;
    WCHAR       wszTitle[cchHeaderMax+1];

    Assert(m_pHdr);

    *wszTitle = 0x0000;

    hr = m_pHdr->GetTitle(wszTitle, ARRAYSIZE(wszTitle));
    if(SUCCEEDED(hr))
        SetWindowTextWrapW(m_hwnd, wszTitle);

    return hr;
}

// *************************
HRESULT CNote::Update(void)
{
    m_pToolbarObj->Update();
    UpdateTitle();
    return S_OK;
}

// *************************
HRESULT CNote::OnSetFocus(HWND hwndFrom)
{
    HWND    hwndBody;

    // setfocus from a kid and not a body. make sure we
    // UIDeactivate the docobj
    SideAssert(m_pBodyObj2->HrGetWindow(&hwndBody)==NOERROR);
    if(hwndFrom != hwndBody)
        m_pBodyObj2->HrUIActivate(FALSE);

    // if focus goes to a kid, update the toolbar
    m_pToolbarObj->Update();

    // focus is going to a kid. Enable/Disable the formatbar
    m_pBodyObj2->HrUpdateFormatBar();

    return S_OK;
}

// *************************
HRESULT CNote::OnUIActivate()
{
    m_fHeaderUIActive = TRUE;
    return OnSetFocus(0);
}

// *************************
HRESULT CNote::OnKillFocus()
{
    m_pToolbarObj->Update();
    return S_OK;
}
// *************************
HRESULT CNote::OnUIDeactivate(BOOL)
{
    m_fHeaderUIActive = FALSE;
    return OnKillFocus();
}

// *************************
HRESULT CNote::IsHTML(void)
{
    return m_fHtml ? S_OK : S_FALSE;
}

HRESULT CNote::IsModal()
{
    return (m_dwNoteCreateFlags & OENCF_MODAL) ? S_OK : S_FALSE;
}

// *************************
HRESULT CNote::SetHTML(BOOL fHTML)
{
    m_fHtml = !!fHTML;
    return NOERROR;
}

#ifdef SMIME_V3
// return selected label in note
// S_OK user select label
// S_FALSE user uncheck using security labels
HRESULT CNote::GetLabelFromNote(PSMIME_SECURITY_LABEL *pplabel)
{
    if(m_fSecurityLabel && m_fMail)
    {
        *pplabel = m_pLabel;
        return S_OK;
    }
    else
    {
        *pplabel = NULL;
        return S_FALSE;
    }
}
HRESULT CNote::IsSecReceiptRequest(void)
{
    if(m_fSecReceiptRequest)
        return(S_OK);
    else
        return(S_FALSE);
}

HRESULT CNote::IsForceEncryption(void)
{
    return(m_pHdr->ForceEncryption(NULL, FALSE));
}
#endif // SMIME_V3

// *************************
HRESULT CNote::SaveAttachment(void)
{
    return m_pBodyObj2 ? m_pBodyObj2->HrSaveAttachment() : E_FAIL;
}

// *************************
HRESULT CNote::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectSave = *pdwEffect;;
    m_fBypassDropTests = FALSE;

    Assert(m_pDropTargetHdr && m_pTridentDropTarget);

    if (m_pHdr->HrIsDragSource() == S_OK)
    {
        m_fBypassDropTests = TRUE; // treated as drop to itself.
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_pDropTargetHdr->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
    if (*pdwEffect == DROPEFFECT_NONE)
    {
        if (!m_fHtml) // plain text mode. If there is no text, we should not take it.
        {
            IEnumFORMATETC* pEnum = NULL;
            FORMATETC       fetc = {0};
            ULONG           celtFetched = 0;
            BOOL            fCFTEXTFound = FALSE;

            // see if there is CF_TEXT format
            if (SUCCEEDED(pDataObj->EnumFormatEtc(DATADIR_GET, &pEnum)))
            {
                pEnum->Reset();

                while (S_OK == pEnum->Next(1, &fetc, &celtFetched))
                {
                    Assert(celtFetched == 1);
                    if (fetc.cfFormat == CF_TEXT)
                    {
                        fCFTEXTFound = TRUE;
                        break;
                    }
                }

                pEnum->Release();
            }

            if (!fCFTEXTFound) // no CF_TEXT, cannot drop in plain text mode.
            {
                *pdwEffect = DROPEFFECT_NONE;
                m_fBypassDropTests = TRUE; // treated as drop to itself.
                return S_OK;
            }
        }

        *pdwEffect = dwEffectSave;
        m_pTridentDropTarget->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
    }

    return S_OK;
}

// *************************
HRESULT CNote::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectSave = *pdwEffect;

    if (m_fBypassDropTests)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    m_pDropTargetHdr->DragOver(grfKeyState, pt, pdwEffect);
    if (*pdwEffect == DROPEFFECT_NONE)
    {
        *pdwEffect = dwEffectSave;
        m_pTridentDropTarget->DragOver(grfKeyState, pt, pdwEffect);
    }

    return S_OK;

}

// *************************
HRESULT CNote::DragLeave(void)
{
    if (m_fBypassDropTests)
        return S_OK;

    m_pDropTargetHdr->DragLeave();
    m_pTridentDropTarget->DragLeave();

    return NOERROR;
}

// *************************
HRESULT CNote::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    IDataObject    *pDataObjNew = NULL;
    HRESULT         hr = S_OK;
    STGMEDIUM       stgmed;
    DWORD           dwEffectSave = *pdwEffect;

    ZeroMemory(&stgmed, sizeof(stgmed));

    if (m_fBypassDropTests)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }

    m_pDropTargetHdr->Drop(pDataObj, grfKeyState, pt, pdwEffect);
    if (*pdwEffect == DROPEFFECT_NONE) // it is Trident's drag&drop
    {
        if(!m_fHtml)
        {
            hr = m_pBodyObj2->PublicFilterDataObject(pDataObj, &pDataObjNew);
            if(FAILED(hr))
                return E_UNEXPECTED;
        }
        else
        {
            pDataObjNew = pDataObj;
            pDataObj->AddRef();
        }

        *pdwEffect = dwEffectSave;
        m_pTridentDropTarget->Drop(pDataObjNew, grfKeyState, pt, pdwEffect);
    }

    ReleaseObj(pDataObjNew);
    return hr;
}

// *************************
HRESULT CNote::InitWindows(RECT *prc, HWND hwndOwner)
{
    HWND        hwnd;
    HMENU       hMenu;
    RECT        rcCreate,
                rc;
    HCURSOR     hcur;
    HWND        hwndCapture;
    DWORD       dwStyle = WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN;
    HRESULT     hr = S_OK;
    DWORD       dwExStyle = WS_EX_WINDOWEDGE | WS_EX_CONTROLPARENT | (IS_BIDI_LOCALIZED_SYSTEM() ? RTL_MIRRORED_WINDOW : 0L);
    WINDOWPLACEMENT wp = {0};

    Assert(hwndOwner == NULL || IsWindow(hwndOwner));
    m_hwndOwner = hwndOwner;
    hcur=SetCursor(LoadCursor(NULL, IDC_WAIT));

    if(!Note_Init(TRUE))
        IF_FAILEXIT(hr = E_FAIL);

    if(prc)
        CopyRect(&rcCreate, prc);
    else
        CopyRect(&rcCreate, &g_rcLastResize);

    m_hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(m_fReadNote?IDR_READ_NOTE_MENU:IDR_SEND_NOTE_MENU));
    MenuUtil_ReplaceHelpMenu(m_hMenu);
    MenuUtil_ReplaceNewMsgMenus(m_hMenu);

    if (m_dwNoteCreateFlags & OENCF_MODAL)
    {
        // Check to make sure nobody has captured the mouse from us
        hwndCapture = GetCapture();
        if (hwndCapture)
            SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);

        // Let's make sure we have a real topmost owner
        if (m_hwndOwner)
        {
            HWND hwndParent = GetParent(m_hwndOwner);

            // IsChild checks the WM_CHILD bit in the window. This will only be
            // set with controls or subs of a window. So, a dialog's parent might be
            // a note, but that dialog will not be a child of the parent.
            // RAID 37188
            while(IsChild(hwndParent, m_hwndOwner))
            {
                m_hwndOwner = hwndParent;
                hwndParent = GetParent(m_hwndOwner);
            }

            // Lose the minimize box for modal notes if there is a parent
            dwStyle &= ~WS_MINIMIZEBOX;
        
        }
    }
    
    hwnd = CreateWindowExWrapW( dwExStyle,
                                c_wszNoteWndClass,
                                NULL, //caption set by en_change of subject
                                dwStyle,
                                prc?rcCreate.left:CW_USEDEFAULT,  // use windows default for x and y.
                                prc?rcCreate.top:CW_USEDEFAULT,
                                cxRect(rcCreate), cyRect(rcCreate), m_hwndOwner, NULL, g_hInst, (LPVOID)this);

    IF_NULLEXIT(hwnd);

    if ((m_dwNoteCreateFlags & OENCF_MODAL) && (NULL != m_hwndOwner))
        EnableWindow(m_hwndOwner, FALSE);

    if ( GetOption(OPT_MAILNOTEPOSEX, (LPVOID)&wp, sizeof(wp)) )
    {
        wp.length = sizeof(wp);
        wp.showCmd = SW_HIDE;
        SetWindowPlacement(hwnd, &wp);   
    }
    else
    {
        CenterDialog(hwnd);
    }

exit:
    SetCursor(hcur);

    return hr;
}

// *************************
HRESULT CNote::Init(DWORD dwAction, DWORD dwCreateFlags, RECT *prc, HWND hwnd, INIT_MSGSITE_STRUCT *pInitStruct, IOEMsgSite *pMsgSite, IUnknown *punkPump)
{
    HRESULT         hr,
                    tempHr = S_OK;
    IMimeMessage   *pMsg = NULL;
    DWORD           dwFormatFlags,
                    dwStatusFlags = 0,
                    dwMsgFlags = (OENA_FORWARDBYATTACH == dwAction) ? (OEGM_ORIGINAL|OEGM_AS_ATTACH) : NOFLAGS;
    LPSTR           pszUnsent = NULL;
    BOOL            fBool = FALSE,
                    fOffline=FALSE;
    
    Assert((pInitStruct && !pMsgSite)|| (!pInitStruct && pMsgSite));

    ReplaceInterface(m_punkPump, punkPump);

    // If passed in an INIT_MSGSITE_STRUCT, must convert it to a pMsgSite
    if (pInitStruct)
    {
        m_pMsgSite = new COEMsgSite();
        if (!m_pMsgSite)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        Assert(pInitStruct);
        hr = m_pMsgSite->Init(pInitStruct);
        if (FAILED(hr))
            goto exit;    
    }
    else
        ReplaceInterface(m_pMsgSite, pMsgSite);

    if(m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwStatusFlags);

    AssertSz(m_pMsgSite, "Why don't we have a msgSite???");

    m_dwNoteAction = dwAction;
    m_fReadNote = !!(OENA_READ == m_dwNoteAction);
    m_fOriginallyWasRead = m_fReadNote;
    m_dwNoteCreateFlags = dwCreateFlags;

    // The storeCallback needs to be set. m_hwnd will be reset once we have a valid handle
    m_hwnd = hwnd;
    m_pMsgSite->SetStoreCallback(this);

    hr = m_pMsgSite->GetMessage(&pMsg, &fBool, dwMsgFlags, &tempHr);
    if (FAILED(hr))
        goto exit;

    // Raid 80277; Set default charset
    if(OENA_FORWARDBYATTACH == dwAction)
    {
        if (NULL == g_hDefaultCharsetForMail) 
            ReadSendMailDefaultCharset();

        pMsg->SetCharset(g_hDefaultCharsetForMail, CSET_APPLY_ALL);
    }

    m_fCompleteMsg = !!fBool;   // m_f* is a bitfield
    fOffline = (hr == HR_S_OFFLINE);

    switch (m_dwNoteAction)
    {
        case OENA_REPLYTOAUTHOR:
        case OENA_FORWARDBYATTACH:
        case OENA_FORWARD:
            m_fMail = TRUE;
            break;

        case OENA_REPLYTONEWSGROUP:
            m_fMail = FALSE;

        case OENA_STATIONERY:
        case OENA_WEBPAGE:
        case OENA_COMPOSE:
            m_fMail = (0 == (m_dwNoteCreateFlags & OENCF_NEWSFIRST));
            break;

        case OENA_REPLYALL:
        case OENA_READ:
        {
            DWORD dwStatusFlags = 0;
            hr = m_pMsgSite->GetStatusFlags(&dwStatusFlags);
            if (FAILED(hr))
                goto exit;

            m_fMail = (0 == (OEMSF_BASEISNEWS & dwStatusFlags));
            break;
        }
    }

    ProcessIncompleteAccts(hwnd);

    hr = ProcessICW(hwnd, m_fMail ? FOLDER_LOCAL : FOLDER_NEWS);
    if (FAILED(hr))
        goto exit;

    // If this is an unsent message and is a read note, then change the type to compose. This needs
    // to happen after setting the m_fMail flag since we mangle the noteAction.
    ChangeReadToComposeIfUnsent(pMsg);

    if (m_fMail)
    {
        m_fPackageImages = !!DwGetOption(OPT_MAIL_SENDINLINEIMAGES);
        dwFormatFlags = FMT_MAIL;
    }
    else
    {
        PROPVARIANT     var;
        IImnAccount    *pAcct = NULL;
        TCHAR           szAcctID[CCHMAX_ACCOUNT_NAME];
        DWORD           dw;

        m_fPackageImages = !!DwGetOption(OPT_NEWS_SENDINLINEIMAGES);

        *szAcctID = 0;

        dwFormatFlags = FMT_NEWS;
        // Bug #24267 - Check the message object for a server name before defaulting
        //              to the default server.
        var.vt = VT_LPSTR;
        if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var)))
        {
            StrCpyN(szAcctID, var.pszVal, ARRAYSIZE(szAcctID));
            SafeMemFree(var.pszVal);
        }

        if (*szAcctID)
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, szAcctID, &pAcct);

        // No account present, or the listed one no longer exists try to get the default
        if (!*szAcctID || (*szAcctID && FAILED(hr)))
            hr = m_pMsgSite->GetDefaultAccount(ACCT_NEWS, &pAcct);

        if ((OENA_WEBPAGE == dwAction) || (OENA_STATIONERY == dwAction))
            dwFormatFlags |= FMT_FORCE_HTML;
        else if (SUCCEEDED(hr) && pAcct && SUCCEEDED(pAcct->GetPropDw(AP_NNTP_POST_FORMAT, &dw)))
        {
            if (dw == POST_USE_HTML)
                dwFormatFlags |= FMT_FORCE_HTML;
            else if (dw == POST_USE_PLAIN_TEXT)
                dwFormatFlags |= FMT_FORCE_PLAIN;
            else
                Assert(dw == POST_USE_DEFAULT);
        }
        ReleaseObj(pAcct);
    }

    GetDefaultOptInfo(&m_rHtmlOpt, &m_rPlainOpt, &fBool, dwFormatFlags);

    switch (m_dwNoteAction)
    {
        case OENA_FORWARDBYATTACH:
            m_fHtml = !!fBool;
            break;

        case OENA_COMPOSE:
            if (m_fOriginallyWasRead)
            {
                DWORD dwFlags = 0;
                pMsg->GetFlags(&dwFlags);
                m_fHtml = !!(dwFlags & IMF_HTML);
            }
            else
                m_fHtml = !!fBool;
            break;

        case OENA_STATIONERY:
        case OENA_WEBPAGE:
        case OENA_READ:
            m_fHtml = TRUE;       // HTML is always cool in a readnote
            break;

        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        case OENA_REPLYALL:
        case OENA_FORWARD:
            // when replying, if option to repect sender format is on, do so
            if (DwGetOption(OPT_REPLYINORIGFMT))
            {
                DWORD dwFlags = 0;
                pMsg->GetFlags(&dwFlags);
                m_fHtml = !!(dwFlags & IMF_HTML);
            }
            else
                m_fHtml = !!fBool;

            // Bug 76570, 76575
            // Set security label
            if(pMsg)
            {
                SECSTATE        SecState;
                HrGetSecurityState(pMsg, &SecState, NULL);
                // only in case of signing message check label
                if(IsSigned(SecState.type))
                {
                    PCRYPT_ATTRIBUTE    pattrLabel;
                    LPBYTE              pbLabel = NULL;
                    DWORD               cbLabel;
                    PSMIME_SECURITY_LABEL plabel = NULL;
        
                    IMimeSecurity2 * pSMIME3 = NULL;
                    IMimeBody      *pBody = NULL;

                    if(pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody) == S_OK)
                    {
                        if(pBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pSMIME3) == S_OK)
                        {
            
                            // Get label attribute
                            if(pSMIME3->GetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED,
                                        0, szOID_SMIME_Security_Label,
                                        &pattrLabel) == S_OK)
                            {
                                // decode label
                                if(CryptDecodeObjectEx(X509_ASN_ENCODING,
                                            szOID_SMIME_Security_Label,
                                            pattrLabel->rgValue[0].pbData,
                                            pattrLabel->rgValue[0].cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            &CryptDecodeAlloc, &plabel, &cbLabel))
                                {
                                    if(plabel)
                                    {
                                        m_fSecurityLabel = TRUE;
                                        SafeMemFree(m_pLabel);
                                        m_pLabel = plabel;
                                    }
                                }
                            }
                            else 
                            {   // Secure receipt is binary message and pMsg->GetFlags always will retutn non-HTML, but we 
                                // forward (or Replay) with our HTML screen and need to set this to HTML.
                                if(CheckSecReceipt(pMsg) == S_OK)
                                    m_fHtml = TRUE;
                            }

                            SafeRelease(pSMIME3);
                        }   
                        ReleaseObj(pBody);
                    }

                }
                CleanupSECSTATE(&SecState);
            }
            break;
    }

    hr = InitWindows(prc, (dwCreateFlags & OENCF_MODAL) ? hwnd : 0);
    if (FAILED(hr))
        goto exit;

    hr = Load(pMsg);
    if (FAILED(hr))
        goto exit;

    if (FAILED(tempHr))
        ShowErrorScreen(tempHr);

    m_fFullHeaders = (S_OK == m_pHdr->FullHeadersShowing());

    if (fOffline)
        ShowErrorScreen(HR_E_OFFLINE);

    hr = InitMenusAndToolbars();        

    // Register with identity manager
    SideAssert(SUCCEEDED(hr = MU_RegisterIdentityNotifier((IUnknown *)(IOENote *)this, &m_dwIdentCookie)));

exit:
    ReleaseObj(pMsg);
    if (FAILED(hr) && m_pMsgSite && !pMsgSite)
        m_pMsgSite->Close();    
    
    return hr;
}

// Will return after close if is modal, otherwise returns immediately
HRESULT CNote::Show(void)
{    
    ShowWindow(m_hwnd, SW_SHOW);
    SetForegroundWindow(m_hwnd);

    if (m_dwNoteCreateFlags & OENCF_MODAL)
    {
        MSG         msg;
        HWNDLIST    hwndList;

        EnableThreadWindows(&hwndList, FALSE, 0, m_hwnd);

        while (GetMessageWrapW(&msg, NULL, 0, 0))
        {
            // This is a member function, so don't need to wrap
            if (TranslateAccelerator(&msg) == S_OK)
                continue;


            ::TranslateMessage(&msg);
            ::DispatchMessageWrapW(&msg);
        }

        EnableThreadWindows(&hwndList, TRUE, 0, m_hwnd);
    }
    return S_OK;
}

// *************************
BOOL CNote::WMCreate(HWND hwnd)
{
    LPTBBUTTON          lpButtons;
    ULONG               cBtns;
    HWND                hwndRebar;
    CMimeEditDocHost   *pNoteBody;
    DWORD               dwStyle;
    RECT                rc;
    VARIANTARG          var;
    IUnknown           *pUnk = NULL;
    REBARBANDINFO       rbbi;

    m_hwnd = hwnd;
    SetWndThisPtr(hwnd, this);
    AddRef();

    Assert(IsWindow(m_hwnd));

    SetProp(hwnd, c_szOETopLevel, (HANDLE)TRUE);

    //Create a new bandsclass and intialize it
    m_pToolbarObj = new CBands();
    if (!m_pToolbarObj)
        return FALSE;

    m_pToolbarObj->HrInit(0, m_hMenu, PARENT_TYPE_NOTE);
    m_pToolbarObj->SetSite((IOENote*)this);
    m_pToolbarObj->ShowDW(TRUE);
    m_pToolbarObj->SetFolderType(GetNoteType());
    m_fToolbarVisible = m_pToolbarObj->IsToolbarVisible();

    m_hwndToolbar = m_pToolbarObj->GetToolbarWnd();
    m_hwndRebar = m_pToolbarObj->GetRebarWnd();

    pNoteBody = new CMimeEditDocHost(MEBF_INNERCLIENTEDGE);
    if (!pNoteBody)
        return FALSE;

    pNoteBody->QueryInterface(IID_IBodyObj2, (LPVOID *)&m_pBodyObj2);
    pNoteBody->Release();
    if (!m_pBodyObj2)
        return FALSE;

    m_pBodyObj2->QueryInterface(IID_IPersistMime, (LPVOID*)&m_pPrstMime);
    if (!m_pPrstMime)
        return FALSE;

    m_pstatus = new CStatusBar();
    if (NULL == m_pstatus)
        return FALSE;

    m_pstatus->Initialize(m_hwnd, SBI_HIDE_SPOOLER | SBI_HIDE_CONNECTED | SBI_HIDE_FILTERED);
    m_pstatus->ShowStatus(m_fStatusbarVisible);

    m_pBodyObj2->HrSetStatusBar(m_pstatus);

    CreateInstance_Envelope(NULL, (IUnknown**)&pUnk);
    if (!pUnk)
        return FALSE;

    pUnk->QueryInterface(IID_IHeader, (LPVOID*)&m_pHdr);
    pUnk->Release();
    if (!m_pHdr)
        return FALSE;

    m_pHdr->QueryInterface(IID_IDropTarget, (LPVOID*)&m_pDropTargetHdr);
    if (!m_pDropTargetHdr)
        return FALSE;

    m_pHdr->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_pCmdTargetHdr);
    if (!m_pCmdTargetHdr)
        return FALSE;

    if (!m_fMail)
        HeaderExecCommand(MSOEENVCMDID_NEWS, MSOCMDEXECOPT_DODEFAULT, NULL);

    var.vt = VT_I4;
    var.lVal = m_dwNoteAction;

    HeaderExecCommand(MSOEENVCMDID_SETACTION, MSOCMDEXECOPT_DODEFAULT, &var);
    if (FAILED(m_pHdr->Init((IHeaderSite*)this, hwnd)))
        return FALSE;

    if (FAILED(InitBodyObj()))
        return FALSE;

    // Set focus in the To: line
    switch (m_dwNoteAction)
    {
        case OENA_COMPOSE:
        case OENA_FORWARD:
        case OENA_FORWARDBYATTACH:
        case OENA_WEBPAGE:
        case OENA_STATIONERY:
            m_pHdr->SetInitFocus(FALSE);
            break;
    }

    m_pBodyObj2->SetEventSink((IMimeEditEventSink *) this);

    SetForegroundWindow(m_hwnd);
    return TRUE;
}

// *************************
void CNote::InitSendAndBccBtns()
{
    DWORD idiIcon;
    HICON hIconTemp = 0;

    Assert(m_hwnd);
    if (m_fMail)
        idiIcon = m_fReadNote?idiMsgPropSent:idiMsgPropUnSent;
    else
        idiIcon = m_fReadNote?idiArtPropPost:idiArtPropUnpost;

    // don't have to free HICON loaded from LoadIcon
    SendMessage(m_hwnd, WM_SETICON, ICON_BIG, (LPARAM)LoadIcon(g_hLocRes, MAKEINTRESOURCE(idiIcon)));

    if (m_fMail)
        idiIcon = m_fReadNote?idiSmallMsgPropSent:idiSmallMsgPropUnSent;
    else
        idiIcon = m_fReadNote?idiSmallArtPropPost:idiSmallArtPropUnpost;

    if(m_hIcon)
    {
        hIconTemp = m_hIcon;
    }
    m_hIcon = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiIcon), IMAGE_ICON, 
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);

    // don't have to free HICON loaded from LoadIcon
    SendMessage(m_hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIcon);

    if(hIconTemp)
    {
        //Bug #101345 - (erici) ICON leaked when 'Previous' or 'Next' button clicked
        DestroyIcon(hIconTemp);
    }

    // If this is a news send note, then we spruce up the send button on the toolbar
    if ((FALSE == m_fReadNote) && (FALSE == m_fMail))
    {
        TBBUTTONINFO tbi;

        ZeroMemory(&tbi, sizeof(TBBUTTONINFO));
        tbi.cbSize = sizeof(TBBUTTONINFO);
        tbi.dwMask = TBIF_IMAGE;
        tbi.iImage = TBIMAGE_SEND_NEWS;
        SendMessage(m_hwndToolbar, TB_SETBUTTONINFO, ID_SEND_DEFAULT, (LPARAM) &tbi);
    }
}

// *************************
HRESULT CNote::HeaderExecCommand(UINT uCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn)
{
    HRESULT hr = S_FALSE;

    if (uCmdID && m_pCmdTargetHdr)
        hr = m_pCmdTargetHdr->Exec(&CGID_Envelope, uCmdID, nCmdExecOpt, pvaIn, NULL);

    return hr;
}

// *************************
HRESULT CNote::InitBodyObj()
{
    DWORD       dwBodyStyle = MESTYLE_NOHEADER;
    HRESULT     hr;
    int         idsErr=0;

    hr = m_pBodyObj2->HrInit(m_hwnd, IBOF_TABLINKS, (IBodyOptions *)this);
    if (FAILED(hr))
        goto fail;

    hr = m_pBodyObj2->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_pCmdTargetBody);
    if (FAILED(hr))
        goto fail;

    hr = m_pBodyObj2->HrShow(TRUE);
    if (FAILED(hr))
        goto fail;

    // if not in html mode, don't show format bar...
    // we do this test here, as HrLoad could determine that a previously saved message
    // is indeed in html, which overrides the default setting
    if(!m_fHtml)
        m_fFormatbarVisible = FALSE;

    if (!m_fReadNote && !m_fBodyContainsFrames && m_fFormatbarVisible)
        dwBodyStyle = MESTYLE_FORMATBAR;

    m_pBodyObj2->HrEnableHTMLMode(m_fHtml);
    m_pBodyObj2->HrSetStyle(dwBodyStyle);

    // all is groovey
    return hr;

fail:
    switch (hr)
    {
        case INET_E_UNKNOWN_PROTOCOL:
            idsErr = idsErrLoadProtocolBad;
            break;

        default:
            idsErr = idsErrNoteDeferedInit;
            break;
    }

    AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErr), NULL, MB_OK);
    return hr;
}

// *************************
HRESULT CNote::InitMenusAndToolbars()
{
    DWORD       dwStatusFlags;
    HRESULT     hr;
    BOOL        fComposeNote,
                fCompleteMsg = !!m_fCompleteMsg, // m_fCompleteMsg is a bit field.
                fNextPrevious;
    HMENU       hMenu = m_hMenu;

    m_fUseReplyHeaders = FALSE;

    Assert(m_pMsgSite);
    if (m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwStatusFlags);

    switch (m_dwNoteAction)
    {
        case OENA_FORWARDBYATTACH:
        case OENA_COMPOSE:
            // if it's a virgin compose-note, we check the regsettings to see if they want to compose
            // from a stationery file. If so, we set the html stream to that file.
            if (m_fHtml && !(m_dwNoteCreateFlags & OENCF_NOSTATIONERY) && (OEMSF_VIRGIN & dwStatusFlags))
                SetComposeStationery();
            break;

        case OENA_STATIONERY:
            if (m_dwNoteCreateFlags & OENCF_USESTATIONERYFONT)
                m_fUseStationeryFonts = TRUE;
            break;

        case OENA_REPLYTOAUTHOR:
        case OENA_REPLYTONEWSGROUP:
        case OENA_REPLYALL:
        case OENA_FORWARD:
            m_fUseReplyHeaders = TRUE;
            break;
    }

    InitSendAndBccBtns();
    
    if (m_fMail)
    {
        if (m_fReadNote || IsReplyNote())
            m_pBodyObj2->HrUIActivate(TRUE);
    }
    else
    {
        if ((OENA_COMPOSE == m_dwNoteAction) && (OEMSF_VIRGIN & dwStatusFlags))
            // for a sendnote in news, put focus in the subject as the to: line is filled in. bug #24720
            m_pHdr->SetInitFocus(TRUE);
        else
            // else , always put focus in the BODY
            m_pBodyObj2->HrUIActivate(TRUE);
    }

    RECT rc;
    GetClientRect(m_hwnd, &rc);
    SendMessage(m_hwnd, WM_SIZE, SIZE_RESTORED, MAKELPARAM(rc.right, rc.bottom));        

    // put us into edit mode if not a readnote...
    hr=m_pBodyObj2->HrSetEditMode(!m_fReadNote && !m_fBodyContainsFrames);
    if (FAILED(hr))
        goto error;

    if (m_fBodyContainsFrames)
        DisableSendNoteOnlyMenus();

    // get the character set of the message being loaded
    if (m_pMsg)
        m_pMsg->GetCharset(&m_hCharset);

error:
    return hr;
}

// *************************
void CNote::DisableSendNoteOnlyMenus()
{
}

// *************************
HACCEL CNote::GetAcceleratorTable()
{
    return (m_fReadNote ? g_hAccelRead : g_hAccelSend);
}

// *************************
HRESULT CNote::TranslateAccelerator(LPMSG lpmsg)
{
    HWND        hwndT,
                hwndFocus;

    if (IsMenuMessage(lpmsg) == S_OK)
       return S_OK;

    // handle the mousewheel messages for this note
    if ((g_msgMSWheel && (lpmsg->message == g_msgMSWheel)) || (lpmsg->message == WM_MOUSEWHEEL))
    {
        POINT pt;
        HWND  hwndT;

        pt.x = GET_X_LPARAM(lpmsg->lParam);
        pt.y = GET_Y_LPARAM(lpmsg->lParam);

        hwndT = WindowFromPoint(pt);
        hwndFocus = GetFocus();

        if (hwndT != m_hwnd && IsChild(m_hwnd, hwndT))
            SendMessage(hwndT, lpmsg->message, lpmsg->wParam, lpmsg->lParam);
        else if (hwndFocus != m_hwnd && IsChild(m_hwnd, hwndFocus))
            SendMessage(hwndFocus, lpmsg->message, lpmsg->wParam, lpmsg->wParam);
        else
            return S_FALSE;
        return S_OK;
    }

    // our accelerators have higher priority.
    if(::TranslateAcceleratorWrapW(m_hwnd, GetAcceleratorTable(), lpmsg))
        return S_OK;

    // see if the body want it for the docobject...
    if(m_pBodyObj2 &&
        m_pBodyObj2->HrTranslateAccelerator(lpmsg)==S_OK)
        return S_OK;

    if (lpmsg->message == WM_KEYDOWN &&
        lpmsg->wParam == VK_TAB && 
        !(GetKeyState(VK_CONTROL) & 0x8000 ))
    {
        BOOL  fGoForward = ( GetKeyState( VK_SHIFT ) & 0x8000 ) == 0;
        CycleThroughControls(fGoForward);

        return S_OK;
    }

    return S_FALSE;
}

// *************************
LRESULT CNote::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT         lResult;
    LRESULT         lres;
    MSG             Menumsg;
    HWND            hwndActive;
    WINDOWPLACEMENT wp;

    Menumsg.hwnd    = hwnd;
    Menumsg.message = msg;
    Menumsg.wParam  = wParam;
    Menumsg.lParam  = lParam;

    if (m_pToolbarObj && (m_pToolbarObj->TranslateMenuMessage(&Menumsg, &lres) == S_OK))
        return lres;

    wParam = Menumsg.wParam;
    lParam = Menumsg.lParam;


    switch(msg)
    {
        case WM_ENABLE:
            if (!m_fInternal)
            {
                Assert (wParam || (m_hlDisabled.cHwnd == NULL && m_hlDisabled.rgHwnd == NULL));
                EnableThreadWindows(&m_hlDisabled, !!wParam, ETW_OE_WINDOWS_ONLY, hwnd);
                g_hwndActiveModal = wParam ? NULL : hwnd;
            }
            break;

        case WM_OE_DESTROYNOTE:
            m_fForceClose = 1;
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_OENOTE_ON_COMPLETE:
            _OnComplete((STOREOPERATIONTYPE)lParam, (HRESULT) wParam);
            break;
            
        case WM_OE_ENABLETHREADWINDOW:
            m_fInternal = 1;
            EnableWindow(hwnd, (BOOL)wParam);
            m_fInternal = 0;
            break;

        case WM_OE_ACTIVATETHREADWINDOW:
            hwndActive = GetLastActivePopup(hwnd);
            if (hwndActive && IsWindowEnabled(hwndActive) && IsWindowVisible(hwndActive))
                ActivatePopupWindow(hwndActive);
            break;

        case NWM_GETDROPTARGET:
            SafeRelease(m_pTridentDropTarget);
            m_pTridentDropTarget = (IDropTarget*) wParam;
            if (m_pTridentDropTarget)
                m_pTridentDropTarget->AddRef();

            AddRef();
            return (LRESULT)(IDropTarget *) this;

        case WM_DESTROY:
            // Unregister with Identity manager
            if (m_dwIdentCookie != 0)
            {
                MU_UnregisterIdentityNotifier(m_dwIdentCookie);
                m_dwIdentCookie = 0;
            }

            wp.length = sizeof(wp);
            GetWindowPlacement(hwnd, &wp);
            SetOption(OPT_MAILNOTEPOSEX, (LPVOID)&wp, sizeof(wp), NULL, 0);

            RemoveProp(hwnd, c_szOETopLevel);

            DeinitSigPopupMenu(hwnd);

            if(m_pBodyObj2)
            {
                m_pBodyObj2->HrSetStatusBar(NULL);
                m_pBodyObj2->HrClose();
            }

            SafeRelease(m_pTridentDropTarget);

            if (m_pToolbarObj)
            {
                DWORD   dwReserved = 0;

                m_pToolbarObj->SetSite(NULL);
                m_pToolbarObj->CloseDW(dwReserved);
            }

            if (m_pCancel)
                m_pCancel->Cancel(CT_ABORT);

            if (m_pMsgSite)
                m_pMsgSite->Close();

            break;

        case WM_NCDESTROY:
            DOUTL(8, "CNote::WMNCDESTROY");
            WMNCDestroy();
            return 0;

        case WM_ACTIVATEAPP:
            if (wParam && g_hwndActiveModal && g_hwndActiveModal != hwnd && 
                !IsWindowEnabled(hwnd))
            {
                // $MODAL
                // if we are getting activated, and are disabled then
                // bring our 'active' window to the top
                Assert (IsWindow(g_hwndActiveModal));
                PostMessage(g_hwndActiveModal, WM_OE_ACTIVATETHREADWINDOW, 0, 0);
            }
            break;
        
        case WM_SYSCOMMAND:
            // if we're minimizing, get the control with focus, as when we get the 
            // next WM_ACTIVATE we will already be minimized
            if (wParam == SC_MINIMIZE)
                m_hwndFocus = GetFocus();
            break;

        case WM_ACTIVATE:
            if (m_pBodyObj2)
                m_pBodyObj2->HrFrameActivate(LOWORD(wParam) != WA_INACTIVE);
            break;

        case WM_ENDSESSION:
            DOUTL(2, "CNote::WM_ENDSESSION");
            if (wParam)
                DestroyWindow(hwnd);
            return 0;

        case WM_QUERYENDSESSION:
            DOUTL(2, "CNote::WM_QUERYENDSESSION");
            // fall thro'

        case WM_CLOSE:
            if (!m_fForceClose && !FCanClose())
                return 0;

            // listen-up:
            // we have to do this EnableWindowof the modal owner in the WM_CLOSE
            // handler, as WM_DESTROY is too late - USER may have SetFocus to the next
            // active toplevel z-order window (as the note has been hidden by then) - if the
            // window is in another process SetFocus back to the owner will be ignored.
            // Also, in the places we call DestroyWindow we need to make sure we go thro' this
            // WM_CLOSE handler. So all calls to DestroyWindow instead call WM_OE_DESTROYNOTE
            // which sets an internal flag to force down the note (so we don't prompt if dirty)
            // and then calls WM_CLOSE, which falls thro' to DefWndProc and results in a DestroyWindow
            // got it?
            if (m_dwNoteCreateFlags & OENCF_MODAL)
            {
                // Need to enable the owner window
                if (NULL != m_hwndOwner)   
                {
                    EnableWindow(m_hwndOwner, TRUE);
                }
            }
           
            break;

        case WM_MEASUREITEM:
            if(m_pBodyObj2 &&
                m_pBodyObj2->HrWMMeasureMenuItem(hwnd, (LPMEASUREITEMSTRUCT)lParam)==S_OK)
                return 0;
            break;

        case WM_DRAWITEM:
            if(m_pBodyObj2 &&
                m_pBodyObj2->HrWMDrawMenuItem(hwnd, (LPDRAWITEMSTRUCT)lParam)==S_OK)
                return 0;
            break;


        case WM_DROPFILES:
            if (m_pHdr)
                m_pHdr->DropFiles((HDROP)wParam, FALSE);
            return 0;

        case WM_COMMAND:
            WMCommand(  GET_WM_COMMAND_HWND(wParam, lParam),
                        GET_WM_COMMAND_ID(wParam, lParam),
                        GET_WM_COMMAND_CMD(wParam, lParam));
            return 0;

        case WM_INITMENUPOPUP:
            return WMInitMenuPopup(hwnd, (HMENU)wParam, (UINT)LOWORD(lParam));

        case WM_GETMINMAXINFO:
            WMGetMinMaxInfo((LPMINMAXINFO)lParam);
            break;

        case WM_MENUSELECT:
            if (LOWORD(wParam)>=ID_STATIONERY_RECENT_0 && LOWORD(wParam)<=ID_STATIONERY_RECENT_9)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
                return 0;
            }
            if (LOWORD(wParam)>=ID_APPLY_STATIONERY_0 && LOWORD(wParam)<=ID_APPLY_STATIONERY_9)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsApplyStationeryGeneralHelp));
                return 0;
            }
            if (LOWORD(wParam)>=ID_SIGNATURE_FIRST && LOWORD(wParam)<=ID_SIGNATURE_LAST)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsInsertSigGeneralHelp));
                return 0;
            }
            if (LOWORD(wParam)>=ID_FORMAT_FIRST && LOWORD(wParam)<=ID_FORMAT_LAST)
            {
                m_pstatus->ShowSimpleText(MAKEINTRESOURCE(idsApplyFormatGeneralHelp));
                return 0;
            }

            HandleMenuSelect(m_pstatus, wParam, lParam);
            return 0;

        case NWM_TESTGETDISP:
        case NWM_TESTGETADDR:
            return lTestHook(msg, wParam, lParam);

        case NWM_UPDATETOOLBAR:
            m_pToolbarObj->Update();
            return 0;

        case NWM_PASTETOATTACHMENT:
            if (m_pHdr)
                m_pHdr->DropFiles((HDROP)wParam, (BOOL)lParam);

            return 0;

        case WM_CONTEXTMENU:
            break;

        case WM_SIZE:
            if(wParam==SIZE_RESTORED)   // update global last-size
                GetWindowRect(hwnd, &g_rcLastResize);

            WMSize(LOWORD(lParam), HIWORD(lParam), FALSE);
            break;

        case WM_NOTIFY:
            WMNotify((int) wParam, (NMHDR *)lParam);
            break;

        case WM_SETCURSOR:
            if (!!m_fWindowDisabled)
            {
                HourGlass();
                return TRUE;
            }
            break;

        case WM_DISPLAYCHANGE:
            {
                WINDOWPLACEMENT wp;

                wp.length = sizeof(wp);
                GetWindowPlacement(hwnd, &wp);
                SetWindowPlacement(hwnd, &wp);
            }
            // Drop through
        case WM_WININICHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            {
                HWND hwndT;

                // pass down to trident
                if (m_pBodyObj2 && 
                    m_pBodyObj2->HrGetWindow(&hwndT)==S_OK)
                    SendMessage(hwndT, msg, wParam, lParam);

                if (m_pToolbarObj &&
                    m_pToolbarObj->GetWindow(&hwndT)==S_OK)
                    SendMessage(hwndT, msg, wParam, lParam);
            }
            break;

        default:
            if (g_msgMSWheel && (msg == g_msgMSWheel))
            {
                HWND hwndFocus = GetFocus();
                if (hwndFocus != hwnd)
                    return SendMessage(hwndFocus, msg, wParam, lParam);
            }
            break;
    }

    lResult=DefWindowProcWrapW(hwnd, msg, wParam, lParam);
    if (msg==WM_ACTIVATE)
    {
        // need to post-process this

        // save the control with the focus don't do this is we're
        // minimized, otherwise GetFocus()==m_hwnd
        if (!HIWORD(wParam))
        {
            // if not minimized, save/restore child focus
            
            if ((LOWORD(wParam) == WA_INACTIVE))
            {
                // if deactivating then save the focus
                m_hwndFocus = GetFocus();
                DOUTL(4, "Focus was on 0x%x", m_hwndFocus);
            }    
            else
            {
                // if activating, and not minimized then restore focus
                if (IsWindow(m_hwndFocus) && 
                    IsChild(hwnd, m_hwndFocus))
                {
                    DOUTL(4, "Restoring Focus to: 0x%x", m_hwndFocus);
                    SetFocus(m_hwndFocus);
                }        
            }
        }
        
        if (!(m_dwNoteCreateFlags & OENCF_MODAL))
            SetTlsGlobalActiveNote((LOWORD(wParam)==WA_INACTIVE)?NULL:this);
        DOUTL(8, "CNote::WMActivate:: %x", GetTlsGlobalActiveNote());
    }
    return lResult;
}

// *************************
BOOL CNote::FCanClose()
{
    int id;
    HRESULT hr = S_OK;

    if(IsDirty()==S_FALSE)
        return TRUE;

    // TODO: set the title properly
    id = AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsSaveChangesMsg), NULL, MB_YESNOCANCEL|MB_ICONWARNING);
    if(id==IDCANCEL)
        return FALSE;

    // Note - It's the job of the subclass to display any UI that might
    //        describe why saving failed.
    if (id == IDYES)
        hr = SaveMessage(NOFLAGS);

    if (FAILED(hr))
    {
        if (E_PENDING == hr)
            m_fCBDestroyWindow = TRUE;
        return FALSE;
    }

    return TRUE;
}

// *************************
HRESULT CNote::SaveMessage(DWORD dwSaveFlags)
{
    HRESULT         hr;
    IMimeMessage   *pMsg = NULL;
    IImnAccount    *pAcct = NULL;

    hr = HrCreateMessage(&pMsg);
    if (FAILED(hr))
        goto exit;

    hr = Save(pMsg, 0);
    if (SUCCEEDED(hr))
    {
        hr = m_pHdr->HrGetAccountInHeader(&pAcct);
        if (FAILED(hr))
            goto exit;

        dwSaveFlags |= OESF_UNSENT;
        if (m_fOriginallyWasRead && (OENA_COMPOSE == m_dwNoteAction))
            dwSaveFlags |= OESF_SAVE_IN_ORIG_FOLDER;

        if(IsSecure(pMsg))
        {
            if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                    MAKEINTRESOURCEW(idsSaveSecMsgToDraft), NULL, MB_OKCANCEL) == IDCANCEL)
            {
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }
            else
            {
                PROPVARIANT     rVariant;
                IMimeBody      *pBody = NULL;

                rVariant.vt = VT_BOOL;
                rVariant.boolVal = TRUE;

                hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
                if(SUCCEEDED(hr))
                {
                    pBody->SetOption(OID_NOSECURITY_ONSAVE, &rVariant);
                    ReleaseObj(pBody);
                }


            }
        }

        m_fHasBeenSaved = TRUE;

        _SetPendingOp(SOT_PUT_MESSAGE);

        hr = m_pMsgSite->Save(pMsg, dwSaveFlags, pAcct);
        if (SUCCEEDED(hr))
            _OnComplete(SOT_PUT_MESSAGE, S_OK);
        else
            if (hr == E_PENDING)
                EnableNote(FALSE);
    }

exit:
    ReleaseObj(pAcct);
    ReleaseObj(pMsg);
    return hr;
}

// *************************
void CNote::WMNCDestroy()
{
    if (m_dwNoteCreateFlags & OENCF_MODAL)
        PostQuitMessage(0);
    SetWndThisPtr(m_hwnd, NULL);

    m_hwnd=NULL;
    Release();
}


// *************************
void CNote::ChangeReadToComposeIfUnsent(IMimeMessage *pMsg)
{
    DWORD   dwStatusFlags = 0;
    if (m_fReadNote && SUCCEEDED(m_pMsgSite->GetStatusFlags(&dwStatusFlags)) && 
        (OEMSF_UNSENT & dwStatusFlags))
    {
        m_dwNoteAction = OENA_COMPOSE;
        m_fReadNote = FALSE;
    }
}

// *************************
void CNote::ReloadMessageFromSite(BOOL fOriginal)
{
    IMimeMessage   *pMsg = NULL;
    BOOL            fBool = FALSE,
                    fTempHtml;
    DWORD           dwBodyStyle = MESTYLE_NOHEADER,
                    dwMsgFlags;
    HRESULT         hr = S_OK,
                    tempHr;

    if (OENA_FORWARDBYATTACH == m_dwNoteAction)
        dwMsgFlags = (OEGM_ORIGINAL|OEGM_AS_ATTACH);
    else
        dwMsgFlags = (fOriginal ? OEGM_ORIGINAL : NOFLAGS);

    hr = m_pMsgSite->GetMessage(&pMsg, &fBool, dwMsgFlags, &tempHr);
    if (SUCCEEDED(hr))
    {
        // ~~~ Check what happens here if message is not downloaded and hit forward as attach
        DWORD dwFlags = 0;
        m_fCompleteMsg = !!fBool;

        // All notes will be read note unless unsent
        m_dwNoteAction = OENA_READ;
        m_fOriginallyWasRead = TRUE;
        m_fReadNote = TRUE;

        // Is this an unsent message and is a read note? Then should be a compose.
        ChangeReadToComposeIfUnsent(pMsg);

        // This needs to be called for the case where we load an IMAP message. In this
        // case we don't know if it is html or not. We won't know until after it is
        // downloaded. That is what is happening at this point. Before we do our
        // load, let's make sure that we have set m_fHtml properly. RAID 46327
        if(CheckSecReceipt(pMsg) == S_OK)
            fTempHtml = TRUE;
        else
        {
            pMsg->GetFlags(&dwFlags);
            fTempHtml = !!(dwFlags & IMF_HTML);
        }

        // If m_fHtml was already set correctly, then don't do it again.
        if (fTempHtml != m_fHtml)
        {
            m_fFormatbarVisible = m_fHtml = fTempHtml;

            if (!m_fReadNote && !m_fBodyContainsFrames && m_fFormatbarVisible)
                dwBodyStyle = MESTYLE_FORMATBAR;

            m_pBodyObj2->HrSetStyle(dwBodyStyle);
            m_pBodyObj2->HrEnableHTMLMode(m_fHtml);
        }

        Load(pMsg);
        InitMenusAndToolbars();
        
        pMsg->Release();

        if (FAILED(tempHr))
            ShowErrorScreen(tempHr);
    }
    else
    {
        if (E_FAIL == hr)
            m_fCBDestroyWindow = TRUE;
    }
}

// *************************
HRESULT CNote::WMCommand(HWND hwndCmd, int id, WORD wCmd)
{
    int         iRet = 0;
    DWORD       dwFlags = 0;
    FOLDERID    folderID = FOLDERID_INVALID;

    DOUTL(4, "CNote::WMCommand");

    OLECMD          cmd;

    // We can hit this via accelerators.  Since accelerators don't go through 
    // QueryStatus(), we need to make sure this should really be enabled.
    cmd.cmdID = id;
    cmd.cmdf = 0;
    if (FAILED(QueryStatus(&CMDSETID_OutlookExpress, 1, &cmd, NULL)) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
        return (S_OK);
    
    // see if any of these are for the body control, if so we're done...
    if(m_pBodyObj2 && SUCCEEDED(m_pBodyObj2->HrWMCommand(hwndCmd, id, wCmd)))
        return S_OK;

    // give the header a shot after the note is done
    if (m_pHdr &&
        m_pHdr->WMCommand(hwndCmd, id, wCmd)==S_OK)
        return S_OK;

    // Don't handle anything that isn't a menu item or accelerator
    if (wCmd <= 1)
    {
        if ((id == ID_SEND_NOW)   || (id >= ID_SEND_NOW_ACCOUNT_FIRST && id <= ID_SEND_NOW_ACCOUNT_LAST) ||
            (id == ID_SEND_LATER) || (id >= ID_SEND_LATER_ACCOUNT_FIRST && id <= ID_SEND_LATER_ACCOUNT_LAST))
        {
            HrSendMail(id);
            return S_OK;
        }

        if (id >= ID_LANG_FIRST && id <= ID_LANG_LAST)
        {
            SwitchLanguage(id);
            return S_OK;
        }

        if (id>=ID_ADD_RECIPIENT_FIRST && id<=ID_ADD_RECIPIENT_LAST)
        {
            if (m_pHdr)
                m_pHdr->AddRecipient(id - ID_ADD_RECIPIENT_FIRST);
            return S_OK;
        }

        if (id > ID_MSWEB_BASE && id < ID_MSWEB_LAST)
        {
            OnHelpGoto(m_hwnd, id);
            return S_OK;
        }

        // Handle all "create new note" IDs
        Assert(m_pMsgSite);
        if (m_pMsgSite)
        {
            m_pMsgSite->GetFolderID(&folderID);
            if (MenuUtil_HandleNewMessageIDs(id, m_hwnd, folderID, m_fMail, (m_dwNoteCreateFlags & OENCF_MODAL)?TRUE:FALSE, m_punkPump))
                return S_OK;
        }

        // ONLY processing menu accelerators
        switch(id)
        {
            case ID_SEND_DEFAULT:
                HrSendMail(DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline() ? ID_SEND_NOW : ID_SEND_LATER);
                return S_OK;

            case ID_ABOUT:
                DoAboutAthena(m_hwnd, idiMail);
                return S_OK;

            case ID_SAVE:
                SaveMessage(NOFLAGS);
                return S_OK;

            case ID_NOTE_DELETE:
            {
                HRESULT hr;

                m_fOrgCmdWasDelete = TRUE;

                _SetPendingOp(SOT_DELETING_MESSAGES);

                hr = m_pMsgSite->Delete(NOFLAGS);
                if (SUCCEEDED(hr))
                    _OnComplete(SOT_DELETING_MESSAGES, S_OK);
                else 
                {
                    if (hr == E_PENDING)
                        EnableNote(FALSE);
                    else
                        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrDeleteMsg), NULL, MB_OK);
                }
                return S_OK;
            }

            case ID_NOTE_COPY_TO_FOLDER:
            case ID_NOTE_MOVE_TO_FOLDER:
            {
                HRESULT         hr;
                IMimeMessage   *pMsg = NULL;
                DWORD           dwStatusFlags = 0;

                m_fCBCopy = (ID_NOTE_COPY_TO_FOLDER == id);

                m_pMsgSite->GetStatusFlags(&dwStatusFlags);
                if (S_OK == IsDirty() || ((OEMSF_FROM_MSG | OEMSF_VIRGIN) & dwStatusFlags))
                {
                    CommitChangesInNote();
                    pMsg = m_pMsg;
                }

                if(IsSecure(m_pMsg) && !m_fReadNote)
                {
                    if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                            MAKEINTRESOURCEW(idsSaveSecMsgToFolder), NULL, MB_OKCANCEL) == IDCANCEL)
                        return S_OK;
                    else
                    {
                        PROPVARIANT     rVariant;
                        IMimeBody      *pBody = NULL;

                        rVariant.vt = VT_BOOL;
                        rVariant.boolVal = TRUE;

                        hr = m_pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
                        if(SUCCEEDED(hr))
                        {
                            pBody->SetOption(OID_NOSECURITY_ONSAVE, &rVariant);
                            ReleaseObj(pBody);
                        }
                    }
                }

                _SetPendingOp(SOT_COPYMOVE_MESSAGE);
                hr = m_pMsgSite->DoCopyMoveToFolder(m_fCBCopy, pMsg, !m_fReadNote);
                if (SUCCEEDED(hr))
                    _OnComplete(SOT_COPYMOVE_MESSAGE, S_OK);
                else if (E_PENDING == hr)
                    EnableNote(FALSE);

                return S_OK;
            }

            case ID_NEXT_UNREAD_MESSAGE:
            case ID_NEXT_UNREAD_THREAD:
            case ID_NEXT_UNREAD_ARTICLE:
                dwFlags = OENF_UNREAD;
                if (ID_NEXT_UNREAD_THREAD == id)
                    dwFlags |= OENF_THREAD;
                // Fall through

            case ID_PREVIOUS:
            case ID_NEXT_MESSAGE:
            {
                HRESULT hr;
                dwFlags |= (m_fMail ? OENF_SKIPMAIL : OENF_SKIPNEWS);

                hr = m_pMsgSite->DoNextPrev((ID_PREVIOUS != id), dwFlags);
                if (SUCCEEDED(hr))
                {
                    ReloadMessageFromSite();
                    AssertSz(!m_fCBDestroyWindow, "Shouldn't need to destroy the window...");
                }
#ifdef DEBUG
                // All DoNextPrev does is set the new message ID. Should never need to go
                // E_PENDING to get that information
                else if (E_PENDING == hr)
                    AssertSz(FALSE, "Didn't expect to get an E_PENDING with NextPrev.");
#endif
                else
                    MessageBeep(MB_OK);
                    
                return S_OK;
            }

            case ID_MARK_THREAD_READ:
                MarkMessage(MARK_MESSAGE_READ, APPLY_CHILDREN);
                return S_OK;

            case ID_NOTE_PROPERTIES:
                DoProperties();
                return S_OK;

            case ID_REPLY:
            case ID_REPLY_GROUP:
            case ID_REPLY_ALL:
            case ID_FORWARD:
            case ID_FORWARD_AS_ATTACH:
            {
                DWORD   dwAction = 0;
                RECT    rc;
                HRESULT hr = S_OK;

                GetWindowRect(m_hwnd, &rc);
                switch (id)
                {
                    case ID_REPLY:              dwAction = OENA_REPLYTOAUTHOR; break;
                    case ID_REPLY_GROUP:        dwAction = OENA_REPLYTONEWSGROUP; break;
                    case ID_REPLY_ALL:          dwAction = OENA_REPLYALL; break;
                    case ID_FORWARD:            dwAction = OENA_FORWARD; break;
                    case ID_FORWARD_AS_ATTACH:  dwAction = OENA_FORWARDBYATTACH; break;
                    default:                    AssertSz(dwAction, "We are about to create a note with no action."); break;
                };

                AssertSz(m_pMsgSite, "We are about to create a note with a null m_pMsgSite.");
                hr = CreateAndShowNote(dwAction, m_dwNoteCreateFlags, NULL, m_hwnd, m_punkPump, &rc, m_pMsgSite);
                if (SUCCEEDED(hr))
                {
                    // Since the new note has this site now, I don't need to keep track of it.
                    // More importantly, if I do, I break the new note since I will try to
                    // close the msgsite on my destroy notification. If I haven't released it,
                    // I would then null out items in 
                    SafeRelease(m_pMsgSite);
                    PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
                }
                else if (m_fReadNote && (MAPI_E_USER_CANCEL != hr))
                    AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrReplyForward), NULL, MB_OK);

                return S_OK;
            }

            case ID_HELP_CONTENTS:
                OEHtmlHelp(GetParent(m_hwnd), c_szMailHelpFileHTML, HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR) c_szCtxHelpDefault);
                return S_OK;

            case ID_README:
                DoReadme(m_hwnd);
                break;
        
            case ID_SEND_OBJECTS:
                m_fPackageImages = !m_fPackageImages;
                return S_OK;

            case ID_NEW_CONTACT:
    #if 0
                Assert(g_pABInit);
                if (g_pABInit)
                    g_pABInit->NewContact( m_hwnd );
    #endif
                nyi("New contact");
                return S_OK;

            case ID_NOTE_SAVE_AS:
                SaveMessageAs();
                return S_OK;

            case ID_CHECK_NAMES:
                HeaderExecCommand(MSOEENVCMDID_CHECKNAMES, MSOCMDEXECOPT_PROMPTUSER, NULL);
                return S_OK;

            case ID_SELECT_RECIPIENTS:
                HeaderExecCommand(MSOEENVCMDID_SELECTRECIPIENTS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_SELECT_NEWSGROUPS:
                HeaderExecCommand(MSOEENVCMDID_PICKNEWSGROUPS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_NEWSGROUPS:
                HeaderExecCommand(MSOEENVCMDID_PICKNEWSGROUPS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_ADDRESS_BOOK:
                HeaderExecCommand(MSOEENVCMDID_VIEWCONTACTS, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_CREATE_RULE_FROM_MESSAGE:
                {
                    MESSAGEINFO msginfo = {0};
                    
                    return HrCreateRuleFromMessage(m_hwnd, (FALSE == m_fMail) ? CRFMF_NEWS : CRFMF_MAIL, &msginfo, m_pMsg);
                }
                break;

            case ID_BLOCK_SENDER:
                {
                    return _HrBlockSender((FALSE == m_fMail) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, m_pMsg, m_hwnd);
                }
                break;
                
            case ID_FIND_MESSAGE:
                DoFindMsg(FOLDERID_ROOT, FOLDER_ROOTNODE);
                break;

            case ID_FIND_PEOPLE:
            {
                TCHAR szWABExePath[MAX_PATH];
                if(S_OK == HrLoadPathWABEXE(szWABExePath, sizeof(szWABExePath)))
                    ShellExecute(NULL, "open", szWABExePath, "/find", "", SW_SHOWNORMAL);
                break;
            }

            case ID_OPTIONS:
                ShowOptions(m_hwnd, ATHENA_OPTIONS, 0, NULL);
                break;

            case ID_ACCOUNTS:
            {
                DoAccountListDialog(m_hwnd, m_fMail?ACCT_MAIL:ACCT_NEWS);
                break;
            }

            case ID_ADD_ALL_TO:
                HeaderExecCommand(MSOEENVCMDID_ADDALLONTO, MSOCMDEXECOPT_DODEFAULT, NULL);
                break;

            case ID_ADD_SENDER:
                if(m_fMail)
                {
                    if (m_pHdr)
                        m_pHdr->AddRecipient(-1);
                }
                else
                    HeaderExecCommand(MSOEENVCMDID_ADDSENDER, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_INSERT_CONTACT_INFO:
                HeaderExecCommand(MSOEENVCMDID_VCARD, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;


            case ID_FULL_HEADERS:
                m_fFullHeaders = !m_fFullHeaders;
                if(m_pHdr)
                    m_pHdr->ShowAdvancedHeaders(m_fFullHeaders);

                if (m_fMail)
                    SetDwOption((m_fReadNote ? OPT_MAILNOTEADVREAD : OPT_MAILNOTEADVSEND), m_fFullHeaders, NULL, 0);
                else
                    SetDwOption((m_fReadNote ? OPT_NEWSNOTEADVREAD : OPT_NEWSNOTEADVSEND), m_fFullHeaders, NULL, 0);
                return S_OK;

            case ID_CUT:
                SendMessage(GetFocus(), WM_CUT, 0, 0);
                return S_OK;

            case ID_NOTE_COPY:
            case ID_COPY:
                SendMessage(GetFocus(), WM_COPY, 0, 0);
                return S_OK;

            case ID_PASTE:
                SendMessage(GetFocus(), WM_PASTE, 0, 0);
                return S_OK;

            case ID_SHOW_TOOLBAR:
                ToggleToolbar();
                return S_OK;

            case ID_CUSTOMIZE:
                SendMessage(m_hwndToolbar, TB_CUSTOMIZE, 0, 0);
                break;

            case ID_FORMATTING_TOOLBAR:
                ToggleFormatbar();
                return S_OK;

            case ID_STATUS_BAR:
                ToggleStatusbar();
                return S_OK;

            case ID_UNDO:
                Edit_Undo(GetFocus());
                return S_OK;

            case ID_SELECT_ALL:
                Edit_SetSel(GetFocus(), 0, -1);
                return S_OK;

            case ID_CLOSE:
                SendMessage(m_hwnd, WM_CLOSE, 0, 0);
                return S_OK;

            case ID_SPELLING:
                if (FCheckSpellAvail() && (!m_fReadNote))
                {
                    HWND    hwndFocus = GetFocus();
                    HRESULT hr;

                    hr = m_pBodyObj2->HrSpellCheck(FALSE);
                    if(FAILED(hr))
                        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrSpellGenericSpell), NULL, MB_OK | MB_ICONSTOP);

                    SetFocus(hwndFocus);
                }
                return S_OK;

            case ID_FORMAT_SETTINGS:
                FormatSettings();
                return S_OK;

            case ID_WORK_OFFLINE:
                if (g_pConMan)
                    g_pConMan->SetGlobalOffline(!g_pConMan->IsGlobalOffline(), hwndCmd);

                if (m_pToolbarObj)
                    m_pToolbarObj->Update();

                break;

            case ID_RICH_TEXT:
            case ID_PLAIN_TEXT:
                // noops
                if(id==ID_RICH_TEXT && m_fHtml)
                    return S_OK;
                if(id==ID_PLAIN_TEXT && !m_fHtml)
                    return S_OK;

                // if going to plain, warn the user he'll loose formatting...
                if((ID_PLAIN_TEXT == id) &&
                   (IDCANCEL == DoDontShowMeAgainDlg(m_hwnd, c_szDSHtmlToPlain, MAKEINTRESOURCE(idsAthena),
                                        MAKEINTRESOURCE(idsWarnHTMLToPlain), MB_OKCANCEL)))
                    return S_OK;

                m_fHtml=!!(id==ID_RICH_TEXT);
        
                m_fFormatbarVisible=!!m_fHtml;
                m_pBodyObj2->HrSetStyle(m_fHtml ? MESTYLE_FORMATBAR : MESTYLE_NOHEADER);
                m_pBodyObj2->HrEnableHTMLMode(m_fHtml);

                // if going into plain-mode blow away formatting
                if (!m_fHtml)
                    m_pBodyObj2->HrDowngradeToPlainText();

                return S_OK;

            case ID_DIGITALLY_SIGN:
                HeaderExecCommand(MSOEENVCMDID_DIGSIGN, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_ENCRYPT:
                if(m_pHdr->ForceEncryption(NULL, FALSE) == S_FALSE)
                    HeaderExecCommand(MSOEENVCMDID_ENCRYPT, MSOCMDEXECOPT_DODEFAULT, NULL);
                return S_OK;

            case ID_INCLUDE_LABEL:
                m_fSecurityLabel = !m_fSecurityLabel;
                CheckAndForceEncryption();
                return S_OK;

            case ID_LABEL_SETTINGS:
                if(m_pLabel)
                {
                    if(DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSelectLabel),
                            m_hwnd, SecurityLabelsDlgProc, (LPARAM) &m_pLabel) != IDOK)
                        return (S_FALSE);
                    CheckAndForceEncryption();
                }
                return S_OK;

            case ID_SEC_RECEIPT_REQUEST:
                m_fSecReceiptRequest = !m_fSecReceiptRequest;
                break;

            case ID_FLAG_MESSAGE:
                m_dwCBMarkType = (!IsFlagged(ARF_FLAGGED)) ? MARK_MESSAGE_FLAGGED : MARK_MESSAGE_UNFLAGGED;
                MarkMessage(m_dwCBMarkType, APPLY_SPECIFIED);
                return S_OK;

            case ID_WATCH_THREAD:
                m_dwCBMarkType = (!IsFlagged(ARF_WATCH)) ? MARK_MESSAGE_WATCH : MARK_MESSAGE_NORMALTHREAD;
                MarkMessage(m_dwCBMarkType, APPLY_SPECIFIED);
                return S_OK;

            case ID_IGNORE_THREAD:
                m_dwCBMarkType = (!IsFlagged(ARF_IGNORE)) ? MARK_MESSAGE_IGNORE : MARK_MESSAGE_NORMALTHREAD;
                MarkMessage(m_dwCBMarkType, APPLY_SPECIFIED);
                return S_OK;

            case ID_APPLY_STATIONERY_0:
            case ID_APPLY_STATIONERY_1:
            case ID_APPLY_STATIONERY_2:
            case ID_APPLY_STATIONERY_3:
            case ID_APPLY_STATIONERY_4:
            case ID_APPLY_STATIONERY_5:
            case ID_APPLY_STATIONERY_6:
            case ID_APPLY_STATIONERY_7:
            case ID_APPLY_STATIONERY_8:
            case ID_APPLY_STATIONERY_9:
            case ID_APPLY_STATIONERY_MORE:
            case ID_APPLY_STATIONERY_NONE:
            {
                AssertSz(m_fHtml, "QueryStatus should have caught this and not let this function run.");
                HRESULT     hr;
                WCHAR       wszBuf[INTERNET_MAX_URL_LENGTH+1];
                *wszBuf = 0;
                switch (id)
                {
                    case ID_APPLY_STATIONERY_MORE:
                        hr = HrGetMoreStationeryFileName(m_hwnd, wszBuf);
                        break;

                    case ID_APPLY_STATIONERY_NONE:
                        *wszBuf=0;
                        hr = NOERROR;
                        break;

                    default:
                        hr = HrGetStationeryFileName(id - ID_APPLY_STATIONERY_0, wszBuf);
                        if (FAILED(hr))
                        {
                            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                                MAKEINTRESOURCEW(idsErrStationeryNotFound), NULL, MB_OK | MB_ICONERROR);
                        
                            HrRemoveFromStationeryMRU(wszBuf);
                        }
                        break;
                }

                if(m_pBodyObj2 && SUCCEEDED(hr))
                {
                    hr = m_pBodyObj2->HrApplyStationery(wszBuf);
                    if(SUCCEEDED(hr))
                        HrAddToStationeryMRU(wszBuf);
                }
                return S_OK;

            case IDOK:
            case IDCANCEL:
                // ignore these
                return S_OK;

            case ID_REQUEST_READRCPT:
                m_pMsgSite->Notify(OEMSN_TOGGLE_READRCPT_REQ);
                return S_OK;

            default:
                if(id>=ID_ADDROBJ_OLE_FIRST && id <=ID_ADDROBJ_OLE_LAST)
                {
                    DoNoteOleVerb(id-ID_ADDROBJ_OLE_FIRST);
                    return S_OK;
                }
            }
        }
    }

    if(wCmd==NHD_SIZECHANGE &&
        id==idcNoteHdr)
    {
        DOUTL(8, "CNote::NHD_SIZECHANGE - doing note WMSize");
        //header control is requesting a resize
        WMSize(NULL, NULL, TRUE);
        return S_OK;
    }

    return S_FALSE;
}

// *************************
BOOL CNote::IsFlagged(DWORD dwFlag)
{
    BOOL fFlagged = FALSE;
    MESSAGEFLAGS dwCurrFlags = 0;

    Assert(m_pMsgSite);
    if (m_pMsgSite)
    {
        // Readnote and compose note are the only ones that can be flagged. The others might
        // be flagged in the store, but since we are replying or forwarding, etc, they can't
        // be flagged. RAID 37729
        if ((m_fReadNote || (OENA_COMPOSE == m_dwNoteAction)) && SUCCEEDED(m_pMsgSite->GetMessageFlags(&dwCurrFlags)))
            fFlagged = (0 != (dwFlag & dwCurrFlags));
    }

    return fFlagged;
}

// *************************
void CNote::DeferedLanguageMenu()
{
    HMENU hMenu = m_hMenu;

    Assert (hMenu);

    if (!m_hmenuLanguage)
    {    // load global MIME language codepage data
        InitMultiLanguage();
    }
    else
    {
        // Charset chaching mechanism requires us to reconstruct 
        // language menu every time
        DestroyMenu(m_hmenuLanguage);
    }
    m_hmenuLanguage = CreateMimeLanguageMenu(m_fMail, m_fReadNote, CustomGetCPFromCharset(m_hCharset, m_fReadNote));       
}

// *************************
LRESULT CNote::WMInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos)
{
    MENUITEMINFO    mii;
    HMENU           hmenuMain;
    HWND            hwndFocus=GetFocus();
    DWORD           dwFlags=0;
    BOOL            fEnableStyleMenu = FALSE;

    hmenuMain = m_hMenu;
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;

    if (hmenuMain == NULL ||!GetMenuItemInfo(hmenuMain, uPos, TRUE, &mii) || mii.hSubMenu != hmenuPopup)
    {

        if (GetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii) && mii.hSubMenu == hmenuPopup)
        {
            mii.wID=ID_POPUP_LANGUAGE;
            mii.fMask = MIIM_ID;
            SetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE_DEFERRED, FALSE, &mii);
        }

        mii.fMask = MIIM_ID | MIIM_SUBMENU;

        if (GetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE, FALSE, &mii) && mii.hSubMenu == hmenuPopup)
        {
            DeferedLanguageMenu();
            mii.fMask = MIIM_SUBMENU;
            mii.wID=ID_POPUP_LANGUAGE;

            hmenuPopup = mii.hSubMenu = m_hmenuLanguage;
            SetMenuItemInfo(hmenuMain, ID_POPUP_LANGUAGE, FALSE, &mii);
        }
        else return 1;
    }

    switch (mii.wID)
    {
        case ID_POPUP_FILE:
        case ID_POPUP_EDIT:
        case ID_POPUP_VIEW:
            break;

        case ID_POPUP_INSERT:
            InitSigPopupMenu(hmenuPopup, NULL);
            break;

        case ID_POPUP_FORMAT:
        {
            AddStationeryMenu(hmenuPopup, ID_POPUP_STATIONERY, ID_APPLY_STATIONERY_0, ID_APPLY_STATIONERY_MORE);
            fEnableStyleMenu = TRUE;
            break;
        }

        case ID_POPUP_TOOLS:
            if (m_fMail)
            {
                DeleteMenu(hmenuPopup, ID_SELECT_NEWSGROUPS, MF_BYCOMMAND);
#ifdef SMIME_V3
                if (!FPresentPolicyRegInfo()) 
                {
                    DeleteMenu(hmenuPopup, ID_INCLUDE_LABEL, MF_BYCOMMAND);
                    DeleteMenu(hmenuPopup, ID_LABEL_SETTINGS, MF_BYCOMMAND);
                    m_fSecurityLabel = FALSE;
                }
                if(!IsSMIME3Supported())
                {
                    DeleteMenu(hmenuPopup, ID_SEC_RECEIPT_REQUEST, MF_BYCOMMAND);
                    m_fSecReceiptRequest = FALSE;
                }


#endif 
            }
            else
            {
                DeleteMenu(hmenuPopup, ID_REQUEST_READRCPT, MF_BYCOMMAND);
#ifdef SMIME_V3
                DeleteMenu(hmenuPopup, ID_INCLUDE_LABEL, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_LABEL_SETTINGS, MF_BYCOMMAND);
                DeleteMenu(hmenuPopup, ID_SEC_RECEIPT_REQUEST, MF_BYCOMMAND);
                m_fSecurityLabel = FALSE;
                m_fSecReceiptRequest = FALSE;
#endif 
            }

            if (GetMenuItemInfo(hmenuPopup, ID_POPUP_ADDRESS_BOOK, FALSE, &mii))
                m_pHdr->UpdateRecipientMenu(mii.hSubMenu);

            break;

        case ID_POPUP_MESSAGE:
        {
            AddStationeryMenu(hmenuPopup, ID_POPUP_NEW_MSG, ID_STATIONERY_RECENT_0, ID_STATIONERY_MORE);
            break;
        }

        case ID_POPUP_LANGUAGE:
        {
            if (m_pBodyObj2)
                m_pBodyObj2->HrOnInitMenuPopup(hmenuPopup, ID_POPUP_LANGUAGE);
            break;
        }
    }
    MenuUtil_EnablePopupMenu(hmenuPopup, this);
    if (fEnableStyleMenu)
    {
        if (m_pBodyObj2)
            m_pBodyObj2->UpdateBackAndStyleMenus(hmenuPopup);
    }

    return S_OK;
}

// *************************
void CNote::RemoveNewMailIcon(void)
{
    HRESULT     hr;
    FOLDERINFO  fiFolderInfo;
    FOLDERID    idFolder;

    // If a message is marked (read or deleted) and it's from the Inbox,
    // remove the new mail notification icon from the tray
    if (NULL == g_pInstance || NULL == m_pMsgSite || NULL == g_pStore)
        return;

    hr = m_pMsgSite->GetFolderID(&idFolder);
    if (FAILED(hr))
        return;

    hr = g_pStore->GetFolderInfo(idFolder, &fiFolderInfo);
    if (SUCCEEDED(hr))
    {
        if (FOLDER_INBOX == fiFolderInfo.tySpecial)
            g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);

        g_pStore->FreeRecord(&fiFolderInfo);
    }
}


// *************************
LRESULT CNote::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, UINT wID)
{
    return 0;
}


// *************************
void CNote::WMGetMinMaxInfo(LPMINMAXINFO pmmi)
{

    MINMAXINFO  mmi={0};
    RECT        rc;
    int         cy;
    ULONG       cyAttMan=0;
    HWND        hwnd;

    cy=GetRequiredHdrHeight();

    
    Assert(IsWindow(m_hwndToolbar));
    if(IsWindowVisible(m_hwndToolbar))
    {
        GetWindowRect(m_hwndToolbar, &rc);
        cy += cyRect(rc);
    }
    
    cy += GetSystemMetrics(SM_CYCAPTION);
    cy += GetSystemMetrics(SM_CYMENU);
    cy += 2*cyMinEdit;
    pmmi->ptMinTrackSize.x=200; //hack
    pmmi->ptMinTrackSize.y=cy;
}

// *************************
INT CNote::GetRequiredHdrHeight()
{
    RECT    rc={0};

    if(m_pHdr)
        m_pHdr->GetRect(&rc);
    return cyRect(rc);
}

// *************************
LONG CNote::lTestHook(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

// *************************
void CNote::WMNotify(int idFrom, NMHDR *pnmh)
{
    switch(pnmh->code)
    {
        case NM_SETFOCUS:
            if (pnmh)
                OnSetFocus(pnmh->hwndFrom);
            break;

        case NM_KILLFOCUS:
            OnKillFocus();
            break;

        case BDN_DOWNLOADCOMPLETE:
            OnDocumentReady();
            break;

        case BDN_MARKASSECURE:
            MarkMessage(MARK_MESSAGE_NOSECUI, APPLY_SPECIFIED);
            break;

        case TBN_DROPDOWN:
            OnDropDown(m_hwnd, pnmh);
            break;
    }
}

// *************************
void CNote::OnDocumentReady()
{
    if (!m_fOnDocReadyHandled && m_fCompleteMsg)
    {
        HRESULT     hr;
        DWORD       dwStatusFlags;

        m_fOnDocReadyHandled = TRUE;

        m_pMsgSite->GetStatusFlags(&dwStatusFlags);
        // once, we've got a successfull download, we can init the attachment manager.
        // we can't do this before, as we have to wait until Trident has requested MHTML parts so we
        // can mark them as inlined. If we're in a reply or reply all then we have to remove the unused
        // attachments at this time

        if (IsReplyNote())
            HrRemoveAttachments(m_pMsg, FALSE);

        // #62618: hack. if forwarding a multi/altern in (force) plain-text mode then the html part
        // shows up as an attachment
        // we call GetTextBody here on the html body if we're a plaintext node in forward so that
        // PID_ATT_RENDERED is set before we load teh attachment well
        if (m_dwNoteAction == OENA_FORWARD && m_fHtml == FALSE)
        {
            HBODY   hBody;
            IStream *pstm;

            if (m_pMsg && 
                !FAILED(m_pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstm, NULL)))
                pstm->Release();
        }


        if (m_pHdr)
        {
            if (FAILED(m_pHdr->OnDocumentReady(m_pMsg)))
                AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrAttmanLoadFail), NULL, MB_OK|MB_ICONEXCLAMATION);
            m_pHdr->SetVCard((OEMSF_FROM_MSG|OEMSF_VIRGIN) & dwStatusFlags);
        }

        ClearDirtyFlag();

        // RAID-25300 - FE-J:Athena: Newsgroup article and mail sent with charset=_autodetect
        // Internet Encoded and Windows Encoding are CPI_AUTODETECT
        {
            INETCSETINFO CsetInfo ;
            HCHARSET hCharset = NULL ;
            int nIdm = 0 ;

            // if it is a new message, check if charset equals to default charset
            if ((OENA_COMPOSE == m_dwNoteAction) && (OEMSF_VIRGIN & dwStatusFlags))
            {
                // defer default charset reading until now ..
                if (g_hDefaultCharsetForMail==NULL) 
                    ReadSendMailDefaultCharset();

                if (m_hCharset != g_hDefaultCharsetForMail )
                    hCharset = g_hDefaultCharsetForMail ;

                // get CharsetInfo from HCHARSET
                if ( hCharset)
                    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
                else
                    MimeOleGetCharsetInfo(m_hCharset,&CsetInfo);
            }
            else
                // get CharsetInfo from HCHARSET
                MimeOleGetCharsetInfo(m_hCharset,&CsetInfo);

            // re-map CP_JAUTODETECT and CP_KAUTODETECT if necessary
            // re-map iso-2022-jp to default charset if they are in the same category
            if (!m_fReadNote) 
            {
                hCharset = GetMimeCharsetFromCodePage(GetMapCP(CsetInfo.cpiInternet, FALSE));
            }
            else
            {
                VARIANTARG  va;

                va.vt = VT_BOOL;
                va.boolVal = VARIANT_TRUE;

                m_pCmdTargetBody->Exec(&CMDSETID_MimeEdit, MECMDID_TABLINKS, 0, &va, NULL);
            }

            // has a new charset defined, change it
            ChangeCharset(hCharset);

            // if user want's auto complete, enable it once we're fully loaded
            if (DwGetOption(OPT_USEAUTOCOMPLETE))
                HeaderExecCommand(MSOEENVCMDID_AUTOCOMPLETE, MSOCMDEXECOPT_DODEFAULT, NULL);

            if (m_fReadNote && m_fMail && m_pMsgSite)
            {
                if(m_pMsgSite->Notify(OEMSN_PROCESS_READRCPT_REQ) != S_OK)
                    return;
            }
        }

        if(DwGetOption(OPT_RTL_MSG_DIR) && ((m_dwNoteAction == OENA_FORWARDBYATTACH) || (OEMSF_VIRGIN & dwStatusFlags)))
        {
            if(FAILED(m_pCmdTargetBody->Exec(&CMDSETID_Forms3, IDM_DIRRTL, OLECMDEXECOPT_DODEFAULT, NULL, NULL)))
                AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrRTLDirFailed), NULL, MB_OK);
        }

        EnterCriticalSection(&m_csNoteState);

        if(m_nisNoteState == NIS_INIT)
            m_nisNoteState = NIS_NORMAL;

        LeaveCriticalSection(&m_csNoteState);
    }    
}

HRESULT CNote::ChangeCharset(HCHARSET hCharset)
{
    HRESULT hr = S_OK;
    if (hCharset && (hCharset != m_hCharset))
    {
        Assert(m_pBodyObj2);
        IF_FAILEXIT(hr = m_pBodyObj2->HrSetCharset(hCharset));

        // set the new charset into the message and call HrLanguageChange to update the headers
        m_hCharset = hCharset;
        if (m_pMsg)
            m_pMsg->SetCharset(hCharset, CSET_APPLY_ALL);

        if (m_pHdr)
            m_pHdr->ChangeLanguage(m_pMsg);

        UpdateTitle();
    }

exit:
    return hr;
}

HRESULT CNote::GetCharset(HCHARSET *phCharset)
{
    Assert(phCharset);

    *phCharset = m_hCharset;

    return S_OK;
}

// *************************
LRESULT CNote::OnDropDown(HWND hwnd, LPNMHDR lpnmh)
{
    UINT            i;
    HMENU           hMenuPopup;
    RECT            rc;
    DWORD           dwCmd;
    TBNOTIFY       *ptbn = (TBNOTIFY *)lpnmh;

    if (ptbn->iItem == ID_SET_PRIORITY)
        {
        hMenuPopup = LoadPopupMenu(IDR_PRIORITY_POPUP);
        if (hMenuPopup != NULL)
            {
            for (i = 0; i < 3; i++)
                CheckMenuItem(hMenuPopup, i, MF_UNCHECKED | MF_BYPOSITION);
            m_pHdr->GetPriority(&i);
            Assert(i != priNone);
            CheckMenuItem(hMenuPopup, 2 - i, MF_CHECKED | MF_BYPOSITION);

            DoToolbarDropdown(hwnd, lpnmh, hMenuPopup);
        
            DestroyMenu(hMenuPopup);
            }
        }
    else if (ptbn->iItem == ID_INSERT_SIGNATURE)
        {
        hMenuPopup = CreatePopupMenu();
        if (hMenuPopup != NULL)
            {        
            FillSignatureMenu(hMenuPopup, NULL);
            DoToolbarDropdown(hwnd, lpnmh, hMenuPopup);

            DestroyMenu(hMenuPopup);
            }
        }
    else if(ptbn->iItem == ID_POPUP_LANGUAGE)
    {
        DeferedLanguageMenu();
        hMenuPopup = m_hmenuLanguage;
        if(hMenuPopup)
        {
            MenuUtil_EnablePopupMenu(hMenuPopup, this);
            DoToolbarDropdown(hwnd, lpnmh, hMenuPopup);
        }
    }

    return(TBDDRET_DEFAULT);
}

// *************************
void CNote::UpdateMsgOptions(LPMIMEMESSAGE pMsg)
{
    // Store the options onto the message object
    SideAssert(SUCCEEDED(HrSetMailOptionsOnMessage(pMsg, &m_rHtmlOpt, &m_rPlainOpt, m_hCharset, m_fHtml)));
}

// *************************
HRESULT CNote::SetComposeStationery()
{
    LPSTREAM        pstm;
    WCHAR           wszFile[MAX_PATH];
    HRESULT         hr=E_FAIL;
    HCHARSET        hCharset;
    ENCODINGTYPE    ietEncoding = IET_DECODED;
    BOOL            fLittleEndian;

    AssertSz(m_fHtml, "Are you sure you want to set stationery in plain-text mode??");

    if (!(m_dwNoteCreateFlags & OENCF_NOSTATIONERY) && m_pMsg &&
        DwGetOption(m_fMail?OPT_MAIL_USESTATIONERY:OPT_NEWS_USESTATIONERY) &&
        SUCCEEDED(GetDefaultStationeryName(m_fMail, wszFile)))
    {
        if (SUCCEEDED(hr = HrCreateBasedWebPage(wszFile, &pstm)))
        {
            if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
            {
                if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
                {
                    m_pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
                }

                ietEncoding = IET_UNICODE;
            }

            hr = m_pMsg->SetTextBody(TXT_HTML, ietEncoding, NULL, pstm, NULL);
            pstm->Release();
            m_fUseStationeryFonts = TRUE;
        }
    }
    return hr;
}

// *************************
HRESULT CNote::CycleThroughControls(BOOL fForward)
{

    HRESULT hr = CheckTabStopArrays();
    if (SUCCEEDED(hr))
    {
        int index, newIndex;
        BOOL fFound = FALSE;
        HWND hCurr = GetFocus();

        for (index = 0; index < m_cTabStopCount; index++)
            if (hCurr == m_pTabStopArray[index])
            {
                fFound = TRUE;
                break;
            }

        newIndex = fFound ? GetNextIndex(index, fForward) : m_iIndexOfBody;

        if (newIndex == m_iIndexOfBody)
            m_pBodyObj2->HrUIActivate(TRUE);
        else       
            SetFocus(m_pTabStopArray[newIndex]);
    }
    return hr;
}

// *************************
HRESULT CNote::CheckTabStopArrays()
{
    HRESULT hr = S_OK;
    if (m_fTabStopsSet)
        return S_OK;

    m_fTabStopsSet = TRUE;
    HWND *pArray = m_pTabStopArray;
    int cCount = MAX_HEADER_COMP;

    hr = m_pHdr->GetTabStopArray(pArray, &cCount);
    if (FAILED(hr))
        goto error;

    pArray += cCount;
    m_cTabStopCount = cCount;
    cCount = MAX_BODY_COMP;

    hr = m_pBodyObj2->GetTabStopArray(pArray, &cCount);
    if (FAILED(hr))
        goto error;

    // This assumes that the first in the list returned from m_pBodyObj2-GetTabStopArray
    // is the Trident window handle. If that changes where it returns more than one 
    // handle, or something else, this simple index scheme won't work
    m_iIndexOfBody = m_cTabStopCount;
    pArray += cCount;
    m_cTabStopCount += cCount;
    cCount = MAX_ATTMAN_COMP;

    m_cTabStopCount += cCount;

    return S_OK;

error:
    m_cTabStopCount = 0;
    m_fTabStopsSet = FALSE;

    return hr;
}

// *************************
int CNote::GetNextIndex(int index, BOOL fForward)
{
    LONG style;
    int cTotalTested = 0;
    BOOL fGoodHandleFound;

    do 
    {
        if (fForward)
        {
            index++;
            if (index >= m_cTabStopCount)
                index = 0;
        }
        else
        {
            // If this is true, other asserts should have fired before now.
            Assert(m_cTabStopCount > 0);
            index--;
            if (index < 0)
                index = m_cTabStopCount - 1;
        }
        style = GetWindowLong(m_pTabStopArray[index], GWL_STYLE);
        cTotalTested++;
        fGoodHandleFound = ((0 == (style & WS_DISABLED)) && 
                            (style & WS_VISIBLE) && 
                            ((style & WS_TABSTOP) || (index == m_iIndexOfBody)));  // Trident doesn't mark itself as a tabstop
    } while (!fGoodHandleFound && (cTotalTested < m_cTabStopCount));

    if (cTotalTested >= m_cTabStopCount)
        index = m_iIndexOfBody;
    return index;
}

// *************************
HRESULT CreateAndShowNote(DWORD dwAction, DWORD dwCreateFlags, INIT_MSGSITE_STRUCT *pInitStruct, 
                          HWND hwnd,      IUnknown *punk, RECT *prc, IOEMsgSite *pMsgSite)
{
    HRESULT hr = S_OK;
    CNote *pNote = NULL;

    AssertSz((pMsgSite || pInitStruct), "Should have either a pInitStruct or a pMsgSite...");

    // If we are coming from news, we might need to pass off this call to the smapi
    // client. If we reply or forward a message that was news, pass it off to smapi
    if ((OENCF_NEWSFIRST & dwCreateFlags) && ((OENA_REPLYTOAUTHOR == dwAction)  || (OENA_FORWARD == dwAction) || (OENA_FORWARDBYATTACH == dwAction)))
    {
        // fIsDefaultMailConfiged hits the reg, only check for last result
        if (!FIsDefaultMailConfiged())
        {
            IOEMsgSite     *pSite = NULL;
            CStoreCB       *pCB = NULL;


            //send using smapi
            if (pInitStruct)
            {
                pCB = new CStoreCB;
                if (!pCB)
                    hr = E_OUTOFMEMORY;

                if (SUCCEEDED(hr))
                    hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsSendingToOutbox), TRUE);

                if (SUCCEEDED(hr))
                    pSite = new COEMsgSite();

                if (!pSite)
                    hr = E_OUTOFMEMORY;

                if (SUCCEEDED(hr))
                    hr = pSite->Init(pInitStruct);

                if (SUCCEEDED(hr))
                    pSite->SetStoreCallback(pCB);
            }
            else
                ReplaceInterface(pSite, pMsgSite);

            if (pSite)
            {
                if (SUCCEEDED(hr))
                {
                    IMimeMessage   *pMsg = NULL;
                    BOOL            fCompleteMsg;
                    HRESULT         hres = E_FAIL;
                    DWORD           dwMsgFlags = (OENA_FORWARDBYATTACH == dwAction) ? (OEGM_ORIGINAL|OEGM_AS_ATTACH) : NOFLAGS;

                    hr = pSite->GetMessage(&pMsg, &fCompleteMsg, dwMsgFlags, &hres);
                    if (E_PENDING == hr)
                    {
                        AssertSz((pCB && pMsgSite), "Should never get E_PENDING with pMsgSite being NULL");
                        pCB->Block();
                        pCB->Close();

                        hr = pSite->GetMessage(&pMsg, &fCompleteMsg, dwMsgFlags, &hres);
                    }
                
                    if (pCB)
                        pCB->Close();

                    if (SUCCEEDED(hr))
                    {
                        if (SUCCEEDED(hres))
                            hr = NewsUtil_ReFwdByMapi(hwnd, pMsg, dwAction);
                        pMsg->Release();
                    }
                }
                // Don't want to close the site if it came from another note...
                if (!pMsgSite)
                    pSite->Close();

                pSite->Release();
            }

            ReleaseObj(pCB);
            // if we succeeded, then we need to tell the creator that we 
            // cancelled the creation through OE and went with the smapi client
            return (FAILED(hr) ? hr : MAPI_E_USER_CANCEL);
        }
    }

    //We are the default smapi client
    pNote = new CNote;
    if (pNote)
        hr = pNote->Init(dwAction, dwCreateFlags, prc, hwnd, pInitStruct, pMsgSite, punk);
    else
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = pNote->Show();

    ReleaseObj(pNote);

    if (FAILED(hr))
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrNewsCantOpen), hr); 
    return hr;
}
// *************************
HRESULT CNote::SaveMessageAs()
{
    HRESULT             hr=S_OK;
    IMimeMessage        *pSecMsg=NULL;
    BOOL                fCanbeDurt = !m_fReadNote;
    PROPVARIANT     rVariant;
    IMimeBody      *pBody = NULL;

    // Raid #25822: we can't just get the message source if it
    // is a secure message
    if (m_fReadNote/* && IsSecure(m_pMsg)*/)
    {
        // Won't care about these since the user already loaded the message
        BOOL    fCompleteMsg = FALSE; 
        HRESULT tempHr = S_OK;
        m_pMsgSite->GetMessage(&pSecMsg, &fCompleteMsg, OEGM_ORIGINAL, &tempHr);

        AssertSz(fCompleteMsg && SUCCEEDED(tempHr), "Shouldn't have reached this point if the load failed now.");
    } 
    else
    {
        hr = CommitChangesInNote();
        if (FAILED(hr))
            goto error;

        // if a compose note, set the X-Unsent header if saving to .eml files, and save the props.
        MimeOleSetBodyPropA(m_pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_XUNSENT), NOFLAGS, "1");

        if(IsSecure(m_pMsg))
        {
            if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                    MAKEINTRESOURCEW(idsSaveSecMsgToFolder), NULL, MB_OKCANCEL) == IDCANCEL)
                goto error;
            else 
            {
                rVariant.vt = VT_BOOL;
                rVariant.boolVal = TRUE;

                hr = m_pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody);
                if(SUCCEEDED(hr))
                {
                    pBody->SetOption(OID_NOSECURITY_ONSAVE, &rVariant);
                    ReleaseObj(pBody);
                }

                fCanbeDurt = FALSE;
            }
        }
        
    }

    // SaveMessageToFile displays a failure error.
    _SetPendingOp(SOT_PUT_MESSAGE);

    hr = HrSaveMessageToFile(m_hwnd, (pSecMsg ? pSecMsg : m_pMsg), m_pMsg, !m_fMail, fCanbeDurt);
    if (SUCCEEDED(hr))
        _OnComplete(SOT_PUT_MESSAGE, S_OK);
    else if (E_PENDING == hr)
    {
        EnableNote(FALSE);
        hr = S_OK;
    }

error:
    ReleaseObj(pSecMsg);
    return hr;
}

// *************************
HRESULT CNote::CommitChangesInNote()
{
    LPMIMEMESSAGE   pMsg=0;
    HRESULT         hr=S_OK;

    Assert(m_pMsg);

    if (!m_fReadNote && !m_fBodyContainsFrames)
    {
        if (FAILED(HrCreateMessage(&pMsg)))
            return E_FAIL;

        hr = Save(pMsg, 0);
        if (SUCCEEDED(hr))
            ReplaceInterface(m_pMsg, pMsg)

        pMsg->Release();
    }

    return hr;
}

// *************************
void CNote::ToggleFormatbar()
{
    m_fFormatbarVisible = !m_fFormatbarVisible;

    SetDwOption(OPT_SHOW_NOTE_FMTBAR, m_fFormatbarVisible, NULL, 0);
    m_pBodyObj2->HrSetStyle(m_fFormatbarVisible ? MESTYLE_FORMATBAR : MESTYLE_NOHEADER);
}

// *************************
void CNote::ToggleStatusbar()
{
    RECT    rc;

    m_fStatusbarVisible = !m_fStatusbarVisible;

    SetDwOption(OPT_SHOW_NOTE_STATUSBAR, m_fStatusbarVisible, NULL, 0);

    m_pstatus->ShowStatus(m_fStatusbarVisible);

    // cause a size
    GetWindowRect(m_hwnd, &rc);
    WMSize(rc.right-rc.left, rc.bottom-rc.top, FALSE);
}

// *************************
HRESULT CNote::ToggleToolbar()
{
    RECT    rc;

    m_fToolbarVisible = !m_fToolbarVisible;

    if (m_pToolbarObj)
        m_pToolbarObj->HideToolbar(!m_fToolbarVisible);

    GetWindowRect(m_hwnd, &rc);
    // cause a size
    WMSize(rc.right-rc.left, rc.bottom-rc.top, FALSE);

    return S_OK;
}

// *************************
void CNote::FormatSettings()
{
    AssertSz(m_fReadNote, "this is broken for readnote!!!");

    if (m_fHtml)
        FGetHTMLOptions(m_hwnd, &m_rHtmlOpt);
    else
        FGetPlainOptions(m_hwnd, &m_rPlainOpt);
}

// *************************
void CNote::SwitchLanguage(int idm)
{
    HCHARSET    hCharset, hOldCharset;
    HRESULT     hr;

    hCharset = GetMimeCharsetFromMenuID(idm);

    if (!hCharset || (hCharset == m_hCharset))
        return;

    hOldCharset = m_hCharset;

    // View|Language in a view does not affect the listview as in v1. It only affect the preview.
    // the user can change his default charset to get changes in the listview
    // setcharset on the body object will cause it to refresh with new fonts etc.
    hr = ChangeCharset(hCharset);
    if (FAILED(hr))
    {
        AthMessageBoxW( m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                        MAKEINTRESOURCEW((hr == hrIncomplete)?idsViewLangMimeDBBad:idsErrViewLanguage), 
                        NULL, MB_OK|MB_ICONEXCLAMATION);
        goto Exit;
    }

    // here after we ask user if he wants to add this change to charset remapping list
    m_pMsgSite->SwitchLanguage(hOldCharset, hCharset);

Exit:
    return;
}

// *************************
BOOL CNote::DoProperties()
{
    NOMSGDATA   noMsgData;
    MSGPROP     msgProp;
    UINT        pri;
    TCHAR       szSubj[256];
    TCHAR       szLocation[1024];
    LPSTR       pszLocation = NULL;
    WCHAR       wszLocation[1024];
    BOOL        fSucceeded;
    
    msgProp.pNoMsgData = &noMsgData;
    msgProp.hwndParent = m_hwnd;
    msgProp.type = (m_fMail ? MSGPROPTYPE_MAIL : MSGPROPTYPE_NEWS);
    msgProp.mpStartPage = MP_GENERAL;
    msgProp.szFolderName = 0;  // This one needs to have special handling
    msgProp.pSecureMsg = NULL;
    msgProp.lpWabal = NULL;
    msgProp.szFolderName = szLocation;
    *szLocation = 0;
    m_pMsgSite->GetLocation(wszLocation, ARRAYSIZE(wszLocation));
    pszLocation = PszToANSI(CP_ACP, wszLocation);
    StrCpyN(szLocation, pszLocation, ARRAYSIZE(szLocation));
    MemFree(pszLocation);
    

    if (m_fReadNote)
    {
        msgProp.dwFlags = ARF_RECEIVED;
        msgProp.pMsg = m_pMsg;
        msgProp.fSecure = IsSecure(msgProp.pMsg);
        if (msgProp.fSecure)
        {
            BOOL    fCompleteMsg = FALSE;
            HRESULT tempHr = S_OK;
            m_pMsgSite->GetMessage(&msgProp.pSecureMsg, &fCompleteMsg, OEGM_ORIGINAL, &tempHr);

            AssertSz(fCompleteMsg && SUCCEEDED(tempHr), "Shouldn't have reached this point if the load failed now.");

            HrGetWabalFromMsg(msgProp.pMsg, &msgProp.lpWabal);
        }
    }
    else
    {
        msgProp.dwFlags = ARF_UNSENT;
        msgProp.pMsg = NULL;
    }

    m_pHdr->GetPriority(&pri);
    if (pri==priLow)
        noMsgData.Pri=IMSG_PRI_LOW;
    else if (pri==priHigh)
        noMsgData.Pri=IMSG_PRI_HIGH;
    else
        noMsgData.Pri=IMSG_PRI_NORMAL;

    noMsgData.pszFrom = NULL;
    noMsgData.pszSent = NULL;

    noMsgData.ulSize = 0;
    noMsgData.cAttachments = 0;
    m_pHdr->HrGetAttachCount(&noMsgData.cAttachments);

    GetWindowText(m_hwnd, szSubj, sizeof(szSubj)/sizeof(TCHAR));
    noMsgData.pszSubject = szSubj;

    msgProp.fFromListView = FALSE;

    fSucceeded = (S_OK == HrMsgProperties(&msgProp));
    ReleaseObj(msgProp.lpWabal);
    ReleaseObj(msgProp.pSecureMsg);

    return fSucceeded;
}

// *************************
HRESULT CNote::HrSendMail(int id)
{
    IImnAccount    *pAccount=NULL;
    ULONG           i;
    BOOL            fFound=FALSE;
    HRESULT         hr;
    BOOL            fSendLater = (id == ID_SEND_LATER);
    VARIANTARG      varIn;
    DWORD           dwMsgSiteFlags=0;

    // Do spell check if needed
    if (FCheckSpellAvail() && FCheckOnSend())
    {
        HWND    hwndFocus=GetFocus();

        hr=m_pBodyObj2->HrSpellCheck(TRUE);
        if (FAILED(hr) || hr==HR_S_SPELLCANCEL)
        {
            if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsSpellMsgSendOK), NULL, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
            {
                SetFocus(hwndFocus);
                return E_FAIL;
            }
        }
    }

    if (!m_fMail && m_pBodyObj2)
    {
        BOOL fEmpty = FALSE;
        if (SUCCEEDED(m_pBodyObj2->HrIsEmpty(&fEmpty)) && fEmpty)
        {
            if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsNoTextInNewsPost), NULL, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
                return MAPI_E_USER_CANCEL;
        }
    }

    // During the send, a call to the note save gets made. During
    // that call, IMimeMessage::Commit gets called. That is a big perf hit.
    // It turns out that commit will get called a second time anyway. So
    // set a flag to tell the save not to commit.
    m_fCommitSave = FALSE;
    hr = HeaderExecCommand(MSOEENVCMDID_SEND, fSendLater?MSOCMDEXECOPT_DODEFAULT:MSOCMDEXECOPT_DONTPROMPTUSER, NULL);
    m_fCommitSave = TRUE;

    // REVIEW: dhaws: I don't think this happens anymore. I think the send call no longer returns the conflict
    //RAID 8780: This message MIME_S_CHARSET_CONFLICT will get propagated to here. Now change it to an E_FAIL;
    if (MIME_S_CHARSET_CONFLICT == hr)
        hr = E_FAIL;
    if (FAILED(hr))
        goto error;

    if (m_pMsgSite)
        m_pMsgSite->GetStatusFlags(&dwMsgSiteFlags);

    // If has been saved, then this note is store based in drafts and
    // need to delete the draft.
    if (((OENA_COMPOSE == m_dwNoteAction) || m_fHasBeenSaved) && !(dwMsgSiteFlags & OEMSF_FROM_FAT))
    {
        HRESULT hr;

        _SetPendingOp(SOT_DELETING_MESSAGES);

        hr = m_pMsgSite->Delete(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT);
        if (SUCCEEDED(hr))
        {
            m_fCBDestroyWindow = TRUE;
            _OnComplete(SOT_DELETING_MESSAGES, S_OK);
        }
        else if (E_PENDING == hr)
        {
            EnableNote(FALSE);
            m_fCBDestroyWindow = TRUE;
        }
        else
        {
            // ~~~ Can we handle this a bit better???
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrDeleteMsg), NULL, MB_OK);
        }
    }
    // If note is reply or forward, then mark the message as appropriate
    else if (IsReplyNote() || (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction))
    {
        HRESULT hr;
        BOOL    fForwarded = (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction);
        // Clear any previous flags so we don't show both, only the most recent 

        m_dwMarkOnReplyForwardState = MORFS_CLEARING;
        hr = MarkMessage(fForwarded ? MARK_MESSAGE_UNREPLIED : MARK_MESSAGE_UNFORWARDED, APPLY_SPECIFIED);
        if (FAILED(hr) && (E_PENDING != hr))
        {
            // Even though we have an error, we can still close the note because the send did work.
            PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
            m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
        }
    }
    // Web Page and stationery
    else
        PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);

error:
    ReleaseObj(pAccount);
    return hr;
}

// *************************
HRESULT CNote::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, IID_IOEMsgSite) &&
        IsEqualGUID(riid, IID_IOEMsgSite))
    {
        if (!m_pMsgSite)
            return E_FAIL;

        *ppvObject = (LPVOID)m_pMsgSite;
        m_pMsgSite->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

// *************************
HRESULT CNote::MarkMessage(MARK_TYPE dwFlags, APPLYCHILDRENTYPE dwApplyType)
{
    HRESULT hr;

    // [PaulHi] 6/8/99  We need to restore the pending operation
    // if the MarkMessage() call fails.
    STOREOPERATIONTYPE  tyPrevOperation = m_OrigOperationType;
    _SetPendingOp(SOT_SET_MESSAGEFLAGS);
    
    hr = m_pMsgSite->MarkMessage(dwFlags, dwApplyType);

    if (SUCCEEDED(hr))
        _OnComplete(SOT_SET_MESSAGEFLAGS, S_OK);
    else if (E_PENDING == hr)
    {
        EnableNote(FALSE);

        EnterCriticalSection(&m_csNoteState);

        if(m_nisNoteState == NIS_INIT)
            m_nisNoteState = NIS_FIXFOCUS;

        LeaveCriticalSection(&m_csNoteState);

        hr = S_OK;
    }
    else
    {
        // Restore previous operation to ensure the note window will be
        // re-enabled.
        _SetPendingOp(tyPrevOperation);
    }

    return hr;
}

HRESULT CNote::_SetPendingOp(STOREOPERATIONTYPE tyOperation)
{
    m_OrigOperationType = tyOperation;
    return S_OK;
}


void CNote::EnableNote(BOOL fEnable)
{
    Assert (IsWindow(m_hwnd));

    m_fInternal = 1;
    if (fEnable)
    {
        if (m_fWindowDisabled)
        {
            EnableWindow(m_hwnd, TRUE);
            if (m_hCursor)
            {
                SetCursor(m_hCursor);
                m_hCursor = 0;
            }
            m_fWindowDisabled = FALSE;
        }
    }
    else
    {
        if (!m_fWindowDisabled)
        {
            m_fWindowDisabled = TRUE;
            EnableWindow(m_hwnd, FALSE);
            m_hCursor = HourGlass();
        }
    }
    m_fInternal = 0;
}

// *************************
void CNote::SetStatusText(LPSTR szBuf)
{
    if(m_pstatus)
        m_pstatus->SetStatusText(szBuf);
}

// *************************
void CNote::SetProgressPct(INT iPct)
{
//    if (m_pstatus)
//        m_pstatus->SetProgressBarPos(1, iPct, FALSE);
}

// *************************
HRESULT CNote::GetBorderDW(IUnknown* punkSrc, LPRECT lprectBorder)
{
    
    GetClientRect(m_hwnd, lprectBorder);
    
    DOUTL(4, "CNote::GetBorderDW called returning=%x,%x,%x,%x",
        lprectBorder->left, lprectBorder->top, lprectBorder->right, lprectBorder->bottom);
    return S_OK;
}

// *************************
HRESULT CNote::RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    DOUTL(4, "CNote::ReqestBorderSpaceST pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    return S_OK;
}

// *************************
HRESULT CNote::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    
    DOUTL(4, "CNote::SetBorderSpaceDW pborderwidths=%x,%x,%x,%x",
          pborderwidths->left, pborderwidths->top, pborderwidths->right, pborderwidths->bottom);
    

    RECT    rcNote = {0};
    GetClientRect(m_hwnd, &rcNote);

    //WMSize(cxRect(rcNote), cyRect(rcNote), FALSE);
    ResizeChildren(cxRect(rcNote), cyRect(rcNote), pborderwidths->top, FALSE);

    return S_OK;
}

// *************************
HRESULT CNote::GetWindow(HWND * lphwnd)                         
{
    *lphwnd = m_hwnd;
    return (m_hwnd ? S_OK : E_FAIL);
}

// *************************
BYTE    CNote::GetNoteType()
{
    BYTE    retval;

    if (m_fReadNote)
        retval = m_fMail ? MailReadNoteType : NewsReadNoteType;
    else
        retval = m_fMail ? MailSendNoteType : NewsSendNoteType;

    return retval;
}

// *************************
HRESULT CNote::IsMenuMessage(MSG *lpmsg)
{
    Assert(m_pToolbarObj);
    if (m_pToolbarObj)
        return m_pToolbarObj->IsMenuMessage(lpmsg);
    else
        return S_FALSE;
}

// *************************
HRESULT CNote::EventOccurred(DWORD nCmdID, IMimeMessage *)
{
    switch (nCmdID)
    {
        case MEHC_CMD_MARK_AS_READ:
            RemoveNewMailIcon();
            MarkMessage(MARK_MESSAGE_READ, APPLY_SPECIFIED);
            break;

        case MEHC_CMD_CONNECT:
            if (g_pConMan)
                g_pConMan->SetGlobalOffline(FALSE);

            ReloadMessageFromSite(TRUE);
            AssertSz(!m_fCBDestroyWindow, "Shouldn't need to destroy the window...");
            break;

        default:
            return S_FALSE;
    }

    return S_OK;
}

// *************************
HRESULT CNote::QuerySwitchIdentities()
{
    IImnAccount *pAcct = NULL;
    DWORD       dwServType;
    HRESULT     hr;

    if (!IsWindowEnabled(m_hwnd))
    {
        Assert(IsWindowVisible(m_hwnd));
        return E_PROCESS_CANCELLED_SWITCH;
    }

    if (IsDirty() != S_FALSE)
    {
        if (FAILED(hr = m_pHdr->HrGetAccountInHeader(&pAcct)))
            goto fail;

        if (FAILED(hr = pAcct->GetServerTypes(&dwServType)))
            goto fail;

        ReleaseObj(pAcct);
        pAcct = NULL;

        SetForegroundWindow(m_hwnd);

        if (!!(dwServType & SRV_POP3) || !!(dwServType & SRV_NNTP))
        {
            if (!FCanClose())
                return E_USER_CANCELLED;
        }
        else
        {
            // IMAP and HTTPMail would have to remote the note, which they
            // can't do at this point, so fail the switch until the window is closed.
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsCantSaveMsg),
                            MAKEINTRESOURCEW(idsNoteCantSwitchIdentity),
                            NULL, MB_OK | MB_ICONEXCLAMATION);
            return E_USER_CANCELLED;
            
        }
    }

    return S_OK;

fail:
    ReleaseObj(pAcct);
    return E_PROCESS_CANCELLED_SWITCH;
}

// *************************
HRESULT CNote::SwitchIdentities()
{
    HRESULT hr;
    
    if (IsDirty() != S_FALSE)
        hr = SaveMessage(OESF_FORCE_LOCAL_DRAFT);
    SendMessage(m_hwnd, WM_CLOSE, 0, 0);

    return S_OK;
}

// *************************
HRESULT CNote::IdentityInformationChanged(DWORD dwType)
{
    return S_OK;
}

// *************************
HRESULT CNote::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, 
                          IOperationCancel *pCancel)
{
    Assert(m_pCancel == NULL);

    if (NULL != pCancel)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    return(S_OK);
}

// *************************
void CNote::ShowErrorScreen(HRESULT hr)
{
    switch (hr)
    {
        case IXP_E_NNTP_ARTICLE_FAILED:
        case STORE_E_EXPIRED:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_Expired);
            break;

        case HR_E_USER_CANCEL_CONNECT:
        case HR_E_OFFLINE:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_Offline);
            SetFocus(m_hwnd);
            break;

        case STG_E_MEDIUMFULL:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_DiskFull);
            break;
            
        case MIME_E_SECURITY_CANTDECRYPT:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_SMimeEncrypt);
            break;

#ifdef SMIME_V3
        case MIME_E_SECURITY_LABELACCESSDENIED:
        case MIME_E_SECURITY_LABELACCESSCANCELLED:
        case MIME_E_SECURITY_LABELCORRUPT:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_SMimeLabel);
            break;
#endif // SMIME_V3

        case MAPI_E_USER_CANCEL:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_DownloadCanceled);
            break;

        default:
            if (m_pBodyObj2)
                m_pBodyObj2->LoadHtmlErrorPage(c_szErrPage_GenFailure);
            break;
    }
    m_fCompleteMsg = FALSE;
}


// *************************
HRESULT CNote::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, 
                             DWORD dwMax, LPCSTR pszStatus)
{
    TCHAR       szRes[CCHMAX_STRINGRES],
                szRes2[CCHMAX_STRINGRES],
                szRes3[CCHMAX_STRINGRES];
    MSG         msg;

    if (m_pstatus && pszStatus)
        m_pstatus->SetStatusText(const_cast<LPSTR>(pszStatus));

    CallbackCloseTimeout(&m_hTimeout);

    switch (tyOperation)
    {
        case SOT_GET_MESSAGE:
            if (m_pstatus)
            {
                if (0 != dwMax)
                {
                    if (!m_fProgress)
                    {
                        m_fProgress = TRUE;
                        m_pstatus->ShowProgress(dwMax);
                    }

                    if (m_pstatus)
                        m_pstatus->SetProgress(dwCurrent);

                    if (!pszStatus)
                    {
                        AthLoadString(idsDownloadingArticle, szRes, ARRAYSIZE(szRes));
                        wnsprintf(szRes2, ARRAYSIZE(szRes2), szRes, (100 * dwCurrent ) / dwMax );
                        m_pstatus->SetStatusText(szRes2);
                    }
                }
                else if (0 != dwCurrent)
                {
                    // dwCurrent is non-zero, but no max has been specified.
                    // This implies that dwCurrent is a byte count.
                    AthLoadString(idsDownloadArtBytes, szRes, ARRAYSIZE(szRes));
                    AthFormatSizeK(dwCurrent, szRes2, ARRAYSIZE(szRes2));
                    wnsprintf(szRes3, ARRAYSIZE(szRes3), szRes, szRes2);
                    m_pstatus->SetStatusText(szRes3);
                }
            }
            break;
    }

    return S_OK;
}

// *************************
HRESULT CNote::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) 
{
    if ((SOT_PUT_MESSAGE == tyOperation) && SUCCEEDED(hrComplete) && pOpInfo && m_pMsgSite)
        m_pMsgSite->UpdateCallbackInfo(pOpInfo);

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    if (m_pstatus)
    {
        if (m_fProgress)
        {
            m_pstatus->HideProgress();
            m_fProgress = FALSE;
        }

        m_pstatus->SetStatusText(const_cast<LPSTR>(c_szEmpty));
    }

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    PostMessage(m_hwnd, WM_OENOTE_ON_COMPLETE, hrComplete, (DWORD)tyOperation);

    // This is not a very neat fix. But, at this time it is a safe fix. 
    // Here is the reason why we can't do it any other place.
    // _OnComplete posts a destroy message to the note window depending on the operation. 
    // To avoid this object from being destroyed before this function returns, the above
    // message is posted. Since there is no way to pass in the error info through PostMessage,
    // we will handle this error here. I am not handling other operation types because some 
    // of them do get handled in _OnComplete
    if (tyOperation == SOT_DELETING_MESSAGES)
    {
        // Display an Error on Failures
        if (FAILED(hrComplete) && hrComplete != HR_E_OFFLINE)
        {
            // Call into my swanky utility
            CallbackDisplayError(m_hwnd, hrComplete, pErrorInfo);
        }

    }
    return S_OK;
}

// *************************
void CNote::_OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete) 
{
    BOOL                fExpectedComplete = TRUE;
    STOREOPERATIONTYPE  tyNewOp = SOT_INVALID;

    m_pMsgSite->OnComplete(tyOperation, hrComplete, &tyNewOp);
    if ((SOT_INVALID != tyNewOp) && (SOT_INVALID != m_OrigOperationType))
        m_OrigOperationType = tyNewOp;

    if (SUCCEEDED(hrComplete))
    {
        switch (tyOperation)
        {
            case SOT_GET_MESSAGE:
                switch (hrComplete)
                {
                case S_OK:
                    ReloadMessageFromSite();
                    AssertSz(!m_fCBDestroyWindow, "Shouldn't need to destroy the window...");
                    break;

                case S_FALSE:
                    // S_FALSE means the operation was canceled
                    ShowErrorScreen(MAPI_E_USER_CANCEL);
                    break;
                }
                break;

            case SOT_PUT_MESSAGE:
                ClearDirtyFlag();
                break;

            case SOT_DELETING_MESSAGES:
                if (!m_fCBDestroyWindow && m_fOrgCmdWasDelete)
                    ReloadMessageFromSite(TRUE);
                m_fOrgCmdWasDelete = FALSE;
                break;

            case SOT_COPYMOVE_MESSAGE:
                if (!m_fCBCopy)
                    ReloadMessageFromSite();
                break;

            case SOT_SET_MESSAGEFLAGS:
                if ((MARK_MAX != m_dwCBMarkType) && m_pHdr)
                {
                    m_pHdr->SetFlagState(m_dwCBMarkType);
                    m_dwCBMarkType = MARK_MAX;
                }

                if (MORFS_UNKNOWN != m_dwMarkOnReplyForwardState)
                {
                    if (MORFS_CLEARING == m_dwMarkOnReplyForwardState)
                    {
                        HRESULT hr;
                        BOOL    fForwarded = (OENA_FORWARD == m_dwNoteAction) || (OENA_FORWARDBYATTACH == m_dwNoteAction);
                        MARK_TYPE dwMarkType = (fForwarded ? MARK_MESSAGE_FORWARDED : MARK_MESSAGE_REPLIED);

                        m_dwMarkOnReplyForwardState = MORFS_SETTING;
                        hr = MarkMessage(dwMarkType, APPLY_SPECIFIED);
                        if (FAILED(hr) && (E_PENDING != hr))
                            m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
                    }
                    else
                    {
                        PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
                        m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
                    }
                }

                // Remove new mail notification icon
                RemoveNewMailIcon();
                break;

            default:
                fExpectedComplete = FALSE;
                break;
        }
    }
    else
    {
        switch (tyOperation)
        {
            case SOT_GET_MESSAGE:
                ShowErrorScreen(hrComplete);
                break;

            case SOT_PUT_MESSAGE:
                if (FAILED(hrComplete))
                {
                    HRESULT hrTemp;

                    // Can't save to remote server for whatever reason. Save to local Drafts instead
                    // First, inform user of the situation, if special folders SHOULD have worked
                    if (STORE_E_NOREMOTESPECIALFLDR != hrComplete)
                    {
                        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena),
                            MAKEINTRESOURCEW(idsForceSaveToLocalDrafts),
                            NULL, MB_OK | MB_ICONEXCLAMATION);
                    }

                    hrTemp = SaveMessage(OESF_FORCE_LOCAL_DRAFT);
                    TraceError(hrTemp);
                }
                break;

            case SOT_SET_MESSAGEFLAGS:
                if (MORFS_UNKNOWN != m_dwMarkOnReplyForwardState)
                    m_dwMarkOnReplyForwardState = MORFS_UNKNOWN;
                break;

            case SOT_DELETING_MESSAGES:
                m_fOrgCmdWasDelete = FALSE;
                break;


            default:
                fExpectedComplete = FALSE;
                break;
        }

    }

    // If the original operation was originated from the note, then
    // we will need to re-enable the note as well as check to see
    // if we need to close the window.
    if (tyOperation == m_OrigOperationType)
    {
        _SetPendingOp(SOT_INVALID);

        EnableNote(TRUE);
        
        EnterCriticalSection(&m_csNoteState);

        if ((tyOperation == SOT_SET_MESSAGEFLAGS) && (m_nisNoteState == NIS_FIXFOCUS))
        {
            if(GetForegroundWindow() == m_hwnd)
                m_pBodyObj2->HrFrameActivate(TRUE);
            else
                m_pBodyObj2->HrGetWindow(&m_hwndFocus);
            m_nisNoteState = NIS_NORMAL;
        }

        LeaveCriticalSection(&m_csNoteState);

        if (!!m_fCBDestroyWindow)
        {
            m_fCBDestroyWindow = FALSE;
            PostMessage(m_hwnd, WM_OE_DESTROYNOTE, 0, 0);
        }
    }
}

// *************************
HRESULT CNote::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{ 
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

// *************************
HRESULT CNote::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{ 
    // Call into general CanConnect Utility
    //return CallbackCanConnect(pszAccountId, m_hwnd, FALSE);
    //Always TRUE will prompt to go online if we are offline, which is what we want to do.
    return CallbackCanConnect(pszAccountId, m_hwnd, TRUE);
}

// *************************
HRESULT CNote::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) 
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwnd, pServer, ixpServerType);
}

// *************************
HRESULT CNote::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

// *************************
HRESULT CNote::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{ 
    *phwndParent = m_hwnd;
    return(S_OK);
}

// *************************
HRESULT CNote::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    HRESULT hr = S_OK;

    // Call into general timeout response utility
    if (NULL != m_pCancel)
        hr = CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);

    return hr;
}

// *************************
HRESULT CNote::CheckCharsetConflict()
{
    return m_fPreventConflictDlg ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\msgsite.h ===
#ifndef _MSGSITE_H
#define _MSGSITE_H

#include "imsgsite.h"

// Current MsgSite Action
// These are the only ones that the msg site worries about.
enum {
    MSA_IDLE = 0,
    MSA_DELETE,
    MSA_COPYMOVE,
    MSA_SAVE,
    MSA_SEND,
    MSA_GET_MESSAGE
};

// CopyMove function used
enum {
    CMF_UNINITED = 0,
    CMF_MSG_TO_FOLDER,
    CMF_TABLE_TO_FOLDER,
    CMF_STORE_TO_FOLDER,
    CMF_FAT_TO_FOLDER,
};

// Original Folder is IMAP state
enum {
    OFIMAP_UNDEFINED = 0,
    OFIMAP_TRUE,
    OFIMAP_FALSE,
};


class COEMsgSite : public IOEMsgSite {
public:

    COEMsgSite();
    ~COEMsgSite();

    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IMsgSite Methods
    virtual HRESULT STDMETHODCALLTYPE Init(INIT_MSGSITE_STRUCT *pInitStruct);
    virtual HRESULT STDMETHODCALLTYPE GetStatusFlags(DWORD *dwflags);
    virtual HRESULT STDMETHODCALLTYPE GetFolderID(FOLDERID *folderID);
    virtual HRESULT STDMETHODCALLTYPE Delete(DELETEMESSAGEFLAGS dwFlags);
    virtual HRESULT STDMETHODCALLTYPE DoNextPrev(BOOL fNext, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE DoCopyMoveToFolder(BOOL fCopy, IMimeMessage *pMsg, BOOL fUnSent);
    virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwflags, IImnAccount *pAcct);

#ifdef SMIME_V3
    virtual HRESULT STDMETHODCALLTYPE SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate, IHeaderSite *pHeaderSite);
#else
    virtual HRESULT STDMETHODCALLTYPE SendToOutbox(IMimeMessage *pMsg, BOOL fSendImmediate);
#endif // SMIME_V3

    virtual HRESULT STDMETHODCALLTYPE MarkMessage(MARK_TYPE dwType, APPLYCHILDRENTYPE dwApplyType);
    virtual HRESULT STDMETHODCALLTYPE GetMessageFlags(MESSAGEFLAGS *pdwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount(ACCTTYPE acctType, IImnAccount **ppAcct);
    virtual HRESULT STDMETHODCALLTYPE GetMessage(IMimeMessage **ppMsg, BOOL *pfCompleteMsg, DWORD dwMessageFlags, HRESULT *phr);
    virtual HRESULT STDMETHODCALLTYPE Close(void);
    virtual HRESULT STDMETHODCALLTYPE SetStoreCallback(IStoreCallback *pStoreCB);
    virtual HRESULT STDMETHODCALLTYPE GetLocation(LPWSTR rgwchLocation, DWORD cchSize);
    virtual HRESULT STDMETHODCALLTYPE SwitchLanguage(HCHARSET hOldCharset, HCHARSET hNewCharset);
    virtual HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, STOREOPERATIONTYPE *ptyNewOp = NULL);
    virtual HRESULT STDMETHODCALLTYPE UpdateCallbackInfo(LPSTOREOPERATIONINFO pOpInfo);
    virtual HRESULT STDMETHODCALLTYPE Notify(DWORD dwNotifyID);

protected:
    HWND GetCallbackHwnd(void);

    void HandlePut(HRESULT hr, STOREOPERATIONTYPE *ptyNewOp);
    void HandleDelete(HRESULT hr);
    void HandleCopyMove(HRESULT hr);
    void HandleGetMessage(HRESULT hr);

    BOOL FCanConnect(void);
    BOOL ThreadingEnabled(void);
    BOOL NeedToSendNews(IMimePropertySet *pPropSet);
    BOOL NeedToSendMail(IMimePropertySet *pPropSet);

    HRESULT LoadMessage(void);
    HRESULT LoadMessageFromFAT(BOOL fOriginal, HRESULT *phr);
    HRESULT LoadMessageFromTable(BOOL fOriginal, HRESULT *phr);
    HRESULT LoadMessageFromStore(void);
    HRESULT LoadMessageFromRow(IMimeMessage **ppMsg, ROWINDEX row);
    HRESULT CreateMsgWithAccountInfo(void);
    HRESULT SetAccountInfo(void);

    HRESULT DoCopyMoveFromFATToFldr(BOOL fUnSent);
    HRESULT DoCopyMoveFromTableToFldr(void);
    HRESULT DoCopyMoveFromStoreToFldr(BOOL fUnSent);
    HRESULT DoCopyMoveFromMsgToFldr(IMimeMessage *pMsg, BOOL fUnSent);

    HRESULT DeleteFromMsgTable(DELETEMESSAGEFLAGS dwFlags);
    HRESULT DeleteFromStore(DELETEMESSAGEFLAGS dwFlags);

#ifdef SMIME_V3
    HRESULT SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail, IHeaderSite *pHeaderSite);
#else
    HRESULT SendMsg(IMimeMessage *pMsg, BOOL fSendImmediately, BOOL fMail);
#endif // SMIME_V3

    HRESULT ClearHeaders(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet);

private:
    BOOL            m_fValidMessage,
                    m_fReloadMessageFlag,
                    m_fNeedToLoadMsg,
                    m_fThreadingEnabled,
                    m_fCBCopy,
                    m_fCBSavedInDrafts,
                    m_fCBSaveInFolderAndDelOrig,
                    m_fGotNewID,
                    m_fHaveCBMessageID,
                    m_fHeaderOnly;
    DWORD           m_dwInitType,
                    m_dwCMFState,
                    m_dwOrigFolderIsImap,
                    m_dwArfFlags,
                    m_dwMSAction;
    ULONG           m_cRef;
    IMimeMessage   *m_pMsg,
                   *m_pOrigMsg;
    IMessageTable  *m_pMsgTable;
    IMessageFolder *m_pCBMsgFolder;
    IMessageFolder *m_pFolderReleaseOnComplete;
    IListSelector  *m_pListSelect;
    IStoreCallback *m_pStoreCB;
    MESSAGEID       m_MessageID,
                    m_CBMessageID,
                    m_NewMessageID;
    FOLDERID        m_FolderID,
                    m_CBFolderID;
    MESSAGEID       m_idBookmark,
                    m_idNewBookmark;
    WCHAR           m_rgwchFileName[MAX_PATH];

    DWORD           m_dwMDNFlags;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\options.h ===
/* *
   * o p t i o n s . h
   * 
   */

#ifndef _OPTIONS_H
#define _OPTIONS_H

//////////////////////////////////////////////////////////////////////////////
//
//  Depends on
//

#ifndef _RICHEDIT_H
#include <richedit.h>
#endif
#include <commdlg.h>
#include <goptions.h>

#ifdef WIN16
#include <mimeole.h>
#endif
// mimeole.h
typedef enum tagENCODINGTYPE ENCODINGTYPE;

//////////////////////////////////////////////////////////////////////////////
//
//  BEGIN
//

#define PORT_CCHMAX         8

#define DOWNLOAD_MAX        10000
#define DOWNLOAD_MIN        10
#define DOWNLOAD_DEFAULT    1000
#define EXPIRE_MAX          100
#define EXPIRE_MIN          1
#define EXPIRE_DEFAULT      5
#define DEFAULT_TIMEOUT     60

enum tagPages {
    PAGE_GEN    = 0x0001,
    PAGE_SEND   = 0x0002,
    PAGE_READ   = 0x0004,
    PAGE_SPELL  = 0x0008,
    PAGE_SEC    = 0x0010,
    PAGE_DIALUP = 0x0020,
    PAGE_ADV    = 0x0040,
    PAGE_SIGS   = 0x0080,
    PAGE_COMPOSE= 0x0100
    };

enum tagStationery {
    PAGE_STATIONERY_MAIL   = 0x0001,
    PAGE_STATIONERY_NEWS   = 0x0002
    };

typedef struct tagOPTPAGES
    {
    DLGPROC pfnDlgProc;
    UINT    uTemplate;
    } OPTPAGES;

typedef struct tagOPTINFO
    {
    IOptionBucketEx *pOpt;
    
    BOOL        fMakeDefaultMail;
    BOOL        fMakeDefaultNews;
    BOOL        fWasSMAPI;
    BOOL        fCanChangeSMAPI;

    BOOL        fMail;

    HIMAGELIST  himl;
    } OPTINFO;

#define ATHENA_OPTIONS  1
#define SPELL_OPTIONS   2

interface IAthenaBrowser;
BOOL ShowOptions(HWND hwndParent, DWORD type, UINT nStartPage, IAthenaBrowser *pBrowser);

BOOL InitOptInfo(DWORD type, OPTINFO **ppoi);
void DeInitOptInfo(OPTINFO *poi);

void InitIndentOptions(CHAR chIndent, HWND hwnd, UINT idCheck, UINT idCombo);

void FillEncodeCombo(HWND hwnd, BOOL fHtml);

void InitCheckCounterFromOptInfo(HWND hwnd, int idCheck, int idEdit, int idSpin, OPTINFO *poi, PROPID opt);
BOOL GetCheckCounter(DWORD *pdw, HWND hwnd, int idCheck, int idEdit, int idSpin);

void ButtonChkFromOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, PROPID opt);
BOOL ButtonChkToOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, ULONG opt);

void FillPollingDialCombo(HWND  hwndPollDialCombo);            

void InitDlgEdit(HWND hwnd, int id, int max, TCHAR *sz);

void InitTimeoutSlider(HWND hwndSlider, HWND hwndText, DWORD dwTimeout);
void SetTimeoutString(HWND hwnd, UINT pos);
DWORD GetTimeoutFromSlider(HWND hwnd);

BOOL ShowStationery(HWND hwndParent, UINT nStartPage);
VOID LoadVCardList(HWND hwndCombo, LPTSTR lpszDisplayName);
BOOL UpdateVCardOptions(HWND hwnd, BOOL fMail, OPTINFO* pmoi);
HRESULT VCardEdit(HWND hwnd, DWORD idc, DWORD idcOther);
HRESULT VCardNewEntry(HWND hwnd);

typedef struct tagHTMLOPT
{
    ENCODINGTYPE    ietEncoding;
    BOOL            f8Bit,
                    fSendImages,
                    fIndentReply;
    ULONG           uWrap;
} 
HTMLOPT, *LPHTMLOPT;

typedef struct tagPLAINOPT
{
    ENCODINGTYPE    ietEncoding;
    BOOL            f8Bit;
    BOOL            fMime;
    ULONG           uWrap;
    CHAR            chQuote;
} 
PLAINOPT, *LPPLAINOPT;

// flags for GetDefaultOptInfo()
#define FMT_MAIL        0x0001
#define FMT_NEWS        0x0002
#define FMT_FORCE_PLAIN 0x0004
#define FMT_FORCE_HTML  0x0008

void GetDefaultOptInfo(LPHTMLOPT prHtmlOpt, LPPLAINOPT prPlainOpt, BOOL *pfHtml, DWORD dwFlags);

void SetPageDirty(OPTINFO *poi, HWND hwnd, DWORD page);
LRESULT InvalidOptionProp(HWND hwndPage, int idcEdit, int idsError, UINT idPage);

BOOL FGetHTMLOptions(HWND hwndParent, LPHTMLOPT pHtmlOpt);
BOOL FGetPlainOptions(HWND hwndParent, LPPLAINOPT pPlainOpt);
BOOL ChangeFontSettings(HWND hwnd);  

INT_PTR CALLBACK PlainSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK HTMLSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK MailStationeryDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewsStationeryDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK StationeryDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, BOOL fMail);
INT_PTR CALLBACK SelectDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK CacheCleanUpDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void DoDefaultClientCheck(HWND hwnd, DWORD dwFlags);
void FreeIcon(HWND hwnd, int idc);

// General Page
INT_PTR CALLBACK GeneralDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    General_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    General_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT General_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Send Page
INT_PTR CALLBACK SendDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Send_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Send_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Send_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Read Page
INT_PTR CALLBACK ReadDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Read_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Read_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Read_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Security Page
INT_PTR CALLBACK SecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Security_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Security_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Security_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Dial Page
INT_PTR CALLBACK DialUpDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Dial_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Dial_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Dial_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Maintenance
INT_PTR CALLBACK MaintenanceDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Maintenance_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Maintenance_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Maintenance_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

// Compose
INT_PTR CALLBACK ComposeDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL    Compose_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    Compose_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Compose_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);

//Receipts
INT_PTR CALLBACK ReceiptsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL Receipts_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void Receipts_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT Receipts_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);


// Test whether or not HTTPMail is enabled (for OE5b2)
BOOL IsHTTPMailEnabled(void);

enum {
    ID_OPTIONS_GENERAL = 0,
    ID_SEND_RECEIEVE,
    ID_DEFAULT_PROGRAMS,
    ID_SENDING,
    ID_MAIL_FORMAT,
    ID_NEWS_FORMAT,
    ID_READING,
    ID_READ_NEWS,
    ID_FONTS,
    ID_SIGNATURES,
    ID_SIG_LIST,
    ID_SIG_EDIT,
    ID_SPELL,
    ID_SPELL_IGNORE,
    ID_LANGUAGE_ICON,
    ID_SECURITY_ZONE,
    ID_SECURE_MAIL,
    ID_CONNECTION,
    ID_CONNECTION_START,
    ID_CONNECTION_INTERNET,
    ID_MAINTENANCE,
    ID_TROUBLESHOOTING,
    ID_FILES,
    ID_STATIONERY_ICON,
    ID_VCARD,
    ID_RECEIPT,
    ID_SEC_RECEIPT,
    ID_MAX
};

#endif //_OPTIONS_H

#if 0
    {IDC_INDENT_CHECK,          IDH_NEWS_SEND_INDENT_WITH},
    {IDC_INDENT_COMBO,          IDH_NEWS_SEND_INDENT_WITH},
    {idcIndentReply,            IDH_NEWS_SEND_INDENT_WITH},
    {idcIndentChar,             IDH_NEWS_SEND_INDENT_WITH},

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\options.cpp ===
/*
*    o p t i o n s . c p p
*
*    Purpose:
*        Implements options propsheets
*
*    Owner:
*        t-anthda.
*        brettm.
*
*    Copyright (C) Microsoft Corp. 1993, 1994.
*/
#include "pch.hxx"
#include <wininet.h>
#include "resource.h"
#include "options.h"
#include "optres.h"
#include <goptions.h>
#include "strconst.h"
#include "mailnews.h"
#include <error.h>
#include "fonts.h"
#include <regutil.h>
#include <secutil.h>
#include <inetreg.h>
#include "mimeutil.h"
#include <ipab.h>
#include "xpcomm.h"
#include "conman.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>
#include <thumb.h>
#include <statnery.h>
#include <url.h>
#include "spell.h"
#include "htmlhelp.h"
#include "shared.h"
#include <sigs.h>
#include "instance.h"
#include <layout.h>
#include "statwiz.h"
#include "storfldr.h"
#include "storutil.h"
#include "cleanup.h"
#include "receipts.h"
#include "demand.h"
#include "multiusr.h"
#include "fontnsc.h"
#include "menuutil.h"

#ifdef SMIME_V3
#include "seclabel.h"
#endif // SMIME_V3

ASSERTDATA

#define MAX_SHOWNAME    25
#define DEFAULT_FONTPIXELSIZE 9

#define SZ_REGKEY_AUTODISCOVERY                 TEXT("SOFTWARE\\Microsoft\\Outlook Express\\5.0")
#define SZ_REGKEY_AUTODISCOVERY_POLICY          TEXT("SOFTWARE\\Policies\\Microsoft\\Windows")

#define SZ_REGVALUE_AUTODISCOVERY               TEXT("AutoDiscovery")
#define SZ_REGVALUE_AUTODISCOVERY_POLICY        TEXT("AutoDiscovery Policy")



void SendTridentOptionsChange();
INT_PTR CALLBACK AdvSecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK FChooseFontHookProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FGetAdvSecOptions(HWND hwndParent, OPTINFO *opie);

#ifdef SMIME_V3
BOOL FGetSecLabel(HWND hwndParent, OPTINFO *opie);
BOOL FGetSecRecOptions(HWND hwndParent, OPTINFO *opie);
INT_PTR CALLBACK SecurityReceiptDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
#endif // SMIME_V3

LRESULT CALLBACK FontSampleSubProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

void HtmlOptFromMailOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void MailOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);
void PlainOptFromMailOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);
void MailOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void PaintFontSample(HWND hwnd, HDC hdc, OPTINFO *poi);
void EnableStationeryWindows(HWND hwnd);
void _SetThisStationery(HWND hwnd, BOOL fMail, LPWSTR pwsz, OPTINFO* pmoi);

enum {
    SAMPLE_MAIL = 0,
    SAMPLE_NEWS = 1
};

void _SetComposeFontSample(HWND hwndDlg, DWORD dwType, OPTINFO *pmoi);

void NewsOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);
void NewsOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void HtmlOptFromNewsOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi);
void PlainOptFromNewsOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi);

BOOL AdvSec_GetEncryptWarnCombo(HWND hwnd, OPTINFO *poi);
BOOL AdvSec_FillEncWarnCombo(HWND hwnd, OPTINFO *poi);

BOOL ChangeSendFontSettings(OPTINFO *pmoi, BOOL fMail, HWND hwnd);

void FreeIcon(HWND hwnd, int idc);

WCHAR g_wszNewsStationery[MAX_PATH];
WCHAR g_wszMailStationery[MAX_PATH];

const OPTPAGES c_rgOptPages[] =
{
    { GeneralDlgProc,               iddOpt_General },
    { ReadDlgProc,                  iddOpt_Read },
    { ReceiptsDlgProc,              iddOpt_Receipts },
    { SendDlgProc,                  iddOpt_Send },
    { ComposeDlgProc,               iddOpt_Compose },
    { SigDlgProc,                   iddOpt_Signature },
    { SpellingPageProc,             iddOpt_Spelling },
    { SecurityDlgProc,              iddOpt_Security },
    { DialUpDlgProc,                iddOpt_DialUp },
    { MaintenanceDlgProc,           iddOpt_Advanced }
};

TCHAR   szDialAlways[CCHMAX_STRINGRES];
TCHAR   szDialIfNotOffline[CCHMAX_STRINGRES];
TCHAR   szDoNotDial[CCHMAX_STRINGRES];

//These static won't hurt switching identities because they need not be initialized when switching the
//identities. These need to be persistent across identities.
static  BOOL    fRasInstalled = FALSE;

BOOL    IsRasInstalled()
{
    //These static won't hurt switching identities because they need not be initialized when switching the
    //identities. These need to be persistent across identities.
    static          BOOL    fCheckedRasInstalled = FALSE;
    
    if (!fCheckedRasInstalled)
    {
        if (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            // Check Win9x key
            char    szSmall[3]; // there should be a "1" or a "0" only
            DWORD   cb;
            HKEY    hkey;
            long    lRes;
            
            lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RNACOMPONENT,
                NULL, KEY_READ, &hkey);
            if(ERROR_SUCCESS == lRes) 
            {
                cb = sizeof(szSmall);
                //  REGSTR_VAL_RNAINSTALLED is defined with TEXT() macro so
                //  if wininet is ever compiled unicode this will be a compile
                //  error.
                lRes = RegQueryValueExA(hkey, REGSTR_VAL_RNAINSTALLED, NULL,
                    NULL, (LPBYTE)szSmall, &cb);
                if(ERROR_SUCCESS == lRes) {
                    if((szSmall[0] == '1') && (szSmall[1] == 0)) {
                        // 1 means ras installed
                        fRasInstalled = TRUE;
                    }
                }
                RegCloseKey(hkey);
            }
        }
        else if (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            // Ask NT service manager if RemoteAccess service is installed
            //
            SC_HANDLE hscm;
            
            hscm = OpenSCManager(NULL, NULL, GENERIC_READ);
            /*
            if(hscm)
            {
            SC_HANDLE hras;
            
              hras = OpenService(hscm, TEXT("RemoteAccess"), GENERIC_READ);
              if(hras)
              {
              // service exists - ras is installed
              fRasInstalled = TRUE;
              
                CloseServiceHandle(hras);
                }
                
                  CloseServiceHandle(hscm);
                  }
            */
            if(hscm)
            {
                SC_HANDLE hras;
                ENUM_SERVICE_STATUS essServices[16];
                DWORD dwError, dwResume = 0, i;
                DWORD cbNeeded = 1, csReturned;
                
                while(FALSE == fRasInstalled && cbNeeded > 0)
                {
                    // Get the next chunk of services
                    dwError = 0;
                    if(FALSE == EnumServicesStatus(hscm, SERVICE_WIN32, SERVICE_ACTIVE,
                        essServices, sizeof(essServices), &cbNeeded, &csReturned,
                        &dwResume))
                    {
                        dwError = GetLastError();
                    }
                    
                    if(dwError && dwError != ERROR_MORE_DATA)
                    {
                        // unknown error - bail
                        break;
                    }
                    
                    for(i=0; i<csReturned; i++)
                    {
                        if(0 == lstrcmp(essServices[i].lpServiceName, TEXT("RasMan")))
                        {
                            // service exists. RAS is installed.
                            fRasInstalled = TRUE;
                            break;
                        }
                    }
                }
                
                CloseServiceHandle(hscm);
            }
        }
        fCheckedRasInstalled = TRUE;
        
    }
    return fRasInstalled;
}

BOOL InitOptInfo(DWORD type, OPTINFO **ppoi)
{
    BOOL fRet;
    OPTINFO *poi;
    
    Assert(type == ATHENA_OPTIONS || type == SPELL_OPTIONS);
    Assert(ppoi != NULL);
    
    fRet = FALSE;
    *ppoi = NULL;
    
    if (!MemAlloc((void **)&poi, sizeof(OPTINFO)))
        return(FALSE);
    
    ZeroMemory(poi, sizeof(OPTINFO));

    poi->himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbOptions), 32, 0,
                                    RGB(255, 0, 255));
    Assert(poi->himl);
    
    // TODO: we may want to make a copy of g_pOptBcktEx and use that instead?????
    
    Assert(g_pOpt != NULL);
    poi->pOpt = g_pOpt;
    poi->pOpt->AddRef();
    // poi->pOpt->EnableNotification(FALSE);
    fRet = TRUE;
    
    if (!fRet)
    {
        DeInitOptInfo(poi);
        poi = NULL;
    }
    
    *ppoi = poi;
    
    return(fRet);
}

void DeInitOptInfo(OPTINFO *poi)
{
    Assert(poi != NULL);

    if (poi->himl)
    {
        ImageList_Destroy(poi->himl);
    }
    
    if (poi->pOpt != NULL)
    {
        // poi->pOpt->EnableNotification(TRUE);
        poi->pOpt->Release();
    }
    
    MemFree(poi);
}


BOOL ShowOptions(HWND hwndParent, DWORD type, UINT nStartPage, IAthenaBrowser *pBrowser)
{
    LPARAM              lParam;
    PROPSHEETHEADERW    psh;
    OPTINFO            *poi;
    int                 i, 
                        cPage;
    OPTPAGES           *pPages;
    BOOL                fRet;
    PROPSHEETPAGEW     *ppsp, 
                        psp[ARRAYSIZE(c_rgOptPages)];
    
    Assert(type == ATHENA_OPTIONS || type == SPELL_OPTIONS);
    
    if (!InitOptInfo(type, &poi))
        return(FALSE);
    
    fRet = FALSE;
    
    pPages = (OPTPAGES *)c_rgOptPages;
    cPage = ARRAYSIZE(c_rgOptPages);
    
    psh.nPages = 0;
    
    // Fill out the PROPSHEETPAGE structs
    for (i = 0, ppsp = psp; i < cPage; i++, pPages++)
    {
        lParam = (LPARAM)poi;
        
        if (pPages->uTemplate == iddOpt_Spelling)
        {
            if (!FCheckSpellAvail())
                continue;

            if (type == SPELL_OPTIONS)
                nStartPage = psh.nPages;
        }
        else if (pPages->uTemplate == iddViewLayout)
        {
            if (pBrowser == NULL)
                continue;
            lParam = (LPARAM)pBrowser;
        }
        
        ppsp->dwSize        = sizeof(*ppsp);
        ppsp->dwFlags       = PSP_DEFAULT;
        ppsp->hInstance = g_hLocRes;
        ppsp->pszTemplate   = MAKEINTRESOURCEW(pPages->uTemplate);
        ppsp->pszIcon       = 0;
        ppsp->pfnDlgProc    = pPages->pfnDlgProc;
        ppsp->pszTitle      = 0;
        ppsp->lParam        = lParam;
        ppsp->pfnCallback   = NULL;
        
        psh.nPages++;
        ppsp++;
    }
    
    // Adjust start page if greater than number of pages
    if ((int)nStartPage > psh.nPages)
    {
        AssertSz(FALSE, "Start page is too high.");
        nStartPage = 0;
    }
    
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_USEICONID | PSH_USEPAGELANG;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hLocRes;
    psh.pszCaption = MAKEINTRESOURCEW(idsOptions);
    psh.nStartPage = nStartPage;
    psh.pszIcon = MAKEINTRESOURCEW(idiMailNews);
    psh.ppsp = (LPCPROPSHEETPAGEW)&psp;
    
    if (-1 != PropertySheetW(&psh))
        fRet = TRUE;
    
    DeInitOptInfo(poi);
    
    return(fRet);
}

void InitDlgEdit(HWND hwnd, int id, int max, TCHAR *sz)
{
    HWND hwndT;
    
    hwndT = GetDlgItem(hwnd, id);
    Edit_LimitText(hwndT, max);
    if (sz != NULL)
        Edit_SetText(hwndT, sz);
}

void InitCheckCounterFromOptInfo(HWND hwnd, int idcCheck, int idcEdit, int idcSpin, OPTINFO *poi, PROPID id)
{
    BOOL f;
    int digit;
    DWORD dw;
    HRESULT hr;
    PROPINFO info;
    
    Assert(poi != NULL);
    Assert(idcEdit != 0);
    Assert(idcSpin != 0);
    
    info.cbSize = sizeof(PROPINFO);
    hr = poi->pOpt->GetPropertyInfo(id, &info, 0);
    Assert(hr == S_OK);
    Assert(info.vt == VT_UI4);
    
    dw = IDwGetOption(poi->pOpt, id);
    f = (dw != OPTION_OFF);
    if (!f)
        dw = IDwGetOptionDefault(poi->pOpt, id);
    
    Assert(info.uMin <= (int)dw);
    Assert(info.uMax >= (int)dw);
    
    if (id == OPT_POLLFORMSGS)
    {
        // convert to minutes from millisecs
        dw = dw / (60 * 1000);
        info.uMin = info.uMin / (60 * 1000);
        info.uMax = info.uMax / (60 * 1000);
    }
    
    if (idcCheck != 0)
    {
        CheckDlgButton(hwnd, idcCheck, f ? BST_CHECKED : BST_UNCHECKED);
    }
    else
    {
        Assert(f);
    }
    SendDlgItemMessage(hwnd, idcSpin, UDM_SETRANGE, 0, MAKELONG(info.uMax, info.uMin));
    
    digit = 1;
    while (info.uMax >= 10)
    {
        info.uMax = info.uMax / 10;
        digit++;
    }
    SendDlgItemMessage(hwnd, idcEdit, EM_LIMITTEXT, (WPARAM)digit, 0);
    
    SetDlgItemInt(hwnd, idcEdit, dw, FALSE);
    EnableWindow(GetDlgItem(hwnd, idcEdit), f);
    EnableWindow(GetDlgItem(hwnd, idcSpin), f);
}

BOOL GetCheckCounter(DWORD *pdw, HWND hwnd, int idcCheck, int idcEdit, int idcSpin)
{
    BOOL f, fRet;
    DWORD dw, range;
    
    f = (idcCheck == 0 || IsDlgButtonChecked(hwnd, idcCheck) == BST_CHECKED);
    if (!f)
    {
        dw = OPTION_OFF;
        fRet = TRUE;
    }
    else
    {
        dw = GetDlgItemInt(hwnd, idcEdit, &fRet, FALSE);
        if (fRet)
        {
            range = (DWORD) SendDlgItemMessage(hwnd, idcSpin, UDM_GETRANGE, 0, 0);
            if (dw < HIWORD(range) || dw > LOWORD(range))
                fRet = FALSE;
        }
    }
    
    *pdw = dw;
    
    return(fRet);
}

void SetPageDirty(OPTINFO *poi, HWND hwnd, DWORD page)
{
    Assert(poi != NULL);
    
    PropSheet_Changed(GetParent(hwnd), hwnd);
}


/////////////////////////////////////////////////////////////////////////////
// General Tab 
//

static const HELPMAP g_rgCtxMapMailGeneral[] = {
    {IDC_LAUNCH_INBOX,          IDH_OPTIONS_GO_TO_INBOX},
    {IDC_NOTIFY_NEW_GROUPS,     IDH_NEWS_OPT_READ_NOTIFY_NEW_NEWS},
    {IDC_SOUND_CHECK,           IDH_MAIL_OPT_READ_PLYSND},
    {IDC_AUTOCHECK_EDIT,        IDH_MAIL_OPT_READ_CHECK_4NEW},
    {IDC_AUTOCHECK_SPIN,        IDH_MAIL_OPT_READ_CHECK_4NEW},
    {IDC_AUTOCHECK_CHECK,       IDH_MAIL_OPT_READ_CHECK_4NEW},
    {IDC_MAILHANDSTAT,          IDH_MAIL_SEND_IM_DEFAULT},
    {IDC_DEFMAIL,               IDH_MAIL_SEND_IM_DEFAULT},
    {IDC_NEWSHANDSTAT,          IDH_NEWS_OPT_READ_DEFAULT},
    {IDC_DEFNEWS,               IDH_NEWS_OPT_READ_DEFAULT},
    {IDC_EXPANDUNREAD_CHECK,    502000},
    {IDC_POLLING_DIAL_OPTIONS,  25252507},
    {IDC_BUDDYLIST_CHECK,       502004},
    {IDC_SEND_RECEIVE_ON_START, 502005},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_GENERAL_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEND_RECEIVE_ICON,     IDH_NEWS_COMM_GROUPBOX},
    {IDC_DEFAULT_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};

INT_PTR CALLBACK GeneralDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, General_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailGeneral);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, General_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, General_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_GENERAL_ICON);
            FreeIcon(hwnd, IDC_SEND_RECEIVE_ICON);
            FreeIcon(hwnd, IDC_DEFAULT_ICON);
            return (TRUE);
    }
        
    return(FALSE);
}

void FillPollingDialCombo(HWND hwndPollDialCombo,     OPTINFO     *pmoi)            
{
    DWORD       dw;
    UINT        iSel;

    LoadString(g_hLocRes, idsDoNotDial, szDoNotDial, ARRAYSIZE(szDoNotDial));
    ComboBox_AddString(hwndPollDialCombo, szDoNotDial);

    LoadString(g_hLocRes, idsDialIfNotOffline, szDialIfNotOffline, ARRAYSIZE(szDialIfNotOffline));
    ComboBox_AddString(hwndPollDialCombo, szDialIfNotOffline);

    LoadString(g_hLocRes, idsDialAlways, szDialAlways, ARRAYSIZE(szDialAlways));
    GetLastError();
    ComboBox_AddString(hwndPollDialCombo, szDialAlways);

    

    dw = IDwGetOption(pmoi->pOpt, OPT_DIAL_DURING_POLL);
    switch (dw)
    {
    case DIAL_ALWAYS:
        iSel = ComboBox_FindStringExact(hwndPollDialCombo, -1, szDialAlways);
        break;

    case DIAL_IF_NOT_OFFLINE:
        iSel = ComboBox_FindStringExact(hwndPollDialCombo, -1, szDialIfNotOffline);
        break;

    case DO_NOT_DIAL:
    default:
        iSel = ComboBox_FindStringExact(hwndPollDialCombo, -1, szDoNotDial);
        break;
    }

    ComboBox_SetCurSel(hwndPollDialCombo, iSel);

}

//
//  FUNCTION:   General_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the General Tab on the options
//              property sheet.
//
BOOL General_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi = 0;
    TCHAR    szRes[CCHMAX_STRINGRES] = "";
    BOOL     fEnable = FALSE;
    DWORD    id;
    DWORD    dw;
    HWND     hwndPollDialCombo;

    // Get the passed in options pointer
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    // Set the check boxes and counters
    ButtonChkFromOptInfo(hwnd, IDC_LAUNCH_INBOX, pmoi, OPT_LAUNCH_INBOX);
    ButtonChkFromOptInfo(hwnd, IDC_NOTIFY_NEW_GROUPS, pmoi, OPT_NOTIFYGROUPS);
    ButtonChkFromOptInfo(hwnd, IDC_EXPANDUNREAD_CHECK, pmoi, OPT_EXPAND_UNREAD);
    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
        ShowWindow(GetDlgItem(hwnd, IDC_BUDDYLIST_CHECK), SW_HIDE);
    else
    {
        GetDlgItemText(hwnd, IDC_BUDDYLIST_CHECK, szRes, CCHMAX_STRINGRES);
        MenuUtil_BuildMessengerString(szRes, ARRAYSIZE(szRes));
        SetDlgItemText(hwnd, IDC_BUDDYLIST_CHECK, szRes);

        ButtonChkFromOptInfo(hwnd, IDC_BUDDYLIST_CHECK, pmoi, OPT_BUDDYLIST_CHECK);
    }
    
    ButtonChkFromOptInfo(hwnd, IDC_SOUND_CHECK, pmoi, OPT_NEWMAILSOUND);
    
    ButtonChkFromOptInfo(hwnd, IDC_SEND_RECEIVE_ON_START, pmoi, OPT_POLLFORMSGS_ATSTARTUP);

    InitCheckCounterFromOptInfo(hwnd, IDC_AUTOCHECK_CHECK, IDC_AUTOCHECK_EDIT, IDC_AUTOCHECK_SPIN,
                                pmoi, OPT_POLLFORMSGS);
    fEnable = (IsDlgButtonChecked(hwnd, IDC_AUTOCHECK_CHECK) == BST_CHECKED);
    
    hwndPollDialCombo = GetDlgItem(hwnd, IDC_POLLING_DIAL_OPTIONS);
    EnableWindow(hwndPollDialCombo, fEnable);
    
    //Fill the combo box and select the right option
    FillPollingDialCombo(hwndPollDialCombo, pmoi);        
        
    // Check to see if we're the default mail handler
    if (FIsDefaultMailConfiged())
    {
        LoadString(g_hLocRes, idsCurrentlyDefMail, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), FALSE);
    }
    else
    {
        LoadString(g_hLocRes, idsNotDefMail, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), TRUE);
    }
    SetWindowText(GetDlgItem(hwnd, IDC_MAILHANDSTAT), szRes);

    // In news only mode...
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_MAILHANDSTAT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), FALSE);

        // Hide other mail options
        EnableWindow(GetDlgItem(hwnd, IDC_SOUND_CHECK), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_LAUNCH_INBOX), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_BUDDYLIST_CHECK), FALSE);
        
    }
    
    // Check to see if we're the default news handler
    szRes[0] = 0;
    if (FIsDefaultNewsConfiged(g_dwAthenaMode & MODE_OUTLOOKNEWS ? DEFAULT_OUTNEWS : 0))
    {
        LoadString(g_hLocRes, idsCurrentlyDefNews, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFNEWS), FALSE);
    }
    else
    {
        LoadString(g_hLocRes, idsNotDefNews, szRes, ARRAYSIZE(szRes));
        EnableWindow(GetDlgItem(hwnd, IDC_DEFNEWS), TRUE);
    }
    SetWindowText(GetDlgItem(hwnd, IDC_NEWSHANDSTAT), szRes);    
    
    // Default to taking no action
    pmoi->fMakeDefaultMail = pmoi->fMakeDefaultNews = FALSE;

    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_OPTIONS_GENERAL, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_GENERAL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_SEND_RECEIEVE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SEND_RECEIVE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_DEFAULT_PROGRAMS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_DEFAULT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    // Stash the pointer
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


//
//  FUNCTION:   General_OnCommand()
//
//  PURPOSE:    Command handler for the General tab on the Options
//              property sheet.
//
void General_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    BOOL     f;
    TCHAR    szRes[CCHMAX_STRINGRES];

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    switch (id)
    {
        case IDC_AUTOCHECK_CHECK:
            if (codeNotify == BN_CLICKED)
            {
                f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_AUTOCHECK_EDIT), f);
                EnableWindow(GetDlgItem(hwnd, IDC_AUTOCHECK_SPIN), f);
    
                EnableWindow(GetDlgItem(hwnd, IDC_POLLING_DIAL_OPTIONS), f);

                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            }
            break;

        case IDC_POLLING_DIAL_OPTIONS:
            if (codeNotify == CBN_SELENDOK)
                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            break;

        case IDC_AUTOCHECK_EDIT:
            if (codeNotify == EN_CHANGE)
                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            break;
                
        case IDC_SEND_RECEIVE_ON_START:
        case IDC_SOUND_CHECK:
        case IDC_NOTIFY_NEW_GROUPS:
        case IDC_LAUNCH_INBOX:
        case IDC_EXPANDUNREAD_CHECK:
        case IDC_BUDDYLIST_CHECK:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_GEN);
            break;
                
        case IDC_DEFMAIL:
            szRes[0] = 0;
            LoadString(g_hLocRes, idsCurrentlyDefMail, szRes, ARRAYSIZE(szRes));
            SetWindowText(GetDlgItem(hwnd, IDC_MAILHANDSTAT), szRes);
            EnableWindow(GetDlgItem(hwnd, IDC_DEFMAIL), FALSE);
            SetPageDirty(pmoi, hwnd, PAGE_GEN);
            pmoi->fMakeDefaultMail = TRUE;
            break;
        
        case IDC_DEFNEWS:
            szRes[0] = 0;
            LoadString(g_hLocRes, idsCurrentlyDefNews, szRes, ARRAYSIZE(szRes));
            SetWindowText(GetDlgItem(hwnd, IDC_NEWSHANDSTAT), szRes);
            EnableWindow(GetDlgItem(hwnd, IDC_DEFNEWS), FALSE);
            SetPageDirty(pmoi, hwnd, PAGE_GEN);
            pmoi->fMakeDefaultNews = TRUE;
            break;
    }                
}


//
//  FUNCTION:   General_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the General Tab.
//
LRESULT General_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    OPTINFO *pmoi = 0;
    BOOL     f;
    DWORD    dw;
    HWND     hwndCombo;
    TCHAR    szEntryName[CCHMAX_STRINGRES];
    UINT     iSel;

    // The only notification we care about is Apply
    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        if (pmoi == NULL)
            return (PSNRET_INVALID_NOCHANGEPAGE);
                    
        // General options
        ButtonChkToOptInfo(hwnd, IDC_LAUNCH_INBOX, pmoi, OPT_LAUNCH_INBOX);
        ButtonChkToOptInfo(hwnd, IDC_NOTIFY_NEW_GROUPS, pmoi, OPT_NOTIFYGROUPS);
        ButtonChkToOptInfo(hwnd, IDC_EXPANDUNREAD_CHECK, pmoi, OPT_EXPAND_UNREAD);
        if (!((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE)))
            ButtonChkToOptInfo(hwnd, IDC_BUDDYLIST_CHECK, pmoi, OPT_BUDDYLIST_CHECK);

        // Send / Receive options
        ButtonChkToOptInfo(hwnd, IDC_SOUND_CHECK, pmoi, OPT_NEWMAILSOUND);
        if (!GetCheckCounter(&dw, hwnd, IDC_AUTOCHECK_CHECK, IDC_AUTOCHECK_EDIT, IDC_AUTOCHECK_SPIN))
            return(InvalidOptionProp(hwnd, IDC_AUTOCHECK_EDIT, idsEnterPollTime, iddOpt_General));
    
        if (dw != OPTION_OFF)
            dw = dw * 60 * 1000;
        ISetDwOption(pmoi->pOpt, OPT_POLLFORMSGS, dw, NULL, 0);

        hwndCombo = GetDlgItem(hwnd, IDC_POLLING_DIAL_OPTIONS);
        iSel = ComboBox_GetCurSel(hwndCombo);
        
        if (iSel != CB_ERR)
        {
            ComboBox_GetLBText(hwndCombo, iSel, szEntryName);
            if (lstrcmp(szDialAlways, szEntryName) == 0)
                dw = DIAL_ALWAYS;
            else 
            if (lstrcmp(szDialIfNotOffline, szEntryName) == 0)
                dw = DIAL_IF_NOT_OFFLINE;
            else
                dw = DO_NOT_DIAL;
        }

        ISetDwOption(pmoi->pOpt, OPT_DIAL_DURING_POLL, dw, NULL, 0);

        ButtonChkToOptInfo(hwnd, IDC_SEND_RECEIVE_ON_START, pmoi, OPT_POLLFORMSGS_ATSTARTUP);

        // Default client                    
        if (pmoi->fMakeDefaultMail)
            SetDefaultMailHandler(0);
    
        if (pmoi->fMakeDefaultNews)
            SetDefaultNewsHandler(g_dwAthenaMode & MODE_OUTLOOKNEWS ? DEFAULT_OUTNEWS : 0);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }
    
    return (FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Send Page
//

const static HELPMAP g_rgCtxMapSendMail[] = 
{
    {IDC_SAVE_CHECK,            IDH_MAIL_SEND_SAVE_COPY},
    {IDC_SENDIMMEDIATE_CHECK,   IDH_NEWSMAIL_SEND_ADVSET_SEND_IMMED},
    {IDC_AUTOWAB_CHECK,         IDH_OPTIONS_ADD_REPLIES},
    {IDC_INCLUDE_CHECK,         IDH_NEWS_SEND_MESS_IN_REPLY},
    {IDC_REPLY_IN_ORIGFMT,      IDH_OPTIONS_REPLY_USING_SENT_FORMAT},
    {idrbMailHTML,              IDH_SEND_HTML},
    {idrbMailPlain,             IDH_SEND_PLAINTEXT},
    {idbtnMailHTML,             353718},
    {idbtnMailPlain,            IDH_SEND_SETTINGS},
    {idrbNewsHTML,              IDH_SEND_HTML},
    {idrbNewsPlain,             IDH_SEND_PLAINTEXT},
    {idbtnNewsHTML,             353718},
    {idbtnNewsPlain,            IDH_SEND_SETTINGS},
    {idbtnSendIntl,             IDH_SEND_SETTINGS},
    {IDC_USEAUTOCOMPLETE_CHECK, 502065},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_MAILFORMAT_GROUP,      IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEND_ICON,             IDH_NEWS_COMM_GROUPBOX},
    {IDC_MAIL_FORMAT_ICON,      IDH_NEWS_COMM_GROUPBOX},
    {IDC_NEWS_FORMAT_ICON,      IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
        
INT_PTR CALLBACK SendDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Send_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapSendMail);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Send_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Send_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_SEND_ICON);
            FreeIcon(hwnd, IDC_MAIL_FORMAT_ICON);
            FreeIcon(hwnd, IDC_NEWS_FORMAT_ICON);
            return (TRUE);
    }
    
    return (FALSE);
}


//
//  FUNCTION:   Send_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Send Tab on the options
//              property sheet.
//
BOOL Send_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi = 0;
    DWORD    dw;
    
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    // Send Options
    ButtonChkFromOptInfo(hwnd, IDC_SAVE_CHECK, pmoi, OPT_SAVESENTMSGS);
    ButtonChkFromOptInfo(hwnd, IDC_SENDIMMEDIATE_CHECK, pmoi, OPT_SENDIMMEDIATE);
    ButtonChkFromOptInfo(hwnd, IDC_AUTOWAB_CHECK, pmoi, OPT_MAIL_AUTOADDTOWABONREPLY);
    ButtonChkFromOptInfo(hwnd, IDC_USEAUTOCOMPLETE_CHECK, pmoi, OPT_USEAUTOCOMPLETE);
    ButtonChkFromOptInfo(hwnd, IDC_INCLUDE_CHECK, pmoi, OPT_INCLUDEMSG);
    ButtonChkFromOptInfo(hwnd, IDC_REPLY_IN_ORIGFMT, pmoi, OPT_REPLYINORIGFMT);

    // Mail Format
    dw = IDwGetOption(pmoi->pOpt, OPT_MAIL_SEND_HTML);
    CheckDlgButton(hwnd, dw ? idrbMailHTML : idrbMailPlain, BST_CHECKED);
    
    // News Format
    dw = IDwGetOption(pmoi->pOpt, OPT_NEWS_SEND_HTML);
    CheckDlgButton(hwnd, dw ? idrbNewsHTML : idrbNewsPlain, BST_CHECKED);
        
    // Hide these controls in news-only mode
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_MAILFORMAT_GROUP), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAILFORMAT_STATIC), FALSE);
        EnableWindow(GetDlgItem(hwnd, idrbMailHTML), FALSE);
        EnableWindow(GetDlgItem(hwnd, idrbMailPlain), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnMailHTML), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnMailPlain), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic4), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_FORMAT_ICON), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnSendIntl), FALSE);

        EnableWindow(GetDlgItem(hwnd, IDC_AUTOWAB_CHECK), FALSE);
    }
    
    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_SENDING, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SEND_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_MAIL_FORMAT, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_MAIL_FORMAT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_NEWS_FORMAT, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_NEWS_FORMAT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


//
//  FUNCTION:   Send_OnCommand()
//
//  PURPOSE:    Command handler for the Send tab on the Options
//              property sheet.
//
void Send_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    HTMLOPT  rHtmlOpt;
    PLAINOPT rPlainOpt;

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    switch (id)
    {
        case IDC_SAVE_CHECK:
        case IDC_SENDIMMEDIATE_CHECK:
        case IDC_AUTOWAB_CHECK:
        case IDC_USEAUTOCOMPLETE_CHECK:
        case IDC_INCLUDE_CHECK:
        case IDC_REPLY_IN_ORIGFMT:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_SEND);
            break;

        case idbtnMailHTML:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rHtmlOpt, sizeof(rHtmlOpt));
                HtmlOptFromMailOpt(&rHtmlOpt, pmoi);
                if(FGetHTMLOptions(hwnd, &rHtmlOpt))
                {
                    MailOptFromHtmlOpt(&rHtmlOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;

        case idbtnSendIntl:
            if (codeNotify == BN_CLICKED)
                SetSendCharSetDlg(hwnd);
            break;
                
        case idbtnMailPlain:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rPlainOpt, sizeof(PLAINOPT));
                PlainOptFromMailOpt(&rPlainOpt, pmoi);
                if(FGetPlainOptions(hwnd, &rPlainOpt))
                {
                    MailOptFromPlainOpt(&rPlainOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;
        
        case idbtnNewsHTML:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rHtmlOpt, sizeof(rHtmlOpt));
                HtmlOptFromNewsOpt(&rHtmlOpt, pmoi);
                if(FGetHTMLOptions(hwnd, &rHtmlOpt))
                {
                    NewsOptFromHtmlOpt(&rHtmlOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;
        
        case idbtnNewsPlain:
            if (codeNotify == BN_CLICKED)
            {
                ZeroMemory(&rPlainOpt, sizeof(PLAINOPT));
            
                PlainOptFromNewsOpt(&rPlainOpt, pmoi);
                if(FGetPlainOptions(hwnd, &rPlainOpt))
                {
                    NewsOptFromPlainOpt(&rPlainOpt, pmoi);
                    SetPageDirty(pmoi, hwnd, PAGE_SEND);
                }
            }
            break;
        
        case idrbMailHTML:
        case idrbMailPlain:
        case idrbNewsHTML:
        case idrbNewsPlain:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_SEND);
            break;
                
    }
}


//
//  FUNCTION:   Send_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Send Tab.
//
LRESULT Send_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *pmoi = 0;
    DWORD    dw, dwOld;

    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        Assert(pmoi != NULL);
    
        // Send Options
        ButtonChkToOptInfo(hwnd, IDC_SAVE_CHECK, pmoi, OPT_SAVESENTMSGS);
        ButtonChkToOptInfo(hwnd, IDC_AUTOWAB_CHECK, pmoi, OPT_MAIL_AUTOADDTOWABONREPLY);
        ButtonChkToOptInfo(hwnd, IDC_USEAUTOCOMPLETE_CHECK, pmoi, OPT_USEAUTOCOMPLETE);
        ButtonChkToOptInfo(hwnd, IDC_INCLUDE_CHECK, pmoi, OPT_INCLUDEMSG);
        ButtonChkToOptInfo(hwnd, IDC_REPLY_IN_ORIGFMT, pmoi, OPT_REPLYINORIGFMT);
    
        // see if the send immediate option has changed from true->false, if so we
        // blow away the dontshow registry for sending to the outbox.
        dwOld = IDwGetOption(pmoi->pOpt, OPT_SENDIMMEDIATE);
        dw = (IsDlgButtonChecked(hwnd, IDC_SENDIMMEDIATE_CHECK) == BST_CHECKED);
        ISetDwOption(pmoi->pOpt, OPT_SENDIMMEDIATE, dw, NULL, 0);
        if (dwOld && !dw)
            SetDontShowAgain(0, (LPSTR) c_szDSSendMail);
    
        // Mail / News format
        ButtonChkToOptInfo(hwnd, idrbMailHTML, pmoi, OPT_MAIL_SEND_HTML);
        ButtonChkToOptInfo(hwnd, idrbNewsHTML, pmoi, OPT_NEWS_SEND_HTML);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}


/////////////////////////////////////////////////////////////////////////////
// Read Page
//

static const HELPMAP g_rgCtxMapMailRead[] = 
{
    {IDC_PREVIEW_CHECK,         IDH_MAIL_OPT_READ_MARK_READ},
    {IDC_MARKASREAD_EDIT,       IDH_MAIL_OPT_READ_MARK_READ},
    {IDC_MARKASREAD_SPIN,       IDH_MAIL_OPT_READ_MARK_READ},
    {idcStatic2,                IDH_MAIL_OPT_READ_MARK_READ},
    {idcDownloadChunks,         IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcStatic1,                IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcNumSubj,                IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcSpinNumSubj,            IDH_NEWS_OPT_READ_DOWNLOAD_SUBJ},
    {idcAutoExpand,             IDH_NEWS_OPT_READ_AUTO_EXPAND},
    {idcAutoFillPreview,        IDH_NEWS_OPT_IN_PREVIEW},
    {idcMarkAllRead,            IDH_NEWS_OPT_READ_MARK_ALL_EXIT},
    {idcAutoInline,             IDH_OPTIONS_READ_SHOW_PICTURE_ATTACHMENTS},
    {idcAutoInlineSlide,        IDH_OPTIONS_READ_SHOW_SLIDESHOW},
    {IDC_FONTSETTINGS,          IDH_OPTIONS_READ_FONT_SETTINGS},
    {idcIntlButton,             IDH_OPTIONS_READ_INTL_SETTINGS},
    {idcTooltips,               502050},
    {IDC_WATCHED_COLOR,         35526},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic9,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_READ_ICON,             IDH_NEWS_COMM_GROUPBOX},
    {IDC_READ_NEWS_ICON,        IDH_NEWS_COMM_GROUPBOX},
    {IDC_FONTS_ICON,            IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
        
INT_PTR CALLBACK ReadDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;    
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Read_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailRead);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Read_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Read_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DRAWITEM:
            Color_WMDrawItem((LPDRAWITEMSTRUCT) lParam, iColorCombo);
            return (FALSE);

        case WM_MEASUREITEM:
        {
            LPMEASUREITEMSTRUCT pmis = (LPMEASUREITEMSTRUCT) lParam;
            HWND hwndColor = GetDlgItem(hwnd, IDC_WATCHED_COLOR);
            HDC hdc = GetDC(hwndColor);
            if (hdc)
            {
                Color_WMMeasureItem(hdc, pmis, iColorCombo);
                ReleaseDC(hwndColor, hdc);
            }

            return (TRUE);
        }

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_READ_ICON);
            FreeIcon(hwnd, IDC_READ_NEWS_ICON);
            FreeIcon(hwnd, IDC_FONTS_ICON);
            return (TRUE);
    }
    
    return(FALSE);
}

//
//  FUNCTION:   Read_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Read Tab on the options
//              property sheet.
//
BOOL Read_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    DWORD    dw;
    OPTINFO *pmoi = 0;
    
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    // Preview pane timer
    InitCheckCounterFromOptInfo(hwnd, IDC_PREVIEW_CHECK, IDC_MARKASREAD_EDIT, 
                                IDC_MARKASREAD_SPIN, pmoi, OPT_MARKASREAD);
    
    ButtonChkFromOptInfo(hwnd, idcAutoExpand, pmoi, OPT_AUTOEXPAND);
    ButtonChkFromOptInfo(hwnd, idcAutoFillPreview, pmoi, OPT_AUTOFILLPREVIEW);
    ButtonChkFromOptInfo(hwnd, idcTooltips, pmoi, OPT_MESSAGE_LIST_TIPS);
    ButtonChkFromOptInfo(hwnd, IDC_READ_IN_TEXT_ONLY, pmoi, OPT_READ_IN_TEXT_ONLY);

    // Watched color
    DWORD dwColor = DwGetOption(OPT_WATCHED_COLOR);
    HWND  hwndColor = GetDlgItem(hwnd, IDC_WATCHED_COLOR);

    SetIntlFont(hwndColor);

    // Create the color control
    HrCreateComboColor(hwndColor);
    Assert(dwColor <= 16);
    ComboBox_SetCurSel(hwndColor, dwColor);

    // Download 300 headers at a time
    InitCheckCounterFromOptInfo(hwnd, idcDownloadChunks, idcNumSubj, idcSpinNumSubj,
                                pmoi, OPT_DOWNLOADCHUNKS);    
    ButtonChkFromOptInfo(hwnd, idcMarkAllRead, pmoi, OPT_MARKALLREAD);
        
    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_READING, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_READ_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_READ_NEWS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_READ_NEWS_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_FONTS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_FONTS_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return(TRUE);    
}


//
//  FUNCTION:   Read_OnCommand()
//
//  PURPOSE:    Command handler for the Read tab on the Options
//              property sheet.
//
void Read_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    DWORD    dw, dwPreview, dwDownload;
    OPTINFO *pmoi = 0;
    BOOL     f;

    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (pmoi == NULL)
        return;
            
    switch (id)
    {
        case IDC_PREVIEW_CHECK:
            if (codeNotify == BN_CLICKED)
            {
                f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_MARKASREAD_EDIT), f);
                EnableWindow(GetDlgItem(hwnd, IDC_MARKASREAD_SPIN), f);
            
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            }
            break;
        
        case idcAutoExpand:
        case idcAutoFillPreview:
        case idcMarkAllRead:
        case idcAutoInlineSlide:
        case idcTooltips:
        case IDC_READ_IN_TEXT_ONLY:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            break;

        case idcDownloadChunks:
            if (codeNotify == BN_CLICKED)
            {
                f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, idcNumSubj), f);
                EnableWindow(GetDlgItem(hwnd, idcSpinNumSubj), f);
            
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            }
            break;

        case IDC_MARKASREAD_EDIT:
        case idcNumSubj:
            if (codeNotify == EN_CHANGE)
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            break;

        case IDC_FONTSETTINGS:
            ChangeFontSettings(hwnd);
            break;
                
        case idcIntlButton:
            if (codeNotify == BN_CLICKED)
                IntlCharsetMapDialogBox(hwnd);
            break;

        case IDC_WATCHED_COLOR:
            if (codeNotify == CBN_SELENDOK)
                SetPageDirty(pmoi, hwnd, PAGE_READ);
            break;
    }
}


//
//  FUNCTION:   Read_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Read Tab.
//
LRESULT Read_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    DWORD    dw, dwPreview, dwDownload;
    WORD     code;
    OPTINFO *pmoi = 0;
    BOOL     f;

    if (PSN_APPLY == pnmhdr->code)
    {
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(pmoi != NULL);
                    
        if (!GetCheckCounter(&dwPreview, hwnd, IDC_PREVIEW_CHECK, IDC_MARKASREAD_EDIT, IDC_MARKASREAD_SPIN))
            return (InvalidOptionProp(hwnd, IDC_MARKASREAD_EDIT, idsEnterPreviewTime, iddOpt_Read));
    
        if (!GetCheckCounter(&dwDownload, hwnd, idcDownloadChunks, idcNumSubj, idcSpinNumSubj))
            return (InvalidOptionProp(hwnd, idcNumSubj, idsEnterDownloadChunks, iddOpt_Read));
    
        ISetDwOption(pmoi->pOpt, OPT_MARKASREAD, dwPreview, NULL, 0);
        ISetDwOption(pmoi->pOpt, OPT_DOWNLOADCHUNKS, dwDownload, NULL, 0);
    
        ButtonChkToOptInfo(hwnd, idcAutoExpand, pmoi, OPT_AUTOEXPAND);
        ButtonChkToOptInfo(hwnd, idcAutoFillPreview, pmoi, OPT_AUTOFILLPREVIEW);
        ButtonChkToOptInfo(hwnd, idcMarkAllRead, pmoi, OPT_MARKALLREAD);
        ButtonChkToOptInfo(hwnd, idcTooltips, pmoi, OPT_MESSAGE_LIST_TIPS);
        ButtonChkToOptInfo(hwnd, IDC_READ_IN_TEXT_ONLY, pmoi, OPT_READ_IN_TEXT_ONLY);

        if (CB_ERR != (dw = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_WATCHED_COLOR))))
            ISetDwOption(pmoi->pOpt, OPT_WATCHED_COLOR, dw, NULL, 0);
    
        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

/////////////////////////////////////////////////////////////////////////////
// Security Page
//

const static HELPMAP g_rgCtxMapSec[] = 
{
    {IDC_SIGN_CHECK,            IDH_OPTIONS_ADD_DIGITAL_SIGNATURE},
    {IDC_ENCRYPT_CHECK,         IDH_OPTIONS_ENCRYPT_MESSAGES},
    {IDC_ADVSETTINGS_BUTTON,    IDH_OPTIONS_SECURITY_ADVANCED},
    {IDC_INTERNET_ZONE,         IDH_SECURITY_ZONES_SETTINGS},
    {IDC_RESTRICTED_ZONE,       IDH_SECURITY_ZONES_SETTINGS},
    {IDC_SENDMAIL_WARN_CHECK,   IDH_SECURITY_SENDMAIL_WARN},
    {IDC_SAFE_ATTACHMENT_CHECK, IDH_SECURITY_SAFE_ATTACHMENTS},
    {idbtnDigitalID,            IDH_GET_DIGITAL_ID},
    {idbtnMoreInfo,             IDH_MORE_ON_CERTIFICATES},
    {idbtnIDs,                  355544},
    {IDC_SEC_LABEL,             IDH_SECURITY_LABEL},
    {IDC_SELECT_LABEL,          IDH_SECURITY_SETLABEL},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_SECURITY_ZONE_ICON,    IDH_NEWS_COMM_GROUPBOX},
    {IDC_SECURE_MAIL_ICON,      IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
   
 
INT_PTR CALLBACK SecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Security_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapSec);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Security_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Security_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_SECURITY_ZONE_ICON);
            FreeIcon(hwnd, IDC_SECURE_MAIL_ICON);
            return (TRUE);
    }
        
    return(FALSE);
}


//
//  FUNCTION:   Security_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Security Tab on the options
//              property sheet.
//
BOOL Security_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *poi = 0;
    DWORD    dw;

    Assert(poi == NULL);
    poi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(poi != NULL);
    
    ButtonChkFromOptInfo(hwnd, IDC_SIGN_CHECK, poi, OPT_MAIL_DIGSIGNMESSAGES);
    ButtonChkFromOptInfo(hwnd, IDC_ENCRYPT_CHECK, poi, OPT_MAIL_ENCRYPTMESSAGES);
    ButtonChkFromOptInfo(hwnd, IDC_SENDMAIL_WARN_CHECK, poi, OPT_SECURITY_MAPI_SEND);
    ButtonChkFromOptInfo(hwnd, IDC_SAFE_ATTACHMENT_CHECK, poi, OPT_SECURITY_ATTACHMENT);

#ifdef FORCE_UNTRUSTED
    dw = URLZONE_UNTRUSTED;
#else // FORCE_UNTRUSTED
    dw = IDwGetOption(poi->pOpt, OPT_SECURITYZONE);
#endif // FORCE_UNTRUSTED

    CheckDlgButton(hwnd, dw == URLZONE_INTERNET ? IDC_INTERNET_ZONE : IDC_RESTRICTED_ZONE, BST_CHECKED);
    if (DwGetOption(OPT_SECURITYZONELOCKED) != 0)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_INTERNET_ZONE), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_RESTRICTED_ZONE), FALSE);
    }
    if (DwGetOption(OPT_SECURITY_MAPI_SEND_LOCKED) != 0)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SENDMAIL_WARN_CHECK), FALSE);
    }
    if (DwGetOption(OPT_SECURITY_ATTACHMENT_LOCKED) != 0)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SAFE_ATTACHMENT_CHECK), FALSE);
    }

    // Hide these controls in news-only mode
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SECURITYSETTINGS_GROUP), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SECURITYSETTINGS_STATIC), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SIGN_CHECK), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ENCRYPT_CHECK), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ADVSETTINGS_BUTTON), FALSE);
#ifdef SMIME_V3
        EnableWindow(GetDlgItem(hwnd, IDC_SELECT_LABEL), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SEC_LABEL), FALSE);
#endif // SMIME_V3
        EnableWindow(GetDlgItem(hwnd, IDC_DIGITALIDS_GROUP), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DIGITALIDS_STATIC), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnDigitalID), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnIDs), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbtnMoreInfo), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic2), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic4), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic5), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic6), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SECURE_MAIL_ICON), FALSE);
    }
    
    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(poi->himl, ID_SECURITY_ZONE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SECURITY_ZONE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(poi->himl, ID_SECURE_MAIL, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SECURE_MAIL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

#ifdef SMIME_V3
    if (!FPresentPolicyRegInfo()) 
    {
        ShowWindow(GetDlgItem(hwnd, IDC_SEC_LABEL), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SELECT_LABEL), SW_HIDE);
    }
    else
        ButtonChkFromOptInfo(hwnd, IDC_SEC_LABEL, poi, OPT_USE_LABELS);

#endif // SMIME_V3

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)poi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return(TRUE);
}


//
//  FUNCTION:   Security_OnCommand()
//
//  PURPOSE:    Command handler for the Security tab on the Options
//              property sheet.
//
void Security_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *poi = 0;
    
    poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (poi == NULL)
        return;
            
    switch (id)
    {
        case idbtnDigitalID:
            GetDigitalIDs(NULL);
            break;

        case idbtnIDs:
            ShowDigitalIDs(hwnd);
            break;

        case idbtnMoreInfo:
            if (codeNotify == BN_CLICKED)
            {
                OEHtmlHelp(hwnd, "%SYSTEMROOT%\\help\\msoe.chm>large_context", HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR) "mail_overview_send_secure_messages.htm");
            }
            break;

        case IDC_INTERNET_ZONE:
        case IDC_RESTRICTED_ZONE:
        case IDC_SENDMAIL_WARN_CHECK:
        case IDC_SAFE_ATTACHMENT_CHECK:
        case IDC_SIGN_CHECK:
#ifdef SMIME_V3
        case IDC_SEC_LABEL:
#endif // SMIME_V3
        case IDC_ENCRYPT_CHECK:
            if (codeNotify == BN_CLICKED)
                PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

#ifdef SMIME_V3                
        case IDC_SELECT_LABEL:
            if (codeNotify == BN_CLICKED)
            {
                FGetSecLabel(hwnd, poi);
            }
            break;
#endif // SMIME_V3

        case IDC_ADVSETTINGS_BUTTON:
            if (codeNotify == BN_CLICKED)
                FGetAdvSecOptions(hwnd, poi);
            break;
    }
}


//
//  FUNCTION:   Security_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Security Tab.
//
LRESULT Security_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *poi;

    if (pnmhdr->code == PSN_APPLY)
    {
        // make sure something has changed
        poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(poi != NULL);

        // update the global options based on states of the controls
        ButtonChkToOptInfo(hwnd, IDC_SIGN_CHECK, poi, OPT_MAIL_DIGSIGNMESSAGES);
        ButtonChkToOptInfo(hwnd, IDC_ENCRYPT_CHECK, poi, OPT_MAIL_ENCRYPTMESSAGES);
        if (IsWindowEnabled(GetDlgItem(hwnd, IDC_SENDMAIL_WARN_CHECK)))
            ButtonChkToOptInfo(hwnd, IDC_SENDMAIL_WARN_CHECK, poi, OPT_SECURITY_MAPI_SEND);
        if (IsWindowEnabled(GetDlgItem(hwnd, IDC_SAFE_ATTACHMENT_CHECK)))
            ButtonChkToOptInfo(hwnd, IDC_SAFE_ATTACHMENT_CHECK, poi, OPT_SECURITY_ATTACHMENT);
#ifdef SMIME_V3
        ButtonChkToOptInfo(hwnd, IDC_SEC_LABEL, poi, OPT_USE_LABELS);
#endif

#ifdef FORCE_UNTRUSTED
        DWORD dwZone = URLZONE_UNTRUSTED;
#else // FORCE_UNTRUSTED
        DWORD dwZone = URLZONE_INTERNET;

        if (IsDlgButtonChecked(hwnd, IDC_RESTRICTED_ZONE))
        {
            dwZone = URLZONE_UNTRUSTED;
        }
#endif // FORCE_UNTRUSTED

        ISetDwOption(poi->pOpt, OPT_SECURITYZONE, dwZone, NULL, 0);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

    
BOOL FGetAdvSecOptions(HWND hwndParent, OPTINFO *opie)
{
    return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddAdvSecurity),
        hwndParent, AdvSecurityDlgProc, (LPARAM)opie)==IDOK);
}

#ifdef SMIME_V3
BOOL FGetSecLabel(HWND hwndParent, OPTINFO *opie)
{
    PSMIME_SECURITY_LABEL plabel = NULL;
    BOOL fRes = FALSE;

    HRESULT hr = HrGetOELabel(&plabel);

    if(DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSelectLabel),
        hwndParent, SecurityLabelsDlgProc, (LPARAM) ((hr == S_OK) ? &plabel : NULL)) == IDOK)
    {
        hr = HrSetOELabel(plabel);
        if(hr == S_OK)
            fRes = TRUE;
    }

    // These two calls are temporary.
    SecPolicyFree(plabel);
    HrUnloadPolicyRegInfo(0);
    return (fRes);
}
#endif // SMIME_V3


/////////////////////////////////////////////////////////////////////////////
// Connection Page
//

static const HELPMAP g_rgCtxMapDialup[] = 
{
    {idcNoConnectionRadio,      IDH_OPTIONS_DIALUP_DONT_CONNECT},
    {idcDialUpCombo,            IDH_OPTIONS_DIALUP_CONNECTION_NUMBER},
    {idcDialRadio,              IDH_OPTIONS_DIALUP_CONNECTION_NUMBER},
    {idcPromptRadio,            IDH_OPTIONS_DIALUP_ASK},
    {idcSwitchCheck,            IDH_OPTIONS_DIALUP_WARN_BEFORE_SWITCHING},
    {idcHangupCheck,            IDH_OPTIONS_DIALUP_HANG_UP},
    {idcDialupButton,           25252596},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_DIAL_START_ICON,       IDH_NEWS_COMM_GROUPBOX},
    {IDC_INTERNET_DIAL_ICON,    IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
    
INT_PTR CALLBACK DialUpDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    HWND        hwndChangeButton;
    OPTINFO     *pmoi;
    
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    
    hwndChangeButton = GetDlgItem(hwnd, idcDialupButton);
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Dial_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapDialup);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Dial_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Dial_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_DIAL_START_ICON);
            FreeIcon(hwnd, IDC_INTERNET_DIAL_ICON);
            FreeIcon(hwnd, IDC_DIAL_ICON);

            if (IsWindow(GetDlgItem(hwnd, IDC_AUTODISCOVERY_ICON)))
            {
                FreeIcon(hwnd, IDC_AUTODISCOVERY_ICON);
            }
            return (TRUE);
    }
    
    return(FALSE);
}
    

//  FUNCTION:   Dial_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Dial Tab on the options
//              property sheet.
#define FEATURE_AUTODISCOVERY_DEFAULT                FALSE

BOOL Dial_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO     *pmoi = 0;
    DWORD       dwEnableAutodial = 0, dwsize = sizeof(DWORD);
    HICON hIcon;

    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);

    ButtonChkFromOptInfo(hwnd, idcSwitchCheck, pmoi, OPT_DIALUP_WARN_SWITCH);
    ButtonChkFromOptInfo(hwnd, idcHangupCheck, pmoi, OPT_DIALUP_HANGUP_DONE);

    EnableWindow(GetDlgItem(hwnd, idcSwitchCheck), IsRasInstalled());
    EnableWindow(GetDlgItem(hwnd, idcHangupCheck), IsRasInstalled());

    // Pictures
    hIcon = ImageList_GetIcon(pmoi->himl, ID_CONNECTION_START, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_DIAL_START_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_CONNECTION_INTERNET, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_INTERNET_DIAL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);


#ifdef FEATURE_AUTODISCOVERY
    // Is the AutoDiscovery feature available?
    if (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY_POLICY, SZ_REGVALUE_AUTODISCOVERY_POLICY, FALSE, TRUE))
    {
        // Yes, so load the state into the controls.
        SendDlgItemMessage(hwnd, IDC_AUTODISCOVERY_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
        CheckDlgButton(hwnd, idcAutoDiscovery, SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY, FALSE, FEATURE_AUTODISCOVERY_DEFAULT));
    }
    else
    {
        // No so remove the UI.
        DestroyWindow(GetDlgItem(hwnd, idcStatic7));
        DestroyWindow(GetDlgItem(hwnd, idcStatic8));
        DestroyWindow(GetDlgItem(hwnd, IDC_AUTODISCOVERY_ICON));
        DestroyWindow(GetDlgItem(hwnd, idcAutoDiscovery));
    }
#endif FEATURE_AUTODISCOVERY

    return(TRUE);
}


//
//  FUNCTION:   Dial_OnCommand()
//
//  PURPOSE:    Command handler for the Dial tab on the Options
//              property sheet.
//
void Dial_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO     *pmoi = 0;

    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (pmoi == NULL)
        return;
    
    switch (id)
    {
        case idcSwitchCheck:
        case idcHangupCheck:
        case idcAutoDiscovery:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(pmoi, hwnd, PAGE_DIALUP);
            break;
        
        case idcDialupButton:
        {
            AssertSz(!!LaunchConnectionDialog, TEXT("LoadLibrary failed on INETCPL.CPL"));
        
            if (LaunchConnectionDialog != NULL)
            {
                LaunchConnectionDialog(hwnd);
            }
            break;
        }
    }        
}


//
//  FUNCTION:   Dial_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Dial Tab.
//
LRESULT Dial_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *pmoi = 0;

    if (PSN_APPLY == pnmhdr->code)
    {
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(pmoi != NULL);
        
        ButtonChkToOptInfo(hwnd, idcSwitchCheck, pmoi, OPT_DIALUP_WARN_SWITCH);
        ButtonChkToOptInfo(hwnd, idcHangupCheck, pmoi, OPT_DIALUP_HANGUP_DONE);

#ifdef FEATURE_AUTODISCOVERY
        // Is the AutoDiscovery feature available?
        if (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY_POLICY, SZ_REGVALUE_AUTODISCOVERY_POLICY, FALSE, TRUE))
        {
            // Yes, so set the AutoDiscovery Option
            BOOL fAutoDiscoveryOn = IsDlgButtonChecked(hwnd, idcAutoDiscovery);
            LPCTSTR pszValue = (fAutoDiscoveryOn ? TEXT("TRUE") : TEXT("FALSE"));
            DWORD cbSize = ((lstrlen(pszValue) + 1) * sizeof(pszValue[0]));

            SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY, REG_SZ, (LPCVOID) pszValue, cbSize);
        }
#endif FEATURE_AUTODISCOVERY

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

/////////////////////////////////////////////////////////////////////////////
// Maintenance Page
//
const static HELPMAP g_rgCtxMapNOAdvnaced[] = 
{
    {idchDeleteMsgs,            IDH_DELETE_AFTER_XXDAYS},
    {idcStatic1,                IDH_DELETE_AFTER_XXDAYS},
    {ideDays,                   IDH_DELETE_AFTER_XXDAYS},
    {idspDays,                  IDH_DELETE_AFTER_XXDAYS},
    {idchDontCacheRead,         IDH_DELETE_READ},
    {ideCompactPer,             IDH_COMPACT_WHEN_WASTED},
    {idcStatic2,                IDH_COMPACT_WHEN_WASTED},
    {idcStatic3,                IDH_COMPACT_WHEN_WASTED},
    {idspCompactPer,            IDH_COMPACT_WHEN_WASTED},
    {idbManualCleanUp,          IDH_CLEAN_UP_BUTTON},
    {idcLogMailXport,           IDH_OPTIONS_MAIL_TRANSPORT},
    {idcLogNewsXport,           IDH_OPTIONS_NEWS_TRANSPORT},
    {idcLogNewsOffline,         IDH_OPTIONS_OFFLINE_LOG},
    {idcLogImapXport,           IDH_OPTIONS_IMAP_TRANSPORT},
    {idcLogHTTPMailXport,       355567},
    {IDC_STORE_LOCATION,        IDH_ADVANCED_STORE_FOLDER},
    {IDC_EMPTY_CHECK,           IDH_MAIL_OPT_READ_EMPTY_DELETED},
    {idcIMAPPurge,              502001},
    {IDC_BACKGROUND_COMPACTION, 502002},
    {IDC_STORE_LOCATION,        502003},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic9,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic10,               IDH_NEWS_COMM_GROUPBOX},
    {idcStatic11,               IDH_NEWS_COMM_GROUPBOX},
    {IDC_CLEANUP_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {IDC_TROUBLE_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};
        
INT_PTR CALLBACK MaintenanceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Maintenance_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapNOAdvnaced);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Maintenance_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Maintenance_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_CLEANUP_ICON);
            FreeIcon(hwnd, IDC_TROUBLE_ICON);
            return (TRUE);
    }
        
    return 0;
}


//
//  FUNCTION:   Maintenance_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Maintenance Tab on the options
//              property sheet.
//
BOOL Maintenance_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO    *poi = 0;
    HICON       hIcon;

    poi = (OPTINFO *)((PROPSHEETPAGE *)lParam)->lParam;
    Assert(poi != NULL);
    
    ButtonChkFromOptInfo(hwnd, IDC_EMPTY_CHECK, poi, OPT_PURGEWASTE);
    ButtonChkFromOptInfo(hwnd, idcIMAPPurge, poi, OPT_IMAPPURGE);

    ButtonChkFromOptInfo(hwnd, IDC_BACKGROUND_COMPACTION, poi, OPT_BACKGROUNDCOMPACT);
    ButtonChkFromOptInfo(hwnd, idchDontCacheRead, poi, OPT_CACHEREAD);
    InitCheckCounterFromOptInfo(hwnd, idchDeleteMsgs, ideDays, idspDays,
                                poi, OPT_CACHEDELETEMSGS);
    InitCheckCounterFromOptInfo(hwnd, 0, ideCompactPer, idspCompactPer,
                                poi, OPT_CACHECOMPACTPER);

    if (0 == IDwGetOption(poi->pOpt, OPT_BACKGROUNDCOMPACT))
    {
        EnableWindow(GetDlgItem(hwnd, idchDontCacheRead), FALSE);
        EnableWindow(GetDlgItem(hwnd, idchDeleteMsgs), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic1), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic2), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
    }
    
    ButtonChkFromOptInfo(hwnd, idcLogMailXport, poi, OPT_MAILLOG);
    ButtonChkFromOptInfo(hwnd, idcLogNewsXport, poi, OPT_NEWS_XPORT_LOG);
    ButtonChkFromOptInfo(hwnd, idcLogImapXport, poi, OPT_MAIL_LOGIMAP4);
    ButtonChkFromOptInfo(hwnd, idcLogHTTPMailXport, poi, OPT_MAIL_LOGHTTPMAIL);

    // Hide these controls in news-only mode
    if (g_dwAthenaMode & MODE_NEWSONLY)
    {
        EnableWindow(GetDlgItem(hwnd, idcLogMailXport), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcLogImapXport), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcIMAPPurge), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcLogHTTPMailXport), FALSE);
    }
    
    // Hide these controls in mail-only mode
    if (g_dwAthenaMode & MODE_MAILONLY)
    {
        EnableWindow(GetDlgItem(hwnd, idcLogNewsXport), FALSE);
        EnableWindow(GetDlgItem(hwnd, idchDeleteMsgs), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspDays), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic1), FALSE);
        EnableWindow(GetDlgItem(hwnd, idchDontCacheRead), FALSE);
        EnableWindow(GetDlgItem(hwnd, ideCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic2), FALSE);
        EnableWindow(GetDlgItem(hwnd, idspCompactPer), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic3), FALSE);
        EnableWindow(GetDlgItem(hwnd, idbManualCleanUp), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic4), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic5), FALSE);
        EnableWindow(GetDlgItem(hwnd, idcStatic6), FALSE);
    }

    // HTTPMail accounts not visible unless the secret reg key exists
    if (!IsHTTPMailEnabled())
        ShowWindow(GetDlgItem(hwnd, idcLogHTTPMailXport), SW_HIDE);

    
    // Pictures
    hIcon = ImageList_GetIcon(poi->himl, ID_MAINTENANCE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_CLEANUP_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(poi->himl, ID_TROUBLESHOOTING, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_TROUBLE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    // Done
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)poi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return(TRUE);
}


//
//  FUNCTION:   Maintenance_OnCommand()
//
//  PURPOSE:    Command handler for the Maintenance tab on the Options
//              property sheet.
//
void Maintenance_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO    *poi;
    DWORD       dw;
    
    poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    if (poi == NULL)
        return;
                
    switch(id)
    {
        case IDC_STORE_LOCATION:
            if (codeNotify == BN_CLICKED)
                DoStoreLocationDlg(hwnd);
            break;
                    
        case idbManualCleanUp:
            if (codeNotify == BN_CLICKED)
                DialogBox(g_hLocRes, MAKEINTRESOURCE(iddCacheMan), hwnd, CacheCleanUpDlgProc);
            break;

        case IDC_EMPTY_CHECK:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(poi, hwnd, PAGE_ADV);
            break;
            
        case idchDeleteMsgs:
            if (codeNotify == BN_CLICKED)
            {
                dw = BST_CHECKED == IsDlgButtonChecked(hwnd, id);
                EnableWindow(GetDlgItem (hwnd, ideDays), dw);
                EnableWindow(GetDlgItem (hwnd, idspDays), dw);
                
                SetPageDirty(poi, hwnd, PAGE_ADV);
            }
            break;
                    
        case ideCompactPer:
        case ideDays:
            if (codeNotify == EN_CHANGE)
                SetPageDirty(poi, hwnd, PAGE_ADV);
            break;
                    
        case IDC_BACKGROUND_COMPACTION:
            if (codeNotify == BN_CLICKED)
            {
                dw = IsDlgButtonChecked(hwnd, id);
                EnableWindow(GetDlgItem(hwnd, idchDontCacheRead), dw);
                EnableWindow(GetDlgItem(hwnd, idchDeleteMsgs), dw);
                EnableWindow(GetDlgItem(hwnd, ideDays), dw && IsDlgButtonChecked(hwnd, idchDeleteMsgs));
                EnableWindow(GetDlgItem(hwnd, idspDays), dw && IsDlgButtonChecked(hwnd, idchDeleteMsgs));
                EnableWindow(GetDlgItem(hwnd, idcStatic1), dw);
                EnableWindow(GetDlgItem(hwnd, idcStatic2), dw);
                EnableWindow(GetDlgItem(hwnd, ideCompactPer), dw);
                EnableWindow(GetDlgItem(hwnd, idspCompactPer), dw);
                EnableWindow(GetDlgItem(hwnd, idcStatic3), dw);
                SetPageDirty(poi, hwnd, PAGE_ADV);
            }
            break;

        case idchDontCacheRead:
        case idcLogNewsXport:
        case idcLogMailXport:
        case idcLogImapXport:
        case idcLogHTTPMailXport:
        case idcIMAPPurge:
            if (codeNotify == BN_CLICKED)
                SetPageDirty(poi, hwnd, PAGE_ADV);
            break;
    }
}


//
//  FUNCTION:   Maintenance_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Maintenance Tab.
//
LRESULT Maintenance_OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    OPTINFO *poi;
    DWORD dwCompact, dwDelete;

    if (PSN_APPLY == pnmhdr->code)
    {
        poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
        Assert(poi != NULL);
                        
        ButtonChkToOptInfo(hwnd, IDC_BACKGROUND_COMPACTION, poi, OPT_BACKGROUNDCOMPACT);

        // Startup or Shutdown background compaction!
        if (DwGetOption(OPT_BACKGROUNDCOMPACT))
            SideAssert(SUCCEEDED(StartBackgroundStoreCleanup(1)));
        else
            SideAssert(SUCCEEDED(CloseBackgroundStoreCleanup()));

        // Delete messages
        if (!GetCheckCounter(&dwDelete, hwnd, idchDeleteMsgs, ideDays, idspDays))
            return(InvalidOptionProp(hwnd, ideDays, idsEnterDays, iddOpt_Advanced));
                        
        // Disk space usage
        if (!GetCheckCounter(&dwCompact, hwnd, 0, ideCompactPer, idspCompactPer))
            return(InvalidOptionProp(hwnd, ideCompactPer, idsEnterCompactPer, iddOpt_Advanced));
        
        ISetDwOption(poi->pOpt, OPT_CACHEDELETEMSGS, dwDelete, NULL, 0);
        ISetDwOption(poi->pOpt, OPT_CACHECOMPACTPER, dwCompact, NULL, 0);
        
        // Cache read articles ?
        ISetDwOption(poi->pOpt, OPT_CACHEREAD, IsDlgButtonChecked(hwnd, idchDontCacheRead), NULL, 0);
        
        // IMAP Purge ?
        ISetDwOption(poi->pOpt, OPT_IMAPPURGE, IsDlgButtonChecked(hwnd, idcIMAPPurge), NULL, 0);
        
        // Logging?
        ButtonChkToOptInfo(hwnd, idcLogMailXport, poi, OPT_MAILLOG);
        ButtonChkToOptInfo(hwnd, idcLogNewsXport, poi, OPT_NEWS_XPORT_LOG);
        ButtonChkToOptInfo(hwnd, idcLogImapXport, poi, OPT_MAIL_LOGIMAP4);
        ButtonChkToOptInfo(hwnd, idcLogHTTPMailXport, poi, OPT_MAIL_LOGHTTPMAIL);
        ButtonChkToOptInfo(hwnd, IDC_EMPTY_CHECK, poi, OPT_PURGEWASTE);

        // Done
        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }

    return (0);
}

    
/////////////////////////////////////////////////////////////////////////////
// Compose Tab 
//

static const HELPMAP g_rgCtxMapCompose[] = {
    {IDC_MAIL_FONT_DEMO,        35585},
    {IDC_NEWS_FONT_DEMO,        35585},
    {IDC_MAIL_FONT_SETTINGS,    35560},
    {IDC_NEWS_FONT_SETTINGS,    35560},
    {IDC_USE_MAIL_STATIONERY,   35587},
    {IDC_USE_NEWS_STATIONERY,   35587},
    {IDC_MAIL_STATIONERY,       35586},
    {IDC_NEWS_STATIONERY,       35586},
    {IDC_SELECT_MAIL,           35575},
    {IDC_SELECT_NEWS,           35575},
    {IDC_DOWNLOAD_MORE,         35650},
    {IDC_MAIL_VCARD,            35611},
    {IDC_NEWS_VCARD,            35611},
    {IDC_EDIT_MAIL_VCARD,       35620},
    {IDC_EDIT_NEWS_VCARD,       35620},
    {IDC_CREATE_NEW,            35632},
    {IDC_MAIL_VCARD_SELECT,     35630},
    {IDC_NEWS_VCARD_SELECT,     35630},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_FONT_ICON,             IDH_NEWS_COMM_GROUPBOX},
    {IDC_STATIONERY_ICON,       IDH_NEWS_COMM_GROUPBOX},
    {IDC_VCARD_ICON,            IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};

INT_PTR CALLBACK ComposeDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    
    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Compose_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapCompose);
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Compose_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Compose_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_FONT_ICON);
            FreeIcon(hwnd, IDC_STATIONERY_ICON);
            FreeIcon(hwnd, IDC_VCARD_ICON);
            return (TRUE);
    }
        
    return(FALSE);
}
    

//
//  FUNCTION:   Compose_OnInitDialog()
//
//  PURPOSE:    Handles the WM_INITDIALOG for the Compose Tab on the options
//              property sheet.
//
BOOL Compose_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi = 0;
    TCHAR    szBuf[CCHMAX_STRINGRES] = "";
    DWORD    dw;
    DWORD    cch;
    HWND     hwndT;
    FARPROC  pfnFontSampleWndProc;
    HRESULT  hr;

    // Get the passed in options pointer
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);

    // Stash the pointer
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);

    // Compose Font Settings
    hwndT = GetDlgItem(hwnd, IDC_MAIL_FONT_DEMO);
    pfnFontSampleWndProc = (FARPROC) SetWindowLongPtrAthW(hwndT, GWLP_WNDPROC, (LPARAM) FontSampleSubProc);
    SetWindowLongPtr(hwndT, GWLP_USERDATA, (LPARAM) pfnFontSampleWndProc);

    
    hwndT = GetDlgItem(hwnd, IDC_NEWS_FONT_DEMO);
    pfnFontSampleWndProc = (FARPROC) SetWindowLongPtrAthW(hwndT, GWLP_WNDPROC, (LPARAM) FontSampleSubProc);
    SetWindowLongPtr(hwndT, GWLP_USERDATA, (LPARAM) pfnFontSampleWndProc);

    // Mail Stationery
    dw = IDwGetOption(pmoi->pOpt, OPT_MAIL_USESTATIONERY);
    SendDlgItemMessage(hwnd, IDC_USE_MAIL_STATIONERY, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_SELECT_MAIL), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_MAIL_STATIONERY), !!dw);
    hr = GetDefaultStationeryName(TRUE, g_wszMailStationery);
    _SetThisStationery(hwnd, TRUE, SUCCEEDED(hr) ? g_wszMailStationery : NULL, pmoi);

    // News Stationery
    dw = IDwGetOption(pmoi->pOpt, OPT_NEWS_USESTATIONERY);
    SendDlgItemMessage(hwnd, IDC_USE_NEWS_STATIONERY, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_SELECT_NEWS), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_NEWS_STATIONERY), !!dw);
    hr = GetDefaultStationeryName(FALSE, g_wszNewsStationery);
    _SetThisStationery(hwnd, FALSE, SUCCEEDED(hr) ? g_wszNewsStationery : NULL, pmoi);

    // Mail VCard
    hwndT = GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT);
    dw = IDwGetOption(pmoi->pOpt, OPT_MAIL_ATTACHVCARD);
    IGetOption(pmoi->pOpt, OPT_MAIL_VCARDNAME, szBuf, sizeof(szBuf));
    SetIntlFont(hwndT);
    LoadVCardList(hwndT, szBuf);
    cch = GetWindowTextLength(hwndT);
    if (cch == 0)
        dw = 0;

    SendDlgItemMessage(hwnd, IDC_MAIL_VCARD, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), (cch && dw));
        
    // News VCard
    hwndT = GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT);
    dw = IDwGetOption(pmoi->pOpt, OPT_NEWS_ATTACHVCARD);
    IGetOption(pmoi->pOpt, OPT_NEWS_VCARDNAME, szBuf, sizeof(szBuf));
    SetIntlFont(hwndT);
    LoadVCardList(hwndT, szBuf);
    cch = GetWindowTextLength(hwndT);
    if (cch == 0)
        dw = 0;

    SendDlgItemMessage(hwnd, IDC_NEWS_VCARD, BM_SETCHECK, !!dw ? BM_SETCHECK : 0, 0);
    EnableWindow(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT), !!dw);
    EnableWindow(GetDlgItem(hwnd, IDC_EDIT_NEWS_VCARD), (cch && dw));

    // Pictures
    HICON hIcon;

    hIcon = ImageList_GetIcon(pmoi->himl, ID_FONTS, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_FONT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_STATIONERY_ICON, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_STATIONERY_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    hIcon = ImageList_GetIcon(pmoi->himl, ID_VCARD, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_VCARD_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
//    if(!!(g_dwAthenaMode & MODE_OUTLOOKNEWS))
    if(!!(g_dwAthenaMode & MODE_NEWSONLY))
    {
        //Disable all the mail stuff
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_FONT_DEMO), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_FONT_SETTINGS), FALSE);

        EnableWindow(GetDlgItem(hwnd, IDC_USE_MAIL_STATIONERY), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_STATIONERY), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_SELECT_MAIL), FALSE);

        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), FALSE);
    }

    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


//
//  FUNCTION:   Compose_OnCommand()
//
//  PURPOSE:    Command handler for the Compose tab on the Options
//              property sheet.
//
void Compose_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    BOOL     f;
    HWND     hwndT;
    TCHAR    szBuf[MAX_PATH];
    WCHAR    wszBuf[MAX_PATH];
    DWORD    cch = 0;
    int      i;
    BOOL     f2;
    TCHAR    szURL[2048];

    *szBuf = 0;
    *wszBuf = 0;

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    switch (id)
    {
        case IDC_MAIL_FONT_SETTINGS:
        case IDC_NEWS_FONT_SETTINGS:
            if (ChangeSendFontSettings(pmoi, id == IDC_MAIL_FONT_SETTINGS, hwnd))
            {
                hwndT = GetDlgItem(hwnd, id == IDC_MAIL_FONT_SETTINGS ? IDC_MAIL_FONT_DEMO : IDC_NEWS_FONT_DEMO);
                InvalidateRect(hwndT, NULL, TRUE);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_USE_MAIL_STATIONERY:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            if( !f )
            {
                SetWindowTextWrapW(GetDlgItem(hwnd,IDC_MAIL_STATIONERY), c_wszEmpty);
                StrCpyNW(g_wszMailStationery, c_wszEmpty, ARRAYSIZE(g_wszMailStationery));
            }
            EnableWindow(GetDlgItem(hwnd, IDC_SELECT_MAIL), f);
            EnableWindow(GetDlgItem(hwnd, IDC_MAIL_STATIONERY), f);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_USE_NEWS_STATIONERY:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            if( !f )
            {
                SetWindowTextWrapW(GetDlgItem(hwnd,IDC_NEWS_STATIONERY), c_wszEmpty);
                StrCpyNW(g_wszNewsStationery, c_wszEmpty, ARRAYSIZE(g_wszNewsStationery));
            }
            EnableWindow(GetDlgItem(hwnd, IDC_SELECT_NEWS), f);
            EnableWindow(GetDlgItem(hwnd, IDC_NEWS_STATIONERY), f);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_SELECT_MAIL:
            hwndT = GetDlgItem(hwnd, IDC_MAIL_STATIONERY);
            cch = GetWindowTextWrapW(hwndT, wszBuf, ARRAYSIZE(wszBuf)-1);
            wszBuf[cch] = 0;
            
            if( HR_SUCCEEDED(HrGetMoreStationeryFileName( hwnd, g_wszMailStationery)) )
            {
                GetStationeryFullName(g_wszMailStationery);
                
                _SetThisStationery(hwnd, TRUE, g_wszMailStationery, pmoi);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_SELECT_NEWS:
            hwndT = GetDlgItem(hwnd, IDC_NEWS_STATIONERY);
            cch = GetWindowText(hwndT, szBuf, sizeof(szBuf)-1);
            szBuf[cch] = 0;
            
            if( HR_SUCCEEDED(HrGetMoreStationeryFileName(hwnd, g_wszNewsStationery)) )
            {
                GetStationeryFullName(g_wszNewsStationery);
                
                _SetThisStationery(hwnd, FALSE, g_wszNewsStationery, pmoi);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_MAIL_VCARD:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            f2 = (SendDlgItemMessage(hwnd, IDC_MAIL_VCARD_SELECT, CB_GETCURSEL, 0, 0) != CB_ERR);
            EnableWindow(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT), f);
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), f2 && f);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_NEWS_VCARD:
            f = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
            f2 = (SendDlgItemMessage(hwnd, IDC_NEWS_VCARD_SELECT, CB_GETCURSEL, 0, 0) != CB_ERR);
            EnableWindow(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT), f);
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_NEWS_VCARD), f && f2);
            PropSheet_Changed(GetParent(hwnd), hwnd);
            break;

        case IDC_MAIL_VCARD_SELECT:
            if (codeNotify == CBN_SELENDOK)
            {
                f = (SendMessage(hwndCtl, CB_GETCURSEL, 0, 0) != CB_ERR);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_MAIL_VCARD), f);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_NEWS_VCARD_SELECT:
            if (codeNotify == CBN_SELENDOK)
            {
                f = (SendMessage(hwndCtl, CB_GETCURSEL, 0, 0) != CB_ERR);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_NEWS_VCARD), f);
                PropSheet_Changed(GetParent(hwnd), hwnd);
            }
            break;

        case IDC_EDIT_MAIL_VCARD:
            VCardEdit(hwnd, IDC_MAIL_VCARD_SELECT, IDC_NEWS_VCARD_SELECT);
            break;

        case IDC_EDIT_NEWS_VCARD:
            VCardEdit(hwnd, IDC_NEWS_VCARD_SELECT, IDC_MAIL_VCARD_SELECT);
            break;

        case IDC_DOWNLOAD_MORE:
            if (SUCCEEDED(URLSubLoadStringA(idsShopMoreStationery, szURL, ARRAYSIZE(szURL), URLSUB_ALL, NULL)))
                ShellExecute(NULL, "open", szURL, NULL, NULL, SW_SHOWNORMAL);
            break;

        case IDC_CREATE_NEW:
            CStatWiz* pStatWiz = 0;
            pStatWiz = new CStatWiz();
            if (pStatWiz)
            {
                pStatWiz->DoWizard(hwnd);
                ReleaseObj(pStatWiz);
            }
            break;
    }                
}


//
//  FUNCTION:   Compose_OnNotify()
//
//  PURPOSE:    Handles the PSN_APPLY notification for the Compose Tab.
//
LRESULT Compose_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    OPTINFO *pmoi = 0;
    TCHAR    szBuf[MAX_PATH];
    DWORD    cch;

    if (PSN_SETACTIVE == pnmhdr->code)
    {
        InvalidateRect(GetDlgItem(hwnd, IDC_MAIL_FONT_DEMO), NULL, TRUE);
        InvalidateRect(GetDlgItem(hwnd, IDC_NEWS_FONT_DEMO), NULL, TRUE);
        return TRUE;
    }
                
    // The only notification we care about is Apply
    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        if (pmoi == NULL)
            return (PSNRET_INVALID_NOCHANGEPAGE);
                    
        // Stationery options
        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_USE_MAIL_STATIONERY))
        {
            // Make sure the user has selected some stationery
            if (0 == GetDlgItemText(hwnd, IDC_MAIL_STATIONERY, szBuf, sizeof(szBuf)))
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsStationery),
                              MAKEINTRESOURCEW(idsSelectStationery),
                              NULL, MB_OK | MB_ICONEXCLAMATION);
            
                SetFocus(GetDlgItem(hwnd, IDC_SELECT_MAIL));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_USE_NEWS_STATIONERY))
        {
            if (0 == GetDlgItemText(hwnd, IDC_NEWS_STATIONERY, szBuf, sizeof(szBuf)))
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsStationery),
                              MAKEINTRESOURCEW(idsSelectStationery),
                              NULL, MB_OK | MB_ICONEXCLAMATION);
                
                SetFocus(GetDlgItem(hwnd, IDC_SELECT_NEWS));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }            
        }

        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_MAIL_VCARD))
        {
            cch = GetWindowTextLength(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT));
            if (cch == 0)
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsChooseName),
                    NULL, MB_OK | MB_ICONEXCLAMATION);

                SetFocus(GetDlgItem(hwnd, IDC_MAIL_VCARD_SELECT));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_NEWS_VCARD))
        {
            cch = GetWindowTextLength(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT));
            if (cch == 0)
            {
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsChooseName),
                    NULL, MB_OK | MB_ICONEXCLAMATION);

                SetFocus(GetDlgItem(hwnd, IDC_NEWS_VCARD_SELECT));
                return (PSNRET_INVALID_NOCHANGEPAGE);
            }
        }

        SetDefaultStationeryName(TRUE, g_wszMailStationery);
        ButtonChkToOptInfo(hwnd, IDC_USE_MAIL_STATIONERY, pmoi, OPT_MAIL_USESTATIONERY);

        SetDefaultStationeryName(FALSE, g_wszNewsStationery);
        ButtonChkToOptInfo(hwnd, IDC_USE_NEWS_STATIONERY, pmoi, OPT_NEWS_USESTATIONERY);

        UpdateVCardOptions(hwnd, TRUE, pmoi);
        UpdateVCardOptions(hwnd, FALSE, pmoi);

        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (PSNRET_NOERROR);
    }
    
    return (FALSE);
}


void InitIndentOptions(CHAR chIndent, HWND hwnd, UINT idCheck, UINT idCombo)
{
    TCHAR szQuote[2], *sz;
    BOOL f;
    int isel;
    HWND hDlg=GetDlgItem(hwnd, idCombo);
    
    f = (chIndent != INDENTCHAR_NONE);
    CheckDlgButton(hwnd, idCheck, f ? BST_CHECKED : BST_UNCHECKED);
    EnableWindow(hDlg, f);
    
    // initialize the quote char combo
    if (!f)
        chIndent = DEF_INDENTCHAR;
    isel = 0;
    szQuote[1] = 0;
    sz = (TCHAR *)c_szQuoteChars;
    while (*sz != NULL)
    {
        *szQuote = *sz;
        SendMessage(hDlg, CB_ADDSTRING, 0, (LPARAM)szQuote);
        if (*szQuote == chIndent)
            SendMessage(hDlg, CB_SETCURSEL, (WPARAM)isel, 0);
        isel++;
        sz++;
    }
}

    
    
void FillEncodeCombo(HWND hwnd, BOOL fHTML, ENCODINGTYPE ietEncoding)
{
    TCHAR   sz[CCHMAX_STRINGRES];
    INT     i;
    
    // $$TODO$ Someday we should allow NONE as a text encoding type for HTML, but we must fix our line wrapping first.
    // None
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    if (!fHTML)
#endif
    {
        LoadString(g_hLocRes, idsNone, sz, CCHMAX_STRINGRES);
        i = (INT) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
        SendMessage(hwnd, CB_SETITEMDATA, i, (LPARAM)IET_7BIT);
    }
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    else
        Assert(ietEncoding != IET_7BIT);
#endif
    
    // QuotedPrintable
    LoadString(g_hLocRes, idsQuotedPrintable, sz, CCHMAX_STRINGRES);
    i = (INT) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
    SendMessage(hwnd, CB_SETITEMDATA, i, (LPARAM)IET_QP);
    
    // Base64
    LoadString(g_hLocRes, idsBase64, sz, CCHMAX_STRINGRES);
    i = (INT) SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
    SendMessage(hwnd, CB_SETITEMDATA, i, (LPARAM)IET_BASE64);
    
    // Select current - will default to QP if HTML is TRUE
    if (ietEncoding == IET_7BIT)
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)0, 0);
    
    else if (ietEncoding == IET_QP)
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)fHTML ? 0 : 1, 0);
#else
    SendMessage(hwnd, CB_SETCURSEL, (WPARAM)1, 0);
#endif
    
    if (ietEncoding == IET_BASE64)
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
        SendMessage(hwnd, CB_SETCURSEL, (WPARAM)fHTML ? 0 : 2, 0);
#else
    SendMessage(hwnd, CB_SETCURSEL, (WPARAM)2, 0);
#endif
}

VOID MailEnableWraps(HWND hwnd, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_TEXT1), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_TEXT2), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_MAILWRAP_SPIN), fEnable);
}



const static int c_rgidsFilter[] =
{
    idsTextFileFilter,
        idsHtmlFileFilter,
        idsAllFilesFilter
};
#define CSIGFILTER  (sizeof(c_rgidsFilter) / sizeof(int))

///Signature tab
const static HELPMAP g_rgCtxMapStationery[] = {
    {IDC_SENDFONTSETTINGS, IDH_STATIONERY_FONT_SETTINGS},
    {IDC_RADIOMYFONT, IDH_STATIONERY_MY_FONT},
    {IDC_RADIOUSETHIS, IDH_STATIONERY_USE_STATIONERY},
    {IDC_SELECT, IDH_STATIONERY_SELECT},
    {IDC_VCARD_CHECK, IDH_STATIONERY_ATTACH_BUSINESS_CARD},
    {IDC_VCARD_COMBO, IDH_STATIONERY_ENTER_BUSINESS_CARD},
    {IDC_VCARD_BUTTON_EDIT, IDH_STATIONERY_EDIT_BUSINESS_CARD},
    {IDC_VCARD_BUTTON_NEW, IDH_STATIONERY_NEW_BUSINESS_CARD},
    {0, 0}};
    
    


LRESULT CALLBACK FontSampleSubProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    OPTINFO     *pmoi;
    WNDPROC     pfn;
    HDC         hdc;
    PAINTSTRUCT ps;
    
    pmoi = (OPTINFO *)GetWindowLongPtr(GetParent(hwnd), DWLP_USER);
    Assert(pmoi);
    
    if (msg == WM_PAINT)
    {
        hdc=BeginPaint (hwnd, &ps);
        PaintFontSample(hwnd, hdc, pmoi);
        EndPaint (hwnd, &ps);
        return(0);
    }
    
    pfn = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    Assert(pfn != NULL);
    return(CallWindowProcWrapW(pfn, hwnd, msg, wParam, lParam));
}

typedef struct tagFONTOPTIONS
{
    PROPID color;
    PROPID size;
    PROPID bold;
    PROPID italic;
    PROPID underline;
    PROPID face;
} FONTOPTIONS;

static const FONTOPTIONS c_rgFontOptions[2] =
{
    {
        OPT_MAIL_FONTCOLOR,
        OPT_MAIL_FONTSIZE,
        OPT_MAIL_FONTBOLD,
        OPT_MAIL_FONTITALIC,
        OPT_MAIL_FONTUNDERLINE,
        OPT_MAIL_FONTFACE
    },
    {
        OPT_NEWS_FONTCOLOR,
        OPT_NEWS_FONTSIZE,
        OPT_NEWS_FONTBOLD,
        OPT_NEWS_FONTITALIC,
        OPT_NEWS_FONTUNDERLINE,
        OPT_NEWS_FONTFACE
    }
};

void PaintFontSample(HWND hwnd, HDC hdc, OPTINFO *pmoi)
{
    int                 dcSave=SaveDC(hdc);
    RECT                rc;
    const FONTOPTIONS   *pfo;
    SIZE                rSize;
    INT                 x, y, cbSample;
    HFONT               hFont, hOldFont;
    LOGFONT             lf={0};
    TCHAR               szBuf[LF_FACESIZE+1];
    WCHAR               wszRes[CCHMAX_STRINGRES],
                        wsz[CCHMAX_STRINGRES],
                        wszFontFace[CCHMAX_STRINGRES];
    DWORD               dw, dwSize;
    BOOL                fBold=FALSE,
                        fItalic=FALSE,
                        fUnderline=FALSE;    
    BOOL                fMail;

    *szBuf = 0;
    *wszRes = 0;
    *wsz = 0;

    fMail = GetWindowLong(hwnd, GWL_ID) == IDC_MAIL_FONT_DEMO;
    pfo = fMail ? &c_rgFontOptions[0] : &c_rgFontOptions[1];
    
    dwSize = IDwGetOption(pmoi->pOpt, pfo->size);
    if (dwSize < 8 || dwSize > 72)
    {
        ISetDwOption(pmoi->pOpt, pfo->size, DEFAULT_FONTPIXELSIZE, NULL, 0);
        
        dwSize = DEFAULT_FONTPIXELSIZE;
    }
    
    INT yPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
    lf.lfHeight =-(INT)((9*10*2*yPerInch)/1440);
    
    fBold = IDwGetOption(pmoi->pOpt, pfo->bold);
    fItalic = IDwGetOption(pmoi->pOpt, pfo->italic);
    fUnderline = IDwGetOption(pmoi->pOpt, pfo->underline);
    
    lf.lfWeight = fBold ? FW_BOLD : FW_NORMAL;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DRAFT_QUALITY;
    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfItalic = !!fItalic;
    lf.lfUnderline = !!fUnderline;
    
    IGetOption(pmoi->pOpt, pfo->face, szBuf, sizeof(szBuf));
    
    if (*szBuf != 0)
    {
        StrCpyN(lf.lfFaceName, szBuf, ARRAYSIZE(lf.lfFaceName));
    }
    else
    {
        if(LoadString(g_hLocRes, idsComposeFontFace, szBuf, LF_FACESIZE))
        {
            StrCpyN(lf.lfFaceName, szBuf, ARRAYSIZE(lf.lfFaceName));
            
            ISetOption(pmoi->pOpt, pfo->face, szBuf, lstrlen(szBuf) + 1, NULL, 0);
        }        
    }
    
    hFont=CreateFontIndirect(&lf);
    hOldFont = (HFONT)SelectObject (hdc, hFont);
    
    GetClientRect(hwnd, &rc);
    FillRect (hdc, &rc, GetSysColorBrush(COLOR_3DFACE));
    // pull in the drawing rect by 2 pixels all around
    InflateRect(&rc, -2, -2);
    SetBkMode (hdc, TRANSPARENT);  // So the background shows through the text.
    
    dw = IDwGetOption(pmoi->pOpt, pfo->color);
    SetTextColor (hdc, dw);
    
    LoadStringWrapW(g_hLocRes, idsFontSampleFmt, wszRes, ARRAYSIZE(wszRes));

    *wszFontFace = 0;
    MultiByteToWideChar(CP_ACP, 0, lf.lfFaceName, -1, wszFontFace, ARRAYSIZE(wszFontFace));

    wnsprintfW(wsz, ARRAYSIZE(wsz), wszRes, dwSize, wszFontFace);
    GetTextExtentPoint32AthW(hdc, wsz, lstrlenW(wsz), &rSize, NOFLAGS);
    x = rc.left + (((rc.right-rc.left) / 2) - (rSize.cx / 2));
    y = rc.top + (((rc.bottom-rc.top) / 2) - (rSize.cy / 2));
    ExtTextOutWrapW(hdc, x, y, ETO_CLIPPED, &rc, wsz, lstrlenW(wsz), NULL);
    DeleteObject(SelectObject (hdc, hOldFont));
    RestoreDC(hdc, dcSave);
}


VOID LoadVCardList(HWND hwndCombo, LPTSTR lpszDisplayName)
{
    HRESULT         hr = NOERROR;
    LPWAB           lpWab = NULL;
    int             cRows = 0;
    DWORD           dwIndex=0;
    
    if(hwndCombo==0)
        return;
    
    ComboBox_ResetContent(hwndCombo);
    
    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;
    
    //load names into the combobox from personal address book
    hr = lpWab->HrFillComboWithPABNames(hwndCombo, &cRows);
    if(FAILED(hr))
        goto error;
    
    if(lpszDisplayName)
        dwIndex = ComboBox_SelectString(hwndCombo, -1, lpszDisplayName);
    
error:
    ReleaseObj(lpWab);
}
    
BOOL UpdateVCardOptions(HWND hwnd, BOOL fMail, OPTINFO* pmoi)
{
    HWND    hDlg;
    DWORD   dw;
    int     cch;
    TCHAR*  sz;
    
    dw = ButtonChkToOptInfo(hwnd, fMail ? IDC_MAIL_VCARD : IDC_NEWS_VCARD, pmoi, fMail ? OPT_MAIL_ATTACHVCARD : OPT_NEWS_ATTACHVCARD);
    
    hDlg = GetDlgItem(hwnd, fMail ? IDC_MAIL_VCARD_SELECT : IDC_NEWS_VCARD_SELECT);
    cch = GetWindowTextLength(hDlg);
    Assert(dw == 0 || cch > 0);
    
    cch++;
    if (!MemAlloc((void **)&sz, cch * sizeof(TCHAR)))
        return(TRUE);
    
    cch = ComboBox_GetText(hDlg, sz, cch) + 1;
    ISetOption(pmoi->pOpt, fMail ? OPT_MAIL_VCARDNAME : OPT_NEWS_VCARDNAME, sz, cch, NULL, 0);
    
    MemFree(sz);    
    return(FALSE);
}
    
// The rest of file is in options2.cpp
HRESULT VCardNewEntry(HWND hwnd)
{
    HRESULT         hr = NOERROR;
    LPWAB           lpWab = NULL;
    TCHAR           szName[MAX_PATH] = {0};
    HWND            hwndCombo = NULL;
    UINT            cb = 0;
    
    hwndCombo = GetDlgItem(hwnd, IDC_VCARD_COMBO);
    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        goto error;
    
    //load names into the combobox from personal address book
    hr = lpWab->HrNewEntry(hwnd, szName, ARRAYSIZE(szName));
    if(FAILED(hr))
        goto error;
    
    // reload the vcard list.
    LoadVCardList(hwndCombo, szName);
    
error:
    ReleaseObj(lpWab);
    return hr;
}
    
HRESULT VCardEdit(HWND hwnd, DWORD idc, DWORD idcOther)
{
    HWND            hwndCombo, hwndOther;
    HRESULT         hr;
    LPWAB           lpWab = NULL;
    TCHAR           szName[MAX_PATH], szPrev[MAX_PATH], szOther[MAX_PATH];
    UINT            cb;
    
    hwndCombo = GetDlgItem(hwnd, idc);
    cb = GetWindowText(hwndCombo, szName, sizeof(szName));
    Assert(cb > 0);
    StrCpyN(szPrev, szName, ARRAYSIZE(szPrev));

    hr = HrCreateWabObject(&lpWab);
    if(FAILED(hr))
        return(hr);
    
    //load names into the combobox from personal address book
    hr = lpWab->HrEditEntry(hwnd, szName, ARRAYSIZE(szName));
    if(SUCCEEDED(hr))
    {
        if (0 != lstrcmp(szName, szPrev))
        {
            hwndOther = GetDlgItem(hwnd, idcOther);
            cb = GetWindowText(hwndOther, szOther, ARRAYSIZE(szOther));
            if (cb > 0)
            {
                if (0 == lstrcmp(szOther, szPrev))
                    LoadVCardList(hwndOther, szName);
                else
                    LoadVCardList(hwndOther, szOther);
            }            
            else
            {
                LoadVCardList(hwndOther, NULL);
            }

            // reload the vcard list.
            LoadVCardList(hwndCombo, szName);
        }
    }
    
    ReleaseObj(lpWab);
    return hr;
}

void _SetThisStationery(HWND hwnd, BOOL fMail, LPWSTR wsz, OPTINFO* pmoi)
{
    HWND        hDlg;
    WCHAR       wszBuf[MAX_PATH];
    WCHAR       wszCompact[MAX_SHOWNAME+1];
    
    *wszBuf = 0;
    *wszCompact = 0;

    hDlg = GetDlgItem(hwnd, fMail ? IDC_MAIL_STATIONERY : IDC_NEWS_STATIONERY);
    SetIntlFont(hDlg);
    if (wsz != NULL)
    {
        StrCpyNW(wszBuf, wsz, ARRAYSIZE(wszBuf));
        GetStationeryFullName(wszBuf);
        if (*wszBuf == 0)
            goto reset;
        
        StripStationeryDir(wszBuf);
        PathRemoveExtensionW(wszBuf);
        PathCompactPathExW(wszCompact, wszBuf, MAX_SHOWNAME, 0);
        SetWindowTextWrapW(hDlg, wszCompact);
        return;
    }
    
reset:
    SetDefaultStationeryName(fMail, wszBuf);
    ISetDwOption(pmoi->pOpt, fMail ? OPT_MAIL_USESTATIONERY :  OPT_NEWS_USESTATIONERY, 
                 FALSE, NULL, 0);

    SetWindowText(hDlg, "");
    return;
}

INT_PTR CALLBACK CacheCleanUpDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    FOLDERINFO Folder;
    FOLDERID idFolder;
    RECURSEFLAGS dwRecurse=RECURSE_INCLUDECURRENT | RECURSE_ONLYSUBSCRIBED | RECURSE_SUBFOLDERS | RECURSE_NOLOCALSTORE;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
        
            // Initialzie the Folder Combo Box
            InitFolderPickerEdit(GetDlgItem(hwnd, IDC_CACHE_FOLDER), FOLDERID_ROOT);
        
            // Display Folder Size Info
            DisplayFolderSizeInfo(hwnd, dwRecurse, FOLDERID_ROOT);
        
            // Done
            return 1;
        
        case WM_DESTROY:
            return 0;
        
        case WM_CLOSE:
            EndDialog(hwnd, IDOK);
            return 1;
        
        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam,lParam))
            {
                case IDCANCEL:
                    SendMessage (hwnd, WM_CLOSE, 0, 0);
                    return 1;
            
                case IDC_FOLDER_BROWSE:
                    if (GET_WM_COMMAND_CMD(wParam,lParam) == BN_CLICKED)
                    {
                        // Pick a Folder
                        if (SUCCEEDED(PickFolderInEdit(hwnd, GetDlgItem(hwnd, IDC_CACHE_FOLDER), TREEVIEW_NOLOCAL, NULL, NULL, &idFolder)))
                        {
                            // Display Folder Size Info
                            DisplayFolderSizeInfo(hwnd, dwRecurse, idFolder);
                        }
                    }
                    return 1;
            
                case idbCompactCache:
                    if (SUCCEEDED(g_pStore->GetFolderInfo(GetFolderIdFromEdit(GetDlgItem(hwnd, IDC_CACHE_FOLDER)), &Folder)))
                    {
                        CleanupFolder(hwnd, dwRecurse, Folder.idFolder, CLEANUP_COMPACT);
                        DisplayFolderSizeInfo(hwnd, dwRecurse, Folder.idFolder);
                        g_pStore->FreeRecord(&Folder);
                    }
                    return 1;
            
                case idbRemove:
                case idbDelete:
                case idbReset:
                    if (SUCCEEDED(g_pStore->GetFolderInfo(GetFolderIdFromEdit(GetDlgItem(hwnd, IDC_CACHE_FOLDER)), &Folder)))
                    {
                        // Locals
                        CHAR szRes[255];
                        CHAR szMsg[255 + 255];
                
                        // Get Command
                        UINT                idCommand=GET_WM_COMMAND_ID(wParam, lParam);
                        UINT                idString;
                        CLEANUPFOLDERTYPE   tyCleanup;
                
                        // Remove
                        if (idbRemove == idCommand)
                            tyCleanup = CLEANUP_REMOVEBODIES;
                        else if (idbDelete == idCommand)
                            tyCleanup = CLEANUP_DELETE;
                        else
                            tyCleanup = CLEANUP_RESET;
                
                        // Root
                        if (FOLDERID_ROOT == Folder.idFolder)
                        {
                            // Determine Warning String
                            if (idbRemove == idCommand)
                                idString = idsConfirmDelBodiesAll;
                            else if (idbDelete == idCommand)
                                idString = idsConfirmDelMsgsAll;
                            else
                                idString = idsConfirmResetAll;
                    
                            // Confirm
                            if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idString), NULL, MB_YESNO | MB_ICONEXCLAMATION))
                                return(1);
                        }
                
                        // Server
                        else if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
                        {
                            // Determine Warning String
                            if (idbRemove == idCommand)
                                idString = idsConfirmDelBodiesStore;
                            else if (idbDelete == idCommand)
                                idString = idsConfirmDelMsgsStore;
                            else
                                idString = idsConfirmResetStore;
                    
                            // Load the String
                            AthLoadString(idString, szRes, ARRAYSIZE(szRes));
                    
                            // Format with the Folder Name
                            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, Folder.pszName);
                    
                            // Confirm
                            if (IDNO == AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szMsg, NULL, MB_YESNO | MB_ICONEXCLAMATION))
                                return(1);
                        }
                
                        // Folder
                        else
                        {
                            // Determine Warning String
                            if (idbRemove == idCommand)
                                idString = idsConfirmDelBodies;
                            else if (idbDelete == idCommand)
                                idString = idsConfirmDelMsgs;
                            else
                                idString = idsConfirmReset;
                    
                            // Load the String
                            AthLoadString(idString, szRes, ARRAYSIZE(szRes));
                    
                            // Format with the Folder Name
                            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, Folder.pszName);
                    
                            // Confirm
                            if (IDNO == AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szMsg, NULL, MB_YESNO | MB_ICONEXCLAMATION))
                                return(1);
                        }
                
                        // Recurse
                        CleanupFolder(hwnd, dwRecurse, Folder.idFolder, tyCleanup);
                
                        // Display Folder Size Info
                        DisplayFolderSizeInfo(hwnd, dwRecurse, (FOLDERID)Folder.idFolder);
                
                        // Cleanup
                        g_pStore->FreeRecord(&Folder);
                    }
                    return 1;
            
                case IDOK:
                    EndDialog(hwnd, IDOK);
                    return 1;
            }
            break;
    }
    
    return 0;
}

// before calling always ensure poi contains valid HTML settings
// else we assert...
void HtmlOptFromMailOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    pHtmlOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_ENCODE);
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    AssertSz(pHtmlOpt->ietEncoding == IET_QP || pHtmlOpt->ietEncoding == IET_BASE64, "Illegal HTML encoding type");
#endif
    pHtmlOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_ALLOW_8BIT);
    pHtmlOpt->fSendImages = IDwGetOption(poi->pOpt, OPT_MAIL_SENDINLINEIMAGES);
    pHtmlOpt->uWrap = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_LINE_WRAP);
    pHtmlOpt->fIndentReply = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_HTML_INDENT_REPLY);
}

void MailOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_ENCODE, (DWORD)pHtmlOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_ALLOW_8BIT, pHtmlOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_SENDINLINEIMAGES, pHtmlOpt->fSendImages, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_LINE_WRAP, pHtmlOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_HTML_INDENT_REPLY, pHtmlOpt->fIndentReply, NULL, 0);
}

void PlainOptFromMailOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    pPlainOpt->fMime = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_MIME);
    pPlainOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ENCODE);
    pPlainOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ALLOW_8BIT);
    pPlainOpt->uWrap = IDwGetOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_LINE_WRAP);
    pPlainOpt->chQuote = (CHAR)IDwGetOption(poi->pOpt, OPT_MAILINDENT);
}

void MailOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_MIME, pPlainOpt->fMime, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ENCODE, (DWORD)pPlainOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_ALLOW_8BIT, pPlainOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAIL_MSG_PLAIN_LINE_WRAP, pPlainOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_MAILINDENT, pPlainOpt->chQuote, NULL, 0);
}

// before calling always ensure poi contains valid HTML settings
// else we assert...
void HtmlOptFromNewsOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    pHtmlOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_ENCODE);
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    Assert(pHtmlOpt->ietEncoding == IET_QP || pHtmlOpt->ietEncoding == IET_BASE64);
#endif
    pHtmlOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_ALLOW_8BIT);
    pHtmlOpt->fSendImages = IDwGetOption(poi->pOpt, OPT_NEWS_SENDINLINEIMAGES);
    pHtmlOpt->uWrap = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_LINE_WRAP);
    pHtmlOpt->fIndentReply = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_HTML_INDENT_REPLY);
}

void NewsOptFromHtmlOpt(LPHTMLOPT pHtmlOpt, OPTINFO *poi)
{
    Assert(pHtmlOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_ENCODE, (DWORD)pHtmlOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_ALLOW_8BIT, pHtmlOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_SENDINLINEIMAGES, pHtmlOpt->fSendImages, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_LINE_WRAP, pHtmlOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_HTML_INDENT_REPLY, pHtmlOpt->fIndentReply, NULL, 0);
}

void PlainOptFromNewsOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    pPlainOpt->fMime = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_MIME);
    pPlainOpt->ietEncoding = (ENCODINGTYPE)IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ENCODE);
    pPlainOpt->f8Bit = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ALLOW_8BIT);
    pPlainOpt->uWrap = IDwGetOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_LINE_WRAP);
    pPlainOpt->chQuote = (CHAR)IDwGetOption(poi->pOpt, OPT_NEWSINDENT);
}

void NewsOptFromPlainOpt(LPPLAINOPT pPlainOpt, OPTINFO *poi)
{
    Assert(pPlainOpt);
    Assert(poi);
    
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_MIME, pPlainOpt->fMime, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ENCODE, (DWORD)pPlainOpt->ietEncoding, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_ALLOW_8BIT, pPlainOpt->f8Bit, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWS_MSG_PLAIN_LINE_WRAP, pPlainOpt->uWrap, NULL, 0);
    ISetDwOption(poi->pOpt, OPT_NEWSINDENT, pPlainOpt->chQuote, NULL, 0);
    
}

BOOL FGetHTMLOptions(HWND hwndParent, LPHTMLOPT pHtmlOpt)
{
    return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddHTMLSettings),
        hwndParent, HTMLSettingsDlgProc, (LPARAM)pHtmlOpt)==IDOK);
}

BOOL FGetPlainOptions(HWND hwndParent, LPPLAINOPT pPlainOpt)
{
    return (DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddPlainSettings),
        hwndParent, PlainSettingsDlgProc, (LPARAM)pPlainOpt)==IDOK);
}

const static HELPMAP g_rgCtxMapSettings[] = {
    {IDC_MIME_RADIO, IDH_NEWSMAIL_SEND_ADVSET_MIME},
    {IDC_UUENCODE_RADIO, IDH_NEWSMAIL_SEND_ADVSET_UUENCODE},
    {IDC_MAILWRAP_EDIT, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_MAILWRAP_SPIN, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_ENCODE_COMBO, IDH_NEWSMAIL_SEND_ADVSET_ENCODE_WITH},
    {IDC_8BIT_HEADER, IDH_SEND_SETTING_8BIT_HEADINGS},
    {IDC_MAILWRAP_TEXT1, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_MAILWRAP_TEXT2, IDH_NEWSMAIL_SEND_ADVSET_WRAP_80_CHAR},
    {IDC_SENDIMAGES, IDH_OPTIONS_SEND_SETTINGS_SEND_PICTURE},
    {IDC_INDENTREPLY_CHECK, 502066},
    {idcStatic1, 353540},
    {IDC_INDENT_CHECK, 502067},
    {IDC_INDENT_COMBO, 502067},
    {idcStaticReplying, 502067},
    {idcStatic2, IDH_NEWS_COMM_GROUPBOX},
    {0,0}};
    
INT_PTR CALLBACK PlainSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD dw;
    BOOL fMime;
    HWND hwndT;
    UINT id,  code;
    LPPLAINOPT   pPlainOpt;
    ENCODINGTYPE ietEncoding;
    
    pPlainOpt = (LPPLAINOPT)GetWindowLongPtr(hwnd, DWLP_USER);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CenterDialog(hwnd);
        
        Assert(pPlainOpt == NULL);
        pPlainOpt = (LPPLAINOPT)lParam;
        Assert(pPlainOpt);
        SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pPlainOpt);
        
        if (pPlainOpt->fMime && (pPlainOpt->ietEncoding == IET_QP || pPlainOpt->ietEncoding == IET_BASE64))
            MailEnableWraps(hwnd, FALSE);
        
        hwndT = GetDlgItem(hwnd, IDC_ENCODE_COMBO);
        FillEncodeCombo(hwndT, FALSE, pPlainOpt->ietEncoding);
        
        CheckDlgButton(hwnd, pPlainOpt->fMime ? IDC_MIME_RADIO : IDC_UUENCODE_RADIO, BST_CHECKED);
        
        InitIndentOptions(pPlainOpt->chQuote, hwnd, IDC_INDENT_CHECK, IDC_INDENT_COMBO);
        
        CheckDlgButton (hwnd, IDC_8BIT_HEADER, pPlainOpt->f8Bit ? 1 : 0);
        if (pPlainOpt->fMime == FALSE)
        {
            EnableWindow (GetDlgItem (hwnd, IDC_8BIT_HEADER), FALSE);
            EnableWindow (GetDlgItem (hwnd, IDC_ENCODE_COMBO), FALSE);
            EnableWindow (GetDlgItem (hwnd, idcStatic1), FALSE);
        }
        
        dw = pPlainOpt->uWrap;
        // this is to handle change in option... it was previously true/false
        // now it is a count of columns for wrapping or OPTION_OFF
        if (dw == 0 || dw == 1 || dw == OPTION_OFF)
            dw = DEF_AUTOWRAP;
        
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_SPIN, UDM_SETRANGE, 0, MAKELONG(AUTOWRAP_MAX, AUTOWRAP_MIN));
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_EDIT, EM_LIMITTEXT, 3, 0);
        SetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, dw, FALSE);
        return(TRUE);
        
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapSettings);
        
    case WM_COMMAND:
        id = GET_WM_COMMAND_ID(wParam,lParam);
        code = GET_WM_COMMAND_CMD(wParam, lParam);
        
        switch (id)
        {
        case IDC_ENCODE_COMBO:
            if (code == CBN_SELCHANGE)
            {
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
                ENCODINGTYPE ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
                if (ietEncoding == IET_QP || ietEncoding == IET_BASE64)
                    MailEnableWraps(hwnd, FALSE);
                else
                    MailEnableWraps(hwnd, TRUE);
            }
            break;
            
        case IDC_INDENT_CHECK:
            if (code == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_INDENT_COMBO),
                    SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == BST_CHECKED);
            }
            break;
            
        case idcIndentReply:
            if (code == BN_CLICKED)
            {
                EnableWindow(GetDlgItem(hwnd, idcIndentChar),
                    SendMessage((HWND)lParam, BM_GETCHECK, 0, 0) == BST_CHECKED);
            }
            break;
            
        case IDC_MIME_RADIO:
        case IDC_UUENCODE_RADIO:
            
            if (id == IDC_UUENCODE_RADIO)
            {
                EnableWindow (GetDlgItem (hwnd, IDC_8BIT_HEADER), FALSE);
                EnableWindow (GetDlgItem (hwnd, IDC_ENCODE_COMBO), FALSE);
                EnableWindow (GetDlgItem (hwnd, idcStatic1), FALSE);
                MailEnableWraps(hwnd, TRUE);
            }
            else
            {
                EnableWindow (GetDlgItem (hwnd, IDC_8BIT_HEADER), TRUE);
                EnableWindow (GetDlgItem (hwnd, IDC_ENCODE_COMBO), TRUE);
                EnableWindow (GetDlgItem (hwnd, idcStatic1), TRUE);
                
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
                ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
                if (ietEncoding == IET_QP || ietEncoding == IET_BASE64)
                    MailEnableWraps(hwnd, FALSE);
                else
                    MailEnableWraps(hwnd, TRUE);
            }
            break;
            
        case IDOK:
            fMime = (IsDlgButtonChecked(hwnd, IDC_MIME_RADIO) == BST_CHECKED);
            
            dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
            ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
            
            if (!(fMime && (ietEncoding == IET_QP || ietEncoding == IET_BASE64)))
            {
                dw = GetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, NULL, FALSE);
                if (dw > AUTOWRAP_MAX || dw < AUTOWRAP_MIN)
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsOptions), MAKEINTRESOURCEW(idsEnterAutoWrap), NULL, MB_OK | MB_ICONEXCLAMATION);
                    SendMessage(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT), EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT));
                    return TRUE;
                }
                
                pPlainOpt->uWrap = dw;
            }
            
            pPlainOpt->fMime = fMime;
            
            pPlainOpt->ietEncoding = ietEncoding;
            
            pPlainOpt->f8Bit = (IsDlgButtonChecked(hwnd, IDC_8BIT_HEADER) == BST_CHECKED);
            
            if ((IsDlgButtonChecked(hwnd, IDC_INDENT_CHECK) == BST_CHECKED))
            {
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_INDENT_COMBO, CB_GETCURSEL, 0, 0);
                pPlainOpt->chQuote = (CHAR)c_szQuoteChars[dw];
            }
            else
                pPlainOpt->chQuote = INDENTCHAR_NONE;
            
            // fall through...
            
        case IDCANCEL:
            EndDialog(hwnd, id);
            return(TRUE);
        }
        break;
        
        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);
            
    }
    
    return (FALSE);
}

INT_PTR CALLBACK HTMLSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD       dw;
    HWND        hwndT;
    UINT        id;
    LPHTMLOPT   pHtmlOpt;
    ENCODINGTYPE ietEncoding;
    
    pHtmlOpt= (LPHTMLOPT)GetWindowLongPtr(hwnd, DWLP_USER);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        CenterDialog(hwnd);
        
        Assert(pHtmlOpt==NULL);
        pHtmlOpt = (LPHTMLOPT)lParam;
        Assert(pHtmlOpt);
        SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pHtmlOpt);
        
        hwndT = GetDlgItem(hwnd, IDC_ENCODE_COMBO);
        FillEncodeCombo(hwndT, TRUE, pHtmlOpt->ietEncoding);
        
        CheckDlgButton (hwnd, IDC_8BIT_HEADER, pHtmlOpt->f8Bit);
        CheckDlgButton (hwnd, IDC_SENDIMAGES, pHtmlOpt->fSendImages);
        CheckDlgButton (hwnd, IDC_INDENTREPLY_CHECK, pHtmlOpt->fIndentReply);
        
        if (pHtmlOpt->ietEncoding == IET_QP || pHtmlOpt->ietEncoding == IET_BASE64)
            MailEnableWraps(hwnd, FALSE);
        else
            MailEnableWraps(hwnd, TRUE);
        
        dw = pHtmlOpt->uWrap;
        // this is to handle change in option... it was previously true/false
        // now it is a count of columns for wrapping or OPTION_OFF
        if (dw == 0 || dw == 1 || dw == OPTION_OFF)
            dw = DEF_AUTOWRAP;
        
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_SPIN, UDM_SETRANGE, 0, MAKELONG(AUTOWRAP_MAX, AUTOWRAP_MIN));
        SendDlgItemMessage(hwnd, IDC_MAILWRAP_EDIT, EM_LIMITTEXT, 3, 0);
        SetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, dw, FALSE);
        return(TRUE);
        
    case WM_HELP:
    case WM_CONTEXTMENU:
        return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapSettings);
        
    case WM_COMMAND:
        id = GET_WM_COMMAND_ID(wParam,lParam);
        
        switch (id)
        {
        case IDC_ENCODE_COMBO:
            if (GET_WM_COMMAND_CMD(wParam,lParam) == CBN_SELCHANGE)
            {
                dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
                ENCODINGTYPE ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
                if (ietEncoding == IET_QP || ietEncoding == IET_BASE64)
                    MailEnableWraps(hwnd, FALSE);
                else
                    MailEnableWraps(hwnd, TRUE);
            }
            break;
            
        case IDOK:
            dw = (DWORD) SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETCURSEL, 0, 0);
            ietEncoding = (ENCODINGTYPE)SendDlgItemMessage(hwnd, IDC_ENCODE_COMBO, CB_GETITEMDATA, dw, 0);
            
            if (!(ietEncoding == IET_QP || ietEncoding == IET_BASE64))
            {
                dw = GetDlgItemInt(hwnd, IDC_MAILWRAP_EDIT, NULL, FALSE);
                if (dw > AUTOWRAP_MAX || dw < AUTOWRAP_MIN)
                {
                    AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsOptions), MAKEINTRESOURCEW(idsEnterAutoWrap), NULL, MB_OK | MB_ICONEXCLAMATION);
                    SendMessage(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT), EM_SETSEL, 0, -1);
                    SetFocus(GetDlgItem(hwnd, IDC_MAILWRAP_EDIT));
                    return TRUE;
                }
                
                pHtmlOpt->uWrap = dw;
            }
            
            pHtmlOpt->ietEncoding = ietEncoding;
            
            pHtmlOpt->f8Bit=(IsDlgButtonChecked(hwnd, IDC_8BIT_HEADER) == BST_CHECKED);
            pHtmlOpt->fSendImages=(IsDlgButtonChecked(hwnd, IDC_SENDIMAGES) == BST_CHECKED);
            pHtmlOpt->fIndentReply=(IsDlgButtonChecked(hwnd, IDC_INDENTREPLY_CHECK) == BST_CHECKED);
            // fall through...
            
        case IDCANCEL:
            EndDialog(hwnd, id);
            return(TRUE);
        }
        break;
        
        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);
            
    }
    return (FALSE);
}

const static HELPMAP g_rgCtxMapAdvSec[] = 
{
    {IDC_ENCRYPT_FOR_SELF, IDH_SECURITY_ADVANCED_INCLUDE_SELF},
    {IDC_INCLUDECERT_CHECK, IDH_SECURITY_ADVANCED_INCLUDE_ID},
    {IDC_OPAQUE_SIGN, IDH_SECURITY_ADVANCED_INCLUDE_PKCS},
    {IDC_AUTO_ADD_SENDERS_CERT_TO_WAB, 355528},
    {IDC_ENCRYPT_WARN_COMBO, 355527},
    {IDC_REVOKE_ONLINE_ONLY, 355529},
    {IDC_REVOKE_NEVER, 355531},
    {idcStatic1, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6, IDH_NEWS_COMM_GROUPBOX},
    {IDC_ENCRYPT_ICON, IDH_NEWS_COMM_GROUPBOX},
    {IDC_SIGNED_ICON, IDH_NEWS_COMM_GROUPBOX},
    {IDC_CERT_ICON, IDH_NEWS_COMM_GROUPBOX},
    {0,0}
};

    
INT_PTR CALLBACK AdvSecurityDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    OPTINFO *poi;
    
    poi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);
    
    switch (message)
    {
        case WM_INITDIALOG:
            CenterDialog(hwnd);
        
            // save our cookie pointer
            Assert(poi == NULL);
            poi = (OPTINFO *)lParam;
            Assert(poi != NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)poi);
        
            // Set the images correctly
            HIMAGELIST himl;
            himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbPaneBar32Hot),
                30, 0, RGB(255, 0, 255));
            if (himl)
            {
                HICON hIcon = ImageList_ExtractIcon(g_hLocRes, himl, 0);
                SendDlgItemMessage(hwnd, IDC_ENCRYPT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
            
                hIcon = ImageList_ExtractIcon(g_hLocRes, himl, 1);
                SendDlgItemMessage(hwnd, IDC_SIGNED_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
            
                hIcon = ImageList_ExtractIcon(g_hLocRes, himl, 6);
                SendDlgItemMessage(hwnd, IDC_CERT_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
            
                ImageList_Destroy(himl);
            }
        
            // set initial state of controls
            AdvSec_FillEncWarnCombo(hwnd, poi);
        
            ButtonChkFromOptInfo(hwnd, IDC_INCLUDECERT_CHECK, poi, OPT_MAIL_INCLUDECERT);
        
            // Encrypt for myself
            CheckDlgButton(hwnd, IDC_ENCRYPT_FOR_SELF, (0 == IDwGetOption(poi->pOpt, OPT_NO_SELF_ENCRYPT)) ? BST_CHECKED : BST_UNCHECKED);
        
            // Opaque signing
            ButtonChkFromOptInfo(hwnd, IDC_OPAQUE_SIGN, poi, OPT_OPAQUE_SIGN);
        
            // Opaque signing
            ButtonChkFromOptInfo(hwnd, IDC_AUTO_ADD_SENDERS_CERT_TO_WAB, poi, OPT_AUTO_ADD_SENDERS_CERT_TO_WAB);

            CheckDlgButton(hwnd, IDC_REVOKE_ONLINE_ONLY, (0 == IDwGetOption(poi->pOpt, OPT_REVOKE_CHECK)) ? BST_UNCHECKED : BST_CHECKED);
            CheckDlgButton(hwnd, IDC_REVOKE_NEVER, (0 != IDwGetOption(poi->pOpt, OPT_REVOKE_CHECK)) ? BST_UNCHECKED : BST_CHECKED);
        
            return(TRUE);
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapAdvSec);
        
        case WM_COMMAND:
            if (poi == NULL)
                break;

            switch (LOWORD(wParam))
            {
                case IDOK:
                    {
                        BOOL fDontEncryptForSelf;
                
                        // update the registry based on states of the controls
                        // BUG: #33047, don't use global options now
                        ButtonChkToOptInfo(hwnd, IDC_INCLUDECERT_CHECK, poi, OPT_MAIL_INCLUDECERT);
                
                        // Opaque signing is stored in registry
                        fDontEncryptForSelf = !(IsDlgButtonChecked(hwnd, IDC_ENCRYPT_FOR_SELF) == BST_CHECKED);
                        ISetDwOption(poi->pOpt, OPT_NO_SELF_ENCRYPT, fDontEncryptForSelf, NULL, 0);
                
                        // Opaque signing is stored in registry
                        ButtonChkToOptInfo(hwnd, IDC_OPAQUE_SIGN, poi, OPT_OPAQUE_SIGN);
                
                        // Opaque signing is stored in registry
                        ButtonChkToOptInfo(hwnd, IDC_AUTO_ADD_SENDERS_CERT_TO_WAB, poi, OPT_AUTO_ADD_SENDERS_CERT_TO_WAB);

                        // Revocation checking
                        ButtonChkToOptInfo(hwnd, IDC_REVOKE_ONLINE_ONLY, poi, OPT_REVOKE_CHECK);

                        // Get encryption warning strenght into registry
                        AdvSec_GetEncryptWarnCombo(hwnd, poi);
                    }
            
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);

                case IDC_REVOKE_NEVER:
                    CheckDlgButton(hwnd, IDC_REVOKE_ONLINE_ONLY, BST_UNCHECKED);
                    CheckDlgButton(hwnd, IDC_REVOKE_NEVER, BST_CHECKED);
                    break;

                case IDC_REVOKE_ONLINE_ONLY:
                    CheckDlgButton(hwnd, IDC_REVOKE_ONLINE_ONLY, BST_CHECKED);
                    CheckDlgButton(hwnd, IDC_REVOKE_NEVER, BST_UNCHECKED);
                    break;
            }
        
            break; // wm_command
        
            case WM_CLOSE:
                SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
                return (TRUE);
            
    } // message switch
    return(FALSE);
}
    
void ButtonChkFromOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, ULONG opt)
{
    Assert(poi != NULL);
    CheckDlgButton(hwnd, idc, (!!IDwGetOption(poi->pOpt, opt)) ? BST_CHECKED : BST_UNCHECKED);
}

BOOL ButtonChkToOptInfo(HWND hwnd, UINT idc, OPTINFO *poi, ULONG opt)
{
    register BOOL f = (IsDlgButtonChecked(hwnd, idc) == BST_CHECKED);
    Assert(poi != NULL);
    ISetDwOption(poi->pOpt, opt, f, NULL, 0);
    
    return(f);
}
    
// These are the bit-strength values that will show up in our drop down.

const ULONG BitStrengthValues[5] = {
    168,
    128,
    64,
    56,
    40
};
const ULONG CBitStrengthValues = sizeof(BitStrengthValues) / sizeof(ULONG);

BOOL AdvSec_FillEncWarnCombo(HWND hwnd, OPTINFO *poi)
{
    HRESULT hr;
    PROPVARIANT var;
    ULONG ulHighestStrength;
    ULONG ulCurrentStrength = 0;
    ULONG i, j;
    ULONG k = 0;
    
    // Get the default lcaps blob from the registry
    hr = poi->pOpt->GetProperty(MAKEPROPSTRING(OPT_MAIL_ENCRYPT_WARN_BITS), &var, 0);
    
    if (SUCCEEDED(hr)) {
        Assert(var.vt == VT_UI4);
        ulCurrentStrength = var.ulVal;
    }
    
    // Get the available encryption algorithms from the available providers.
    ulHighestStrength = GetHighestEncryptionStrength();
    if (! ulCurrentStrength) {  // default to highest available
        ulCurrentStrength = ulHighestStrength;
    }
    
    for (i = 0; i < CBitStrengthValues; i++)
    {
        if (BitStrengthValues[i] <= ulHighestStrength)
        {
            // Add it to the list
            // LPTSTR lpString = NULL;
            // DWORD rgdw[1] = {BitStrengthValues[i]};
            TCHAR szBuffer[100];    // really ought to be big enough
            TCHAR szTmp[256] = _T("");;
            
            LoadString(g_hLocRes, idsBitStrength, szBuffer, ARRAYSIZE(szBuffer));
            
            if (szBuffer[0])
            {
#ifdef OLD
                FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    szBuffer,
                    0, 0,
                    (LPTSTR)&lpString, 0, (va_list *)rgdw);
#endif
                wnsprintf(szTmp, ARRAYSIZE(szTmp), szBuffer, BitStrengthValues[i]);
            }
            
            if (szTmp[0])
            {
                j = (ULONG) SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_ADDSTRING, 0, (LPARAM)szTmp/*lpString*/);
                // Item data is the bit strength
                SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_SETITEMDATA, j, BitStrengthValues[i]);
                if (ulCurrentStrength == BitStrengthValues[i])
                {
                    SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_SETCURSEL, (WPARAM)j, 0);
                }
            }
            // LocalFree(lpString);
            // lpString = NULL;
        }
    }
    
    return(SUCCEEDED(hr));
}
    
    
BOOL AdvSec_GetEncryptWarnCombo(HWND hwnd, OPTINFO *poi)
{
    HRESULT hr;
    ULONG i;
    ULONG ulStrength = 0;
    ULONG ulHighestStrength;
    PROPVARIANT var;
    
    // What item is selected?
    i = (ULONG) SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_GETCURSEL, 0, 0);
    if (i != CB_ERR) {
        ulStrength = (ULONG) SendDlgItemMessageA(hwnd, IDC_ENCRYPT_WARN_COMBO, CB_GETITEMDATA, (WPARAM)i, 0);
    }
    
    // If the strength is the highest available, then set this to the default value.
    ulHighestStrength = GetHighestEncryptionStrength();
    if (ulHighestStrength == ulStrength) {
        ulStrength = 0;
    }
    
    // Set the default value to the registry
    var.vt = VT_UI4;
    var.ulVal = ulStrength;
    hr = poi->pOpt->SetProperty(MAKEPROPSTRING(OPT_MAIL_ENCRYPT_WARN_BITS), &var, 0);
    
    return(SUCCEEDED(hr));
}

    
BOOL ChangeSendFontSettings(OPTINFO *pmoi, BOOL fMail, HWND hwnd)
{
    const FONTOPTIONS *pfo;
    CHOOSEFONT  cf;
    LOGFONT     logfont;
    HDC         hdc;
    LONG        yPerInch;
    DWORD       dwColor, dwSize;
    BOOL        fRet = FALSE,
        fBold,
        fItalic,
        fUnderline;
    
    Assert(pmoi != NULL);
    Assert(hwnd != NULL);
    
    ZeroMemory(&logfont, sizeof(LOGFONT));
    
    pfo = fMail ? &c_rgFontOptions[0] : &c_rgFontOptions[1];
    
    dwColor     = IDwGetOption(pmoi->pOpt, pfo->color);
    dwSize      = IDwGetOption(pmoi->pOpt, pfo->size);
    fBold       = IDwGetOption(pmoi->pOpt, pfo->bold);
    fItalic     = IDwGetOption(pmoi->pOpt, pfo->italic);
    fUnderline  = IDwGetOption(pmoi->pOpt, pfo->underline);
    
    logfont.lfWeight = fBold ? FW_BOLD : FW_NORMAL;
    logfont.lfItalic = !!fItalic;
    logfont.lfUnderline = !!fUnderline;
    
    IGetOption(pmoi->pOpt, pfo->face, logfont.lfFaceName, sizeof(logfont.lfFaceName));
    
    hdc = GetDC(hwnd);
    yPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(hwnd, hdc);
    
    if (dwSize)
        logfont.lfHeight = -(INT)((dwSize*10*2*yPerInch)/1440);
    
    if (dwColor)
        cf.rgbColors = dwColor;
    
    cf.lStructSize      = sizeof(CHOOSEFONT);
    cf.hwndOwner        = hwnd;
    cf.hDC              = NULL;
    cf.lpLogFont        = &logfont;
    cf.Flags            = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS | CF_ENABLEHOOK |
        CF_EFFECTS | CF_LIMITSIZE | CF_NOVERTFONTS | CF_NOSCRIPTSEL;
    cf.lCustData        = 0;
    cf.lpfnHook         = (LPOFNHOOKPROC)FChooseFontHookProc;
    cf.lpTemplateName   = NULL;
    cf.hInstance        = NULL;
    cf.nFontType        = REGULAR_FONTTYPE | SCREEN_FONTTYPE;
    cf.nSizeMin         = 8;
    cf.nSizeMax         = 36;
    
    if (fRet = ChooseFont(&cf))
    {
        ISetDwOption(pmoi->pOpt, pfo->color, cf.rgbColors, NULL, 0);
        ISetDwOption(pmoi->pOpt, pfo->size, cf.iPointSize/10, NULL, 0);
        
        ISetDwOption(pmoi->pOpt, pfo->bold, logfont.lfWeight == FW_BOLD, NULL, 0);
        ISetDwOption(pmoi->pOpt, pfo->italic, !!logfont.lfItalic, NULL, 0);
        ISetDwOption(pmoi->pOpt, pfo->underline, !!logfont.lfUnderline, NULL, 0);
        
        ISetOption(pmoi->pOpt, pfo->face, logfont.lfFaceName, lstrlen(logfont.lfFaceName) + 1, NULL, 0);
    }
    
    return fRet;
}
    
INT_PTR CALLBACK FChooseFontHookProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        CenterDialog(hwnd);
        EnableWindow(GetDlgItem(hwnd, 1040), FALSE);
        break;
    }
    return(FALSE);
}

static  TCHAR s_szUserDefined[] = "\\50000";
static  TCHAR s_szScrUserDefined[] = "\\Scripts\\40";

BOOL ChangeFontSettings(HWND hwnd)
{
    LPCTSTR pszRoot;
    TCHAR szIntl[MAX_PATH];
    TCHAR szCodePage[MAX_PATH*2];
    TCHAR szScript[MAX_PATH*2];
    DWORD cb;
    DWORD dwVal;
    DWORD dwType;
    HKEY hKeyCP = NULL;
    HKEY hKeyScr = NULL;
    DWORD   dw;



    pszRoot = MU_GetRegRoot();
    if (pszRoot != NULL)
    {
        StrCpyN(szIntl, pszRoot, ARRAYSIZE(szIntl));
        StrCatBuff(szIntl, c_szTridentIntl, ARRAYSIZE(szIntl));

        OpenFontsDialog(hwnd, szIntl);

        // HACK! HACK! HACK! Bug 84378

        StrCpyN(szCodePage, szIntl, ARRAYSIZE(szCodePage));
        StrCatBuff(szCodePage, s_szUserDefined, ARRAYSIZE(szCodePage));
        StrCpyN(szScript, szIntl, ARRAYSIZE(szScript));
        StrCatBuff(szScript, s_szScrUserDefined, ARRAYSIZE(szScript));


        if (RegCreateKeyEx(HKEY_CURRENT_USER, szCodePage, NULL, NULL, NULL, KEY_READ, NULL, &hKeyCP, &dw)
                == ERROR_SUCCESS)
        {
            if (RegCreateKeyEx(HKEY_CURRENT_USER, szScript, NULL, NULL, NULL, KEY_WRITE, NULL, &hKeyScr, &dw)
                == ERROR_SUCCESS)
            {

                TCHAR szFont[MAX_MIMEFACE_NAME];

                cb = MAX_MIMEFACE_NAME * sizeof(szFont[0]);
                if (RegQueryValueEx(hKeyCP, REGSTR_VAL_FIXED_FONT, NULL, NULL,
                                (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hKeyScr, REGSTR_VAL_FIXED_FONT, NULL, REG_SZ, (LPBYTE)szFont, (lstrlen(szFont)+1)*sizeof(TCHAR));
                }

                cb = MAX_MIMEFACE_NAME * sizeof(szFont[0]);
                if (RegQueryValueEx(hKeyCP, REGSTR_VAL_PROP_FONT,  NULL, NULL,
                                (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hKeyScr, REGSTR_VAL_PROP_FONT,  NULL, REG_SZ, (LPBYTE)szFont, (lstrlen(szFont)+1)*sizeof(TCHAR));
                }

                RegCloseKey(hKeyScr);
            }
            RegCloseKey(hKeyCP);
        }
        // END of HACK!!!

        // hack: we should call these only if OpenFontsDialog tells us user has changed the font.
        g_lpIFontCache->OnOptionChange();
    
        SendTridentOptionsChange();

        // Re-Read Default Character Set
        SetDefaultCharset(NULL);

        // Reset g_uiCodePage
        cb = sizeof(dwVal);
        if (ERROR_SUCCESS == SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, REGSTR_VAL_DEFAULT_CODEPAGE, &dwType, &dwVal, &cb))
            g_uiCodePage = (UINT)dwVal;
    }

    return TRUE;
}
    
void GetDefaultOptInfo(LPHTMLOPT prHtmlOpt, LPPLAINOPT prPlainOpt, BOOL *pfHtml, DWORD dwFlags)
{
    BOOL fMail;
    
    Assert (prHtmlOpt && prPlainOpt && pfHtml );
    
    ZeroMemory (prHtmlOpt, sizeof(HTMLOPT));
    ZeroMemory (prPlainOpt, sizeof(PLAINOPT));
    
    fMail = !!(dwFlags & FMT_MAIL);
    
    // setup reasonable defaults
    prPlainOpt->uWrap = 76;
    prPlainOpt->ietEncoding = IET_7BIT;
    prHtmlOpt->ietEncoding = IET_QP;
    
    if (fMail)
    {
        // Mail Options
        if (!!(dwFlags & FMT_FORCE_PLAIN))
            *pfHtml = FALSE;
        else if (!!(dwFlags & FMT_FORCE_HTML))
            *pfHtml = TRUE;
        else
            *pfHtml = !!DwGetOption(OPT_MAIL_SEND_HTML);
        
        // HTML Options
        prHtmlOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_MAIL_MSG_HTML_ENCODE);
        prHtmlOpt->f8Bit = !!DwGetOption(OPT_MAIL_MSG_HTML_ALLOW_8BIT);
        prHtmlOpt->fSendImages = !!DwGetOption(OPT_MAIL_SENDINLINEIMAGES);
        prHtmlOpt->uWrap = DwGetOption(OPT_MAIL_MSG_HTML_LINE_WRAP);
        
        // Plain text options
        prPlainOpt->fMime = !!DwGetOption(OPT_MAIL_MSG_PLAIN_MIME);
        prPlainOpt->f8Bit = !!DwGetOption(OPT_MAIL_MSG_PLAIN_ALLOW_8BIT);
        prPlainOpt->uWrap = DwGetOption(OPT_MAIL_MSG_PLAIN_LINE_WRAP);
        prPlainOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_MAIL_MSG_PLAIN_ENCODE);
    }
    else
    {
        // News Options
        if (!!(dwFlags & FMT_FORCE_PLAIN))
            *pfHtml = FALSE;
        else if (!!(dwFlags & FMT_FORCE_HTML))
            *pfHtml = TRUE;
        else
            *pfHtml = !!DwGetOption(OPT_NEWS_SEND_HTML);
        
        // HTML Options
        prHtmlOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_NEWS_MSG_HTML_ENCODE);
        prHtmlOpt->f8Bit = !!DwGetOption(OPT_NEWS_MSG_HTML_ALLOW_8BIT);
        prHtmlOpt->fSendImages = !!DwGetOption(OPT_NEWS_SENDINLINEIMAGES);
        prHtmlOpt->uWrap = DwGetOption(OPT_NEWS_MSG_HTML_LINE_WRAP);
        
        prPlainOpt->fMime = !!DwGetOption(OPT_NEWS_MSG_PLAIN_MIME);
        prPlainOpt->f8Bit = !!DwGetOption(OPT_NEWS_MSG_PLAIN_ALLOW_8BIT);
        prPlainOpt->uWrap = DwGetOption(OPT_NEWS_MSG_PLAIN_LINE_WRAP);
        prPlainOpt->ietEncoding = (ENCODINGTYPE)DwGetOption(OPT_NEWS_MSG_PLAIN_ENCODE);
    }
    
    // Do some validation based on the stuff that may be in the registry
    
    // Allow 8bit in headers is always on if not a MIME message
    if (!prPlainOpt->fMime)
        prPlainOpt->f8Bit = TRUE;
    
    // HTML has to be either QP or base-64. If not, then force QP
#ifdef DONT_ALLOW_HTML_NONE_ENCODING
    if (prHtmlOpt->ietEncoding != IET_QP && prHtmlOpt->ietEncoding != IET_BASE64)
        prHtmlOpt->ietEncoding = IET_QP;
#else
    // if PLAIN, MIME: then enforce either QP, B64 or 7BIT: Default to 7BIT
    if (prHtmlOpt->ietEncoding != IET_QP && prHtmlOpt->ietEncoding != IET_BASE64 && prHtmlOpt->ietEncoding != IET_7BIT)
        prHtmlOpt->ietEncoding = IET_7BIT;
#endif
    
    // if PLAIN, MIME: then enforce either QP, B64 or 7BIT: Default to 7BIT
    if (prPlainOpt->fMime &&
        prPlainOpt->ietEncoding != IET_QP && prPlainOpt->ietEncoding != IET_BASE64 && prPlainOpt->ietEncoding != IET_7BIT)
        prPlainOpt->ietEncoding = IET_7BIT;
    
    // if PLAIN, UU: then enforce 7BIT.
    if (!prPlainOpt->fMime && prPlainOpt->ietEncoding != IET_7BIT)
        prPlainOpt->ietEncoding = IET_7BIT;
}
    
LRESULT InvalidOptionProp(HWND hwndPage, int idcEdit, int idsError, UINT idPage)
{
    HWND hwndCurr, hwndParent, hwndEdit;
    
    Assert(hwndPage != NULL);
    Assert(idPage != 0);
    Assert(idcEdit != 0);
    Assert(idsError != 0);
    
    hwndParent = GetParent(hwndPage);
    
    AthMessageBoxW(hwndPage, MAKEINTRESOURCEW(idsOptions), MAKEINTRESOURCEW(idsError), 0, MB_ICONSTOP | MB_OK);
    
    hwndCurr = PropSheet_GetCurrentPageHwnd(hwndParent);
    if (hwndCurr != hwndPage)
        SendMessage(hwndParent, PSM_SETCURSELID, 0, (LPARAM)idPage);
    
    hwndEdit = GetDlgItem(hwndPage, idcEdit);
    SendMessage(hwndEdit, EM_SETSEL, 0, -1);
    SetFocus(hwndEdit);
    
    return (PSNRET_INVALID_NOCHANGEPAGE);
}
    
INT_PTR CALLBACK DefaultClientDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);    

void DoDefaultClientCheck(HWND hwnd, DWORD dwFlags)
{
    int iret;
    DWORD dwType, dw, cb;
    BOOL f, bSet = FALSE;
    
    // Are we handling?
    if (dwFlags & DEFAULT_MAIL)
    {
        if (FIsDefaultMailConfiged())
            return;
    }
    else
    {
        if (FIsDefaultNewsConfiged(dwFlags))
            return;
    }
    
    // Someone else is a valid handler
    
    // If we're supposed to be the "outlook newsreader", then we check for "don't ask" in a different place
    cb = sizeof(DWORD);
    if (dwFlags & DEFAULT_OUTNEWS)
    {
        f = (ERROR_SUCCESS != AthUserGetValue(c_szRegOutNewsDefault, c_szNoCheckDefault,
            &dwType, (LPBYTE)&dw, &cb) || dw == 0);
    }
    else
    {
        f = (ERROR_SUCCESS != AthUserGetValue(dwFlags & DEFAULT_MAIL ? c_szRegPathMail : c_szRegPathNews,
            c_szNoCheckDefault, &dwType, (LPBYTE)&dw, &cb) || dw == 0);
    }
    
    if (f)
    {
        iret = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddAthenaDefault), hwnd, DefaultClientDlgProc, (LPARAM) dwFlags);
        if (HIWORD(iret) != 0)
        {
            dw = 1;
            if (dwFlags & DEFAULT_OUTNEWS)
            {
                AthUserSetValue(c_szRegOutNewsDefault, c_szNoCheckDefault, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
            }
            else
            {
                AthUserSetValue(dwFlags & DEFAULT_MAIL ? c_szRegPathMail : c_szRegPathNews,
                    c_szNoCheckDefault, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
            }
        }
        
        bSet = (LOWORD(iret) == IDYES);
    }
    
    if (bSet)
    {
        dwFlags |= DEFAULT_UI;
        if (dwFlags & DEFAULT_MAIL)
            SetDefaultMailHandler(dwFlags);
        else
            SetDefaultNewsHandler(dwFlags);
    }
}
    
INT_PTR CALLBACK DefaultClientDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WORD id;
    TCHAR sz[CCHMAX_STRINGRES];
    HICON hicon;
    BOOL fRet = TRUE;
    
    switch (msg)
    {
        case WM_INITDIALOG:
            if (lParam & DEFAULT_OUTNEWS)
            {
                LoadString(g_hLocRes, idsNotDefOutNewsClient, sz, ARRAYSIZE(sz));
                SetDlgItemText(hwnd, IDC_NOTDEFAULT, sz);
            
                LoadString(g_hLocRes, idsAlwaysCheckOutNews, sz, ARRAYSIZE(sz));
                SetDlgItemText(hwnd, IDC_ALWAYSCHECK, sz);
            }
            else if (lParam & DEFAULT_NEWS)
            {
                LoadString(g_hLocRes, idsNotDefNewsClient, sz, ARRAYSIZE(sz));
                SetDlgItemText(hwnd, IDC_NOTDEFAULT, sz);
            }
        
            hicon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_EXCLAMATION));
            if (hicon != NULL)
                SendDlgItemMessage(hwnd, IDC_WARNINGICON, STM_SETICON, (WPARAM)hicon, 0);
        
            CheckDlgButton(hwnd, IDC_ALWAYSCHECK, BST_CHECKED);
        
            CenterDialog(hwnd);
            PostMessage(hwnd, WM_USER, 0, 0);
            break;
        
        case WM_USER:
            SetForegroundWindow(hwnd);
            break;
        
        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
            {
                case IDYES:
                case IDNO:
                    EndDialog(hwnd, MAKELONG(id, BST_UNCHECKED == IsDlgButtonChecked(hwnd, IDC_ALWAYSCHECK) ? 1 : 0));
                    break;
            }
            break;
        
        default:
            fRet = FALSE;
            break;
    }
    
    return(fRet);
}
    
BOOL CALLBACK TridentSearchCB(HWND hwnd, LPARAM lParam)
{
    DWORD   dwProc,
            dwAthenaProc=GetCurrentProcessId();
    TCHAR   rgch[MAX_PATH];
    
    if (GetWindowThreadProcessId(hwnd, &dwProc) && dwProc == dwAthenaProc &&
        GetClassName(hwnd, rgch, ARRAYSIZE(rgch)) &&
        lstrcmp(rgch, "Internet Explorer_Hidden")==0)
        {
            PostMessage(hwnd, WM_USER + 338, 0, 0);
            return FALSE;
        }

    return TRUE;
}

void SendTridentOptionsChange()
{
    // walk the top-level windows in our process, looking for the trident notification window
    // when we find it, post it WM_USER + 338
    EnumWindows(TridentSearchCB, 0);
}
    
void FreeIcon(HWND hwnd, int idc)
{
    HICON hIcon;

    hIcon = (HICON) SendDlgItemMessage(hwnd, idc, STM_GETIMAGE, IMAGE_ICON, 0);
    SendDlgItemMessage(hwnd, idc, STM_SETIMAGE, IMAGE_ICON, NULL);

    if (hIcon)
        DestroyIcon(hIcon);
}
// -----------------------------------------------------------------------------
// IsHTTPMailEnabled
// HTTPMail accounts can only be created and accessed when a special
// registry value exists. This limitation exists during development of
// OE 5.0, and will probably be removed for release.
// -----------------------------------------------------------------------------
BOOL IsHTTPMailEnabled(void)
{
#ifdef NOHTTPMAIL
    return FALSE;    
#else
    DWORD   cb, bEnabled = FALSE;
    HKEY    hkey = NULL;

    // open the OE5.0 key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(bEnabled);
        RegQueryValueEx(hkey, c_szEnableHTTPMail, 0, NULL, (LPBYTE)&bEnabled, &cb);

        RegCloseKey(hkey);
    }

    return bEnabled;
#endif
}

const static HELPMAP g_rgCtxMapReceipts[] =
{
    {IDC_MDN_SEND_REQUEST,     IDH_RECEIPTS_REQUEST},
    {IDC_DONOT_REPSONDTO_RCPT, IDH_RECEIPTS_NEVER},
    {IDC_ASKME_FOR_RCPT,       IDH_RECEIPTS_ASK},
    {IDC_SEND_AUTO_RCPT,       IDH_RECEIPTS_ALWAYS},
    {IDC_TO_CC_LINE_RCPT,      IDH_RECEIPTS_EXCEPTIONS},
    {IDC_SECURE_RECEIPT,       IDH_RECEIPTS_SECURE},
    {0,                        0                  }
};

INT_PTR CALLBACK ReceiptsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT     lResult;

    switch (message)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, Receipts_OnInitDialog);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapReceipts);
            break;
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, Receipts_OnCommand);
            return (TRUE);
            
        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, Receipts_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            FreeIcon(hwnd, IDC_RECEIPT);
            FreeIcon(hwnd, IDC_SEND_RECEIVE_ICON);
            if(!IsSMIME3Supported())
                FreeIcon(hwnd, IDC_SEC_REC);                
            return (TRUE);
    }
    
    return (FALSE);
}

BOOL Receipts_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    OPTINFO *pmoi    = 0;
    BOOL     fEnable = FALSE;
    DWORD    id;
    DWORD    dw;
    DWORD    dwLocked = FALSE;
    DWORD    dwType;
    DWORD    cbData;
    HKEY     hKeyLM;

    // Get the passed in options pointer
    Assert(pmoi == NULL);
    pmoi = (OPTINFO *)(((PROPSHEETPAGE *)lParam)->lParam);
    Assert(pmoi != NULL);
    
    dw = IDwGetOption(pmoi->pOpt, OPT_MDN_SEND_RECEIPT);

    switch (dw)
    {
        case MDN_SENDRECEIPT_AUTO:
            id = IDC_SEND_AUTO_RCPT;
            break;

        case MDN_DONT_SENDRECEIPT:
            id = IDC_DONOT_REPSONDTO_RCPT;
            break;
        
        default:
        case MDN_PROMPTFOR_SENDRECEIPT:
            id = IDC_ASKME_FOR_RCPT;
            break;
    }

    CheckDlgButton(hwnd, id, BST_CHECKED);

    ButtonChkFromOptInfo(hwnd, IDC_TO_CC_LINE_RCPT, pmoi, OPT_TO_CC_LINE_RCPT);

    cbData = sizeof(DWORD);
    
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szSendMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&  
        (ERROR_SUCCESS != AthUserGetValue(NULL, c_szSendMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    if (!!dwLocked)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_SEND_AUTO_RCPT),       FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_DONOT_REPSONDTO_RCPT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ASKME_FOR_RCPT),       FALSE);
    }

    cbData = sizeof(DWORD);
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szSendReceiptToListLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&
        (ERROR_SUCCESS != AthUserGetValue(NULL, c_szSendReceiptToListLocked, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    fEnable = (id == IDC_SEND_AUTO_RCPT);

    if (!fEnable || (!!dwLocked))
    {
        EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_LINE_RCPT),  FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_TEXT), FALSE);
    }

    //Request for Receipt
    ButtonChkFromOptInfo(hwnd, IDC_MDN_SEND_REQUEST, pmoi, OPT_MDN_SEND_REQUEST);

    cbData = sizeof(DWORD);
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szRequestMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&
        (ERROR_SUCCESS != AthUserGetValue(NULL, c_szRequestMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    if (!!dwLocked)
    {
        EnableWindow(GetDlgItem(hwnd, IDC_MDN_SEND_REQUEST), FALSE);
    }    

    HICON hIcon;

#ifdef SMIME_V3
    if(!IsSMIME3Supported())
    {
        ShowWindow(GetDlgItem(hwnd, IDC_SR_TXT1), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SRES_TXT2), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SECURE_RECEIPT), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_SRES_TXT3), SW_HIDE);
        EnableWindow(GetDlgItem(hwnd, IDC_SECURE_RECEIPT), FALSE);
        ShowWindow(GetDlgItem(hwnd, idiSecReceipt), SW_HIDE);
    }
    else
    {
        if (g_dwAthenaMode & MODE_NEWSONLY)
        {
            EnableWindow(GetDlgItem(hwnd, IDC_SECURE_RECEIPT), FALSE);
        }
        hIcon = ImageList_GetIcon(pmoi->himl, ID_SEC_RECEIPT, ILD_TRANSPARENT);
        SendDlgItemMessage(hwnd, IDC_SEC_REC, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

    }

    // ButtonChkFromOptInfo(hwnd, IDC_SECURE_RECEIPT, pmoi, OPT_SECURE_READ_RECEIPT);
#endif // SMIME_V3

    // Pictures

    hIcon = ImageList_GetIcon(pmoi->himl, ID_RECEIPT, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_RECEIPT, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    
    hIcon = ImageList_GetIcon(pmoi->himl, ID_SEND_RECEIEVE, ILD_TRANSPARENT);
    SendDlgItemMessage(hwnd, IDC_SEND_RECEIVE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
    

    // Stash the pointer
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pmoi);
    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
}


void Receipts_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    OPTINFO *pmoi = 0;
    BOOL     fEnable;

    // Get our stored options info
    pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
    if (pmoi == NULL)
        return;

    if (codeNotify == BN_CLICKED)
    {
        switch (id)
        {
            case IDC_SEND_AUTO_RCPT:
                fEnable = (SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_LINE_RCPT), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_TEXT), fEnable);
                PropSheet_Changed(GetParent(hwnd), hwnd);
                break;

            case IDC_DONOT_REPSONDTO_RCPT:
            case IDC_ASKME_FOR_RCPT:
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_LINE_RCPT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_TO_CC_TEXT), FALSE);
                //Fallthrough
        
            case IDC_MDN_SEND_REQUEST:
            // case IDC_SECURE_RECEIPT:
            case IDC_TO_CC_LINE_RCPT:
                PropSheet_Changed(GetParent(hwnd), hwnd);
                break;

#ifdef SMIME_V3
            case IDC_SECURE_RECEIPT:
                FGetSecRecOptions(hwnd, pmoi);
                break;
#endif // SMIME_V3
        }
    }
}


LRESULT Receipts_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    OPTINFO *pmoi = 0;
    DWORD    dw;
    DWORD    id;

    // The only notification we care about is Apply
    if (PSN_APPLY == pnmhdr->code)
    {
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwnd, DWLP_USER);    
        if (pmoi == NULL)
            return (PSNRET_INVALID_NOCHANGEPAGE);
                    
        // General options
        ButtonChkToOptInfo(hwnd, IDC_MDN_SEND_REQUEST, pmoi, OPT_MDN_SEND_REQUEST);
        // ButtonChkToOptInfo(hwnd, IDC_SECURE_RECEIPT, pmoi, OPT_NOTIFYGROUPS);

        id = IDC_ASKME_FOR_RCPT;
        if (IsDlgButtonChecked(hwnd, IDC_DONOT_REPSONDTO_RCPT) == BST_CHECKED)
        {
            id = IDC_DONOT_REPSONDTO_RCPT;
        }
        else if (IsDlgButtonChecked(hwnd, IDC_SEND_AUTO_RCPT) == BST_CHECKED)
        {
            id = IDC_SEND_AUTO_RCPT;
        }

        switch (id)
        {
            case IDC_SEND_AUTO_RCPT:
                dw = MDN_SENDRECEIPT_AUTO;
                break;

            case IDC_DONOT_REPSONDTO_RCPT:
                dw = MDN_DONT_SENDRECEIPT;
                break;
        
            default:
            case IDC_ASKME_FOR_RCPT:
                dw = MDN_PROMPTFOR_SENDRECEIPT;
                break;
        }

        ISetDwOption(pmoi->pOpt, OPT_MDN_SEND_RECEIPT, dw, NULL, 0);
        
        ButtonChkToOptInfo(hwnd, IDC_TO_CC_LINE_RCPT, pmoi, OPT_TO_CC_LINE_RCPT);

        return (PSNRET_NOERROR);

    }   

    return (FALSE);
}

#ifdef SMIME_V3
// Security receipts options

BOOL FGetSecRecOptions(HWND hwndParent, OPTINFO *opie)
{
    BOOL fRes = FALSE;

    if(DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddSecReceipt),
        hwndParent, SecurityReceiptDlgProc, (LPARAM) (opie)) == IDOK)
    {
//        hr = HrSetOELabel(plabel);
//        if(hr == S_OK)
        fRes = TRUE;
    }

    return (fRes);

}


// Dlg proc
static const HELPMAP g_rgCtxMapSecureRec[] = {
    {IDC_SEC_SEND_REQUEST,      IDH_SECURERECEIPTS_REQUEST},
    {IDC_DONOT_RESSEC_RCPT,     IDH_SECURERECEIPTS_NEVER},
    {IDC_ASKME_FOR_SEC_RCPT,    IDH_SECURERECEIPTS_ASK},
    {IDC_SEC_AUTO_RCPT,         IDH_SECURERECEIPTS_ALWAYS},
    {IDC_ENCRYPT_RCPT,          IDH_SECURERECEIPTS_ENCRYPT},
    {IDC_SECREC_VERIFY,         IDH_SECURERECEIPTS_VERIFY},
    {idcStatic1,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEC_REC,               IDH_NEWS_COMM_GROUPBOX},
    {IDC_SEND_RECEIVE_ICON,     IDH_NEWS_COMM_GROUPBOX},
    {IDC_GENERAL_ICON,          IDH_NEWS_COMM_GROUPBOX},
    {0,                         0}
};


INT_PTR CALLBACK SecurityReceiptDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT                 hr;
    LONG_PTR                iEntry;
    OPTINFO                 *pmoi    = 0;
    DWORD                   dw = 0;
    UINT                    id = 0;
    HICON                   hIcon = NULL;
    
    switch ( msg) {
    case WM_INITDIALOG:

        pmoi = (OPTINFO *)(lParam);
        Assert(pmoi != NULL);

        SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM) pmoi);

        CenterDialog(hwndDlg);
        
        hIcon = ImageList_GetIcon(pmoi->himl, ID_SEC_RECEIPT, ILD_TRANSPARENT);;

        SendDlgItemMessage(hwndDlg, IDC_SEC_REC, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

        hIcon = ImageList_GetIcon(pmoi->himl, ID_SEND_RECEIEVE, ILD_TRANSPARENT);
        SendDlgItemMessage(hwndDlg, IDC_SEND_RECEIVE_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);
        
        hIcon = ImageList_GetIcon(pmoi->himl, ID_OPTIONS_GENERAL, ILD_TRANSPARENT);
        SendDlgItemMessage(hwndDlg, IDC_GENERAL_ICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon);

        ButtonChkFromOptInfo(hwndDlg, IDC_SEC_SEND_REQUEST, pmoi, OPT_SECREC_USE);
        ButtonChkFromOptInfo(hwndDlg, IDC_SECREC_VERIFY, pmoi, OPT_SECREC_VERIFY);
        ButtonChkFromOptInfo(hwndDlg, IDC_ENCRYPT_RCPT,  pmoi, OPT_SECREC_ENCRYPT);

        dw = IDwGetOption(pmoi->pOpt, OPT_MDN_SEC_RECEIPT);

        switch (dw)
        {
            case MDN_SENDRECEIPT_AUTO:
                id = IDC_SEC_AUTO_RCPT;
                break;

            case MDN_DONT_SENDRECEIPT:
                id = IDC_DONOT_RESSEC_RCPT;
                break;
        
            case MDN_PROMPTFOR_SENDRECEIPT:
            default:
                id = IDC_ASKME_FOR_SEC_RCPT;
                break;
        }

        CheckDlgButton(hwndDlg, id, BST_CHECKED);


        if (id != IDC_SEC_AUTO_RCPT)
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENCRYPT_RCPT),  FALSE);

        break;
        
    case WM_COMMAND:
        // Get our stored options info
        pmoi = (OPTINFO *)GetWindowLongPtr(hwndDlg, DWLP_USER);    
        if (pmoi == NULL)
            break;

        switch (LOWORD(wParam)) 
        {

        case IDC_SEC_AUTO_RCPT:
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENCRYPT_RCPT),  TRUE);
            break;

        case IDC_DONOT_RESSEC_RCPT:
        case IDC_ASKME_FOR_SEC_RCPT:
            EnableWindow(GetDlgItem(hwndDlg, IDC_ENCRYPT_RCPT),  FALSE);
            break;

        case IDOK:
            ButtonChkToOptInfo(hwndDlg, IDC_SEC_SEND_REQUEST, pmoi, OPT_SECREC_USE);
            ButtonChkToOptInfo(hwndDlg, IDC_SECREC_VERIFY, pmoi, OPT_SECREC_VERIFY);
            ButtonChkToOptInfo(hwndDlg, IDC_ENCRYPT_RCPT, pmoi, OPT_SECREC_ENCRYPT);

            dw = MDN_PROMPTFOR_SENDRECEIPT;

            if (IsDlgButtonChecked(hwndDlg, IDC_DONOT_RESSEC_RCPT) == BST_CHECKED)
                dw = MDN_DONT_SENDRECEIPT;
            else if (IsDlgButtonChecked(hwndDlg, IDC_SEC_AUTO_RCPT) == BST_CHECKED)
                dw = MDN_SENDRECEIPT_AUTO;

            ISetDwOption(pmoi->pOpt, OPT_MDN_SEC_RECEIPT, dw, NULL, 0);
            EndDialog(hwndDlg, IDOK);
            break;        

        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;

        default:
            return FALSE;
        }
        break;
        
    case WM_CONTEXTMENU:
    case WM_HELP:
        return OnContextHelp(hwndDlg, msg, wParam, lParam, g_rgCtxMapSecureRec);
        break;

    case WM_DESTROY:
        FreeIcon(hwndDlg, IDC_SEND_RECEIVE_ICON);
        FreeIcon(hwndDlg, IDC_GENERAL_ICON);
        FreeIcon(hwndDlg, IDC_SEC_REC);                
        return (TRUE);

    default:
        return FALSE;
    }
    
    return TRUE;
}

#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\rtf2html.h ===
#ifndef _INC_RTF2HTML
#define _INC_RTF2HTML

#ifdef __cplusplus
extern "C" {
#endif 
#define CFCONV_HTML_TO_RTF      0
#define CFCONV_RTF_TO_HTML      1

ULONG   SizeHTML(HGLOBAL hgl);
HANDLE  ConvertRTF2HTML(HANDLE hgl, UINT uiDirection);

int CALLBACK CallbackHTMLtoRTF(UINT  cch, UINT nPercentComplete);
int CALLBACK CallbackRTFtoHTML(int rgf, int unused);
HANDLE  CallMtmTextConverter(HWND   hwnd, 
                             UINT   uiConvertDirection, 
                             HANDLE ghInputData, 
                             long   lInputDataSize);
#ifdef __cplusplus
}
#endif 

#endif //_INC_RTF2HTML
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\optres.h ===
#ifndef _INC_OPTRES_H
#define _INC_OPTRES_H

#define IDC_SOUND_CHECK             1000
#define IDC_PREVIEW_CHECK           1001
#define IDC_AUTOCHECK_CHECK         1002
#define IDC_AUTOCHECK_EDIT          1003
#define IDC_EMPTY_CHECK             1004
#define IDC_AUTOCHECK_SPIN          1005
#define IDC_SAVE_CHECK              1006
#define IDC_CHECK3                  1008
#define IDC_INDENT_CHECK            1010
#define IDC_INDENT_COMBO            1011
#define IDC_MIME_RADIO              1013
#define IDC_UUENCODE_RADIO          1014
#define IDC_ENCODE_COMBO            1015
#define IDC_BREAK_CHECK             1016
#define IDC_BREAK_EDIT              1017
#define IDC_BREAK_SPIN              1018
#define IDC_NOSIG_RADIO             1020
#define IDC_TEXT_RADIO              1021
#define IDC_FILE_RADIO              1022
#define IDC_TEXT_EDIT               1023
#define IDC_FILE_EDIT               1024
#define IDC_BROWSE_BUTTON           1025
#define IDC_ADVANCED_BUTTON         1026
#define IDC_INCLUDE_CHECK           1027
#define IDC_AUTOSIGNATURE_CHECK     1029
#define IDC_MARKASREAD_EDIT         1030
#define IDC_MARKASREAD_SPIN         1031
#define IDC_MAILTIMEOUT_SLIDER      1033
#define IDC_MAILTIMEOUT_STATIC      1034
#define IDC_SENDIMMEDIATE_CHECK     1036
#define IDC_SIGREPLY_CHECK          1037
#define IDC_MAILWRAP_EDIT           1038
#define IDC_MAILWRAP_SPIN           1039
#define IDC_8BIT_HEADER             1040
#define IDC_MAILWRAP_TEXT1          1041
#define IDC_MAILWRAP_TEXT2          1042
#define idcStaticOrFwd              1047
#define idcStaticReplying           1048
#define IDC_AUTOWAB_CHECK           1049

#define IDC_INCLUDE_OTHERS          1051
#define IDC_SIGN_CHECK              1052
#define IDC_ENCRYPT_CHECK           1053
#define IDC_ADVSETTINGS_BUTTON      1054
#define IDC_CERT_COMBO              1055
#define IDC_INCLUDECERT_CHECK       1056
#define IDC_ENCRYPT_COMBO           1057
#define IDC_ENCRYPT_FOR_SELF        1058
#define IDC_OPAQUE_SIGN             1059

#define IDC_FONTSETTINGS            1060
#define idcAutoInline               1061
#define idcAutoInlineSlide          1062
#define IDC_SENDIMAGES              1063
#define IDC_REPLY_IN_ORIGFMT        1064
#define IDC_STORE_LOCATION          1065
#define IDC_STORE_EDIT              1066
#define IDC_CHANGE_BTN              1067

#define IDC_AUTO_ADD_SENDERS_CERT_TO_WAB    1068
#define IDC_ENCRYPT_WARN_COMBO      1069


#define IDC_VCARD_CHECK             1071
#define IDC_VCARD_COMBO             1072
#define IDC_VCARD_BUTTON_EDIT       1073
#define IDC_VCARD_BUTTON_NEW        1074
#define IDC_BROWSE_PICTURE          1075
#define IDC_BKGRNDPICTURE_CHECK     1076
#define IDC_BKGRNDPICTURE           1077
#define IDC_SENDFONTSETTINGS        1078
#define IDC_INDENTREPLY_CHECK       1079
#define IDC_USEAUTOCOMPLETE_CHECK   1080
#define IDC_SIGBOTTOM_CHECK         1081

#define IDC_ALWAYSCHECK             1090
#define IDC_NOTDEFAULT              1091
#define IDC_WARNINGICON             1092
#define IDC_ENCRYPT_ICON			1093
#define	IDC_SIGNED_ICON				1094

#define	IDC_SIG_LIST                1095
#define	IDC_NEW_BUTTON              1096
#define	IDC_REMOVE_BUTTON           1097
#define	IDC_RENAME_BUTTON           1098
#define	IDC_ADDSIG_CHECK            1099
#define	IDC_ADDREPLY_CHECK          1100
#define	IDC_DEFAULT_BUTTON          1101
#define	IDC_ADV_BUTTON              1102
#define IDC_ACCOUNT_LIST            1103
#define IDC_ADVSIG_STATIC           1104
#define IDC_POLLING_DIAL_OPTIONS    1105
#define IDC_CERT_ICON               1106
#define IDC_SELECT_LABEL            1107
#define IDC_SEC_LABEL               1108


#define idcName                                   2001
#define idcOrganization                           2002
#define idcEmailAddress                           2003
#define idcReplyTo                                2004
#define idcNumSubj                                2005
#define idcSpinNumSubj                            2006
#define idcAdvancedBtn                            2007
#define idcAutoExpand                             2008
#define idcMarkAllRead                            2009
#define idcSelectEntireWord                       2010
#define idcMarkReadPreview                        2011
#define idcCheckForNew                            2012
#define idcEditHowOften                           2013
#define idcSpinHowOften                           2014
#define idcIncludeInReply                         2015
#define idcFontList                               2016
#define idcChange                                 2017
#define idcDemoText                               2018
#define idcSuggest                                2019
#define idcCheckBeforeSend                        2020
#define idcIgnoreUpper                            2021
#define idcIgnoreNum                              2022
#define idcIgnoreOrig                             2023
#define idcRadioText                              2024
#define idcSigText                                2025
#define idcRadioFile                              2026
#define idcFileName                               2027
#define idcBrowse                                 2028
#define idcAutoAddSig                             2029
#define idcDownloadChunks                         2030
#define idcAttachMime                             2031
#define idcAttachUuencode                         2032
#define IDC_BUDDYLIST_CHECK                       2033

#define IDC_NOTIFY_NEW_GROUPS                     2037
#define idcSaveCopy                               2038
#define idcIndentReply                            2039
#define idcIndentChar                             2040
#define idcProperties                             2041
#define idcAddServer                              2043
#define idcRemoveServer                           2044
#define idcPreviewTimeout                         2045
#define idcPreviewSpin                            2046
#define idcEncoding                               2047
#define idcServerList                             2048
#define idcNewsWrapEdit                           2049
#define idcNewsWrapSpin                           2050
#define idcAutoFillPreview                        2051
#define idch8bitHeader                            2052

#define idcTotalSize                              2053
#define idcWastedSpace                            2054
#define idbRemove                                 2055
#define idbCompactCache                           2059
#define idbDelete                                 2060
#define idchDeleteMsgs                            2061
#define ideDays                                   2062
#define idspDays                                  2063
#define idchDontCacheRead                         2066
#define idbManualCleanUp                          2067
#define idsDiskUsage                              2068
#define ideCompactPer                             2071
#define idspCompactPer                            2072
#define idcStartGroup                             2073
#define idcNewsWrapText1                          2074
#define idcNewsWrapText2                          2075
#define idcAdd                                    2076
#define idcSetAsDefault                           2077
#define idcFontSettings                           2078
#define idcLogNewsXport                           2079
#define idcNewsXportBrowse                        2080
#define idcLogNewsOffline                         2081
#define idcOfflineBrowse                          2082
#define idcNoConnectionRadio                      2083
#define idcDialRadio                              2084
#define idcDialUpCombo                            2085
#define idcPromptRadio                            2086
#define idcSwitchCheck                            2087
#define idbtnMailPlain                            2088
#define idbtnMailHTML                             2089
#define idrbMailPlain                             2090
#define idrbMailHTML                              2091
#define idbtnNewsPlain                            2092
#define idbtnNewsHTML                             2093
#define idrbNewsPlain                             2094
#define idrbNewsHTML                              2095
#define idcLogMailXport                           2096
#define idcHangupCheck                            2097
#define IDC_LAUNCH_INBOX                          2098
#define idcIntlButton                             2099
#define IDC_SAMPLE                                2100
#define IDC_RADIOMYFONT                           2101
#define IDC_RADIOUSETHIS                          2102
#define IDC_EDITSTATIONERY                        2103
#define IDC_SELECT                                2104
#define IDC_SIGNATURE                             2105
#define IDC_ADDSTATIONERY                         2106
#define IDC_PREVIEW                               2107
#define IDC_LISTSTATIONERY                        2108
#define IDC_MORESTATIONERY                        2110
#define idbtnSendIntl                             2111
#define idbtnIDs                                  2112
#define idcAutoDiscovery                          2113

#define idcZone                                   2115
#define idbtnDigitalID                            2117
#define idbtnMoreInfo                             2118
#define idcLogImapXport                           2119
#define idcResetText                              2120
#define idbReset                                  2121
#define IDC_ENGLISH_HDR_CHECK                     2122
#define IDC_EXPANDUNREAD_CHECK                    2124
#define IDC_MAILFORMAT_GROUP                      2125
#define IDC_SECURITYSETTINGS_GROUP                2126
#define IDC_DIGITALIDS_GROUP                      2127
#define IDC_MAILFORMAT_STATIC                     2128
#define IDC_SECURITYSETTINGS_STATIC               2129
#define IDC_DIGITALIDS_STATIC                     2130
#define IDC_MOREPREVIEW                           2132
#define IDC_SHOWPREVIEW_CHECK                     2133
#define idcIMAPPurge                              2134
#define idcTooltips                               2135
#define idcDialupButton                           2136
#define IDC_DEFMAIL                               2137
#define IDC_DEFNEWS                               2138
#define IDC_MAILHANDSTAT                          2139
#define IDC_NEWSHANDSTAT                          2140
#define IDC_STATIONERY                            2141
#define IDC_INTERNET_ZONE                         2142
#define IDC_RESTRICTED_ZONE                       2143
#define IDC_SEND_RECEIVE_ON_START                 2144
#define IDC_BACKGROUND_COMPACTION                 2145
#define IDC_MAIL_FORMAT                           2146
#define IDC_MAIL_FORMAT_ADVANCED                  2147
#define IDC_NEWS_FORMAT                           2148
#define IDC_NEWS_FORMAT_ADVANCED                  2149
#define IDC_ADD_SIG                               2150
#define IDC_EDIT_SIG                              2151
#define IDC_TROUBLE_ICON                          2152
#define IDC_CLEANUP_ICON                          2153
#define IDC_DIAL_ICON                             2154
#define IDC_DIAL_START_ICON                       2155
#define IDC_INTERNET_DIAL_ICON                    2156
#define IDC_READ_ICON                             2157
#define IDC_READ_NEWS_ICON                        2158
#define IDC_FONTS_ICON                            2159
#define IDC_SECURITY_ZONE_ICON                    2160
#define IDC_SECURE_MAIL_ICON                      2161
#define IDC_SEND_ICON                             2162
#define IDC_MAIL_FORMAT_ICON                      2163
#define IDC_NEWS_FORMAT_ICON                      2164
#define IDC_SIGLIST_ICON                          2165
#define IDC_SIG_SETTINGS_ICON                     2166
#define IDC_SPELL_SETTINGS_ICON                   2167
#define IDC_SPELL_IGNORE_ICON                     2168
#define IDC_SPELL_LANGUAGE_ICON                   2169
#define IDC_SIG_EDIT_ICON                         2170
#define IDC_GENERAL_ICON                          2171
#define IDC_SEND_RECEIVE_ICON                     2172
#define IDC_DEFAULT_ICON                          2173
#define IDC_CACHE_FOLDER                          2174
#define IDC_FOLDER_BROWSE                         2175
#define IDC_MAIL_FONT_SETTINGS                    2176
#define IDC_NEWS_FONT_SETTINGS                    2177
#define IDC_MAIL_FONT_DEMO                        2178
#define IDC_NEWS_FONT_DEMO                        2179
#define IDC_FONT_ICON                             2180
#define IDC_SELECT_MAIL                           2181
#define IDC_SELECT_NEWS                           2182
#define IDC_MAIL_STATIONERY                       2183
#define IDC_NEWS_STATIONERY                       2184
#define IDC_USE_MAIL_STATIONERY                   2185
#define IDC_USE_NEWS_STATIONERY                   2186
#define IDC_DOWNLOAD_MORE                         2187
#define IDC_CREATE_NEW                            2188
#define IDC_STATIONERY_ICON                       2189
#define IDC_MAIL_VCARD                            2190
#define IDC_NEWS_VCARD                            2191
#define IDC_VCARD_ICON                            2192
#define IDC_EDIT_VCARD                            2193
#define IDC_MAIL_VCARD_SELECT                     2194
#define IDC_NEWS_VCARD_SELECT                     2195
#define IDC_EDIT_MAIL_VCARD                       2196
#define IDC_EDIT_NEWS_VCARD                       2197
#define idcLogHTTPMailXport                       2198
#define IDC_RTL_MSG_DIR_CHECK                     2199

#define IDC_SHOWPREVIEW_BUTTON_ADD                2200
#define IDC_SHOWPREVIEW_BUTTON_EDIT               2201
#define IDC_WATCHED_COLOR                         2202
#define IDC_REVOKE_ONLINE_ONLY                    2203
#define IDC_REVOKE_NEVER                          2204

#define IDC_MDN_SEND_REQUEST                      2205
#define IDC_SECURE_RECEIPT                        2206
#define IDC_DONOT_REPSONDTO_RCPT                  2207
#define IDC_ASKME_FOR_RCPT                        2208
#define IDC_SEND_AUTO_RCPT                        2209
#define IDC_TO_CC_LINE_RCPT                       2210
#define IDC_TO_CC_TEXT                            2211
#define IDC_RECEIPT                               2212
#define IDC_AUTODISCOVERY_ICON                    2213

#define IDC_SENDMAIL_WARN_CHECK                   2220
#define IDC_SAFE_ATTACHMENT_CHECK                 2221
#define IDC_READ_IN_TEXT_ONLY                     2222

#define IDC_SR_TXT1                               2232
#define IDC_SRES_TXT2                             2233
#define IDC_SRES_TXT3                             2234
#define IDC_SEC_SEND_REQUEST                      2235
#define IDC_DONOT_RESSEC_RCPT                     2236
#define IDC_ASKME_FOR_SEC_RCPT                    2237
#define IDC_SEC_AUTO_RCPT                         2238
#define IDC_ENCRYPT_RCPT                          2239
#define IDC_SECREC_VERIFY                         2240
#define IDC_SEC_REC                               2241

#endif // _INC_OPTRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\wells.h ===
/*
 *  w e l l s . h
 *	
 *  Purpose:
 *  	implments name checking and stuff for the wells
 *	
 *	Author:brettm
 */

#ifndef _WELLS_H
#define _WELLS_H

#include <ipab.h>

#define cchUnresolvedMax 512

enum    // flags for check names
{
    CNF_DONTRESOLVE     =0x01,
    CNF_SILENTRESOLVEUI =0x02
};

class CAddrWells
{
public:
    CAddrWells();
    ~CAddrWells();

    HRESULT HrInit(ULONG cWells, HWND *rgHwnd, ULONG *rgRecipType);
    HRESULT HrSetWabal(LPWABAL lpWabal);
    HRESULT HrCheckNames(HWND hwnd, ULONG uFlags);
    HRESULT HrSelectNames(HWND hwnd, int iFocus, BOOL fNews);
    HRESULT HrDisplayWells(HWND hwnd);
    HRESULT OnFontChange();

private:
    HRESULT UnresolvedText(LPWSTR pwszText, LONG cch);
    HRESULT HrAddNamesToList(HWND hwndWell, LONG lRecipType);
    HRESULT HrAddUnresolvedName();
    HRESULT HrAddRecipientsToWells();

private:
    HWND    *m_rgHwnd;
    ULONG   *m_rgRecipType;
    ULONG   m_cWells;
    LPWABAL m_lpWabal;

    // stuff used for dynamic parsing
    HWND                m_hwndWell;
    WCHAR               m_rgwch[cchUnresolvedMax];
    ULONG               m_cchBuf;
    BOOL                m_fTruncated;
    LONG                m_lRecipType;

    HRESULT _UpdateFont(HWND hwndWell);

};

// utility function...
HRESULT HrAddRecipientToWell(HWND hwndEdit, LPADRINFO lpAdrInfo, BOOL fAddSemi=FALSE);

#endif // _WELLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\wells.cpp ===
/*
 *  w e l l s . c p p 
 *    
 *  Purpose:
 *      implments name checking and stuff for the wells
 *    
 *    Author:brettm
 *
 *  Ported to C++ and modified for Athena from Capone src
 */
#include <pch.hxx>
#include <resource.h>
#include <richedit.h>
#include <ipab.h>
#include <addrlist.h>
#include "addrobj.h"
#include "wells.h"
#include "header.h"
#include <ourguid.h>

ASSERTDATA

HRESULT CAddrWells::HrInit(ULONG cWells, HWND *rgHwnd, ULONG *rgRecipType)
{
    
    if(cWells<=0 || rgHwnd==NULL || rgRecipType==NULL)
        return E_INVALIDARG;

    Assert(m_rgHwnd==NULL);
    Assert(m_rgRecipType==NULL);
    Assert(m_cWells==0);    
    
    if(!MemAlloc((LPVOID *)&m_rgHwnd, sizeof(HWND)*cWells))
        return E_OUTOFMEMORY;

    if(!MemAlloc((LPVOID *)&m_rgRecipType, sizeof(ULONG)*cWells))
        return E_OUTOFMEMORY;

    CopyMemory(m_rgHwnd, rgHwnd, sizeof(HWND)*cWells);
    CopyMemory(m_rgRecipType, rgRecipType, sizeof(ULONG)*cWells);
    m_cWells=cWells;
    return NOERROR;
}

HRESULT CAddrWells::HrSetWabal(LPWABAL lpWabal)
{
    Assert(lpWabal);

    if(!lpWabal)
        return E_INVALIDARG;
    
    ReleaseObj(m_lpWabal);
    m_lpWabal=lpWabal;
    m_lpWabal->AddRef();
    return NOERROR;    
}

HRESULT CAddrWells::HrCheckNames(HWND hwnd, ULONG uFlags)
{
    HRESULT     hr=NOERROR;
    ULONG       ulWell;
    HCURSOR     hcur;
    BOOL        fDirty=FALSE;
           
    if(!m_lpWabal)
        return E_FAIL;

    // This optimization will only occur in the office envelope
    // on autosave. In most cases, the ResolveNames in the header
    // will stop before calling down to this level. For the other 
    // minority cases, we should leave this code in.
    for(ulWell=0; ulWell<m_cWells; ulWell++)
        if(Edit_GetModify(m_rgHwnd[ulWell]))
            {
            fDirty=TRUE;
            break;
            }

    if(!fDirty)
        return NOERROR;
        
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // clear the current list
    m_lpWabal->Reset();

    for(ulWell=0; ulWell<m_cWells; ulWell++)
        if(Edit_GetModify(m_rgHwnd[ulWell]))
            hr=HrAddNamesToList(m_rgHwnd[ulWell], m_rgRecipType[ulWell]);

    if(!(uFlags&CNF_DONTRESOLVE))
    {
        if(uFlags&CNF_SILENTRESOLVEUI)
            hr=m_lpWabal->HrResolveNames(NULL, FALSE);
        else
            hr=m_lpWabal->HrResolveNames(hwnd, TRUE);
        HrDisplayWells(hwnd);
    }

    if(hcur)
        SetCursor(hcur);

    return hr;
}

HRESULT CAddrWells::HrDisplayWells(HWND hwnd)
{
    HRESULT hr=E_FAIL;
    HCURSOR hcursor;
    HWND    hwndBlock;
    ULONG   ulWell;
    
    if (m_lpWabal)
    {
        hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        // brettm: hack taken from Capone. LockUpdateWindow doesn't work for the
        // richedit, so we block paints by covering the edit controls with a
        // paint-swallowing window until we're done...
        hwndBlock=HwndStartBlockingPaints(hwnd);
        
        // empty the wells...
        for(ulWell=0; ulWell<m_cWells; ulWell++)
            SetWindowText(m_rgHwnd[ulWell], NULL);
       
        hr=HrAddRecipientsToWells();
        StopBlockingPaints(hwndBlock);
        
        if (hcursor)
            SetCursor(hcursor);
    }
    return hr;
}

CAddrWells::CAddrWells()
{
    m_lpWabal = 0;
    m_rgHwnd = NULL;
    m_rgRecipType = NULL;
    m_cWells = 0;
};

CAddrWells::~CAddrWells()
{
    ReleaseObj(m_lpWabal);
    if(m_rgRecipType)
        MemFree(m_rgRecipType);
    if(m_rgHwnd)
        MemFree(m_rgHwnd);
};



HRESULT CAddrWells::HrAddNamesToList(HWND hwndWell, LONG lRecipType)
{
    ULONG               iOb;
    ULONG               cOb;
    REOBJECT            reobj = {0};
    HRESULT             hr;
    PHCI                phci;
    LPRICHEDITOLE       preole;
    LPPERSIST           ppersist = NULL;
    LPWSTR              pwszText = NULL;
    DWORD               cch;

    Assert(IsWindow(hwndWell));

    // if the edit is not dirty, we're done
    if(!Edit_GetModify(hwndWell))
        return S_OK;

    phci = (HCI*)GetWindowLongPtr(hwndWell, GWLP_USERDATA);
    Assert(phci);

    preole = phci->preole;
    Assert(preole);

    m_hwndWell = hwndWell;
    m_cchBuf = 0;
    m_fTruncated = FALSE;
    m_lRecipType = lRecipType;

    reobj.cbStruct = sizeof(reobj);

    cOb = preole->GetObjectCount();
    for (iOb = 0; iOb < cOb; iOb++)
    {
        LPADRINFO   pAdrInfo=NULL;
        IF_FAILEXIT(hr = preole->GetObject(iOb, &reobj, REO_GETOBJ_POLEOBJ));
        
        IF_FAILEXIT(hr = reobj.poleobj->QueryInterface(IID_IPersist, (LPVOID *)&ppersist));
#ifdef DEBUG
        AssertValidAddrObject(reobj.poleobj);
#endif
        // HrGetAdrInfo doesn't alloc memory.
        IF_FAILEXIT(hr = ((CAddrObj *)ppersist)->HrGetAdrInfo(&pAdrInfo));
        
        // set the new recipient type...
        pAdrInfo->lRecipType=lRecipType;
        IF_FAILEXIT(hr = m_lpWabal->HrAddEntry(pAdrInfo));

        SafeRelease(ppersist);
        SafeRelease(reobj.poleobj);
    }
    
    // now we add in all the unresolved names...

    cch = GetRichEditTextLen(m_hwndWell) + 1;
    if (0 == cch)
        return (S_FALSE);

    IF_NULLEXIT(MemAlloc((LPVOID*)&pwszText, cch * sizeof(WCHAR)));

    GetRichEditText(m_hwndWell, pwszText, cch, FALSE, phci->pDoc);

    hr = UnresolvedText(pwszText, cch - 1); 
    
    // Add whatever is left after the last semicolon
    if (SUCCEEDED(hr))
        HrAddUnresolvedName();
    
exit:
    if(m_fTruncated)      // warn if we trucated an address
        MessageBeep(MB_OK);
    
    ReleaseObj(reobj.poleobj);
    ReleaseObj(ppersist);
    MemFree(pwszText);
    
    return hr;
}


HRESULT CAddrWells::OnFontChange()
{
    ULONG   ulWell;

    for(ulWell=0; ulWell<m_cWells; ulWell++)
        _UpdateFont(m_rgHwnd[ulWell]);

    return S_OK;
}


HRESULT CAddrWells::_UpdateFont(HWND hwndWell)
{
    ULONG               iOb;
    ULONG               cOb;
    REOBJECT            rObject={0};
    IRichEditOle        *pREOle;
    IOleInPlaceSite     *pIPS;
    LPPERSIST           pPersist = NULL;

    rObject.cbStruct = sizeof(REOBJECT);

    // walk the ole objects and send them an font-update
    if (SendMessage(hwndWell, EM_GETOLEINTERFACE, 0, (LPARAM) &pREOle))
    {
        cOb = pREOle->GetObjectCount();

        for (iOb = 0; iOb < cOb; iOb++)
        {
            if (pREOle->GetObject(iOb, &rObject, REO_GETOBJ_POLEOBJ)==S_OK)
            {
                if (rObject.poleobj->QueryInterface(IID_IPersist, (LPVOID *)&pPersist)==S_OK)
                {
                    ((CAddrObj *)pPersist)->OnFontChange();
                    pPersist->Release();
                }
                rObject.poleobj->Release();
            }
        }
        pREOle->Release();
    }
    InvalidateRect(hwndWell, NULL, TRUE);
    return S_OK;
}


HRESULT CAddrWells::HrAddUnresolvedName()
{
    HRESULT hr = S_OK;
    // strip any trailing white-space
    while(m_cchBuf > 0 && (m_rgwch[m_cchBuf - 1] == L' '
                            || m_rgwch[m_cchBuf - 1] == L'\t'))
        --m_cchBuf;

    if (m_cchBuf)
    {
        // there is something in the buffer...
        m_rgwch[m_cchBuf] = L'\0';
        hr = m_lpWabal->HrAddUnresolved(m_rgwch, m_lRecipType);
        m_cchBuf = 0;
    }
    
    return hr;
}

HRESULT CAddrWells::UnresolvedText(LPWSTR pwszText, LONG cch)
{
    HRESULT     hr = S_OK;

    // The algorithm below will strip spaces off of the
    // beginning and end of each name

    while (cch)
    {
        cch--;
        // On some versions of richedit, 0xfffc is inserted in the text
        // where there is a addrObj present. So just skip over that.
        if ((L'\t' == *pwszText) || (0xfffc == *pwszText))
            *pwszText = L' ';
        
        if (*pwszText == L';' || *pwszText == L'\r'|| *pwszText == L',')
        {
            hr = HrAddUnresolvedName();
            if (S_OK != hr)
                goto err;
        }
        else
        {
            if ((*pwszText != L' ' && *pwszText != L'\n' && *pwszText != L'\r')
                || m_cchBuf > 0)
            {
                if (m_cchBuf < ARRAYSIZE(m_rgwch) - 1)
                    m_rgwch[m_cchBuf++] = *pwszText;
                else
                    // Truncation has occurred so I want to beep
                    m_fTruncated = TRUE;
            }
        }
        ++pwszText;
    }
    
err:
    return hr;
}




enum
{
    mapiTo=0,
    mapiCc,
    mapiFrom,
    mapiReplyTo,
    mapiBcc,
    mapiMax
};

HRESULT CAddrWells::HrAddRecipientsToWells()
{
    HRESULT         hr;
    ADRINFO         AdrInfo;
    HWND            hwnd;
    HWND            hwndMap[mapiMax]={0};
    ULONG           ulWell;
    
    Assert(m_lpWabal);
    // walk the list of entries, and add them to the well...
    
    // build mapping to MAPI_TO -> hwnd if available to make the lookup quicker..
    
    for(ulWell=0; ulWell<m_cWells; ulWell++)
    {
        switch(m_rgRecipType[ulWell])
        {
            case MAPI_TO:
                hwndMap[mapiTo]=m_rgHwnd[ulWell];
                break;
            case MAPI_CC:
                hwndMap[mapiCc]=m_rgHwnd[ulWell];
                break;
            case MAPI_BCC:
                hwndMap[mapiBcc]=m_rgHwnd[ulWell];
                break;
            case MAPI_REPLYTO:
                hwndMap[mapiReplyTo]=m_rgHwnd[ulWell];
                break;
            case MAPI_ORIG:
                hwndMap[mapiFrom]=m_rgHwnd[ulWell];
                break;
        }
    }
    
    if(m_lpWabal->FGetFirst(&AdrInfo))
    {
        do
        {
            hwnd=0;
            switch(AdrInfo.lRecipType)
            {
                case MAPI_TO:
                    hwnd=hwndMap[mapiTo];
                    break;
                case MAPI_CC:
                    hwnd=hwndMap[mapiCc];
                    break;
                case MAPI_ORIG:
                    hwnd=hwndMap[mapiFrom];
                    break;
                case MAPI_BCC:
                    hwnd=hwndMap[mapiBcc];
                    break;
                case MAPI_REPLYTO:
                    hwnd=hwndMap[mapiReplyTo];
                    break;
                default:
                    AssertSz(0, "Unsupported RECIPTYPE in AdrList");
            }
            
            if(hwnd && IsWindow(hwnd))
            {
                hr = HrAddRecipientToWell(hwnd, &AdrInfo, TRUE);
                if(FAILED(hr))
                    return hr;
            }
        }
        while(m_lpWabal->FGetNext(&AdrInfo));
    }        
    return NOERROR;
}

/*
 *    HrAddRecipientToWell
 *    
 *    Purpose:
 *        This function adds a recipient to a recipient well.
 *    
 *    Parameters:
 *        hwndEdit        hwnd of the recipient well to add the
 *                        recipient to
 *        pae                pointer to an ADRENTRY
 *        fAddSemi        whether to add a semicolon between entries
 *        fCopyEntry        whether to copy the ADRENTRY or just use it
 *    
 *    Returns:
 *        scode
 */
HRESULT HrAddRecipientToWell(HWND hwndEdit, LPADRINFO lpAdrInfo, BOOL fAddSemi)
{
    HRESULT         hr = S_OK;
    CAddrObj       *pAddrObj = NULL;
    INT             cch;
    REOBJECT        reobj = {0};
    PHCI            phci;
    LPRICHEDITOLE   preole;

    Assert(IsWindow(hwndEdit));
    Assert(lpAdrInfo);

    phci = (HCI*)GetWindowLongPtr(hwndEdit, GWLP_USERDATA);
    Assert(phci);

    preole = phci->preole;
    Assert(preole);

    if(lpAdrInfo->fResolved)
    {
        // Initialize the object information structure
        reobj.cbStruct = sizeof(reobj);
        reobj.cp = REO_CP_SELECTION;
        reobj.clsid = CLSID_AddrObject;
        reobj.dwFlags = REO_BELOWBASELINE|REO_INVERTEDSELECT|
            REO_DYNAMICSIZE|REO_DONTNEEDPALETTE;
        reobj.dvaspect = DVASPECT_CONTENT;
        
        IF_FAILEXIT(hr = preole->GetClientSite(&reobj.polesite));
        
        IF_NULLEXIT(pAddrObj = new CAddrObj());
        
        IF_FAILEXIT(hr = pAddrObj->HrSetAdrInfo(lpAdrInfo));
    }
    
    if (fAddSemi && (cch = GetRichEditTextLen(hwndEdit)))
    {
        Edit_SetSel(hwndEdit, cch, cch);
        HdrSetRichEditText(hwndEdit, L"; ", TRUE);
    }
    
    if (!lpAdrInfo->fResolved)
    {
        // Its an unresolved name
        AssertSz(lpAdrInfo->lpwszDisplay, "Recipient must have a Display Name");
        HdrSetRichEditText(hwndEdit, lpAdrInfo->lpwszDisplay, TRUE);
    }
    else
    {
        // Its a resolved name
        IF_FAILEXIT(hr = pAddrObj->QueryInterface(IID_IOleObject, (LPVOID *)&reobj.poleobj));
        
        IF_FAILEXIT(hr = reobj.poleobj->SetClientSite(reobj.polesite));
        
        IF_FAILEXIT(hr = preole->InsertObject(&reobj));
    }
    
exit:
    ReleaseObj(reobj.poleobj);
    ReleaseObj(reobj.polesite);
    ReleaseObj(pAddrObj);
    return hr;
}

HRESULT CAddrWells::HrSelectNames(HWND hwnd, int iFocus, BOOL fNews)
{
    HRESULT     hr;
    ULONG       ulWell;


    m_lpWabal->Reset();

    for(ulWell=0; ulWell<m_cWells; ulWell++)
        if(Edit_GetModify(m_rgHwnd[ulWell]))
            hr=HrAddNamesToList(m_rgHwnd[ulWell], m_rgRecipType[ulWell]);

    hr=m_lpWabal->HrPickNames(hwnd, m_rgRecipType, m_cWells, iFocus, fNews);
    if(FAILED(hr))
        goto error;

    hr=HrDisplayWells(hwnd);
    if(FAILED(hr))
        goto error;

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\receipts.h ===
#ifndef _RECEIPTS_H_
#define _RECEIPTS_H_

enum RECEIPTTYPE
{
    READRECEIPT,
    DELETERECEIPT,
};

#define MDN_REQUEST                 0x00000001


//Util functions related to receipts
BOOL IsMDN(IMimeMessage *pMsg);
BOOL IsReturnReceiptsAllowed();

HRESULT ProcessReturnReceipts(IMessageTable  *pMsgTable, 
                              IStoreCallback *pStoreCB, 
                              ROWINDEX        iRow, 
                              RECEIPTTYPE     ReceiptType,
                              FOLDERID        IdFolder,
                              IMimeMessage *pMessage);

HRESULT SetRootHeaderFields(IMimeMessage  *pMessageRcpt, 
                         IMimeMessage     *pOriginalMsg, 
                         LPWSTR           lpszNotificationTo,
                         RECEIPTTYPE      ReceiptType);

HRESULT InsertReadableText(IMimeMessage  *pMessageRcpt, 
                           IMimeMessage *pOriginalMsg);

HRESULT InsertSecondComponent(IMimeMessage *pMessageRcpt, 
                              IMimeMessage     *pOriginalMsg);

BOOL    PromptReturnReceipts(IStoreCallback   *pStoreCB);

HRESULT CheckForLists(IMimeMessage   *pOriginalMsg, 
                      IStoreCallback   *pStoreCB, 
                      IImnAccount   *pDefAccount);

HRESULT AddOriginalAndFinalRecipient(IMimeMessage *pOriginalMsg,
                                  IMimeMessage *pMessageRcpt,
                                  IStream      *pStream);
 
DWORD   GetLockKeyValue(LPCTSTR     pszValue);

BOOL  fMessageEncodingMatch(IMimeMessage *pMsg);

void  ShowErrorMessage(IStoreCallback   *pStoreCB);

#endif //_RECEIPTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\receipts.cpp ===
#include "pch.hxx"
#include <cryptdlg.h>
#include "strconst.h"
#include "msoert.h"
#include "resource.h"
#include "mailutil.h"
#include "ipab.h"
#include "receipts.h"
#include "oestore.h"
#include "shlwapip.h" 
#include "goptions.h"
#include "conman.h"
#include "multlang.h"
#include "demand.h"
#include "secutil.h"

#ifdef SMIME_V3
HRESULT ProcessSecureReceipt(IMimeMessage * pMsg, IStoreCallback  *pStoreCB);
INT_PTR CALLBACK SecRecResDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
#endif // SMIME_V3

const WCHAR c_szReadableTextFirst[]     = L"This is a receipt for the mail you sent to\r\n";
const WCHAR c_szReadableTextSecond[]    = L"\r\n\r\nThis receipt verifies that the message has been displayed on the recipient's computer at ";
const WCHAR c_szReceiptsAt[]            = L" at ";
const WCHAR c_szReadReceipt[]           = L"Read: %s";

const WCHAR c_szSecReadReceipt[]           = L"Secure Receipt: %s";

//Does not include NULL
const int cbReadableTextFirst     = sizeof(c_szReadableTextFirst)     - sizeof(*c_szReadableTextFirst);
const int cbReadableTextSecond    = sizeof(c_szReadableTextSecond)    - sizeof(*c_szReadableTextSecond);
const int cbReceiptsAt            = sizeof(c_szReceiptsAt)            - sizeof(*c_szReceiptsAt);

//Include NULL
const int cbReadReceipt           = sizeof(c_szReadReceipt);


//Not wide, does not include NULL
const TCHAR c_szDisposition[]           = TEXT("\r\nDisposition: manual-action/");
const TCHAR c_szMDNSendAutomatically[]  = TEXT("MDN-sent-automatically; ");
const TCHAR c_szMDNSendManually[]       = TEXT("MDN-sent-manually; ");
const TCHAR c_szOriginalRecipient[]     = TEXT("\r\nOriginal-Recipient: rfc822;");
const TCHAR c_szFinalRecipient[]        = TEXT("Final-Recipient: rfc822;");
const TCHAR c_szOriginalMessageId[]     = TEXT("\r\nOriginal-Message-ID: ");
const TCHAR c_szDisplayed[]             = TEXT("displayed\r\n");

//Does not include NULL
const int cbDisposition           = sizeof(c_szDisposition)           - sizeof(*c_szDisposition);
const int cbMDNSendAutomatically  = sizeof(c_szMDNSendAutomatically)  - sizeof(*c_szMDNSendAutomatically);
const int cbMDNSendManually       = sizeof(c_szMDNSendManually)       - sizeof(*c_szMDNSendManually);
const int cbOriginalRecipient     = sizeof(c_szOriginalRecipient)     - sizeof(*c_szOriginalRecipient);
const int cbFinalRecipient        = sizeof(c_szFinalRecipient)        - sizeof(*c_szFinalRecipient);
const int cbOriginalMessageId     = sizeof(c_szOriginalMessageId)     - sizeof(*c_szOriginalMessageId);
const int cbDisplayed             = sizeof(c_szDisplayed)             - sizeof(*c_szDisplayed);


HRESULT ProcessReturnReceipts(IMessageTable  *pTable, 
                             IStoreCallback  *pStoreCB,
                             ROWINDEX        iRow, 
                             RECEIPTTYPE     ReceiptType,
                             FOLDERID        IdFolder,
                             IMimeMessage *pMsg)
{
    IMimeMessage        *pMessage       = NULL;
    IMimeMessage        *pMessageRcpt   = NULL;
    BOOL                fSendImmediate  = FALSE;
    BOOL                fMail           = TRUE;
    LPWABAL             lpWabal         = NULL;
    LPWSTR              lpsz            = NULL;
    MESSAGEINFO         *pMsgInfo       = NULL;
    IImnAccount         *pTempAccount   = NULL;
    HRESULT             hr              = S_OK;
    DWORD               dwOption;
    PROPVARIANT         var = {0};
    FOLDERINFO          FolderInfo = {0};

    TraceCall("ProcessReturnReceipts");

   if (!pTable || !g_pAcctMan)
        return TraceResult(E_INVALIDARG);

    IF_FAILEXIT(hr = g_pStore->GetFolderInfo(IdFolder, &FolderInfo));

    if (FolderInfo.tySpecial == FOLDER_OUTBOX || FolderInfo.tyFolder == FOLDER_NEWS)
    {
        goto exit;
    }

    //First of all check if this has already been processed
    IF_FAILEXIT(hr = pTable->GetRow(iRow, &pMsgInfo));
    
    if ((!pMsgInfo) || (pMsgInfo->dwFlags & (ARF_RCPT_PROCESSED | ARF_NEWSMSG)))
        goto exit;

    //Mark this flag as having been processed
    IF_FAILEXIT(hr = pTable->Mark(&iRow, 1, APPLY_SPECIFIED, MARK_MESSAGE_RCPT_PROCESSED, pStoreCB));

    if(!pMsg)
        IF_FAILEXIT(hr = pTable->OpenMessage(iRow, 0, &pMessage, pStoreCB));
    else
        pMessage = pMsg;
        
#ifdef SMIME_V3
    // Secure receipt check
    hr = ProcessSecureReceipt(pMessage, pStoreCB);
    if(hr != S_OK)
        goto exit;
#endif // SMIME_V3

    dwOption = DwGetOption(OPT_MDN_SEND_RECEIPT);
    if (dwOption == MDN_DONT_SENDRECEIPT)
        goto exit;

    hr = MimeOleGetBodyPropW(pMessage, HBODY_ROOT, STR_HDR_DISP_NOTIFICATION_TO, 
                                        NOFLAGS, &lpsz);

    if (FAILED(hr) || !lpsz || !*lpsz)
    {
        //Check if there is a Return-Receipt-To header
        hr = MimeOleGetBodyPropW(pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_RETRCPTTO), 
                                        NOFLAGS, &lpsz);

        if (FAILED(hr) || !lpsz || !*lpsz)
        {
            if (hr == MIME_E_NOT_FOUND)
            {
                //this is a legitimate error, so we don't want to show an error to the user
                hr = S_OK;
            }
            goto exit;
        }
    }

    if (dwOption == MDN_PROMPTFOR_SENDRECEIPT)
    {
        if (!PromptReturnReceipts(pStoreCB))
        goto exit;
    }

    var.vt = VT_LPSTR;
    
    IF_FAILEXIT(hr = pMessage->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var));

    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pTempAccount));
    
    if ((dwOption == MDN_SENDRECEIPT_AUTO) && (!!DwGetOption(OPT_TO_CC_LINE_RCPT)))
    {
        IF_FAILEXIT(hr = CheckForLists(pMessage, pStoreCB, pTempAccount));

        if (hr == S_FALSE)
        {
            // My name is not found in the list. So we don't send a receipt. 
            // However this is not failure.
            goto exit;
        }
    }

    IF_FAILEXIT(hr = HrCreateMessage (&pMessageRcpt));

    IF_FAILEXIT(hr = SetRootHeaderFields(pMessageRcpt, pMessage, lpsz, READRECEIPT));
                
    IF_FAILEXIT(hr = HrSetAccountByAccount(pMessageRcpt, pTempAccount));

    IF_FAILEXIT(hr = HrGetWabalFromMsg(pMessageRcpt, &lpWabal));

    IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMessageRcpt, pTempAccount, lpWabal, TRUE, 0, FALSE));

    IF_FAILEXIT(hr = HrSetWabalOnMsg(pMessageRcpt, lpWabal));

    fSendImmediate = (DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline());

    IF_FAILEXIT(hr = SendMailToOutBox((IStoreCallback*)pStoreCB, pMessageRcpt, fSendImmediate, FALSE, fMail));

exit:
    
    //Show an error if it failed
    if (FAILED(hr))
        ShowErrorMessage(pStoreCB);

    g_pStore->FreeRecord(&FolderInfo);
    
    SafeMemFree(var.pszVal);

    pTable->ReleaseRow(pMsgInfo);

    SafeRelease(pMessageRcpt);

    SafeRelease(pTempAccount);

    SafeRelease(lpWabal);

    SafeMemFree(lpsz);

    if(!pMsg)
        SafeRelease(pMessage);

    return hr;
}


HRESULT SetRootHeaderFields(IMimeMessage   *pMessageRcpt, 
                            IMimeMessage   *pOriginalMsg, 
                            LPWSTR          lpszNotificationTo,
                            RECEIPTTYPE     ReceiptType)
{
    HRESULT             hr              = S_OK;
    LPWSTR              lpsz            = NULL;
    LPWSTR              szParam         = NULL;
    UINT                ResId;
    LPWSTR              pszRefs         = NULL;
    LPWSTR              pszOrigRefs     = NULL;
    LPWSTR              pszNewRef       = NULL;
    WCHAR               lpBuffer[CCHMAX_STRINGRES];
    int                 cch = 0;

    // Trace
    TraceCall("_SetRootHeaderFields");

    // Set the subject and the To field.
    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, lpszNotificationTo));

    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &lpsz));

    switch (ReceiptType)
    {
        case DELETERECEIPT:
            ResId = idsDeleteReceipt;
            break;

        case READRECEIPT:
        default:
            ResId = idsReadReceipt;
            break;
    }

    if (fMessageEncodingMatch(pOriginalMsg))
    {
        AthLoadStringW(ResId, lpBuffer, ARRAYSIZE(lpBuffer));
    }
    else
    {
        //The encoding didn't match, so we just load english headers
        StrCpyNW(lpBuffer, c_szReadReceipt, ARRAYSIZE(lpBuffer));
    }

    cch = lstrlenW(lpsz) + lstrlenW(lpBuffer) + 1;
    IF_FAILEXIT(hr = HrAlloc((LPVOID*)&szParam,  cch * sizeof(WCHAR)));

    wnsprintfW(szParam, cch, lpBuffer, lpsz);

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, szParam));

    //Set Time
    IF_FAILEXIT(hr = HrSetSentTimeProp(pMessageRcpt, NULL));

    //Set References property
    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pszNewRef));

    //No need to check for return value. It gets handled correctly in HrCreateReferences
    MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &pszOrigRefs);

    IF_FAILEXIT(hr = HrCreateReferences(pszOrigRefs, pszNewRef, &pszRefs));

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, pszRefs));

    //Readable text
    //TODO: Change the file name depending on the ReceiptType
    IF_FAILEXIT(hr = InsertReadableText(pMessageRcpt, pOriginalMsg));

    //Create the second part
    IF_FAILEXIT(hr = InsertSecondComponent(pMessageRcpt, pOriginalMsg));

    //Set Content-type field. Content-type: multipart/report; report-type=disposition-notification;
    //Content-type is multipart, sub-content-type is report and report-type is a parameter whose 
    //value should be set to disposition-notification
    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, c_szMultiPartReport));

    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, HBODY_ROOT, STR_PAR_REPORTTYPE, PDF_ENCODED, c_szDispositionNotification));

exit:
    SafeMemFree(lpsz);
    SafeMimeOleFree(pszNewRef);
    SafeMemFree(szParam);
    SafeMimeOleFree(pszOrigRefs);
    SafeMemFree(pszRefs);
    return(hr);
}

HRESULT InsertReadableText(IMimeMessage  *pMessageRcpt, IMimeMessage *pOriginalMsg)
{
    HBODY           hBody;
    IStream         *pStream    = NULL;
    HRESULT         hr          = S_OK;
    LPWSTR          lpsz        = NULL;
    ULONG           cbWritten;
    WCHAR           lpBuffer[CCHMAX_STRINGRES];
    HCHARSET        hCharset = NULL;
    WCHAR           wszReceiptSentDate[CCHMAX_STRINGRES];
    WCHAR           wszOriginalSentDate[CCHMAX_STRINGRES];
    PROPVARIANT     varOriginal;
    PROPVARIANT     var;
    INETCSETINFO    CsetInfo = {0};

    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, &lpsz));

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream((IStream**)&pStream));

    varOriginal.vt = VT_FILETIME;
    IF_FAILEXIT(hr = pOriginalMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &varOriginal));


    var.vt = VT_FILETIME;
    IF_FAILEXIT(hr = pMessageRcpt->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &var));
    
    if (fMessageEncodingMatch(pOriginalMsg))
    {
        AthLoadStringW(idsReadableTextFirst, lpBuffer, CCHMAX_STRINGRES);

        IF_FAILEXIT(hr = pStream->Write(lpBuffer, lstrlenW(lpBuffer) * sizeof(WCHAR), &cbWritten));

        IF_FAILEXIT(hr = pStream->Write(lpsz, lstrlenW(lpsz) * sizeof(WCHAR), &cbWritten));

        *lpBuffer = 0;

        AthLoadStringW(idsReceiptAt, lpBuffer, CCHMAX_STRINGRES);
        
        IF_FAILEXIT(hr = pStream->Write(lpBuffer, lstrlenW(lpBuffer) * sizeof(WCHAR), &cbWritten));

        *wszOriginalSentDate = 0;
        AthFileTimeToDateTimeW(&varOriginal.filetime, wszOriginalSentDate, ARRAYSIZE(wszOriginalSentDate),
                            DTM_NOSECONDS);

        IF_FAILEXIT(hr = pStream->Write(wszOriginalSentDate, lstrlenW(wszOriginalSentDate) * sizeof(*wszOriginalSentDate), 
                                        &cbWritten));

        AthLoadStringW(idsReadableTextSecond, lpBuffer, CCHMAX_STRINGRES);

        IF_FAILEXIT(hr = pStream->Write(lpBuffer, lstrlenW(lpBuffer) * sizeof(WCHAR), &cbWritten));

        *wszReceiptSentDate = 0;
        AthFileTimeToDateTimeW(&var.filetime, wszReceiptSentDate, ARRAYSIZE(wszReceiptSentDate),
                                DTM_NOSECONDS);
    }
    else
    {
        //Insert English headers and content

        IF_FAILEXIT(hr = pStream->Write(c_szReadableTextFirst, cbReadableTextFirst, &cbWritten));

        IF_FAILEXIT(hr = pStream->Write(lpsz, lstrlenW(lpsz) * sizeof(WCHAR), &cbWritten));
        
        IF_FAILEXIT(hr = pStream->Write(c_szReceiptsAt, cbReceiptsAt, &cbWritten));

        //Original Sent Date
        *wszOriginalSentDate = 0;
        AthFileTimeToDateTimeW(&varOriginal.filetime, wszOriginalSentDate, ARRAYSIZE(wszOriginalSentDate),
                                DTM_FORCEWESTERN | DTM_NOSECONDS);

        IF_FAILEXIT(hr = pStream->Write(wszOriginalSentDate, lstrlenW(wszOriginalSentDate) * sizeof(*wszOriginalSentDate), 
                                        &cbWritten));

        //Second line of readable text
        IF_FAILEXIT(hr = pStream->Write(c_szReadableTextSecond, cbReadableTextSecond, &cbWritten));        


        //Receipt Sent Date
        *wszReceiptSentDate = 0;
        AthFileTimeToDateTimeW(&var.filetime, wszReceiptSentDate, ARRAYSIZE(wszReceiptSentDate),
                                DTM_FORCEWESTERN | DTM_NOSECONDS);
    }

    IF_FAILEXIT(hr = pStream->Write(wszReceiptSentDate, lstrlenW(wszReceiptSentDate) * sizeof(*wszReceiptSentDate), 
                                        &cbWritten));

    IF_FAILEXIT(hr = pOriginalMsg->GetCharset(&hCharset));

    // re-map CP_JAUTODETECT and CP_KAUTODETECT if necessary
    // re-map iso-2022-jp to default charset if they are in the same category
    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CsetInfo));
    
    IF_NULLEXIT(hCharset = GetMimeCharsetFromCodePage(GetMapCP(CsetInfo.cpiInternet, FALSE)));
    
    IF_FAILEXIT(hr = pMessageRcpt->SetCharset(hCharset, CSET_APPLY_ALL));

    IF_FAILEXIT(hr = pMessageRcpt->SetTextBody(TXT_PLAIN, IET_UNICODE, NULL, pStream, &hBody));

exit:
    SafeRelease(pStream);
    SafeMemFree(lpsz);
    return hr;
}

HRESULT InsertSecondComponent(IMimeMessage  *pMessageRcpt, IMimeMessage     *pOriginalMsg)
{
    HBODY               hBody;
    ULONG               cbWritten;
    IStream             *pStream    = NULL;
    LPTSTR              lpsz        = NULL;
    HRESULT             hr          = S_OK;

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream((IStream**)&pStream));

    //Final Recipient
    IF_FAILEXIT(hr = AddOriginalAndFinalRecipient(pOriginalMsg, pMessageRcpt, pStream));
    
    //Original Message Id
    IF_FAILEXIT(hr = MimeOleGetBodyPropA(pOriginalMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &lpsz));

    IF_FAILEXIT(hr = pStream->Write(c_szOriginalMessageId, cbOriginalMessageId, &cbWritten));

    IF_FAILEXIT(hr = pStream->Write(lpsz, lstrlen(lpsz) * sizeof(TCHAR), &cbWritten));


    //TODO:If the receipt type is deleted, change the last parameter to reflect the correct string

    IF_FAILEXIT(hr = pStream->Write(c_szDisposition, cbDisposition, &cbWritten));

    if (DwGetOption(OPT_MDN_SEND_RECEIPT) == MDN_PROMPTFOR_SENDRECEIPT)
        IF_FAILEXIT(hr = pStream->Write(c_szMDNSendManually, cbMDNSendManually, &cbWritten));
    else
        IF_FAILEXIT(hr = pStream->Write(c_szMDNSendAutomatically, cbMDNSendAutomatically, &cbWritten));
            
    IF_FAILEXIT(hr = pStream->Write(c_szDisplayed, cbDisplayed, &cbWritten));

    IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

    IF_FAILEXIT(hr = pMessageRcpt->AttachObject(IID_IStream, pStream, &hBody));

    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, hBody, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, c_szMessageDispNotification));

    //Change the content-disposition header field to inline, so that this body gets copied and not get attached.
    IF_FAILEXIT(hr = MimeOleSetBodyPropA(pMessageRcpt, hBody, PIDTOSTR(PID_HDR_CNTDISP), NOFLAGS, STR_DIS_INLINE));

exit:
    MemFree(lpsz);
    ReleaseObj(pStream);

    return hr;
}

HRESULT AddOriginalAndFinalRecipient(IMimeMessage *pOriginalMsg,
                          IMimeMessage *pMessageRcpt,
                          IStream      *pStream)
{
    IMimeEnumAddressTypes   *pEnumAddrTypes = NULL;
    HRESULT                 hr = S_OK;
    ULONG                   cbWritten;
    ULONG                   Count;
    ADDRESSPROPS            AddressProps;
    ULONG                   cFetched;
    IMimeAddressTable       *pAddrTable = NULL;
    LPTSTR                  lpszOriginalRecip = NULL;
    ADDRESSLIST             addrList = {0};

    IF_FAILEXIT(hr = pOriginalMsg->BindToObject(HBODY_ROOT, IID_IMimeAddressTable, (LPVOID*)&pAddrTable));

    IF_FAILEXIT(hr = pAddrTable->EnumTypes(IAT_FROM, IAP_EMAIL, &pEnumAddrTypes));
    
#ifdef DEBUG
    IF_FAILEXIT(hr = pEnumAddrTypes->Count(&Count));

    Assert (Count == 1);
#endif DEBUG

    IF_FAILEXIT(hr = pEnumAddrTypes->Next(1, &AddressProps, &cFetched));

    Assert(cFetched == 1);
    
    if (!(AddressProps.pszEmail) || !(*AddressProps.pszEmail))
    {
        hr = E_FAIL;
        goto exit;
    }

    IF_FAILEXIT(hr = pStream->Write(c_szFinalRecipient, cbFinalRecipient, &cbWritten));

    IF_FAILEXIT(hr = pStream->Write(AddressProps.pszEmail, lstrlen(AddressProps.pszEmail) * sizeof(TCHAR), &cbWritten));

    hr = MimeOleGetBodyPropA(pOriginalMsg, HBODY_ROOT, STR_HDR_ORIG_RECIPIENT, NOFLAGS, &lpszOriginalRecip);
    if (SUCCEEDED(hr))
    {
        IF_FAILEXIT(hr = MimeOleParseRfc822Address(IAT_TO, IET_ENCODED, lpszOriginalRecip, &addrList));
        
        if (addrList.cAdrs > 0)
        {
            IF_FAILEXIT(hr = pStream->Write(c_szOriginalRecipient, cbOriginalRecipient, &cbWritten));

            IF_FAILEXIT(hr = pStream->Write(addrList.prgAdr[0].pszEmail, lstrlen(addrList.prgAdr[0].pszEmail), &cbWritten));
        }
    }
    else
    {
        if (hr == MIME_E_NOT_FOUND)
            hr = S_OK;
    }

exit:
    if (g_pMoleAlloc)
    {
        g_pMoleAlloc->FreeAddressProps(&AddressProps);

        if (addrList.cAdrs)
            g_pMoleAlloc->FreeAddressList(&addrList);
    }

    ReleaseObj(pEnumAddrTypes);

    ReleaseObj(pAddrTable);

    MemFree(lpszOriginalRecip);
    
    return hr;
}

HRESULT CheckForLists(IMimeMessage   *pOriginalMsg, IStoreCallback   *pStoreCB, IImnAccount   *pDefAccount)
{
    HRESULT                 hr                  = S_OK;
    IMimeEnumAddressTypes   *pEnumAddrTypes     = NULL;
    ULONG                   cbAddrTypes;
    ULONG                   cFetched;
    ADDRESSPROPS            *prgAddress         = NULL;
    TCHAR                   szEmail[CCHMAX_EMAIL_ADDRESS];
    DWORD                   index;
    
    IF_FAILEXIT(hr = pOriginalMsg->EnumAddressTypes(IAT_TO | IAT_CC, IAP_EMAIL, &pEnumAddrTypes));
        
    IF_FAILEXIT(hr = pEnumAddrTypes->Count(&cbAddrTypes));

    IF_FAILEXIT(hr = HrAlloc((LPVOID*)&prgAddress, cbAddrTypes * sizeof(ADDRESSPROPS)));

    IF_FAILEXIT(hr = pEnumAddrTypes->Next(cbAddrTypes, prgAddress, &cFetched));
    
    IF_FAILEXIT(hr = pDefAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmail, ARRAYSIZE(szEmail)));
    
    if (!(*szEmail))
    {
        hr = E_FAIL;
        goto exit;    
    }

    for (index = 0; index < cFetched; index++)
    {
        if (lstrcmpi(szEmail, (prgAddress + index)->pszEmail) == 0)
            break;
    }

    if (index == cFetched)
    {
        //We did not find it.
        hr = S_FALSE;
    }

exit:

    if (g_pMoleAlloc && prgAddress)
    {
        for (index = 0; index < cFetched; index++)
        {
            g_pMoleAlloc->FreeAddressProps(&prgAddress[index]);
        }
    }

    MemFree(prgAddress);

    ReleaseObj(pEnumAddrTypes);
    
    return hr;
}

void ShowErrorMessage(IStoreCallback    *pStoreCB)
{
    HWND    hwnd;

    Assert(pStoreCB);

    if (SUCCEEDED(pStoreCB->GetParentWindow(0, &hwnd)))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsReceiptsError),
                      0, MB_OK);
    }
}

BOOL PromptReturnReceipts(IStoreCallback   *pStoreCB)
{
    HWND    hwnd;
    int     idAnswer;
    BOOL    fRet = FALSE;
//  HWND    hwndFocus;

    if (SUCCEEDED(pStoreCB->GetParentWindow(0, &hwnd)))
    {
        /*
        hwndFocus = GetFocus();
        if (hwndFocus != hwnd)
            hwnd = hwndFocus;
        */

        idAnswer = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsPromptReturnReceipts),
                                          0, MB_YESNO | MB_ICONEXCLAMATION );

        fRet = (idAnswer == IDYES);
    }

    return fRet;
}

BOOL IsMDN(IMimeMessage *pMsg)
{
    LPTSTR      lpsz    = NULL;
    BOOL        fRetVal = FALSE;

    
    if (SUCCEEDED(MimeOleGetBodyPropA(pMsg, HBODY_ROOT, STR_PAR_REPORTTYPE, NOFLAGS, &lpsz)) && (lpsz) && (*lpsz))
    {         
        if (lstrcmp(c_szDispositionNotification, lpsz))
        {
            fRetVal = TRUE;
        }

        MemFree(lpsz);
    }
    return fRetVal;
}

DWORD   GetLockKeyValue(LPCTSTR     pszValue)
{
    DWORD   cbData;
    DWORD   dwLocked = FALSE;
    DWORD   dwType;
    HKEY    hKeyLM;

    cbData = sizeof(DWORD);
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, c_szRequestMDNLocked, &dwType, (LPBYTE)&dwLocked, &cbData)) &&
        (ERROR_SUCCESS != AthUserGetValue(NULL, pszValue, &dwType, (LPBYTE)&dwLocked, &cbData)))
        dwLocked = FALSE;

    return dwLocked;
}

BOOL  fMessageEncodingMatch(IMimeMessage *pMsg)
{
    INETCSETINFO    CharsetInfo;
    BOOL            fret = FALSE;
    HRESULT         hr = S_OK;
    HCHARSET        hCharset = NULL;
    CODEPAGEINFO    CodePage = {0};

    Assert(pMsg);

    IF_FAILEXIT(hr = pMsg->GetCharset(&hCharset));

    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CharsetInfo));

    /*
    if (CharsetInfo.cpiWindows == GetACP() || CharsetInfo.cpiWindows == CP_UNICODE)
        fret = TRUE;
    */

    IF_FAILEXIT(hr = MimeOleGetCodePageInfo(CharsetInfo.cpiInternet, &CodePage));

    if (CodePage.cpiFamily == GetACP() || CodePage.cpiFamily == CP_UNICODE)
        fret = TRUE;
exit:

    return fret;
}

#ifdef SMIME_V3

static const BYTE RgbASNForSHASign[11] = 
{
    0x30, 0x09, 0x30, 0x07, 0x06, 0x05, 0x2b, 0x0e, 
    0x03, 0x02, 0x1a
};


// Auto association of signing certificate for secure receipt
BOOL AutoAssociateCert(BOOL *fAllowTryAgain, HWND hwnd, IImnAccount *pTempAccount)
{
    if(*fAllowTryAgain)
    {
        *fAllowTryAgain = FALSE;
        if (SUCCEEDED(_HrFindMyCertForAccount(hwnd, NULL, pTempAccount, FALSE)))
            return(TRUE);
    }
    return(FALSE);
}


void ErrorSendSecReceipt(HWND hwnd, HRESULT hr, IImnAccount *pAccount)
{
    if(hr == HR_E_ATHSEC_NOCERTTOSIGN)
    {
        if(DialogBoxParam(g_hLocRes, 
                MAKEINTRESOURCE(iddErrSecurityNoSigningCert), hwnd, 
                ErrSecurityNoSigningCertDlgProc, NULL) == idGetDigitalIDs)
            GetDigitalIDs(pAccount);
    }
    else
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsCannotSendSecReceipt),
                      0, MB_OK | MB_ICONSTOP);
    return;
}

// Process secure receipts
HRESULT ProcessSecureReceipt(IMimeMessage * pMsg, IStoreCallback  *pStoreCB)
{

    IMimeMessage        *pMessageRcpt   = NULL;
    IMimeBody *         pBody = NULL;
    IMimeBody *         pBodyRec = NULL;
    IMimeSecurity2 *    pSMIME3 = NULL;
    CERT_NAME_BLOB      *rgReceiptFromList = NULL;
    DWORD               cReceiptFromList = 0;
    PCX509CERT          pCert = NULL;
    THUMBBLOB           tbCert = {0, 0};
    HCERTSTORE          hMyCertStore = NULL;
    X509CERTRESULT      certResult;
    CERTSTATE           cs;
    LPVOID              pv = NULL;
    DWORD               dwBits = 40;
    DWORD               cb = 0;
    LPBYTE              pBlobData = NULL;
    ULONG               ulSecurityType = MST_CLASS_SMIME_V1;

    LPWABAL             lpWabal = NULL;
    PROPVARIANT         var = {0};
    DWORD               dwOption = 0;
    UINT                uiRes = 0;
    HRESULT             hr = S_OK;
    IImnAccount         *pTempAccount   = NULL;
    HWND                hwnd = NULL;
    TCHAR               szEmail[CCHMAX_EMAIL_ADDRESS];
    BOOL                fSendImmediate  = FALSE;
    LPWSTR              lpsz            = NULL;
    WCHAR               lpBuffer[CCHMAX_STRINGRES];
    LPWSTR              szParam         = NULL;
    SECSTATE            secStateRec = {0};
    BOOL                fAllowTryAgain = TRUE;
    PCCERT_CONTEXT      *rgCertChain = NULL;
    DWORD               cCertChain = 0;
    const DWORD         dwIgnore = CERT_VALIDITY_NO_CRL_FOUND;
    DWORD               dwTrust = 0;
    LPWSTR              pszRefs         = NULL;
    LPWSTR              pszOrigRefs     = NULL;
    LPWSTR              pszNewRef       = NULL;
    HCHARSET            hCharset = NULL;
    INETCSETINFO        CsetInfo = {0};
    HBODY               hBody = NULL;
    int                 cch;

    Assert(pMsg != NULL);

    // get windof for error messages
    IF_FAILEXIT(hr = pStoreCB->GetParentWindow(0, &hwnd));

    // if option set DO NOT send secure receipt then exit
    dwOption = DwGetOption(OPT_MDN_SEC_RECEIPT);
    if (dwOption == MDN_DONT_SENDRECEIPT)
        goto exit;

    // check do we have secure receipt request in message?
    IF_FAILEXIT(hr = HrGetInnerLayer(pMsg, &hBody));

    IF_FAILEXIT(hr = pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void**)&pBody));

    IF_FAILEXIT(hr = pBody->GetOption(OID_SECURITY_TYPE, &var));

    if(!(var.ulVal & MST_RECEIPT_REQUEST))
    {
        var.ulVal = 0; // Set to 0, because var.pszVal and var.ulVal point to the same address.
        hr = S_OK;
        goto exit;
    }
    // Check do we trust this message: Bug 78118
    IF_FAILEXIT(hr = HrGetSecurityState(pMsg, &secStateRec, NULL));
    if(!IsSignTrusted(&secStateRec))
    {
        // do not show any error message in this case,  just exit
        hr = S_OK;
        goto exit;
    }

    // we have request, check that we would like to send receipt
    if (dwOption == MDN_PROMPTFOR_SENDRECEIPT)
    {
        uiRes = (UINT) DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSecResponse),
            hwnd, SecRecResDlgProc, (LPARAM) 0);

        if(uiRes == 0)
        {
            hr = S_FALSE;
            goto exit;
        }
        else if((uiRes != IDOK) && (uiRes != IDYES))           // IDYES means we will encrypt receipt
        {
            hr = S_OK;
            goto exit;
        }
    }

    // Get SMIME3 Security interface on message
    IF_FAILEXIT(hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pSMIME3));

    // Get List of people who should send receipts
    IF_FAILEXIT(hr = pSMIME3->GetReceiptSendersList(0, &cReceiptFromList,&rgReceiptFromList));

    // Check if asking for receipt from noone
    if (hr == S_FALSE) 
    {
        hr = S_OK;
        goto exit;
    }

    // Check account information
    var.vt = VT_LPSTR;
    
    IF_FAILEXIT(hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var));

    if(FAILED(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pTempAccount)))
    {
        MemFree(var.pszVal);
        goto exit;
    }

    SafeMemFree(var.pszVal);

    // Check that we are in secure list
    IF_FAILEXIT(hr = pTempAccount->GetPropSz(AP_SMTP_EMAIL_ADDRESS, szEmail, ARRAYSIZE(szEmail)));

    if(!FNameInList(szEmail, cReceiptFromList,rgReceiptFromList))
    {
        // we are not in list
        hr = S_FALSE;
        goto exit;
    }

    // Get a certificate for receipt
Try_agian:
    if((hr = pTempAccount->GetProp(AP_SMTP_CERTIFICATE, NULL, &tbCert.cbSize)) != S_OK)
    {
        if(AutoAssociateCert(&fAllowTryAgain, hwnd, pTempAccount))
            goto Try_agian;
        else
        {
            hr = HR_E_ATHSEC_NOCERTTOSIGN;
            goto exit;
        }

    }
    IF_FAILEXIT(hr = HrAlloc((void**)&tbCert.pBlobData, tbCert.cbSize));
    IF_FAILEXIT(hr = pTempAccount->GetProp(AP_SMTP_CERTIFICATE, tbCert.pBlobData, &tbCert.cbSize));

    hMyCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING,
                    NULL, CERT_SYSTEM_STORE_CURRENT_USER, c_szMyCertStore);

    if (hMyCertStore == NULL)
        goto exit;

    certResult.cEntries = 1;
    certResult.rgcs = &cs;
    certResult.rgpCert = &pCert;
                    
    if((hr = MimeOleGetCertsFromThumbprints(&tbCert, &certResult, &hMyCertStore, 1) != S_OK))
    {
        if(AutoAssociateCert(&fAllowTryAgain, hwnd, pTempAccount))
            goto Try_agian;
        else
        {
            hr = HR_E_ATHSEC_NOCERTTOSIGN;
            goto exit;
        }

    }

    // Check certificate
    // As to CRLs, if we'll ever have one!
    dwTrust = DwGenerateTrustedChain(hwnd, NULL, pCert,
                        dwIgnore, TRUE, &cCertChain, &rgCertChain);

    if (rgCertChain)
    {
        for (cCertChain--; int(cCertChain)>=0; cCertChain--)
            CertFreeCertificateContext(rgCertChain[cCertChain]);
        MemFree(rgCertChain);
        rgCertChain = NULL;
    }

    if (dwTrust)
    {
        if(AutoAssociateCert(&fAllowTryAgain, hwnd, pTempAccount))
            goto Try_agian;
        else
        {
            hr = HR_E_ATHSEC_NOCERTTOSIGN;
            goto exit;
        }

    }
        

    // Create receipt message
    IF_FAILEXIT(hr = pSMIME3->CreateReceipt(0, lstrlen(szEmail), (const BYTE *) szEmail, 1, &pCert, &pMessageRcpt));

//     IF_FAILEXIT(hr = HrCreateMessage (&pMessageRcpt));

//    IF_FAILEXIT(hr = SetRootHeaderFields(pMessageRcpt, pMsg, szEmail, READRECEIPT));  // szEmail is bug!

    // Subject
    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pMsg, HBODY_ROOT, STR_ATT_NORMSUBJ, NOFLAGS, &lpsz));
    if (fMessageEncodingMatch(pMsg))
    {
        AthLoadStringW(idsSecureReceiptText, lpBuffer, ARRAYSIZE(lpBuffer));
    }
    else
    {
        //The encoding didn't match, so we just load english headers
        StrCpyNW(lpBuffer, c_szSecReadReceipt, ARRAYSIZE(lpBuffer));
    }

    // Init security options
#if 0
    if(DwGetOption(OPT_MAIL_INCLUDECERT))
    {
        ulSecurityType |= ((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);
        HrInitSecurityOptions(pMessageRcpt, ulSecurityType);
    }
#endif // 0

    cch = lstrlenW(lpsz) + lstrlenW(lpBuffer) + 1;
    IF_FAILEXIT(hr = HrAlloc((LPVOID*)&szParam,  cch * sizeof(WCHAR)));

    wnsprintfW(szParam, cch, lpBuffer, lpsz);

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, szParam));

    //Set Time
    IF_FAILEXIT(hr = HrSetSentTimeProp(pMessageRcpt, NULL));

    //Set References property
    IF_FAILEXIT(hr = MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pszNewRef));

    //No need to check for return value. It gets handled correctly in HrCreateReferences
    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, &pszOrigRefs);

    IF_FAILEXIT(hr = HrCreateReferences(pszOrigRefs, pszNewRef, &pszRefs));

    IF_FAILEXIT(hr = MimeOleSetBodyPropW(pMessageRcpt, HBODY_ROOT, PIDTOSTR(PID_HDR_REFS), NOFLAGS, pszRefs));
               
    IF_FAILEXIT(hr = HrSetAccountByAccount(pMessageRcpt, pTempAccount));
//
    IF_FAILEXIT(hr = HrGetWabalFromMsg(pMessageRcpt, &lpWabal));

    IF_FAILEXIT(hr = HrSetSenderInfoUtil(pMessageRcpt, pTempAccount, lpWabal, TRUE, 0, FALSE));

    IF_FAILEXIT(hr = HrSetWabalOnMsg(pMessageRcpt, lpWabal));

//#if 0
    IF_FAILEXIT(hr = pMessageRcpt->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pBodyRec));

    // Set hash algorithm
    // Init with no symcap gives max allowed by providers
    MimeOleSMimeCapInit(NULL, NULL, &pv);

    MimeOleSMimeCapGetHashAlg(pv, NULL, &cb, &dwBits);

    var.vt = VT_BLOB;
    if(cb > 0)
    {
        if(!MemAlloc((LPVOID *)&pBlobData, cb)) 
            goto exit;

        // ZeroMemory(&pBlobData, cb);

        MimeOleSMimeCapGetHashAlg(pv, pBlobData, &cb, &dwBits);
        var.blob.cbSize = cb;
        var.blob.pBlobData = pBlobData;
    }
    else
    {
        var.blob.cbSize = sizeof(RgbASNForSHASign);
        var.blob.pBlobData = (LPBYTE) RgbASNForSHASign;
    }

    IF_FAILEXIT(hr = pBodyRec->SetOption(OID_SECURITY_ALG_HASH, &var));

#ifdef _WIN64
    var.vt = VT_UI8;
    var.pulVal = (ULONG *) hwnd;
    IF_FAILEXIT(hr = pBody->SetOption(OID_SECURITY_HWND_OWNER_64, &var));
#else
    var.vt = VT_UI4;
    var.ulVal = (DWORD) hwnd;
    IF_FAILEXIT(hr = pBodyRec->SetOption(OID_SECURITY_HWND_OWNER, &var));
    var.ulVal = 0; // Set to 0, because var.pszVal and var.ulVal point to the same address.
#endif // _WIN64

//    IF_FAILEXIT(hr = pMessageRcpt->Commit(0));
// #endif //0

    IF_FAILEXIT(hr = pMsg->GetCharset(&hCharset));

    // re-map CP_JAUTODETECT and CP_KAUTODETECT if necessary
    // re-map iso-2022-jp to default charset if they are in the same category

    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset, &CsetInfo));
    
    IF_NULLEXIT(hCharset = GetMimeCharsetFromCodePage(GetMapCP(CsetInfo.cpiInternet, FALSE)));

    IF_FAILEXIT(hr = pMessageRcpt->SetCharset(hCharset, CSET_APPLY_ALL));

    // should be new header
    
    fSendImmediate = (DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline());

    if (DwGetOption(OPT_MAIL_INCLUDECERT))
        IF_FAILEXIT(hr = SendSecureMailToOutBox((IStoreCallback*)pStoreCB, pMessageRcpt, fSendImmediate, FALSE, TRUE, NULL));
    else
        IF_FAILEXIT(hr = SendMailToOutBox((IStoreCallback*)pStoreCB, pMessageRcpt, fSendImmediate, FALSE, TRUE));
exit:
    if(FAILED(hr))
        ErrorSendSecReceipt(hwnd, hr, pTempAccount);

    CleanupSECSTATE(&secStateRec);
    SafeMemFree(lpsz);
    SafeMemFree(szParam);
    SafeMemFree(pBlobData);
    SafeMemFree(pv);
    SafeRelease(pBodyRec);
    SafeRelease(pMessageRcpt);

    if(hMyCertStore)
        CertCloseStore(hMyCertStore, 0);

    if(pCert)
        CertFreeCertificateContext(pCert);

    // if(tbCert.pBlobData)
    SafeMemFree(tbCert.pBlobData);
    SafeRelease(lpWabal);

    SafeRelease(pTempAccount);
    SafeRelease(pSMIME3);
    SafeRelease(pBody);
    SafeMimeOleFree(pszNewRef);
    SafeMimeOleFree(pszOrigRefs);
    MemFree(pszRefs);
    return(hr);
}

INT_PTR CALLBACK SecRecResDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg) 
    {
    case WM_INITDIALOG:
        CenterDialog(hwndDlg);
        CheckDlgButton(hwndDlg, IDC_ENCRECEIPT, (!!DwGetOption(OPT_SECREC_ENCRYPT)) ? BST_CHECKED : BST_UNCHECKED);
        break;
        
    case WM_COMMAND:
        switch (LOWORD(wParam)) 
        {
        case IDOK:
            
            EndDialog(hwndDlg, IsDlgButtonChecked(hwndDlg, IDC_ENCRECEIPT) ? IDYES : IDOK);
            break;        
    
        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;
            
        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}



#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\mail\uidlcmn.h ===
// ========================================================================================
// U I D L C M N . H
// ========================================================================================
#ifndef __UIDLCMN_H
#define __UIDLCMN_H

// ========================================================================================
// UIDLINFO
// ========================================================================================
typedef struct tagUIDLINFO
{
    BYTE            fDownloaded;
    BYTE            fDeletedOnClient;
    FILETIME        ftDownload;
    LPTSTR          lpszUidl;
    LPTSTR          lpszServer;
    LPTSTR          lpszUserName;

} UIDLINFO, *LPUIDLINFO;

#endif // __UIDLCMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\newsdlgs.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     newsdlgs.h
//
//  PURPOSE:    Defines general news dialogs
//

#ifndef __NEWSDLGS_H__
#define __NEWSDLGS_H__


/////////////////////////////////////////////////////////////////////////////
// Dialog callbacks

typedef struct tagUPDATENEWSGROUPINFO 
    {
    BOOL fNews;
    DWORD dwGroupFlags;
    DWORD cMarked;
    int   idCmd;
    } UPDATENEWSGROUPINFO, *PUPDATENEWSGROUPINFO;

INT_PTR CALLBACK UpdateNewsgroup(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

/////////////////////////////////////////////////////////////////////////////
// Control IDs

#define IDC_GET_CHECK                               1001
#define IDC_NEWHEADERS_RADIO                        1002
#define IDC_NEWMSGS_RADIO                           1003
#define IDC_ALLMSGS_RADIO                           1004
#define IDC_GETMARKED_CHECK                         1005



#endif // __NEWSDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\newsstor.h ===
/*
 *  n e w s s t o r . h
 *  
 *  Purpose:
 *      Derives from IMessageServer to implement news specific store communication
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _NEWSSTOR_H
#define _NEWSSTOR_H

#include "imnxport.h"
#include "range.h"

interface IMimeMessage;
typedef IMimeMessage *LPMIMEMESSAGE;
typedef DWORD MSGID;

class CNewsStore;
typedef HRESULT (CNewsStore::*PFNOPFUNC)(THIS_ void);

#define OPFLAG_DESCRIPTIONS     0x0001
#define OPFLAG_NOGROUPCMD       0x0002

typedef struct tagOPERATION
{
    STOREOPERATIONTYPE tyOperation;
    const PFNOPFUNC *pfnState;
    int iState;
    int cState;
    IStoreCallback *pCallback;
    NNTPSTATE nsPending;
    DWORD dwFlags;

    ULONG cPrevFolders;
    FOLDERID *pPrevFolders;
    FOLDERID idFolder;
    SYNCFOLDERFLAGS dwSyncFlags;
    SYSTEMTIME st;
    DWORD cHeaders;
    MESSAGEID idMessage;
    LPSTR pszArticleId;
    IStream *pStream;
    FILEADDRESS faStream;
    MESSAGEFLAGS dwMsgFlags;
    LPSTR pszGroup;
    DWORD idServerMessage;

    BOOL fCancel;
    STOREERROR error;
    DWORD dwProgress;
    DWORD dwTotal;
} OPERATION;

typedef struct tagSREFRESHOP {
    DWORD       dwFirstNew;
    DWORD       dwLast;
    DWORD       dwFirst;
    DWORD       dwChunk;
    DWORD       dwDlSize;
    UINT        uObtained;
    UINT        cOps;
    UINT        MaxOps;
    BOOL        fEnabled;
    BOOL        fOnlyNewHeaders;
} SREFRESHOP;

class CNewsStore :
        public IMessageServer,
        public INNTPCallback,
        public IOperationCancel,
        public INewsStore,
        public ITransportCallbackService
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CNewsStore(void);
    ~CNewsStore(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMessageServer Members
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder);
    STDMETHODIMP SetIdleCallback(IStoreCallback *pDefaultCallback);
    STDMETHODIMP SynchronizeFolder (SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, IStoreCallback  *pCallback);
    STDMETHODIMP GetMessage (MESSAGEID idMessage, IStoreCallback  *pCallback);
    STDMETHODIMP PutMessage (FOLDERID idFolder, MESSAGEFLAGS dwFlags, LPFILETIME pftReceived, IStream  *pStream, IStoreCallback  *pCallback);        
    STDMETHODIMP CopyMessages (IMessageFolder  *pDest, COPYMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteMessages (DELETEMESSAGEFLAGS dwOptions, LPMESSAGEIDLIST pList, IStoreCallback  *pCallback);
    STDMETHODIMP SetMessageFlags (LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP GetServerMessageFlags(MESSAGEFLAGS *pFlags);
    STDMETHODIMP SynchronizeStore (FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP CreateFolder (FOLDERID idParent, SPECIALFOLDER tySpecial, LPCSTR pszName, FLDRFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP MoveFolder (FOLDERID idFolder, FOLDERID idParentNew, IStoreCallback  *pCallback);
    STDMETHODIMP RenameFolder (FOLDERID idFolder, LPCSTR pszName, IStoreCallback  *pCallback);
    STDMETHODIMP DeleteFolder (FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback  *pCallback);
    STDMETHODIMP SubscribeToFolder (FOLDERID idFolder, BOOL fSubscribe, IStoreCallback  *pCallback);
    STDMETHODIMP GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback);
    STDMETHODIMP Close(DWORD dwFlags);
    STDMETHODIMP ConnectionAddRef() { return E_NOTIMPL; };
    STDMETHODIMP ConnectionRelease() { return E_NOTIMPL; };
    STDMETHODIMP GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback);
    STDMETHODIMP GetAdBarUrl(IStoreCallback     *pCallback) {return E_NOTIMPL;};
    STDMETHODIMP GetMinPollingInterval(IStoreCallback     *pCallback) {return E_NOTIMPL;};
    HRESULT      Initialize(FOLDERID idStoreRoot, LPCSTR pszAccountId);
    HRESULT      GetArticle(LPCSTR pszArticleId, IStream *pStream, IStoreCallback *pCallback);

    //----------------------------------------------------------------------
    // IOperationCancel Members
    //----------------------------------------------------------------------
    STDMETHODIMP Cancel(CANCELTYPE tyCancel);

    //----------------------------------------------------------------------
    // INNTPCallback Members
    //----------------------------------------------------------------------
    STDMETHODIMP OnTimeout (DWORD *pdwTimeout, IInternetTransport *pTransport);
    STDMETHODIMP OnLogonPrompt (LPINETSERVER pInetServer, IInternetTransport *pTransport);
    STDMETHODIMP_(INT) OnPrompt (HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    STDMETHODIMP OnStatus (IXPSTATUS ixpstatus, IInternetTransport *pTransport);
    STDMETHODIMP OnError (IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    STDMETHODIMP OnCommand (CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);
    STDMETHODIMP OnResponse (LPNNTPRESPONSE pResponse);

    //----------------------------------------------------------------------
    // ITransportCallbackService
    //----------------------------------------------------------------------
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);
    STDMETHODIMP GetAccount(LPDWORD pdwServerType, IImnAccount **ppAcount);

    //----------------------------------------------------------------------
    // INewsStore
    //----------------------------------------------------------------------
    STDMETHODIMP MarkCrossposts(LPMESSAGEIDLIST pList, BOOL fRead);

    HRESULT Connect(void);
    HRESULT Group(void);
    HRESULT GroupIfNecessary(void);
    HRESULT ExpireHeaders(void);
    HRESULT Headers(void);
    HRESULT Article(void);
    HRESULT Post(void);
    HRESULT List(void);
    HRESULT DeleteDeadGroups(void);
    HRESULT Descriptions(void);
    HRESULT NewGroups(void); 
    HRESULT XHdrReferences(void);
    HRESULT XHdrSubject(void);
    HRESULT WatchedArticles(void);

    static LRESULT CALLBACK NewsStoreWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    void        _FreeOperation(void);
    HRESULT     _DoOperation(void);
    HRESULT     _BeginDeferredOperation(void);
    HRESULT     _List(LPCSTR pszCommand);
    HRESULT     _ComputeHeaderRange(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, FOLDERINFO *pInfo, RANGE *pRange);
    void        _MarkCrossposts(LPCSTR szXRefs, BOOL fRead);

    BOOL        _CreateWnd(void);
    HRESULT     _CreateDataFilePath(LPCTSTR pszAccount, LPCTSTR pszFileName, LPTSTR pszPath, DWORD cchPathSize);
    
    BOOL        _FConnected() { return (m_pTransport && m_ixpStatus != IXP_DISCONNECTING && m_ixpStatus != IXP_DISCONNECTED ); }
    HRESULT     _HandleArticleResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleListResponse(LPNNTPRESPONSE pResp, BOOL fNew);
    HRESULT     _HandleHeadResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleGroupResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandlePostResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleXHdrReferencesResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleXHdrSubjectResponse(LPNNTPRESPONSE pResp);
    HRESULT     _HandleWatchedArticleResponse(LPNNTPRESPONSE pResp);

    void        _FillStoreError(LPSTOREERROR pErrorInfo, IXPRESULT *pResult, LPSTR pszGroup = NULL);
    BOOL        _IsWatchedThread(LPSTR pszRef, LPSTR pszSubject);
    HRESULT     _SaveMessageToStore(IMessageFolder *pFolder, DWORD id, LPSTREAM pstm);

    //----------------------------------------------------------------------
    // Class Member Data
    //----------------------------------------------------------------------
private:
    
    LONG                    m_cRef;         // Reference Counting
    HWND                    m_hwnd;
    IMessageStore          *m_pStore;
    IMessageFolder         *m_pFolder;
    FOLDERID                m_idFolder;
    FOLDERID                m_idParent;
    char                    m_szGroup[256];
    char                    m_szAccountId[CCHMAX_ACCOUNT_NAME];

    OPERATION               m_op;
    SREFRESHOP             *m_pROP;

    INNTPTransport         *m_pTransport;
    IXPSTATUS               m_ixpStatus;
    INETSERVER              m_rInetServerInfo;
    DWORD                   m_dwLastStatusTicks;

    // GetWatchInfo state
    DWORD                   m_dwWatchLow;
    DWORD                   m_dwWatchHigh;

    LPTSTR                 *m_rgpszWatchInfo;
    BOOL                    m_fXhdrSubject;
    CRangeList              m_cRange;
    DWORD                   m_cCurrent;
    DWORD                   m_cTotal;

    IMessageTable          *m_pTable; // Used for downloading Watched Messages.

#ifdef DEBUG
    DWORD                   m_dwThreadId;
#endif // DEBUG
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT CreateNewsStore(IUnknown *pUnkOuter, IUnknown **ppUnknown);
HRESULT NewsUtil_CreateDataFilePath(LPCTSTR pszAccount, LPCTSTR pszFileName, LPTSTR pszPath);

#endif  //_NEWSSTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\grpdlg.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     GrpDlg.h
//
//  PURPOSE:    Defines the CGroupListDlg class.
//

#ifndef __GRPDLG_H__
#define __GRPDLG_H__

#define idtFindDelay    1
#define dtFindDelay     600
#define szDelimiters    TEXT(" ,\t;")

// Forward references
class CNNTPServer;
class CGroupList;
class CSubList;
class CEmptyList;


/////////////////////////////////////////////////////////////////////////////
// Types

// SERVERINFO - One of these structs is kept for each news server currently
//              configured.  We keep all the information about the server,
//              including the agent used to connect, the list of groups which
//              groups are subscribed or new, etc. here.
typedef struct tagSERVERINFO
    {
    LPTSTR           pszAcct;
    CNNTPServer     *pNNTPServer;
    CGroupList      *pGroupList;
    CSubList        *pSubList;
    LPDWORD          rgdwItems;
    LPDWORD          rgdwOrigSub;
    DWORD            cOrigSub;
    DWORD            cItems;
    BOOL             fNewViewed;
    BOOL             fDirty;
    } SERVERINFO, *PSERVERINFO;

// #define SetSubscribed(_b, _f) (_b) = (_f ? ((_b) | GROUP_SUBSCRIBED) : ((_b) & ~GROUP_SUBSCRIBED))
// #define SetNew(_b, _f)        (_b) = (_f ? ((_b) | GROUP_NEW) : ((_b) & ~GROUP_NEW))

// SIZETABLE - This struct is used to make the dialog resizable.  We keep one
//             of these for each control in the dialog.  The rect's are updated
//             in WM_SIZE.  A table of these is built in WM_INITDIALOG.
typedef struct tagSIZETABLE
    {
    HWND hwndCtl;
    UINT id;
    RECT rc;
    } SIZETABLE, *PSIZETABLE;
    
    
// COLUMNS - This struct is used to store the widths of the columns in the 
//           dialog box so the widths can be persisted from session to session.
//           This guy is created in the WM_DESTROY handler and read in
//           CGroupListDlg::InitListView().

#define COLUMNS_VERSION 0x1
#define NUM_COLUMNS     2       // Group name, Description

typedef struct tagCOLUMNS
    {
    DWORD  dwVersion;
    DWORD  rgWidths[NUM_COLUMNS];
    } COLUMNS, *PCOLUMNS;


// CGroupListDlg - This class manages the Newsgroups... Dialog.  It used to have
//                 several subclasses so if it seems wierd to have all these 
//                 functions as virtual that's why.
class CGroupListDlg
    {
    /////////////////////////////////////////////////////////////////////////
    // Initialization
public:
    CGroupListDlg();
    ~CGroupListDlg();
  
#ifdef DEAD
    virtual BOOL FCreate(HWND hwndOwner, CNNTPServer *pNNTPServer, 
                         CSubList *pSubList, LPTSTR* ppszNewGroup, 
                         LPTSTR* ppszNewServer, UINT m_iTabSelect = 0, 
                         BOOL fEnableGoto = TRUE, LPTSTR pszAcctSel = NULL);
#endif // DEAD

protected:
    virtual BOOL FCreate(HWND hwndOwner, UINT idd);

    /////////////////////////////////////////////////////////////////////////
    // Message Handlers
protected:
    static BOOL CALLBACK GroupListDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                          LPARAM lParam);
    virtual BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    virtual void OnTimer(HWND hwnd, UINT id);
    virtual void OnPaint(HWND hwnd);
    virtual void OnClose(HWND hwnd);
    virtual void OnDestroy(HWND hwnd);
    virtual void OnSize(HWND hwnd, UINT state, int cx, int cy);
    virtual void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    virtual void OnChangeServers(HWND hwnd);
    
    virtual BOOL IsGrpDialogMessage(HWND hwnd, LPMSG pMsg);
    
    /////////////////////////////////////////////////////////////////////////
    // Group List manipulation
    void QueryList(LPTSTR pszQuery);
    void ResetList(void);
    void FilterFavorites(void);
    void FilterNew(void);
    
    void SetSubscribed(PSERVERINFO psi, DWORD index, BOOL fSubscribe);
    BOOL IsSubscribed(PSERVERINFO psi, DWORD index);
    BOOL IsNew(PSERVERINFO psi, DWORD index);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    LPTSTR GetFindText(void);
    virtual BOOL ChangeServers(LPTSTR pszAcct, BOOL fUseAgent,
                               BOOL fForce = FALSE);
    BOOL FillServerList(HWND hwndList, LPTSTR pszSelectServer);
    BOOL OnSwitchTabs(HWND hwnd, UINT iTab);
    void UpdateStateInfo(PSERVERINFO psi);
    virtual BOOL InitListView(HWND hwndList);
    void SetLastServer(LPTSTR pszAcct);
    void SetLastGroup(LPTSTR pszGroup);
    PSERVERINFO FInitServer(LPTSTR pszAcct, CNNTPServer* pNNTPServer, 
                            CSubList* pSubList);
    void Sort(LPDWORD rgdw, DWORD c);
    void ShowHideDescriptions(BOOL fShow);
    HRESULT HandleResetButton(void);
    HRESULT SaveCurrentSubscribed(PSERVERINFO psi, LPTSTR** prgszSubscribed, LPUINT pcSub);
    HRESULT RestoreCurrentSubscribed(PSERVERINFO psi, LPTSTR* rgszSub, UINT cSub);
    

    // Whenever we do something that might update the state of a button on
    // the dialog, we call this to allow the subclasses to update their UI.
    virtual void UpdateStateUI(void);

protected:
    /////////////////////////////////////////////////////////////////////////
    // Class Data

    // Array of server information objects.  Each object contains all the 
    // objects and state arrays for the server it needs.
    PSERVERINFO m_rgServerInfo;
    DWORD       m_cServers;
    DWORD       m_cMaxServers;
    PSERVERINFO m_psiCur;
    
    // Handy window handles to have available
    HWND        m_hwnd;
    HWND        m_hwndList;
    HWND        m_hwndFindText;
    HWND        m_hwndOwner;

    // State variables
    BOOL        m_fAllowDesc;       // TRUE if the user can search descriptions
    LPTSTR      m_pszPrevQuery;     // The string that we last searched on
    UINT        m_cchPrevQuery;     // The allocated length of m_pszPrevQuery
    
    // Values used in resizing
    UINT        m_cxHorzSep;
    UINT        m_cyVertSep;
    PSIZETABLE  m_rgst;             // st - SizeTable.  I use this a lot so I wanted it short - SteveSer
    SIZE        m_sizeDlg;
    POINT       m_ptDragMin;

    // Everything else
    HIMAGELIST   m_himlFolders;      // The folder image list.
    HIMAGELIST   m_himlState;
    CNNTPServer *m_pNNTPServer;
    CSubList    *m_pSubList;
    BOOL         m_fServerListInited;
    DWORD        m_dwCurrentAccount;
    LPTSTR       m_pszCurrentAccount;
    LPTSTR       m_pszLastAccount;
    LPTSTR       m_pszLastGroup;    
    BOOL         m_fSaveWindowPos;
    UINT         m_iTabSelect;
    BOOL         m_fEnableGoto;
    LPTSTR       m_pszAcctSel;
    HICON        m_hIcon;

    CEmptyList  *m_pEmptyList;
    };




/////////////////////////////////////////////////////////////////////////////
// Dialog Control ID's
// 

#define idcGroupList                2001            // Group list listview
#define idcFindText                 2002            // Find query edit box
#define idcShowFavorites            2003            // Filter favorites toggle
#define idcUseDesc                  2004            // Use Desc checkbox
#define idcServers                  2005            // Server Listview
#define idcHelp                     2006            // Help button
#define idcResetList                2007            // Rebuild the group list

#define idcUpdateNow                1001
#define idcFullWord                 1004
#define idcPreview                  1006
#define idcProgress                 1007
#define idcApply                    1008
#define idcFind                     1010
#define idcDispText                 1011
#define idcServerText               1012
#define idcPreviewBtn               1013
#define idcSubscribe                1014
#define idcUnsubscribe              1015
#define idcTabs                     1016
#define idcStaticNewsServers        1017
#define idcStaticVertLine           1018
#define idcStaticHorzLine           1019
#define idcGoto                     1020

enum { iTabAll = 0, iTabSubscribed, iTabNew, iTabMax };
enum { iCtlFindText = 0, iCtlUseDesc, iCtlGroupList, iCtlSubscribe, iCtlUnsubscribe,
       iCtlResetList, iCtlGoto, iCtlOK, iCtlCancel, iCtlServers, iCtlStaticNewsServers, iCtlStaticVertLine, 
       iCtlStaticHorzLine, iCtlTabs, iCtlMax };


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\newsstor.cpp ===
/*
 *    n e w s s t o r . c p p 
 *    
 *    Purpose:
 *      Derives from IMessageServer to implement news specific store communication
 *    
 *    Owner:
 *      cevans.
 *
 *    History:
 *      May '98: Created
 *      June '98 Rewrote
 *
 *    Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "newsstor.h"
#include "xpcomm.h"
#include "xputil.h"
#include "conman.h"
#include "IMsgSite.h"
#include "note.h"
#include "storutil.h"
#include "storfldr.h"
#include "oerules.h"
#include "ruleutil.h"
#include <rulesmgr.h>
#include <serverq.h>
#include "newsutil.h"
#include "range.h"

#define AssertSingleThreaded AssertSz(m_dwThreadId == GetCurrentThreadId(), "Multi-threading make me sad.")

#define WM_NNTP_BEGIN_OP (WM_USER + 69)

static const char s_szNewsStoreWndClass[] = "Outlook Express NewsStore";

// Get XX Header consts
const BYTE   MAXOPS = 3;            // maxnumber of HEADER commands to issue
const BYTE   DLOVERKILL = 10;       // percent to grab more than user's desired chunk [10,..)
const BYTE   FRACNEEDED = 8;        // percent needed to satisfy user's amount [1,10]

void AddRequestedRange(FOLDERINFO *pInfo, DWORD dwLow, DWORD dwHigh, BOOL *pfReq, BOOL *pfRead);

// SOT_SYNC_FOLDER
static const PFNOPFUNC c_rgpfnSyncFolder[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Group,
    &CNewsStore::ExpireHeaders,
    &CNewsStore::Headers
};

// SOT_GET_MESSAGE
static const PFNOPFUNC c_rgpfnGetMessage[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::GroupIfNecessary,  // only issue group command if necessary
    &CNewsStore::Article
};

// SOT_PUT_MESSAGE
static const PFNOPFUNC c_rgpfnPutMessage[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Post
};

// SOT_SYNCING_STORE
static const PFNOPFUNC c_rgpfnSyncStore[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::List,
    &CNewsStore::DeleteDeadGroups,
    &CNewsStore::Descriptions
};

// SOT_GET_NEW_GROUPS
static const PFNOPFUNC c_rgpfnGetNewGroups[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::NewGroups
};

// SOT_UPDATE_FOLDER
static const PFNOPFUNC c_rgpfnUpdateFolder[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Group
};

// SOT_GET_WATCH_INFO
static const PFNOPFUNC c_rgpfnGetWatchInfo[] = 
{
    &CNewsStore::Connect,
    &CNewsStore::Group,
    &CNewsStore::XHdrReferences,
    &CNewsStore::XHdrSubject,
    &CNewsStore::WatchedArticles
};


//
//  FUNCTION:   CreateNewsStore()
//
//  PURPOSE:    Creates the CNewsStore object and returns it's IUnknown 
//              pointer.
//
//  PARAMETERS: 
//      [in]  pUnkOuter - Pointer to the IUnknown that this object should
//                        aggregate with.
//      [out] ppUnknown - Returns the pointer to the newly created object.
//
HRESULT CreateNewsStore(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    HRESULT hr;
    IMessageServer *pServer;

    // Trace
    TraceCall("CreateNewsStore");

    // Invalid Args
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNewsStore *pNew = new CNewsStore();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    hr = CreateServerQueue((IMessageServer *)pNew, &pServer);

    pNew->Release();
    if (FAILED(hr))
        return(hr);

    // Cast to unknown
    *ppUnknown = SAFECAST(pServer, IMessageServer *);

    // Done
    return S_OK;
}

//----------------------------------------------------------------------
// CNewsStore
//----------------------------------------------------------------------

//
//
//  FUNCTION:   CNewsStore::CNewsStore()
//
//  PURPOSE:    Constructor
//
CNewsStore::CNewsStore()
{
    m_cRef = 1;
    m_hwnd = NULL;
    m_pStore = NULL;
    m_pFolder = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_idParent = FOLDERID_INVALID;
    m_szGroup[0] = 0;
    m_szAccountId[0] = 0;

    ZeroMemory(&m_op, sizeof(m_op));
    m_pROP = NULL;

    m_pTransport = NULL;
    m_ixpStatus = IXP_DISCONNECTED;
    m_dwLastStatusTicks = 0;

    ZeroMemory(&m_rInetServerInfo, sizeof(INETSERVER));

    m_dwWatchLow = 0;
    m_dwWatchHigh = 0;
    m_rgpszWatchInfo = 0;
    m_fXhdrSubject = 0;
    m_cRange.Clear();

    m_pTable = NULL;

#ifdef DEBUG
    m_dwThreadId = GetCurrentThreadId();
#endif // DEBUG
}

//
//
//  FUNCTION:   CNewsStore::~CNewsStore()
//
//  PURPOSE:    Destructor
//
CNewsStore::~CNewsStore()
{
    AssertSingleThreaded;
    
    if (m_hwnd != NULL)
        DestroyWindow(m_hwnd);

    if (m_pTransport)
    {
        // If we're still connected, drop the connection and then release
        if (_FConnected())
            m_pTransport->DropConnection();

        SideAssert(m_pTransport->Release() == 0);
        m_pTransport = NULL;
    }

    _FreeOperation();
    if (m_pROP != NULL)
        MemFree(m_pROP);

    SafeRelease(m_pStore);
    SafeRelease(m_pFolder);
    SafeRelease(m_pTable);
}

//
//  FUNCTION:   CNewsStore::QueryInterface()
//
STDMETHODIMP CNewsStore::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CNewsStore::QueryInterface");

    AssertSingleThreaded;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IMessageServer *)this;
    else if (IID_IMessageServer == riid)
        *ppv = (IMessageServer *)this;
    else if (IID_ITransportCallback == riid)
        *ppv = (ITransportCallback *)this;
    else if (IID_ITransportCallbackService == riid)
        *ppv = (ITransportCallbackService *)this;
    else if (IID_INNTPCallback == riid)
        *ppv = (INNTPCallback *)this;
    else if (IID_INewsStore == riid)
        *ppv = (INewsStore *)this;
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

//
//  FUNCTION:   CNewsStore::AddRef()
//
STDMETHODIMP_(ULONG) CNewsStore::AddRef(void)
{
    TraceCall("CNewsStore::AddRef");

    AssertSingleThreaded;

    return InterlockedIncrement(&m_cRef);
}

//
//  FUNCTION:   CNewsStore::Release()
//
STDMETHODIMP_(ULONG) CNewsStore::Release(void)
{
    TraceCall("CNewsStore::Release");

    AssertSingleThreaded;

    LONG cRef = InterlockedDecrement(&m_cRef);
    
    Assert(cRef >= 0);

    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

HRESULT CNewsStore::Initialize(IMessageStore *pStore, FOLDERID idStoreRoot, IMessageFolder *pFolder, FOLDERID idFolder)
{
    HRESULT hr;
    FOLDERINFO info;

    AssertSingleThreaded;

    if (pStore == NULL || idStoreRoot == FOLDERID_INVALID)
        return(E_INVALIDARG);

    if (!_CreateWnd())
        return(E_FAIL);

    m_idParent = idStoreRoot;
    m_idFolder = idFolder;
    ReplaceInterface(m_pStore, pStore);
    ReplaceInterface(m_pFolder, pFolder);

    hr = m_pStore->GetFolderInfo(idStoreRoot, &info);
    if (FAILED(hr))
        return(hr);

    Assert(!!(info.dwFlags & FOLDER_SERVER));

    StrCpyN(m_szAccountId, info.pszAccountId, ARRAYSIZE(m_szAccountId));

    m_pStore->FreeRecord(&info);

    return(S_OK);
}

HRESULT CNewsStore::ResetFolder(IMessageFolder *pFolder, FOLDERID idFolder)
{
    AssertSingleThreaded;

    if (pFolder == NULL || idFolder == FOLDERID_INVALID)
        return(E_INVALIDARG);

    m_idFolder = idFolder;
    ReplaceInterface(m_pFolder, pFolder);

    return(S_OK);
}

HRESULT CNewsStore::Initialize(FOLDERID idStoreRoot, LPCSTR pszAccountId)
{
    AssertSingleThreaded;

    if (idStoreRoot == FOLDERID_INVALID || pszAccountId == NULL)
        return(E_INVALIDARG);

    if (!_CreateWnd())
        return(E_FAIL);

    m_idParent = idStoreRoot;
    m_idFolder = FOLDERID_INVALID;
#pragma prefast(suppress:282, "this macro uses the assignment as part of a test for NULL")
    ReplaceInterface(m_pStore, NULL);
#pragma prefast(suppress:282, "this macro uses the assignment as part of a test for NULL")
    ReplaceInterface(m_pFolder, NULL);

    StrCpyN(m_szAccountId, pszAccountId, ARRAYSIZE(m_szAccountId));

    return(S_OK);
}

BOOL CNewsStore::_CreateWnd()
{
    WNDCLASS wc;

    Assert(m_hwnd == NULL);

    if (!GetClassInfo(g_hInst, s_szNewsStoreWndClass, &wc))
    {
        wc.style                = 0;
        wc.lpfnWndProc          = CNewsStore::NewsStoreWndProc;
        wc.cbClsExtra           = 0;
        wc.cbWndExtra           = 0;
        wc.hInstance            = g_hInst;
        wc.hIcon                = NULL;
        wc.hCursor              = NULL;
        wc.hbrBackground        = NULL;
        wc.lpszMenuName         = NULL;
        wc.lpszClassName        = s_szNewsStoreWndClass;
        
        if (RegisterClass(&wc) == 0 && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
            return E_FAIL;
    }

    m_hwnd = CreateWindowEx(WS_EX_TOPMOST,
                        s_szNewsStoreWndClass,
                        s_szNewsStoreWndClass,
                        WS_POPUP,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        g_hInst,
                        (LPVOID)this);

    return (NULL != m_hwnd);
}

// --------------------------------------------------------------------------------
// CHTTPMailServer::_WndProc
// --------------------------------------------------------------------------------
LRESULT CALLBACK CNewsStore::NewsStoreWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CNewsStore *pThis = (CNewsStore *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (msg)
    {
        case WM_NCCREATE:
            Assert(pThis == NULL);
            pThis = (CNewsStore *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
            break;
    
        case WM_NNTP_BEGIN_OP:
            Assert(pThis != NULL);
            pThis->_DoOperation();
            break;
    }

    return(DefWindowProc(hwnd, msg, wParam, lParam));
}

HRESULT CNewsStore::_BeginDeferredOperation(void)
{
    return (PostMessage(m_hwnd, WM_NNTP_BEGIN_OP, 0, 0) ? E_PENDING : E_FAIL);
}

HRESULT CNewsStore::Close(DWORD dwFlags)
{
    AssertSingleThreaded;

    // let go of the transport, so that it let's go of us

    if (m_op.tyOperation != SOT_INVALID)
        m_op.fCancel = TRUE;

    if (dwFlags & MSGSVRF_DROP_CONNECTION || dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (_FConnected())
            m_pTransport->DropConnection();
    }

    if (dwFlags & MSGSVRF_HANDS_OFF_SERVER)
    {
        if (m_pTransport)
        {
            m_pTransport->HandsOffCallback();
            m_pTransport->Release();
            m_pTransport = NULL;
        }
    }

    return(S_OK);
}

void CNewsStore::_FreeOperation()
{
    FILEADDRESS faStream;
    if (m_op.pCallback != NULL)
        m_op.pCallback->Release();
    if (m_pFolder != NULL && m_op.faStream != 0)
        m_pFolder->DeleteStream(m_op.faStream);
    if (m_op.pStream != NULL)
        m_op.pStream->Release();
    if (m_op.pPrevFolders != NULL)
        MemFree(m_op.pPrevFolders);
    if (m_op.pszGroup != NULL)
        MemFree(m_op.pszGroup);
    if (m_op.pszArticleId != NULL)
        MemFree(m_op.pszArticleId);

    ZeroMemory(&m_op, sizeof(OPERATION));
    m_op.tyOperation = SOT_INVALID;
}

HRESULT CNewsStore::Connect()
{
    INETSERVER      rInetServerInfo;
    HRESULT         hr;
    BOOL            fInetInit;
    IImnAccount     *pAccount = NULL;
    char            szAccountName[CCHMAX_ACCOUNT_NAME];
    char            szLogFile[MAX_PATH];
    DWORD           dwLog;

    AssertSingleThreaded;
    Assert(m_op.pCallback != NULL);

    //Bug# 68339
    if (g_pAcctMan)
    {
        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, &pAccount);
        if (FAILED(hr))
            return(hr);

        fInetInit = FALSE;

        if (_FConnected())
        {
            Assert(m_pTransport != NULL);

            hr = m_pTransport->InetServerFromAccount(pAccount, &rInetServerInfo);
            if (FAILED(hr))
                goto exit;

            Assert(m_rInetServerInfo.szServerName[0] != 0);
            if (m_rInetServerInfo.rasconntype == rInetServerInfo.rasconntype &&
                m_rInetServerInfo.dwPort == rInetServerInfo.dwPort &&
                m_rInetServerInfo.fSSL == rInetServerInfo.fSSL &&
                m_rInetServerInfo.fTrySicily == rInetServerInfo.fTrySicily &&
                m_rInetServerInfo.dwTimeout == rInetServerInfo.dwTimeout &&
                0 == lstrcmp(m_rInetServerInfo.szUserName, rInetServerInfo.szUserName) &&
                ('\0' == rInetServerInfo.szPassword[0] ||
                    0 == lstrcmp(m_rInetServerInfo.szPassword, rInetServerInfo.szPassword)) &&
                0 == lstrcmp(m_rInetServerInfo.szServerName, rInetServerInfo.szServerName) &&
                0 == lstrcmp(m_rInetServerInfo.szConnectoid, rInetServerInfo.szConnectoid))
            {
                hr = S_OK;
                goto exit;
            }

            fInetInit = TRUE;

            m_pTransport->DropConnection();
        }

        hr = m_op.pCallback->CanConnect(m_szAccountId, NOFLAGS);
        if (hr != S_OK)
        {
            if (hr == S_FALSE)
                hr = HR_E_USER_CANCEL_CONNECT;
            goto exit;
        }

        if (!m_pTransport)
        {
            *szLogFile = 0;

            dwLog = DwGetOption(OPT_NEWS_XPORT_LOG);
            if (dwLog)
            {
                hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccountName, ARRAYSIZE(szAccountName));
                if (FAILED(hr))
                    goto exit;

                _CreateDataFilePath(m_szAccountId, szAccountName, szLogFile, ARRAYSIZE(szLogFile));
            }

            hr = CreateNNTPTransport(&m_pTransport);
            if (FAILED(hr))
                goto exit;            

            hr = m_pTransport->InitNew(*szLogFile ? szLogFile : NULL, this);
            if (FAILED(hr))
                goto exit;
        }

        // Convert the account name to an INETSERVER struct that can be passed to Connect()
        if (fInetInit)
        {
            CopyMemory(&m_rInetServerInfo, &rInetServerInfo, sizeof(INETSERVER));
        }
        else
        {
            hr = m_pTransport->InetServerFromAccount(pAccount, &m_rInetServerInfo);
            if (FAILED(hr))
                goto exit;
        }

        // Always connect using the most recently supplied password from the user
        GetPassword(m_rInetServerInfo.dwPort, m_rInetServerInfo.szServerName,
            m_rInetServerInfo.szUserName, m_rInetServerInfo.szPassword,
            sizeof(m_rInetServerInfo.szPassword));

        if (m_pTransport)
        {
            hr = m_pTransport->Connect(&m_rInetServerInfo, TRUE, TRUE);
            if (hr == S_OK)
            {
                m_op.nsPending = NS_CONNECT;
                hr = E_PENDING;
            }
        }

exit:
        if (pAccount)
            pAccount->Release();
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CNewsStore::Group()
{
    HRESULT hr;
    FOLDERINFO info;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    hr = m_pStore->GetFolderInfo(m_op.idFolder, &info);
    if (SUCCEEDED(hr))
    {
        hr = m_pTransport->CommandGROUP(info.pszName);
        if (hr == S_OK)
        {
            m_op.pszGroup = PszDup(info.pszName);
            m_op.nsPending = NS_GROUP;
            hr = E_PENDING;
        }

        m_pStore->FreeRecord(&info);
    }

    return hr;
}

HRESULT CNewsStore::GroupIfNecessary()
{
    FOLDERINFO info;
    HRESULT hr = S_OK;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    if (0 == (m_op.dwFlags & OPFLAG_NOGROUPCMD))
    {
        hr = m_pStore->GetFolderInfo(m_op.idFolder, &info);
        if (SUCCEEDED(hr))
        {
            if (0 != lstrcmpi(m_szGroup, info.pszName))
            {
                hr = m_pTransport->CommandGROUP(info.pszName);
                if (hr == S_OK)
                {
                    m_op.nsPending = NS_GROUP;
                    hr = E_PENDING;
                }
            }

            m_pStore->FreeRecord(&info);
        }
    }

    return hr;
}

HRESULT CNewsStore::ExpireHeaders()
{
    HRESULT hr;
    FOLDERINFO info;
    MESSAGEINFO Message;
    DWORD dwLow, cid, cidBuf;
    MESSAGEIDLIST idList;
    HROWSET hRowset;
    HLOCK hNotify;

    hr = m_pStore->GetFolderInfo(m_op.idFolder, &info);
    if (FAILED(hr))
        return(hr);

    dwLow = min(info.dwServerLow - 1, info.dwClientHigh); 

    m_pStore->FreeRecord(&info);

    hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
    if (FAILED(hr))
        return(hr);

    cid = 0;
    cidBuf = 0;
    idList.cAllocated = 0;
    idList.prgidMsg = NULL;

    hr = m_pFolder->LockNotify(NOFLAGS, &hNotify);
    if (SUCCEEDED(hr))
    {
        while (TRUE)
        {
            hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (FAILED(hr))
                break;

            // Done
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }

            if ((DWORD_PTR)Message.idMessage <= dwLow ||
                !!(Message.dwFlags & ARF_ARTICLE_EXPIRED))
            {
                if (cid == cidBuf)
                {
                    cidBuf += 512;
                    if (!MemRealloc((void **)&idList.prgidMsg, cidBuf * sizeof(MESSAGEID)))
                    {
                        m_pFolder->FreeRecord(&Message);
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                }

                idList.prgidMsg[cid] = Message.idMessage;
                cid++;
            }

            m_pFolder->FreeRecord(&Message);
        }

        m_pFolder->UnlockNotify(&hNotify);
    }

    m_pFolder->CloseRowset(&hRowset);

    // if it fails, its no big deal, they'll just have some stale headers until next time
    if (cid > 0)
    {
        Assert(idList.prgidMsg != NULL);

        idList.cMsgs = cid;

        // Delete the messages from the folder without a trashcan (after all, this is news)
        if (SUCCEEDED(m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | DELETE_MESSAGE_NOPROMPT, &idList, NULL, NULL)) &&
            SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &info)))
        {
            info.dwClientLow = dwLow + 1;
            m_pStore->UpdateRecord(&info);

            m_pStore->FreeRecord(&info);
        }

        MemFree(idList.prgidMsg);
    }

    return(hr);
}

HRESULT CNewsStore::Headers(void)
{
    FOLDERINFO FolderInfo;
    HRESULT hr;
    RANGE rRange;
    BOOL fNew;

    hr = m_pStore->GetFolderInfo(m_op.idFolder, &FolderInfo);
    if (FAILED(hr))
        return(hr);

    Assert(0 == lstrcmpi(m_szGroup, FolderInfo.pszName));

    hr = _ComputeHeaderRange(m_op.dwSyncFlags, m_op.cHeaders, &FolderInfo, &rRange);
    
    if (hr == S_OK)
    {
        // Transport will not allow dwFirst to be 0.  
        // In this case, there are no messages to be received.
        Assert(rRange.dwFirst > 0);
        Assert(rRange.dwFirst <= rRange.dwLast);

        hr = m_pTransport->GetHeaders(&rRange);
        if (hr == S_OK)
        {
            m_op.nsPending = NS_HEADERS;
            hr = E_PENDING;
        }
    }

    if (hr != E_PENDING)
    {
        if (m_pROP != NULL)
        {
            MemFree(m_pROP);
            m_pROP = NULL;
        }
    }

    if (hr == S_FALSE)
        hr = S_OK;

    m_pStore->FreeRecord(&FolderInfo);

    return(hr);
}

HRESULT CNewsStore::_ComputeHeaderRange(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders, FOLDERINFO *pInfo, RANGE *pRange)
{
    HRESULT hr;
    UINT uLeftToGet;
    ULONG ulMaxReq;
    BOOL fFullScan;
    DWORD dwDownload;
    CRangeList *pRequested;

    Assert(pInfo != NULL);
    Assert(pRange != NULL);

    // Bail if there are no messages to be gotten
    if (0 == pInfo->dwServerCount ||
        pInfo->dwServerLow > pInfo->dwServerHigh)
        {
        Assert(!m_pROP);
        return(S_FALSE);
        }

    pRequested = new CRangeList;
    if (pRequested == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if (pInfo->Requested.cbSize > 0)
        pRequested->Load(pInfo->Requested.pBlobData, pInfo->Requested.cbSize);

    ulMaxReq = pRequested->Max();

    Assert(0 == pRequested->Min());
    fFullScan = (0 == pRequested->MinOfRange(ulMaxReq));
    
    // Bail if we've scanned the whole group
    if (fFullScan && (pRequested->Max() == pInfo->dwServerHigh))
        goto endit;

    if (m_pROP != NULL)
    {
        // Bail if we've gotten all the user wants
        if (m_pROP->uObtained >= ((FRACNEEDED * m_pROP->dwChunk) / 10))
            goto endit;

        // Bail if this has gone on for too many calls
        if (m_pROP->cOps > m_pROP->MaxOps)
            goto endit;
    }
    else
    {
        m_op.dwProgress = 0;

        // Do setup
        if (!MemAlloc((LPVOID*)&m_pROP, sizeof(SREFRESHOP)))
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        ZeroMemory(m_pROP, sizeof(SREFRESHOP));
        m_pROP->fOnlyNewHeaders = !!(dwFlags & SYNC_FOLDER_NEW_HEADERS);

        if (!!(dwFlags & SYNC_FOLDER_XXX_HEADERS))
        {
            Assert(cHeaders > 0);
            m_pROP->dwChunk = cHeaders;
            m_pROP->dwDlSize = (DWORD)((m_pROP->dwChunk * DLOVERKILL) / 10);
            m_pROP->MaxOps = MAXOPS;
            m_pROP->fEnabled = TRUE;
    
            m_op.dwTotal = m_pROP->dwDlSize;
        }    
        else
        {
            // user has turned off the X headers option
            // so we need to get all of the newest headers, but then also
            // grab any old headers on this refresh
            // we have to do all that here and now because there is no
            // UI available to the user

            // don't want to quit except on a full scan
            // m_pROP->fOnlyNewHeaders = FALSE;
            m_pROP->MaxOps = m_pROP->dwChunk = m_pROP->dwDlSize = pInfo->dwServerHigh;
            Assert(!m_pROP->fEnabled);

            m_op.dwTotal = pInfo->dwNotDownloaded;
        }
    }

    uLeftToGet = m_pROP->dwDlSize - m_pROP->uObtained;
    if (RANGE_ERROR == ulMaxReq)
    {
        AssertSz(0, TEXT("shouldn't be here, but you can ignore."));
        ulMaxReq = pInfo->dwServerLow - 1;
    }
    Assert(ulMaxReq <= pInfo->dwServerHigh);
    Assert(pRequested->IsInRange(pInfo->dwServerLow - 1));

    ///////////////////////////////////
    /// Compute begin and end numbers

    if (ulMaxReq < pInfo->dwServerHigh)
    {
        // get the newest headers
        Assert(0 == m_pROP->cOps);      // EricAn said this assert might not be valid
        Assert(ulMaxReq + 1 >= pInfo->dwServerLow);

        m_pROP->dwLast = pInfo->dwServerHigh;
        if (!m_pROP->fEnabled || (m_pROP->dwChunk - 1 > m_pROP->dwLast))
        {
            m_pROP->dwFirst =  ulMaxReq + 1;
        }
        else
        {
            // we use dwChunk here b/c headers will be nearly dense
            m_pROP->dwFirst = max(m_pROP->dwLast - (m_pROP->dwChunk - 1), ulMaxReq + 1);
        }
        m_pROP->dwFirstNew = ulMaxReq + 1;
    }
    else if (m_pROP->dwFirst > m_pROP->dwFirstNew)  // if init to zero, won't be true
    {
        // still new headers user hasn't seen
        Assert(m_pROP->cOps);                                   // can't happen at first
        Assert(m_pROP->dwFirstNew >= pInfo->dwServerLow);       // better be valid
        Assert(m_pROP->fEnabled);                               // should have gotten them all

        m_pROP->dwLast = m_pROP->dwFirst - 1;         // since cOps is pos, dwFirst is valid
        if (uLeftToGet - 1 > m_pROP->dwLast)
            m_pROP->dwFirst = m_pROP->dwFirstNew;
        else
            m_pROP->dwFirst = max(m_pROP->dwLast - (uLeftToGet - 1), m_pROP->dwFirstNew);
    }
    else if (!m_pROP->fOnlyNewHeaders) 
    {
        RangeType rt;
        // want to find the highest num header we've never requested
        
        m_pROP->dwFirstNew = pInfo->dwServerHigh;  // no new mesgs in this session
        if (!pRequested->HighestAntiRange(&rt))
        {
            AssertSz(0, TEXT("You can ignore if you want, but we shouldn't be here."));
            rt.low = max(pRequested->Max() + 1, pInfo->dwServerLow);
            rt.high = pInfo->dwServerHigh;
            if (rt.low == rt.high)
                goto endit;
        }

        m_pROP->dwLast = rt.high;
        if (!m_pROP->fEnabled || ((uLeftToGet - 1) > rt.high))
            m_pROP->dwFirst = rt.low;
        else
            m_pROP->dwFirst = max(rt.low, rt.high - (uLeftToGet - 1));
    }
    else
    {
        goto endit;
    }

    // check our math and logic about download range
    Assert(m_pROP->dwLast <= pInfo->dwServerHigh);
    Assert(m_pROP->dwFirst >= pInfo->dwServerLow);
    Assert(!pRequested->IsInRange(m_pROP->dwLast));
    Assert(!pRequested->IsInRange(m_pROP->dwFirst));
    Assert(!m_pROP->fEnabled || ((m_pROP->dwLast - m_pROP->dwFirst) < m_pROP->dwDlSize));

    if (!m_pROP->dwLast || (m_pROP->dwFirst > m_pROP->dwLast))
    {
        AssertSz(0, TEXT("You would have made a zero size HEADER call"));
        goto endit;
    }

    pRequested->Release();

    pRange->idType = RT_RANGE;
    pRange->dwFirst = m_pROP->dwFirst;
    pRange->dwLast = m_pROP->dwLast;    

    dwDownload = pRange->dwLast - pRange->dwFirst + 1;
    if (dwDownload + m_op.dwProgress > m_op.dwTotal)
        m_op.dwTotal = dwDownload + m_op.dwProgress;

    return(S_OK);

endit:
    hr = S_FALSE;

error:
    if (m_pROP != NULL)
    {
        MemFree(m_pROP);
        m_pROP = NULL;
    }
    if(pRequested) pRequested->Release();

    return(hr);
}

HRESULT CNewsStore::Article()
{
    HRESULT hr;
    MESSAGEINFO info;
    DWORD dwTotalLines;
    ARTICLEID rArticleId;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    dwTotalLines = 0;

    if (m_op.pszArticleId != NULL)
    {
        rArticleId.idType = AID_MSGID;
        rArticleId.pszMessageId = m_op.pszArticleId;
        m_op.pszArticleId = NULL;
    }
    else if (m_op.idMessage)
    {
        ZeroMemory(&info, sizeof(info));
        info.idMessage = m_op.idMessage;

        hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &info, NULL);
        if (DB_S_FOUND == hr)
        {
            dwTotalLines = info.cLines;
            m_pFolder->FreeRecord(&info);
        }

        rArticleId.idType = AID_ARTICLENUM;
        rArticleId.dwArticleNum = (DWORD_PTR)m_op.idMessage;
    }
    else
    {
        Assert(m_op.idServerMessage);
        rArticleId.idType = AID_ARTICLENUM;
        rArticleId.dwArticleNum = m_op.idServerMessage;
    }

    m_op.dwProgress = 0;
    m_op.dwTotal = dwTotalLines;

    hr = m_pTransport->CommandARTICLE(&rArticleId);
    if (hr == S_OK)
    {
        m_op.nsPending = NS_ARTICLE;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::Post()
{
    HRESULT hr;
    NNTPMESSAGE rMsg;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    rMsg.pstmMsg = m_op.pStream;
    rMsg.cbSize = 0;

    hr = m_pTransport->CommandPOST(&rMsg);
    if (SUCCEEDED(hr))
    {
        m_op.nsPending = NS_POST;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::NewGroups()
{
    HRESULT hr;
    NNTPMESSAGE rMsg;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    hr = m_pTransport->CommandNEWGROUPS(&m_op.st, NULL);
    if (SUCCEEDED(hr))
    {
        m_op.nsPending = NS_NEWGROUPS;
        hr = E_PENDING;
    }

    return(hr);
}

int __cdecl CompareFolderIds(const void *elem1, const void *elem2)
{
    return(*((DWORD *)elem1) - *((DWORD *)elem2));
}

HRESULT CNewsStore::List()
{
    HRESULT hr;
    ULONG cFolders;
    FOLDERINFO info;
    IEnumerateFolders *pEnum;

    Assert(0 == m_op.dwFlags);
    Assert(m_op.pPrevFolders == NULL);

    m_op.cPrevFolders = 0;

    hr = m_pStore->EnumChildren(m_idParent, FALSE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cFolders);
        if (SUCCEEDED(hr) && cFolders > 0)
        {
            if (!MemAlloc((void **)&m_op.pPrevFolders, cFolders * sizeof(FOLDERID)))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                while (S_OK == pEnum->Next(1, &info, NULL))
                {
                    m_op.pPrevFolders[m_op.cPrevFolders] = info.idFolder;
                    m_op.cPrevFolders++;

                    m_pStore->FreeRecord(&info);
                }

                Assert(m_op.cPrevFolders == cFolders);

                qsort(m_op.pPrevFolders, m_op.cPrevFolders, sizeof(FOLDERID), CompareFolderIds);
            }
        }

        pEnum->Release();
    }

    if (SUCCEEDED(hr))
        hr = _List(NULL);

    return(hr);
}

HRESULT CNewsStore::DeleteDeadGroups()
{
    ULONG i;
    HRESULT hr;
    FOLDERID *pId;

    if (m_op.pPrevFolders != NULL)
    {
        Assert(m_op.cPrevFolders > 0);

        for (i = 0, pId = m_op.pPrevFolders; i < m_op.cPrevFolders; i++, pId++)
        {
            if (*pId != 0)
            {
                hr = m_pStore->DeleteFolder(*pId, DELETE_FOLDER_NOTRASHCAN, NULL);
                Assert(SUCCEEDED(hr));
            }
        }

        MemFree(m_op.pPrevFolders);
        m_op.pPrevFolders = NULL;
    }

    return(S_OK);
}

static const char c_szNewsgroups[] = "NEWSGROUPS";

HRESULT CNewsStore::Descriptions()
{
    HRESULT hr;

    m_op.dwFlags = OPFLAG_DESCRIPTIONS;
    hr = _List(c_szNewsgroups);

    return(hr);
}

HRESULT CNewsStore::_List(LPCSTR pszCommand)
{
    HRESULT hr;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    m_op.dwProgress = 0;
    m_op.dwTotal = 0;

    hr = m_pTransport->CommandLIST((LPSTR)pszCommand);
    if (hr == S_OK)
    {
        m_op.nsPending = NS_LIST;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::_DoOperation()
{
    HRESULT             hr;
    STOREOPERATIONINFO  soi;
    STOREOPERATIONINFO  *psoi;

    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pfnState != NULL);
    Assert(m_op.cState > 0);
    Assert(m_op.iState <= m_op.cState);

    hr = S_OK;

    if (m_op.iState == 0)
    {
        if (m_op.tyOperation == SOT_GET_MESSAGE)
        {
            // provide message id on get message start
            soi.cbSize = sizeof(STOREOPERATIONINFO);
            soi.idMessage = m_op.idMessage;
            psoi = &soi;
        }
        else
        {
            psoi = NULL;
        }

        m_op.pCallback->OnBegin(m_op.tyOperation, psoi, (IOperationCancel *)this);
    }

    while (m_op.iState < m_op.cState)
    {
        hr = (this->*(m_op.pfnState[m_op.iState]))();

        if (FAILED(hr))
            break;

        m_op.iState++;
    }

    if ((m_op.iState == m_op.cState) ||
        (FAILED(hr) && hr != E_PENDING))
    {
        if (hr == HR_E_USER_CANCEL_CONNECT)
        {
            // if operation is canceled, add the flush flag
            m_op.error.dwFlags |= SE_FLAG_FLUSHALL;
        }

        if (FAILED(hr))
        {
            IXPRESULT   rIxpResult;

            // Fake an IXPRESULT
            ZeroMemory(&rIxpResult, sizeof(rIxpResult));
            rIxpResult.hrResult = hr;

            // Return meaningful error information
            _FillStoreError(&m_op.error, &rIxpResult);
            Assert(m_op.error.hrResult == hr);
        }
        else
            m_op.error.hrResult = hr;

        m_op.pCallback->OnComplete(m_op.tyOperation, hr, NULL, &m_op.error);
        _FreeOperation();
    }

    return(hr);
}

//
//  FUNCTION:   CNewsStore::SynchronizeFolder()
//
//  PURPOSE:    Load all of the new messages headers for this folder
//              as appropriate based on the flags
//
//  PARAMETERS: 
//      [in]  dwFlags - 
//
HRESULT CNewsStore::SynchronizeFolder(SYNCFOLDERFLAGS dwFlags, DWORD cHeaders,
                                      IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::SynchronizeFolder");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);
    Assert(m_pROP == NULL);

    m_op.tyOperation = SOT_SYNC_FOLDER;
    m_op.pfnState = c_rgpfnSyncFolder;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = m_idFolder;
    m_op.dwSyncFlags = dwFlags;
    m_op.cHeaders = cHeaders;

    hr = _BeginDeferredOperation();

    return hr;   
}

// 
//  FUNCTION:   CNewsStore::GetMessage()
//
//  PURPOSE:    Start the retrieval of a single message as specified 
//              by idMessage.
//
//  PARAMETERS: 
//      [in]  idFolder - 
//      [in]  idMessage - 
//      [in]  pStream - 
//      [in]  pCallback - callbacks in case we need to present ui, progress, 
//
HRESULT CNewsStore::GetMessage(MESSAGEID idMessage, IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetMessage");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    // create a persistent stream
    if (FAILED(hr = CreatePersistentWriteStream(m_pFolder, &m_op.pStream, &m_op.faStream)))
        goto exit;

    m_op.tyOperation = SOT_GET_MESSAGE;
    m_op.pfnState = c_rgpfnGetMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMessage);
    m_op.dwFlags = 0;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = m_idFolder;
    m_op.idMessage = idMessage;

    hr = _BeginDeferredOperation();

exit:
    return hr;
}

HRESULT CNewsStore::GetArticle(LPCSTR pszArticleId, IStream *pStream,
                               IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetArticle");

    AssertSingleThreaded;
    Assert(pStream != NULL);
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.pszArticleId = PszDup(pszArticleId);
    if (m_op.pszArticleId == NULL)
        return(E_OUTOFMEMORY);

    m_op.tyOperation = SOT_GET_MESSAGE;
    m_op.pfnState = c_rgpfnGetMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetMessage);
    m_op.dwFlags = OPFLAG_NOGROUPCMD;
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = m_idFolder;
    m_op.idMessage = 0;
    m_op.pStream = pStream;
    m_op.pStream->AddRef();

    hr = _BeginDeferredOperation();

    return hr;
}

//
//  FUNCTION:   CNewsStore::PutMessage()
//
//  PURPOSE:    Posting news messages
//
//  PARAMETERS: 
//      [in]  idFolder - 
//      [in]  dwFlags - 
//      [in]  pftReceived - 
//      [in]  pStream - 
//      [in]  pCallback - callbacks in case we need to present ui, progress, 
//
HRESULT CNewsStore::PutMessage(FOLDERID idFolder, MESSAGEFLAGS dwFlags,
                            LPFILETIME pftReceived, IStream *pStream,
                            IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetMessage");

    AssertSingleThreaded;
    Assert(pStream != NULL);
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_PUT_MESSAGE;
    m_op.pfnState = c_rgpfnPutMessage;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnPutMessage);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idFolder;
    m_op.dwMsgFlags = dwFlags;
    m_op.pStream = pStream;
    m_op.pStream->AddRef();

    hr = _BeginDeferredOperation();

    return hr;
}

//
//  FUNCTION:   CNewsStore::SynchronizeStore()
//
//  PURPOSE:    Synchronize the list of mail groups
//
//  PARAMETERS: 
//      [in]  idParent - 
//      [in]  dwFlags - 
//      [in]  pCallback - callbacks in case we need to present ui, progress, 
//
HRESULT CNewsStore::SynchronizeStore(FOLDERID idParent, SYNCSTOREFLAGS dwFlags, IStoreCallback *pCallback)
{
    HRESULT hr;

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_SYNCING_STORE;
    m_op.pfnState = c_rgpfnSyncStore;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnSyncStore);

    if (0 == (dwFlags & SYNC_STORE_GET_DESCRIPTIONS))
    {
        // we don't need to do the descriptions command
        m_op.cState -= 1;
    }

    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idParent;

    hr = _BeginDeferredOperation();

    return(hr);
}

HRESULT CNewsStore::GetNewGroups(LPSYSTEMTIME pSysTime, IStoreCallback *pCallback)
{
    HRESULT hr;

    AssertSingleThreaded;
    Assert(pSysTime != NULL);
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_GET_NEW_GROUPS;
    m_op.pfnState = c_rgpfnGetNewGroups;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetNewGroups);

    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.st = *pSysTime;
    m_op.idFolder = m_idParent;

    hr = _BeginDeferredOperation();

    return(hr);
}

//
//  FUNCTION:   CNewsStore::GetFolderCounts()
//
//  PURPOSE:    Update folder statistics for the passed in folder
//
//  PARAMETERS: 
//      [in]  idFolder - folder id associated with the newsgroup
//      [in]  pCallback - callbacks to send OnComplete to.
//
HRESULT CNewsStore::GetFolderCounts(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetFolderCounts");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_UPDATE_FOLDER;
    m_op.pfnState = c_rgpfnUpdateFolder;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnUpdateFolder);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idFolder;

    hr = _BeginDeferredOperation();

    return hr;   
}

HRESULT CNewsStore::SetIdleCallback(IStoreCallback *pDefaultCallback)
{
    // Stack
    TraceCall("CNewsStore::SetIdleCallback");

    return E_NOTIMPL;
}

HRESULT CNewsStore::CopyMessages(IMessageFolder *pDest, COPYMESSAGEFLAGS dwOptions,
                                 LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags,
                                 IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::CopyMessages");

    return E_NOTIMPL;
}

HRESULT CNewsStore::DeleteMessages(DELETEMESSAGEFLAGS dwOptions,
                                   LPMESSAGEIDLIST pList, IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::DeleteMessages");
    
    AssertSingleThreaded;
    Assert(pList != NULL);
    Assert(pCallback != NULL);
    Assert(m_pFolder != NULL);
    
    return(m_pFolder->DeleteMessages(DELETE_MESSAGE_NOTRASHCAN | dwOptions, pList, NULL, NULL));
}

HRESULT CNewsStore::SetMessageFlags(LPMESSAGEIDLIST pList, LPADJUSTFLAGS pFlags, SETMESSAGEFLAGSFLAGS dwFlags,
                                    IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::SetMessageFlags");
    Assert(NULL == pList || pList->cMsgs > 0);
    return E_NOTIMPL;
}

HRESULT CNewsStore::GetServerMessageFlags(MESSAGEFLAGS *pFlags)
{
    return S_FALSE;
}

HRESULT CNewsStore::CreateFolder(FOLDERID idParent, SPECIALFOLDER tySpecial,
                                 LPCSTR pszName, FLDRFLAGS dwFlags,
                                 IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::CreateFolder");
    
    return E_NOTIMPL;
}

HRESULT CNewsStore::MoveFolder(FOLDERID idFolder, FOLDERID idParentNew,
                               IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::MoveFolder");

    return E_NOTIMPL;
}

HRESULT CNewsStore::RenameFolder(FOLDERID idFolder, LPCSTR pszName, IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::RenameFolder");

    return E_NOTIMPL;
}

HRESULT CNewsStore::DeleteFolder(FOLDERID idFolder, DELETEFOLDERFLAGS dwFlags, IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::DeleteFolder");

    return E_NOTIMPL;
}

HRESULT CNewsStore::SubscribeToFolder(FOLDERID idFolder, BOOL fSubscribe,
                                      IStoreCallback *pCallback)
{
    // Stack
    TraceCall("CNewsStore::SubscribeToFolder");

    return E_NOTIMPL;
}

//
//  FUNCTION:   CNewsStore::Cancel()
//
//  PURPOSE:    Cancel the operation
//
//  PARAMETERS: 
//      [in]  tyCancel - The way that the operation was canceled.
//                       Generally CT_ABORT or CT_CANCEL
//
HRESULT CNewsStore::Cancel(CANCELTYPE tyCancel)
{
    if (m_op.tyOperation != SOT_INVALID)
    {
        m_op.fCancel = TRUE;

        if (_FConnected())
            m_pTransport->DropConnection();
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnTimeout()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  pdwTimeout - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    // Stack
    TraceCall("CNewsStore::OnTimeout");

    AssertSingleThreaded;
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);
        
    m_op.pCallback->OnTimeout(&m_rInetServerInfo, pdwTimeout, IXP_NNTP);

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnLogonPrompt()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  pInetServer - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    HRESULT hr;
    char    szPassword[CCHMAX_PASSWORD];

    // Stack
    TraceCall("CNewsStore::OnLogonPrompt");

    AssertSingleThreaded;
    Assert(pInetServer != NULL);
    Assert(pTransport != NULL);
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);

    // Check if we have a cached password that's different from current password
    hr = GetPassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName,
        szPassword, sizeof(szPassword));
    if (SUCCEEDED(hr) && 0 != lstrcmp(szPassword, pInetServer->szPassword))
    {
        StrCpyN(pInetServer->szPassword, szPassword, ARRAYSIZE(pInetServer->szPassword));
        return S_OK;
    }

    hr = m_op.pCallback->OnLogonPrompt(pInetServer, IXP_NNTP);

    // Cache the password for this session
    if (S_OK == hr)
    {
        SavePassword(pInetServer->dwPort, pInetServer->szServerName, pInetServer->szUserName, pInetServer->szPassword);

        // copy the password/user name into our local inetserver
        StrCpyN(m_rInetServerInfo.szPassword, pInetServer->szPassword, ARRAYSIZE(m_rInetServerInfo.szPassword));
        StrCpyN(m_rInetServerInfo.szUserName, pInetServer->szUserName, ARRAYSIZE(m_rInetServerInfo.szUserName));
    }

    return(hr);
}

//
//  FUNCTION:   CNewsStore::OnPrompt()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  hrError - 
//      [in]  pszText - 
//      [in]  pszCaption - 
//      [in]  uType - 
//      [in]  pTransport - 
//
int CNewsStore::OnPrompt(HRESULT hrError, LPCSTR pszText, LPCSTR pszCaption,
                          UINT uType, IInternetTransport *pTransport)
{
    int iResponse = 0;

    // Stack
    TraceCall("CNewsStore::OnPrompt");

    AssertSingleThreaded;
    Assert(m_op.tyOperation != SOT_INVALID);
    Assert(m_op.pCallback != NULL);

    m_op.pCallback->OnPrompt(hrError, pszText, pszCaption, uType, &iResponse);

    return(iResponse);
}

//
//  FUNCTION:   CNewsStore::OnStatus()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  ixpstatus - status code passed in from the transport
//      [in]  pTransport - The NNTP transport that is calling us
//
HRESULT CNewsStore::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::OnStatus");

    AssertSingleThreaded;

    m_ixpStatus = ixpstatus;

    if (m_op.pCallback != NULL)
        m_op.pCallback->OnProgress(SOT_CONNECTION_STATUS, ixpstatus, 0, m_rInetServerInfo.szServerName);

    // If we were disconnected, then clean up some internal state.
    if (IXP_DISCONNECTED == ixpstatus)
    {
        // Reset the group name so we know to reissue it later.
        m_szGroup[0] = 0;

        if (m_op.tyOperation != SOT_INVALID)
        {
            Assert(m_op.pCallback != NULL);
        
            if (m_op.fCancel)
            {
                IXPRESULT   rIxpResult;

                // if operation is canceled, add the flush flag
                m_op.error.dwFlags |= SE_FLAG_FLUSHALL;

                // Fake the IXPRESULT
                ZeroMemory(&rIxpResult, sizeof(rIxpResult));
                rIxpResult.hrResult = STORE_E_OPERATION_CANCELED;

                // Return meaningful error information
                _FillStoreError(&m_op.error, &rIxpResult);
                Assert(STORE_E_OPERATION_CANCELED == m_op.error.hrResult);

                m_op.pCallback->OnComplete(m_op.tyOperation, m_op.error.hrResult, NULL, &m_op.error);

                _FreeOperation();
            }
        }
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnError()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  ixpstatus - 
//      [in]  pResult - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult,
                            IInternetTransport *pTransport)
{
    // Stack
    TraceCall("CNewsStore::OnError");

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::OnCommand()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  cmdtype - 
//      [in]  pszLine - 
//      [in]  hrResponse - 
//      [in]  pTransport - 
//
HRESULT CNewsStore::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse,
                              IInternetTransport *pTransport)
{
    // Stack
    TraceCall("CNewsStore::OnCommand");
    
    return E_NOTIMPL;
}

HRESULT CNewsStore::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    HRESULT hr;

    AssertSingleThreaded;

    Assert(m_op.pCallback != NULL);
    hr = m_op.pCallback->GetParentWindow(dwReserved, phwndParent);

    return hr;
}

HRESULT CNewsStore::GetAccount(LPDWORD pdwServerType, IImnAccount **ppAccount)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Args
    Assert(ppAccount);
    Assert(g_pAcctMan);

    // Initialize
    *ppAccount = NULL;

    // Find the Account
    IF_FAILEXIT(hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, ppAccount));

    // Set server type
    *pdwServerType = SRV_NNTP;

exit:
    // Done
    return(hr);
}

//
//  FUNCTION:   CNewsStore::OnResponse()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      [in]  pResponse - response data from the query
//
HRESULT CNewsStore::OnResponse(LPNNTPRESPONSE pResponse)
{
    HRESULT hr, hrResult;

    AssertSingleThreaded;

    // If we got disconnected etc while there was still socket activity pending
    // this can happen.
    if (m_op.tyOperation == SOT_INVALID)
        return(S_OK);
    Assert(m_op.pCallback != NULL);

    // Here's a little special something.  If the caller is waiting for a connect
    // response, and the connect fails the transport's returns a response with the
    // state set to NS_DISCONNECTED.  If this is the case, we coerce it a bit to
    // make the states happy.
    if (m_op.nsPending == NS_CONNECT && pResponse->state == NS_DISCONNECTED)
        pResponse->state = NS_CONNECT;

    if (pResponse->state == NS_IDLE)
        return(S_OK);

    // Check to see if we're in the right state.  If we're out of sync, good 
    // luck trying to recover without disconnecting.
    Assert(pResponse->state == m_op.nsPending);

    hr = S_OK;
    hrResult = pResponse->rIxpResult.hrResult;

    // If this is a GROUP command, we need to update our internal state to show
    // what group we're now in if we need to switch later.  Also update the 
    // folderinfo with current stats from the server.
    if (pResponse->state == NS_GROUP)
        hr = _HandleGroupResponse(pResponse);

    // We need to handle the article response to copy the lines to the caller's
    // stream.
    else if (pResponse->state == NS_ARTICLE)
        hr = _HandleArticleResponse(pResponse);

    //pump the data into the store
    else if (pResponse->state == NS_LIST)
        hr = _HandleListResponse(pResponse, FALSE);

    //pump the headers into the folder
    else if (pResponse->state == NS_HEADERS)
        hr = _HandleHeadResponse(pResponse);

    //callback to the poster with result
    else if (pResponse->state == NS_POST)
        hr = _HandlePostResponse(pResponse);

    else if (pResponse->state == NS_NEWGROUPS)
        hr = _HandleListResponse(pResponse, TRUE);

    else if (pResponse->state == NS_XHDR)
    {
        if (m_fXhdrSubject)
            hr = _HandleXHdrSubjectResponse(pResponse);
        else
            hr = _HandleXHdrReferencesResponse(pResponse);
    }


    else if (FAILED(pResponse->rIxpResult.hrResult))
    {
        Assert(pResponse->fDone);

        _FillStoreError(&m_op.error, &pResponse->rIxpResult);

        if (pResponse->state == NS_CONNECT)
        {
            // if connection fails, then add the flush-flag
            m_op.error.dwFlags |= SE_FLAG_FLUSHALL;
        }

        m_op.pCallback->OnComplete(m_op.tyOperation, pResponse->rIxpResult.hrResult, NULL, &m_op.error);
    }

    pResponse->pTransport->ReleaseResponse(pResponse);

    if (FAILED(hrResult))
    {
        _FreeOperation();
        return(S_OK);
    }

    if (FAILED(hr))
    {
        m_op.error.hrResult = hr;

        if (_FConnected())
            m_pTransport->DropConnection();
    
        m_op.pCallback->OnComplete(m_op.tyOperation, hr, NULL, NULL);
        _FreeOperation();
        return (S_OK);
    }

    // Check to see if we can issue the next command
    else if (pResponse->fDone)
    {
        m_op.iState++;
        _DoOperation();
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandleHeadResponse
//
//  PURPOSE:    Stuff the headers into the message store
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleHeadResponse(LPNNTPRESPONSE pResp)
{
    DWORD              dwLow, dwHigh;
    BOOL               fFreeReq, fFreeRead;
    HRESULT            hr;
    CRangeList        *pRange;
    LPSTR              lpsz;
    ADDRESSLIST        addrList;
    PROPVARIANT        rDecoded;
    NNTPHEADER        *pHdrOld;
    FOLDERINFO         FolderInfo;
    MESSAGEINFO        rMessageInfo;
    MESSAGEINFO       *pHdrNew = &rMessageInfo;
    IOERule           *pIRuleSender = NULL;
    BOOL               fDontSave = FALSE;
    HLOCK              hNotifyLock = NULL;
    ACT_ITEM *         pActions = NULL;
    ULONG              cActions = 0;
    IOEExecRules *     pIExecRules = NULL;

    Assert(m_pFolder);
    Assert(pResp);
    Assert(m_pROP != NULL);
    
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        if (m_pROP != NULL)
        {
            MemFree(m_pROP);
            m_pROP = NULL;
        }

        return(S_OK);
    }

    if (pResp->rHeaders.cHeaders == 0)
    {
        Assert(pResp->fDone);

        if (SUCCEEDED(m_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
        {   
            AddRequestedRange(&FolderInfo, m_pROP->dwFirst, m_pROP->dwLast, &fFreeReq, &fFreeRead);
            FolderInfo.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&FolderInfo);

            m_pStore->UpdateRecord(&FolderInfo);

            if (fFreeReq)
                MemFree(FolderInfo.Requested.pBlobData);
            if (fFreeRead)
                MemFree(FolderInfo.Read.pBlobData);

            m_pROP->cOps++;
            m_op.iState--;

            m_pStore->FreeRecord(&FolderInfo);
        }

        return(S_OK);
    }

    pRange = NULL;
    if (SUCCEEDED(m_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
    {   
        if (FolderInfo.Read.cbSize > 0)
        {
            pRange = new CRangeList;
            if (pRange != NULL)
                pRange->Load(FolderInfo.Read.pBlobData, FolderInfo.Read.cbSize);
        }

        m_pStore->FreeRecord(&FolderInfo);
    }

    m_pROP->uObtained += pResp->rHeaders.cHeaders;

    // Get the block sender rule if it exists
    Assert(NULL != g_pRulesMan);
    (VOID) g_pRulesMan->GetRule(RULEID_SENDERS, RULE_TYPE_NEWS, 0, &pIRuleSender);

    m_pFolder->LockNotify(NOFLAGS, &hNotifyLock);
    
    // Loop through the headers in pResp and convert each to a MESSAGEINFO
    // and write it to the store
    for (UINT i = 0; i < pResp->rHeaders.cHeaders; i++)
    {
        m_op.dwProgress++;

        pHdrOld = &(pResp->rHeaders.rgHeaders[i]);

        ZeroMemory(&rMessageInfo, sizeof(rMessageInfo));
        fDontSave = FALSE;

        // Article ID
        pHdrNew->idMessage = (MESSAGEID)((DWORD_PTR)pHdrOld->dwArticleNum);

        if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &rMessageInfo, NULL))
        {
            m_pFolder->FreeRecord(&rMessageInfo);
            m_op.dwProgress++;
            continue;
        }

        // Account ID
        pHdrNew->pszAcctId = m_szAccountId;
        pHdrNew->pszAcctName = m_rInetServerInfo.szAccount;
        
        // Subject
        rDecoded.vt = VT_LPSTR;
        if (FAILED(MimeOleDecodeHeader(NULL, pHdrOld->pszSubject, &rDecoded, NULL)))
            pHdrNew->pszSubject = PszDup(pHdrOld->pszSubject);
        else
            pHdrNew->pszSubject = rDecoded.pszVal;

        // Strip trailing whitespace from the subject
        ULONG cb = 0;
        UlStripWhitespace(pHdrNew->pszSubject, FALSE, TRUE, &cb);
        
        // Normalize the subject
        pHdrNew->pszNormalSubj = SzNormalizeSubject(pHdrNew->pszSubject);

        // From
        pHdrNew->pszFromHeader = pHdrOld->pszFrom;
        if (S_OK == MimeOleParseRfc822Address(IAT_FROM, IET_ENCODED, pHdrNew->pszFromHeader, &addrList))
        {
            if (addrList.cAdrs > 0)
            {
                pHdrNew->pszDisplayFrom = addrList.prgAdr[0].pszFriendly;
                addrList.prgAdr[0].pszFriendly = NULL;
                pHdrNew->pszEmailFrom = addrList.prgAdr[0].pszEmail;
                addrList.prgAdr[0].pszEmail = NULL;
            }
            g_pMoleAlloc->FreeAddressList(&addrList);
        }

        // Date
        MimeOleInetDateToFileTime(pHdrOld->pszDate, &pHdrNew->ftSent);

        // Set the Reveived date (this will get set right when we download the message)
        pHdrNew->ftReceived = pHdrNew->ftSent;

        // Message-ID
        pHdrNew->pszMessageId = pHdrOld->pszMessageId;

        // References
        pHdrNew->pszReferences = pHdrOld->pszReferences;

        // Article Size in bytes
        pHdrNew->cbMessage = pHdrOld->dwBytes;

        // Lines
        pHdrNew->cLines = pHdrOld->dwLines;

        // XRef
        if (pHdrOld->pszXref)
            pHdrNew->pszXref = pHdrOld->pszXref;
        else
            pHdrNew->pszXref = NULL;

        // Its a news message
        FLAGSET(pHdrNew->dwFlags, ARF_NEWSMSG);

        if (NULL != pIRuleSender)
        {
            pIRuleSender->Evaluate(pHdrNew->pszAcctId, pHdrNew, m_pFolder, 
                                    NULL, NULL, pHdrOld->dwBytes, &pActions, &cActions);
            if ((1 == cActions) && (ACT_TYPE_DELETE == pActions[0].type))
            {
                fDontSave = TRUE;
            }
        }
        
        //Add it to the database
        hr = S_OK;
        if (FALSE == fDontSave)
        {
            if (pRange != NULL)
            {
                if (pRange->IsInRange(pHdrOld->dwArticleNum))
                    FLAGSET(pHdrNew->dwFlags, ARF_READ);
            }

            hr = m_pFolder->InsertRecord(pHdrNew);
            if (SUCCEEDED(hr))
            {
                if (NULL == pIExecRules)
                {
                    CExecRules *    pExecRules;
                    
                    pExecRules = new CExecRules;
                    if (NULL != pExecRules)
                    {
                        hr = pExecRules->QueryInterface(IID_IOEExecRules, (void **) &pIExecRules);
                        if (FAILED(hr))
                        {
                            delete pExecRules;
                        }
                    }
                }
                
                g_pRulesMan->ExecuteRules(RULE_TYPE_NEWS, NOFLAGS, NULL, pIExecRules, pHdrNew, m_pFolder, NULL);
            }
        }
        
        // Free the memory in rMessageInfo so we can start anew with the next entry
        SafeMemFree(pHdrNew->pszSubject);
        SafeMemFree(pHdrNew->pszDisplayFrom);
        SafeMemFree(pHdrNew->pszEmailFrom);

        // Free up any actions done by rules
        if (NULL != pActions)
        {
            RuleUtil_HrFreeActionsItem(pActions, cActions);
            MemFree(pActions);
            pActions = NULL;
        }
        
        if (FAILED(hr) && hr != DB_E_DUPLICATE)
        {
            SafeRelease(pRange);
            SafeRelease(pIRuleSender);
            SafeRelease(pIExecRules);
            m_pFolder->UnlockNotify(&hNotifyLock);
            return(hr);
        }

        m_op.pCallback->OnProgress(SOT_SYNC_FOLDER, m_op.dwProgress, m_op.dwTotal, m_szGroup);
    }

    m_pFolder->UnlockNotify(&hNotifyLock);
    SafeRelease(pIRuleSender);
    SafeRelease(pIExecRules);
    SafeRelease(pRange);

    Assert(m_op.dwProgress <= m_op.dwTotal);
    if (m_op.pCallback)
    {
        m_op.pCallback->OnProgress(SOT_SYNC_FOLDER, m_op.dwProgress, m_op.dwTotal, m_szGroup);

        // We have to re-fetch the folder info because m_pFolder->InsertRecord may have update this folder....
        if (m_pStore && SUCCEEDED(m_pStore->GetFolderInfo(m_idFolder, &FolderInfo)))
        {   
            dwLow = pResp->rHeaders.rgHeaders[0].dwArticleNum;
            dwHigh = pResp->rHeaders.rgHeaders[pResp->rHeaders.cHeaders - 1].dwArticleNum;

            AddRequestedRange(&FolderInfo, m_pROP->dwFirst, pResp->fDone ? m_pROP->dwLast : dwHigh, &fFreeReq, &fFreeRead);

            if (FolderInfo.dwClientLow == 0 || dwLow < FolderInfo.dwClientLow)
                FolderInfo.dwClientLow = dwLow;
            if (dwHigh > FolderInfo.dwClientHigh)
                FolderInfo.dwClientHigh = dwHigh;

            FolderInfo.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&FolderInfo);

            m_pStore->UpdateRecord(&FolderInfo);

            if (fFreeReq)
                MemFree(FolderInfo.Requested.pBlobData);
            if (fFreeRead)
                MemFree(FolderInfo.Read.pBlobData);

            if (pResp->fDone)
            {
                m_pROP->cOps++;
                m_op.iState--;
            }

            m_pStore->FreeRecord(&FolderInfo);
        }
    }
    return(S_OK);
}

void MarkExistingFolder(FOLDERID idFolder, FOLDERID *pId, ULONG cId)
{
    // TODO: if this linear search is too slow, use a binary search
    // (but we'll have to switch to a struct with folderid and bool)
    ULONG i;

    Assert(pId != NULL);
    Assert(cId > 0);

    for (i = 0; i < cId; i++, pId++)
    {
        if (idFolder == *pId)
        {
            *pId = 0;
            break;
        }
        else if (idFolder < *pId)
        {
            break;
        }
    }
}

//
//  FUNCTION:   CNewsStore::HandleListResponse
//
//  PURPOSE:    Callback function used by the protocol to give us one line
//              at a time in response to a "LIST" command.  Add each line
//              as a folder in the global folder store.
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleListResponse(LPNNTPRESPONSE pResp, BOOL fNew)
{
    LPSTR psz, pszCount;
    int nSize;
    char szGroupName[CCHMAX_FOLDER_NAME], szNumber[15];
    FLDRFLAGS fFolderFlags;
    HRESULT hr;
    BOOL fDescriptions;      
    UINT lFirst, lLast;
    FOLDERINFO Folder;
    STOREOPERATIONTYPE type;
    LPNNTPLIST pnl = &pResp->rList;

    Assert(pResp);

    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        return(S_OK);
    }

    fDescriptions = !!(m_op.dwFlags & OPFLAG_DESCRIPTIONS);

    if ((fNew && pnl->cLines > 0) ||
        (!fNew && pResp->fDone))
    {
        if (SUCCEEDED(m_pStore->GetFolderInfo(m_idParent, &Folder)))
        {
            if (fNew ^ !!(Folder.dwFlags & FOLDER_HASNEWGROUPS))
            {
                Folder.dwFlags ^= FOLDER_HASNEWGROUPS;
                m_pStore->UpdateRecord(&Folder);
            }

            m_pStore->FreeRecord(&Folder);
        }
    }

    for (DWORD i = 0; i < pnl->cLines; i++, m_op.dwProgress++)
    {
        // Parse out just the group name.
        psz = pnl->rgszLines[i];
        Assert(*psz);
        
        if (fDescriptions && *psz == '#')
            continue;

        while (*psz && !IsSpace(psz))
            psz = CharNext(psz);

        nSize = (int)(psz - pnl->rgszLines[i]);
        
        if (nSize >= CCHMAX_FOLDER_NAME)
            nSize = CCHMAX_FOLDER_NAME - 1;

        CopyMemory(szGroupName, pnl->rgszLines[i], nSize);
        szGroupName[nSize] = 0;
        
        // this is the first article in the group
        while (*psz && IsSpace(psz))
            psz = CharNext(psz);

        if (fDescriptions)
        {
            // psz now points to the description which should be 
            // null terminated in the response.
            // Load the folder, if possible, and set the description
            // on it.
            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.pszName = szGroupName;
            Folder.idParent = m_idParent;

            if (DB_S_FOUND == m_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                if (Folder.pszDescription == NULL ||
                    0 != lstrcmp(psz, Folder.pszDescription))
                {
                    Folder.pszDescription = psz;
                    m_pStore->UpdateRecord(&Folder);
                }

                m_pStore->FreeRecord(&Folder);
            }
        }
        else
        {
            pszCount = psz;
            while (*psz && !IsSpace(psz))
                psz = CharNext(psz);
        
            nSize = (int) (psz - pszCount);
            CopyMemory(szNumber, pszCount, nSize);
            szNumber[nSize] = 0;
            lLast = StrToInt(szNumber);

            // this is the last article in the group
            while (*psz && IsSpace(psz))
                psz = CharNext(psz);
        
            pszCount = psz;
            while (*psz && !IsSpace(psz))
                psz = CharNext(psz);

            nSize = (int)(psz - pszCount);
            CopyMemory(szNumber, pszCount, nSize);
            szNumber[nSize] = 0;
            lFirst = StrToInt(szNumber);

            // Now go see if the group allows posting or not.
            while (*psz && IsSpace(psz))
                psz = CharNext(psz);
        
#define FOLDER_LISTMASK (FOLDER_NEW | FOLDER_NOPOSTING | FOLDER_MODERATED | FOLDER_BLOCKED)

            if (fNew)
                fFolderFlags = FOLDER_NEW;
            else
                fFolderFlags = 0;

            if (*psz == 'n')
                fFolderFlags |= FOLDER_NOPOSTING;
            else if (*psz == 'm')
                fFolderFlags |= FOLDER_MODERATED;
            else if (*psz == 'x')
                fFolderFlags |= FOLDER_BLOCKED;

            ZeroMemory(&Folder, sizeof(FOLDERINFO));
            Folder.pszName = szGroupName;
            Folder.idParent = m_idParent;

            if (DB_S_FOUND == m_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                if (m_op.pPrevFolders != NULL)
                    MarkExistingFolder(Folder.idFolder, m_op.pPrevFolders, m_op.cPrevFolders);

                Assert(0 == (fFolderFlags & ~FOLDER_LISTMASK));

                if ((Folder.dwFlags & FOLDER_LISTMASK) != fFolderFlags)
                {
                    Folder.dwFlags = (Folder.dwFlags & ~FOLDER_LISTMASK);
                    Folder.dwFlags |= fFolderFlags;
                    m_pStore->UpdateRecord(&Folder);
                }

                // TODO: should we update server high, low and count here???

                m_pStore->FreeRecord(&Folder);
            }
            else
            {
                // ZeroMemory(&Folder, sizeof(FOLDERINFO));
                // Folder.idParent = m_idParent;
                // Folder.pszName = szGroupName;
                Folder.tySpecial = FOLDER_NOTSPECIAL;
                Folder.dwFlags = fFolderFlags;
                Folder.dwServerLow = lFirst;
                Folder.dwServerHigh = lLast;
                if (Folder.dwServerLow <= Folder.dwServerHigh)
                {
                    Folder.dwServerCount = Folder.dwServerHigh - Folder.dwServerLow + 1;
                    Folder.dwNotDownloaded = Folder.dwServerCount;
                }

                hr = m_pStore->CreateFolder(NOFLAGS, &Folder, NULL);           
                Assert(hr != STORE_S_ALREADYEXISTS);
                if (FAILED(hr))
                    return(hr);
            }
        }
    }

    // only send status every 1/2 second or so.
    if (GetTickCount() > (m_dwLastStatusTicks + 500))
    {
        if (fNew)
            type = SOT_GET_NEW_GROUPS;
        else
            type = fDescriptions ? SOT_SYNCING_DESCRIPTIONS : SOT_SYNCING_STORE;

        m_op.pCallback->OnProgress(type, m_op.dwProgress, 0, m_rInetServerInfo.szServerName);
        m_dwLastStatusTicks = GetTickCount();
    }

    if (!fNew &&
        !fDescriptions &&
        pResp->fDone &&
        SUCCEEDED(pResp->rIxpResult.hrResult))
    {
        IImnAccount *pAcct;
        SYSTEMTIME stNow;
        FILETIME ftNow;

        hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, m_szAccountId, &pAcct);
        if (SUCCEEDED(hr))
        {
            GetSystemTime(&stNow);
            SystemTimeToFileTime(&stNow, &ftNow);
            pAcct->SetProp(AP_LAST_UPDATED, (LPBYTE)&ftNow, sizeof(ftNow));
            pAcct->SaveChanges();

            pAcct->Release();
        }
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandlePostResponse
//
//  PURPOSE:    Callback function used by the protocol to give us one line
//              at a time in response to a "POST" command.  Add each line
//              as a folder in the global folder store.
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandlePostResponse(LPNNTPRESPONSE pResp)
{    
    Assert(pResp != NULL);
    
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        return(S_OK);
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandleGroupResponse
//
//  PURPOSE:    Callback function when a GROUP command completes
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleGroupResponse(LPNNTPRESPONSE pResp)
{
    FOLDERINFO FolderInfo;
    FOLDERID idFolder;
    BOOL fFreeReq, fFreeRead;

    Assert(pResp);

    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);
        Assert(m_op.pszGroup != NULL);

        _FillStoreError(&m_op.error, &pResp->rIxpResult, m_op.pszGroup);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        if (pResp->rIxpResult.uiServerError == IXP_NNTP_NO_SUCH_NEWSGROUP)
        {
            // HACK: this is so the treeview gets the notification that this folder is being deleted
            m_pStore->SubscribeToFolder(m_op.idFolder, TRUE, NULL);
            m_pStore->DeleteFolder(m_op.idFolder, DELETE_FOLDER_NOTRASHCAN, NULL);
        }

        return(S_OK);
    }

    IxpAssert(pResp->rGroup.pszGroup);
    StrCpyN(m_szGroup, pResp->rGroup.pszGroup, ARRAYSIZE(m_szGroup));

    if (SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &FolderInfo)))
    {
        fFreeReq = FALSE;
        fFreeRead = FALSE;

        if (pResp->rGroup.dwFirst <= pResp->rGroup.dwLast)
        {
            FolderInfo.dwServerLow = pResp->rGroup.dwFirst;
            FolderInfo.dwServerHigh = pResp->rGroup.dwLast;
            FolderInfo.dwServerCount = pResp->rGroup.dwCount;

            if (FolderInfo.dwServerLow > 0)
                AddRequestedRange(&FolderInfo, 0, FolderInfo.dwServerLow - 1, &fFreeReq, &fFreeRead);

            FolderInfo.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&FolderInfo);
        }
        else
        {
            FolderInfo.dwServerLow = 0;
            FolderInfo.dwServerHigh = 0;
            FolderInfo.dwServerCount = 0;
            FolderInfo.dwNotDownloaded = 0;
        }

        m_pStore->UpdateRecord(&FolderInfo);

        if (fFreeReq)
            MemFree(FolderInfo.Requested.pBlobData);
        if (fFreeRead)
            MemFree(FolderInfo.Read.pBlobData);

        m_pStore->FreeRecord(&FolderInfo);
    }

    return(S_OK);
}

//
//  FUNCTION:   CNewsStore::HandleArticleResponse
//
//  PURPOSE:    Callback function used by the protocol write a message
//              into the store.
//
//  PARAMETERS:
//      pResp   - Pointer to an NNTPResp from the server.
//
//  RETURN VALUE:
//      ignored
//    
HRESULT CNewsStore::_HandleArticleResponse(LPNNTPRESPONSE pResp)
{
    HRESULT hr;
    ADJUSTFLAGS flags;
    MESSAGEIDLIST list;
    ULONG cbWritten;

    Assert(pResp);

    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);

        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);

        if ((pResp->rIxpResult.uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_NUM ||
            pResp->rIxpResult.uiServerError == IXP_NNTP_NO_SUCH_ARTICLE_FOUND) &&
            m_pFolder != NULL)
        {
            list.cAllocated = 0;
            list.cMsgs = 1;
            list.prgidMsg = &m_op.idMessage;

            flags.dwAdd = ARF_ARTICLE_EXPIRED;
            flags.dwRemove = ARF_DOWNLOAD;

            m_pFolder->SetMessageFlags(&list, &flags, NULL, NULL);
            m_pFolder->SetMessageStream(m_op.idMessage, m_op.pStream);
            m_op.faStream = 0;
        }

        return(S_OK);
    }

    // We need to write the bytes that are returned on to the stream the
    // caller provided

    Assert(m_op.pStream);

    hr = m_op.pStream->Write(pResp->rArticle.pszLines,
                        pResp->rArticle.cbLines, &cbWritten);
    // if (FAILED(hr) || (pResp->rArticle.cbLines != cbWritten))
    if (FAILED(hr))
        return(hr);

    Assert(pResp->rArticle.cbLines == cbWritten);

    // The NNTPRESPONSE struct is going to get sent to the caller anyway,
    // so we need to doctor the cLines member to be the total line count
    // for the message.
    m_op.dwProgress += pResp->rArticle.cLines;

    m_op.pCallback->OnProgress(SOT_GET_MESSAGE, m_op.dwProgress, m_op.dwTotal, NULL);

    // If we're done, then we also rewind the stream
    if (pResp->fDone)
    {
        HrRewindStream(m_op.pStream);
        
        // Articles coming in from news: article urls do not have an IMessageFolder associated with them.
        if (m_pFolder)
        {
            flags.dwAdd = 0;
            flags.dwRemove = ARF_DOWNLOAD;

            if (m_op.idServerMessage)
                _SaveMessageToStore(m_pFolder, m_op.idServerMessage, m_op.pStream);
            else
                CommitMessageToStore(m_pFolder, &flags, m_op.idMessage, m_op.pStream);

            m_op.faStream = 0;
        }

        if (m_op.pStream != NULL)
        {
            m_op.pStream->Release();
            m_op.pStream = NULL;
        }
    }

    SafeMemFree(pResp->rArticle.pszLines);

    return(S_OK);
}

void CNewsStore::_FillStoreError(LPSTOREERROR pErrorInfo, IXPRESULT *pResult, LPSTR pszGroup)
{
    TraceCall("CNewsStore::FillStoreError");
    Assert(m_cRef >= 0); // Can be called during destruction
    Assert(NULL != pErrorInfo);

    if (pszGroup == NULL)
        pszGroup = m_szGroup;

    // Fill out the STOREERROR structure
    ZeroMemory(pErrorInfo, sizeof(*pErrorInfo));
    pErrorInfo->hrResult = pResult->hrResult;
    pErrorInfo->uiServerError = pResult->uiServerError; 
    pErrorInfo->hrServerError = pResult->hrServerError;
    pErrorInfo->dwSocketError = pResult->dwSocketError; 
    pErrorInfo->pszProblem = pResult->pszProblem;
    pErrorInfo->pszDetails = pResult->pszResponse;
    pErrorInfo->pszAccount = m_rInetServerInfo.szAccount;
    pErrorInfo->pszServer = m_rInetServerInfo.szServerName;
    pErrorInfo->pszFolder = pszGroup;
    pErrorInfo->pszUserName = m_rInetServerInfo.szUserName;
    pErrorInfo->pszProtocol = "NNTP";
    pErrorInfo->pszConnectoid = m_rInetServerInfo.szConnectoid;
    pErrorInfo->rasconntype = m_rInetServerInfo.rasconntype;
    pErrorInfo->ixpType = IXP_NNTP;
    pErrorInfo->dwPort = m_rInetServerInfo.dwPort;
    pErrorInfo->fSSL = m_rInetServerInfo.fSSL;
    pErrorInfo->fTrySicily = m_rInetServerInfo.fTrySicily;
    pErrorInfo->dwFlags = 0;
}

//
//  FUNCTION:   CNewsStore::_CreateDataFilePath()
//
//  PURPOSE:    Creates a full path to a data file based on an account and a filename
//
//  PARAMETERS:
//      <in>  pszAccount    - account name
//      <in>  pszFileName   - file name to be appended
//      <out> pszPath       - full path to data file
//
HRESULT CNewsStore::_CreateDataFilePath(LPCTSTR pszAccountId, LPCTSTR pszFileName, LPTSTR pszPath, DWORD cchPathSize)
{
    HRESULT hr = NOERROR;
    TCHAR   szDirectory[MAX_PATH];

    Assert(pszAccountId && *pszAccountId);
    Assert(pszFileName);
    Assert(pszPath);

    // Get the Store Root Directory
    hr = GetStoreRootDirectory(szDirectory, ARRAYSIZE(szDirectory));

    // Validate that I have room
    if (lstrlen(szDirectory) + lstrlen((LPSTR)pszFileName) + 2 >= MAX_PATH)
    {
        Assert(FALSE);
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    if (SUCCEEDED(hr))
        hr = OpenDirectory(szDirectory);

    // Format the filename
    wnsprintf(pszPath, cchPathSize,"%s\\%s.log", szDirectory, pszFileName);

exit:
    return hr;
}

void AddRequestedRange(FOLDERINFO *pInfo, DWORD dwLow, DWORD dwHigh, BOOL *pfReq, BOOL *pfRead)
{
    CRangeList *pRange;

    Assert(pInfo != NULL);
    Assert(dwLow <= dwHigh);
    Assert(pfReq != NULL);
    Assert(pfRead != NULL);

    *pfReq = FALSE;
    *pfRead = FALSE;

    pRange = new CRangeList;
    if (pRange != NULL)
    {
        if (pInfo->Requested.cbSize > 0)
            pRange->Load(pInfo->Requested.pBlobData, pInfo->Requested.cbSize);

        pRange->AddRange(dwLow, dwHigh);

        *pfReq = pRange->Save(&pInfo->Requested.pBlobData, &pInfo->Requested.cbSize);

        pRange->Release();
    }

    if (pInfo->Read.cbSize > 0)
    {
        pRange = new CRangeList;
        if (pRange != NULL)
        {
            pRange->Load(pInfo->Read.pBlobData, pInfo->Read.cbSize);

            pRange->DeleteRange(dwLow, dwHigh);

            *pfRead = pRange->Save(&pInfo->Read.pBlobData, &pInfo->Read.cbSize);

            pRange->Release();
        }
    }
}

HRESULT CNewsStore::MarkCrossposts(LPMESSAGEIDLIST pList, BOOL fRead)
{
    PROPVARIANT var;
    IMimeMessage *pMimeMsg;
    IStream *pStream;
    DWORD i;
    MESSAGEINFO Message;
    HRESULT hr;
    LPSTR psz;
    HROWSET hRowset = NULL;

    if (NULL == pList)
    {
        hr = m_pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &hRowset);
        if (FAILED(hr))
            return(hr);
    }

    for (i = 0; ; i++)
    {
        if (pList != NULL)
        {
            if (i >= pList->cMsgs)
                break;

            Message.idMessage = pList->prgidMsg[i];

            hr = m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
            if (FAILED(hr))
                break;
            else if (hr != DB_S_FOUND)
                continue;
        }
        else
        {
            hr = m_pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL);
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
            else if (FAILED(hr))
            {
                break;
            }
        }

        psz = NULL;

        if (Message.pszXref == NULL &&
            !!(Message.dwFlags & ARF_HASBODY))
        {
            if (SUCCEEDED(MimeOleCreateMessage(NULL, &pMimeMsg)))
            {
                if (SUCCEEDED(m_pFolder->OpenStream(ACCESS_READ, Message.faStream, &pStream)))
                {
                    if (SUCCEEDED(hr = pMimeMsg->Load(pStream)))
                    {
                        var.vt = VT_EMPTY;
                        if (SUCCEEDED(pMimeMsg->GetProp(PIDTOSTR(STR_HDR_XREF), NOFLAGS, &var)))
                        {
                            Message.pszXref = var.pszVal;
                            psz = var.pszVal;
                            m_pFolder->UpdateRecord(&Message);
                        }
                    }

                    pStream->Release();
                }

                pMimeMsg->Release();
            }
        }

        if (Message.pszXref != NULL && *Message.pszXref != 0)
            _MarkCrossposts(Message.pszXref, fRead);

        if (psz != NULL)
            MemFree(psz);

        m_pFolder->FreeRecord(&Message);
    }

    if (hRowset != NULL)
        m_pFolder->CloseRowset(&hRowset);

    return(hr);
}

void CNewsStore::_MarkCrossposts(LPCSTR szXRefs, BOOL fRead)
{
    HRESULT    hr;
    CRangeList *pRange;
    BOOL       fReq, fFree;
    DWORD      dwArtNum;
    IMessageFolder *pFolder;
    MESSAGEINFO Message;
    FOLDERINFO info;
    LPSTR      szT = StringDup(szXRefs);
    LPSTR      psz = szT, pszNum;

    if (!szT)
        return;

    // skip over the server field
    // $BUGBUG - we should really verify that our server generated the XRef
    while (*psz && *psz != ' ')
        psz++;

    while (1)
        {
        // skip whitespace
        while (*psz && (*psz == ' ' || *psz == '\t'))
            psz++;
        if (!*psz)
            break;

        // find the article num
        pszNum = psz;
        while (*pszNum && *pszNum != ':')
            pszNum++;
        if (!*pszNum)
            break;
        *pszNum++ = 0;
        
        // Bug #47253 - Don't pass NULL pointers to SHLWAPI.
        if (!*pszNum)
            break;
        dwArtNum = StrToInt(pszNum);

        if (lstrcmpi(psz, m_szGroup) != 0)
        {
            ZeroMemory(&info, sizeof(FOLDERINFO));
            info.idParent = m_idParent;
            info.pszName = psz;

            if (DB_S_FOUND == m_pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &info, NULL))
            {
                if (!!(info.dwFlags & FOLDER_SUBSCRIBED))
                {
                    fReq = FALSE;

                    if (info.Requested.cbSize > 0)
                    {
                        pRange = new CRangeList;
                        if (pRange != NULL)
                        {
                            pRange->Load(info.Requested.pBlobData, info.Requested.cbSize);
                            fReq = pRange->IsInRange(dwArtNum);
                            pRange->Release();
                        }
                    }

                    if (fReq)
                    {
                        hr = m_pStore->OpenFolder(info.idFolder, NULL, NOFLAGS, &pFolder);
                        if (SUCCEEDED(hr))
                        {
                            ZeroMemory(&Message, sizeof(MESSAGEINFO));
                            Message.idMessage = (MESSAGEID)((DWORD_PTR)dwArtNum);

                            hr = pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &Message, NULL);
                            if (DB_S_FOUND == hr)
                            {
                                if (fRead ^ !!(Message.dwFlags & ARF_READ))
                                {
                                    Message.dwFlags ^= ARF_READ;

                                    if (fRead && !!(Message.dwFlags & ARF_DOWNLOAD))
                                        Message.dwFlags ^= ARF_DOWNLOAD;

                                    pFolder->UpdateRecord(&Message);
                                }

                                pFolder->FreeRecord(&Message);
                            }

                            pFolder->Release();
                        }
                    }
                    else
                    {
                        pRange = new CRangeList;
                        if (pRange != NULL)
                        {
                            if (info.Read.cbSize > 0)
                                pRange->Load(info.Read.pBlobData, info.Read.cbSize);
                            if (fRead)
                                pRange->AddRange(dwArtNum);
                            else
                                pRange->DeleteRange(dwArtNum);
                            fFree = pRange->Save(&info.Read.pBlobData, &info.Read.cbSize);
                            pRange->Release();

                            m_pStore->UpdateRecord(&info);

                            if (fFree)
                                MemFree(info.Read.pBlobData);
                        }
                    }
                }

                m_pStore->FreeRecord(&info);
            }
        }

        // skip over digits
        while (IsDigit(pszNum))
            pszNum++;
        psz = pszNum;        
        }

    MemFree(szT);
}


HRESULT CNewsStore::GetWatchedInfo(FOLDERID idFolder, IStoreCallback *pCallback)
{
    HRESULT hr;

    // Stack
    TraceCall("CNewsStore::GetWatchedInfo");

    AssertSingleThreaded;
    Assert(pCallback != NULL);
    Assert(m_op.tyOperation == SOT_INVALID);

    m_op.tyOperation = SOT_GET_WATCH_INFO;
    m_op.pfnState = c_rgpfnGetWatchInfo;
    m_op.iState = 0;
    m_op.cState = ARRAYSIZE(c_rgpfnGetWatchInfo);
    m_op.pCallback = pCallback;
    m_op.pCallback->AddRef();

    m_op.idFolder = idFolder;

    hr = _BeginDeferredOperation();

    return hr;  
}


HRESULT CNewsStore::XHdrReferences(void)
{
    HRESULT     hr = S_OK;
    FOLDERINFO  fi;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    if (SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &fi)))
    {
        if (fi.dwClientWatchedHigh < fi.dwServerHigh)
        {
            m_dwWatchLow = max(fi.dwClientHigh + 1, fi.dwClientWatchedHigh + 1);
            m_dwWatchHigh = fi.dwServerHigh;

            // Save our new high value
            fi.dwClientWatchedHigh = fi.dwServerHigh;
            m_pStore->UpdateRecord(&fi);

            // Check to see if we have any work to do
            if (m_dwWatchLow <= m_dwWatchHigh)
            {
                // Allocate an array for the retreived data
                if (!MemAlloc((LPVOID *) &m_rgpszWatchInfo, sizeof(LPTSTR) * (m_dwWatchHigh - m_dwWatchLow + 1)))
                {
                    m_pStore->FreeRecord(&fi);
                    return (E_OUTOFMEMORY);
                }
                ZeroMemory(m_rgpszWatchInfo, sizeof(LPTSTR) * (m_dwWatchHigh - m_dwWatchLow + 1));

                m_cRange.Clear();
                m_cTotal = 0;
                m_cCurrent = 0;
            
                m_op.dwProgress = 0;
                m_op.dwTotal = m_dwWatchHigh - m_dwWatchLow;

                m_fXhdrSubject = FALSE;

                RANGE range;
                range.idType = RT_RANGE;
                range.dwFirst = m_dwWatchLow;
                range.dwLast = m_dwWatchHigh;

                hr = m_pTransport->CommandXHDR("References", &range, NULL);
                if (hr == S_OK)
                {
                    m_op.nsPending = NS_XHDR;
                    hr = E_PENDING;
                }
            }
        }

        m_pStore->FreeRecord(&fi);
    }

    return(hr);
}


HRESULT CNewsStore::_HandleXHdrReferencesResponse(LPNNTPRESPONSE pResp)
{
    NNTPXHDR *pHdr;

    // Check for error
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);
        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);
        return(S_OK);
    }

    // Loop through the returned data and insert those values into our array
    for (DWORD i = 0; i < pResp->rXhdr.cHeaders; i++)
    {
        pHdr = &(pResp->rXhdr.rgHeaders[i]);
        Assert(pHdr->dwArticleNum <= m_dwWatchHigh);

        // Some servers return "(none)" for articles that don't have that 
        // header.  Smart servers just don't return anything.
        if (0 != lstrcmpi(pHdr->pszHeader, "(none)"))
        {            
            m_rgpszWatchInfo[pHdr->dwArticleNum - m_dwWatchLow] = PszDupA(pHdr->pszHeader);
        }
    }

    // Show a little progress here.  This is actually a little complicated.  The
    // data returned might have a single line for each header, or might be sparse.
    // we need to show progress proportional to how far we are through the headers.
    m_op.dwProgress = (pResp->rXhdr.rgHeaders[pResp->rXhdr.cHeaders - 1].dwArticleNum - m_dwWatchLow);
    m_op.pCallback->OnProgress(SOT_GET_WATCH_INFO, m_op.dwProgress, m_op.dwTotal, 
                               m_rInetServerInfo.szServerName);

    return (S_OK);
}


HRESULT CNewsStore::XHdrSubject(void)
{
    HRESULT     hr = S_OK;
    FOLDERINFO  fi;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    // Check to see if we have any work to do
    if ((m_dwWatchLow > m_dwWatchHigh) || (m_dwWatchLow == 0 && m_dwWatchHigh == 0))
        return (S_OK);

    m_op.dwProgress = 0;
    m_op.dwTotal = m_dwWatchHigh - m_dwWatchLow;

    RANGE range;
    range.idType = RT_RANGE;
    range.dwFirst = m_dwWatchLow;
    range.dwLast = m_dwWatchHigh;

    m_fXhdrSubject = TRUE;

    hr = m_pTransport->CommandXHDR("Subject", &range, NULL);
    if (hr == S_OK)
    {
        m_op.nsPending = NS_XHDR;
        hr = E_PENDING;
    }

    return(hr);
}

HRESULT CNewsStore::_HandleXHdrSubjectResponse(LPNNTPRESPONSE pResp)
{
    NNTPXHDR *pHdr;

    // Check for error
    if (FAILED(pResp->rIxpResult.hrResult))
    {
        Assert(pResp->fDone);

        _FillStoreError(&m_op.error, &pResp->rIxpResult);
        m_op.pCallback->OnComplete(m_op.tyOperation, pResp->rIxpResult.hrResult, NULL, &m_op.error);
        return(S_OK);
    }

    // Loop through the returned data see which ones are watched
    for (DWORD i = 0; i < pResp->rXhdr.cHeaders; i++)
    {
        pHdr = &(pResp->rXhdr.rgHeaders[i]);
        Assert(pHdr->dwArticleNum <= m_dwWatchHigh);

        // Check to see if this is part of a watched thread
        if (_IsWatchedThread(m_rgpszWatchInfo[pHdr->dwArticleNum - m_dwWatchLow], pHdr->pszHeader))
        {
            m_cRange.AddRange(pHdr->dwArticleNum);
            m_cTotal++;
        }
    }

    // Show a little progress here.
    m_op.dwProgress += pResp->rXhdr.cHeaders;
    m_op.pCallback->OnProgress(SOT_GET_WATCH_INFO, m_op.dwProgress, m_op.dwTotal, 
                               m_rInetServerInfo.szServerName);

    // If this is the end of the xhdr data, we can free our array of references
    if (pResp->fDone)
    {
        for (UINT i = 0; i < (m_dwWatchHigh - m_dwWatchLow + 1); i++)
        {
            if (m_rgpszWatchInfo[i])
                MemFree(m_rgpszWatchInfo[i]);
        }

        MemFree(m_rgpszWatchInfo);
        m_rgpszWatchInfo = 0;

        m_dwWatchLow = 0;
        m_dwWatchHigh = 0;
    }

    return (S_OK);
}


BOOL CNewsStore::_IsWatchedThread(LPSTR pszRef, LPSTR pszSubject)
{
    // Get the Parent
    Assert(m_pFolder);
    return(S_OK == m_pFolder->IsWatched(pszRef, pszSubject) ? TRUE : FALSE);
}


HRESULT CNewsStore::WatchedArticles(void)
{
    HRESULT     hr = S_OK;
    ARTICLEID   rArticleId;

    AssertSingleThreaded;
    Assert(m_pTransport != NULL);

    // Check to see if we have any work to do
    if (m_cRange.Cardinality() == 0)
        return (S_OK);

    m_op.pCallback->OnProgress(SOT_GET_WATCH_INFO, ++m_cCurrent, m_cTotal, NULL);

    m_op.idServerMessage = m_cRange.Min();
    m_op.idMessage = 0;

    m_cRange.DeleteRange(m_cRange.Min());

    // Create a stream
    if (FAILED(hr = CreatePersistentWriteStream(m_pFolder, &m_op.pStream, &m_op.faStream)))
        return (E_OUTOFMEMORY);

    hr = Article();

    if (hr == E_PENDING)
        m_op.iState--;

    return (hr);
}


HRESULT CNewsStore::_SaveMessageToStore(IMessageFolder *pFolder, DWORD id, LPSTREAM pstm)
{
    FOLDERINFO info;
    BOOL fFreeReq, fFreeRead;
    IMimeMessage *pMsg = 0;
    HRESULT       hr;
    MESSAGEID     idMessage = (MESSAGEID)((DWORD_PTR)id);

    // Create a new message
    if (SUCCEEDED(hr = MimeOleCreateMessage(NULL, &pMsg)))
    {
        if (SUCCEEDED(hr = pMsg->Load(pstm)))
        {
            if (SUCCEEDED(m_pStore->GetFolderInfo(m_op.idFolder, &info)))
            {
                fFreeReq = FALSE;
                fFreeRead = FALSE;

                AddRequestedRange(&info, id, id, &fFreeReq, &fFreeRead);
                info.dwNotDownloaded = NewsUtil_GetNotDownloadCount(&info);

                m_pStore->UpdateRecord(&info);

                if (fFreeReq)
                    MemFree(info.Requested.pBlobData);
                if (fFreeRead)
                    MemFree(info.Read.pBlobData);
            }

            hr = m_pFolder->SaveMessage(&idMessage, 0, 0, m_op.pStream, pMsg, NOSTORECALLBACK);
        }

        pMsg->Release();
    }

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mailnews\news\order.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Order.h
//
//  PURPOSE:    Header file for the order articles dialog
//


#define IDC_MESSAGE_LIST                1001
#define IDC_MOVE_UP                     1002
#define IDC_MOVE_DOWN                   1003

#define IDC_DOWNLOAD_AVI                2001
#define IDC_GENERAL_TEXT                2002
#define IDC_SPECIFIC_TEXT               2003
#define IDC_DOWNLOAD_PROG               2004



/////////////////////////////////////////////////////////////////////////////
// Class CCombineAndDecode
//

class CCombineAndDecode : public IStoreCallback, public ITimeoutCallback
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CCombineAndDecode();
    ~CCombineAndDecode();

    HRESULT Start(HWND hwndParent, IMessageTable *pTable, ROWINDEX *rgRows, 
                  DWORD cRows, FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    
    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback interface
    //
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback
    //
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

    /////////////////////////////////////////////////////////////////////////
    // Order dialog message handling stuff
    //
public:
    static INT_PTR CALLBACK OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    INT_PTR CALLBACK _OrderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    _Order_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void    _Order_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void    _Order_OnClose(HWND hwnd);
    LRESULT _Order_OnDragList(HWND hwnd, int idCtl, LPDRAGLISTINFO lpdli);

    /*
    void _Order_OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    void _Order_OnSize(HWND hwnd, UINT state, int cx, int cy);
    void _Order_OnPaint(HWND hwnd);
    */

    /////////////////////////////////////////////////////////////////////////
    // Order dialog message handling stuff
    //
public:
    static INT_PTR CALLBACK CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    INT_PTR CALLBACK _CombineDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL    _Combine_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void    _Combine_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void    _Combine_OnDestroy(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void _Combine_GetNextArticle(HWND hwnd);
    void _Combine_OnMsgAvail(HWND hwnd);
    void _Combine_OpenNote(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Member Data
    //
private:
    ULONG               m_cRef;

    // Groovy Window Handles
    HWND                m_hwndParent;

    // Interface pointers and all that
    IMessageTable      *m_pTable;
    ROWINDEX           *m_rgRows;
    DWORD               m_cRows;
    FOLDERID            m_idFolder;

    // Order dialog state variables
    LPTSTR              m_pszBuffer;
    LPARAM              m_lpData;
    UINT                m_iItemToMove;

    // Combine dialog state variables
    DWORD               m_cLinesTotal;
    DWORD               m_cCurrentLine;
    DWORD               m_cPrevLine;
    DWORD               m_dwCurrentArt;
    IMimeMessageParts  *m_pMsgParts;
    IOperationCancel   *m_pCancel;
    STOREOPERATIONTYPE  m_type;
    HTIMEOUT            m_hTimeout;
    HWND                m_hwndDlg;
};


#if 0
typedef struct tagORDERPARAMS
    {
    // This stuff get's passed in
    PINETMSGHDR    *rgpMsgs;
    DWORD           cMsgs;
    HWND            hwndOwner;
    CNNTPServer    *pNNTPServer;
    CGroup         *pGroup;      
    TCHAR           szGroup[256];
    
    // This stuff is private data for the dialog
    DWORD           cLinesTotal;
    DWORD           cCurrentLine;
    DWORD           cPrevLine;
    DWORD           dwCurrentArt;
    LPMIMEMESSAGEPARTS  pMsgParts;
    } ORDERPARAMS, *PORDERPARAMS;


BOOL CALLBACK OrderMsgsDlg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK CombineAndDecodeProg(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                   LPARAM lParam);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\m