system32\\appmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\appwiz.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\aqadmin.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\aqueue.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\arp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\arp1394.sys", NULL},
    {NULL, L"%systemroot%\\system32\\asctrls.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\asferror.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\asp.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_filter.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_isapi.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_rc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_regiis.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_state.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_wp.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\aspnetoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\aspperf.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\asr_fmt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\asr_ldm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\asr_pfu.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\asyncmac.sys", NULL},
    {NULL, L"%systemroot%\\system32\\at.exe", NULL},
    {L"bhp001.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\atalk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atapi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ati.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ati2drad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ati2dvaa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ati2dvag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati2mpad.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati2mtaa.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati2mtag.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ati3d1ag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ati3d2ag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\AtiBt829.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atidrab.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atidrae.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atidvag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atidvai.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Atievxx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimpab.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimpae.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimtag.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimtai.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinbtxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinmdxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinpdxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinraxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinrvxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinsnxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinttxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atintuxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinxbxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinxsxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atipcxxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atiraged.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atiragem.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atirtcap.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atirtsnd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atitunep.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ATITVSnd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ativdaxx.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ativmdcd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ativmvxx.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ativttxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ativxbar.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atixbar.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atkctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atlmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atmadm.exe", NULL},
    {L"bhp024.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\ATMARP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmarpc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmarps.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmepvc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atmfd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmlane.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atmpvcno.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmuni.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atrace.dll", NULL},
    {NULL, L"%systemroot%\\system32\\attrib.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv01nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv02nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv04nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv06nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv10nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\audiosrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\audstub.sys", NULL},
    {NULL, L"%systemroot%\\system32\\authz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\autochk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\autoconv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\autodisc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\autofmt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\autolfn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\avc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\AvcAUDIO.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\avcstrm.sys", NULL},
    {NULL, L"%systemroot%\\system\\AVICAP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\AVICAP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\avicap32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\avifil32.dll", NULL},
    {NULL, L"%systemroot%\\system\\AVIFILE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\AVIFILE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\avmcoxp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\avmenum.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\avmwan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\azroles.dll", NULL},
    {NULL, L"%systemroot%\\system32\\azroleui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\b1cbase.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\b57xp32.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\b5820w2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\banshee.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\banshee.sys", NULL},
    {NULL, L"%systemroot%\\system32\\basesrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\batmeter.dll", NULL},
    {NULL, L"%systemroot%\\system32\\batt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\battc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BCM4E5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BCMDM.sys", NULL},
    {NULL, L"%systemroot%\\system32\\bcmmodex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bdaplgin.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\bdasup.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\beep.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Bfax.sys", NULL},
    {NULL, L"%systemroot%\\system32\\bfaxdev.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bfaxfsp.dll", NULL},
    {NULL, L"%ProgramFiles%\\Brooktrout Technology\\Brooktrout FSP\\Snapin\\bfaxsnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bfaxtsp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\bhsupp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bidispl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\big5.nls", NULL},
    {NULL, L"%systemroot%\\system32\\binlsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\bitsoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bitsprx2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\blackbox.dll", NULL},
    {NULL, L"%systemroot%\\help\\bnts.dll", NULL},
    {L"bhp002.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\BONE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\bootcfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\bootvid.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bopomofo.nls", NULL},
    {NULL, L"%systemroot%\\system32\\bosprep.exe", NULL},
    {NULL, L"%systemroot%\\system32\\BrBidiIf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\brcoinst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\breecemc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\BrEvIF.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrFilt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrFiltLo.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrFiltUp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\bridge.sys", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfBidi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfcWia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfLpt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfRsmg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfUSB.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\browscap.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\browselc.dll", NULL},
    {L"bhp003.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\browser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\browser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\browseui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\browsewm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrParImg.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrParwdm.sys", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\brpinfo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrScnRsm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrSerIf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrSerWdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrUsbMdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrUsbScn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\btdlld.dll", NULL},
    {NULL, L"%systemroot%\\system32\\btpagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\bulltlp3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\c_037.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10000.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10001.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10002.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10003.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10004.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10005.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10006.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10007.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10008.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10010.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10017.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10021.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10029.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10079.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10081.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10082.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1026.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1047.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1140.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1141.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1142.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1143.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1144.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1145.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1146.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1147.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1148.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1149.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1250.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1251.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1252.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1253.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1254.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1255.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1256.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1257.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1258.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1361.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20000.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20001.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20002.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20003.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20004.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20005.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20105.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20106.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20107.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20108.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20127.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20261.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20269.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20273.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20277.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20278.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20280.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20284.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20285.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20290.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20297.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20420.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20423.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20424.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20833.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20838.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20866.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20871.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20880.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20905.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20924.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20932.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20936.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20949.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_21025.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_21027.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_21866.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28591.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28592.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28593.nls", NULL},
    {NULL, L"%systemroot%\\system32\\C_28594.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\C_28595.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\C_28596.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\C_28597.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\c_28598.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28599.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28603.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28605.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_437.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_500.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_708.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_720.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_737.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_775.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_850.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_852.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_855.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_857.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_858.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_860.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_861.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_862.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_863.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_864.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_865.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_866.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_869.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_870.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_874.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_875.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_932.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_936.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_949.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_950.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_g18030.dll", NULL},
    {L"cg18030.dll", L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\c_g18030.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\c_is2022.dll", NULL},
    {NULL, L"%systemroot%\\system32\\c_iscii.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cabinet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cabview.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cacls.exe", NULL},
    {NULL, L"%systemroot%\\system32\\calc.exe", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\callcont.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CamDrO21.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\camdrv21.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\camdrv30.sys", NULL},
    {NULL, L"%systemroot%\\system\\CamExO20.ax", NULL},
    {NULL, L"%systemroot%\\system\\CamExO20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\camext20.ax", NULL},
    {NULL, L"%systemroot%\\system\\camext20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Camext30.ax", NULL},
    {NULL, L"%systemroot%\\system32\\Camext30.dll", NULL},
    {NULL, L"%systemroot%\\system32\\camocx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\capesnpn.dll", NULL},
    {L"diapi2.sys", L"%systemroot%\\system32\\drivers\\disdn\\capi20.sys", NULL},
    {L"diapi2NT.dll", L"%systemroot%\\system32\\capi20NT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cards.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\CasPol.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\catsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\catsrvps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\catsrvut.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cb102.sys", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\cb32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CB325.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cben5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cbidf2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cbmdmkxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CCDECODE.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ccfapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ccfgnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cd20xrnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cdfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cdfview.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cdosys.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cdrom.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CE3N5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cem28n5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cem33n5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cem56n5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\certadm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certcli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certdb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certenc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\certobj.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\certocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certpdef.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certreq.exe", NULL},
    {NULL, L"%systemroot%\\system32\\certsrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\certtmpl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certutil.exe", NULL},
    {NULL, L"%systemroot%\\system32\\certxds.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cewmdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cfgbkend.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Ch7xxNT5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\chajei.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\change.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\changer.sys", NULL},
    {NULL, L"%systemroot%\\system32\\charmap.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chglogon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chgport.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chgusr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chkdsk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chkntfs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\choice.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chsbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\chtbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTMBX.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTSKDIC.DIC", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTSKDIC.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTSKF.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\ciadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cic.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cidaemon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\cimwin32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cinemclc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTIME.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGB.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGD.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGIE.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGL.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\CINTLGNT.IME", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGS.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGSI.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGU.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGUC.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTSETP.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\ciodm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cipher.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cirrus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cirrus.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cisvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ckcnv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cl5465.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cl546x.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cl546xm.sys", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClAdmWiz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\classpnp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\clb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clbcatex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clbcatq.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClCfgSrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cleanmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cleanri.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clip.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clipbrd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clipsrv.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClNetRes.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClNetREx.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\CluAdmEx.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\CluAdmin.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\CluAdMMC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clusapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\clusdisk.sys", NULL},
    {L"IIS_clusftp.vbs", L"%systemroot%\\system32\\inetsrv\\clusftp.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\ClusNet.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\clusocm.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClusRes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ClusSprt.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClusSvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cluster.exe", NULL},
    {L"IIS_clusweb.vbs", L"%systemroot%\\system32\\inetsrv\\clusweb.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\ClusWMI.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cmbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cmbp0wdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cmcfg32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmd.exe", NULL},
    {L"evtgprov.dll", L"%systemroot%\\system32\\wbem\\CmdEvTgProv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmdial32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cmdide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cmdkey.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmdl32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmmon32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmpbk32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmprops.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmstp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cnbjmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cnetcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cnvfat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cnxt1803.sys", NULL},
    {NULL, L"%systemroot%\\system32\\colbact.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comaddin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\comadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comcat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comclust.exe", NULL},
    {NULL, L"%systemroot%\\system\\COMMDLG.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\COMMDLG.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\comp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\compact.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\compbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\compobj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\compstui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comrepl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\comrepl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\comrereg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\comres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\comsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comsvcs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comuid.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\conf.exe", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ConfigWizards.exe", L"netfxocm.inf"},
    {NULL, L"%ProgramFiles%\\NetMeeting\\confmrsl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\confmsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\conime.exe", NULL},
    {NULL, L"%systemroot%\\system32\\console.dll", NULL},
    {NULL, L"%systemroot%\\system32\\control.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ContRot.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\convert.exe", NULL},
    {NULL, L"%systemroot%\\system32\\convlog.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\convmsg.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\CORPerfMonExt.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\corpol.dll", NULL},
    {NULL, L"%systemroot%\\system32\\country.sys", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\cplexe.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqarray.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqarry2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqcissm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqdap01.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqfcalm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqtrnd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cprofile.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\crcdisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\credui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\crtaud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\crtdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\crusoe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\csamsp.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\csc.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\cscdll.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\cscomp.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\cscompmgd.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\1033\\cscompui.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\cscript.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cscui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\csrsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\csrss.exe", NULL},
    {NULL, L"%systemroot%\\system32\\csseqchk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\csvde.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ctfmon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ctl3dv2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ctljystk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ctmasetp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ctype.nls", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\CustomMarshalers.dll", L"netfxocm.inf"},
    {L"cv60450.exe", L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\cvtres.exe", L"netfxocm.inf"},
    {L"cwcosnt5.sys", L"%systemroot%\\system32\\drivers\\cwcos.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cwcspud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cwcwdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cwrwdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyclad-z.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyclom-y.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cyycoins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyyport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cyyports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cyzcoins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyzport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cyzports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3d8.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3d8thk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dim.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dim700.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dpmesh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dramp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3drm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dxof.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dac2w2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dac960nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\danim.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dataclen.dll", NULL},
    {NULL, L"%systemroot%\\system32\\datime.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\davcdata.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\davclnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\daxctle.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\dayi.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\dbgeng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dbghelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dc21x4.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dc240usd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dc260usd.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\dcap32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dcgpofix.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dciman32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dcomcnfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dcphelp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dcpromo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dcpromo.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ddeml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ddeshare.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ddraw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ddrawex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ddrop.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\ddsmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\debug.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\DebugEx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\defpa.sys", NULL},
    {NULL, L"%systemroot%\\system32\\defrag.exe", NULL},
    {NULL, L"%systemroot%\\system32\\desk.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\deskadp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\deskmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\deskperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\devenum.dll", NULL},
    {NULL, L"%systemroot%\\system32\\devmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dfe650.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dfe650d.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgfat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgifc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgifps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgntfs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dfscmd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfscore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfsgui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfsinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfssetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfsshlex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfssvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dgapci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dgconfig.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dgnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dgrpsetu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dgsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpcsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpssvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpwiz.exe", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Triedit\\DHTMLED.OCX", NULL},
    {NULL, L"%systemroot%\\system32\\diactfrm.dll", NULL},
    {NULL, L"%systemroot%\\dialer.exe", NULL},
    {NULL, L"%systemroot%\\system32\\diantz.exe", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\diasymreader.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\digest.dll", NULL},
    {NULL, L"%systemroot%\\system32\\DigiAsyn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digiasyn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\DigiDBP.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digidxb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digifep5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\DigiFwrk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\DigiHLC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\digiinf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\DigiIsdn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digiisdn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\digirlpt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digirlpt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\DigiView.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\disdn\\dimaint.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dimap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dinput.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dinput8.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\directdb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\disk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\diskcopy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\diskdump.sys", NULL},
    {NULL, L"%systemroot%\\system32\\diskpart.exe", NULL},
    {NULL, L"%systemroot%\\system32\\diskperf.exe", NULL},
    {NULL, L"%systemroot%\\system32\\disrvci.dll", NULL},
    {NULL, L"%systemroot%\\system32\\disrvpp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\disrvsu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ditrace.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\disdn\\diwansrv.sys", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\dlimport.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dllhost.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dllhst3g.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dlttape.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\DM9PCI5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\dmadmin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dmboot.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmconfig.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmdlgs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmdskmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmdskres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmintf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dmio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmivcitf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dmload.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmocx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmremote.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dmserver.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\DMusic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmvdsitf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmview.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\dns.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dnsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnsmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnsperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\dnsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnsrslvr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnswiz.exe", NULL},
    {NULL, L"%systemroot%\\system32\\docprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\docprop2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\domadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\doskey.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dosx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4Prt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4Scan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4usb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\DP83820.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dpcdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dplaysvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dplayx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpmodemx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnaddr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnhpast.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnhupnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnlobby.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnsvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dpti2o.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dpvacm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpvoice.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpvsetup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dpvvox.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpwsockx.dll", NULL},
    {L"drvqry.exe", L"%systemroot%\\system32\\driverquery.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\drmk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\drmkaud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drmv2clt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drwatson.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drwtsn32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ds16gt.dLL", NULL},
    {NULL, L"%systemroot%\\system32\\dsadd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsauth.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsdmo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsdmoprp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsget.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dshowext.ax", NULL},
    {NULL, L"%systemroot%\\system32\\dskquota.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dskquoui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsmod.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsmove.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsound.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsound3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\dsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsquery.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsquery.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsrestor.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsrevt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsrm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dssec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsuiext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsuiwiz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dumprep.exe", NULL},
    {NULL, L"%systemroot%\\system32\\duser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dvdplay.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dvdupgrd.exe", NULL},
    {L"dwil1033.dll", L"%systemroot%\\system32\\1033\\dwintl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dwwin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dx7vb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dx8vb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dxapi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dxdiag.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dxg.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dxgthk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dxmrtp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dxtmsft.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dxtrans.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\e1000325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\e100b325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\edb500.dll", NULL},
    {NULL, L"%systemroot%\\system32\\edlin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\efsadu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\EL556ND5.sys", L"net3c556.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\el575ND5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656CD5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656CT5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656ND5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656SE5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el90xbc5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el90xnd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el985n51.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el98xn5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\EL99XN51.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\elmsmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\els.dll", NULL},
    {L"em556n4.sys", L"%systemroot%\\system32\\drivers\\em556n4a.sys", NULL},
    {L"em556n4.sys", L"%systemroot%\\system32\\drivers\\em556n4b.sys", NULL},
    {L"em556n4.sys", L"%systemroot%\\system32\\drivers\\em556n4i.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\emu10K1b.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\enum1394.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\epcfw2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\epstw2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\eqn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\EqnClass.Dll", NULL},
    {NULL, L"%systemroot%\\system32\\eqndiag.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eqnlogr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eqnloop.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ersvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\es.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\es198x.sys", NULL},
    {NULL, L"%systemroot%\\system32\\esent.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esent97.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esentprf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esentutl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\esscli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\essm2e.sys", NULL},
    {NULL, L"%systemroot%\\system32\\esucm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esuimg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esuni.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esunib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\eudcedit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eventcls.dll", NULL},
    {L"evcreate.exe", L"%systemroot%\\system32\\eventcreate.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eventlog.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\EventLogMessages.dll", L"netfxocm.inf"},
    {L"evtquery.vbs", L"%systemroot%\\system32\\eventquery.vbs", NULL},
    {L"evtrig.exe", L"%systemroot%\\system32\\eventtriggers.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eventvwr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\evntagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\evntcmd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\evntrprv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\evntwin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\exabyte2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\examc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\exe2bin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\expand.exe", NULL},
    {NULL, L"%systemroot%\\explorer.exe", NULL},
    {NULL, L"%systemroot%\\system32\\exstrace.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\extrac32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\f3ahvoas.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fa410nd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fastopen.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\fastprox.dll", NULL},
    {NULL, L"%systemroot%\\system32\\faultrep.dll", NULL},
    {NULL, L"%ProgramFiles%\\Brooktrout Technology\\Brooktrout FSP\\Bfax\\faxinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\fc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\fcachdll.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\fdc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fde.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fdeploy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\feclient.dll", NULL},
    {L"fem556n5.sys", L"%systemroot%\\system32\\drivers\\fem556na.sys", NULL},
    {L"fem556n5.sys", L"%systemroot%\\system32\\drivers\\fem556nb.sys", NULL},
    {L"fem556n5.sys", L"%systemroot%\\system32\\drivers\\fem556ni.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fetnd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\filemgmt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\find.exe", NULL},
    {NULL, L"%systemroot%\\system32\\findstr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\finger.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fips.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fixmapi.exe", NULL},
    {NULL, L"%systemroot%\\system32\\flattemp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\flpydisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fmifs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fontext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fontsub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fontview.exe", NULL},
    {NULL, L"%systemroot%\\system32\\forcedos.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\FOREHE.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\forfiles.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\fp50ext.dll", NULL},
    {L"bhp004.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\FRAME.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\framebuf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\framedyn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\freedisk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fs_rec.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\fsconins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fsutil.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fsvga.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ftdisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ftlx041e.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\ftp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ftpctrs2.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ftpmib.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ftpsvc2.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\ftsrch.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\fusion.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\fwdprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fxsadmin.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsapi.dll", L"fxsocm.inf"},
    {L"NT4_fxsapi.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\NT4\\fxsapi.dll", L"fxsocm.inf"},
    {L"W9X_fxsapi.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxsapi.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscfgwz.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsclnt.exe", L"fxsocm.inf"},
    {L"W9X_fxsclnt.exe", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxsclnt.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsclntr.dll", L"fxsocm.inf"},
    {L"W9X_fxsclntr.dll", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxsclntr.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscom.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscomex.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscover.exe", L"fxsocm.inf"},
    {L"W9X_fxscover.exe", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxscover.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsdrv.dll", L"fxsocm.inf"},
    {L"W9X_fxsdrv32.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxsdrv32.dll", L"fxsocm.inf"},
    {L"NT4_fxsdrv4.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\NT4\\fxsdrv4.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsevent.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsext32.dll", L"fxsocm.inf"},
    {L"W9X_fxsext32.dll", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxsext32.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsmon.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\fxsocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fxsperf.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsres.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsroute.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsrtmtd.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxssend.exe", L"fxsocm.inf"},
    {L"W9X_fxssend.exe", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxssend.exe", L"fxsocm.inf"},
    {L"FXS_setup.exe", L"%systemroot%\\system32\\clients\\faxclient\\fxssetup.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsst.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxssvc.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxst30.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxst30p.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxstiff.dll", L"fxsocm.inf"},
    {L"W9X_fxstiff.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxstiff.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsui.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxswzrd.dll", L"fxsocm.inf"},
    {L"W9X_fxswzrd.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxswzrd.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsxp32.dll", L"fxsocm.inf"},
    {L"W9X_fxsxp32.dll", L"%systemroot%\\system32\\clients\\faxclient\\System\\fxsxp32.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\G200d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\G200m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\g400dhd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\g400dhm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\g550dhd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\g550dhm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\g711codc.ax", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\gacutil.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\gameenum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\gcdef.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gdi.exe", NULL},
    {NULL, L"%systemroot%\\system32\\gdi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\geo.nls", NULL},
    {NULL, L"%systemroot%\\system32\\getmac.exe", NULL},
    {NULL, L"%systemroot%\\system32\\gettype.exe", NULL},
    {NULL, L"%systemroot%\\system32\\getuname.dll", NULL},
    {NULL, L"%systemroot%\\system32\\glmf32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\glu32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\gm.dls", NULL},
    {NULL, L"%systemroot%\\system32\\gpedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gpkcsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gpkrsrc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\gpr400.sys", NULL},
    {L"gprslt.exe", L"%systemroot%\\system32\\gpresult.exe", NULL},
    {NULL, L"%systemroot%\\system32\\gptext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gpupdate.exe", NULL},
    {NULL, L"%systemroot%\\system32\\grovel.exe", NULL},
    {NULL, L"%systemroot%\\system32\\grovmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\grpconv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\grserial.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\gzip.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\h323.tsp", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\h323cc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\h323msp.dll", NULL},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Dicts\\hanja.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Dicts\\hanjadic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HCAppRes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hccoin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\HCF_MSFT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hdwwiz.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\help.exe", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HelpCtr.exe", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HelpHost.exe", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HelpSvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\hexedit.dll", NULL},
    {NULL, L"%systemroot%\\hh.exe", NULL},
    {NULL, L"%systemroot%\\system32\\hhctrl.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\mui\\0009\\hhctrlui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hhsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hid.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidgame.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidir.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidparse.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hidphone.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\hidserv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidusb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\himem.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hlink.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\HMMAPI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\hnetcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hnetmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hostmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hostname.exe", NULL},
    {NULL, L"%systemroot%\\system32\\hotplug.dll", NULL},
    {NULL, L"%systemroot%\\system32\\HpDigWia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hpmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hpn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hpojwia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hpt4qic.sys", NULL},
    {NULL, L"%ProgramFiles%\\Windows NT\\htrn_jis.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\http.sys", NULL},
    {NULL, L"%systemroot%\\system32\\httpapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\httpext.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\httpmib.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\httpodbc.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\htui.dll", NULL},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\HWXCHT.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\hwxjpn.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Applets\\hwxkor.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\i2omgmt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i2omp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\i740dnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i740nt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i8042prt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\i81xdnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i81xnt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ias.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasacct.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasads.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iashlpr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iaspolcy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasrad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasrecst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iassam.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iassdo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iassvcs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\IBMSGNET.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\IBMTOK.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\IBMTRP.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ibmvcap.sys", NULL},
    {NULL, L"%systemroot%\\system32\\icaapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Icam3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Icam3EXT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icam4com.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Icam4EXT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Icam4USB.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Icam5com.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Icam5EXT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Icam5USB.sys", NULL},
    {NULL, L"%systemroot%\\system32\\icfgnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icm32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icmp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icmui.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwconn.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwconn1.exe", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwconn2.exe", NULL},
    {NULL, L"%systemroot%\\system32\\icwdial.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwdl.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwhelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icwphbk.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwres.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwrmind.exe", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwtutor.exe", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\idq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\idwlog.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ie4uinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ieakeng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ieaksie.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ieakui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iedkcs32.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IEExec.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IEExecRemote.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IEHost.dll", L"netfxocm.inf"},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\MSInfo\\IEINFO5.OCX", NULL},
    {NULL, L"%systemroot%\\system32\\iepeers.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iernonce.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iesetup.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\IEXPLORE.EXE", NULL},
    {NULL, L"%systemroot%\\system32\\iexpress.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ifmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ifsutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\igmpagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\igmpv2.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IIEHost.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\iis.dll", NULL},
    {L"IIS_iis_switch.vbs", L"%systemroot%\\system32\\inetsrv\\iis_switch.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisadmin.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisapp.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisback.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iiscfg.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisclex4.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\IIsCnfg.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisext.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\IIsFtp.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\IIsFtpdr.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iislog.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iismui.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisres.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iissuba.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisuiobj.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisutil.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisvdir.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisw3adm.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisweb.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iiswmi.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ilasm.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\ils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imadmui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imagehlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imapi.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\imapi.sys", NULL},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Dicts\\imekr.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imekr61.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\imekrcic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Applets\\imekrmbx.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\imekrmig.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\imepadsm.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\imepadsv.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imgutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imjp81.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imjp81k.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpcd.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpch.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpcic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpcus.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdadm.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdct.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdct.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdsvr.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpgn.grm", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpinst.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpln.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpmig.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpnm.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjprw.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpsb.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpst.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjptk.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpuex.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjputy.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjputyc.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpzp.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\imkrinst.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\imlang.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imm32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\IMSCINST.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\imsinsnt.dll", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\imskdic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\imskf.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\inetcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetcomm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetcpl.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\inetcplc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\inetinfo.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetmib1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetpp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetppui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetres.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\inetwiz.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\infocomm.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\infoctrs.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\infosoft.dll", NULL},
    {NULL, L"%systemroot%\\system32\\initpki.dll", NULL},
    {NULL, L"%systemroot%\\system32\\input.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inseng.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\InstallUtil.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\InstallUtilLib.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\tsclient\\win32\\instmsia.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clients\\tsclient\\win32\\instmsiw.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\intelide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\intl.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\inuse.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\io8.sys", NULL},
    {NULL, L"%systemroot%\\system32\\IO8Ports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iologmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ip5515.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ipbootp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipconf.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\ipconfig.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ipfltdrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\iphlpapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipmontr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ipnat.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ipnathlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ippromon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprip.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprip2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprtprio.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprtrmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsec6.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ipsecsnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsecsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsink.ax", NULL},
    {NULL, L"%systemroot%\\system32\\ipsmsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ipsraidn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ipv6mon.dll", NULL},
    {L"bhp005.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\IPX.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\ipxroute.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ipxsap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\irbus.sys", NULL},
    {NULL, L"%systemroot%\\system32\\irclass.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\irda.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\irenum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\irftp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\irmk7.sys", NULL},
    {NULL, L"%systemroot%\\system32\\irmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\irprops.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\irsir.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\irstusb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\isapips.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\isapnp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iscomlog.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\isign32.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\isignup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ismip.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ismserv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ismsink.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ismsmtp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\isrdbg32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\isrpc.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ISymWrapper.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\iuctl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iuengine.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ixsso.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iyuv_32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jet500.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jetconv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\jetpack.exe", NULL},
    {NULL, L"%systemroot%\\system32\\jgaw400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgdw400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgmd400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgpl400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgsd400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgsh400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jobexec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\joy.cpl", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\jsc.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\jvcmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101a.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101b.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101c.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd103.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd106.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd106n.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbda1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbda1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbda2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbda2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbda3.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbda3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdal.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdarme.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdarmw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdax2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdaze.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdazel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbene.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdblr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdca.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcan.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\kbdclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcz1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcz2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdda.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbddiv1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbddiv1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbddiv2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbddiv2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbddv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdest.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfa.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdfa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgae.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgeo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgkl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgr1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhe220.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhe319.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdheb.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdheb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhela2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhela3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhept.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\kbdhid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhu1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdibm02.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdic.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdindev.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdindev.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinguj.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinguj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinhin.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinhin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinkan.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinkan.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinmar.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinmar.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinpun.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinpun.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdintam.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdintam.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdintel.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdintel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdit142.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdjpn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdkaz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdkor.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdkyr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdla.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlk41a.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlk41j.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlt1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlv1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdmac.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdne.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnec95.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnecat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnecnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdno.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdpl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdpl1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdpo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdro.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdru.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdru1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsl1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsyr1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdsyr1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsyr2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdsyr2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdtat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth0.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth0.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth3.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdtuf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdtuq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbduk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdur.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdurdu.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdurdu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbduzb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdvntc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdycc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdycl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kd1394.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kdcom.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kdcsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kerberos.dll", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\PARSERS\\kerbprsr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\key01.sys", NULL},
    {NULL, L"%systemroot%\\system\\KEYBOARD.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\KEYBOARD.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\keyboard.sys", NULL},
    {NULL, L"%systemroot%\\system32\\keymgr.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\keymgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kmddsp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\kmixer.sys", NULL},
    {NULL, L"%systemroot%\\system32\\korwbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\korwbrkr.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\krnl386.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\krnlprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ks.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ksc.nls", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ksecdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ksproxy.ax", NULL},
    {NULL, L"%systemroot%\\system32\\kstvtune.ax", NULL},
    {NULL, L"%systemroot%\\system32\\ksuser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kswdmcap.ax", NULL},
    {NULL, L"%systemroot%\\system32\\ksxbar.ax", NULL},
    {NULL, L"%systemroot%\\system32\\l_except.nls", NULL},
    {NULL, L"%systemroot%\\system32\\l_intl.nls", NULL},
    {NULL, L"%systemroot%\\system32\\label.exe", NULL},
    {L"bhp023.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LANE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\langwrbk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lcwiz.exe", NULL},
    {L"bhp025.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LDAP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\ldifde.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\libxprmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\liccpa.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\licdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\licenoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\licmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\licmgr10.dll", NULL},
    {NULL, L"%systemroot%\\system32\\licwmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\linkinfo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\LIT220P.SYS", NULL},
    {L"bhp006.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LLC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\llsmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\llsrpc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\llssrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lmhsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lmmib2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\lmndis3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\lmrt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lnkstub.exe", NULL},
    {NULL, L"%systemroot%\\system32\\loadperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\locale.nls", NULL},
    {NULL, L"%systemroot%\\system32\\localsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\localspl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\localui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\locator.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lodctr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\loghours.dll", NULL},
    {NULL, L"%systemroot%\\system32\\logman.exe", NULL},
    {NULL, L"%systemroot%\\system32\\logoff.exe", NULL},
    {L"bhp019.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LOGON.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\logon.scr", NULL},
    {NULL, L"%systemroot%\\system32\\logonui.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\logscrpt.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\lonsint.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\loop.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\lp6nds35.sys", NULL},
    {NULL, L"%systemroot%\\system32\\lpdsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lpk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lpq.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lpr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lprhelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lprmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lprmonui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lrwizdll.dll", NULL},
    {L"bhp020.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LSARPC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\lsass.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lserver.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltck000c.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltmdmnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltmdmntl.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltmdmntt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltotape.sys", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\Lexicon\\1033\\ltts1033.lxa", NULL},
    {L"luna.mst", L"%systemroot%\\Resources\\Themes\\Luna\\luna.msstyles", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\LwAdiHid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\LwUsbHid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\lz32.dll", NULL},
    {NULL, L"%systemroot%\\system\\LZEXPAND.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\LZEXPAND.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\m4mc.sys", NULL},
    {L"bhp007.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\MAC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\macfile.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mag_hook.dll", NULL},
    {NULL, L"%systemroot%\\system32\\magnify.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\mailmsg.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\main.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\makecab.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mammoth.sys", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\PARSERS\\mcast.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mcastmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mcd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mcd32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mcdsrv32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mchgrcoi.dll", NULL},
    {NULL, L"%systemroot%\\system\\MCIAVI.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MCIAVI.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\mciavi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mcicda.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciole16.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciole32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciqtz32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciseq.dll", NULL},
    {NULL, L"%systemroot%\\system\\MCISEQ.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MCISEQ.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\mciwave.dll", NULL},
    {NULL, L"%systemroot%\\system\\MCIWAVE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MCIWAVE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mdgndis5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mdhcp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mdminst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mdwmdmsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mem.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\memcard.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\MemStPCI.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\metadata.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\mf.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mf3216.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mfc42.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mfc42u.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mgaud.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mgaum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mgmtapi.dll", NULL},
    {L"AzRLPia.dll", L"%systemroot%\\Microsoft.NET\\AuthMan\\Microsoft.Interop.Security.AzRoles.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.JScript.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.JScript.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.VisualBasic.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.VisualBasic.Vsa.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.VisualC.Dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.Vb.CodeDOMProcessor.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.Vb.CodeDOMProcessor.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft_VsaVb.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\midimap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\migisol.exe", NULL},
    {NULL, L"%systemroot%\\system32\\miglibnt.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\MigPol.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\MigPolWin.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\Com\\migregdb.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mimefilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mindex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\miniqic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mlang.dat", NULL},
    {NULL, L"%systemroot%\\system32\\mlang.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mll_hp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mll_mtf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mll_qic.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mmcbase.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmcndmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmcshext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmfutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmsys.cpl", NULL},
    {NULL, L"%systemroot%\\system\\MMSYSTEM.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\MMSYSTEM.DLL", NULL},
    {NULL, L"%systemroot%\\system\\MMTASK.TSK", NULL},
    {NULL, L"%systemroot%\\system32\\MMTASK.TSK", NULL},
    {NULL, L"%systemroot%\\system32\\mmutilse.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mnmdd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mnmdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mnmsrvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mobsync.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mobsync.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\modem.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\MODEMCSA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\modemui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\modex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\mofcomp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\mofd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\moricons.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mouclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mouhid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mountmgr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mountvol.exe", NULL},
    {NULL, L"%systemroot%\\system\\MOUSE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MOUSE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mpe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mpg2splt.ax", NULL},
    {NULL, L"%systemroot%\\system32\\mpg4dmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mplay32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mpnotify.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mpr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprddm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprdim.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mqac.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mqad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqads.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqbkup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqcertui.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\MQClus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdbodbc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdscli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdssrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdssvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqgentr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqise.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqlogmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqmig.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqmigrat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqoa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqoa10.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mqoa20.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mqperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqqm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqrt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqrtdep.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqtgsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqtrig.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqupgrd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mraid35x.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mrinfo.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mrxdav.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mrxsmb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msaatext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msacm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msacm32.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msado25.tlb", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msado26.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\msafd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msapsspc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msasn1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msaudite.dll", NULL},
    {NULL, L"%systemroot%\\ime\\mscandui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mscat32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mscdexnt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msclus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mscms.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msconf.dll", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\msconfig.exe", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorcfg.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscordbc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscordbi.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscoree.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mui\\0409\\mscoreer.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorie.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mscorier.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mscories.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorjit.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorld.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorlib.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorlib.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.0.3705\\mscormmc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorpe.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorrc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorsec.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\MUI\\0409\\mscorsecr.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorsn.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorsvr.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscortim.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorwks.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mscpx32r.dLL", NULL},
    {NULL, L"%systemroot%\\system32\\MSCTF.dll", NULL},
    {NULL, L"%systemroot%\\system32\\MSCTFIME.IME", NULL},
    {NULL, L"%systemroot%\\system32\\MSCTFP.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaorar.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdart.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdatl3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdmo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msdtclog.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtcprx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\msdtcstp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtctm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtcuiu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msdv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msdvbnp.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msftedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msgame.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msgina.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msgpc.sys", NULL},
    {NULL, L"%systemroot%\\srchasst\\msgr3en.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msgsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mshta.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mshtml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mshtml.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mshtmled.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mshtmler.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msident.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msidle.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msidntld.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msieftp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msiexec.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msihnd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msimg32.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\msimn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msimsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\MSIMTF.dll", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\msinfo.dll", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\MSInfo\\msinfo32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\msiprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msir3jp.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\msir3jp.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\MSIRCOMM.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msiregmv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msisam11.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msisip.dll", NULL},
    {L"msjetol1.dll", L"%systemroot%\\system32\\msjetoledb40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mskssrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mslbui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msls31.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\mslwvtts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msmpu401.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\msmqocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msnetobj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msnsspc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobcomm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobdl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msobjs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobmain.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobshel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobweb.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\msoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msoeacct.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\msoeres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msoert2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msoobe.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msorc32r.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mspaint.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mspatcha.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mspclock.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mspmsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mspmspsv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppalrt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppcnfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msppcntr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mspplkrh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppmalr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppmd5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppnxus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mspqm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msprivs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msr2c.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msr2cenu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msratelc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msrating.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msrle32.dll", NULL},
    {L"bhp008.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\MSRPC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\mssap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msscds32.ax", NULL},
    {NULL, L"%systemroot%\\system32\\msscp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msscript.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\mssign32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msswch.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msswchx.exe", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\MST120.DLL", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\MST123.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mstape.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mstask.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\MSTEE.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mstime.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mstlsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstsc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mstscax.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstsmhst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstsmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msuni11.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msutb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msv1_0.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvcirt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvcp50.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\System32\\msvcp60.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\msvcp60.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\msvcr71.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\msvcrt20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvfw32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvidc32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvidctl.dll", NULL},
    {NULL, L"%systemroot%\\system\\MSVIDEO.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\MSVIDEO.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\msw3prt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswebdvd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswmdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswsock.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml2r.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml3r.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxmlr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msyuv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\mtsadmin.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mtstocom.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mtxclu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxlegih.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxoci.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mtxoci8.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\mui\\muisetup.exe", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\multibox.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\mup.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mxcard.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mxicfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mxnic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mxport.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mxport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mycomput.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mydocs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n1000325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n100325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\n9i128.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n9i128.sys", NULL},
    {NULL, L"%systemroot%\\system32\\n9i128v2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n9i128v2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n9i3d.sys", NULL},
    {NULL, L"%systemroot%\\system32\\n9i3disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\NABTSFEC.sys", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nac.dll", NULL},
    {NULL, L"%systemroot%\\system32\\napmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\narrator.exe", NULL},
    {NULL, L"%systemroot%\\system32\\narrhook.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nbtstat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ncobjapi.dll", NULL},
    {L"bhp009.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\NCP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\ncpa.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\ncprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nddeapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nddeapir.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nddenb32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndis.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndisip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\npp\\ndisnpp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndistapi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndisuio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndproxy.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ndptsp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ne2000.sys", NULL},
    {NULL, L"%systemroot%\\system32\\neo20xx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\neo20xx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\net.exe", NULL},
    {NULL, L"%systemroot%\\system32\\net1.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netapi.dll", NULL},
    {L"bhp010.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\NETBIOS.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\netbios.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\netbt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\netcfgx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netdde.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netevent.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\netfxocm.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\NETFXSBS10.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\neth.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netid.dll", NULL},
    {L"bhp011.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\netlogon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netlogon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\netmon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\netoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netplwiz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netrap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netsh.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netshell.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netstat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netui0.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netui1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netui2.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\netuires.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\NetWlan5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\newdev.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\NEXTLINK.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\nfrd960.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ngen.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\nic1394.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nikedrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nlb.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nlbmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\nlbmprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nlhtml.dll", NULL},
    {NULL, L"%systemroot%\\srchasst\\nls302en.lex", NULL},
    {NULL, L"%systemroot%\\system32\\nlsfunc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\nmapi.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmas.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmasnt.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmchat.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmcom.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nmevtmsg.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmft.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nmmkcert.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nmnt.sys", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmoldwb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nmsupp.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmwb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nntpapi.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\nntpctrs.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\nntpfs.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\nntpsvc.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\NOTEPAD.EXE", NULL},
    {NULL, L"%systemroot%\\system32\\NOTEPAD.EXE", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\npdrmv2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\npfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\npp\\nppagent.exe", NULL},
    {NULL, L"%systemroot%\\system32\\npptools.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nscirda.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nshipsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nslookup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nsmmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntbackup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos404.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos411.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos412.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos804.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsatq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsbcli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsbmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsbsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdskcc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsutil.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\ntevt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrsprf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrsres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ntfsdrv.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\ntio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio404.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio411.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio412.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio804.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntkrnlpa.exe", NULL},
    {L"ntkrpamp.exe", L"%systemroot%\\system32\\ntkrnlpa.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntlanman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntlanui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntlanui2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntlsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmarta.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsdba.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsevt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmssvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\ntoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntprint.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntsd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntshrui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntvdm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntvdmd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\null.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nv3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nv3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nv4_disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nv4_mini.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nw16.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nwcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nwevent.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwlnkipx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwlnknb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwlnkspx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nwprovau.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwrdr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nwscript.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nwwks.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oakley.dll", NULL},
    {NULL, L"%systemroot%\\system32\\objsel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\occache.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\ocgen.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbc16gt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbcp32r.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\oeimport.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\oemig50.exe", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\oemiglib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\offfilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ohci1394.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ole2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ole2disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ole2nls.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oleacc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oleaccrc.dll", NULL},
    {NULL, L"%systemroot%\\system\\OLECLI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\OLECLI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\olecli32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\olecnv32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oledlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oleprn.dll", NULL},
    {NULL, L"%systemroot%\\system\\OLESVR.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\OLESVR.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\olesvr32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\olethk32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\oobebaln.exe", NULL},
    {L"opnfiles.exe", L"%systemroot%\\system32\\openfiles.exe", NULL},
    {NULL, L"%systemroot%\\system32\\opengl32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\oprghdlr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\oschoice.exe", NULL},
    {NULL, L"%systemroot%\\system32\\osk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ospf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ospfagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ospfmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\osuninst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\otc06x5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\otceth5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\otcsercb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCam2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCD.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCE.sys", NULL},
    {NULL, L"%systemroot%\\system32\\OVCodec2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCodek2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\OVComC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\OVComS.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVSound2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\OVUI2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\OVUI2RC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\p3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\packager.exe", NULL},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\PADRS404.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\padrs411.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\padrs412.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\padrs804.dll", L"intl.inf"},
    {L"pagefile.vbs", L"%systemroot%\\system32\\pagefileconfig.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\panmap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\paqsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\parport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\parser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\partmgr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\parvdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\pathping.exe", NULL},
    {NULL, L"%systemroot%\\system32\\pautoenr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\pbsnetoc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pc100nds.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\PCA200E.SYS", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\pchshell.dll", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\pchsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pciide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pciidex.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcmcia.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcmlm56.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcntpci5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcx500.sys", NULL},
    {NULL, L"%systemroot%\\system32\\pdh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pentnt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perc2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perc2hib.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\PerfCounter.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\perfctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfdisk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfmon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\perfnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfnw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfos.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfproc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perm2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\perm2dll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perm3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\perm3dd.dll", NULL},
    {L"bhp046.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\pgmparser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\phdsext.ax", NULL},
    {NULL, L"%systemroot%\\system\\philcam1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\philcam1.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\philcam2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\PhilDec.sys", NULL},
    {NULL, L"%systemroot%\\system32\\phon.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\photowiz.dll", NULL},
    {NULL, L"%systemroot%\\system\\phvfwext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pid.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pidgen.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pifmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ping.exe", NULL},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSA.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSD.DIC", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSD.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSK.DIC", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGC.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGD.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGDX.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGI.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGIX.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGL.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\PINTLGNT.IME", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGR.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGS.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLPHR.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\pjlmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\plasmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\plugin.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PMIGRATE.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\pmspl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pngfilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pnrmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\policman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\polstore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\portcls.sys", NULL},
    {NULL, L"%systemroot%\\system32\\powercfg.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\powercfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\powerfil.sys", NULL},
    {NULL, L"%systemroot%\\system32\\powrprof.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ppa.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ppa3.sys", NULL},
    {L"bhp012.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\PPP.DLL", NULL},
    {L"nmpppoe.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\PPPOE.dll", NULL},
    {NULL, L"%systemroot%\\system32\\prc.nls", NULL},
    {NULL, L"%systemroot%\\system32\\prcp.nls", NULL},
    {NULL, L"%systemroot%\\system32\\prflbmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\print.exe", NULL},
    {NULL, L"%systemroot%\\system32\\printui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\prncnfg.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prndrvr.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnjobs.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnmngr.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnport.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnqctl.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\processr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\proctexe.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\profmap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\progman.exe", NULL},
    {NULL, L"%systemroot%\\system32\\proquota.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\provthrd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\proxycfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\psapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\psbase.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pschdprf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\psched.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pscr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\psisdecd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\psisrndr.ax", NULL},
    {NULL, L"%systemroot%\\system32\\psnppagn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pstorec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pstorsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ptilink.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ptpusd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pubprn.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\pwdssp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qappsrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\qasf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qcap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qdv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qdvd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qedwipes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\qic157.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql1080.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql10wnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql12160.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql1240.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql1280.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql2100.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql2200.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql2300.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\qlstrmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\qmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qmgrprxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\qntmmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\qosname.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qprocess.exe", NULL},
    {NULL, L"%systemroot%\\system32\\quartz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\query.dll", NULL},
    {NULL, L"%systemroot%\\system32\\query.exe", NULL},
    {NULL, L"%systemroot%\\system32\\quick.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\quser.exe", NULL},
    {NULL, L"%systemroot%\\system32\\qwinsta.exe", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\Lexicon\\1033\\r1033tts.lxa", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\r2mdkxga.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\r2mdmkxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\racpldlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ramdisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rasacd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rasadhlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasauto.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasautou.exe", NULL},
    {NULL, L"%systemroot%\\system32\\raschap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasdial.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rasdlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rasirda.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rasl2tp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rasman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasmans.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasmontr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasmxs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasphone.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rasppp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\raspppoe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\raspptp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\raspti.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rasrad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rassapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rassfm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rastapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rastls.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasuser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rawwan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\rbfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rcancel.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\rcbdyctl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rcimlby.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rcp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdbss.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdchost.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdpcdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdpcfgex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rdpclip.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rdpdd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdpdr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdpsnd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdpwd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdpwsx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rdsaddin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rdshost.exe", NULL},
    {NULL, L"%systemroot%\\system32\\recover.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\redbook.sys", NULL},
    {NULL, L"%systemroot%\\system32\\redir.exe", NULL},
    {NULL, L"%systemroot%\\system32\\reg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regapi.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\RegAsm.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\RegCode.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\regedit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regedt32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\regfilt.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\regini.exe", NULL},
    {NULL, L"%systemroot%\\system32\\register.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regsvc.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\RegSvcs.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\regsvr32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regtrace.exe", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\regwiz.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regwizc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\relog.exe", NULL},
    {NULL, L"%systemroot%\\system32\\remotepg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\remotesp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\remrras.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rend.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\repdrvfs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\replace.exe", NULL},
    {NULL, L"%systemroot%\\system32\\replprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\reset.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\ResrcMon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\resutils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rexec.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rexpire.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rfeed.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rgroup.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\rigpsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rio8drv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\riodrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ripagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\riprep.exe", NULL},
    {NULL, L"%systemroot%\\system32\\risetup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\RMCast.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rndismp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rnr20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rocket.sys", NULL},
    {NULL, L"%systemroot%\\system32\\romanime.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\rootmdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\route.exe", NULL},
    {NULL, L"%systemroot%\\system32\\routemon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\routetab.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcns4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcnsh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcproxy\\RpcProxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rpcref.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\rpcrt4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcss.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rpfun.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rrasprxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rraswiz.exe", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\rrcm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsAdmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsCli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsCommon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsConn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsEng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsEngPs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rsess.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\rsfilter.sys", NULL},
    {NULL, L"%systemroot%\\system32\\RsFsa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsfsaps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsh.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rshx32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsIdb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsJob.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsLaunch.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsLnk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RSMGRSTR.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsmmllsv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsMover.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsmps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsmsink.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsmui.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsnotify.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsopprov.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\rsoptcom.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Rss.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsServ.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsServPs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsShell.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsSub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsSubPs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsTask.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsTore.exe", NULL},
    {L"bhp022.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\RSVP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\rtcdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtcshare.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rthwcls.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\RTL8029.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\RTL8139.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rtm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtrfiltr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtrupg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtutils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\runas.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rundll32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\runonce.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rwinsta.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rwnh.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\s3gNB.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3gNBm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\S3gsav4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\S3gsav4m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3gsavm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3gsavmx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3legacy.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3mt3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3mt3d.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3mtrio.dll", NULL},
    {NULL, L"%systemroot%\\system32\\s3mvirge.dll", NULL},
    {NULL, L"%systemroot%\\system32\\s3sav3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3sav3dm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3ssav.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3ssavm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sacdrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sacsess.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sacsvr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\safrcdlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\safrdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\safrslv.dll", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\TTS\\1033\\sam.sdf", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\TTS\\1033\\sam.spd", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\sapi.cpl", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\sapi.dll", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\sapisvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\saport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\savedump.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sbp2port.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\sbscmp10.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\sbscrdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sbscrevt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sbscrexe.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\scarddlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scardsvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sccbase.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sccmn50m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sccmusbm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sccsccp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scecli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scesrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\schedsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\schmmgmt.dll", NULL},
    {L"sctasks.exe", L"%systemroot%\\system32\\schtasks.exe", NULL},
    {NULL, L"%systemroot%\\system32\\schupgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sclgntfy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scmstcs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SCR111.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\scrcons.exe", NULL},
    {NULL, L"%systemroot%\\system32\\scrdenrl.dll", NULL},
    {L"scrdia64.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\ia64\\scrdenrl.dll", NULL},
    {L"scrdw2k.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\w2k\\scrdenrl.dll", NULL},
    {L"scrdx86.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\x86\\scrdenrl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scredir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\SCRIPTO.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\scriptpw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scrnsave.scr", NULL},
    {NULL, L"%systemroot%\\system32\\scrptutl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scsiport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scsiprnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scsiscan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sdpblb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\seaddsmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\secedit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\seclogon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\secur32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\security.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sendcmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sendmail.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sens.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sensapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\senscfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\seo.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\seos.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\serenum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\serial.sys", NULL},
    {NULL, L"%systemroot%\\system32\\serialui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sermouse.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\serscan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\servdeps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\services.exe", NULL},
    {NULL, L"%systemroot%\\system32\\serwvdrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sessmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sethc.exe", NULL},
    {L"FXS_strap.exe", L"%systemroot%\\system32\\clients\\faxclient\\setup.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\setup.exe", NULL},
    {L"tscmsi02.w32", L"%systemroot%\\system32\\clients\\tsclient\\win32\\setup.exe", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\setup50.exe", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\setup_wm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\setupcl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\setupqry.dll", NULL},
    {NULL, L"%systemroot%\\system32\\setx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfc_os.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sfloppy.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sfmapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sfmatalk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sfmatmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmprint.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfmpsdib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmpsexe.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfmpsfnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spool\\prtprocs\\w32x86\\sfmpsprt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sfmsrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sfmsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfmwshat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sgiul50.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sgiulnt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\shadow.exe", NULL},
    {NULL, L"%systemroot%\\system32\\share.exe", NULL},
    {NULL, L"%systemroot%\\system32\\shdoclc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shdocvw.dll", NULL},
    {NULL, L"%systemroot%\\system\\SHELL.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\SHELL.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\shell32.dll", NULL},
    {L"blue_ss.dll", L"%systemroot%\\Resources\\Themes\\Luna\\Shell\\NormalColor\\shellstyle.dll", NULL},
    {L"class_ss.dll", L"%systemroot%\\system32\\shellstyle.dll", NULL},
    {L"home_ss.dll", L"%systemroot%\\Resources\\Themes\\Luna\\Shell\\Homestead\\shellstyle.dll", NULL},
    {L"metal_ss.dll", L"%systemroot%\\Resources\\Themes\\Luna\\Shell\\Metallic\\shellstyle.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shfolder.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\shfusion.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\shfusres.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\shgina.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shimgvw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shlwapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shmedia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shmgrate.exe", NULL},
    {NULL, L"%systemroot%\\system32\\shrpubw.exe", NULL},
    {NULL, L"%systemroot%\\system32\\shscrap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shsvcs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shutdown.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sigtab.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sigverif.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SiInt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\simpdata.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\simptcp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sis.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sis300ip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sis300iv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SiS6306p.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SiS6306v.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sisagp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sisbkup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sisgrp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sisgrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sisnic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SiSV.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SiSV256.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sk98xwin.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\skdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\skeys.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SkFpWin.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Sla30nd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\slbcsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\slbiop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\slbrccsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\slbs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\slip.sys", NULL},
    {L"bhp013.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\SMB.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbali.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbhc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smcirda.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smclib.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smi2smir.exe", NULL},
    {NULL, L"%systemroot%\\system32\\smidispb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smierrsm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smierrsy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smiminib.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smimsgif.dll", NULL},
    {NULL, L"%systemroot%\\system32\\smlogcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\smlogsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\smss.exe", NULL},
    {NULL, L"%systemroot%\\system32\\smtpapi.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\smtpcons.dll", NULL},
    {NULL, L"%systemroot%\\system32\\smtpctrs.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\smtpsvc.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\snapshot.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sndrec32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sndvol32.exe", NULL},
    {NULL, L"%systemroot%\\help\\sniffpol.dll", NULL},
    {L"bhp014.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\SNMP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\snmp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\snmpapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpcl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpincl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\snmpmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpsmir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\snmpsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpstup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpthrd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\snmptrap.exe", NULL},
    {NULL, L"%systemroot%\\system32\\snprfdll.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\snyaitmc.sys", NULL},
    {NULL, L"%systemroot%\\ime\\SOFTKBD.DLL", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\softkey.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\softpub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sonyait.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sonydcam.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sonymc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SONYPVU1.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\sort.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sortkey.nls", NULL},
    {NULL, L"%systemroot%\\system32\\sorttbls.nls", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\SOS.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system\\SOUND.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\SOUND.DRV", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\spcommon.dll", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\1033\\spcplui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\spctramc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SPDPorts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SPEED.sys", NULL},
    {NULL, L"%systemroot%\\ime\\spgrmr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\splitter.sys", NULL},
    {NULL, L"%systemroot%\\system32\\spnike.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spoolss.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spoolsv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sprestrt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sprio600.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sprio800.dll", NULL},
    {NULL, L"%systemroot%\\ime\\SPTIP.dll", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\TTS\\1033\\spttseng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spxcoins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Spxupchk.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\sqlxmlx.dll", NULL},
    {NULL, L"%systemroot%\\srchasst\\srchctls.dll", NULL},
    {NULL, L"%systemroot%\\srchasst\\srchui.dll", NULL},
    {L"srgb.icm", L"%systemroot%\\system32\\spool\\drivers\\color\\sRGB Color Space Profile.icm", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\srv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\srvsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ssinc.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\ssmarque.scr", NULL},
    {NULL, L"%systemroot%\\help\\sstub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\stclient.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\stcusb.sys", NULL},
    {NULL, L"%systemroot%\\system\\stdole.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\stdole32.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\stdprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sti.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sti_ci.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\StlnATA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\stlncoin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\StlnProp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\stobject.dll", NULL},
    {NULL, L"%systemroot%\\system32\\storage.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\storport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\storprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\storprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\stream.sys", NULL},
    {NULL, L"%systemroot%\\system32\\streamci.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\streamip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\strmfilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\subst.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\svcext.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\svchost.exe", NULL},
    {NULL, L"%systemroot%\\system32\\svcpack.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sw_effct.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sw_wheel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swdisp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swenum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swkeypad.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swmidi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swnvram.sys", NULL},
    {NULL, L"%systemroot%\\system32\\swprv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SXPorts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sxs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sym_hi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sym_u3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\symc810.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\symc8xx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\symmpi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\syncapp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\synceng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\syncui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sysaudio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sysdm.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\sysedit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sysinv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\syskey.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sysmon.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\syssetup.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Configuration.Install.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Data.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Data.OracleClient.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Design.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.DirectoryServices.dll", L"netfxocm.inf"},
    {L"Sy52106.dll", L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Drawing.Design.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Drawing.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Drawing.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system\\SYSTEM.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\SYSTEM.DRV", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.EnterpriseServices.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.EnterpriseServices.Thunk.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.EnterpriseServices.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Management.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Messaging.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Runtime.Remoting.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Runtime.Serialization.Formatters.Soap.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Security.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.ServiceProcess.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.Mobile.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.RegularExpressions.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.Services.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Windows.Forms.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Windows.Forms.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.XML.dll", L"netfxocm.inf"},
    {L"sysinfo.exe", L"%systemroot%\\system32\\systeminfo.exe", NULL},
    {NULL, L"%systemroot%\\system32\\systray.exe", NULL},
    {NULL, L"%systemroot%\\system32\\t2embed.dll", NULL},
    {NULL, L"%systemroot%\\system32\\t2r4disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\t2r4mini.sys", NULL},
    {NULL, L"%systemroot%\\system32\\takeown.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tandqic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tape.sys", NULL},
    {NULL, L"%systemroot%\\system\\TAPI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\TAPI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\tapi3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapicfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tapiperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapisnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapisrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapiui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\taskkill.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tasklist.exe", NULL},
    {NULL, L"%systemroot%\\system32\\taskmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tbatm155.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tcmsetup.exe", NULL},
    {L"bhp015.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\TCPIP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tcpip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tcpip6.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tcpmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tcpmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tcpmonui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tcpsvcs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tdc.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdk100b.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdpipe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdtcp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\telephon.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\telnet.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\termdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\termmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\termsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tffsport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tftp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tftpd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tgiul50.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tgiulnt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Thawbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\themeui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\timedate.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\timeout.exe", NULL},
    {NULL, L"%systemroot%\\system\\TIMER.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\TIMER.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLGC.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLGL.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\TINTLGNT.IME", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLGS.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLPHR.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTSETP.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\tjisdn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tlntadmn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tlntsess.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tlntsvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tlntsvrp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tls236.dll", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TMIGRATE.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\tmplprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\toolhelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Tos4mo.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tosdvd03.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\toside.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tp4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tp4mon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tp4res.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tracerpt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tracert.exe", NULL},
    {NULL, L"%systemroot%\\system32\\traffic.dll", NULL},
    {L"bhp016.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\TRAIL.DLL", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\trialoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\trid3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\trid3dm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tridkb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tridkbm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tridxp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tridxpm.sys", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Triedit\\TRIEDIT.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\trksvr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\trkwks.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\trnsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\AdStatus\\trustmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsadmin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsappcmp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tsbvcap.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tsbyuv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tscc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tscfgwmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tscon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tscupgrd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsd32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsddd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsdiscon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsecimp.exe", NULL},
    {NULL, L"%systemroot%\\help\\tshoot.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tskill.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\tsoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsprof.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tssdis.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tssdjet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsshutdn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsuserex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tunmp.sys", NULL},
    {NULL, L"%systemroot%\\twain.dll", NULL},
    {NULL, L"%systemroot%\\twain_32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\twext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\TwoTrack.sys", NULL},
    {NULL, L"%systemroot%\\system32\\txflog.dll", NULL},
    {NULL, L"%systemroot%\\system32\\typeperf.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\uddiocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\udfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ufat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\uihelper.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\ulib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ultra.sys", NULL},
    {NULL, L"%systemroot%\\system32\\umandlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\UmaxCam.dll", NULL},
    {NULL, L"%systemroot%\\system32\\umdmxfrm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\unicdime.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\unicode.nls", NULL},
    {L"W95_unidrv.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\unidrv.dll", L"fxsocm.inf"},
    {L"W98_unidrv.dll", L"%systemroot%\\system32\\clients\\faxclient\\System\\W98\\unidrv.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\uniime.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\unimdm.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\unimdmat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\uniplat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\unlodctr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\unsecapp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\untfs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\update.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\updprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\upg351db.exe", NULL},
    {NULL, L"%systemroot%\\PCHealth\\UploadLB\\Binaries\\UploadM.exe", NULL},
    {L"bhp045.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\upnpparser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ups.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ureg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\urlauth.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\usb8023.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\USBAUDIO.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbcamd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbcamd2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbccgp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbehci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbhub.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbintel.sys", NULL},
    {NULL, L"%systemroot%\\system32\\usbmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbohci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbprint.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbscan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbser.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbstor.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbuhci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\usbui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\user.exe", NULL},
    {NULL, L"%systemroot%\\system32\\user32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\userenv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\userinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\usp10.dll", NULL},
    {NULL, L"%systemroot%\\system32\\utildll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\utilman.exe", NULL},
    {NULL, L"%systemroot%\\system32\\uxtheme.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\vbc.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\1033\\vbc7ui.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\vbisurf.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Vchnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdmdbg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\vdmindvd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\vdmredir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vds.exe", NULL},
    {NULL, L"%systemroot%\\system32\\vds_ps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdsbas.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdsdyndr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdsldr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\vdsutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\vdswmi.dll", NULL},
    {NULL, L"%systemroot%\\system\\VER.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\VER.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\verifier.dll", NULL},
    {NULL, L"%systemroot%\\system32\\verifier.exe", NULL},
    {NULL, L"%systemroot%\\system32\\version.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vfwwdm32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vga.dll", NULL},
    {NULL, L"%systemroot%\\system\\VGA.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\VGA.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\vga.sys", NULL},
    {NULL, L"%systemroot%\\system32\\vga256.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vga64k.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\vgapnp.sys", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\VGX\\vgx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\viaagp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\viaide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\viairda.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\videoprt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\viewprov.dll", NULL},
    {L"bhp017.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\VINES.DLL", NULL},
    {NULL, L"%systemroot%\\vmmreg32.dll", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\voicepad.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\voicesub.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\volsnap.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\VsaVb7rt.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\1033\\Vsavb7rtUI.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\vss_ddu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vss_ps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssadmin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\vssapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssddups.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\vsswmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vwipxspx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vwipxspx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\w32time.dll", NULL},
    {NULL, L"%systemroot%\\system32\\w32tm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\w32topl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3cache.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3comlog.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3core.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3ctrlps.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3ctrs.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3dt.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3ext.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3isapi.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\w3ssl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3tp.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3wp.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\W840ND.sys", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wab.exe", NULL},
    {NULL, L"%commonprogramfiles%\\System\\wab32.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\wab32res.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wabfind.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wabimp.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wabmig.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV01nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV02NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV05NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV07nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV08NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV09NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\waitfor.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\wam.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\wamps.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\wamreg.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\wanarp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\watchdog.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV01nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV02NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV04nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV06nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV10nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wavemsp.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\wb32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcntl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcomn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcons.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemdisp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemdisp.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemess.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemprox.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemtest.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemupgd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wbfirdma.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wceusbsh.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wCh7xxNT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\WDHAALBA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wdigest.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wdmaud.drv", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wdmaud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\webcheck.dll", NULL},
    {NULL, L"%systemroot%\\system32\\webclnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\webhits.dll", NULL},
    {NULL, L"%systemroot%\\system32\\webvw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wextract.exe", NULL},
    {NULL, L"%systemroot%\\system\\WFWNET.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\WFWNET.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\where.exe", NULL},
    {NULL, L"%systemroot%\\system32\\whoami.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wiaacmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wiadefui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiadss.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiafbdrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiarpc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiascr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiaservc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiasf.ax", NULL},
    {NULL, L"%systemroot%\\system32\\wiashext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiavideo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wifeman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\win32k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\win32spl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\win87em.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winar30.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\winbrand.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winchat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winfax.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wingb.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\winhelp.exe", NULL},
    {NULL, L"%systemroot%\\winhlp32.exe", NULL},
    {L"winhstb.exe", L"%systemroot%\\system32\\winhlp32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winime.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\winipsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\winmgmt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\winmgmtr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winmm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winmsd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winnls.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winntbbu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winpy.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\winrnr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wins.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winscard.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsevnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsock.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsp.ime", L"intl.inf"},
    {L"bhp021.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\WINSPL.DLL", NULL},
    {NULL, L"%systemroot%\\system\\WINSPOOL.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\WINSPOOL.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\winspool.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winsrpc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winssnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsta.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winver.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winzm.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\wkssvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlanmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlbs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wlbs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wlbsctrl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wlbsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wldap32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wlluc48.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wlnotify.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlsnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlstore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmadmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmadmoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmasf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmdmlog.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmdmps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmerrenu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\xml\\wmi2xml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wmiacpi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiadap.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiapres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiaprpl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiapsrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmic.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmicookr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmidcprv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmidx.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wmilib.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmimsg.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\WMINet_Utils.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipcima.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipdfs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipdskq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipicmp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipiprt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipjobj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmiprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiprvsd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiprvse.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipsess.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmiscmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmisvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmitimep.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiutils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmnetmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmp.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\wmpcd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmpcore.dll", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\wmplayer.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wmploc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmpshell.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmpstub.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wmpui.dll", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\wmpvis.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmsdmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmsdmoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmstream.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmv8dmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmv8ds32.ax", NULL},
    {NULL, L"%systemroot%\\system32\\wmvcore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmvdmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmvdmoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmvds32.ax", NULL},
    {NULL, L"%ProgramFiles%\\Windows NT\\Accessories\\wordpad.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wow32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wowdeb.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wowexec.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wowfax.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wowfaxui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wpabaln.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wpnpinst.exe", NULL},
    {NULL, L"%systemroot%\\system32\\write.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ws2_32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ws2help.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ws2ifsl.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wscript.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wsecedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshatm.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\WSHClus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshcon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wship6.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshirda.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshisn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshnetbs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshom.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\wshqos.dll", NULL},
    {NULL, L"%systemroot%\\system32\\WshRm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshtcpip.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wSiINTxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wsnmp32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wsock32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\WSTCODEC.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\wstdecod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wtsapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wuauclt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wuaueng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wuauserv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wupdmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wVchNTxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wzcdlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wzcsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wzcsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xactsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xcopy.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\xem336n5.sys", NULL},
    {L"xenria64.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\ia64\\xenroll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xenroll.dll", NULL},
    {L"xenrx86.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\x86\\xenroll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xjis.nls", NULL},
    {NULL, L"%systemroot%\\system32\\xlog.exe", NULL},
    {L"bhp018.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\XNS.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\xolehlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\zipfldr.dll", NULL},
};

#define CountSbsFiles (sizeof(SbsFiles)/sizeof(SbsFiles[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\postbuildscripts\sfp\x86_ent.h ===
PROTECT_FILE_ENTRY EntFiles[] =
{
    {NULL, L"%systemroot%\\AppPatch\\AcGenral.dll", NULL},
    {NULL, L"%systemroot%\\AppPatch\\AcLayers.dll", NULL},
    {NULL, L"%systemroot%\\AppPatch\\AcSpecfc.dll", NULL},
    {NULL, L"%systemroot%\\AppPatch\\AcXtrnal.dll", NULL},
    {NULL, L"%systemroot%\\system32\\admwprox.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\adsiis.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\ahui.exe", NULL},
    {NULL, L"%systemroot%\\system32\\apphelp.dll", NULL},
    {NULL, L"%systemroot%\\AppPatch\\apphelp.sdb", NULL},
    {NULL, L"%systemroot%\\help\\apps.chm", NULL},
    {NULL, L"%systemroot%\\system32\\asycfilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atmlib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\CertMap.ocx", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\CertWiz.ocx", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\cfgmgr32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\Cnfgprts.ocx", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\coadmin.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\comctl32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comdlg32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\compatUI.dll", NULL},
    {NULL, L"%systemroot%\\system32\\crypt32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cryptdlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cryptdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cryptext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cryptnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cryptsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cryptui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ctl3d32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dispex.dll", NULL},
    {NULL, L"%systemroot%\\fonts\\dosapp.fon", NULL},
    {NULL, L"%systemroot%\\AppPatch\\drvmain.sdb", NULL},
    {NULL, L"%systemroot%\\system32\\dssenh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fastfat.sys", NULL},
    {NULL, L"%systemroot%\\fonts\\framd.ttf", NULL},
    {NULL, L"%systemroot%\\fonts\\framdit.ttf", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisext.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iismap.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisreset.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisrstap.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisrstas.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisRtl.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisui.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\imeshare.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\inetmgr.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\inetmgr.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\infoadmn.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\ipsec.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\isatq.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\itircl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\itss.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jscript.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jsproxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kernel32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\logui.ocx", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\lsasrv.dll", NULL},
    {NULL, L"%systemroot%\\fonts\\marlett.ttf", NULL},
    {NULL, L"%systemroot%\\system32\\mfc40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mfc40u.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\System\\mfc42.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\System32\\mfc42u.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\mfcsubs.dll", NULL},
    {NULL, L"%systemroot%\\fonts\\micross.ttf", NULL},
    {NULL, L"%systemroot%\\fonts\\modern.fon", NULL},
    {NULL, L"%systemroot%\\AppPatch\\msimain.sdb", NULL},
    {NULL, L"%systemroot%\\system32\\mssip32.dll", NULL},
    {L"FXS_msvcrt.dll", L"%systemroot%\\system32\\clients\\faxclient\\System32\\msvcrt.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\msvcrt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvcrt40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndiswan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\netapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\nntpadm.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\nntpsnap.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\ntdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ntfs.sys", NULL},
    {L"ntkrnlmp.exe", L"%systemroot%\\system32\\ntoskrnl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntoskrnl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nwapi16.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nwapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nwc.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\ocmanage.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbccp32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odtext32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oembios.bin", NULL},
    {NULL, L"%systemroot%\\system32\\oembios.dat", NULL},
    {NULL, L"%systemroot%\\system32\\oembios.sig", NULL},
    {NULL, L"%systemroot%\\system32\\ole32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oleaut32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\olepro32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\riched20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\riched32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsaenh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\s3legacy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\samlib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\samsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\schannel.dll", NULL},
    {NULL, L"%systemroot%\\fonts\\script.fon", NULL},
    {NULL, L"%systemroot%\\system32\\scrobj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scrrun.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sdbinst.exe", NULL},
    {NULL, L"%systemroot%\\system32\\secupd.dat", NULL},
    {NULL, L"%systemroot%\\system32\\secupd.sig", NULL},
    {NULL, L"%systemroot%\\system32\\setupapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfcfiles.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shimeng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\slayerxp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\smtpadm.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\smtpsnap.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\staxmem.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\stdole2.tlb", NULL},
    {NULL, L"%systemroot%\\AppPatch\\sysmain.sdb", NULL},
    {NULL, L"%systemroot%\\system32\\sysocmgr.exe", NULL},
    {NULL, L"%systemroot%\\fonts\\tahoma.ttf", NULL},
    {NULL, L"%systemroot%\\fonts\\tahomabd.ttf", NULL},
    {NULL, L"%systemroot%\\twunk_16.exe", NULL},
    {NULL, L"%systemroot%\\twunk_32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\typelib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\umpnpmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\url.dll", NULL},
    {NULL, L"%systemroot%\\system32\\urlmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vbscript.dll", NULL},
    {NULL, L"%systemroot%\\fonts\\vgaoem.fon", NULL},
    {NULL, L"%systemroot%\\system32\\wamregps.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\wininet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winlogon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wintrust.dll", NULL},
    {NULL, L"%systemroot%\\system32\\asfsipc.dll", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\DAO\\dao360.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drmclien.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drmstor.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ds32gt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dxmasf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\expsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\laprxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\logagent.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mpg4ds32.ax", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\mplayer2.exe", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadce.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadcer.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadcf.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadcfr.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadco.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadcor.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadcs.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msadds.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msadds32.ax", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msaddsr.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msader15.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msado15.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msado20.tlb", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msado21.tlb", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msadomd.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msador15.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msadox.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msadrh15.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mscpxl32.dLL", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdadc.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaenum.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaer.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaora.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaosp.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msdaprsr.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msdaprst.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaps.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msdarem.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msdaremr.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdasc.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdasql.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdasqlr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdatsrc.tlb", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdatt.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaurl.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\msadc\\msdfmap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdxm.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\msdxmlc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msexch40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msexcl40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msjet40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msjint40.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msjro.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msjter40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msjtes40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msltus40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msorcl32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mspbde40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msrd2x40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msrd3x40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msrepl40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstext40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswdat10.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswstr10.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msxactps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxbde40.dll", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\npdsplay.dll", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\npwmsdrm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbc32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbc32gt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbcad32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\odbcconf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbcconf.exe", NULL},
    {NULL, L"%systemroot%\\system32\\odbcconf.rsp", NULL},
    {NULL, L"%systemroot%\\system32\\odbccp32.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\odbccr32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbccu32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbcint.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbcji32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbcjt32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbctrac.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oddbse32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odexl32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odfox32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odpdx32.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\oledb32.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\oledb32r.dll", NULL},
    {NULL, L"%systemroot%\\system32\\strmdll.dll", NULL},
    {NULL, L"%systemroot%\\inf\\unregmp2.exe", NULL},
    {NULL, L"%systemroot%\\system32\\vbajet32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\wmsocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\12520437.cpx", NULL},
    {NULL, L"%systemroot%\\system32\\12520850.cpx", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\1394bus.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\3CWMCRU.sys", NULL},
    {NULL, L"%systemroot%\\system32\\3dfxvs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\3dfxvsm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\4mmdat.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\61883.sys", NULL},
    {NULL, L"%systemroot%\\system32\\6to4svc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\8514a.dll", NULL},
    {NULL, L"%systemroot%\\system32\\aaaamon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ac97ali.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ac97intc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ac97sis.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ac97via.sys", NULL},
    {NULL, L"%systemroot%\\system32\\access.cpl", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Accessibility.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\acctres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\accwiz.exe", NULL},
    {NULL, L"%systemroot%\\Application Compatibility Scripts\\aciniupd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\acledit.dll", NULL},
    {NULL, L"%systemroot%\\AppPatch\\AcLua.dll", NULL},
    {NULL, L"%systemroot%\\system32\\aclui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\acpi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\acpiec.sys", NULL},
    {NULL, L"%systemroot%\\Application Compatibility Scripts\\acregl.exe", NULL},
    {NULL, L"%systemroot%\\Application Compatibility Scripts\\acsr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\activeds.dll", NULL},
    {NULL, L"%systemroot%\\system32\\activeds.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\actmovie.exe", NULL},
    {NULL, L"%systemroot%\\system32\\actxprxy.dll", NULL},
    {NULL, L"%systemroot%\\AppPatch\\AcWebSvc.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\administration\\addusr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adicsc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adicvls.sys", NULL},
    {L"saadmcfg.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\adminconfig.dll", NULL},
    {L"saadmweb.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\adminweb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\admparse.dll", NULL},
    {NULL, L"%systemroot%\\system32\\adprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\adptif.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adptsf50.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adpu160m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adpu320.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ADROT.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\adsiisex.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\adsldp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\adsldpc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\adsmsext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\adsnds.dll", NULL},
    {NULL, L"%systemroot%\\system32\\adsnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\adsnw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adv01nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adv02nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adv05nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adv07nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adv08nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\adv09nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\advapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\advpack.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\aec.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\afcnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\afd.sys", NULL},
    {NULL, L"%systemroot%\\system\\Agcgauge.ax", NULL},
    {NULL, L"%systemroot%\\msagent\\agentanm.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agentctl.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agentdp2.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agentdpv.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agentmpx.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agentpsh.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agentsr.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agentsvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\agp440.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\agpcpq.sys", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0401.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0404.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0405.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0406.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0407.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0408.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0409.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt040b.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt040c.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt040d.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\msagent\\intl\\agt040e.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0410.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0411.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0412.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0413.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0414.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0415.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0416.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0419.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt041d.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt041f.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0804.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0816.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\intl\\agt0c0a.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\agtctl15.tlb", NULL},
    {NULL, L"%systemroot%\\msagent\\agtintl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\aic78u2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\aic78xx.sys", NULL},
    {L"saalteml.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\alertemailmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\alg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ALI5261.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\aliide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\alim1541.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\alink.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\1033\\alinkui.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\alrsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\amdagp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\amdagp8p.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\amdk6.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\amdk7.sys", NULL},
    {NULL, L"%systemroot%\\system32\\amstream.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\an983.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ansi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\apcups.dll", NULL},
    {NULL, L"%systemroot%\\system32\\append.exe", NULL},
    {NULL, L"%systemroot%\\system32\\appmgmts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\appmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\appwiz.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\aqadmin.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\aqueue.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\arp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\arp1394.sys", NULL},
    {NULL, L"%systemroot%\\system32\\asctrls.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\ASFArchiver.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\asferror.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\asp.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_filter.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_isapi.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_rc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_regiis.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_state.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\aspnet_wp.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\aspnetoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\aspperf.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\asr_fmt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\asr_ldm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\asr_pfu.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\asyncmac.sys", NULL},
    {NULL, L"%systemroot%\\system32\\at.exe", NULL},
    {L"bhp001.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\atalk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atapi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ati.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ati2drad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ati2dvaa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ati2dvag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati2mpad.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati2mtaa.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ati2mtag.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ati3d1ag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ati3d2ag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\AtiBt829.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atidrab.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atidrae.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atidvag.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atidvai.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Atievxx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimpab.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimpae.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimtag.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atimtai.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinbtxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinmdxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinpdxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinraxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinrvxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinsnxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinttxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atintuxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinxbxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atinxsxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atipcxxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atiraged.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atiragem.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atirtcap.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atirtsnd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atitunep.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ATITVSnd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ativdaxx.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ativmdcd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ativmvxx.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ativttxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ativxbar.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atixbar.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atkctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\atl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atlmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atmadm.exe", NULL},
    {L"bhp024.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\ATMARP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmarpc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmarps.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmepvc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atmfd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmlane.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atmpvcno.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atmuni.sys", NULL},
    {NULL, L"%systemroot%\\system32\\atrace.dll", NULL},
    {NULL, L"%systemroot%\\system32\\attrib.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv01nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv02nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv04nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv06nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\atv10nt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\administration\\au_accnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\audiosrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\audstub.sys", NULL},
    {NULL, L"%systemroot%\\system32\\authz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\autochk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\autoconv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\autodisc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\autofmt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\autolfn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\avc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\AvcAUDIO.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\avcstrm.sys", NULL},
    {NULL, L"%systemroot%\\system\\AVICAP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\AVICAP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\avicap32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\avifil32.dll", NULL},
    {NULL, L"%systemroot%\\system\\AVIFILE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\AVIFILE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\avmcoxp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\avmenum.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\avmwan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\azroles.dll", NULL},
    {NULL, L"%systemroot%\\system32\\azroleui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\b1cbase.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\b57xp32.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\b5820w2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\administration\\backsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\banshee.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\banshee.sys", NULL},
    {NULL, L"%systemroot%\\system32\\basesrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\batmeter.dll", NULL},
    {NULL, L"%systemroot%\\system32\\batt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\battc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BCM4E5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BCMDM.sys", NULL},
    {NULL, L"%systemroot%\\system32\\bcmmodex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bdaplgin.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\bdasup.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\beep.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Bfax.sys", NULL},
    {NULL, L"%systemroot%\\system32\\bfaxdev.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bfaxfsp.dll", NULL},
    {NULL, L"%ProgramFiles%\\Brooktrout Technology\\Brooktrout FSP\\Snapin\\bfaxsnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bfaxtsp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\bhsupp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bidispl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\big5.nls", NULL},
    {NULL, L"%systemroot%\\system32\\binlsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\bitsoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bitsprx2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\blackbox.dll", NULL},
    {NULL, L"%systemroot%\\help\\bnts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\administration\\bomsnap.dll", NULL},
    {L"bhp002.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\BONE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\bootcfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\bootvid.dll", NULL},
    {NULL, L"%systemroot%\\system32\\bopomofo.nls", NULL},
    {NULL, L"%systemroot%\\system32\\BrBidiIf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\brcoinst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\breecemc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\BrEvIF.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrFilt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrFiltLo.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrFiltUp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\bridge.sys", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfBidi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfcWia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfLpt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfRsmg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\BrmfUSB.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\browscap.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\browselc.dll", NULL},
    {L"bhp003.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\browser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\browser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\browseui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\browsewm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrParImg.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrParwdm.sys", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\brpinfo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrScnRsm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\BrSerIf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrSerWdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrUsbMdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\BrUsbScn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\btdlld.dll", NULL},
    {NULL, L"%systemroot%\\system32\\btpagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\bulltlp3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\c_037.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10000.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10001.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10002.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10003.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10004.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10005.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10006.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10007.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10008.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10010.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10017.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10021.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10029.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10079.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10081.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_10082.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1026.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1047.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1140.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1141.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1142.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1143.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1144.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1145.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1146.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1147.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1148.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1149.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1250.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1251.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1252.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1253.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1254.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1255.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1256.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1257.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1258.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_1361.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20000.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20001.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20002.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20003.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20004.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20005.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20105.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20106.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20107.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20108.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20127.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20261.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20269.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20273.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20277.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20278.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20280.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20284.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20285.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20290.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20297.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20420.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20423.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20424.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20833.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20838.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20866.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20871.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20880.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20905.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20924.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20932.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20936.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_20949.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_21025.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_21027.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_21866.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28591.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28592.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28593.nls", NULL},
    {NULL, L"%systemroot%\\system32\\C_28594.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\C_28595.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\C_28596.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\C_28597.NLS", NULL},
    {NULL, L"%systemroot%\\system32\\c_28598.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28599.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28603.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_28605.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_437.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_500.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_708.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_720.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_737.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_775.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_850.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_852.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_855.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_857.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_858.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_860.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_861.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_862.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_863.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_864.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_865.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_866.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_869.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_870.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_874.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_875.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_932.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_936.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_949.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_950.nls", NULL},
    {NULL, L"%systemroot%\\system32\\c_g18030.dll", NULL},
    {L"cg18030.dll", L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\c_g18030.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\c_is2022.dll", NULL},
    {NULL, L"%systemroot%\\system32\\c_iscii.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cabinet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cabview.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cacls.exe", NULL},
    {NULL, L"%systemroot%\\system32\\calc.exe", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\callcont.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CamDrO21.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\camdrv21.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\camdrv30.sys", NULL},
    {NULL, L"%systemroot%\\system\\CamExO20.ax", NULL},
    {NULL, L"%systemroot%\\system\\CamExO20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\camext20.ax", NULL},
    {NULL, L"%systemroot%\\system\\camext20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Camext30.ax", NULL},
    {NULL, L"%systemroot%\\system32\\Camext30.dll", NULL},
    {NULL, L"%systemroot%\\system32\\camocx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\capesnpn.dll", NULL},
    {L"diapi2.sys", L"%systemroot%\\system32\\drivers\\disdn\\capi20.sys", NULL},
    {L"diapi2NT.dll", L"%systemroot%\\system32\\capi20NT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cards.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\CasPol.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\catsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\catsrvps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\catsrvut.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cb102.sys", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\cb32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CB325.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cben5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cbidf2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cbmdmkxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CCDECODE.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ccfapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ccfgnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cd20xrnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cdfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cdfview.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cdosys.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cdrom.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\CE3N5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cem28n5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cem33n5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cem56n5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\certadm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certcli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certdb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certenc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\certobj.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\certocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certpdef.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certreq.exe", NULL},
    {NULL, L"%systemroot%\\system32\\certsrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\certtmpl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\certutil.exe", NULL},
    {NULL, L"%systemroot%\\system32\\certxds.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cewmdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cfgbkend.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Ch7xxNT5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\chajei.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\change.exe", NULL},
    {L"sachglng.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\ChangeLangMsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\changer.sys", NULL},
    {NULL, L"%systemroot%\\system32\\charmap.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chglogon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chgport.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chgusr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chkdsk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chkntfs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\choice.exe", NULL},
    {NULL, L"%systemroot%\\system32\\chsbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\chtbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTMBX.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTSKDIC.DIC", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTSKDIC.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\CHTSKF.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\ciadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cic.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cidaemon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\cimwin32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cinemclc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTIME.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGB.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGD.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGIE.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGL.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\CINTLGNT.IME", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGS.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGSI.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGU.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTLGUC.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\CINTLGNT\\CINTSETP.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\ciodm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cipher.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cirrus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cirrus.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cisvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ckcnv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cl5465.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cl546x.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cl546xm.sys", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClAdmWiz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\classpnp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\clb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clbcatex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clbcatq.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClCfgSrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cleanmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cleanri.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clip.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clipbrd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clipsrv.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClNetRes.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClNetREx.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\CluAdmEx.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\CluAdmin.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\CluAdMMC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clusapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\clusdisk.sys", NULL},
    {L"IIS_clusftp.vbs", L"%systemroot%\\system32\\inetsrv\\clusftp.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\ClusNet.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\clusocm.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClusRes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ClusSprt.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\ClusSvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cluster.exe", NULL},
    {L"IIS_clusweb.vbs", L"%systemroot%\\system32\\inetsrv\\clusweb.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\ClusWMI.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cmbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cmbp0wdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cmcfg32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmd.exe", NULL},
    {L"evtgprov.dll", L"%systemroot%\\system32\\wbem\\CmdEvTgProv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmdial32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cmdide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cmdkey.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmdl32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmmon32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmpbk32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmprops.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cmstp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cmutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cnbjmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cnetcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cnvfat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cnxt1803.sys", NULL},
    {NULL, L"%systemroot%\\system32\\colbact.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comaddin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\comadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comcat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comclust.exe", NULL},
    {NULL, L"%systemroot%\\system\\COMMDLG.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\COMMDLG.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\comp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\compact.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\compbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\compobj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\compstui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comrepl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\comrepl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\comrereg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\comres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\comsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comsvcs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\comuid.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\conf.exe", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ConfigWizards.exe", L"netfxocm.inf"},
    {NULL, L"%ProgramFiles%\\NetMeeting\\confmrsl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\confmsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\conime.exe", NULL},
    {NULL, L"%systemroot%\\system32\\console.dll", NULL},
    {NULL, L"%systemroot%\\system32\\control.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ContRot.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\convert.exe", NULL},
    {NULL, L"%systemroot%\\system32\\convlog.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\convmsg.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\CORPerfMonExt.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\corpol.dll", NULL},
    {NULL, L"%systemroot%\\system32\\country.sys", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\cplexe.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqarray.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqarry2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqcissm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqdap01.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqfcalm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cpqtrnd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cprofile.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\crcdisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\credui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\crtaud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\crtdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\crusoe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\csamsp.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\csc.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\cscdll.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\cscomp.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\cscompmgd.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\1033\\cscompui.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\cscript.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cscui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\csrsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\csrss.exe", NULL},
    {NULL, L"%systemroot%\\system32\\csseqchk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\csvde.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ctfmon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ctl3d32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ctl3dv2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ctljystk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ctmasetp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ctype.nls", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\CustomMarshalers.dll", L"netfxocm.inf"},
    {L"cv60450.exe", L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\cvtres.exe", L"netfxocm.inf"},
    {L"cwcosnt5.sys", L"%systemroot%\\system32\\drivers\\cwcos.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cwcspud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cwcwdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cwrwdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyclad-z.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyclom-y.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cys.exe", NULL},
    {NULL, L"%systemroot%\\system32\\cyycoins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyyport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cyyports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\cyzcoins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\cyzport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\cyzports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3d8.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3d8thk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dim.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dim700.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dpmesh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dramp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3drm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\d3dxof.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dac2w2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dac960nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\danim.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dataclen.dll", NULL},
    {L"sadattim.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\DateTimeMsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\datime.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\davcdata.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\davclnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\daxctle.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\dayi.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\dbgeng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dbghelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dc21x4.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dc240usd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dc260usd.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\dcap32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dcgpofix.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dciman32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dcomcnfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dcphelp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dcpromo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dcpromo.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ddeml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ddeshare.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ddraw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ddrawex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ddrop.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\ddsmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\debug.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\DebugEx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\defpa.sys", NULL},
    {NULL, L"%systemroot%\\system32\\defrag.exe", NULL},
    {NULL, L"%systemroot%\\system32\\desk.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\deskadp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\deskmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\deskperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\devenum.dll", NULL},
    {L"sadvceid.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\deviceid.dll", NULL},
    {NULL, L"%systemroot%\\system32\\devmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dfe650.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dfe650d.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgfat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgifc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgifps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgntfs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfrgui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dfscmd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfscore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfsgui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfsinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dfssetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfsshlex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dfssvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dgapci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dgconfig.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dgnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dgrpsetu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dgsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpcsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpssvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dhcpwiz.exe", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Triedit\\DHTMLED.OCX", NULL},
    {NULL, L"%systemroot%\\system32\\diactfrm.dll", NULL},
    {NULL, L"%systemroot%\\dialer.exe", NULL},
    {NULL, L"%systemroot%\\system32\\diantz.exe", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\diasymreader.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\digest.dll", NULL},
    {NULL, L"%systemroot%\\system32\\DigiAsyn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digiasyn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\DigiDBP.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digidxb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digifep5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\DigiFwrk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\DigiHLC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\digiinf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\DigiIsdn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digiisdn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\digirlpt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\digirlpt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\DigiView.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\disdn\\dimaint.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dimap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dinput.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dinput8.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\directdb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\disk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\diskcopy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\diskdump.sys", NULL},
    {NULL, L"%systemroot%\\system32\\diskpart.exe", NULL},
    {NULL, L"%systemroot%\\system32\\diskperf.exe", NULL},
    {NULL, L"%systemroot%\\system32\\disrvci.dll", NULL},
    {NULL, L"%systemroot%\\system32\\disrvpp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\disrvsu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ditrace.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\disdn\\diwansrv.sys", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\dlimport.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dllhost.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dllhst3g.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dlttape.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\DM9PCI5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\dmadmin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dmboot.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmconfig.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmdlgs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmdskmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmdskres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmintf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dmio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmivcitf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dmload.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmocx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmremote.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dmserver.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\DMusic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dmutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmvdsitf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dmview.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\dns.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dnsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnsmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnsperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\dnsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnsrslvr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dnswiz.exe", NULL},
    {NULL, L"%systemroot%\\system32\\docprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\docprop2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\domadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\doskey.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dosx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4Prt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4Scan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Dot4usb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\DP83820.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dpcdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dplaysvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dplayx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpmodemx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnaddr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnhpast.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnhupnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnlobby.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpnsvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dpti2o.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dpvacm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpvoice.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpvsetup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dpvvox.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dpwsockx.dll", NULL},
    {L"drvqry.exe", L"%systemroot%\\system32\\driverquery.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\drmk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\drmkaud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drmv2clt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drwatson.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drwtsn32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ds16gt.dLL", NULL},
    {NULL, L"%systemroot%\\system32\\dsadd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsadmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsauth.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsdmo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsdmoprp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsget.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dshowext.ax", NULL},
    {NULL, L"%systemroot%\\system32\\dskquota.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dskquoui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsmod.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsmove.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsound.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsound3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\dsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsquery.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsquery.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dsrestor.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsrevt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsrm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dssec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsuiext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dsuiwiz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dumprep.exe", NULL},
    {NULL, L"%systemroot%\\system32\\duser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dvdplay.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dvdupgrd.exe", NULL},
    {L"dwil1033.dll", L"%systemroot%\\system32\\1033\\dwintl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dwwin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\dx7vb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dx8vb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dxapi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dxdiag.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dxg.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\dxgthk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\dxmrtp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dxtmsft.dll", NULL},
    {NULL, L"%systemroot%\\system32\\dxtrans.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\e1000325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\e100b325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\edb500.dll", NULL},
    {NULL, L"%systemroot%\\system32\\edlin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\efsadu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\EL556ND5.sys", L"net3c556.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\el575ND5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656CD5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656CT5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656ND5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el656SE5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el90xbc5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el90xnd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el985n51.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\el98xn5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\EL99XN51.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\elmsmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\els.dll", NULL},
    {L"em556n4.sys", L"%systemroot%\\system32\\drivers\\em556n4a.sys", NULL},
    {L"em556n4.sys", L"%systemroot%\\system32\\drivers\\em556n4b.sys", NULL},
    {L"em556n4.sys", L"%systemroot%\\system32\\drivers\\em556n4i.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\emu10K1b.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\enum1394.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\epcfw2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\epstw2k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\eqn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\EqnClass.Dll", NULL},
    {NULL, L"%systemroot%\\system32\\eqndiag.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eqnlogr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eqnloop.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ersvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\es.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\es198x.sys", NULL},
    {NULL, L"%systemroot%\\system32\\esent.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esent97.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esentprf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esentutl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\esscli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\essm2e.sys", NULL},
    {NULL, L"%systemroot%\\system32\\esucm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esuimg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esuni.dll", NULL},
    {NULL, L"%systemroot%\\system32\\esunib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\eudcedit.exe", NULL},
    {L"saevent.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\event.dll", NULL},
    {NULL, L"%systemroot%\\system32\\eventcls.dll", NULL},
    {L"evcreate.exe", L"%systemroot%\\system32\\eventcreate.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eventlog.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\EventLogMessages.dll", L"netfxocm.inf"},
    {L"evtquery.vbs", L"%systemroot%\\system32\\eventquery.vbs", NULL},
    {L"evtrig.exe", L"%systemroot%\\system32\\eventtriggers.exe", NULL},
    {NULL, L"%systemroot%\\system32\\eventvwr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\evntagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\evntcmd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\evntrprv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\evntwin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\exabyte2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\examc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\exe2bin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\expand.exe", NULL},
    {NULL, L"%systemroot%\\explorer.exe", NULL},
    {NULL, L"%systemroot%\\system32\\exstrace.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\extrac32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\f3ahvoas.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fa410nd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fastopen.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\fastprox.dll", NULL},
    {NULL, L"%systemroot%\\system32\\faultrep.dll", NULL},
    {NULL, L"%ProgramFiles%\\Brooktrout Technology\\Brooktrout FSP\\Bfax\\faxinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\fc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\fcachdll.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\fdc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fde.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fdeploy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\feclient.dll", NULL},
    {L"fem556n5.sys", L"%systemroot%\\system32\\drivers\\fem556na.sys", NULL},
    {L"fem556n5.sys", L"%systemroot%\\system32\\drivers\\fem556nb.sys", NULL},
    {L"fem556n5.sys", L"%systemroot%\\system32\\drivers\\fem556ni.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fetnd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\filemgmt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\find.exe", NULL},
    {NULL, L"%systemroot%\\system32\\findstr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\finger.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fips.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fixmapi.exe", NULL},
    {NULL, L"%systemroot%\\system32\\flattemp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\flpydisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\fmifs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fontext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fontsub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fontview.exe", NULL},
    {NULL, L"%systemroot%\\system32\\forcedos.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\FOREHE.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\forfiles.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\fp50ext.dll", NULL},
    {L"bhp004.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\FRAME.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\framebuf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\framedyn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\freedisk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fs_rec.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\fsconins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fsutil.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\fsvga.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ftdisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ftlx041e.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\ftp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ftpctrs2.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ftpmib.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ftpsvc2.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\ftsrch.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\fusion.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\fwdprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fxsadmin.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsapi.dll", L"fxsocm.inf"},
    {L"NT4_fxsapi.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\NT4\\fxsapi.dll", L"fxsocm.inf"},
    {L"W9X_fxsapi.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxsapi.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscfgwz.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsclnt.exe", L"fxsocm.inf"},
    {L"W9X_fxsclnt.exe", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxsclnt.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsclntr.dll", L"fxsocm.inf"},
    {L"W9X_fxsclntr.dll", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxsclntr.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscom.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscomex.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxscover.exe", L"fxsocm.inf"},
    {L"W9X_fxscover.exe", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxscover.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsdrv.dll", L"fxsocm.inf"},
    {L"W9X_fxsdrv32.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxsdrv32.dll", L"fxsocm.inf"},
    {L"NT4_fxsdrv4.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\NT4\\fxsdrv4.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsevent.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsext32.dll", L"fxsocm.inf"},
    {L"W9X_fxsext32.dll", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxsext32.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsmon.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\fxsocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\fxsperf.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsres.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsroute.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsrtmtd.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxssend.exe", L"fxsocm.inf"},
    {L"W9X_fxssend.exe", L"%systemroot%\\system32\\clients\\faxclient\\PrgFiles\\msfax\\Bin9x\\fxssend.exe", L"fxsocm.inf"},
    {L"FXS_setup.exe", L"%systemroot%\\system32\\clients\\faxclient\\fxssetup.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsst.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxssvc.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxst30.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxst30p.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxstiff.dll", L"fxsocm.inf"},
    {L"W9X_fxstiff.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxstiff.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxsui.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\fxswzrd.dll", L"fxsocm.inf"},
    {L"W9X_fxswzrd.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\fxswzrd.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\fxsxp32.dll", L"fxsocm.inf"},
    {L"W9X_fxsxp32.dll", L"%systemroot%\\system32\\clients\\faxclient\\System\\fxsxp32.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\G200d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\G200m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\g400dhd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\g400dhm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\g550dhd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\g550dhm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\g711codc.ax", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\gacutil.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\gameenum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\gcdef.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gdi.exe", NULL},
    {NULL, L"%systemroot%\\system32\\gdi32.dll", NULL},
    {L"sagnlset.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\generalsettings.dll", NULL},
    {NULL, L"%systemroot%\\system32\\geo.nls", NULL},
    {NULL, L"%systemroot%\\system32\\getmac.exe", NULL},
    {NULL, L"%systemroot%\\system32\\gettype.exe", NULL},
    {NULL, L"%systemroot%\\system32\\getuname.dll", NULL},
    {NULL, L"%systemroot%\\system32\\glmf32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\glu32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\gm.dls", NULL},
    {NULL, L"%systemroot%\\system32\\gpedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gpkcsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gpkrsrc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\gpr400.sys", NULL},
    {L"gprslt.exe", L"%systemroot%\\system32\\gpresult.exe", NULL},
    {NULL, L"%systemroot%\\system32\\gptext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\gpupdate.exe", NULL},
    {NULL, L"%systemroot%\\system32\\grovel.exe", NULL},
    {NULL, L"%systemroot%\\system32\\grovmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\grpconv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\grserial.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\gzip.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\h323.tsp", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\h323cc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\h323msp.dll", NULL},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Dicts\\hanja.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Dicts\\hanjadic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HCAppRes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hccoin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\HCF_MSFT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hdwwiz.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\help.exe", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HelpCtr.exe", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HelpHost.exe", NULL},
    {L"sahelp.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\helpmsg.dll", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\HelpSvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\hexedit.dll", NULL},
    {NULL, L"%systemroot%\\hh.exe", NULL},
    {NULL, L"%systemroot%\\system32\\hhctrl.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\mui\\0009\\hhctrlui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hhsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hid.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidgame.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidir.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidparse.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hidphone.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\hidserv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hidusb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\himem.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hlink.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\HMMAPI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\hnetcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hnetmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hostmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\hostname.exe", NULL},
    {NULL, L"%systemroot%\\system32\\hotplug.dll", NULL},
    {NULL, L"%systemroot%\\system32\\HpDigWia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hpmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hpn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\hpojwia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\hpt4qic.sys", NULL},
    {NULL, L"%ProgramFiles%\\Windows NT\\htrn_jis.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\http.sys", NULL},
    {NULL, L"%systemroot%\\system32\\httpapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\httpext.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\httpmib.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\httpodbc.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\htui.dll", NULL},
    {NULL, L"%systemroot%\\ime\\CHTIME\\Applets\\HWXCHT.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\hwxjpn.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Applets\\hwxkor.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\i2omgmt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i2omp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\i740dnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i740nt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i8042prt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\i81xdnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\i81xnt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ias.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasacct.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasads.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iashlpr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iaspolcy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasrad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iasrecst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iassam.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iassdo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iassvcs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\IBMSGNET.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\IBMTOK.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\IBMTRP.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ibmvcap.sys", NULL},
    {NULL, L"%systemroot%\\system32\\icaapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Icam3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Icam3EXT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icam4com.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Icam4EXT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Icam4USB.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Icam5com.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Icam5EXT.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Icam5USB.sys", NULL},
    {NULL, L"%systemroot%\\system32\\icfgnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icm32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icmp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icmui.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwconn.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwconn1.exe", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwconn2.exe", NULL},
    {NULL, L"%systemroot%\\system32\\icwdial.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwdl.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwhelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\icwphbk.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwres.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwrmind.exe", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwtutor.exe", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\icwutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\idq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\idwlog.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ie4uinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ieakeng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ieaksie.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ieakui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iedkcs32.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IEExec.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IEExecRemote.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IEHost.dll", L"netfxocm.inf"},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\MSInfo\\IEINFO5.OCX", NULL},
    {NULL, L"%systemroot%\\system32\\iepeers.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iernonce.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iesetup.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\IEXPLORE.EXE", NULL},
    {NULL, L"%systemroot%\\system32\\iexpress.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ifmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ifsutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\igmpagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\igmpv2.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\IIEHost.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\iis.dll", NULL},
    {L"IIS_iis_switch.vbs", L"%systemroot%\\system32\\inetsrv\\iis_switch.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisadmin.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisapp.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisback.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iiscfg.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisclex4.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\IIsCnfg.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisext.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\IIsFtp.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\IIsFtpdr.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iislog.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iismui.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisres.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iissuba.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisuiobj.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisutil.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisvdir.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iisw3adm.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\iisweb.vbs", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iiswmi.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ilasm.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\ils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imadmui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imagehlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imapi.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\imapi.sys", NULL},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Dicts\\imekr.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imekr61.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\imekrcic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\Applets\\imekrmbx.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\imekrmig.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\imepadsm.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\imepadsv.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imgutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\imjp81.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imjp81k.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpcd.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpch.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpcic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpcus.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdadm.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdct.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdct.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpdsvr.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpgn.grm", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpinst.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpln.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpmig.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpnm.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjprw.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpsb.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpst.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjptk.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjpuex.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjputy.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\imjputyc.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\DICTS\\imjpzp.dic", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMKR6_1\\imkrinst.exe", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\imlang.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\imm32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\IMSCINST.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\Setup\\imsinsnt.dll", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\imskdic.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\imskf.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\inetcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetcomm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetcpl.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\inetcplc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\inetinfo.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetmib1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetpp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetppui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetres.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\inetwiz.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\infocomm.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\infoctrs.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\infosoft.dll", NULL},
    {NULL, L"%systemroot%\\system32\\initpki.dll", NULL},
    {NULL, L"%systemroot%\\system32\\input.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inseng.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\InstallUtil.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\InstallUtilLib.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\clients\\tsclient\\win32\\instmsia.exe", NULL},
    {NULL, L"%systemroot%\\system32\\clients\\tsclient\\win32\\instmsiw.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\intelide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\interop_msxml.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\intl.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\inuse.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\io8.sys", NULL},
    {NULL, L"%systemroot%\\system32\\IO8Ports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iologmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ip5515.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ipbootp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipconf.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\ipconfig.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ipfltdrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\iphlpapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipmontr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ipnat.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ipnathlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ippromon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprip.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprip2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprtprio.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iprtrmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsec6.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ipsecsnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsecsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsink.ax", NULL},
    {NULL, L"%systemroot%\\system32\\ipsmsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ipsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ipsraidn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ipv6mon.dll", NULL},
    {L"bhp005.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\IPX.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\ipxroute.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ipxsap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\irbus.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\isapips.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\isapnp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\iscomlog.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\isign32.dll", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\isignup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ismip.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ismserv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ismsink.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ismsmtp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\isrdbg32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\isrpc.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ISymWrapper.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\iuctl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iuengine.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ixsso.dll", NULL},
    {NULL, L"%systemroot%\\system32\\iyuv_32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jet500.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jetconv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\jetpack.exe", NULL},
    {NULL, L"%systemroot%\\system32\\jgaw400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgdw400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgmd400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgpl400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgsd400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jgsh400.dll", NULL},
    {NULL, L"%systemroot%\\system32\\jobexec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\joy.cpl", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\jsc.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\jvcmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101a.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101b.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd101c.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd103.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd106.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbd106n.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbda1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbda1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbda2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbda2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbda3.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbda3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdal.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdarme.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdarmw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdax2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdaze.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdazel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbene.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdblr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdbu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdca.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcan.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\kbdclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcz1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdcz2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdda.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbddiv1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbddiv1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbddiv2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbddiv2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbddv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdest.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfa.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdfa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdfr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgae.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgeo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgkl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdgr1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhe220.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhe319.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdheb.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdheb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhela2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhela3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhept.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\kbdhid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdhu1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdibm02.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdic.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdindev.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdindev.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinguj.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinguj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinhin.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinhin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinkan.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinkan.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinmar.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinmar.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdinpun.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdinpun.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdintam.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdintam.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdintel.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdintel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdit142.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdjpn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdkaz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdkor.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdkyr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdla.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlk41a.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlk41j.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlt1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdlv1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdmac.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdne.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnec95.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnecat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdnecnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdno.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdpl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdpl1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdpo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdro.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdru.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdru1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsl1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsyr1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdsyr1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdsyr2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdsyr2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdtat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth0.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth0.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth1.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth2.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdth3.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdth3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdtuf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdtuq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbduk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdur.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdurdu.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\kbdurdu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdusx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbduzb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdvntc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdycc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kbdycl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kd1394.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kdcom.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kdcsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kerberos.dll", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\PARSERS\\kerbprsr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\key01.sys", NULL},
    {NULL, L"%systemroot%\\system\\KEYBOARD.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\KEYBOARD.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\keyboard.sys", NULL},
    {NULL, L"%systemroot%\\system32\\keymgr.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\keymgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kmddsp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\kmixer.sys", NULL},
    {NULL, L"%systemroot%\\system32\\korwbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\korwbrkr.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\krnl386.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\krnlprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ks.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ksc.nls", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ksecdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ksproxy.ax", NULL},
    {NULL, L"%systemroot%\\system32\\kstvtune.ax", NULL},
    {NULL, L"%systemroot%\\system32\\ksuser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\kswdmcap.ax", NULL},
    {NULL, L"%systemroot%\\system32\\ksxbar.ax", NULL},
    {NULL, L"%systemroot%\\system32\\l_except.nls", NULL},
    {NULL, L"%systemroot%\\system32\\l_intl.nls", NULL},
    {NULL, L"%systemroot%\\system32\\label.exe", NULL},
    {L"bhp023.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LANE.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\langwrbk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lcwiz.exe", NULL},
    {L"bhp025.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LDAP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\ldifde.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\libxprmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\liccpa.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\licdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\licenoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\licmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\licmgr10.dll", NULL},
    {NULL, L"%systemroot%\\system32\\licwmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\linkinfo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\LIT220P.SYS", NULL},
    {L"bhp006.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LLC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\llsmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\llsrpc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\llssrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lmhsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lmmib2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\lmndis3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\lmrt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lnkstub.exe", NULL},
    {NULL, L"%systemroot%\\system32\\loadperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\locale.nls", NULL},
    {NULL, L"%systemroot%\\system32\\localsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\localspl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\localui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\locator.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lodctr.exe", NULL},
    {L"salog.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\log.dll", NULL},
    {NULL, L"%systemroot%\\system32\\loghours.dll", NULL},
    {NULL, L"%systemroot%\\system32\\logman.exe", NULL},
    {NULL, L"%systemroot%\\system32\\logoff.exe", NULL},
    {L"bhp019.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LOGON.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\logon.scr", NULL},
    {NULL, L"%systemroot%\\system32\\logonui.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\logscrpt.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\lonsint.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\loop.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\lp6nds35.sys", NULL},
    {NULL, L"%systemroot%\\system32\\lpdsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lpk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lpq.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lpr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lprhelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lprmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lprmonui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\lrwizdll.dll", NULL},
    {L"bhp020.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\LSARPC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\lsass.exe", NULL},
    {NULL, L"%systemroot%\\system32\\lserver.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltck000c.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltmdmnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltmdmntl.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltmdmntt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ltotape.sys", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\Lexicon\\1033\\ltts1033.lxa", NULL},
    {L"luna.mst", L"%systemroot%\\Resources\\Themes\\Luna\\luna.msstyles", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\LwAdiHid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\LwUsbHid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\lz32.dll", NULL},
    {NULL, L"%systemroot%\\system\\LZEXPAND.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\LZEXPAND.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\m4mc.sys", NULL},
    {L"bhp007.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\MAC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\macfile.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mag_hook.dll", NULL},
    {NULL, L"%systemroot%\\system32\\magnify.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\mailmsg.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\main.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\makecab.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mammoth.sys", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\PARSERS\\mcast.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mcastmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mcd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mcd32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mcdsrv32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mchgrcoi.dll", NULL},
    {NULL, L"%systemroot%\\system\\MCIAVI.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MCIAVI.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\mciavi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mcicda.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciole16.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciole32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciqtz32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mciseq.dll", NULL},
    {NULL, L"%systemroot%\\system\\MCISEQ.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MCISEQ.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\mciwave.dll", NULL},
    {NULL, L"%systemroot%\\system\\MCIWAVE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MCIWAVE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mdgndis5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mdhcp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mdminst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mdwmdmsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mem.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\memcard.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\MemStPCI.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\metadata.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\mf.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mf3216.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mfc42.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mfc42u.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mgaud.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mgaum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mgmtapi.dll", NULL},
    {L"AzRLPia.dll", L"%systemroot%\\Microsoft.NET\\AuthMan\\Microsoft.Interop.Security.AzRoles.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.JScript.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.JScript.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.VisualBasic.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.VisualBasic.Vsa.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.VisualC.Dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.Vb.CodeDOMProcessor.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft.Vsa.Vb.CodeDOMProcessor.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Microsoft.WindowsMediaServices.DLL", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\Microsoft_VsaVb.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\midimap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\migisol.exe", NULL},
    {NULL, L"%systemroot%\\system32\\miglibnt.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\MigPol.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\MigPolWin.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\Com\\migregdb.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mimefilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mindex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\miniqic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mlang.dat", NULL},
    {NULL, L"%systemroot%\\system32\\mlang.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mll_hp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mll_mtf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mll_qic.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mmcbase.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmcndmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmcshext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmfutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mmsys.cpl", NULL},
    {NULL, L"%systemroot%\\system\\MMSYSTEM.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\MMSYSTEM.DLL", NULL},
    {NULL, L"%systemroot%\\system\\MMTASK.TSK", NULL},
    {NULL, L"%systemroot%\\system32\\MMTASK.TSK", NULL},
    {NULL, L"%systemroot%\\system32\\mmutilse.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mnmdd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mnmdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mnmsrvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mobsync.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mobsync.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\modem.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\MODEMCSA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\modemui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\modex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\mofcomp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\mofd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\moricons.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mouclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mouhid.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mountmgr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mountvol.exe", NULL},
    {NULL, L"%systemroot%\\system\\MOUSE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\MOUSE.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mpe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mpg2splt.ax", NULL},
    {NULL, L"%systemroot%\\system32\\mpg4dmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mplay32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mpnotify.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mpr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprddm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprdim.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mprui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mqac.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mqad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqads.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqbkup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqcertui.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\MQClus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdbodbc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdscli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdssrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqdssvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqgentr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqise.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqlogmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqmig.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqmigrat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqoa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqoa10.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mqoa20.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mqperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqqm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqrt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqrtdep.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqtgclus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqtgsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mqtrig.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqupgrd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mqutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mraid35x.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mrinfo.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mrxdav.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mrxsmb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msaatext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msacm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msacm32.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msado25.tlb", NULL},
    {NULL, L"%commonprogramfiles%\\System\\ado\\msado26.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\msafd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msapsspc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msasn1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msaudite.dll", NULL},
    {NULL, L"%systemroot%\\ime\\mscandui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mscat32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mscdexnt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msclus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mscms.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msconf.dll", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\msconfig.exe", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorcfg.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscordbc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscordbi.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscoree.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mui\\0409\\mscoreer.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorie.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mscorier.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mscories.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorjit.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorld.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorlib.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorlib.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.0.3705\\mscormmc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorpe.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorrc.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorsec.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\MUI\\0409\\mscorsecr.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorsn.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorsvr.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscortim.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mscorwks.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\mscpx32r.dLL", NULL},
    {NULL, L"%systemroot%\\system32\\MSCTF.dll", NULL},
    {NULL, L"%systemroot%\\system32\\MSCTFIME.IME", NULL},
    {NULL, L"%systemroot%\\system32\\MSCTFP.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdaorar.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdart.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\msdatl3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdmo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msdtclog.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtcprx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\msdtcstp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtctm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msdtcuiu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msdv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msdvbnp.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msftedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msgame.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msgina.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msgpc.sys", NULL},
    {NULL, L"%systemroot%\\srchasst\\msgr3en.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msgsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mshta.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mshtml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mshtml.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mshtmled.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mshtmler.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msident.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msidle.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msidntld.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msieftp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msiexec.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msihnd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msimg32.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\msimn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msimsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\MSIMTF.dll", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\msinfo.dll", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\MSInfo\\msinfo32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\msiprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msir3jp.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\msir3jp.lex", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\msiregmv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msisam11.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msisip.dll", NULL},
    {L"msjetol1.dll", L"%systemroot%\\system32\\msjetoledb40.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mskssrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mslbui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msls31.dll", NULL},
    {NULL, L"%systemroot%\\msagent\\mslwvtts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\msmpu401.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\msmqocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msnetobj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msnsspc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobcomm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobdl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msobjs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobmain.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobshel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msobweb.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\msoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msoeacct.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\msoeres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msoert2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\msoobe.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msorc32r.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mspaint.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mspatcha.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mspclock.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mspmsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mspmspsv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msports.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppalrt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppcnfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\msppcntr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mspplkrh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppmalr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppmd5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msppnxus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mspqm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\msprivs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msr2c.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msr2cenu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msratelc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msrating.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msrle32.dll", NULL},
    {L"bhp008.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\MSRPC.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\mssap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msscds32.ax", NULL},
    {NULL, L"%systemroot%\\system32\\msscp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msscript.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\mssign32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msswch.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msswchx.exe", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\MST120.DLL", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\MST123.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mstape.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mstask.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\MSTEE.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mstime.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstinit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mstlsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstsc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mstscax.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstsmhst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mstsmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msuni11.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msutb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msv1_0.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvcirt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvcp50.dll", NULL},
    {NULL, L"%systemroot%\\system32\\clients\\faxclient\\System32\\msvcp60.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\msvcp60.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\msvcr71.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\msvcrt20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvfw32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvidc32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msvidctl.dll", NULL},
    {NULL, L"%systemroot%\\system\\MSVIDEO.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\MSVIDEO.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\msw3prt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswebdvd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswmdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mswsock.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml2r.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxml3r.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msxmlr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\msyuv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Com\\mtsadmin.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\mtstocom.exe", NULL},
    {NULL, L"%systemroot%\\system32\\mtxclu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxlegih.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mtxoci.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\mtxoci8.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\mui\\muisetup.exe", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\multibox.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\mup.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mxcard.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mxicfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mxnic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mxport.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\mxport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\mycomput.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mydocs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\mys.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n1000325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n100325.sys", NULL},
    {NULL, L"%systemroot%\\system32\\n9i128.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n9i128.sys", NULL},
    {NULL, L"%systemroot%\\system32\\n9i128v2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n9i128v2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\n9i3d.sys", NULL},
    {NULL, L"%systemroot%\\system32\\n9i3disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\NABTSFEC.sys", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nac.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Namespace.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\napmmc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\narrator.exe", NULL},
    {NULL, L"%systemroot%\\system32\\narrhook.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nbtstat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ncobjapi.dll", NULL},
    {L"bhp009.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\NCP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\ncpa.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\ncprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nddeapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nddeapir.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nddenb32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndis.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndisip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\npp\\ndisnpp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndistapi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndisuio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ndproxy.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ndptsp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ne2000.sys", NULL},
    {NULL, L"%systemroot%\\system32\\neo20xx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\neo20xx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\net.exe", NULL},
    {NULL, L"%systemroot%\\system32\\net1.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netapi.dll", NULL},
    {L"bhp010.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\NETBIOS.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\netbios.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\netbt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\netcfgx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netdde.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netevent.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\netfxocm.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\NETFXSBS10.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\neth.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netid.dll", NULL},
    {L"bhp011.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\netlogon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netlogon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\netmon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\netoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netplwiz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netrap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netsh.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netshell.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netstat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\netui0.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netui1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\netui2.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\netuires.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\NetWlan5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\newdev.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\NEXTLINK.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\nfrd960.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\ngen.exe", L"netfxocm.inf"},
    {L"sanic.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\nic.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nic1394.sys", NULL},
    {L"sanicgbl.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\nicglobal.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nikedrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nlb.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nlbmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\nlbmprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nlhtml.dll", NULL},
    {NULL, L"%systemroot%\\srchasst\\nls302en.lex", NULL},
    {NULL, L"%systemroot%\\system32\\nlsfunc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\nmapi.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmas.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmasnt.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmchat.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmcom.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nmevtmsg.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmft.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nmmkcert.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nmnt.sys", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmoldwb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nmsupp.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\nmwb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nntpapi.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\nntpctrs.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\nntpfs.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\nntpsvc.dll", L"ins.inf"},
    {NULL, L"%systemroot%\\NOTEPAD.EXE", NULL},
    {NULL, L"%systemroot%\\system32\\NOTEPAD.EXE", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\npdrmv2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\npfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\npp\\nppagent.exe", NULL},
    {NULL, L"%systemroot%\\system32\\npptools.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nshipsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nslookup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nsmmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\nsneterr.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\ntbackup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos404.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos411.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos412.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdos804.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsatq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsbcli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsbmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsbsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsetup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdskcc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntdsutil.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\ntevt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrsprf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntfrsres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ntfsdrv.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\ntio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio404.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio411.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio412.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntio804.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ntkrnlpa.exe", NULL},
    {L"ntkrpamp.exe", L"%systemroot%\\system32\\ntkrnlpa.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntlanman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntlanui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntlanui2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntlsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmarta.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsdba.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsevt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmsmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntmssvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\ntoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntprint.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntsd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntshrui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ntvdm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ntvdmd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\null.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nv4_disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nv4_mini.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nw16.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nwcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\nwevent.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwlnkipx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwlnknb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwlnkspx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nwprovau.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\nwrdr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\nwscript.exe", NULL},
    {NULL, L"%systemroot%\\system32\\nwwks.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oakley.dll", NULL},
    {NULL, L"%systemroot%\\system32\\objsel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\occache.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\ocgen.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbc16gt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\odbcp32r.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\oeimport.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\oemig50.exe", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\oemiglib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\offfilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ohci1394.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ole2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ole2disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ole2nls.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oleacc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oleaccrc.dll", NULL},
    {NULL, L"%systemroot%\\system\\OLECLI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\OLECLI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\olecli32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\olecnv32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oledlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oleprn.dll", NULL},
    {NULL, L"%systemroot%\\system\\OLESVR.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\OLESVR.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\olesvr32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\olethk32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\oobe\\oobebaln.exe", NULL},
    {L"opnfiles.exe", L"%systemroot%\\system32\\openfiles.exe", NULL},
    {NULL, L"%systemroot%\\system32\\opengl32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\oprghdlr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\oschoice.exe", NULL},
    {NULL, L"%systemroot%\\system32\\osk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ospf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ospfagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ospfmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\osuninst.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\otc06x5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\otceth5.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\otcsercb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCam2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCD.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCE.sys", NULL},
    {NULL, L"%systemroot%\\system32\\OVCodec2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVCodek2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\OVComC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\OVComS.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\OVSound2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\OVUI2.dll", NULL},
    {NULL, L"%systemroot%\\system32\\OVUI2RC.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\p3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\POP3Server\\P3Admin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\POP3Server\\P3Store.dll", NULL},
    {NULL, L"%systemroot%\\system32\\packager.exe", NULL},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\PADRS404.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\padrs411.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\padrs412.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\SHARED\\RES\\padrs804.dll", L"intl.inf"},
    {L"pagefile.vbs", L"%systemroot%\\system32\\pagefileconfig.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\panmap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\paqsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\parport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\parser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\partmgr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\parvdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\pathping.exe", NULL},
    {NULL, L"%systemroot%\\system32\\pautoenr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\pbsnetoc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pc100nds.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\PCA200E.SYS", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\pchshell.dll", NULL},
    {NULL, L"%systemroot%\\PCHealth\\HelpCtr\\Binaries\\pchsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pciide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pciidex.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcmcia.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcmlm56.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcntpci5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pcx500.sys", NULL},
    {NULL, L"%systemroot%\\system32\\pdh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pentnt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perc2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perc2hib.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\PerfCounter.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\perfctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfdisk.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfmon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\perfnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfnw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfos.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfproc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\perfts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perm2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\perm2dll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\perm3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\perm3dd.dll", NULL},
    {L"bhp046.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\pgmparser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\phdsext.ax", NULL},
    {NULL, L"%systemroot%\\system\\philcam1.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\philcam1.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\philcam2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\PhilDec.sys", NULL},
    {NULL, L"%systemroot%\\system32\\phon.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\photowiz.dll", NULL},
    {NULL, L"%systemroot%\\system\\phvfwext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pid.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pidgen.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pifmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ping.exe", NULL},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSA.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSD.DIC", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSD.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\CHSIME\\APPLETS\\PINTLCSK.DIC", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGC.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGD.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGDX.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGI.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGIX.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGL.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\PINTLGNT.IME", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGR.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLGS.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PINTLPHR.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\pjlmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\plasmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\PlaylistTransformPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\plugin.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\PINTLGNT\\PMIGRATE.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\pmspl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pngfilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pnpmem.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pnrmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\policman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\polstore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\POP3Server\\Pop3Auth.dll", NULL},
    {NULL, L"%systemroot%\\system32\\POP3Server\\Pop3evt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\pop3msg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\pop3oc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\POP3Server\\pop3perf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\POP3Server\\pop3snap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\POP3Server\\POP3Svc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\portcls.sys", NULL},
    {NULL, L"%systemroot%\\system32\\powercfg.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\powercfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\powerfil.sys", NULL},
    {NULL, L"%systemroot%\\system32\\powrprof.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ppa.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ppa3.sys", NULL},
    {L"bhp012.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\PPP.DLL", NULL},
    {L"nmpppoe.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\PPPOE.dll", NULL},
    {NULL, L"%systemroot%\\system32\\prc.nls", NULL},
    {NULL, L"%systemroot%\\system32\\prcp.nls", NULL},
    {NULL, L"%systemroot%\\system32\\prflbmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\print.exe", NULL},
    {NULL, L"%systemroot%\\system32\\printui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\prncnfg.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prndrvr.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnjobs.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnmngr.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnport.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\prnqctl.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\processr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\proctexe.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\profmap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\progman.exe", NULL},
    {NULL, L"%systemroot%\\system32\\proquota.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\provthrd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\proxycfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\psapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\psbase.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pschdprf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\psched.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\pscr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\psisdecd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\psisrndr.ax", NULL},
    {NULL, L"%systemroot%\\system32\\psnppagn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pstorec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pstorsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ptilink.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ptpusd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\pubprn.vbs", NULL},
    {NULL, L"%systemroot%\\system32\\pwdssp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qappsrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\qasf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qcap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qdv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qdvd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qedwipes.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\qic157.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql1080.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql10wnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql12160.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql1240.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql1280.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql2100.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql2200.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ql2300.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\qlstrmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\qmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qmgrprxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\qntmmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\qosname.dll", NULL},
    {NULL, L"%systemroot%\\system32\\qprocess.exe", NULL},
    {NULL, L"%systemroot%\\system32\\quartz.dll", NULL},
    {NULL, L"%systemroot%\\system32\\query.dll", NULL},
    {NULL, L"%systemroot%\\system32\\query.exe", NULL},
    {NULL, L"%systemroot%\\system32\\quick.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\quser.exe", NULL},
    {NULL, L"%systemroot%\\system32\\qwinsta.exe", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\Lexicon\\1033\\r1033tts.lxa", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\r2mdkxga.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\r2mdmkxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\racpldlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ramdisk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rasacd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rasadhlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasauto.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasautou.exe", NULL},
    {NULL, L"%systemroot%\\system32\\raschap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasdial.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rasdlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rasl2tp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rasman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasmans.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasmontr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasmxs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasphone.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rasppp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\raspppoe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\raspptp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\raspti.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rasrad.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rassapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rassfm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rastapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rastls.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rasuser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rawwan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\rbfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rcancel.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\rcbdyctl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rcimlby.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rcp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdbss.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdchost.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdpcdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdpcfgex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rdpclip.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rdpdd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdpdr.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdpsnd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rdpwd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rdpwsx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rdsaddin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rdshost.exe", NULL},
    {NULL, L"%systemroot%\\system32\\recover.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\redbook.sys", NULL},
    {NULL, L"%systemroot%\\system32\\redir.exe", NULL},
    {NULL, L"%systemroot%\\system32\\reg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regapi.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\RegAsm.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\RegCode.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\regedit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regedt32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\regfilt.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\regini.exe", NULL},
    {NULL, L"%systemroot%\\system32\\register.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regsvc.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\RegSvcs.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\regsvr32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regtrace.exe", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\regwiz.exe", NULL},
    {NULL, L"%systemroot%\\system32\\regwizc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\relog.exe", NULL},
    {NULL, L"%systemroot%\\system32\\remotepg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\remotesp.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\remrras.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rend.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\repdrvfs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\replace.exe", NULL},
    {NULL, L"%systemroot%\\system32\\replprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\reset.exe", NULL},
    {NULL, L"%systemroot%\\Cluster\\ResrcMon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\resutils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rexec.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rexpire.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rfeed.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rgroup.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\rigpsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rio8drv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\riodrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ripagnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\riprep.exe", NULL},
    {NULL, L"%systemroot%\\system32\\risetup.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\RMCast.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rndismp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rnr20.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rocket.sys", NULL},
    {NULL, L"%systemroot%\\system32\\romanime.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\rootmdm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\route.exe", NULL},
    {NULL, L"%systemroot%\\system32\\routemon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\routetab.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcns4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcnsh.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcproxy\\RpcProxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rpcref.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\rpcrt4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rpcss.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rpfun.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rrasprxy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rraswiz.exe", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\rrcm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsAdmin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsCli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsCommon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsConn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsEng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsEngPs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\rsess.vbs", L"ins.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\rsfilter.sys", NULL},
    {NULL, L"%systemroot%\\system32\\RsFsa.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsfsaps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsh.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rshx32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsIdb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsJob.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsLaunch.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsLnk.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RSMGRSTR.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsmmllsv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsMover.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsmps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rsmsink.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsmui.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsnotify.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rsopprov.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\rsoptcom.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Rss.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsServ.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RsServPs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsShell.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsSub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsSubPs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsTask.dll", NULL},
    {NULL, L"%systemroot%\\system32\\RsTore.exe", NULL},
    {L"bhp022.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\RSVP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\rtcdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtcshare.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\rthwcls.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\RTL8139.sys", NULL},
    {NULL, L"%systemroot%\\system32\\rtm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtrfiltr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtrupg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\rtutils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\runas.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rundll32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\runonce.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rwinsta.exe", NULL},
    {NULL, L"%systemroot%\\system32\\rwnh.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\s3gNB.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3gNBm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\S3gsav4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\S3gsav4m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3gsavm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3gsavmx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3legacy.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3mt3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3mt3d.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3mtrio.dll", NULL},
    {NULL, L"%systemroot%\\system32\\s3mvirge.dll", NULL},
    {NULL, L"%systemroot%\\system32\\s3sav3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3sav3dm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\s3ssav.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\s3ssavm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sacdrv.sys", NULL},
    {L"sacore.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\sacoremsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sacsess.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sacsvr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\safrcdlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\safrdm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\safrslv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\sagenmsg.dll", NULL},
    {L"sainstal.dll", L"%systemroot%\\system32\\sainstall.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\sakitmsg.dll", NULL},
    {L"saloclui.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\salocaluimsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\salogs.dll", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\TTS\\1033\\sam.sdf", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\TTS\\1033\\sam.spd", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\sapi.cpl", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\sapi.dll", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\sapisvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\saport.sys", NULL},
    {L"sashutdn.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\SaShutdown_msg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\savedump.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sbp2port.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\sbscmp10.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\sc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\scarddlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scardsvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sccbase.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sccmn50m.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sccmusbm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sccsccp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scecli.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scesrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\schedsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\schmmgmt.dll", NULL},
    {L"sctasks.exe", L"%systemroot%\\system32\\schtasks.exe", NULL},
    {NULL, L"%systemroot%\\system32\\schupgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sclgntfy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scmstcs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SCR111.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\scrcons.exe", NULL},
    {NULL, L"%systemroot%\\system32\\scrdenrl.dll", NULL},
    {L"scrdia64.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\ia64\\scrdenrl.dll", NULL},
    {L"scrdw2k.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\w2k\\scrdenrl.dll", NULL},
    {L"scrdx86.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\x86\\scrdenrl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scredir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\SCRIPTO.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\scriptpw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\scrnsave.scr", NULL},
    {NULL, L"%systemroot%\\system32\\scrptutl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scsiport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scsiprnt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\scsiscan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sdpblb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\seaddsmc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\secedit.exe", NULL},
    {NULL, L"%systemroot%\\system32\\seclogon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\secur32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\security.dll", NULL},
    {L"saslfcrt.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\selfsigncertmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sendcmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sendmail.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sens.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sensapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\senscfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\seo.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\seos.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\serenum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\serial.sys", NULL},
    {NULL, L"%systemroot%\\system32\\serialui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sermouse.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\serscan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\servdeps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\services.exe", NULL},
    {NULL, L"%systemroot%\\system32\\serwvdrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sessmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sethc.exe", NULL},
    {L"FXS_strap.exe", L"%systemroot%\\system32\\clients\\faxclient\\setup.exe", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\setup.exe", NULL},
    {L"tscmsi02.w32", L"%systemroot%\\system32\\clients\\tsclient\\win32\\setup.exe", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\setup50.exe", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\setup_wm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\RemInst\\setupcl.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\setupqry.dll", NULL},
    {NULL, L"%systemroot%\\system32\\setx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfc_os.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sfloppy.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sfmapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sfmatalk.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sfmatmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmmsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmprint.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfmpsdib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sfmpsexe.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfmpsfnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spool\\prtprocs\\w32x86\\sfmpsprt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sfmsrv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sfmsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sfmwshat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sgiul50.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sgiulnt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\shadow.exe", NULL},
    {NULL, L"%systemroot%\\system32\\share.exe", NULL},
    {NULL, L"%systemroot%\\system32\\shdoclc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shdocvw.dll", NULL},
    {NULL, L"%systemroot%\\system\\SHELL.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\SHELL.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\shell32.dll", NULL},
    {L"blue_ss.dll", L"%systemroot%\\Resources\\Themes\\Luna\\Shell\\NormalColor\\shellstyle.dll", NULL},
    {L"class_ss.dll", L"%systemroot%\\system32\\shellstyle.dll", NULL},
    {L"home_ss.dll", L"%systemroot%\\Resources\\Themes\\Luna\\Shell\\Homestead\\shellstyle.dll", NULL},
    {L"metal_ss.dll", L"%systemroot%\\Resources\\Themes\\Luna\\Shell\\Metallic\\shellstyle.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shfolder.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\shfusion.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\shfusres.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\shgina.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shimgvw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shlwapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shmedia.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shmgrate.exe", NULL},
    {NULL, L"%systemroot%\\system32\\shrpubw.exe", NULL},
    {NULL, L"%systemroot%\\system32\\shscrap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shsvcs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\shutdown.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sigtab.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sigverif.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SiInt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\simpdata.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\simptcp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sis.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sis300ip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sis300iv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SiS6306p.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SiS6306v.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sisagp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sisbkup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sisgrp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sisgrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sisnic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SiSV.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SiSV256.dll", NULL},
    {L"sasitare.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\sitearea.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sk98xwin.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\skdll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\skeys.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SkFpWin.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Sla30nd5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\slbcsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\slbiop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\slbrccsp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\NETMON\\slbs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\slip.sys", NULL},
    {L"bhp013.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\SMB.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smb.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbali.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbbatt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbclass.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smbhc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smclib.sys", NULL},
    {NULL, L"%systemroot%\\system32\\smcyscom.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smi2smir.exe", NULL},
    {NULL, L"%systemroot%\\system32\\smidispb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smierrsm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smierrsy.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\smiminib.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\SNMP\\smimsgif.dll", NULL},
    {NULL, L"%systemroot%\\system32\\smlogcfg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\smlogsvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\smss.exe", NULL},
    {NULL, L"%systemroot%\\system32\\smtpapi.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\smtpcons.dll", NULL},
    {NULL, L"%systemroot%\\system32\\smtpctrs.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\smtpsvc.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\snapshot.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sndrec32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sndvol32.exe", NULL},
    {NULL, L"%systemroot%\\help\\sniffpol.dll", NULL},
    {L"bhp014.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\SNMP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\snmp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\snmpapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpcl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpincl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\snmpmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpsmir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\snmpsnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpstup.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\snmpthrd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\snmptrap.exe", NULL},
    {NULL, L"%systemroot%\\system32\\snprfdll.dll", L"ims.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\snyaitmc.sys", NULL},
    {NULL, L"%systemroot%\\ime\\SOFTKBD.DLL", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\softkey.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\softpub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sonyait.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sonydcam.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sonymc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SONYPVU1.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\sort.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sortkey.nls", NULL},
    {NULL, L"%systemroot%\\system32\\sorttbls.nls", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\SOS.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system\\SOUND.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\SOUND.DRV", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\spcommon.dll", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Speech\\1033\\spcplui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\spctramc.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SPDPorts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\SPEED.sys", NULL},
    {NULL, L"%systemroot%\\ime\\spgrmr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\splitter.sys", NULL},
    {NULL, L"%systemroot%\\system32\\spnike.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spoolss.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spoolsv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sprestrt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sprio600.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sprio800.dll", NULL},
    {NULL, L"%systemroot%\\ime\\SPTIP.dll", NULL},
    {NULL, L"%commonprogramfiles%\\SpeechEngines\\Microsoft\\TTS\\1033\\spttseng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\spxcoins.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Spxupchk.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\Ole DB\\sqlxmlx.dll", NULL},
    {NULL, L"%systemroot%\\srchasst\\srchctls.dll", NULL},
    {NULL, L"%systemroot%\\srchasst\\srchui.dll", NULL},
    {L"srgb.icm", L"%systemroot%\\system32\\spool\\drivers\\color\\sRGB Color Space Profile.icm", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\srv.sys", NULL},
    {NULL, L"%systemroot%\\system32\\srvsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\ssinc.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\ssmarque.scr", NULL},
    {NULL, L"%systemroot%\\help\\sstub.dll", NULL},
    {NULL, L"%systemroot%\\system32\\stclient.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\stcusb.sys", NULL},
    {NULL, L"%systemroot%\\system\\stdole.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\stdole32.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\stdprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sti.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sti_ci.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\StlnATA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\stlncoin.dll", NULL},
    {NULL, L"%systemroot%\\system32\\StlnProp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\stobject.dll", NULL},
    {NULL, L"%systemroot%\\system32\\storage.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\storport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\storprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\storprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\stream.sys", NULL},
    {NULL, L"%systemroot%\\system32\\streamci.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\streamip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\strmfilt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\strmtest.exe", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\subst.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\svcext.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\svchost.exe", NULL},
    {NULL, L"%systemroot%\\system32\\svcpack.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sw_effct.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sw_wheel.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swdisp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swenum.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swkeypad.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swmidi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\swnvram.sys", NULL},
    {NULL, L"%systemroot%\\system32\\swprv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\SXPorts.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sxs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sym_hi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sym_u3.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\symc810.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\symc8xx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\symmpi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\syncapp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\synceng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\syncui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\sysaudio.sys", NULL},
    {NULL, L"%systemroot%\\system32\\sysdm.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\sysedit.exe", NULL},
    {L"sasysinf.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\sysinfomsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\sysinv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\syskey.exe", NULL},
    {NULL, L"%systemroot%\\system32\\sysmon.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\syssetup.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Configuration.Install.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Data.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Data.OracleClient.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Design.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.DirectoryServices.dll", L"netfxocm.inf"},
    {L"Sy52106.dll", L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Drawing.Design.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Drawing.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Drawing.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system\\SYSTEM.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\SYSTEM.DRV", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.EnterpriseServices.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.EnterpriseServices.Thunk.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.EnterpriseServices.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Management.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Messaging.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Runtime.Remoting.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Runtime.Serialization.Formatters.Soap.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Security.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.ServiceProcess.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.Mobile.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.RegularExpressions.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Web.Services.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Windows.Forms.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.Windows.Forms.tlb", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\System.XML.dll", L"netfxocm.inf"},
    {L"sysinfo.exe", L"%systemroot%\\system32\\systeminfo.exe", NULL},
    {NULL, L"%systemroot%\\system32\\systray.exe", NULL},
    {NULL, L"%systemroot%\\system32\\t2embed.dll", NULL},
    {NULL, L"%systemroot%\\system32\\t2r4disp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\t2r4mini.sys", NULL},
    {NULL, L"%systemroot%\\system32\\takeown.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tandqic.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tape.sys", NULL},
    {NULL, L"%systemroot%\\system\\TAPI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\TAPI.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\tapi3.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapicfg.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tapiperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapisnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapisrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tapiui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\taskkill.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tasklist.exe", NULL},
    {NULL, L"%systemroot%\\system32\\taskmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tbatm155.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tcmsetup.exe", NULL},
    {L"bhp015.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\TCPIP.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tcpip.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tcpip6.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tcpmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tcpmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tcpmonui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tcpsvcs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tdc.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdk100b.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdpipe.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tdtcp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\telephon.cpl", NULL},
    {L"satelnet.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\telnet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\telnet.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\termdd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\termmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\termsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tffsport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tftp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tftpd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tgiul50.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tgiulnt5.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Thawbrkr.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\themeui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\timedate.cpl", NULL},
    {NULL, L"%systemroot%\\system32\\timeout.exe", NULL},
    {NULL, L"%systemroot%\\system\\TIMER.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\TIMER.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLGC.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLGL.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\TINTLGNT.IME", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLGS.IMD", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTLPHR.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TINTSETP.EXE", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\tjisdn.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tlntadmn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tlntsess.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tlntsvr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tlntsvrp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tls236.dll", NULL},
    {NULL, L"%systemroot%\\system32\\IME\\TINTLGNT\\TMIGRATE.DLL", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\tmplprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\toolhelp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tosdvd03.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\toside.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tp4.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tp4mon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tp4res.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tracerpt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tracert.exe", NULL},
    {NULL, L"%systemroot%\\system32\\traffic.dll", NULL},
    {L"bhp016.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\TRAIL.DLL", NULL},
    {NULL, L"%ProgramFiles%\\Internet Explorer\\Connection Wizard\\trialoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\trid3d.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\trid3dm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tridkb.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tridkbm.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tridxp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tridxpm.sys", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\Triedit\\TRIEDIT.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\trksvr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\trkwks.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\trnsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\AdStatus\\trustmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsadmin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsappcmp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tsbvcap.sys", NULL},
    {NULL, L"%systemroot%\\system32\\tsbyuv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tscc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tscfgwmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tscon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tscupgrd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsd32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsddd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsdiscon.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsecimp.exe", NULL},
    {L"satservr.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\tserver.dll", NULL},
    {NULL, L"%systemroot%\\help\\tshoot.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tskill.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\tsoc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsprof.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tssdis.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tssdjet.dll", NULL},
    {NULL, L"%systemroot%\\system32\\tsshutdn.exe", NULL},
    {NULL, L"%systemroot%\\system32\\tsuserex.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\tunmp.sys", NULL},
    {NULL, L"%systemroot%\\twain.dll", NULL},
    {NULL, L"%systemroot%\\twain_32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\twext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\TwoTrack.sys", NULL},
    {NULL, L"%systemroot%\\system32\\txflog.dll", NULL},
    {NULL, L"%systemroot%\\system32\\typeperf.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Setup\\uddiocm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\udfs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\ufat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\uihelper.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\ulib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ultra.sys", NULL},
    {NULL, L"%systemroot%\\system32\\umandlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\UmaxCam.dll", NULL},
    {NULL, L"%systemroot%\\system32\\umdmxfrm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\unicdime.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\unicode.nls", NULL},
    {L"W95_unidrv.dll", L"%systemroot%\\system32\\clients\\faxclient\\Drivers\\W9X\\unidrv.dll", L"fxsocm.inf"},
    {L"W98_unidrv.dll", L"%systemroot%\\system32\\clients\\faxclient\\System\\W98\\unidrv.dll", L"fxsocm.inf"},
    {NULL, L"%systemroot%\\system32\\uniime.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\unimdm.tsp", NULL},
    {NULL, L"%systemroot%\\system32\\unimdmat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\uniplat.dll", NULL},
    {NULL, L"%systemroot%\\system32\\unlodctr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\unsecapp.exe", NULL},
    {NULL, L"%systemroot%\\system32\\untfs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\update.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\updprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\upg351db.exe", NULL},
    {NULL, L"%systemroot%\\PCHealth\\UploadLB\\Binaries\\UploadM.exe", NULL},
    {L"bhp045.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\upnpparser.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ups.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ureg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\urlauth.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\usb8023.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\USBAUDIO.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbcamd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbcamd2.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbccgp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbehci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbhub.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbintel.sys", NULL},
    {NULL, L"%systemroot%\\system32\\usbmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbohci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbport.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbprint.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbscan.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbser.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbstor.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\usbuhci.sys", NULL},
    {NULL, L"%systemroot%\\system32\\usbui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\user.exe", NULL},
    {NULL, L"%systemroot%\\system32\\user32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\userenv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\userinit.exe", NULL},
    {L"sausrmsg.dll", L"%systemroot%\\system32\\ServerAppliance\\MUI\\0409\\usermsg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\usp10.dll", NULL},
    {NULL, L"%systemroot%\\system32\\utildll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\utilman.exe", NULL},
    {NULL, L"%systemroot%\\system32\\uxtheme.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\vbc.exe", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\1033\\vbc7ui.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\vbisurf.ax", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\Vchnt5.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdmdbg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\vdmindvd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\vdmredir.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vds.exe", NULL},
    {NULL, L"%systemroot%\\system32\\vds_ps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdsbas.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdsdyndr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vdsldr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\vdsutil.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\vdswmi.dll", NULL},
    {NULL, L"%systemroot%\\system\\VER.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\VER.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\verifier.dll", NULL},
    {NULL, L"%systemroot%\\system32\\verifier.exe", NULL},
    {NULL, L"%systemroot%\\system32\\version.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vfwwdm32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vga.dll", NULL},
    {NULL, L"%systemroot%\\system\\VGA.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\VGA.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\vga.sys", NULL},
    {NULL, L"%systemroot%\\system32\\vga256.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vga64k.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\vgapnp.sys", NULL},
    {NULL, L"%commonprogramfiles%\\Microsoft Shared\\VGX\\vgx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\viaagp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\viaide.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\videoprt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\viewprov.dll", NULL},
    {L"bhp017.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\VINES.DLL", NULL},
    {NULL, L"%systemroot%\\vmmreg32.dll", NULL},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\voicepad.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\ime\\IMJP8_1\\APPLETS\\voicesub.dll", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\volsnap.sys", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\VsaVb7rt.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\1033\\Vsavb7rtUI.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\vss_ddu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vss_ps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssadmin.exe", NULL},
    {NULL, L"%systemroot%\\system32\\vssapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssddups.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vssvc.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\vsswmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vwipxspx.dll", NULL},
    {NULL, L"%systemroot%\\system32\\vwipxspx.exe", NULL},
    {NULL, L"%systemroot%\\system32\\w32time.dll", NULL},
    {NULL, L"%systemroot%\\system32\\w32tm.exe", NULL},
    {NULL, L"%systemroot%\\system32\\w32topl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3cache.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3comlog.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3core.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3ctrlps.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3ctrs.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3dt.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3ext.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3isapi.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\w3ssl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3tp.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\w3wp.exe", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\W840ND.sys", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wab.exe", NULL},
    {NULL, L"%commonprogramfiles%\\System\\wab32.dll", NULL},
    {NULL, L"%commonprogramfiles%\\System\\wab32res.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wabfind.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wabimp.dll", NULL},
    {NULL, L"%ProgramFiles%\\Outlook Express\\wabmig.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV01nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV02NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV05NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV07nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV08NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wADV09NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\waitfor.exe", NULL},
    {NULL, L"%systemroot%\\system32\\inetsrv\\wam.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\wamps.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\inetsrv\\wamreg.dll", L"iis.inf"},
    {NULL, L"%systemroot%\\system32\\drivers\\wanarp.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\watchdog.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV01nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV02NT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV04nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV06nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wATV10nt.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wavemsp.dll", NULL},
    {NULL, L"%ProgramFiles%\\NetMeeting\\wb32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcntl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcomn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcons.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemcore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemdisp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemdisp.tlb", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemess.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemperf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemprox.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemtest.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wbemupgd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wceusbsh.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wCh7xxNT.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wd.sys", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\WDHAALBA.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wdigest.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wdmaud.drv", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wdmaud.sys", NULL},
    {NULL, L"%systemroot%\\system32\\webcheck.dll", NULL},
    {NULL, L"%systemroot%\\system32\\webclnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\webhits.dll", NULL},
    {NULL, L"%systemroot%\\system32\\webvw.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wextract.exe", NULL},
    {NULL, L"%systemroot%\\system\\WFWNET.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\WFWNET.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\where.exe", NULL},
    {NULL, L"%systemroot%\\system32\\whoami.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wiaacmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wiadefui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiadss.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiafbdrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiarpc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiascr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiaservc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiasf.ax", NULL},
    {NULL, L"%systemroot%\\system32\\wiashext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wiavideo.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wifeman.dll", NULL},
    {NULL, L"%systemroot%\\system32\\win32k.sys", NULL},
    {NULL, L"%systemroot%\\system32\\win32spl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\win87em.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winar30.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\winbrand.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winchat.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winfax.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wingb.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\winhelp.exe", NULL},
    {NULL, L"%systemroot%\\winhlp32.exe", NULL},
    {L"winhstb.exe", L"%systemroot%\\system32\\winhlp32.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winime.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\winipsec.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\winmgmt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\winmgmtr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winmm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winmsd.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winnls.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winntbbu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winpop.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winpy.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\winrnr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wins.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winscard.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsctrs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsevnt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsmib.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsock.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsp.ime", L"intl.inf"},
    {L"bhp021.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\WINSPL.DLL", NULL},
    {NULL, L"%systemroot%\\system\\WINSPOOL.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\WINSPOOL.DRV", NULL},
    {NULL, L"%systemroot%\\system32\\winspool.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winsrpc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winssnap.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winsta.dll", NULL},
    {NULL, L"%systemroot%\\system32\\winver.exe", NULL},
    {NULL, L"%systemroot%\\system32\\winzm.ime", L"intl.inf"},
    {NULL, L"%systemroot%\\system32\\administration\\wizchain.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wkssvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlanmon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlbs.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wlbs.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wlbsctrl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wlbsprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wldap32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wlluc48.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wlnotify.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlsnp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wlstore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmadmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmadmoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmasf.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmdmlog.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmdmps.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmerrenu.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\xml\\wmi2xml.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wmiacpi.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiadap.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiapres.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiaprpl.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiapsrv.exe", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMIBridge.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\wmic.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmicookr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmidcprv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmidx.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wmilib.sys", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMIListener.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\wmimsg.dll", NULL},
    {NULL, L"%systemroot%\\Microsoft.NET\\Framework\\v1.1.4322\\WMINet_Utils.dll", L"netfxocm.inf"},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipcima.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipdfs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipdskq.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipicmp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipiprt.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipjobj.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmiprop.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiprov.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiprvsd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiprvse.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmipsess.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmiscmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmisvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmitimep.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wbem\\wmiutils.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmnetmgr.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmp.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\wmpcd.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmpcore.dll", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\wmplayer.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wmploc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmpshell.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmpstub.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wmpui.dll", NULL},
    {NULL, L"%ProgramFiles%\\Windows Media Player\\wmpvis.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSACLCheckPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\wmsactscrpt.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSAdmin.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSAdminRES.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSAnonAuthenPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSArchiveSinkV1PropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\web\\WMSASPADMIN.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSBROWSE.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSBrowseRES.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSDigestAuthenPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wmsdmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmsdmoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\wmseditor.exe", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wmserr.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wmserror.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMServer.exe", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSHTTPAuthenPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSHTTPControlPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSHttpSysCfg.exe", L"wmsocm.inf"},
    {NULL, L"%systemdrive%\\WMPub\\WMIISLog\\wmsiislog.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSIPAccessPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSIpHlp.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSLF.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSLogPropPages.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSMONITOR.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSMonitorRES.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSMulticastSinkPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSNetworkDataSourcePropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wmsperf.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\wmsperfmon.exe", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSPLAYLIST.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSPlaylistRES.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSPluginRES.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSScriptPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSServer.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSServerConfig.exe", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSServerResource.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSServerResourceRES.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSServerTypeLib.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSServerUpgrade.exe", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\wmssnmp.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\WMSSrvMk.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wmstream.dll", NULL},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSUnicastSinkPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSWizard.exe", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSWizardRES.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\Windows Media\\Server\\Admin\\mmc\\WMSWMIPropPage.dll", L"wmsocm.inf"},
    {NULL, L"%systemroot%\\system32\\wmv8dmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmv8ds32.ax", NULL},
    {NULL, L"%systemroot%\\system32\\wmvcore.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmvdmod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmvdmoe.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wmvds32.ax", NULL},
    {NULL, L"%ProgramFiles%\\Windows NT\\Accessories\\wordpad.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wow32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wowdeb.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wowexec.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wowfax.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wowfaxui.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wpabaln.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wpnpinst.exe", NULL},
    {NULL, L"%systemroot%\\system32\\write.exe", NULL},
    {NULL, L"%systemroot%\\system32\\ws2_32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\ws2help.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\ws2ifsl.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wscript.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wsecedit.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshatm.dll", NULL},
    {NULL, L"%systemroot%\\Cluster\\WSHClus.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshcon.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshext.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wship6.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshisn.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshnetbs.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshom.ocx", NULL},
    {NULL, L"%systemroot%\\system32\\wshqos.dll", NULL},
    {NULL, L"%systemroot%\\system32\\WshRm.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wshtcpip.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wSiINTxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wsnmp32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wsock32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\WSTCODEC.SYS", NULL},
    {NULL, L"%systemroot%\\system32\\wstdecod.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wtsapi32.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wuauclt.exe", NULL},
    {NULL, L"%systemroot%\\system32\\wuaueng.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wuauserv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wupdmgr.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\wVchNTxx.sys", NULL},
    {NULL, L"%systemroot%\\system32\\wzcdlg.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wzcsapi.dll", NULL},
    {NULL, L"%systemroot%\\system32\\wzcsvc.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xactsrv.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xcopy.exe", NULL},
    {NULL, L"%systemroot%\\system32\\drivers\\xem336n5.sys", NULL},
    {L"xenria64.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\ia64\\xenroll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xenroll.dll", NULL},
    {L"xenrx86.dll", L"%systemroot%\\system32\\CertSrv\\CertControl\\x86\\xenroll.dll", NULL},
    {NULL, L"%systemroot%\\system32\\xjis.nls", NULL},
    {NULL, L"%systemroot%\\system32\\xlog.exe", NULL},
    {L"bhp018.dll", L"%systemroot%\\system32\\NETMON\\PARSERS\\XNS.DLL", NULL},
    {NULL, L"%systemroot%\\system32\\xolehlp.dll", NULL},
    {NULL, L"%systemroot%\\system32\\zipfldr.dll", NULL},
};

#define CountEntFiles (sizeof(EntFiles)/sizeof(EntFiles[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.0.3705\aspnet_perf.h ===
#define OBJECT_1                                           0
#define OBJECT_2                                           2
#define ASPNET_APPLICATION_RESTARTS                        4
#define ASPNET_APPLICATIONS_RUNNING                        6
#define ASPNET_REQUESTS_DISCONNECTED                       8
#define ASPNET_REQUEST_EXECUTION_TIME                      10
#define ASPNET_REQUESTS_REJECTED                           12
#define ASPNET_REQUESTS_QUEUED                             14
#define ASPNET_WPS_RUNNING                                 16
#define ASPNET_WPS_RESTARTS                                18
#define ASPNET_REQUEST_WAIT_TIME                           20
#define ASPNET_STATE_SERVER_SESSIONS_ACTIVE                22
#define ASPNET_STATE_SERVER_SESSIONS_ABANDONED             24
#define ASPNET_STATE_SERVER_SESSIONS_TIMED_OUT             26
#define ASPNET_STATE_SERVER_SESSIONS_TOTAL                 28
#define ASPNET_ANONYMOUS_REQUESTS                          30
#define ASPNET_ANONYMOUS_REQUESTS_RATE                     32
#define ASPNET_TOTAL_CACHE_ENTRIES                         34
#define ASPNET_TOTAL_CACHE_TURNOVER_RATE                   36
#define ASPNET_TOTAL_CACHE_HITS                            38
#define ASPNET_TOTAL_CACHE_MISSES                          40
#define ASPNET_TOTAL_CACHE_RATIO                           42
#define ASPNET_TOTAL_CACHE_RATIO_BASE                      44
#define ASPNET_API_CACHE_ENTRIES                           46
#define ASPNET_API_CACHE_TURNOVER_RATE                     48
#define ASPNET_API_CACHE_HITS                              50
#define ASPNET_API_CACHE_MISSES                            52
#define ASPNET_API_CACHE_RATIO                             54
#define ASPNET_API_CACHE_RATIO_BASE                        56
#define ASPNET_OUTPUT_CACHE_ENTRIES                        58
#define ASPNET_OUTPUT_CACHE_TURNOVER_RATE                  60
#define ASPNET_OUTPUT_CACHE_HITS                           62
#define ASPNET_OUTPUT_CACHE_MISSES                         64
#define ASPNET_OUTPUT_CACHE_RATIO                          66
#define ASPNET_OUTPUT_CACHE_RATIO_BASE                     68
#define ASPNET_COMPILATIONS                                70
#define ASPNET_DEBUGGING_REQUESTS                          72
#define ASPNET_ERRORS_PRE_PROCESSING                       74
#define ASPNET_ERRORS_COMPILING                            76
#define ASPNET_ERRORS_DURING_REQUEST                       78
#define ASPNET_ERRORS_UNHANDLED                            80
#define ASPNET_ERRORS_UNHANDLED_RATE                       82
#define ASPNET_ERRORS_TOTAL                                84
#define ASPNET_ERRORS_TOTAL_RATE                           86
#define ASPNET_PIPELINES                                   88
#define ASPNET_REQUEST_BYTES_IN                            90
#define ASPNET_REQUEST_BYTES_OUT                           92
#define ASPNET_REQUESTS_EXECUTING                          94
#define ASPNET_REQUESTS_FAILED                             96
#define ASPNET_REQUESTS_NOT_FOUND                          98
#define ASPNET_REQUESTS_NOT_AUTHORIZED                     100
#define ASPNET_REQUESTS_TIMED_OUT                          102
#define ASPNET_REQUESTS_SUCCEDED                           104
#define ASPNET_REQUESTS_TOTAL                              106
#define ASPNET_REQUESTS_TOTAL_RATE                         108
#define ASPNET_SESSIONS_ACTIVE                             110
#define ASPNET_SESSIONS_ABANDONED                          112
#define ASPNET_SESSIONS_TIMED_OUT                          114
#define ASPNET_SESSIONS_TOTAL                              116
#define ASPNET_TRANSACTIONS_ABORTED                        118
#define ASPNET_TRANSACTIONS_COMMITTED                      120
#define ASPNET_TRANSACTIONS_PENDING                        122
#define ASPNET_TRANSACTIONS_TOTAL                          124
#define ASPNET_TRANSACTIONS_RATE                           126
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.0.3705\corperfmonsymbols.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------ 
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//------------------------------------------------------------------------ 
#define DotNetCLR_Memory_OBJECT                            0
#define GEN0_COLLECTIONS_COUNTER                           2
#define GEN1_COLLECTIONS_COUNTER                           4
#define GEN2_COLLECTIONS_COUNTER                           6
#define GEN0_BYTES_PROMOTED_COUNTER                        8
#define GEN1_BYTES_PROMOTED_COUNTER                        10
#define GEN0_PROMOTION_RATE                                12
#define GEN1_PROMOTION_RATE                                14
#define GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER           16
#define GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER           18
#define GEN0_HEAP_SIZE_COUNTER                             20
#define GEN1_HEAP_SIZE_COUNTER                             22
#define GEN2_HEAP_SIZE_COUNTER                             24
#define LARGE_OBJECT_SIZE_COUNTER                          26
#define SURVIVE_FINALIZE_COUNTER                           28
#define NUM_HANDLES_COUNTER                                30
#define ALLOCATION_RATE_COUNTER                            32
#define INDUCED_GC_COUNTER                                 34
#define PER_TIME_IN_GC_COUNTER                             36
#define PER_TIME_IN_GC_COUNTER_BASE                        38
#define TOTAL_HEAP_SIZE_COUNTER                            40
#define TOTAL_COMMITTED_MEM_COUNTER                        42
#define TOTAL_RESERVED_MEM_COUNTER                         44
#define GC_PINNED_OBJECTS                                  46
#define GC_SINKBLOCKS                                      48
#define DotNetCLR_Loading_OBJECT                           50
#define LOADING_CLASSES_TOTAL                              52
#define LOADING_TIME                                       54
#define LOADING_ASMSEARCHLEN                               56
#define LOADING_LOADFAILURES_TOTAL                         58
#define LOADING_LOADFAILURES_INST                          60
#define LOADING_HEAPSIZE                                   62
#define LOADING_APPDOMAINS_UNLOADED_TOTAL                  64
#define LOADING_APPDOMAINS_UNLOADED_INST                   66
#define LOADING_CLASSES_CUR                                68
#define LOADING_CLASSES_INST                               70
#define LOADING_APPDOMAINS_CUR                             72
#define LOADING_APPDOMAINS_TOTAL                           74
#define LOADING_APPDOMAINS_INST                            76
#define LOADING_ASSEMBLIES_CUR                             78
#define LOADING_ASSEMBLIES_TOTAL                           80
#define LOADING_ASSEMBLIES_INST                            82
#define DotNetCLR_Jit_OBJECT                               84
#define TOTAL_METHODS_JITTED                               86
#define JITTED_IL_CUR                                      88
#define JITTED_IL_TOTAL                                    90
#define JITTED_IL_INST                                     92
#define JIT_FAILURES                                       94
#define TIME_IN_JIT                                        96
#define TIME_IN_JIT_BASE                                   98
#define DotNetCLR_Interop_OBJECT                           100
#define CURRENT_CCW                                        102
#define CURRENT_STUBS                                      104
#define NUM_MARSHALLING                                    106
#define TOTAL_TLB_IMPORTS                                  108
#define TOTAL_TLB_EXPORTS                                  110
#define DotNetCLR_LocksAndThreads_OBJECT                   112
#define CONTENTION_TOTAL                                   114
#define CONTENTION_INST                                    116
#define QUEUE_LENGTH_CUR                                   118
#define QUEUE_LENGTH_TOTAL                                 120
#define QUEUE_LENGTH_INST                                  122
#define CURRENT_LOGICAL_THREADS                            124
#define CURRENT_PHYSICAL_THREADS                           126
#define RECOGNIZED_THREADS_CUR                             128
#define RECOGNIZED_THREADS_TOTAL                           130
#define RECOGNIZED_THREADS_INST                            132
#define DotNetCLR_Security_OBJECT                          134
#define SECURITY_TOTALRTCHECKS                             136
#define SECURITY_TIMEAUTHORIZE                             138
#define SECURITY_LINKCHECKS                                140
#define SECURITY_TIMERTCHECKS                              142
#define SECURITY_TIMERTCHECKS_BASE                         144
#define SECURITY_DEPTHSECURITY                             146
#define DotNetCLR_Remoting_OBJECT                          148
#define CONTEXT_REMOTECALLS_INST                           150
#define CONTEXT_CHANNELS                                   152
#define CONTEXT_PROXIES                                    154
#define CONTEXT_CLASSES                                    156
#define CONTEXT_OBJALLOC                                   158
#define CONTEXT_CONTEXTS                                   160
#define CONTEXT_REMOTECALLS_TOTAL                          162
#define DotNetCLR_Excep_OBJECT                             164
#define EXCEP_THROWN_TOTAL                                 166
#define EXCEP_THROWN_INST                                  168
#define TOTAL_EXCEP_FILTERS_RUN                            170
#define TOTAL_EXCEP_FINALLYS_RUN                           172
#define EXCEPT_STACK_DEPTH                                 174
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.0.3705\_dataperfcounters.h ===
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
#define DEVICE_COUNTER_6 12;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.0.3705\_networkingperfcounters.h ===
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.1.4322\aspnet_perf.h ===
#define OBJECT_1                                           0
#define OBJECT_2                                           2
#define ASPNET_APPLICATION_RESTARTS                        4
#define ASPNET_APPLICATIONS_RUNNING                        6
#define ASPNET_REQUESTS_DISCONNECTED                       8
#define ASPNET_REQUEST_EXECUTION_TIME                      10
#define ASPNET_REQUESTS_REJECTED                           12
#define ASPNET_REQUESTS_QUEUED                             14
#define ASPNET_WPS_RUNNING                                 16
#define ASPNET_WPS_RESTARTS                                18
#define ASPNET_REQUEST_WAIT_TIME                           20
#define ASPNET_STATE_SERVER_SESSIONS_ACTIVE                22
#define ASPNET_STATE_SERVER_SESSIONS_ABANDONED             24
#define ASPNET_STATE_SERVER_SESSIONS_TIMED_OUT             26
#define ASPNET_STATE_SERVER_SESSIONS_TOTAL                 28
#define ASPNET_ANONYMOUS_REQUESTS                          30
#define ASPNET_ANONYMOUS_REQUESTS_RATE                     32
#define ASPNET_TOTAL_CACHE_ENTRIES                         34
#define ASPNET_TOTAL_CACHE_TURNOVER_RATE                   36
#define ASPNET_TOTAL_CACHE_HITS                            38
#define ASPNET_TOTAL_CACHE_MISSES                          40
#define ASPNET_TOTAL_CACHE_RATIO                           42
#define ASPNET_TOTAL_CACHE_RATIO_BASE                      44
#define ASPNET_API_CACHE_ENTRIES                           46
#define ASPNET_API_CACHE_TURNOVER_RATE                     48
#define ASPNET_API_CACHE_HITS                              50
#define ASPNET_API_CACHE_MISSES                            52
#define ASPNET_API_CACHE_RATIO                             54
#define ASPNET_API_CACHE_RATIO_BASE                        56
#define ASPNET_OUTPUT_CACHE_ENTRIES                        58
#define ASPNET_OUTPUT_CACHE_TURNOVER_RATE                  60
#define ASPNET_OUTPUT_CACHE_HITS                           62
#define ASPNET_OUTPUT_CACHE_MISSES                         64
#define ASPNET_OUTPUT_CACHE_RATIO                          66
#define ASPNET_OUTPUT_CACHE_RATIO_BASE                     68
#define ASPNET_COMPILATIONS                                70
#define ASPNET_DEBUGGING_REQUESTS                          72
#define ASPNET_ERRORS_PRE_PROCESSING                       74
#define ASPNET_ERRORS_COMPILING                            76
#define ASPNET_ERRORS_DURING_REQUEST                       78
#define ASPNET_ERRORS_UNHANDLED                            80
#define ASPNET_ERRORS_UNHANDLED_RATE                       82
#define ASPNET_ERRORS_TOTAL                                84
#define ASPNET_ERRORS_TOTAL_RATE                           86
#define ASPNET_PIPELINES                                   88
#define ASPNET_REQUEST_BYTES_IN                            90
#define ASPNET_REQUEST_BYTES_OUT                           92
#define ASPNET_REQUESTS_EXECUTING                          94
#define ASPNET_REQUESTS_FAILED                             96
#define ASPNET_REQUESTS_NOT_FOUND                          98
#define ASPNET_REQUESTS_NOT_AUTHORIZED                     100
#define ASPNET_REQUESTS_TIMED_OUT                          102
#define ASPNET_REQUESTS_SUCCEDED                           104
#define ASPNET_REQUESTS_TOTAL                              106
#define ASPNET_REQUESTS_TOTAL_RATE                         108
#define ASPNET_SESSIONS_ACTIVE                             110
#define ASPNET_SESSIONS_ABANDONED                          112
#define ASPNET_SESSIONS_TIMED_OUT                          114
#define ASPNET_SESSIONS_TOTAL                              116
#define ASPNET_TRANSACTIONS_ABORTED                        118
#define ASPNET_TRANSACTIONS_COMMITTED                      120
#define ASPNET_TRANSACTIONS_PENDING                        122
#define ASPNET_TRANSACTIONS_TOTAL                          124
#define ASPNET_TRANSACTIONS_RATE                           126
#define ASPNET_SESSION_STATE_SERVER_CONNECTIONS            128
#define ASPNET_SESSION_SQL_SERVER_CONNECTIONS              130
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.1.4322\corperfmonsymbols.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------ 
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//   AUTO GENERATED FILE. DO NOT EDIT. USE $/com99/src/profile/perfmonhelp 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//------------------------------------------------------------------------ 
#define DotNetCLR_Memory_OBJECT                            0
#define GEN0_COLLECTIONS_COUNTER                           2
#define GEN1_COLLECTIONS_COUNTER                           4
#define GEN2_COLLECTIONS_COUNTER                           6
#define GEN0_BYTES_PROMOTED_COUNTER                        8
#define GEN1_BYTES_PROMOTED_COUNTER                        10
#define GEN0_PROMOTION_RATE                                12
#define GEN1_PROMOTION_RATE                                14
#define GEN0_FINALIZATION_BYTES_PROMOTED_COUNTER           16
#define GEN1_FINALIZATION_BYTES_PROMOTED_COUNTER           18
#define GEN0_HEAP_SIZE_COUNTER                             20
#define GEN1_HEAP_SIZE_COUNTER                             22
#define GEN2_HEAP_SIZE_COUNTER                             24
#define LARGE_OBJECT_SIZE_COUNTER                          26
#define SURVIVE_FINALIZE_COUNTER                           28
#define NUM_HANDLES_COUNTER                                30
#define ALLOCATION_RATE_COUNTER                            32
#define INDUCED_GC_COUNTER                                 34
#define PER_TIME_IN_GC_COUNTER                             36
#define PER_TIME_IN_GC_COUNTER_BASE                        38
#define TOTAL_HEAP_SIZE_COUNTER                            40
#define TOTAL_COMMITTED_MEM_COUNTER                        42
#define TOTAL_RESERVED_MEM_COUNTER                         44
#define GC_PINNED_OBJECTS                                  46
#define GC_SINKBLOCKS                                      48
#define DotNetCLR_Loading_OBJECT                           50
#define LOADING_CLASSES_TOTAL                              52
#define LOADING_TIME                                       54
#define LOADING_ASMSEARCHLEN                               56
#define LOADING_LOADFAILURES_TOTAL                         58
#define LOADING_LOADFAILURES_INST                          60
#define LOADING_HEAPSIZE                                   62
#define LOADING_APPDOMAINS_UNLOADED_TOTAL                  64
#define LOADING_APPDOMAINS_UNLOADED_INST                   66
#define LOADING_CLASSES_CUR                                68
#define LOADING_CLASSES_INST                               70
#define LOADING_APPDOMAINS_CUR                             72
#define LOADING_APPDOMAINS_TOTAL                           74
#define LOADING_APPDOMAINS_INST                            76
#define LOADING_ASSEMBLIES_CUR                             78
#define LOADING_ASSEMBLIES_TOTAL                           80
#define LOADING_ASSEMBLIES_INST                            82
#define DotNetCLR_Jit_OBJECT                               84
#define TOTAL_METHODS_JITTED                               86
#define JITTED_IL_CUR                                      88
#define JITTED_IL_TOTAL                                    90
#define JITTED_IL_INST                                     92
#define JIT_FAILURES                                       94
#define TIME_IN_JIT                                        96
#define TIME_IN_JIT_BASE                                   98
#define DotNetCLR_Interop_OBJECT                           100
#define CURRENT_CCW                                        102
#define CURRENT_STUBS                                      104
#define NUM_MARSHALLING                                    106
#define TOTAL_TLB_IMPORTS                                  108
#define TOTAL_TLB_EXPORTS                                  110
#define DotNetCLR_LocksAndThreads_OBJECT                   112
#define CONTENTION_TOTAL                                   114
#define CONTENTION_INST                                    116
#define QUEUE_LENGTH_CUR                                   118
#define QUEUE_LENGTH_TOTAL                                 120
#define QUEUE_LENGTH_INST                                  122
#define CURRENT_LOGICAL_THREADS                            124
#define CURRENT_PHYSICAL_THREADS                           126
#define RECOGNIZED_THREADS_CUR                             128
#define RECOGNIZED_THREADS_TOTAL                           130
#define RECOGNIZED_THREADS_INST                            132
#define DotNetCLR_Security_OBJECT                          134
#define SECURITY_TOTALRTCHECKS                             136
#define SECURITY_TIMEAUTHORIZE                             138
#define SECURITY_LINKCHECKS                                140
#define SECURITY_TIMERTCHECKS                              142
#define SECURITY_TIMERTCHECKS_BASE                         144
#define SECURITY_DEPTHSECURITY                             146
#define DotNetCLR_Remoting_OBJECT                          148
#define CONTEXT_REMOTECALLS_INST                           150
#define CONTEXT_CHANNELS                                   152
#define CONTEXT_PROXIES                                    154
#define CONTEXT_CLASSES                                    156
#define CONTEXT_OBJALLOC                                   158
#define CONTEXT_CONTEXTS                                   160
#define CONTEXT_REMOTECALLS_TOTAL                          162
#define DotNetCLR_Excep_OBJECT                             164
#define EXCEP_THROWN_TOTAL                                 166
#define EXCEP_THROWN_INST                                  168
#define TOTAL_EXCEP_FILTERS_RUN                            170
#define TOTAL_EXCEP_FINALLYS_RUN                           172
#define EXCEPT_STACK_DEPTH                                 174
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.1.4322\_dataperfcounters.h ===
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
#define DEVICE_COUNTER_6 12;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\x86\managed\urt\v1.1.4322\_networkingperfcounters.h ===
#define OBJECT_1 0;
#define DEVICE_COUNTER_1 2;
#define DEVICE_COUNTER_2 4;
#define DEVICE_COUNTER_3 6;
#define DEVICE_COUNTER_4 8;
#define DEVICE_COUNTER_5 10;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\common.inc ===
#
# Common include file 'sources' files in the CTF project.
#

#
# Set private paths
#

INCLUDES        = \
    ..;\
    $(WINDOWS_INC_PATH); \
    $(SDK_INC_PATH); \
    $(BASE_INC_PATH);\
    $(INCLUDES)

#
# Skip these files when determining dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                       atlbase.h  \
                       atlcom.h   \
                       atlconv.h  \
                       atlctl.h   \
                       atlctl.cpp \
                       atliface.h \
                       atlimpl.cpp \
                       atlwin.h   \
                       atlwin.cpp \
                       ia64inst.h \
                       macapi.h   \
                       macname1.h \
                       macname2.h \
                       macocidl.h \
                       macpub.h   \
                       macwin32.h \
                       mainwin.h  \
                       mwversion.h \
                       ntamd64.h \
                       penwin.h \
                       pshpck16.h \
                       rpcerr.h   \
                       rpcmac.h   \
                       setupx.h   \
                       skbapi.h   \
                       statreg.h  \
                       statreg.cpp \
                       unixstuff.h \
                       version.h  \
                       winwlm.h   \
                       ..\inc16\shellapi.h \
                       assertwithstack.h



#
# Do this to assure that we run W2K, NT4, Win9x even with the latest header.
#
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
WIN32_WIN95_VERSION=$(LATEST_WIN32_WIN95_VERSIOIN)
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)

#
# Override NT5 settings
#
SUBSYSTEM_VERSION=4.00

#
# Defining this allows windows.h to include other headers
#
NOT_LEAN_AND_MEAN= 1

#
# Don't link to the runtime libs
#
USE_NOLIBS      = 1

#
# Don't link to NTDLL if this runs on both platforms
#
NO_NTDLL=1

UMTYPE          = windows

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32 -DUSE_MIRRORING -DNT -DCUAS_ENABLE

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif


# ------ Debug Only Defines --------

!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w

# Check for missing PURE directives in interface decls (debug only)
C_DEFINES       = $(C_DEFINES) -DNO_NOVTABLE
!endif

# ------ End Debug Only Defines --------


#
# our target is both Win9x and NT. need map and sym.
#
USE_MAPSYM      = 1


CICERO_DIR       = $(PROJECT_ROOT)\AdvCore\ctf

INCLUDES         = $(INCLUDES);             \
                   $(CICERO_DIR)\inc;       \
                   $(CICERO_DIR)\inc\$(O);  \
                   $(CICERO_DIR)\inc_test

CICERO_LIBS      = $(CICERO_DIR)\uuid\$O\uimuuid.lib    \
                   $(CICERO_DIR)\lib\$O\immxlib.lib     \
                   $(CICERO_DIR)\prvlib\$O\prvlib.lib   \
                   $(CICERO_DIR)\cicmem\$O\cicmem.lib

CICERO_LIBS2     = $(CICERO_LIBS)                       \
                   $(CICERO_DIR)\uim\$O\msctf.lib

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\api.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    api.cpp

Abstract:

    This file implements the CActiveIMMAppEx Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "list.h"
#include "globals.h"


//+---------------------------------------------------------------------------
//
// CGuidMapList
//    Allocated by Global data object !!
//
//----------------------------------------------------------------------------

extern CGuidMapList      *g_pGuidMapList;


//+---------------------------------------------------------------------------
//
// MsimtfIsWindowFiltered
//
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI MsimtfIsWindowFiltered(HWND hwnd)
{
    if (!g_pGuidMapList)
        return FALSE;

    return g_pGuidMapList->_IsWindowFiltered(hwnd);
}

//+---------------------------------------------------------------------------
//
// MsimtfIsGuidMapEnable
//
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI MsimtfIsGuidMapEnable(HIMC himc, BOOL *pbGuidmap)
{
    if (!g_pGuidMapList)
        return FALSE;

    return g_pGuidMapList->_IsGuidMapEnable(himc, pbGuidmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\common.inc ===
#
# include file for aimm project
#

!include $(PROJECT_ROOT)\AdvCore\ctf\common.inc

AIMM_DIR            = $(CICERO_DIR)\aimm1.2
INCLUDES            = $(AIMM_DIR)\inc;$(AIMM_DIR)\uuid\$(O);$(INCLUDES)

C_DEFINES=$(C_DEFINES) -DSLEEPMODE  -DOLD_AIMM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\atom.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    atom.cpp

Abstract:

    This file implements the CAtomObject class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "atom.h"
#include "globals.h"

//+---------------------------------------------------------------------------
//
// CAtomObject
//
//----------------------------------------------------------------------------

HRESULT
CAtomObject::_InitAtom(
    LPCTSTR lpString
    )
{
    HRESULT hr;
    size_t  cch;

    if (m_AtomName)
        return S_OK;

    hr = StringCchLength(lpString, 255, &cch);
    if (hr != S_OK)
        return hr;

    m_AtomName = new TCHAR[cch+1];
    if (m_AtomName == NULL)
        return E_OUTOFMEMORY;

    hr = StringCchCopy(m_AtomName, cch+1, lpString);
    return hr;
}

HRESULT
CAtomObject::_Activate()
{
    EnterCriticalSection(g_cs);

    int ref = ++m_AtomRefCount;

    if (ref == 1) {
        //
        // Add AIMM1.2 ATOM
        //
        m_Atom = AddAtom(m_AtomName);
    }

    LeaveCriticalSection(g_cs);

    return S_OK;
}

HRESULT
CAtomObject::_Deactivate()
{
    EnterCriticalSection(g_cs);

    int ref = --m_AtomRefCount;

    if (ref == 0) {
        //
        // Delete AIMM1.2 ATOM
        //
        DeleteAtom(m_Atom);
        m_Atom = 0;
    }

    LeaveCriticalSection(g_cs);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping
// this).

#include <windows.h>
#include "ccstock.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSIMTF"
#define SZ_MODULE       "MSIMTF"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\atom.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    atom.h

Abstract:

    This file defines the CAtomObject Class.

Author:

Revision History:

Notes:

--*/


#ifndef ATOM_H
#define ATOM_H


/////////////////////////////////////////////////////////////////////////////
// CAtomObject

class CAtomObject
{
public:
    CAtomObject() : m_AtomRefCount(0), m_AtomName(NULL), m_Atom(0) { }
    virtual ~CAtomObject()
    {
        if (m_AtomName)
            delete [] m_AtomName;
        if (m_Atom)
            DeleteAtom(m_Atom);
    }

    HRESULT _InitAtom(LPCTSTR lpString);
    HRESULT _Activate();
    HRESULT _Deactivate();

private:
    int        m_AtomRefCount;
    LPTSTR     m_AtomName;
    ATOM       m_Atom;
};

#endif // ATOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmex.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmex.h

Abstract:

    This file defines the CActiveIMMAppEx Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _DIMMEX_H_
#define _DIMMEX_H_

#include "resource.h"
#include "globals.h"
#include "list.h"
#include "atom.h"
#include "delay.h"
#include "oldaimm.h"

extern CGuidMapList      *g_pGuidMapList;

BOOL InitFilterList();
void UninitFilterList();

extern CAtomObject  *g_pAimmAtom;

BOOL InitAimmAtom();
void UninitAimmAtom();


    //
    // 4955DD32-B159-11d0-8FCF-00AA006BCC59
    //
    static const IID IID_IActiveIMMAppTrident4x = {
       0x4955DD32,
       0xB159,
       0x11d0,
       { 0x8F, 0xCF, 0x00, 0xaa, 0x00, 0x6b, 0xcc, 0x59 }
    };

    // 
    // c839a84c-8036-11d3-9270-0060b067b86e
    // 
    static const IID IID_IActiveIMMAppPostNT4 = { 
        0xc839a84c,
        0x8036,
        0x11d3,
        {0x92, 0x70, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e}
    };

//+---------------------------------------------------------------------------
//
// CComActiveIMMApp
//
//----------------------------------------------------------------------------

class CComActiveIMMApp : public IActiveIMMAppEx,
                         public IActiveIMMMessagePumpOwner,
                         public IAImmThreadCompartment,
                         public IServiceProvider
{
public:
    CComActiveIMMApp()
    {
        _fEnableGuidMap = FALSE;
        m_hModCtfIme = NULL;
    }

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        //
        // Look up disabling Text Services status from the registry.
        // If it is disabled, return fail not to support Text Services.
        //
        if (IsDisabledTextServices())
            return FALSE;

        if (RunningInExcludedModule())
            return FALSE;

        if (!IsInteractiveUserLogon())
            return FALSE;

        if (NoTipsInstalled(NULL))
            return FALSE;

        return TRUE;
    }

    //
    // IActiveIMMMessagePumpOwner
    //
    STDMETHODIMP Start() { return E_NOTIMPL; }
    STDMETHODIMP End() { return E_NOTIMPL; }
    STDMETHODIMP OnTranslateMessage(const MSG *pMsg) { return E_NOTIMPL; }
    STDMETHODIMP Pause(DWORD *pdwCookie) { return E_NOTIMPL; }
    STDMETHODIMP Resume(DWORD dwCookie) { return E_NOTIMPL; }

    //
    // IActiveIMMApp/IActiveIMM methods
    //

    /*
     * AIMM Input Context (hIMC) Methods.
     */
    STDMETHODIMP CreateContext(HIMC *phIMC)
    {
        HIMC hIMC = imm32::ImmCreateContext();
        if (hIMC) {
            *phIMC = hIMC;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP DestroyContext(HIMC hIMC)
    {
        return (imm32::ImmDestroyContext(hIMC)) ? S_OK
                                                : E_FAIL;
    }
    STDMETHODIMP AssociateContext(HWND hWnd, HIMC hIMC, HIMC *phPrev)
    {
        *phPrev = imm32::ImmAssociateContext(hWnd, hIMC);
        return S_OK;
    }
    STDMETHODIMP AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags)
    {
        return (imm32::ImmAssociateContextEx(hWnd, hIMC, dwFlags)) ? S_OK
                                                                   : E_FAIL;
    }
    STDMETHODIMP GetContext(HWND hWnd, HIMC *phIMC)
    {
        *phIMC = imm32::ImmGetContext(hWnd);
        return S_OK;
    }
    STDMETHODIMP ReleaseContext(HWND hWnd, HIMC hIMC)
    {
        return (imm32::ImmReleaseContext(hWnd, hIMC)) ? S_OK
                                                      : E_FAIL;
    }
    STDMETHODIMP GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount)
    {
        *pdwLockCount = imm32::ImmGetIMCLockCount(hIMC);
        return S_OK;
    }
    STDMETHODIMP LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC)
    {
        return (*ppIMC = imm32::ImmLockIMC(hIMC)) ? S_OK
                                                  : E_FAIL;
    }
    STDMETHODIMP UnlockIMC(HIMC hIMC)
    {
        imm32::ImmUnlockIMC(hIMC);
        return S_OK;
    }

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    STDMETHODIMP CreateIMCC(DWORD dwSize, HIMCC *phIMCC)
    {
        HIMCC hIMCC = imm32::ImmCreateIMCC(dwSize);
        if (hIMCC) {
            *phIMCC = hIMCC;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP DestroyIMCC(HIMCC hIMCC)
    {
        /*
         * ImmDestroyIMCC maped to LocalFree.
         *   if the function fails, the return value is equal to a handle to the local memory object.
         *   if the function succeeds, the return value is NULL.
         */
        return (imm32::ImmDestroyIMCC(hIMCC)) ? E_FAIL
                                              : S_OK;
    }
    STDMETHODIMP GetIMCCSize(HIMCC hIMCC, DWORD *pdwSize)
    {
        *pdwSize = imm32::ImmGetIMCCSize(hIMCC);
        return S_OK;
    }
    STDMETHODIMP ReSizeIMCC(HIMCC hIMCC, DWORD dwSize, HIMCC *phIMCC)
    {
        HIMCC hNewIMCC = imm32::ImmReSizeIMCC(hIMCC, dwSize);
        if (hNewIMCC) {
            *phIMCC = hNewIMCC;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount)
    {
        *pdwLockCount = imm32::ImmGetIMCCLockCount(hIMCC);
        return S_OK;
    }
    STDMETHODIMP LockIMCC(HIMCC hIMCC, void **ppv)
    {
        return (*ppv = imm32::ImmLockIMCC(hIMCC)) ? S_OK
                                                  : E_FAIL;
    }
    STDMETHODIMP UnlockIMCC(HIMCC hIMCC)
    {
        if (imm32::ImmUnlockIMCC(hIMCC)) {
            // memory object still locked.
            return S_OK;
        }
        else {
            DWORD err = GetLastError();
            if (err == NO_ERROR)
                // memory object is unlocked.
                return S_OK;
            else if (err == ERROR_NOT_LOCKED)
                // memory object is already unlocked.
                return S_OK;
        }
        return E_FAIL;
    }

    /*
     * AIMM Open Status API Methods
     */
    STDMETHODIMP GetOpenStatus(HIMC hIMC)
    {
        return imm32::ImmGetOpenStatus(hIMC) ? S_OK : S_FALSE;
    }
    STDMETHODIMP SetOpenStatus(HIMC hIMC, BOOL fOpen)
    {
        return (imm32::ImmSetOpenStatus(hIMC, fOpen)) ? S_OK
                                                      : E_FAIL;
    }

    /*
     * AIMM Conversion Status API Methods
     */
    STDMETHODIMP GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion, DWORD *lpfdwSentence)
    {
        return (imm32::ImmGetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence)) ? S_OK
                                                                                     : E_FAIL;
    }
    STDMETHODIMP SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence)
    {
        return (imm32::ImmSetConversionStatus(hIMC, fdwConversion, fdwSentence)) ? S_OK
                                                                                 : E_FAIL;
    }

    /*
     * AIMM Status Window Pos API Methods
     */
    STDMETHODIMP GetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
    {
        return (imm32::ImmGetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                             : E_FAIL;
    }
    STDMETHODIMP SetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
    {
        return (imm32::ImmSetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                             : E_FAIL;
    }

    /*
     * AIMM Composition String API Methods
     */
    STDMETHODIMP GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
    {
        LONG lRet;
        if ((dwIndex & GCS_COMPATTR) && IsGuidMapEnable(hIMC))
        {
            dwIndex &= ~GCS_COMPATTR;
            dwIndex |=  GCS_COMPGUIDATTR;
        }
        lRet = imm32::ImmGetCompositionStringA(hIMC, dwIndex, lpBuf, dwBufLen);
        if (lRet < 0)
            return E_FAIL;
        else {
            *plCopied = lRet;
            return S_OK;
        }
    }
    STDMETHODIMP GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
    {
        LONG lRet;
        if ((dwIndex & GCS_COMPATTR) && IsGuidMapEnable(hIMC))
        {
            dwIndex &= ~GCS_COMPATTR;
            dwIndex |=  GCS_COMPGUIDATTR;
        }
        lRet = imm32::ImmGetCompositionStringW(hIMC, dwIndex, lpBuf, dwBufLen);
        if (lRet < 0)
            return E_FAIL;
        else {
            *plCopied = lRet;
            return S_OK;
        }
    }
    STDMETHODIMP SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
    {
        if (imm32::ImmSetCompositionStringA(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
    {
        if (imm32::ImmSetCompositionStringW(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen))
            return S_OK;
        else
            return E_FAIL;
    }

    /*
     * AIMM Composition Font API Methods
     */
    STDMETHODIMP GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
    {
        if (imm32::ImmGetCompositionFontA(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
    {
        if (imm32::ImmGetCompositionFontW(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
    {
        if (imm32::ImmSetCompositionFontA(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }
    STDMETHODIMP SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
    {
        if (imm32::ImmSetCompositionFontW(hIMC, lplf))
            return S_OK;
        else
            return E_FAIL;
    }

    /*
     * AIMM Composition Window API Methods
     */
    STDMETHODIMP GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
    {
        return (imm32::ImmGetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                                  : E_FAIL;
    }
    STDMETHODIMP SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
    {
        return (imm32::ImmSetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                                  : E_FAIL;
    }

    /*
     * AIMM Candidate List API Methods
     */
    STDMETHODIMP GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListA(hIMC, dwIndex, lpCandList, uBufLen);
        if (dwRet) {
            *puCopied = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListW(hIMC, dwIndex, lpCandList, uBufLen);
        if (dwRet) {
            *puCopied = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListCountA(hIMC, lpdwListSize);
        if (dwRet) {
            *pdwBufLen = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }
    STDMETHODIMP GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
    {
        DWORD dwRet;
        dwRet = imm32::ImmGetCandidateListCountW(hIMC, lpdwListSize);
        if (dwRet) {
            *pdwBufLen = dwRet;
            return S_OK;
        }
        return E_FAIL;
    }

    /*
     * AIMM Candidate Window API Methods
     */
    STDMETHODIMP GetCandidateWindow(HIMC hIMC, DWORD dwIndex, CANDIDATEFORM *lpCandidate)
    {
        return (imm32::ImmGetCandidateWindow(hIMC, dwIndex, lpCandidate)) ? S_OK
                                                                          : E_FAIL;
    }
    STDMETHODIMP SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate)
    {
        return (imm32::ImmSetCandidateWindow(hIMC, lpCandidate)) ? S_OK
                                                                 : E_FAIL;
    }

    /*
     * AIMM Guide Line API Methods
     */
    STDMETHODIMP GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetGuideLineA(hIMC, dwIndex, pBuf, dwBufLen);
        return S_OK;
    }
    STDMETHODIMP GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetGuideLineW(hIMC, dwIndex, pBuf, dwBufLen);
        return S_OK;
    }

    /*
     * AIMM Notify IME API Method
     */
    STDMETHODIMP NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
    {
        return (imm32::ImmNotifyIME(hIMC, dwAction, dwIndex, dwValue)) ? S_OK
                                                                       : E_FAIL;
    }

    /*
     * AIMM Menu Items API Methods
     */
    STDMETHODIMP GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetImeMenuItemsA(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize);
        return S_OK;
    }
    STDMETHODIMP GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult)
    {
        *pdwResult = imm32::ImmGetImeMenuItemsW(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize);
        return S_OK;
    }

    /*
     * AIMM Register Word API Methods
     */
    STDMETHODIMP RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister)
    {
        return imm32::ImmRegisterWordA(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister)
    {
        return imm32::ImmRegisterWordW(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister)
    {
        return imm32::ImmUnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister)
    {
        return imm32::ImmUnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
    }
    STDMETHODIMP EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum)
    {
        return E_FAIL;
    }
    STDMETHODIMP EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum)
    {
        return E_FAIL;
    }
    STDMETHODIMP GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetRegisterWordStyleA(hKL, nItem, lpStyleBuf);
        return S_OK;
    }
    STDMETHODIMP GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetRegisterWordStyleW(hKL, nItem, lpStyleBuf);
        return S_OK;
    }

    /*
     * AIMM Configuration API Methods.
     */
    STDMETHODIMP ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata)
    {
        return imm32::ImmConfigureIMEA(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
    }
    STDMETHODIMP ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata)
    {
        return imm32::ImmConfigureIMEW(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
    }
    STDMETHODIMP GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetDescriptionA(hKL, lpszDescription, uBufLen);
        return *puCopied ? S_OK : E_FAIL;
    }
    STDMETHODIMP GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetDescriptionW(hKL, lpszDescription, uBufLen);
        return *puCopied ? S_OK : E_FAIL;
    }
    STDMETHODIMP GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetIMEFileNameA(hKL, lpszFileName, uBufLen);
        return S_OK;
    }
    STDMETHODIMP GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetIMEFileNameW(hKL, lpszFileName, uBufLen);
        return S_OK;
    }
    STDMETHODIMP InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL)
    {
        *phKL = imm32::ImmInstallIMEA(lpszIMEFileName, lpszLayoutText);
        return S_OK;
    }
    STDMETHODIMP InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL)
    {
        *phKL = imm32::ImmInstallIMEW(lpszIMEFileName, lpszLayoutText);
        return S_OK;
    }
    STDMETHODIMP GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty)
    {
        *pdwProperty = imm32::ImmGetProperty(hKL, fdwIndex);
        return S_OK;
    }
    STDMETHODIMP IsIME(HKL hKL)
    {
        //
        //
        //
        //
        if (!imm32prev::CtfAImmIsIME(hKL))
            return S_FALSE;

        return imm32::ImmIsIME(hKL) ? S_OK : E_FAIL;
    }

    // others
    STDMETHODIMP EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        *plResult = imm32::ImmEscapeA(hKL, hIMC, uEscape, lpData);
        return S_OK;
    }
    STDMETHODIMP EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        *plResult = imm32::ImmEscapeW(hKL, hIMC, uEscape, lpData);
        return S_OK;
    }
    STDMETHODIMP GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetConversionListA(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
        return S_OK;
    }
    STDMETHODIMP GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
    {
        *puCopied = imm32::ImmGetConversionListW(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
        return S_OK;
    }
    STDMETHODIMP GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd)
    {
        *phDefWnd = imm32::ImmGetDefaultIMEWnd(hWnd);
        return S_OK;
    }
    STDMETHODIMP GetVirtualKey(HWND hWnd, UINT *puVirtualKey)
    {
        *puVirtualKey = imm32::ImmGetVirtualKey(hWnd);
        return S_OK;
    }
    STDMETHODIMP IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        return imm32::ImmIsUIMessageA(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
    }
    STDMETHODIMP IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        return imm32::ImmIsUIMessageW(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
    }

    // ime helper methods
    STDMETHODIMP GenerateMessage(HIMC hIMC)
    {
        return (imm32::ImmGenerateMessage(hIMC)) ? S_OK
                                                 : E_FAIL;
    }

    // hot key manipulation api's
    STDMETHODIMP GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL)
    {
        return (imm32::ImmGetHotKey(dwHotKeyID, puModifiers, puVKey, phKL)) ? S_OK
                                                                            : E_FAIL;
    }
    STDMETHODIMP SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL)
    {
        return (imm32::ImmSetHotKey(dwHotKeyID, uModifiers, uVKey, hKL)) ? S_OK
                                                                         : E_FAIL;
    }
    STDMETHODIMP SimulateHotKey(HWND hWnd, DWORD dwHotKeyID)
    {
        return imm32::ImmSimulateHotKey(hWnd, dwHotKeyID) ? S_OK : S_FALSE;
    }

    // soft keyboard api's
    STDMETHODIMP CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd);
    STDMETHODIMP DestroySoftKeyboard(HWND hSoftKbdWnd);
    STDMETHODIMP ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    // win98/nt5 apis
    STDMETHODIMP DisableIME(DWORD idThread)
    {
        return imm32::ImmDisableIME(idThread) ? S_OK : E_FAIL;
    }
    STDMETHODIMP RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
    {
        *plResult = imm32::ImmRequestMessageA(hIMC, wParam, lParam);
        return S_OK;
    }
    STDMETHODIMP RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
    {
        *plResult = imm32::ImmRequestMessageW(hIMC, wParam, lParam);
        return S_OK;
    }
    STDMETHODIMP EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum)
    {
        Assert(0);
        return E_NOTIMPL;
    }

    // methods without corresponding IMM APIs

    //
    // IActiveIMMApp methods
    //

    STDMETHODIMP Activate(BOOL fRestoreLayout);
    STDMETHODIMP Deactivate();

    STDMETHODIMP OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    //
    // FilterClientWindows
    //
    STDMETHODIMP FilterClientWindows(ATOM *aaWindowClasses, UINT uSize);

    //
    //
    //
    STDMETHODIMP GetCodePageA(HKL hKL, UINT *uCodePage);
    STDMETHODIMP GetLangId(HKL hKL, LANGID *plid);

    //
    // IActiveIMMAppEx
    //
    STDMETHODIMP FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap);
    STDMETHODIMP FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);

    STDMETHODIMP GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom);

    STDMETHODIMP UnfilterClientWindowsEx(HWND hWnd);

    //
    // IServiceProvider
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IAImmThreadCompartment,
    //
    STDMETHODIMP SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);
    STDMETHODIMP GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);

protected:
    VOID _EnableGuidMap(BOOL fEnableGuidMap)
    {
        _fEnableGuidMap = fEnableGuidMap;
    }

private:
    BOOL IsGuidMapEnable(HIMC hIMC)
    {
        if (!InitFilterList())
            return FALSE;

        if (_fEnableGuidMap)
        {
            BOOL fGuidMap;

            if (g_pGuidMapList->_IsGuidMapEnable(hIMC, &fGuidMap))
            {
                if (fGuidMap)
                {
                    return imm32prev::CtfImmIsGuidMapEnable(hIMC);
                }
            }
        }
        return FALSE;
    }

private:
    BOOL  _fEnableGuidMap : 1;    // TRUE: Enable GUID Map attribute

    HMODULE m_hModCtfIme;
};

//+---------------------------------------------------------------------------
//
// CActiveIMMAppEx
//
//----------------------------------------------------------------------------

class CActiveIMMAppEx : public CComActiveIMMApp,
                        public CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx>
{
public:
    BEGIN_COM_MAP_IMMX(CActiveIMMAppEx)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppTrident4x, CActiveIMMAppEx)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppPostNT4, CActiveIMMAppEx)
        COM_INTERFACE_ENTRY(IActiveIMMApp)
        COM_INTERFACE_ENTRY_FUNC(IID_IActiveIMMAppEx, TRUE, CActiveIMMAppEx::EnableGuidMap)
        COM_INTERFACE_ENTRY(IActiveIMMMessagePumpOwner)
        COM_INTERFACE_ENTRY(IAImmThreadCompartment)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (IsOldAImm())
        {
            // aimm12 has some whacky CreateIntance rules to support trident
            return CActiveIMM_CreateInstance(pUnkOuter, riid, ppvObj);
        }
        else
        {
            return CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx>::CreateInstance(pUnkOuter, riid, ppvObj);
        }
    }

    static void PostCreateInstance(REFIID riid, void *pvObj)
    {
        imm32prev::CtfImmSetAppCompatFlags(IMECOMPAT_AIMM12);
    }

    static HRESULT WINAPI EnableGuidMap(void* pv, REFIID riid, LPVOID* ppv, DWORD dw)
    {
        if (IsEqualIID(riid, IID_IActiveIMMAppEx))
        {
            CActiveIMMAppEx* _pActiveIMM = (CActiveIMMAppEx*) pv;
            *ppv = SAFECAST(_pActiveIMM, IActiveIMMAppEx*);
            if (*ppv)
            {
                _pActiveIMM->AddRef();
                _pActiveIMM->_EnableGuidMap((BOOL)dw);
                return S_OK;
            }
            return E_NOINTERFACE;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
};

//+---------------------------------------------------------------------------
//
// CActiveIMMAppEx_Trident
//
//----------------------------------------------------------------------------

class CActiveIMMAppEx_Trident : public CComActiveIMMApp,
                                public CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx_Trident>
{
public:
    BEGIN_COM_MAP_IMMX(CActiveIMMAppEx_Trident)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppTrident4x, CActiveIMMAppEx_Trident)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppPostNT4, CActiveIMMAppEx_Trident)
        COM_INTERFACE_ENTRY(IActiveIMMApp)
        COM_INTERFACE_ENTRY(IActiveIMMAppEx)
        COM_INTERFACE_ENTRY(IActiveIMMMessagePumpOwner)
        COM_INTERFACE_ENTRY(IAImmThreadCompartment)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (IsOldAImm())
        {
            // aimm12 has some whacky CreateIntance rules to support trident
            return CActiveIMM_CreateInstance_Trident(pUnkOuter, riid, ppvObj);
        }
        else
        {
            return CComObjectRoot_CreateInstance_Verify<CActiveIMMAppEx_Trident>::CreateInstance(pUnkOuter, riid, ppvObj);
        }
    }

    static void PostCreateInstance(REFIID riid, void *pvObj)
    {
        imm32prev::CtfImmSetAppCompatFlags(IMECOMPAT_AIMM12_TRIDENT);
    }
};

#endif // _DIMMEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmwrp.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmwrp.cpp

Abstract:

    This file implements the CActiveIMMApp Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "dimmwrp.h"
#include "resource.h"
#include "cregkey.h"

//
// Check IE5.5 version
//
static BOOL g_fCachedIE = FALSE;
static BOOL g_fNewVerIE = FALSE;

#define IEVERSION55     0x00050032
#define IEVERSION6      0x00060000


//
// REGKEY
//
const TCHAR c_szMSIMTFKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\MSIMTF\\");

// REG_DWORD : 0     // No
//             1     // Only Trident (default)
//             2     // Always AIMM12
const TCHAR c_szUseAIMM12[] = TEXT("UseAIMM12");

// REG_MULTI_SZ
//    Known EXE module list for Trident aware applications.
const TCHAR c_szKnownEXE[] = TEXT("KnownEXE");

//+---------------------------------------------------------------------------
//
// Check registry to decice load AIMM1.2
//
//----------------------------------------------------------------------------

#define DIMM12_NO              0
#define DIMM12_TRIDENTONLY     1
#define DIMM12_ALWAYS          2

DWORD
IsAimm12Enable()
{
    CMyRegKey    Aimm12Reg;
    LONG       lRet;
    lRet = Aimm12Reg.Open(HKEY_LOCAL_MACHINE, c_szMSIMTFKey, KEY_READ);
    if (lRet == ERROR_SUCCESS) {
        DWORD dw;
        lRet = Aimm12Reg.QueryValue(dw, c_szUseAIMM12);
        if (lRet == ERROR_SUCCESS) {
            return dw;
        }
    }

    return DIMM12_TRIDENTONLY;
}

//+---------------------------------------------------------------------------
//
// Is this trident module
//
// We should distinguish what exe module calls CoCreateInstance( CLSID_CActiveIMM ).
// If caller is any 3rd party's or unknown modle,
// then we could not support AIMM 1.2 interface.
//
//----------------------------------------------------------------------------

BOOL
IsTridentModule()
{
    TCHAR szFileName[MAX_PATH + 1];
    if (::GetModuleFileName(NULL,            // handle to module
                            szFileName,      // file name of module
                            ARRAYSIZE(szFileName) - 1) == 0)
        return FALSE;

    szFileName[ARRAYSIZE(szFileName) - 1] = TEXT('\0');

    TCHAR  szModuleName[MAX_PATH + 1];
    LPTSTR pszFilePart = NULL;
    DWORD dwLen;
    dwLen = ::GetFullPathName(szFileName,            // file name
                              ARRAYSIZE(szModuleName) - 1,
                              szModuleName,          // path buffer
                              &pszFilePart);         // address of file name in path
    if (dwLen > ARRAYSIZE(szModuleName) - 1)
        return FALSE;

    if (pszFilePart == NULL)
        return FALSE;

    szModuleName[ARRAYSIZE(szModuleName) - 1] = TEXT('\0');

    //
    // Setup system defines module list from registry value.
    //
    int        len;

    CMyRegKey    Aimm12Reg;
    LONG       lRet;
    lRet = Aimm12Reg.Open(HKEY_LOCAL_MACHINE, c_szMSIMTFKey, KEY_READ);
    if (lRet == ERROR_SUCCESS) {
        TCHAR  szValue[MAX_PATH];

        lRet = Aimm12Reg.QueryValueCch(szValue, c_szKnownEXE, ARRAYSIZE(szValue));

        if (lRet == ERROR_SUCCESS) {
            LPTSTR psz = szValue;
            while (*psz) {
                len = lstrlen(psz);

                if (lstrcmpi(pszFilePart, psz) == 0) {
                    return TRUE;        // This is Trident module.
                }

                psz += len + 1;
            }
        }
    }

    //
    // Setup default module list from resource data (RCDATA)
    //
    LPTSTR  lpName = (LPTSTR) ID_KNOWN_EXE;

    HRSRC hRSrc = FindResourceEx(g_hInst, RT_RCDATA, lpName, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    if (hRSrc == NULL)
        return FALSE;

    HGLOBAL hMem = LoadResource(g_hInst, hRSrc);
    if (hMem == NULL)
        return FALSE;

    LPTSTR psz = (LPTSTR)LockResource(hMem);

    while (*psz) {
        len = lstrlen(psz);

        if (lstrcmpi(pszFilePart, psz) == 0) {
            return TRUE;        // This is Trident module.
        }

        psz += len + 1;
    }

    return FALSE;
}

BOOL
IsTridentNewVersion()
{
    BOOL fRet = FALSE;
    TCHAR  szMShtmlName[MAX_PATH + 1];

    if (g_fCachedIE)
    {
        return g_fNewVerIE;
    }

    //
    // Get "mshtml.dll" module from system directory and read version.
    //
    if (GetSystemDirectory(szMShtmlName, ARRAYSIZE(szMShtmlName) - 1))
    {
        UINT cb;
        void *pvData;
        DWORD dwVerHandle;
        VS_FIXEDFILEINFO *pffi;
        HRESULT hr;

        szMShtmlName[ARRAYSIZE(szMShtmlName) - 1] = TEXT('\0');
        hr = StringCchCat(szMShtmlName, ARRAYSIZE(szMShtmlName), TEXT("\\"));
        if (hr != S_OK)
            return FALSE;
        hr = StringCchCat(szMShtmlName, ARRAYSIZE(szMShtmlName), TEXT("mshtml.dll"));
        if (hr != S_OK)
            return FALSE;

        cb = GetFileVersionInfoSize(szMShtmlName, &dwVerHandle);

        if (cb == 0)
            return FALSE;

        if ((pvData = cicMemAlloc(cb)) == NULL)
            return FALSE;

        if (GetFileVersionInfo(szMShtmlName, 0, cb, pvData) &&
            VerQueryValue(pvData, TEXT("\\"), (void **)&pffi, &cb))
        {
            g_fCachedIE = TRUE;

            //fRet = g_fNewVerIE = (pffi->dwProductVersionMS >= IEVERSION55);
            if ((pffi->dwProductVersionMS >= IEVERSION55) &&
                (pffi->dwProductVersionMS <= IEVERSION6))
            {
                fRet = g_fNewVerIE = TRUE;
            }
            else
            {
                fRet = g_fNewVerIE = FALSE;
            }
        }
        else
        {
            fRet = FALSE;
        }

        cicMemFree(pvData);           
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// GetCompatibility
//
//----------------------------------------------------------------------------

VOID GetCompatibility(DWORD* dw, BOOL* fTrident, BOOL* _fTrident55)
{
    //
    // Retrieve AIMM1.2 Enable flag from REGKEY
    //
    *dw = IsAimm12Enable();

    //
    // Retrieve Trident aware application flag from REGKEY and RESOURCE.
    //
    *fTrident = IsTridentModule();

    //
    // Check Trident version with "mshtml.dll" module
    //
    *_fTrident55 = FALSE;

    if (*fTrident)
    {
        *_fTrident55 = IsTridentNewVersion();
    }
}

//+---------------------------------------------------------------------------
//
// VerifyCreateInstance
//
//----------------------------------------------------------------------------

BOOL CActiveIMMApp::VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    DWORD dw;
    BOOL  fTrident;
    BOOL  _fTrident55;
    GetCompatibility(&dw, &fTrident, &_fTrident55);

    if ( (dw == DIMM12_ALWAYS) ||
        ((dw == DIMM12_TRIDENTONLY) && fTrident))
    {
        //
        // CreateInstance AIMM1.2
        //
        return CComActiveIMMApp::VerifyCreateInstance(pUnkOuter, riid, ppvObj);
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// PostCreateInstance
//
//----------------------------------------------------------------------------

void CActiveIMMApp::PostCreateInstance(REFIID riid, void *pvObj)
{
    DWORD dw;
    BOOL  fTrident;
    BOOL  _fTrident55;
    GetCompatibility(&dw, &fTrident, &_fTrident55);

    imm32prev::CtfImmSetAppCompatFlags(IMECOMPAT_AIMM_LEGACY_CLSID | (_fTrident55 ? IMECOMPAT_AIMM_TRIDENT55 : 0));
}

#ifdef OLD_AIMM_ENABLED

//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance (Old AIMM1.2)
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM_CreateInstance_Legacy(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj)
{
    DWORD dw;
    BOOL  fTrident;
    BOOL  _fTrident55;
    GetCompatibility(&dw, &fTrident, &_fTrident55);

    if ( (dw == DIMM12_ALWAYS) ||
        ((dw == DIMM12_TRIDENTONLY) && fTrident))
    {
        //
        // CreateInstance AIMM1.2
        //
        g_fInLegacyClsid = TRUE;
        return CActiveIMM_CreateInstance(pUnkOuter, riid, ppvObj);
    }

    return E_NOINTERFACE;
}

#endif // OLD_AIMM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\delay.cpp ===
//
// delay.cpp
//
// Delay load imported functions for perf.
//

#include "private.h"
#include "ciccs.h"

extern CCicCriticalSectionStatic g_cs;

FARPROC GetFn(HINSTANCE *phInst, LPCTSTR pchLib, LPCSTR pchFunc)
{
    if (*phInst == 0)
    {
        EnterCriticalSection(g_cs);

        if (*phInst == 0)
        {
            *phInst = LoadSystemLibrary(pchLib);
        }

        LeaveCriticalSection(g_cs);

        if (*phInst == 0)
        {
            Assert(0);
            return NULL;
        }
    }

    return GetProcAddress(*phInst, pchFunc);
}

#define DELAYLOAD(_hInst, _DllName, _CallConv, _FuncName, _Args1, _Args2, _RetType, _ErrVal)   \
_RetType _CallConv _FuncName _Args1                                             \
{                                                                               \
    static FARPROC pfn = NULL;                                                  \
                                                                                \
    if (pfn == NULL || _hInst == NULL)                                          \
    {                                                                           \
        pfn = GetFn(&_hInst, _DllName, #_FuncName);                             \
                                                                                \
        if (pfn == NULL)                                                        \
        {                                                                       \
            Assert(0);                                                          \
            return (_RetType) _ErrVal;                                          \
        }                                                                       \
    }                                                                           \
                                                                                \
    return ((_RetType (_CallConv *)_Args1) (pfn)) _Args2;                       \
}


//
// imm32.dll
//
namespace imm32 {

    const TCHAR module_imm32[] = TEXT("imm32.dll");

#define IMM32LOAD(_FuncName, _Args1, _Args2, _RetType, _ErrVal) \
    DELAYLOAD(g_hImm32, module_imm32, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal)


    HINSTANCE g_hImm32 = 0;

    BOOL FreeLibrary()
    {
        BOOL ret = FALSE;
        if (g_hImm32 != NULL)
        {
            ret = ::FreeLibrary(g_hImm32);
            g_hImm32 = NULL;
        }
        return ret;
    }

    /*
     * IMM32 Input Context (hIMC) API Interface.
     */
    IMM32LOAD(ImmCreateContext, (void), (), HIMC, 0)
    IMM32LOAD(ImmDestroyContext, (HIMC hIMC), (hIMC), BOOL, FALSE)
    IMM32LOAD(ImmAssociateContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), HIMC, 0)
    IMM32LOAD(ImmAssociateContextEx, (HWND hWnd, HIMC hIMC, DWORD dwFlags), (hWnd, hIMC, dwFlags), BOOL, FALSE)
    IMM32LOAD(ImmGetContext, (HWND hWnd), (hWnd), HIMC, 0)
    IMM32LOAD(ImmReleaseContext, (HWND hWnd, HIMC hIMC), (hWnd, hIMC), BOOL, FALSE)
    IMM32LOAD(ImmGetIMCLockCount, (HIMC hIMC), (hIMC), DWORD, 0)
    IMM32LOAD(ImmUnlockIMC, (HIMC hIMC), (hIMC), BOOL, FALSE)
    IMM32LOAD(ImmLockIMC, (HIMC hIMC), (hIMC), LPINPUTCONTEXT, NULL)

    /*
     * IMM32 Input Context Components (hIMCC) API Interface.
     */
    IMM32LOAD(ImmCreateIMCC, (DWORD dw), (dw), HIMCC, FALSE)
    IMM32LOAD(ImmDestroyIMCC, (HIMCC hIMCC), (hIMCC), HIMCC, hIMCC)
    IMM32LOAD(ImmGetIMCCSize, (HIMCC hIMCC), (hIMCC), DWORD, 0)
    IMM32LOAD(ImmReSizeIMCC, (HIMCC hIMCC, DWORD dw), (hIMCC, dw), HIMCC, 0)
    IMM32LOAD(ImmGetIMCCLockCount, (HIMCC hIMCC), (hIMCC), DWORD, 0)
    IMM32LOAD(ImmUnlockIMCC, (HIMCC hIMCC), (hIMCC), BOOL, FALSE)
    IMM32LOAD(ImmLockIMCC, (HIMCC hIMCC), (hIMCC), LPVOID, NULL)

    /*
     * IMM32 Composition String API Interface
     */
    IMM32LOAD(ImmGetCompositionStringA, (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), LONG, 0);
    IMM32LOAD(ImmGetCompositionStringW, (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), LONG, 0);
    IMM32LOAD(ImmSetCompositionStringA, (HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen), (hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen), BOOL, FALSE);
    IMM32LOAD(ImmSetCompositionStringW, (HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen), (hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen), BOOL, FALSE);

    /*
     * IMM32 Composition Font API Interface
     */
    IMM32LOAD(ImmGetCompositionFontA, (HIMC hIMC, LPLOGFONTA lplf), (hIMC, lplf), BOOL, FALSE);
    IMM32LOAD(ImmGetCompositionFontW, (HIMC hIMC, LPLOGFONTW lplf), (hIMC, lplf), BOOL, FALSE);
    IMM32LOAD(ImmSetCompositionFontA, (HIMC hIMC, LPLOGFONTA lplf), (hIMC, lplf), BOOL, FALSE);
    IMM32LOAD(ImmSetCompositionFontW, (HIMC hIMC, LPLOGFONTW lplf), (hIMC, lplf), BOOL, FALSE);

    /*
     * IMM32 Open Status API Interface
     */
    IMM32LOAD(ImmGetOpenStatus, (HIMC hIMC), (hIMC), BOOL, FALSE)
    IMM32LOAD(ImmSetOpenStatus, (HIMC hIMC, BOOL f), (hIMC, f), BOOL, FALSE)

    /*
     * IMM32 Conversion Status API Interface
     */
    IMM32LOAD(ImmGetConversionStatus, (HIMC hIMC, LPDWORD pdw1, LPDWORD pdw2), (hIMC, pdw1, pdw2), BOOL, FALSE)
    IMM32LOAD(ImmSetConversionStatus, (HIMC hIMC, DWORD dw1, DWORD dw2), (hIMC, dw1, dw2), BOOL, FALSE)

    /*
     * IMM32 Status Window Pos API Interface
     */
    IMM32LOAD(ImmGetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE)
    IMM32LOAD(ImmSetStatusWindowPos, (HIMC hIMC, LPPOINT lpptPos), (hIMC, lpptPos), BOOL, FALSE)


    /*
     * IMM32 Composition Window API Interface
     */
    IMM32LOAD(ImmGetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM lpCompForm), (hIMC, lpCompForm), BOOL, FALSE)
    IMM32LOAD(ImmSetCompositionWindow, (HIMC hIMC, LPCOMPOSITIONFORM lpCompForm), (hIMC, lpCompForm), BOOL, FALSE);


    /*
     * IMM32 Candidate Window API Interface
     */
    IMM32LOAD(ImmGetCandidateWindow, (HIMC hIMC, DWORD dw, LPCANDIDATEFORM pCF), (hIMC, dw, pCF), BOOL, FALSE)
    IMM32LOAD(ImmSetCandidateWindow, (HIMC hIMC, LPCANDIDATEFORM pCF), (hIMC, pCF), BOOL, FALSE)
    IMM32LOAD(ImmGetCandidateListA, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0);
    IMM32LOAD(ImmGetCandidateListW, (HIMC hIMC, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen), (hIMC, dwIndex, lpCandList, dwBufLen), DWORD, 0);
    IMM32LOAD(ImmGetCandidateListCountA, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0);
    IMM32LOAD(ImmGetCandidateListCountW, (HIMC hIMC, LPDWORD lpdwListCount), (hIMC, lpdwListCount), DWORD, 0);

    /*
     * IMM32 Generate Message API Interface
     */
    IMM32LOAD(ImmGenerateMessage, (HIMC hIMC), (hIMC), BOOL, FALSE);

    /*
     * IMM32 Notify IME API Interface
     */
    IMM32LOAD(ImmNotifyIME, (HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue), (hIMC, dwAction, dwIndex, dwValue), BOOL, FALSE)

    /*
     * IMM32 Guide Line IME API Interface
     */
    IMM32LOAD(ImmGetGuideLineA, (HIMC hIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0);
    IMM32LOAD(ImmGetGuideLineW, (HIMC hIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen), (hIMC, dwIndex, lpBuf, dwBufLen), DWORD, 0);

    /*
     * IMM32 Menu items API Interface
     */
    IMM32LOAD(ImmGetImeMenuItemsA, (HIMC hIMC, DWORD dwFlags, DWORD dwType, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, lpImeParentMenu, lpImeMenu, dwSize), DWORD, 0);
    IMM32LOAD(ImmGetImeMenuItemsW, (HIMC hIMC, DWORD dwFlags, DWORD dwType, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize), (hIMC, dwFlags, dwType, lpImeParentMenu, lpImeMenu, dwSize), DWORD, 0);

    /*
     * IMM32 Default IME Window API Interface
     */
    IMM32LOAD(ImmGetDefaultIMEWnd, (HWND hWnd), (hWnd), HWND, 0);
    IMM32LOAD(ImmGetVirtualKey, (HWND hWnd), (hWnd), UINT, VK_PROCESSKEY);

    /*
     * IMM32 UI message API Interface
     */
    IMM32LOAD(ImmIsUIMessageA, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE);
    IMM32LOAD(ImmIsUIMessageW, (HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam), (hWnd, u, wParam, lParam), BOOL, FALSE);

    /*
     * IMM32 Simulate hotkey API Interface
     */
    IMM32LOAD(ImmSimulateHotKey, (HWND hWnd, DWORD dwHotKeyID), (hWnd, dwHotKeyID), BOOL, FALSE);
    IMM32LOAD(ImmGetHotKey, (DWORD dwHotKeyId, LPUINT lpuModifiers, LPUINT lpuVKey, LPHKL lphKL), (dwHotKeyId, lpuModifiers, lpuVKey, lphKL), BOOL, FALSE);
    IMM32LOAD(ImmSetHotKey, (DWORD dwHotKeyId, UINT uModifiers, UINT uVKey, HKL hKL), (dwHotKeyId, uModifiers, uVKey, hKL), BOOL, FALSE);

    /*
     * IMM32 Property API Interface
     */
    IMM32LOAD(ImmGetProperty, (HKL hKL, DWORD dw), (hKL, dw), DWORD, 0);

    /*
     * IMM32 Description API Interface
     */
    IMM32LOAD(ImmGetDescriptionA, (HKL hKL, LPSTR lpszDescription, UINT uBufLen), (hKL, lpszDescription, uBufLen), UINT, 0);
    IMM32LOAD(ImmGetDescriptionW, (HKL hKL, LPWSTR lpszDescription, UINT uBufLen), (hKL, lpszDescription, uBufLen), UINT, 0);
    IMM32LOAD(ImmGetIMEFileNameA, (HKL hKL, LPSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0);
    IMM32LOAD(ImmGetIMEFileNameW, (HKL hKL, LPWSTR lpszFileName, UINT uBufLen), (hKL, lpszFileName, uBufLen), UINT, 0);

    /*
     * IMM32 Conversion List API Interface
     */
    IMM32LOAD(ImmGetConversionListA, (HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0);
    IMM32LOAD(ImmGetConversionListW, (HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag), (hKL, hIMC, psz, pCL, dwBufLen, uFlag), DWORD, 0);

    /*
     * IMM32 IsIME API Interface
     */
    IMM32LOAD(ImmIsIME, (HKL hKL), (hKL), BOOL, FALSE);

    /*
     * IMM32 Escape API Interface
     */
    IMM32LOAD(ImmEscapeA, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0);
    IMM32LOAD(ImmEscapeW, (HKL hKL, HIMC hIMC, UINT u, LPVOID pv), (hKL, hIMC, u, pv), LRESULT, 0);

    /*
     * IMM32 Configure IME Interface
     */
    IMM32LOAD(ImmConfigureIMEA, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE);
    IMM32LOAD(ImmConfigureIMEW, (HKL hKL, HWND hWnd, DWORD dw, LPVOID pv), (hKL, hWnd, dw, pv), BOOL, FALSE);

    /*
     * IMM32 Register Word IME Interface
     */
    IMM32LOAD(ImmRegisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE);
    IMM32LOAD(ImmRegisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister), (hKL, lpszReading, dw, lpszRegister), BOOL, FALSE);
    IMM32LOAD(ImmUnregisterWordA, (HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE);
    IMM32LOAD(ImmUnregisterWordW, (HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister), (hKL, lpszReading, dw, lpszUnregister), BOOL, FALSE);
    IMM32LOAD(ImmGetRegisterWordStyleA, (HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0);
    IMM32LOAD(ImmGetRegisterWordStyleW, (HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf), (hKL, nItem, lpStyleBuf), UINT, 0);

    /*
     * IMM32 soft kbd API
     */
    IMM32LOAD(ImmCreateSoftKeyboard, (UINT uType, HWND hOwner, int x, int y), (uType, hOwner, x, y), HWND, NULL);
    IMM32LOAD(ImmDestroySoftKeyboard, (HWND hSoftKbdWnd), (hSoftKbdWnd), BOOL, FALSE);
    IMM32LOAD(ImmShowSoftKeyboard, (HWND hSoftKbdWnd, int nCmdShow), (hSoftKbdWnd, nCmdShow), BOOL, FALSE);

    /*
     * IMM32 Enumurate Input Context API
     */
    IMM32LOAD(ImmEnumInputContext, (DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam), (idThread, lpfn, lParam), BOOL, FALSE);

    /*
     * IMM32 win98/nt5 apis
     */
    IMM32LOAD(ImmDisableIME, (DWORD dwId), (dwId), BOOL, FALSE);

    IMM32LOAD(ImmRequestMessageA, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0);
    IMM32LOAD(ImmRequestMessageW, (HIMC hIMC, WPARAM wParam, LPARAM lParam), (hIMC, wParam, lParam), LRESULT, 0);

    IMM32LOAD(ImmInstallIMEA, (LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText), (lpszIMEFileName, lpszLayoutText), HKL, 0);
    IMM32LOAD(ImmInstallIMEW, (LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText), (lpszIMEFileName, lpszLayoutText), HKL, 0);
}



//
// imm32.dll
//
namespace imm32prev {

    const TCHAR module_imm32[] = TEXT("imm32.dll");

#define IMM32LOAD(_FuncName, _Args1, _Args2, _RetType, _ErrVal) \
    DELAYLOAD(g_hImm32, module_imm32, WINAPI, _FuncName, _Args1, _Args2, _RetType, _ErrVal)


    HINSTANCE g_hImm32 = 0;

    BOOL FreeLibrary()
    {
        BOOL ret = FALSE;
        if (g_hImm32 != NULL)
        {
            ret = ::FreeLibrary(g_hImm32);
            g_hImm32 = NULL;
        }
        return ret;
    }


    IMM32LOAD(CtfImmGetGuidAtom, (HIMC hIMC, BYTE bAttr, DWORD* pGuidAtom), (hIMC, bAttr, pGuidAtom), HRESULT, S_OK);
    IMM32LOAD(CtfImmIsGuidMapEnable, (HIMC hIMC), (hIMC), BOOL, FALSE);
    IMM32LOAD(CtfImmIsCiceroEnabled, (VOID), (), BOOL, FALSE);
    IMM32LOAD(CtfImmIsCiceroStartedInThread, (VOID), (), BOOL, FALSE);
    IMM32LOAD(CtfImmSetCiceroStartInThread, (BOOL fSet), (fSet), HRESULT, S_OK);
    IMM32LOAD(GetKeyboardLayoutCP, (HKL hKL), (hKL), UINT, 0);
    IMM32LOAD(ImmGetAppCompatFlags, (HIMC hIMC), (hIMC), DWORD, 0);
    IMM32LOAD(CtfImmSetAppCompatFlags, (DWORD dwFlag), (dwFlag), VOID, NULL);
    IMM32LOAD(CtfAImmActivate, (HMODULE* phMod), (phMod), HRESULT, E_FAIL);
    IMM32LOAD(CtfAImmDeactivate, (HMODULE hMod), (hMod), HRESULT, E_FAIL);
    IMM32LOAD(CtfAImmIsIME, (HKL hkl), (hkl), BOOL, FALSE);
}


//
// version.dll
//
const TCHAR module_version[] = TEXT("version.dll");

HINSTANCE g_hVersion = 0;


DELAYLOAD(g_hVersion, module_version, WINAPI, GetFileVersionInfoSizeA, (LPTSTR pszFileName, LPDWORD pdwHandle), (pszFileName, pdwHandle), DWORD, 0);
DELAYLOAD(g_hVersion, module_version, WINAPI, GetFileVersionInfoA, (LPTSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData), (lptstrFilename, dwHandle, dwLen, lpData), BOOL, FALSE);
DELAYLOAD(g_hVersion, module_version, WINAPI, VerQueryValueA, (const LPVOID pBlock, LPTSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen), (pBlock, lpSubBlock, lplpBuffer, puLen), BOOL, FALSE);

//
// msctf.dll
//
const TCHAR module_msctf[] = TEXT("msctf.dll");

HINSTANCE g_hCTF = 0;

DELAYLOAD(g_hCTF, module_msctf, WINAPI, TF_CreateLangBarMgr, (ITfLangBarMgr **pplbm), (pplbm), HRESULT, E_FAIL);

//
// ole32.dll
//
HINSTANCE g_hOle32 = 0;

HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoCreateInstance");

        if (pfn == NULL)
        {
            Assert(0);
            if (ppv != NULL)
            {
                *ppv = NULL;
            }
            return E_FAIL;
        }
    }

    return ((HRESULT (STDAPICALLTYPE *)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv))(pfn))(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoTaskMemAlloc");

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(ULONG cb))(pfn))(cb);
}

LPVOID STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoTaskMemRealloc");

        if (pfn == NULL)
        {
            Assert(0);
            return NULL;
        }
    }

    return ((LPVOID (STDAPICALLTYPE *)(LPVOID pv, ULONG cb))(pfn))(pv, cb);
}

void STDAPICALLTYPE Internal_CoTaskMemFree(void* pv)
{
    static FARPROC pfn = NULL;

    if (pfn == NULL || g_hOle32 == NULL)
    {
        pfn = GetFn(&g_hOle32, TEXT("ole32.dll"), "CoTaskMemFree");

        if (pfn == NULL)
        {
            Assert(0);
            return;
        }
    }

    ((void (STDAPICALLTYPE *)(void* pv))(pfn))(pv);
}



//
// cleanup -- called from process detach
//

void UninitDelayLoadLibraries()
{
    EnterCriticalSection(g_cs);

    imm32::FreeLibrary();
    imm32prev::FreeLibrary();


    if (g_hVersion != 0)
    {
        FreeLibrary(g_hVersion);
        g_hVersion = NULL;
    }

    if (g_hCTF != 0)
    {
        FreeLibrary(g_hCTF);
        g_hCTF = NULL;
    }

    if (g_hOle32 != 0)
    {
        FreeLibrary(g_hOle32);
        g_hOle32 = NULL;
    }

    LeaveCriticalSection(g_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\delay.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    delay.h

Abstract:

    This file defines the IMM32 Namespace.

Author:

Revision History:

Notes:

--*/

#ifndef _DELAY_H_
#define _DELAY_H_

namespace imm32 {
    BOOL FreeLibrary(VOID);

    /*
     * IMM32 Input Context (hIMC) API Interface.
     */
    HIMC WINAPI ImmCreateContext(void);
    BOOL WINAPI ImmDestroyContext(IN HIMC);
    HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
    BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
    HIMC WINAPI ImmGetContext(IN HWND);
    BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
    DWORD WINAPI ImmGetIMCLockCount(IN HIMC);
    LPINPUTCONTEXT WINAPI ImmLockIMC(IN HIMC);
    BOOL  WINAPI ImmUnlockIMC(IN HIMC);

    /*
     * IMM32 Input Context Components (hIMCC) API Interface.
     */
    HIMCC  WINAPI ImmCreateIMCC(IN DWORD);
    HIMCC  WINAPI ImmDestroyIMCC(IN HIMCC);
    DWORD  WINAPI ImmGetIMCCSize(IN HIMCC);
    HIMCC  WINAPI ImmReSizeIMCC(IN HIMCC, IN DWORD);
    DWORD  WINAPI ImmGetIMCCLockCount(IN HIMCC);
    LPVOID WINAPI ImmLockIMCC(IN HIMCC);
    BOOL   WINAPI ImmUnlockIMCC(IN HIMCC);

    /*
     * IMM32 Composition String API Interface
     */
    LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);

    /*
     * IMM32 Composition Font API Interface
     */
    BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
    BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
    BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
    BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);

    /*
     * IMM32 Open Status API Interface
     */
    BOOL WINAPI ImmGetOpenStatus(IN HIMC);
    BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

    /*
     * IMM32 Conversion Status API Interface
     */
    BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
    BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);

    /*
     * IMM32 Status Window Pos API Interface
     */
    BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
    BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);


    /*
     * IMM32 Composition Window API Interface
     */
    BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
    BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);

    /*
     * IMM32 Candidate API Interface
     */
    BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
    BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);
    DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
    DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);

    /*
     * IMM32 Generate Message API Interface
     */
    BOOL WINAPI ImmGenerateMessage(IN HIMC);

    /*
     * IMM32 Notify IME API Interface
     */
    BOOL WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

    /*
     * IMM32 Guide Line IME API Interface
     */
    DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);

    /*
     * IMM32 Menu items API Interface
     */
    DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
    DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);

    /*
     * IMM32 Default IME Window API Interface
     */
    HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);
    UINT WINAPI ImmGetVirtualKey(IN HWND);

    /*
     * IMM32 UI message API Interface
     */
    BOOL WINAPI ImmIsUIMessageA(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);
    BOOL WINAPI ImmIsUIMessageW(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);

    /*
     * IMM32 Simulate hotkey API Interface
     */
    BOOL WINAPI ImmSimulateHotKey(HWND hWnd, DWORD dwHotKeyID);
    BOOL WINAPI ImmGetHotKey(DWORD dwHotKeyId, LPUINT lpuModifiers, LPUINT lpuVKey, LPHKL lphKL);
    BOOL WINAPI ImmSetHotKey(DWORD dwHotKeyId, UINT uModifiers, UINT uVKey, HKL hKL);

    /*
     * IMM32 Property API Interface
     */
    DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

    /*
     * IMM32 Description API Interface
     */
    UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameA(HKL hKL, LPSTR lpszFileName, UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameW(HKL hKL, LPWSTR lpszFileName, UINT uBufLen);

    /*
     * IMM32 Conversion List API Interface
     */
    DWORD WINAPI ImmGetConversionListA(HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);
    DWORD WINAPI ImmGetConversionListW(HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);

    /*
     * IMM32 IsIME API Interface
     */
    BOOL WINAPI ImmIsIME(HKL hKL);

    /*
     * IMM32 Escape API Interface
     */
    LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
    LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);

    /*
     * IMM32 Configure IME Interface
     */
    BOOL WINAPI ImmConfigureIMEA(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
    BOOL WINAPI ImmConfigureIMEW(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);

    /*
     * IMM32 Register Word IME Interface
     */
    BOOL WINAPI ImmRegisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister);
    BOOL WINAPI ImmRegisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister);
    BOOL WINAPI ImmUnregisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister);
    BOOL WINAPI ImmUnregisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister);
    UINT WINAPI ImmGetRegisterWordStyleA(HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
    UINT WINAPI ImmGetRegisterWordStyleW(HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);

    /*
     * IMM32 soft kbd API
     */
    HWND WINAPI ImmCreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y);
    BOOL WINAPI ImmDestroySoftKeyboard(HWND hSoftKbdWnd);
    BOOL WINAPI ImmShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    /*
     * IMM32 Enumurate Input Context API
     */
    BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

    /*
     * IMM32 win98/nt5 apis
     */
    BOOL WINAPI ImmDisableIME(DWORD dwId);

    LRESULT WINAPI ImmRequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam);
    LRESULT WINAPI ImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam);

    HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
    HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
}

namespace imm32prev {
    BOOL FreeLibrary(VOID);

    /*
     * IMM32 Private functions.
     */
    HRESULT WINAPI CtfImmGetGuidAtom(IN HIMC hIMC, IN BYTE bAttr, OUT DWORD* pGuidAtom);
    BOOL    WINAPI CtfImmIsGuidMapEnable(IN HIMC hIMC);
    BOOL    WINAPI CtfImmIsCiceroEnabled(VOID);
    BOOL    WINAPI CtfImmIsCiceroStartedInThread(VOID);
    HRESULT WINAPI CtfImmSetCiceroStartInThread(IN BOOL fSet);
    UINT    WINAPI GetKeyboardLayoutCP(IN HKL hKL);
    DWORD   WINAPI ImmGetAppCompatFlags(IN HIMC hIMC);
    VOID    WINAPI CtfImmSetAppCompatFlags(IN DWORD dwFlag);
    HRESULT WINAPI CtfAImmActivate(HMODULE* phMod);
    HRESULT WINAPI CtfAImmDeactivate(HMODULE hMod);
    BOOL    WINAPI CtfAImmIsIME(HKL hkl);
}

//
// ole32
//
HRESULT STDAPICALLTYPE Internal_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv);
#define CoCreateInstance Internal_CoCreateInstance

LPVOID  STDAPICALLTYPE Internal_CoTaskMemAlloc(ULONG cb);
#define CoTaskMemAlloc   Internal_CoTaskMemAlloc

LPVOID  STDAPICALLTYPE Internal_CoTaskMemRealloc(LPVOID pv, ULONG cb);
#define CoTaskMemRealloc Internal_CoTaskMemRealloc

void    STDAPICALLTYPE Internal_CoTaskMemFree(void* pv);
#define CoTaskMemFree    Internal_CoTaskMemFree

#endif // _DELAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmwrp.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmwrp.h

Abstract:

    This file defines the CActiveIMMApp Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _DIMMWRP_H_
#define _DIMMWRP_H_

#include "resource.h"
#include "dimmex.h"

//+---------------------------------------------------------------------------
//
// CActiveIMMApp
//
//----------------------------------------------------------------------------

class CActiveIMMApp : public CComActiveIMMApp,
                      public CComObjectRoot_CreateInstance_Verify<CActiveIMMApp>
{
public:
    BEGIN_COM_MAP_IMMX(CActiveIMMApp)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppTrident4x, CActiveIMMApp)
        COM_INTERFACE_ENTRY_IID(IID_IActiveIMMAppPostNT4, CActiveIMMApp)
        COM_INTERFACE_ENTRY(IActiveIMMApp)
        COM_INTERFACE_ENTRY(IActiveIMMMessagePumpOwner)
        COM_INTERFACE_ENTRY(IAImmThreadCompartment)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP_IMMX()

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (IsOldAImm())
        {
            // aimm12 has some whacky CreateIntance rules to support trident
            return CActiveIMM_CreateInstance_Legacy(pUnkOuter, riid, ppvObj);
        }
        else
        {
            return CComObjectRoot_CreateInstance_Verify<CActiveIMMApp>::CreateInstance(pUnkOuter, riid, ppvObj);
        }
    }

    static BOOL VerifyCreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    static void PostCreateInstance(REFIID riid, void *pvObj);
};

#endif // _DIMMWRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dimmex.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dimmex.cpp

Abstract:

    This file implements the CActiveIMMAppEx Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "msctfp.h"
#include "dimmex.h"
#include "list.h"
#include "atom.h"
#include "globals.h"
#include "tls.h"
#include "apcompat.h"

//+---------------------------------------------------------------------------
//
// CGuidMapList
//    Allocated by Global data object !!
//
//----------------------------------------------------------------------------

CGuidMapList      *g_pGuidMapList = NULL;

BOOL InitFilterList()
{
    BOOL bRet;
    EnterCriticalSection(g_cs);

    if (!g_pGuidMapList)
        g_pGuidMapList = new CGuidMapList;

    bRet = g_pGuidMapList ? TRUE : FALSE;
    LeaveCriticalSection(g_cs);

    return bRet;
}

void UninitFilterList()
{
    //
    // this function is called in DllMain(). Don't need to be protected by
    // g_cs.
    //
    // EnterCriticalSection(g_cs);

    if (g_pGuidMapList)
        delete g_pGuidMapList;

    g_pGuidMapList = NULL;

    // LeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// CAtomObject
//    Allocated by Global data object !!
//
//----------------------------------------------------------------------------

CAtomObject       *g_pAimmAtomObject = NULL;

BOOL InitAimmAtom()
{
    BOOL bRet;
    EnterCriticalSection(g_cs);

    if (! FindAtom(TF_ENABLE_PROCESS_ATOM)) {
        //
        // This process is not WinWord XP nor Cicero aware application
        //
        bRet = FALSE;
    }
    else {
        if (!g_pAimmAtomObject) {
            g_pAimmAtomObject = new CAtomObject();
            if (g_pAimmAtomObject) {
                if (g_pAimmAtomObject->_InitAtom(AIMM12_PROCESS_ATOM) != S_OK) {
                    delete g_pAimmAtomObject;
                    g_pAimmAtomObject = NULL;
                }
            }
        }
        bRet = g_pAimmAtomObject ? TRUE : FALSE;
    }

    LeaveCriticalSection(g_cs);

    return bRet;
}

void UninitAimmAtom()
{
    //
    // this function is called in DllMain(). Don't need to be protected by
    // g_cs.
    //
    // EnterCriticalSection(g_cs);

    if (g_pAimmAtomObject)
        delete g_pAimmAtomObject;

    g_pAimmAtomObject = NULL;

    // LeaveCriticalSection(g_cs);
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------


STDAPI CComActiveIMMApp::Activate(BOOL fRestoreLayout)
{
    HRESULT hr = S_OK;

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (! InitAimmAtom()) {
        if (! FindAtom(AIMM12_PROCESS_ATOM))
            AddAtom(AIMM12_PROCESS_ATOM);
    }
    else {
        g_pAimmAtomObject->_Activate();      // Activate AIMM12 atom
    }

    int cnt = ptls->IncrementAIMMRefCnt();

    #ifndef KACF_DISABLECICERO
    #define KACF_DISABLECICERO 0x00000100    // If set. Cicero support for the current process
                                             // is disabled.
    #endif

    if (! IsOldAImm() && ! IsCUAS_ON() && ! APPCOMPATFLAG(KACF_DISABLECICERO) && cnt == 1)
    {
        hr = imm32prev::CtfAImmActivate(&m_hModCtfIme);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::Deactivate()
{
    HRESULT hr = S_OK;

    TLS* ptls = TLS::GetTLS();
    if (ptls == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (InitAimmAtom()) {
        g_pAimmAtomObject->_Deactivate();    // Deactivate AIMM12 atom
    }

    int cnt = ptls->DecrementAIMMRefCnt();

    if (! IsOldAImm() && ! IsCUAS_ON() && ! APPCOMPATFLAG(KACF_DISABLECICERO) && cnt == 0)
    {
        hr = imm32prev::CtfAImmDeactivate(m_hModCtfIme);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// FilterClientWindows
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::FilterClientWindows(ATOM *aaWindowClasses, UINT uSize)
{
    return FilterClientWindowsGUIDMap(aaWindowClasses, uSize, NULL);
}

STDAPI CComActiveIMMApp::FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap)
{
    if (!InitFilterList())
        return E_OUTOFMEMORY;

    return g_pGuidMapList->_Update(aaWindowClasses, uSize, aaGuidMap);
}

//+---------------------------------------------------------------------------
//
// FilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap)
{
    if (!InitFilterList())
        return E_OUTOFMEMORY;

    return g_pGuidMapList->_Update(hWnd, fGuidMap);

}

//+---------------------------------------------------------------------------
//
// UnfilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::UnfilterClientWindowsEx(HWND hWnd)
{
    if (!InitFilterList())
        return E_OUTOFMEMORY;

    return g_pGuidMapList->_Remove(hWnd);
}

//+---------------------------------------------------------------------------
//
// GetGuidAtom
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom)
{
    return imm32prev::CtfImmGetGuidAtom(hImc, bAttr, pGuidAtom);
}

//+---------------------------------------------------------------------------
//
// GetCodePageA
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetCodePageA(HKL hKL, UINT *puCodePage)
{
    if (puCodePage == NULL)
        return E_INVALIDARG;

    TraceMsg(TF_FUNC, "CComActiveIMMApp::GetCodePageA");

    *puCodePage = imm32prev::GetKeyboardLayoutCP(hKL);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetLangId
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetLangId(HKL hKL, LANGID *plid)
{
    if (plid == NULL)
        return E_INVALIDARG;

    TraceMsg(TF_FUNC, "CComActiveIMMApp::GetLangId");

    *plid = LOWORD(HandleToUlong(hKL));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::QueryService( 
    REFGUID guidService,
    REFIID riid,
    void **ppv
    )
{
    ITfThreadMgr *ptim = NULL;
    ITfDocumentMgr *pdim = NULL;
    ITfContext *pic = NULL;
    HRESULT hr = E_NOINTERFACE;

    if (ppv == NULL) {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF))
        return E_INVALIDARG;

    if (FAILED(TF_CreateThreadMgr(&ptim)))
        return E_FAIL;

    if (!ptim)
        return E_FAIL;

    if (IsEqualIID(riid, IID_ITfThreadMgr)) {
        *ppv = SAFECAST(ptim, ITfThreadMgr*);
        ptim->AddRef();
        hr = S_OK;
    }
    else {

        if (FAILED(ptim->GetFocus(&pdim)))
            pdim = NULL;

        if (IsEqualIID(riid, IID_ITfDocumentMgr)) {
            if (pdim) {
                *ppv = SAFECAST(pdim, ITfDocumentMgr*);
                pdim->AddRef();
                hr = S_OK;
            }
        }
        else if (IsEqualIID(riid, IID_ITfContext)) {
            if (pdim) {
                if (SUCCEEDED(pdim->GetTop(&pic)) && pic) {
                    *ppv = SAFECAST(pic, ITfContext*);
                    pic->AddRef();
                    hr = S_OK;
                }
            }
        }
    }

    if (ptim)
        ptim->Release();

    if (pdim)
        pdim->Release();

    if (pic)
        pic->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
// SetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::SetThreadCompartmentValue(
    REFGUID rguid,
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;

    ITfThreadMgr *ptim = NULL;
    HRESULT hr = E_FAIL;

    if (FAILED(TF_CreateThreadMgr(&ptim)))
        return hr;

    if (ptim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)ptim, rguid, &pComp)))
        {
            //
            // Hack to get App Client Id.
            //
            TfClientId tid;
            ptim->Activate(&tid);
            ptim->Deactivate();

            hr = pComp->SetValue(tid, pvar);
            pComp->Release();
        }
        ptim->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// GetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::GetThreadCompartmentValue(
    REFGUID rguid,
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    ITfThreadMgr *ptim = NULL;

    if (FAILED(TF_CreateThreadMgr(&ptim)))
        return hr;

    QuickVariantInit(pvar);

    if (ptim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)ptim, rguid, &pComp)))
        {
            hr = pComp->GetValue(pvar);
            pComp->Release();
        }
        ptim->Release();
    }

    return hr;

}

//+---------------------------------------------------------------------------
//
// OnDefWindowProc
//
//----------------------------------------------------------------------------

STDAPI CComActiveIMMApp::OnDefWindowProc(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    *plResult = 0;

    BOOL fUnicode = IsWindowUnicode(hWnd);
    HRESULT hr = S_FALSE;   // returns S_FALSE, DefWindowProc should be called.

    //
    // RE4.0 won't call DefWindowProc even returns S_FALSE.
    // This code recover some IME message as same old AIMM code (dimm\aime_wnd.cpp)
    //
    switch (Msg)
    {
        case WM_IME_KEYDOWN:
        case WM_IME_KEYUP:
        case WM_IME_CHAR:
        case WM_IME_COMPOSITION:
        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
        case WM_IME_NOTIFY:
        case WM_IME_SETCONTEXT:
            if (fUnicode)
            {
                *plResult = ::DefWindowProcW(hWnd, Msg, wParam, lParam);
            }
            else
            {
                *plResult = ::DefWindowProcA(hWnd, Msg, wParam, lParam);
            }
            hr = S_OK;
            break;

        case WM_IME_REQUEST:
            switch (wParam)
            {
                case IMR_QUERYCHARPOSITION:
                    if (fUnicode)
                    {
                        *plResult = ::DefWindowProcW(hWnd, Msg, wParam, lParam);
                    }
                    else
                    {
                        *plResult = ::DefWindowProcA(hWnd, Msg, wParam, lParam);
                    }
                    hr = S_OK;
                    break;
            }
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\dllmain.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    dllmain.cpp

Abstract:

    This file implements the DLL MAIN.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "globals.h"
#include "dimmex.h"
#include "dimmwrp.h"
#include "oldaimm.h"
#include "tls.h"

DECLARE_OSVER()

//+---------------------------------------------------------------------------
//
// ProcessAttach
//
//----------------------------------------------------------------------------

BOOL ProcessAttach(HINSTANCE hInstance)
{
    CcshellGetDebugFlags();

    g_hInst = hInstance;

    if (!g_cs.Init())
       return FALSE;

    Dbg_MemInit(TEXT("MSIMTF"), NULL);

    InitOSVer();

#ifdef OLD_AIMM_ENABLED
    //
    // Might be required by some library function, so let's initialize
    // it as the first thing.
    //
    TFInitLib_PrivateForCiceroOnly(Internal_CoCreateInstance);
#endif // OLD_AIMM_ENABLED

    if (IsOldAImm())
    {
        return OldAImm_DllProcessAttach(hInstance);
    }
    else
    {
        TLS::Initialize();
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// ProcessDettach
//
//----------------------------------------------------------------------------

void ProcessDettach(HINSTANCE hInstance)
{
#ifdef OLD_AIMM_ENABLED
    TFUninitLib();
#endif // OLD_AIMM_ENABLED

    if (! IsOldAImm())
    {
        UninitFilterList();
        UninitAimmAtom();
    }

    if (IsOldAImm())
    {
        OldAImm_DllProcessDetach();
    }
    else
    {
        TLS::DestroyTLS();
        TLS::Uninitialize();
    }

    Dbg_MemUninit();

    g_cs.Delete();
}

//+---------------------------------------------------------------------------
//
// DllMain
//
//----------------------------------------------------------------------------

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Now real DllEntry point is _DllMainCRTStartup.
            // _DllMainCRTStartup does not call our DllMain(DLL_PROCESS_DETACH)
            // if our DllMain(DLL_PROCESS_ATTACH) fails.
            // So we have to clean this up.
            //
            if (!ProcessAttach(hInstance))
            {
                ProcessDettach(hInstance);
                return FALSE;
            }
            break;

        case DLL_THREAD_ATTACH:
            if (IsOldAImm())
            {
                return OldAImm_DllThreadAttach();
            }
            break;

        case DLL_THREAD_DETACH:
            if (IsOldAImm())
            {
                OldAImm_DllThreadDetach();
            }
            else
            {
                TLS::DestroyTLS();
            }
            break;

        case DLL_PROCESS_DETACH:
            ProcessDettach(hInstance);
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\globals.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This file defines the global data.

Author:

Revision History:

Notes:

--*/


#ifndef _GLOBAL_H_
#define _GLOBAL_H_


#include "ciccs.h"

UINT GetCodePageFromLangId(LCID lcid);
HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp);

#if !defined(OLD_AIMM_ENABLED)
BOOL RunningInExcludedModule();
#endif // OLD_AIMM_ENABLED

extern CCicCriticalSectionStatic g_cs;

extern HINSTANCE g_hInst;

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\makefile.inc ===
imm.h : $(OAK_INC_PATH)\immdev.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\list.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.cpp

Abstract:

    This file implements the CGuidMapList class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "list.h"
#include "globals.h"
#include "delay.h"

//+---------------------------------------------------------------------------
//
// CGuidMapList
//
//----------------------------------------------------------------------------

HRESULT
CGuidMapList::_Update(
    ATOM *aaWindowClasses,
    UINT uSize,
    BOOL *aaGuidMap)
{
    if (aaWindowClasses == NULL && uSize > 0)
        return E_INVALIDARG;

    EnterCriticalSection(g_cs);

    while (uSize--) {
        GUID_MAP_CLIENT filter;
        filter.fGuidMap =  aaGuidMap != NULL ? *aaGuidMap++ : FALSE;
        m_ClassFilterList.SetAt(*aaWindowClasses++, filter);
    }

    LeaveCriticalSection(g_cs);
    return S_OK;
}

HRESULT
CGuidMapList::_Update(
    HWND hWnd,
    BOOL fGuidMap)
{
    EnterCriticalSection(g_cs);

    GUID_MAP_CLIENT filter;
    filter.fGuidMap = fGuidMap;

    m_WndFilterList.SetAt(hWnd, filter);

    LeaveCriticalSection(g_cs);
    return S_OK;
}

HRESULT
CGuidMapList::_Remove(
    HWND hWnd)
{
    EnterCriticalSection(g_cs);

    m_WndFilterList.RemoveKey(hWnd);

    LeaveCriticalSection(g_cs);
    return S_OK;
}

BOOL
CGuidMapList::_IsGuidMapEnable(
    HIMC hIMC,
    BOOL *pbGuidMap)
{
    BOOL fRet = FALSE;

    INPUTCONTEXT* imc = imm32::ImmLockIMC(hIMC);
    if (imc == NULL)
    {
        return fRet;
    }

    EnterCriticalSection(g_cs);

    GUID_MAP_CLIENT filter = { 0 };

    BOOL bGuidMap = FALSE;

    fRet = m_WndFilterList.Lookup(imc->hWnd, filter);
    if (fRet)
    {
        bGuidMap = filter.fGuidMap;
    }
    else
    {
        ATOM aClass = (ATOM)GetClassLong(imc->hWnd, GCW_ATOM);
        fRet = m_ClassFilterList.Lookup(aClass, filter);
        if (fRet)
        {
            bGuidMap = filter.fGuidMap;
        }
    }

    LeaveCriticalSection(g_cs);

    if (pbGuidMap)
        *pbGuidMap = bGuidMap;

    imm32::ImmUnlockIMC(hIMC);

    return fRet;
}

BOOL
CGuidMapList::_IsWindowFiltered(
    HWND hWnd)
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    GUID_MAP_CLIENT filter = { 0 };


    fRet = m_WndFilterList.Lookup(hWnd, filter);
    if (!fRet)
    {
        ATOM aClass = (ATOM)GetClassLong(hWnd, GCW_ATOM);
        fRet = m_ClassFilterList.Lookup(aClass, filter);
    }

    LeaveCriticalSection(g_cs);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\list.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.h

Abstract:

    This file defines the CGuidMapList Class.

Author:

Revision History:

Notes:

--*/


#ifndef LIST_H
#define LIST_H

#include "template.h"

/////////////////////////////////////////////////////////////////////////////
// CGuidMapList

class CGuidMapList
{
public:
    CGuidMapList() { }
    virtual ~CGuidMapList() { }

    HRESULT _Update(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);
    HRESULT _Update(HWND hWnd, BOOL fGuidMap);
    HRESULT _Remove(HWND hWnd);

    BOOL _IsGuidMapEnable(HIMC hIMC, BOOL *pbGuidMap);
    BOOL _IsWindowFiltered(HWND hWnd);

private:
    typedef struct {
        BOOL fGuidMap : 1;
    } GUID_MAP_CLIENT;

    CMap<ATOM,                     // class KEY
         ATOM,                     // class ARG_KEY
         GUID_MAP_CLIENT,          // class VALUE
         GUID_MAP_CLIENT           // class ARG_VALUE
        > m_ClassFilterList;

    CMap<HWND,                     // class KEY
         HWND,                     // class ARG_KEY
         GUID_MAP_CLIENT,          // class VALUE
         GUID_MAP_CLIENT           // class ARG_VALUE
        > m_WndFilterList;
};

#endif // LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\oldaimm.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    oldaimm.cpp

Abstract:

    This file implements the old AIMM Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "oldaimm.h"
#include "delay.h"
#include "cregkey.h"
#include "globals.h"

#ifdef OLD_AIMM_ENABLED

#include "imtls.h"

DWORD g_dwTLSIndex = -1;
BOOL  g_fInLegacyClsid = FALSE;
BOOL  g_fTrident55 = FALSE;
BOOL  g_fAIMM12Trident = FALSE;

typedef enum
{
    CUAS_UNKNOWN = -1,
    CUAS_OFF     = 0,
    CUAS_ON      = 1
} CUAS_SWITCH;

CUAS_SWITCH g_fCUAS = CUAS_UNKNOWN;

//+---------------------------------------------------------------------------
//
// IsCTFIMEEnabled
//
//----------------------------------------------------------------------------

BOOL IsCTFIMEEnabled()
{
    return imm32prev::CtfImmIsCiceroEnabled();
}

//+---------------------------------------------------------------------------
//
// IsOldAImm
//
//----------------------------------------------------------------------------

BOOL IsOldAImm()
{
    if (! GetSystemMetrics( SM_IMMENABLED ))
        return TRUE;

    if (! IsCTFIMEEnabled())
        return TRUE;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// IsCUAS_ON
//
//----------------------------------------------------------------------------

BOOL IsCUAS_ON()
{
    //
    // REGKEY
    //
    const TCHAR c_szCTFSharedKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\SystemShared");

    // REG_DWORD : 0     // No
    //             1     // Yes
    const TCHAR c_szCUAS[] = TEXT("CUAS");

    if (g_fCUAS == CUAS_UNKNOWN)
    {
        CMyRegKey    CtfReg;
        LONG       lRet;
        lRet = CtfReg.Open(HKEY_LOCAL_MACHINE, c_szCTFSharedKey, KEY_READ);
        if (lRet == ERROR_SUCCESS) {
            DWORD dw;
            lRet = CtfReg.QueryValue(dw, c_szCUAS);
            if (lRet == ERROR_SUCCESS) {
                g_fCUAS = (dw == 0 ? CUAS_OFF : CUAS_ON);
            }
        }
    }

    return g_fCUAS == CUAS_ON ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// OldAImm_DllProcessAttach
//
//----------------------------------------------------------------------------

BOOL OldAImm_DllProcessAttach(HINSTANCE hInstance)
{
    g_hInst = hInstance;

    g_dwTLSIndex = TlsAlloc();

    if (!DIMM12_DllProcessAttach())
        return FALSE;

    if (!WIN32LR_DllProcessAttach())
        return FALSE;

    return TRUE;
}

BOOL OldAImm_DllThreadAttach()
{
    WIN32LR_DllThreadAttach();
    return TRUE;
}

VOID OldAImm_DllThreadDetach()
{
    WIN32LR_DllThreadDetach();

    IMTLS_Free();
}

VOID OldAImm_DllProcessDetach()
{
    WIN32LR_DllProcessDetach();

    IMTLS_Free();
    TlsFree(g_dwTLSIndex);
}

#else // OLD_AIMM_ENABLED

BOOL IsOldAImm() { return FALSE; }
BOOL OldAImm_DllProcessAttach(HINSTANCE hInstance) { return FALSE; }
BOOL OldAImm_DllThreadAttach() { return FALSE; }
VOID OldAImm_DllThreadDetach() { }
VOID OldAImm_DllProcessDetach() { }

#endif // OLD_AIMM_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\globals.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    globals.cpp

Abstract:

    This file implements the global data.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "list.h"
#include "tls.h"

CCicCriticalSectionStatic g_cs;

// for combase
CRITICAL_SECTION *GetServerCritSec(void)
{
    return g_cs;
}

HINSTANCE g_hInst;

// used by COM server
HINSTANCE GetServerHINSTANCE(void)
{
    return g_hInst;
}

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

DWORD TLS::dwTLSIndex = 0;

#if !defined(OLD_AIMM_ENABLED)

//+---------------------------------------------------------------------------
//
// RunningInExcludedModule
//
// Exclude some processes from using the old aimm IIDs/CLSIDs.
//----------------------------------------------------------------------------

BOOL RunningInExcludedModule()
{
    DWORD dwHandle;
    void *pvData;
    VS_FIXEDFILEINFO *pffi;
    UINT cb;
    TCHAR ch;
    TCHAR *pch;
    TCHAR *pchFileName;
    BOOL fRet;
    TCHAR achModule[MAX_PATH + 1];

    if (GetModuleFileName(NULL, achModule, ARRAY_SIZE(achModule) - 1) == 0)
        return FALSE;

    achModule[ARRAYSIZE(achModule) - 1] = TEXT('\0');

    pch = pchFileName = achModule;

    while ((ch = *pch) != 0)
    {
        pch = CharNext(pch);

        if (ch == TEXT('\\'))
        {
            pchFileName = pch;
        }
    }

    fRet = FALSE;

    if (lstrcmpi(pchFileName, TEXT("outlook.exe")) == 0)
    {
        static BOOL s_fCached = FALSE;
        static BOOL s_fOldVersion = TRUE;

        // don't run aimm with versions of outlook before 10.0

        if (s_fCached)
        {
            return s_fOldVersion;
        }

        cb = GetFileVersionInfoSize(achModule, &dwHandle);

        if (cb == 0)
        {
            // can't get ver info...assume the worst
            return TRUE;
        }

        if ((pvData = cicMemAlloc(cb)) == NULL)
            return TRUE; // assume the worst

        if (GetFileVersionInfo(achModule, 0, cb, pvData) &&
            VerQueryValue(pvData, TEXT("\\"), (void **)&pffi, &cb))
        {
            fRet = s_fOldVersion = (HIWORD(pffi->dwProductVersionMS) < 10);
            s_fCached = TRUE; // set this last to be thread safe
        }
        else
        {
            fRet = TRUE; // something went wrong
        }

        cicMemFree(pvData);           
    }

    return fRet;
}

#endif // OLD_AIMM_ENABLED

//+---------------------------------------------------------------------------
//
//  GetCompartment
//
//----------------------------------------------------------------------------

HRESULT GetCompartment(IUnknown *punk, REFGUID rguidComp, ITfCompartment **ppComp)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;

    if (FAILED(hr = punk->QueryInterface(IID_ITfCompartmentMgr,
                                         (void **)&pCompMgr)))
        goto Exit;

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\oldaimm.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    oldaimm.h

Abstract:

    This file defines the old AIMM Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _OLDAIMM_H_
#define _OLDAIMM_H_

extern BOOL  g_fInLegacyClsid;

/*
 * Proto-type in oldaimm.cpp
 */
BOOL IsOldAImm();
BOOL IsCUAS_ON();
BOOL OldAImm_DllProcessAttach(HINSTANCE hInstance);
BOOL OldAImm_DllThreadAttach();
VOID OldAImm_DllThreadDetach();
VOID OldAImm_DllProcessDetach();

extern HRESULT CActiveIMM_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
extern HRESULT CActiveIMM_CreateInstance_Trident(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
extern HRESULT CActiveIMM_CreateInstance_Legacy(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

void UninitDelayLoadLibraries();

#ifdef OLD_AIMM_ENABLED

/*
 * Proto-type in old aimm lib
 */
extern BOOL DIMM12_DllProcessAttach();

extern BOOL WIN32LR_DllProcessAttach();
extern void WIN32LR_DllThreadAttach();
extern void WIN32LR_DllThreadDetach();
extern void WIN32LR_DllProcessDetach();

extern HRESULT WIN32LR_DllRegisterServer(void);
extern HRESULT WIN32LR_DllUnregisterServer(void);

extern BOOL RunningInExcludedModule();

#endif // OLD_AIMM_ENABLED
#endif // _OLDAIMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\tls.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    tls.h

Abstract:

    This file defines the TLS.

Author:

Revision History:

Notes:

--*/

#ifndef _TLS_H_
#define _TLS_H_

class TLS
{
public:
    static inline void Initialize()
    {
        dwTLSIndex = TlsAlloc();
    }

    static inline void Uninitialize()
    {
        TlsFree(dwTLSIndex);
    }

    static inline TLS* GetTLS()
    {
        //
        // Should allocate TLS data if doesn't exist.
        //
        return InternalAllocateTLS();
    }

    static inline TLS* ReferenceTLS()
    {
        //
        // Shouldn't allocate TLS data even TLS data doesn't exist.
        //
        return (TLS*)TlsGetValue(dwTLSIndex);
    }

    static inline BOOL DestroyTLS()
    {
        return InternalDestroyTLS();
    }

    inline int IncrementAIMMRefCnt()
    {
        return ++_fActivateCnt;
    }

    inline int DecrementAIMMRefCnt()
    {
        if (_fActivateCnt)
            return --_fActivateCnt;
        else
            return -1;
    }

private:
    int   _fActivateCnt;

private:
    static inline TLS* InternalAllocateTLS()
    {
        TLS* ptls = (TLS*)TlsGetValue(dwTLSIndex);
        if (ptls == NULL)
        {
            if ((ptls = (TLS*)cicMemAllocClear(sizeof(TLS))) == NULL)
                return NULL;

            if (! TlsSetValue(dwTLSIndex, ptls))
            {
                cicMemFree(ptls);
                return NULL;
            }
        }
        return ptls;
    }

    static BOOL InternalDestroyTLS()
    {
        TLS* ptls = (TLS*)TlsGetValue(dwTLSIndex);
        if (ptls != NULL)
        {
            cicMemFree(ptls);
            TlsSetValue(dwTLSIndex, NULL);
            return TRUE;
        }
        return FALSE;
    }

private:
    static DWORD dwTLSIndex;
};

#endif // _TLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for AIMM1.2 WRAPPER project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <immp.h>
#include <ole2.h>
#include <ocidl.h>
#include <olectl.h>
#include <debug.h>
#include "delay.h"
#include <limits.h>
#include "combase.h"
#if 0
// New NT5 header
#include "immdev.h"
#endif
#define _IMM_
#define _DDKIMM_H_

#include "aimm12.h"
#include "aimmex.h"
#include "aimmp.h"
#include "aimm.h"
#include "msuimw32.h"

#include "immxutil.h"
#include "helpers.h"
#include "osver.h"

#include "mem.h"

#ifndef STRSAFE_NO_DEPRECATE
#define STRSAFE_NO_DEPRECATE
#endif
#include <strsafe.h> 

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof(x)/sizeof(x)[0])
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    ARRAY_SIZE(x)
#endif

//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\aimmwrap\server.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    server.cpp

Abstract:

    This file implements the CComModule Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "oldaimm.h"
#include "dimmex.h"
#include "dimmwrp.h"

BEGIN_COCLASSFACTORY_TABLE
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_CActiveIMM12,         CActiveIMMAppEx,           TEXT("CActiveIMMAppEx"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_CActiveIMM12_Trident, CActiveIMMAppEx_Trident,   TEXT("CActiveIMMAppEx_Trident"))
    DECLARE_COCLASSFACTORY_ENTRY(CLSID_CActiveIMM,           CActiveIMMApp,             TEXT("CActiveIMMApp"))
END_COCLASSFACTORY_TABLE

//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    return TRUE;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process detach, like
// FreeLibrary calls, COM Releases, or mutexing.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
}

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppvObj
    )
{
    return COMBase_DllGetClassObject(rclsid, riid, ppvObj);
}

STDAPI
DllCanUnloadNow(
    void
    )
{
    return COMBase_DllCanUnloadNow();
}

STDAPI
DllRegisterServer(
    void
    )
{
#ifdef OLD_AIMM_ENABLED
    HRESULT hr;
    if ((hr=WIN32LR_DllRegisterServer()) != S_OK)
        return hr;
#else
    #error Should call RegisterCategories(GUID_PROP_MSIMTF_READONLY)
#endif // OLD_AIMM_ENABLED

    return COMBase_DllRegisterServer();
}

STDAPI
DllUnregisterServer(
    void
    )
{
#ifdef OLD_AIMM_ENABLED
    HRESULT hr;
    if ((hr=WIN32LR_DllUnregisterServer()) != S_OK)
        return hr;
#else
    #error Should call UnregisterCategories(GUID_PROP_MSIMTF_READONLY)
#endif // OLD_AIMM_ENABLED

    return COMBase_DllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\aime.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime.cpp

Abstract:

    This file implements the Active IME (Cicero) Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "context.h"
#include "defs.h"
#include "cdimm.h"
#include "globals.h"

BOOL
CActiveIMM::_CreateActiveIME()
{
    //
    // do the ImeInquire
    //

    // Inquire IME's information and UI class name.
    _pActiveIME->Inquire(TRUE, &_IMEInfoEx.ImeInfo, _IMEInfoEx.achWndClass, &_IMEInfoEx.dwPrivate);

    // Create default input context.
    _InputContext._CreateDefaultInputContext(_GetIMEProperty(PROP_PRIVATE_DATA_SIZE),
                                             (_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE) ? TRUE : FALSE,
                                             TRUE);

    //
    // Create default IME window.
    //
    _DefaultIMEWindow._CreateDefaultIMEWindow(_InputContext._GetDefaultHIMC());

    return TRUE;
}

BOOL
CActiveIMM::_DestroyActiveIME(
    )
{
    // Destroy default input context.
    _InputContext._DestroyDefaultInputContext();

    // shut down our tip
    _pActiveIME->Destroy(0);

    // Destroy default IME window.
    _DefaultIMEWindow._DestroyDefaultIMEWindow();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _GetCompositionString
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_GetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    DWORD dwCompLen,
    LONG* lpCopied,
    LPVOID lpBuf,
    BOOL fUnicode
    )
{
    HRESULT hr;
    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
    if (FAILED(hr = lpCompStr.GetResult()))
        return hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    BOOL  fSwapGuidMapField = FALSE;
    DWORD dwSwapLen;
    DWORD dwSwapOffset;

    if (IsGuidMapEnable(lpIMC->hWnd) && (lpIMC->fdwInit & INIT_GUID_ATOM)) {
        //
        // Transrate GUID map attribute.
        //
        lpIMC->m_pContext->MapAttributes((HIMC)lpIMC);

        dwSwapLen    = lpCompStr->CompStr.dwCompAttrLen;
        dwSwapOffset = lpCompStr->CompStr.dwCompAttrOffset;
        lpCompStr->CompStr.dwCompAttrLen    = lpCompStr->dwGuidMapAttrLen;
        lpCompStr->CompStr.dwCompAttrOffset = lpCompStr->dwGuidMapAttrOffset;
        fSwapGuidMapField = TRUE;
    }

    if ((!fUnicode && !lpIMC.IsUnicode()) ||
        ( fUnicode &&  lpIMC.IsUnicode())   ) {
        /*
         * Composition string in input context is of ANSI style when fUnicode is FALSE.
         * Composition string in input context is of Unicode style when fUnicode is TRUE.
         */
        if (! dwCompLen) {
            // query required buffer size. not inculde \0.
            if (! fUnicode) {
                hr = _InputContext.GetCompositionString(lpCompStr, dwIndex, lpCopied, sizeof(BYTE));
            }
            else {
                switch (dwIndex) {
                    case GCS_COMPATTR:          // ANSI-only
                    case GCS_COMPREADATTR:      // ANSI-only
                    case GCS_COMPREADCLAUSE:    // ANSI-only
                    case GCS_RESULTCLAUSE:      // ANSI-only
                    case GCS_RESULTREADCLAUSE:  // ANSI-only
                    case GCS_COMPCLAUSE:        // ANSI-only
                        hr = _InputContext.GetCompositionString(lpCompStr, dwIndex, lpCopied, sizeof(BYTE));
                        break;
                    default:
                        hr = _InputContext.GetCompositionString(lpCompStr, dwIndex, lpCopied);
                        break;
                }
            }
        }
        else {
            hr = S_OK;
            switch (dwIndex) {
                case GCS_COMPSTR:
                case GCS_COMPREADSTR:
                case GCS_RESULTSTR:
                case GCS_RESULTREADSTR:
                    if (! fUnicode) {
                        CBCompString bstr(cp, lpCompStr, dwIndex);
                        if (bstr.ReadCompData() != 0) {
                            *lpCopied = (LONG)bstr.ReadCompData((CHAR*)lpBuf,
                                                          dwCompLen / sizeof(CHAR)) * sizeof(CHAR);
                        }
                    }
                    else {
                        CWCompString wstr(cp, lpCompStr, dwIndex);
                        if (wstr.ReadCompData() != 0) {
                            *lpCopied = (LONG)wstr.ReadCompData((WCHAR*)lpBuf,
                                                          dwCompLen / sizeof(WCHAR)) * sizeof(WCHAR);
                        }
                    }
                    break;
                case GCS_COMPATTR:          // ANSI-only
                case GCS_COMPREADATTR:      // ANSI-only
                    {
                        CBCompAttribute battr(cp, lpCompStr, dwIndex);
                        if (battr.ReadCompData() != 0) {
                            *lpCopied = (LONG)battr.ReadCompData((BYTE*)lpBuf,
                                                           dwCompLen / sizeof(BYTE)) * sizeof(CHAR);
                        }
                    }
                    break;
                case GCS_COMPREADCLAUSE:    // ANSI-only
                case GCS_RESULTCLAUSE:      // ANSI-only
                case GCS_RESULTREADCLAUSE:  // ANSI-only
                case GCS_COMPCLAUSE:        // ANSI-only
                    {
                        CBCompClause bclause(cp, lpCompStr, dwIndex);
                        if (bclause.ReadCompData() != 0) {
                            *lpCopied = (LONG)bclause.ReadCompData((DWORD*)lpBuf,
                                                             dwCompLen / sizeof(DWORD)) * sizeof(DWORD);
                        }
                    }
                    break;
                case GCS_CURSORPOS:
                case GCS_DELTASTART:
                    if (! fUnicode) {
                        CBCompCursorPos bpos(cp, lpCompStr, dwIndex);
                    }
                    else {
                        CWCompCursorPos wpos(cp, lpCompStr, dwIndex);
                    }
                    break;
                default:
                    hr = E_INVALIDARG;
                    *lpCopied = IMM_ERROR_GENERAL; // ala Win32
                    break;
            }
        }

        goto _exit;
    }

    /*
     * ANSI caller, Unicode input context/composition string when fUnicode is FALSE.
     * Unicode caller, ANSI input context/composition string when fUnicode is TRUE
     */
    hr = S_OK;
    switch (dwIndex) {
        case GCS_COMPSTR:
        case GCS_COMPREADSTR:
        case GCS_RESULTSTR:
        case GCS_RESULTREADSTR:
            if (! fUnicode) {
                /*
                 * Get ANSI string from Unicode composition string.
                 */
                CWCompString wstr(cp, lpCompStr, dwIndex);
                CBCompString bstr(cp, lpCompStr);
                if (wstr.ReadCompData() != 0) {
                    bstr = wstr;
                    *lpCopied = (LONG)bstr.ReadCompData((CHAR*)lpBuf,
                                                  dwCompLen / sizeof(CHAR)) * sizeof(CHAR);
                }
            }
            else {
                /*
                 * Get Unicode string from ANSI composition string.
                 */
                CBCompString bstr(cp, lpCompStr, dwIndex);
                CWCompString wstr(cp, lpCompStr);
                if (bstr.ReadCompData() != 0) {
                    wstr = bstr;
                    *lpCopied = (LONG)wstr.ReadCompData((WCHAR*)lpBuf,
                                                  dwCompLen / sizeof(WCHAR)) * sizeof(WCHAR);
                }
            }
            break;
        case GCS_COMPATTR:
        case GCS_COMPREADATTR:
            if (! fUnicode) {
                /*
                 * Get ANSI attribute from Unicode composition attribute.
                 */
                CWCompAttribute wattr(cp, lpCompStr, dwIndex);
                CBCompAttribute battr(cp, lpCompStr);
                if (wattr.ReadCompData() != 0 &&
                    wattr.m_wcompstr.ReadCompData() != 0) {
                    battr = wattr;
                    *lpCopied = (LONG)battr.ReadCompData((BYTE*)lpBuf,
                                                   dwCompLen / sizeof(BYTE)) * sizeof(BYTE);
                }
            }
            else {
                /*
                 * Get Unicode attribute from ANSI composition attribute.
                 */
                CBCompAttribute battr(cp, lpCompStr, dwIndex);
                CWCompAttribute wattr(cp, lpCompStr);
                if (battr.ReadCompData() != 0 &&
                    battr.m_bcompstr.ReadCompData() != 0) {
                    wattr = battr;
                    *lpCopied = (LONG)wattr.ReadCompData((BYTE*)lpBuf,
                                                   dwCompLen / sizeof(BYTE)) * sizeof(BYTE);
                }
            }
            break;
        case GCS_COMPREADCLAUSE:
        case GCS_RESULTCLAUSE:
        case GCS_RESULTREADCLAUSE:
        case GCS_COMPCLAUSE:
            if (! fUnicode) {
                /*
                 * Get ANSI clause from Unicode composition clause.
                 */
                CWCompClause wclause(cp, lpCompStr, dwIndex);
                CBCompClause bclause(cp, lpCompStr);
                if (wclause.ReadCompData() != 0 &&
                    wclause.m_wcompstr.ReadCompData() != 0) {
                    bclause = wclause;
                    *lpCopied = (LONG)bclause.ReadCompData((DWORD*)lpBuf,
                                                     dwCompLen / sizeof(DWORD)) * sizeof(DWORD);
                }
            }
            else {
                /*
                 * Get Unicode clause from ANSI composition clause.
                 */
                CBCompClause bclause(cp, lpCompStr, dwIndex);
                CWCompClause wclause(cp, lpCompStr);
                if (bclause.ReadCompData() != 0 &&
                    bclause.m_bcompstr.ReadCompData() != 0) {
                    wclause = bclause;
                    *lpCopied = (LONG)wclause.ReadCompData((DWORD*)lpBuf,
                                                     dwCompLen / sizeof(DWORD)) * sizeof(DWORD);
                }
            }
            break;
        case GCS_CURSORPOS:
        case GCS_DELTASTART:
            if (! fUnicode) {
                /*
                 * Get ANSI cursor/delta start position from Unicode composition string.
                 */
                CWCompCursorPos wpos(cp, lpCompStr, dwIndex);
                CBCompCursorPos bpos(cp, lpCompStr);
                if (wpos.ReadCompData() != 0 &&
                    wpos.m_wcompstr.ReadCompData() != 0) {
                    bpos = wpos;
                    *lpCopied = bpos.GetAt(0);
                }
            }
            else {
                /*
                 * Get Unicode cursor/delta start position from ANSI composition string.
                 */
                CBCompCursorPos bpos(cp, lpCompStr, dwIndex);
                CWCompCursorPos wpos(cp, lpCompStr);
                if (bpos.ReadCompData() != 0 &&
                    bpos.m_bcompstr.ReadCompData() != 0) {
                    wpos = bpos;
                    *lpCopied = wpos.GetAt(0);
                }
            }
            break;
        default:
            hr = E_INVALIDARG;
            *lpCopied = IMM_ERROR_GENERAL; // ala Win32
            break;
    }

_exit:
    if (fSwapGuidMapField) {
        lpCompStr->CompStr.dwCompAttrLen    = dwSwapLen;
        lpCompStr->CompStr.dwCompAttrOffset = dwSwapOffset;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Internal_SetCompositionString
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_Internal_SetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    LPVOID lpComp,
    DWORD dwCompLen,
    LPVOID lpRead,
    DWORD dwReadLen,
    BOOL fUnicode,
    BOOL fNeedAWConversion
    )
{
    HRESULT hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        CBCompString bCompStr(cp, hIMC, (CHAR*)lpComp, dwCompLen);
        CBCompString bCompReadStr(cp, hIMC, (CHAR*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   lpComp, dwCompLen,
                                                   lpRead, dwReadLen);
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CWCompString wCompStr(cp, hIMC);
            if (dwCompLen)
                wCompStr = bCompStr;

            CWCompString wCompReadStr(cp, hIMC);
            if (dwReadLen)
                wCompReadStr = bCompReadStr;

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompStr, (DWORD)(wCompStr.GetSize()),
                                                   wCompReadStr, (DWORD)(wCompReadStr.GetSize()));
        }
    }
    else {
        CWCompString wCompStr(cp, hIMC, (WCHAR*)lpComp, dwCompLen);
        CWCompString wCompReadStr(cp, hIMC, (WCHAR*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   lpComp, dwCompLen,
                                                   lpRead, dwReadLen);
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CBCompString bCompStr(cp, hIMC);
            if (dwCompLen)
                bCompStr = wCompStr;

            CBCompString bCompReadStr(cp, hIMC);
            if (dwReadLen)
                bCompReadStr = wCompReadStr;

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompStr, (DWORD)(bCompStr.GetSize()),
                                                   bCompReadStr, (DWORD)(bCompReadStr.GetSize()));
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _Internal_SetCompositionAttribute
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_Internal_SetCompositionAttribute(
    HIMC hIMC,
    DWORD dwIndex,
    LPVOID lpComp,
    DWORD dwCompLen,
    LPVOID lpRead,
    DWORD dwReadLen,
    BOOL fUnicode,
    BOOL fNeedAWConversion
    )
{
    HRESULT hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        CBCompAttribute bCompAttr(cp, hIMC, (BYTE*)lpComp, dwCompLen);
        CBCompAttribute bCompReadAttr(cp, hIMC, (BYTE*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CBCompAttribute himc_battr(cp, lpCompStr, GCS_COMPATTR);
                CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(hr=CheckAttribute(bCompAttr, himc_battr, himc_bclause)))
                    return hr;

                CBCompAttribute himc_breadattr(cp, lpCompStr, GCS_COMPREADATTR);
                CBCompClause    himc_breadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(hr=CheckAttribute(bCompReadAttr, himc_breadattr, himc_breadclause)))
                    return hr;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompAttr, (DWORD)(bCompAttr.GetSize()),
                                                   bCompReadAttr, (DWORD)(bCompReadAttr.GetSize()));
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CWCompAttribute wCompAttr(cp, hIMC);
            CWCompAttribute wCompReadAttr(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    wCompAttr = bCompAttr;

                    CWCompAttribute himc_wattr(cp, lpCompStr, GCS_COMPATTR);
                    CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckAttribute(wCompAttr, himc_wattr, himc_wclause)))
                        return hr;
                }

                if (dwReadLen) {
                    wCompReadAttr = bCompReadAttr;

                    CWCompAttribute himc_wreadattr(cp, lpCompStr, GCS_COMPREADATTR);
                    CWCompClause    himc_wreadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckAttribute(wCompReadAttr, himc_wreadattr, himc_wreadclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompAttr, (DWORD)(wCompAttr.GetSize()),
                                                   wCompReadAttr, (DWORD)(wCompReadAttr.GetSize()));
        }
    }
    else {
        CWCompAttribute wCompAttr(cp, hIMC, (BYTE*)lpComp, dwCompLen);
        CWCompAttribute wCompReadAttr(cp, hIMC, (BYTE*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CWCompAttribute himc_wattr(cp, lpCompStr, GCS_COMPATTR);
                CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(hr=CheckAttribute(wCompAttr, himc_wattr, himc_wclause)))
                    return hr;

                CWCompAttribute himc_wreadattr(cp, lpCompStr, GCS_COMPREADATTR);
                CWCompClause    himc_wreadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(hr=CheckAttribute(wCompReadAttr, himc_wreadattr, himc_wreadclause)))
                    return hr;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompAttr, (DWORD)(wCompAttr.GetSize()),
                                                   wCompReadAttr, (DWORD)(wCompReadAttr.GetSize()));
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CBCompAttribute bCompAttr(cp, hIMC);
            CBCompAttribute bCompReadAttr(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    bCompAttr = wCompAttr;

                    CBCompAttribute himc_battr(cp, lpCompStr, GCS_COMPATTR);
                    CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckAttribute(bCompAttr, himc_battr, himc_bclause)))
                        return hr;
                }

                if (dwReadLen) {
                    bCompReadAttr = wCompReadAttr;

                    CBCompAttribute himc_breadattr(cp, lpCompStr, GCS_COMPREADATTR);
                    CBCompClause    himc_breadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckAttribute(bCompReadAttr, himc_breadattr, himc_breadclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompAttr, (DWORD)(bCompAttr.GetSize()),
                                                   bCompReadAttr, (DWORD)(bCompReadAttr.GetSize()));
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// _Internal_SetCompositionClause
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_Internal_SetCompositionClause(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen,
    IN BOOL fUnicode,
    IN BOOL fNeedAWConversion
    )
{
    HRESULT hr;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        CBCompClause bCompClause(cp, hIMC, (DWORD*)lpComp, dwCompLen);
        CBCompClause bCompReadClause(cp, hIMC, (DWORD*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CBCompClause himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(hr=CheckClause(bCompClause, himc_bclause)))
                    return hr;

                CBCompClause himc_breadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(hr=CheckClause(bCompReadClause, himc_breadclause)))
                    return hr;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompClause, (DWORD)(bCompClause.GetSize()),
                                                   bCompReadClause, (DWORD)(bCompReadClause.GetSize()));
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CWCompClause wCompClause(cp, hIMC);
            CWCompClause wCompReadClause(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    wCompClause = bCompClause;

                    CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckClause(wCompClause, himc_wclause)))
                        return hr;
                }

                if (dwReadLen) {
                    wCompReadClause = bCompReadClause;

                    CWCompClause    himc_wclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckClause(wCompReadClause, himc_wclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompClause, (DWORD)(wCompClause.GetSize()),
                                                   wCompReadClause, (DWORD)(wCompReadClause.GetSize()));
        }
    }
    else {
        CWCompClause wCompClause(cp, hIMC, (DWORD*)lpComp, dwCompLen);
        CWCompClause wCompReadClause(cp, hIMC, (DWORD*)lpRead, dwReadLen);
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                CWCompClause himc_wclause(cp, lpCompStr, GCS_COMPCLAUSE);
                if (FAILED(CheckClause(wCompClause, himc_wclause)))
                    return E_FAIL;

                CWCompClause himc_wreadclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                if (FAILED(CheckClause(wCompReadClause, himc_wreadclause)))
                    return E_FAIL;
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   wCompClause, (DWORD)(wCompClause.GetSize()),
                                                   wCompReadClause, (DWORD)(wCompReadClause.GetSize()));
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CBCompClause bCompClause(cp, hIMC);
            CBCompClause bCompReadClause(cp, hIMC);
            {
                DIMM_IMCLock lpIMC(hIMC);
                if (FAILED(hr = lpIMC.GetResult()))
                    return hr;

                DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
                if (FAILED(hr = lpCompStr.GetResult()))
                    return hr;

                if (dwCompLen) {
                    bCompClause = wCompClause;

                    CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPCLAUSE);
                    if (FAILED(hr=CheckClause(bCompClause, himc_bclause)))
                        return hr;
                }

                if (dwReadLen) {
                    bCompReadClause = wCompReadClause;

                    CBCompClause    himc_bclause(cp, lpCompStr, GCS_COMPREADCLAUSE);
                    if (FAILED(hr=CheckClause(bCompReadClause, himc_bclause)))
                        return hr;
                }
            }

            hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                   bCompClause, (DWORD)(bCompClause.GetSize()),
                                                   bCompReadClause, (DWORD)(bCompReadClause.GetSize()));
        }
    }

    return hr;
}

HRESULT
CActiveIMM::_Internal_ReconvertString(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen,
    IN BOOL fUnicode,
    IN BOOL fNeedAWConversion,
    OUT LRESULT* plResult           // = NULL
    )
{
    HRESULT hr;
    LPVOID lpOrgComp = lpComp;
    LPVOID lpOrgRead = lpRead;

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    HWND hWnd = NULL;
    if (dwIndex == IMR_CONFIRMRECONVERTSTRING ||
        dwIndex == IMR_RECONVERTSTRING ||
        dwIndex == IMR_DOCUMENTFEED) {
        DIMM_IMCLock imc(hIMC);
        if (FAILED(hr = imc.GetResult()))
            return hr;

        hWnd = imc->hWnd;
    }

    if (! fUnicode) {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       lpComp, dwCompLen,
                                                       lpRead, dwReadLen);
            }
            else {
                *plResult = ::SendMessageA(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)lpComp);
            }
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            CBReconvertString bReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
            CWReconvertString wReconvStr(cp, hIMC);
            if (bReconvStr.m_bcompstr.ReadCompData()) {
                wReconvStr = bReconvStr;
            }

            CBReconvertString bReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
            CWReconvertString wReconvReadStr(cp, hIMC);
            if (bReconvReadStr.m_bcompstr.ReadCompData()) {
                wReconvReadStr = bReconvReadStr;
            }

            BOOL fCompMem = FALSE, fReadMem = FALSE;
            LPRECONVERTSTRING _lpComp = NULL;
            DWORD _dwCompLen = wReconvStr.ReadCompData();
            if (_dwCompLen) {
                _lpComp = (LPRECONVERTSTRING) new BYTE[ _dwCompLen ];
                if (_lpComp) {
                    fCompMem = TRUE;
                    wReconvStr.ReadCompData(_lpComp, _dwCompLen);
                }
            }
            LPRECONVERTSTRING _lpRead = NULL;
            DWORD _dwReadLen = wReconvReadStr.ReadCompData();
            if (_dwReadLen) {
                _lpRead = (LPRECONVERTSTRING) new BYTE[ _dwReadLen ];
                if (_lpRead) {
                    fReadMem = TRUE;
                    wReconvStr.ReadCompData(_lpRead, _dwReadLen);
                }
            }

            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       _lpComp, _dwCompLen,
                                                       _lpRead, _dwReadLen);
            }
            else {
                *plResult = ::SendMessageA(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)_lpComp);
            }

            if (fCompMem)
                delete [] _lpComp;
            if (fReadMem)
                delete [] _lpRead;
        }
    }
    else {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       lpComp, dwCompLen,
                                                       lpRead, dwReadLen);
            }
            else {
                *plResult = ::SendMessageW(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)lpComp);
            }
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            CWReconvertString wReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
            CBReconvertString bReconvStr(cp, hIMC);
            if (wReconvStr.m_wcompstr.ReadCompData()) {
                bReconvStr = wReconvStr;
            }

            CWReconvertString wReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
            CBReconvertString bReconvReadStr(cp, hIMC);
            if (wReconvReadStr.m_wcompstr.ReadCompData()) {
                bReconvReadStr = wReconvReadStr;
            }

            BOOL fCompMem = FALSE, fReadMem = FALSE;
            LPRECONVERTSTRING _lpComp = NULL;
            DWORD _dwCompLen = bReconvStr.ReadCompData();
            if (_dwCompLen) {
                _lpComp = (LPRECONVERTSTRING) new BYTE[ _dwCompLen ];
                if (_lpComp) {
                    fCompMem = TRUE;
                    bReconvStr.ReadCompData(_lpComp, _dwCompLen);
                }
            }
            LPRECONVERTSTRING _lpRead = NULL;
            DWORD _dwReadLen = bReconvReadStr.ReadCompData();
            if (_dwReadLen) {
                _lpRead = (LPRECONVERTSTRING) new BYTE[ _dwReadLen ];
                if (_lpRead) {
                    fReadMem = TRUE;
                    bReconvStr.ReadCompData(_lpRead, _dwReadLen);
                }
            }

            if (dwIndex != IMR_CONFIRMRECONVERTSTRING &&
                dwIndex != IMR_RECONVERTSTRING &&
                dwIndex != IMR_DOCUMENTFEED) {
                hr = _pActiveIME->SetCompositionString(hIMC,dwIndex,
                                                       _lpComp, _dwCompLen,
                                                       _lpRead, _dwReadLen);
            }
            else {
                *plResult = ::SendMessageW(hWnd,
                                           WM_IME_REQUEST,
                                           dwIndex, (LPARAM)_lpComp);
            }

            if (fCompMem)
                delete [] _lpComp;
            if (fReadMem)
                delete [] _lpRead;
        }
    }

    /*
     * Check if need ANSI/Unicode back conversion
     */
    if (fNeedAWConversion) {
        switch (dwIndex) {
            case SCS_QUERYRECONVERTSTRING:
            case IMR_RECONVERTSTRING:
            case IMR_DOCUMENTFEED:
                if (lpOrgComp) {
                    if (! fUnicode) {
                        CWReconvertString wReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
                        CBReconvertString bReconvStr(cp, hIMC);
                        if (wReconvStr.m_wcompstr.ReadCompData()) {
                            bReconvStr = wReconvStr;
                            bReconvStr.m_bcompstr.ReadCompData((CHAR*)lpOrgComp, (DWORD)bReconvStr.m_bcompstr.ReadCompData());
                        }
                    }
                    else {
                        CBReconvertString bReconvStr(cp, hIMC, (LPRECONVERTSTRING)lpComp, dwCompLen);
                        CWReconvertString wReconvStr(cp, hIMC);
                        if (bReconvStr.m_bcompstr.ReadCompData()) {
                            wReconvStr = bReconvStr;
                            wReconvStr.m_wcompstr.ReadCompData((WCHAR*)lpOrgComp, (DWORD)wReconvStr.m_wcompstr.ReadCompData());
                        }
                    }
                }
                if (lpOrgRead) {
                    if (! fUnicode) {
                        CWReconvertString wReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
                        CBReconvertString bReconvReadStr(cp, hIMC);
                        if (wReconvReadStr.m_wcompstr.ReadCompData()) {
                            bReconvReadStr = wReconvReadStr;
                            bReconvReadStr.m_bcompstr.ReadCompData((CHAR*)lpOrgComp, (DWORD)bReconvReadStr.m_bcompstr.ReadCompData());
                        }
                    }
                    else {
                        CBReconvertString bReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)lpRead, dwReadLen);
                        CWReconvertString wReconvReadStr(cp, hIMC);
                        if (bReconvReadStr.m_bcompstr.ReadCompData()) {
                            wReconvReadStr = bReconvReadStr;
                            wReconvReadStr.m_wcompstr.ReadCompData((WCHAR*)lpOrgComp, (DWORD)wReconvReadStr.m_wcompstr.ReadCompData());
                        }
                    }
                }
                break;
        }
    }

    return hr;
}

HRESULT
CActiveIMM::_Internal_CompositionFont(
    DIMM_IMCLock& imc,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    BOOL fNeedAWConversion,
    LRESULT* plResult
    )
{
    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    if (! fUnicode) {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * ANSI caller, Unicode input context/composition string.
             */
            LOGFONTA LogFontA;
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)&LogFontA);
            LFontAtoLFontW(&LogFontA, (LOGFONTW*)lParam, cp);
        }
    }
    else {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * Unicode caller, ANSI input context/composition string.
             */
            LOGFONTW LogFontW;
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)&LogFontW);
            LFontWtoLFontA(&LogFontW, (LOGFONTA*)lParam, cp);
        }
    }

    return S_OK;
}

HRESULT
CActiveIMM::_Internal_QueryCharPosition(
    DIMM_IMCLock& imc,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    BOOL fNeedAWConversion,
    LRESULT* plResult
    )
{
    if (! fUnicode) {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of ANSI style.
             */
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * ANSI caller, Receiver Unicode application.
             */
            IMECHARPOSITION* ipA = (IMECHARPOSITION*)lParam;
            DWORD dwSaveCharPos = ipA->dwCharPos;
            _GetCompositionString((HIMC)imc, GCS_CURSORPOS, 0, (LONG*)&ipA->dwCharPos, NULL, TRUE);
            *plResult = ::SendMessageA(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)ipA);
            ipA->dwCharPos = dwSaveCharPos;
        }
    }
    else {
        if (! fNeedAWConversion) {
            /*
             * Composition string in input context is of Unicode style.
             */
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, lParam);
        }
        else {
            /*
             * Unicode caller, Receiver ANSI application.
             */
            IMECHARPOSITION* ipW = (IMECHARPOSITION*)lParam;
            DWORD dwSaveCharPos = ipW->dwCharPos;
            _GetCompositionString((HIMC)imc, GCS_CURSORPOS, 0, (LONG*)&ipW->dwCharPos, NULL, FALSE);
            *plResult = ::SendMessageW(imc->hWnd,
                                       WM_IME_REQUEST,
                                       wParam, (LPARAM)ipW);
            ipW->dwCharPos = dwSaveCharPos;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _SetCompositionString
//
//----------------------------------------------------------------------------

HRESULT
CActiveIMM::_SetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    LPVOID lpComp,
    DWORD dwCompLen,
    LPVOID lpRead,
    DWORD dwReadLen,
    BOOL fUnicode
    )
{
    HRESULT hr;
    BOOL fNeedAWConversion;
    BOOL fIMCUnicode;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    TraceMsg(TF_API, "CActiveIMM::SetCompositionString");

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
        if (FAILED(hr = lpCompStr.GetResult()))
            return hr;

        if (lpCompStr->CompStr.dwSize < sizeof(COMPOSITIONSTRING))
            return E_FAIL;

        fIMCUnicode = lpIMC.IsUnicode();
    }

    /*
     * Check if we need Unicode conversion
     */
    if ((!fUnicode && !fIMCUnicode) ||
        ( fUnicode &&  fIMCUnicode)   ) {
        /*
         * No ANSI conversion needed when fUnicode is FALSE.
         * No Unicode conversion needed when fUnicode is TRUE.
         */
        fNeedAWConversion = FALSE;
    }
    else {
        fNeedAWConversion = TRUE;
    }

    switch (dwIndex) {
        case SCS_SETSTR:
            hr = _Internal_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            break;
        case SCS_CHANGEATTR:
            hr = _Internal_SetCompositionAttribute(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            break;
        case SCS_CHANGECLAUSE:
            hr = _Internal_SetCompositionClause(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            break;
        case SCS_SETRECONVERTSTRING:
        case SCS_QUERYRECONVERTSTRING:

            if (_GetIMEProperty(PROP_SCS_CAPS) & SCS_CAP_SETRECONVERTSTRING) {
                hr = _Internal_ReconvertString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
            }
            else if (ptls != NULL) {
                LANGID langid;

                ptls->pAImeProfile->GetLangId(&langid);

                if (PRIMARYLANGID(langid) == LANG_KOREAN) {
                    hr = _Internal_ReconvertString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, fUnicode, fNeedAWConversion);
                }
            }

            break;
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}


void
CActiveIMM::LFontAtoLFontW(
    LPLOGFONTA lpLogFontA,
    LPLOGFONTW lpLogFontW,
    UINT uCodePage
    )
{
    INT i;

    memcpy(lpLogFontW, lpLogFontA, sizeof(LOGFONTA)-LF_FACESIZE);

    i = MultiByteToWideChar(uCodePage,            // hIMC's code page
                            MB_PRECOMPOSED,
                            lpLogFontA->lfFaceName,
                            strlen(lpLogFontA->lfFaceName),
                            lpLogFontW->lfFaceName,
                            LF_FACESIZE);
    lpLogFontW->lfFaceName[i] = L'\0';
    return;
}

void
CActiveIMM::LFontWtoLFontA(
    LPLOGFONTW lpLogFontW,
    LPLOGFONTA lpLogFontA,
    UINT uCodePage
    )
{
    INT i;

    memcpy(lpLogFontA, lpLogFontW, sizeof(LOGFONTA)-LF_FACESIZE);

    i = WideCharToMultiByte(uCodePage,            // hIMC's code page
                            0,
                            lpLogFontW->lfFaceName,
                            wcslen(lpLogFontW->lfFaceName),
                            lpLogFontA->lfFaceName,
                            LF_FACESIZE-1,
                            NULL,
                            NULL);
    lpLogFontA->lfFaceName[i] = '\0';
    return;
}

HRESULT
CActiveIMM::_GetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    IN BOOL fUnicode
    )

/*++

    AIMM Composition Font API Methods

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionFont");

    DWORD dwProcessId;
    BOOL fImcUnicode;
    UINT uCodePage;

    if (FAILED(_pActiveIME->GetCodePageA(&uCodePage)))
        return E_FAIL;

    if (!_InputContext.ContextLookup(hIMC, &dwProcessId, &fImcUnicode)) {
        TraceMsg(TF_WARNING, "CActiveIMM::_GetCompositionFont: Invalid hIMC %lx", hIMC);
        return E_FAIL;
    }

    if (fUnicode) {
        if (! fImcUnicode) {
            LOGFONTA LogFontA, *pLogFontA;
            pLogFontA = &LogFontA;
            if (SUCCEEDED(_GetCompositionFont(hIMC, (LOGFONTAW*)pLogFontA, FALSE))) {
                LFontAtoLFontW(pLogFontA, &lplf->W, uCodePage);
                return S_OK;
            }

            return E_FAIL;
        }
    }
    else {
        if (fImcUnicode) {
            LOGFONTW LogFontW, *pLogFontW;
            pLogFontW = &LogFontW;
            if (SUCCEEDED(_GetCompositionFont(hIMC, (LOGFONTAW*)pLogFontW, TRUE))) {
                LFontWtoLFontA(pLogFontW, &lplf->A, uCodePage);
                return S_OK;
            }

            return E_FAIL;
        }
    }

    HRESULT hr;
    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    return _InputContext.GetCompositionFont(lpIMC, lplf, fUnicode);
}

HRESULT
CActiveIMM::_SetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    IN BOOL fUnicode
    )

/*++

    AIMM Composition Font API Methods

--*/

{
    HRESULT hr;
    HWND hWnd;

    TraceMsg(TF_API, "CActiveIMM::SetCompositionFont");

    DWORD dwProcessId;
    BOOL fImcUnicode;
    UINT uCodePage;

    if (FAILED(_pActiveIME->GetCodePageA(&uCodePage)))
        return E_FAIL;

    if (!_InputContext.ContextLookup(hIMC, &dwProcessId, &fImcUnicode)) {
        TraceMsg(TF_WARNING, "CActiveIMM::_SetCompositionFont: Invalid hIMC %lx", hIMC);
        return E_FAIL;
    }

    if (fUnicode) {
        if (! fImcUnicode) {
            LOGFONTA LogFontA, *pLogFontA;
            pLogFontA = &LogFontA;
            LFontWtoLFontA(&lplf->W, pLogFontA, uCodePage);

            return _SetCompositionFont(hIMC, (LOGFONTAW*)pLogFontA, FALSE);
        }
    }
    else {
        if (fImcUnicode) {
            LOGFONTW LogFontW, *pLogFontW;
            pLogFontW = &LogFontW;
            LFontAtoLFontW(&lplf->A, pLogFontW, uCodePage);

            return _SetCompositionFont(hIMC, (LOGFONTAW*)pLogFontW, TRUE);
        }
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetCompositionFont(lpIMC, lplf, fUnicode);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of composition font.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETCOMPOSITIONFONT,
                   IMN_SETCOMPOSITIONFONT, 0L);

    return hr;
}

HRESULT
CActiveIMM::_RequestMessage(
    IN HIMC hIMC,
    IN WPARAM wParam,
    IN LPARAM lParam,
    OUT LRESULT *plResult,
    IN BOOL fUnicode
    )

/*++

    AIMM Request Message API Methods

--*/

{
    TraceMsg(TF_API, "CActiveIMM::RequestMessage");

    HRESULT hr;

    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    //
    // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
    // Any string data doesn't convert between ASCII <--> Unicode.
    // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
    // If ASCII wnd proc, then returns ASCII string.
    // Otherwise if Unicode wnd proc, returns Unicode string.
    //
    BOOL bUnicodeTarget = ::IsWindowUnicode(imc->hWnd);

    BOOL fNeedAWConversion;

    /*
     * Check if we need Unicode conversion
     */
    if ((!fUnicode && !bUnicodeTarget) ||
        ( fUnicode &&  bUnicodeTarget)   ) {
        /*
         * No ANSI conversion needed when fUnicode is FALSE.
         * No Unicode conversion needed when fUnicode is TRUE.
         */
        fNeedAWConversion = FALSE;
    }
    else {
        fNeedAWConversion = TRUE;
    }

    switch (wParam) {
        case IMR_CONFIRMRECONVERTSTRING:
        case IMR_RECONVERTSTRING:
        case IMR_DOCUMENTFEED:
            hr = _Internal_ReconvertString(hIMC,
                                           (DWORD)wParam,
                                           (LPVOID)lParam, ((LPRECONVERTSTRING)lParam)->dwSize,
                                           NULL, 0,
                                           fUnicode, fNeedAWConversion,
                                           plResult);
            break;
        case IMR_COMPOSITIONFONT:
            hr = _Internal_CompositionFont(imc,
                                           wParam, lParam,
                                           fUnicode, fNeedAWConversion,
                                           plResult);
            break;
        case IMR_QUERYCHARPOSITION:
            hr = _Internal_QueryCharPosition(imc,
                                             wParam, lParam,
                                             fUnicode, fNeedAWConversion,
                                             plResult);
            break;
    }

    return hr;
}



/*
 * EnumInputContext callback
 */
/* static */
BOOL CALLBACK CActiveIMM::_SelectContextProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    SCE *psce = (SCE *)lParam;
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    BOOL bIsRealIme_SelKL;
    BOOL bIsRealIme_UnSelKL;

    if (bIsRealIme_SelKL = _this->_IsRealIme(psce->hSelKL))
        return FALSE;

    bIsRealIme_UnSelKL = _this->_IsRealIme(psce->hUnSelKL);

    /*
     * Reinitialize the input context for the selected layout.
     */
    DWORD dwPrivateSize = _this->_GetIMEProperty(PROP_PRIVATE_DATA_SIZE);
    _this->_InputContext.UpdateInputContext(hIMC, dwPrivateSize);

    /*
     * Select the input context
     */
    _this->_AImeSelect(hIMC, TRUE, bIsRealIme_SelKL, bIsRealIme_UnSelKL);

    return TRUE;
}

/* static */
BOOL CALLBACK CActiveIMM::_UnSelectContextProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    SCE *psce = (SCE *)lParam;
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    BOOL bIsRealIme_SelKL;
    BOOL bIsRealIme_UnSelKL;

    if (bIsRealIme_UnSelKL = _this->_IsRealIme(psce->hUnSelKL))
        return FALSE;

    bIsRealIme_SelKL = _this->_IsRealIme(psce->hSelKL);

    _this->_AImeSelect(hIMC, FALSE, bIsRealIme_SelKL, bIsRealIme_UnSelKL);

    return TRUE;
}

/* static */
BOOL CALLBACK CActiveIMM::_NotifyIMEProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    if (_this->_IsRealIme())
        return FALSE;

    _this->_AImeNotifyIME(hIMC, NI_COMPOSITIONSTR, (DWORD)lParam, 0);

    return TRUE;
}

#ifdef UNSELECTCHECK
/* static */
BOOL CALLBACK CActiveIMM::_UnSelectCheckProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS(); // consider: put TLS in lParam!
    if (_this == NULL)
        return FALSE;

    _this->_AImeUnSelectCheck(hIMC);

    return TRUE;
}
#endif UNSELECTCHECK

/* static */
BOOL CALLBACK CActiveIMM::_EnumContextProc(
    HIMC hIMC,
    LPARAM lParam
    )
{
    CContextList* _hIMC_List = (CContextList*)lParam;
    if (_hIMC_List) {
        CContextList::CLIENT_IMC_FLAG client_flag = CContextList::IMCF_NONE;
        _hIMC_List->SetAt(hIMC, client_flag);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\aime_kl.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime_kl.cpp

Abstract:

    This file implements the Active IME for hKL (Cicero) Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"

const UINT IME_T_EUDC_DIC_SIZE = 80;    // the Tradition Chinese EUDC dictionary.

HRESULT
CActiveIMM::_Escape(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult,
    BOOL fUnicode
    )
{
    if ( (  fUnicode &&  (_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE)) ||
         (! fUnicode && !(_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE))
       ) {
        /*
         * Doesn't need W/A or A/W conversion. Calls directly to IME to
         * bring up the configuration dialog box.
         */
        return _pActiveIME->Escape(hIMC, uEscape, lpData, plResult);
    }

    UINT cp;
    _pActiveIME->GetCodePageA(&cp);

    /*
     * Unicode caller, ANSI IME, Needs W/A conversion depending on the uEscape
     * ANSI caller, Unicode IME, Needs A/W conversion depending on the uEscape
     */
    HRESULT hr = E_FAIL;
    switch (uEscape) {
        case IME_ESC_GET_EUDC_DICTIONARY:
        case IME_ESC_IME_NAME:
        case IME_ESC_GETHELPFILENAME:
            if (fUnicode) {
                LPSTR bbuf = new char [ sizeof(char) * IME_T_EUDC_DIC_SIZE ];
                if (bbuf) {
                    hr = _Escape(hKL, hIMC, uEscape, (void*)(LPCSTR)bbuf, plResult, FALSE);
                    if (SUCCEEDED(hr)) {
                        CBCompString bstr(cp, hIMC, bbuf, lstrlenA(bbuf));
                        CWCompString wstr(cp);
                        wstr = bstr;

                        wstr.ReadCompData((WCHAR*)lpData, IME_T_EUDC_DIC_SIZE);
                    }

                    delete [] bbuf;
                }
            }
            else {
                LPWSTR wbuf = new WCHAR [ sizeof(WCHAR) * IME_T_EUDC_DIC_SIZE ];
                if (wbuf) {
                    hr = _Escape(hKL, hIMC, uEscape, (void*)(LPCWSTR)wbuf, plResult, TRUE);
                    if (SUCCEEDED(hr)) {
                        CWCompString wstr(cp, hIMC, wbuf, lstrlenW(wbuf));
                        CBCompString bstr(cp);
                        bstr = wstr;

                        bstr.ReadCompData((CHAR*)lpData, IME_T_EUDC_DIC_SIZE);
                    }
                    delete [] wbuf;
                }
            }
            break;
        case IME_ESC_SET_EUDC_DICTIONARY:
        case IME_ESC_HANJA_MODE:
            if (fUnicode) {
                CWCompString wstr(cp, hIMC, (LPWSTR)lpData, lstrlenW((LPWSTR)lpData));
                CBCompString bstr(cp);
                bstr = wstr;

                DWORD dwLenReading = (DWORD)bstr.GetSize();
                LPSTR bbuf = new CHAR [sizeof(CHAR) * dwLenReading];
                if (bbuf) {
                    bstr.ReadCompData(bbuf, dwLenReading);
                    bbuf[dwLenReading] = L'\0';

                    hr = _Escape(hKL, hIMC, uEscape, (void*)bbuf, plResult, FALSE);
                    delete [] bbuf;
                }
            }
            else {
                CBCompString bstr(cp, hIMC, (LPSTR)lpData, lstrlenA((LPSTR)lpData));
                CWCompString wstr(cp);
                wstr = bstr;

                DWORD dwLenReading = (DWORD)wstr.GetSize();
                LPWSTR wbuf = new WCHAR [sizeof(WCHAR) * dwLenReading];
                if (wbuf)
                {
                    wstr.ReadCompData(wbuf, dwLenReading);
                    wbuf[dwLenReading] = L'\0';

                    hr = _Escape(hKL, hIMC, uEscape, (void*)wbuf, plResult, TRUE);
                    delete [] wbuf;
                }
            }
            break;
        case IME_ESC_SEQUENCE_TO_INTERNAL:
            {
                INT i = 0;
                if (fUnicode) {
                    hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
                    if (SUCCEEDED(hr)) {
                        char bbuf[ 2 ];
                        if (HIBYTE(LOWORD(*plResult)))
                            bbuf[i++] = HIBYTE(LOWORD(*plResult));
                        if (LOBYTE(LOWORD(*plResult)))
                            bbuf[i++] = LOBYTE(LOWORD(*plResult));

                        CBCompString bstr(cp, hIMC, bbuf, i);
                        CWCompString wstr(cp);
                        wstr = bstr;

                        switch (wstr.ReadCompData()) {
                            case 1:  *plResult = MAKELONG(wstr[0], 0); break;
                            case 2:  *plResult = MAKELONG(wstr[1], wstr[0]); break;
                            default: *plResult = 0; break;
                        }
                    }
                }
                else {
                    hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
                    if (SUCCEEDED(hr)) {
                        WCHAR wbuf[ 2 ];
                        if (HIWORD(*plResult))
                            wbuf[i++] = HIWORD(*plResult);
                        if (LOWORD(*plResult))
                            wbuf[i++] = LOWORD(*plResult);

                        CWCompString wstr(cp, hIMC, wbuf, i);
                        CBCompString bstr(cp);
                        bstr = wstr;

                        switch (bstr.ReadCompData()) {
                            case 1:  *plResult = MAKELONG(MAKEWORD(bstr[0], 0), 0); break;
                            case 2:  *plResult = MAKELONG(MAKEWORD(bstr[1], bstr[0]), 0); break;
                            case 3:  *plResult = MAKELONG(MAKEWORD(bstr[2], bstr[1]), MAKEWORD(bstr[0], 0)); break;
                            case 4:  *plResult = MAKELONG(MAKEWORD(bstr[3], bstr[2]), MAKEWORD(bstr[1], bstr[0])); break;
                            default: *plResult = 0; break;
                        }
                    }
                }
            }
            break;
        default:
            if (fUnicode)
                hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
            else
                hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
    }

    return hr;
}

HRESULT
CActiveIMM::_ConfigureIMEA(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDA *lpdata
    )
{
    REGISTERWORDW RegDataW;
    RegDataW.lpReading =
    RegDataW.lpWord    = NULL;

    if (dwMode & IME_CONFIG_REGISTERWORD) {
        UINT cp;
        _pActiveIME->GetCodePageA(&cp);

        CBCompString bReadingStr(cp);
        bReadingStr.WriteCompData(lpdata->lpReading, lstrlenA(lpdata->lpReading));
        DWORD dwLenReading = bReadingStr.ConvertUnicodeString();
        RegDataW.lpReading = new WCHAR [ dwLenReading + 1 ];
        if (RegDataW.lpReading == NULL)
            return E_OUTOFMEMORY;

        bReadingStr.ConvertUnicodeString(RegDataW.lpReading, dwLenReading);
        RegDataW.lpReading[ dwLenReading ] = L'\0';

        CBCompString bWordStr(cp);
        bWordStr.WriteCompData(lpdata->lpWord, lstrlenA(lpdata->lpWord));
        DWORD dwLenWord = bWordStr.ConvertUnicodeString();
        RegDataW.lpWord = new WCHAR [ dwLenWord + 1 ];
        if (RegDataW.lpWord == NULL) {
            delete [] RegDataW.lpReading;
            return E_OUTOFMEMORY;
        }

        bWordStr.ConvertUnicodeString(RegDataW.lpWord, dwLenWord);
        RegDataW.lpWord[ dwLenWord ] = L'\0';
    }

    HRESULT hr = _ConfigureIMEW(hKL, hWnd, dwMode, &RegDataW);

    if (RegDataW.lpReading)
        delete [] RegDataW.lpReading;
    if (RegDataW.lpWord)
        delete [] RegDataW.lpWord;
    return hr;
}

HRESULT
CActiveIMM::_ConfigureIMEW(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *lpdata
    )
{
    return _pActiveIME->Configure(hKL, hWnd, dwMode, lpdata);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\aime_wnd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime_wnd.cpp

Abstract:

    This file implements the Active IME for hWnd (Cicero) Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "imewndhd.h"
#include "cdimm.h"


/*++

Method:

    IActiveIMMApp::OnDefWindowProc

Routine Description:

    Replaces the DefWindowProc function

Arguments:

    hWnd - [in] Handle to the window procedure that received this message.
    uMsg - [in] Unsigned integer that specifies the message.
    wParam - [in] WPARAM value that specifies additional message information.
    lParam - [in] LPARAM value that specifies additional message information.
    plResult - [out] Address of an LRESULT value that receives the result of the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

Remarks:

    This method must be called before you would normally call DefWindowProc.
    If IActiveIMMApp::OnDefWindowProc returns S_FALSE, DefWindowProc should be called.

--*/

HRESULT
CActiveIMM::OnDefWindowProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult    
    )
{
    BOOL fUnicode = IsWindowUnicode(hWnd);
    HRESULT hr = S_FALSE; // returns S_FALSE, DefWindowProc should be called.

    Assert(GetCurrentThreadId() == GetWindowThreadProcessId(hWnd, NULL));
    Assert(plResult && *plResult == 0);    

    if (IsOnImm() || _IsRealIme())
        return S_FALSE;

    switch (uMsg)
    {
        case WM_IME_KEYDOWN:
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                PostMessageW(hWnd, WM_KEYDOWN, wParam, lParam);
            }
            else {
                PostMessageA(hWnd, WM_KEYDOWN, wParam, lParam);
            }
            *plResult = 0;
            hr = S_OK;
            break;

        case WM_IME_KEYUP:
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                PostMessageW(hWnd, WM_KEYUP, wParam, lParam);
            }
            else {
                PostMessageA(hWnd, WM_KEYUP, wParam, lParam);
            }
            *plResult = 0;
            hr = S_OK;
            break;

        case WM_IME_CHAR:
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                PostMessageW(hWnd, WM_CHAR, wParam, 1L);
            }
            else {
                UINT uCodePage;
                _pActiveIME->GetCodePageA(&uCodePage);

                if (IsDBCSLeadByteEx(uCodePage, (BYTE)(wParam >> 8))) {
                    PostMessageA(hWnd,
                                 WM_CHAR,
                                 (WPARAM)((BYTE)(wParam >> 8)),    // leading byte
                                 1L);
                    PostMessageA(hWnd,
                                 WM_CHAR,
                                 (WPARAM)((BYTE)wParam),           // trailing byte
                                 1L);
                }
                else {
                    PostMessageA(hWnd, WM_CHAR, wParam, 1L);
                }
            }
            *plResult = 0;
            hr = S_OK;
            break;

        case WM_IME_COMPOSITION:
            if (lParam & GCS_RESULTSTR) {
                HIMC hIMC;

                GetContext(hWnd, &hIMC);
                if (hIMC != NULL) {
                    LONG cbLen;

                    if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
                        LPWSTR pwszBuffer;
                        /*
                         * GetCompositionString returns the size of buffer needed in byte
                         */
                        if (SUCCEEDED(_GetCompositionString(hIMC, GCS_RESULTSTR, 0, &cbLen, NULL, fUnicode)) &&
                            cbLen != 0) {
                            pwszBuffer = (LPWSTR)new BYTE[cbLen];
                            if (pwszBuffer != NULL) {
                                _GetCompositionString(hIMC, GCS_RESULTSTR, cbLen, &cbLen, pwszBuffer, fUnicode);
                                DWORD dwIndex;
                                for (dwIndex = 0; dwIndex < cbLen / sizeof(WCHAR); dwIndex++)
                                    SendMessageW(hWnd, WM_IME_CHAR, MAKEWPARAM(pwszBuffer[dwIndex], 0), 1L);
                                delete [] pwszBuffer;
                            }
                        }
                    }
                    else {
                        LPSTR pszBuffer;
                        /*
                         * GetCompositionString returns the size of buffer needed in byte
                         */
                        if (SUCCEEDED(_GetCompositionString(hIMC, GCS_RESULTSTR, 0, &cbLen, NULL, fUnicode)) &&
                            cbLen != 0) {
                            pszBuffer = new CHAR[cbLen];
                            if (pszBuffer != NULL) {
                                _GetCompositionString(hIMC, GCS_RESULTSTR, cbLen, &cbLen, pszBuffer, fUnicode);
                                UINT uCodePage;
                                _pActiveIME->GetCodePageA(&uCodePage);

                                DWORD dwIndex;
                                for (dwIndex = 0; dwIndex < cbLen / sizeof(CHAR); dwIndex++) {
                                    if (IsDBCSLeadByteEx(uCodePage, pszBuffer[dwIndex])) {
                                        if (dwIndex+1 < cbLen / sizeof(CHAR)) {
                                            SendMessageA(hWnd,
                                                         WM_IME_CHAR,
                                                         MAKEWPARAM(MAKEWORD(pszBuffer[dwIndex+1], pszBuffer[dwIndex]), 0),
                                                         1L);
                                            dwIndex++;
                                        }
                                    }
                                    else {
                                        SendMessageA(hWnd,
                                                     WM_IME_CHAR,
                                                     MAKEWPARAM(MAKEWORD(pszBuffer[dwIndex], 0), 0),
                                                     1L);

                                    }
                                }
                                delete [] pszBuffer;
                            }
                        }
                    }
                }
            }
            /*
             * Fall through to send to Default IME Window with checking
             * activated hIMC.
             */
        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
            return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);

        case WM_IME_NOTIFY:
            switch (wParam)
            {
                case IMN_OPENSTATUSWINDOW:
                case IMN_CLOSESTATUSWINDOW:
                    return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);
                default:
                    return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);
            }
            break;

        case WM_IME_REQUEST:
            switch (wParam)
            {
                case IMR_QUERYCHARPOSITION:
                    return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode);
                default:
                    break;
            }
            break;

        case WM_IME_SETCONTEXT:
            return _ToIMEWindow(hWnd, uMsg, wParam, lParam, plResult, fUnicode, FALSE);

        case WM_IME_SELECT:
            TraceMsg(TF_WARNING, "OnDefWindowProc should not receive WM_IME_SELECT");
            break;
    }

    return hr;
}

HRESULT
CActiveIMM::_ToIMEWindow(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT*& plResult,
    BOOL fUnicode,
    BOOL fChkIMC
    )
{
    HRESULT hr = E_FAIL;
    HWND hwndDefIme;

    /*
     * We assume this Wnd uses DefaultIMEWindow.
     * If this window has its own IME window, it have to call
     * IsUIMessage()....
     */
    if (SUCCEEDED(_DefaultIMEWindow.GetDefaultIMEWnd(hWnd, &hwndDefIme))) {
        if (hwndDefIme == hWnd) {
            /*
             * VC++ 1.51 TLW0NCL.DLL subclass IME class window
             * and pass IME message to DefWindowProc().
             */
            TraceMsg(TF_WARNING, "IME Class window is hooked and IME message [%X] are sent to DefWindowProc", uMsg);
            *plResult = (fUnicode ? ImeWndProcW : ImeWndProcA)(hWnd, uMsg, wParam, lParam);
            return S_OK;
        }

        if (fChkIMC) {
            /*
             * If hImc of this window is not activated for IME window,
             * we don't send WM_IME_NOTIFY.
             */
            HIMC hIMC = NULL;
            _InputContext.GetContext(hWnd, &hIMC);
            CIMEWindowHandler* pimeui = GetImeWndHandler(hwndDefIme);
            if (pimeui == NULL)
                return E_FAIL;

            if (pimeui->ImeGetImc() == hIMC) {
                *plResult = (fUnicode && IsOnNT()    // Because Win9x platform doesn't have PostMessageW
                    ? SendMessageW : SendMessageA)(hwndDefIme, uMsg, wParam, lParam);
                hr = S_OK;
            }
            else {
                TraceMsg(TF_WARNING, "DefWindowProc can not send WM_IME_message [%X] now", uMsg);
                hr = E_FAIL;
            }
        }
        else {
            if (fUnicode && IsOnNT()) {    // Because Win9x platform doesn't have PostMessageW
                *plResult = SendMessageW(hwndDefIme, uMsg, wParam, lParam);
            }
            else {
                *plResult = SendMessageA(hwndDefIme, uMsg, wParam, lParam);
            }
            hr = S_OK;
        }
    }

    return hr;
}

VOID
CActiveIMM::_AimmPostMessage(
    HWND hwnd,
    INT iNum,
    LPTRANSMSG lpTransMsg,
    DIMM_IMCLock& lpIMC
    )
{
    while (iNum--) {
        if (lpIMC.IsUnicode() && IsOnNT()) {    // Because Win9x platform doesn't have PostMessageW
            PostMessageW(hwnd,
                         lpTransMsg->message,
                         lpTransMsg->wParam,
                         lpTransMsg->lParam);
        }
        else {
            _AimmPostSendMessageA(hwnd,
                                  lpTransMsg->message,
                                  lpTransMsg->wParam,
                                  lpTransMsg->lParam,
                                  lpIMC,
                                  TRUE);
        }
        lpTransMsg++;
    }
}

VOID
CActiveIMM::_AimmSendMessage(
    HWND hwnd,
    INT iNum,
    LPTRANSMSG lpTransMsg,
    DIMM_IMCLock& lpIMC
    )
{
    while (iNum--) {
        if (lpIMC.IsUnicode() && IsOnNT()) {    // Because Win9x platform doesn't have SendMessageW
            SendMessageW(hwnd,
                         lpTransMsg->message,
                         lpTransMsg->wParam,
                         lpTransMsg->lParam);
        }
        else {
            _AimmPostSendMessageA(hwnd,
                                  lpTransMsg->message,
                                  lpTransMsg->wParam,
                                  lpTransMsg->lParam,
                                  lpIMC);
        }
        lpTransMsg++;
    }
}

VOID
CActiveIMM::_AimmPostSendMessageA(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    DIMM_IMCLock& lpIMC,
    BOOL fPost
    )
{
    if (IsOnNT() || ((! IsOnNT()) && (! lpIMC.IsUnicode()))) {
        fPost ? PostMessageA(hwnd, msg, wParam, lParam)
              : SendMessageA(hwnd, msg, wParam, lParam);
    }
    else {
        if (msg == WM_IME_COMPOSITION) {

            UINT cp;
            _pActiveIME->GetCodePageA(&cp);

            CWCompString wstr(cp, lpIMC, (LPWSTR)&wParam, 1);
            CBCompString bstr(cp, lpIMC);
            bstr = wstr;
            if (bstr.ReadCompData()) {
                if (bstr.GetSize() > 1)
                    wParam = MAKEWPARAM(bstr.GetAt(0), bstr.GetAt(1));
                else
                    wParam = bstr.GetAt(0);
            }
        }
        fPost ? PostMessageA(hwnd, msg, wParam, lParam)
              : SendMessageA(hwnd, msg, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\aime_hook.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    aime_hook.cpp

Abstract:

    This file implements the Active IME for hook (Cicero)  lass.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"
#include "globals.h"

HRESULT
CActiveIMM::_ProcessKey(
    WPARAM *pwParam,
    LPARAM *plParam,
    BOOL fNoMsgPump
    )

/*+++

Return Value:

    Returns S_OK, KeyboardHook doesn't call CallNextHookEx. This means this key code eaten by dimm.
    Returns S_FALSE, KeyboardHook calls CallNextHookEx.

---*/

{
    HIMC hActiveIMC;
    BYTE abKbdState[256];
    WPARAM wParam;
    LPARAM lParam;
    DWORD fdwProperty;

    wParam = *pwParam; // deref for perf
    lParam = *plParam;

    hActiveIMC = _GetActiveContext();

    HRESULT hr;

    DIMM_IMCLock pIMC(hActiveIMC);
    if (FAILED(hr=pIMC.GetResult())) {
        return hr;
    }

#if 0
    //
    // Disable code for the Office 10 PPT (office bug #110692).
    // But, I never remove this code. because this is very IMPORTANT with IE4.
    //

    HWND hCaptureWnd;

    if (fNoMsgPump &&
        wParam != VK_PROCESSKEY && // korean imes will get VK_PROCESSKEY events after mouse events
        (hCaptureWnd = GetCapture()))
    {
        if (_hFocusWnd == hCaptureWnd)
        {
            // This is a workaround for a limitation of using a keyboard hook proc.  Normally if trident's
            // server window has the mouse capture it insures TranslateMessage isn't called (by returning
            // S_OK to an OLE pre-TranslateAccelerator method).  Thus no
            // WM_IME_*COMPOSITION and no WM_CHAR.  For bug 1174, we were sending WM_IME_STARTCOMPOSITION
            // when trident had the mouse capture.  It ignored the message in this state and then barfed
            // on later WM_IME_COMPOSITIONS.
            //
            // This code will eat all keystrokes destined for an aime when the focus window has the capture.
            // This is not ideal, but hopefully reasonable.  One more reason to use OnTranslateMessage.
            //
            *pwParam = 0; // eat the key!
            fRet = TRUE;
            return fRet;
        }

        // consider: this I think is outlook 98 specific, but we no longer
        // support outlook98 w/ IActiveIMMAppTrident4x
        if (hCaptureWnd != _hFocusWnd /* && !IsAIMEWnd(hCaptureWnd) */ )
            return fRet;
    }
#endif

#if 0
    if (_fMenuSelected)
    {
        // we check for KF_MENUMODE below for robustness, but that won't
        // catch the case where someone left alts to highlight "File" etc
        // then types while a composition string is in progress
        return S_FALSE;
    }
#endif

#if 0
    #define SCANCODE_ALTDN_MASK   (0x00ff0000 | ((DWORD)KF_ALTDOWN << 16))

    // consider: technically we can put this off a little
    // but it's probably worth it to leave the translation here in case we change
    // something that affects further tests
    if (pid->uCodePage == 949)
    {
        BOOL fExt = HIWORD(lParam) & KF_EXTENDED;

        // translate us 101 -> korean specific keys

        if (wParam == VK_RCONTROL || (wParam == VK_CONTROL && fExt))
        {
            // map right ctl to VK_HANJA
            wParam = VK_HANJA;
        }
        else if (wParam == VK_RMENU || (wParam == VK_MENU && fExt))
        {
            // map right alt to VK_HANGUL
            wParam = VK_HANGUL;
            lParam &= ~SCANCODE_ALTDN_MASK;
        }
        else if (((lParam >> 16) & 0xff) == 0xd && (HIWORD(lParam) & KF_ALTDOWN) && !fExt)
        {
            // map left alt-= and left alt-+ to VK_JUNJA
            // note we're assuming a us 101 qwerty layout above, which is correct currently
            wParam = VK_JUNJA;
            lParam &= ~SCANCODE_ALTDN_MASK;
        }
        *pwParam = wParam;
        *plParam = lParam;
    }
#endif

    if (!GetKeyboardState(abKbdState))
        return S_FALSE;

    _KbdTouchUp(abKbdState, wParam, lParam);

    fdwProperty = _GetIMEProperty(PROP_IME_PROPERTY);

    if ((HIWORD(lParam) & KF_MENUMODE) ||
        ((HIWORD(lParam) & KF_UP) && (fdwProperty & IME_PROP_IGNORE_UPKEYS)) ||
        ((HIWORD(lParam) & KF_ALTDOWN) && !(fdwProperty & IME_PROP_NEED_ALTKEY)))
    {
        return S_FALSE;
    }

    hr = _pActiveIME->ProcessKey(hActiveIMC, (UINT)wParam, (DWORD)lParam, abKbdState);

    if (hr == S_OK && !fNoMsgPump)
    {
#if 0
        // save the key the ime wants to eat in case the app is interested
        pPIMC->fSavedVKey = TRUE;
        pPIMC->uSavedVKey = wParam & 0xff;
#endif

        PostMessage(_hFocusWnd, (HIWORD(lParam) & KF_UP) ? WM_KEYUP : WM_KEYDOWN, VK_PROCESSKEY, lParam);
    }

    return hr;
}


const DWORD TRANSMSGCOUNT = 256;

HRESULT
CActiveIMM::_ToAsciiEx(
    WPARAM wParam,
    LPARAM lParam
    )

/*+++

Return Value:

    Returns S_OK, KeyboardHook doesn't call CallNextHookEx. This means this key code eaten by dimm.
    Returns S_FALSE, KeyboardHook calls CallNextHookEx.

---*/

{
    BYTE abKbdState[256];
    UINT uVirKey;

    HRESULT hr;

    HIMC hActiveIMC = _GetActiveContext();

    DIMM_IMCLock lpIMC(hActiveIMC);
    if (FAILED(hr=lpIMC.GetResult())) {
        return hr;
    }

#if 0
    // clear the saved virtual key that corresponded to wParam
    pPIMC->fSavedVKey = FALSE;
#endif

    if (!GetKeyboardState(abKbdState))
        return S_FALSE;

    _KbdTouchUp(abKbdState, wParam, lParam);

    uVirKey = (UINT)wParam & 0xffff;

    DWORD fdwProperty = _GetIMEProperty(PROP_IME_PROPERTY);

    if (fdwProperty & IME_PROP_KBD_CHAR_FIRST) {

        HKL hKL = NULL;
        _GetKeyboardLayout(&hKL);

        WCHAR wc = 0;
        if (IsOnNT()) {
            Assert(g_pfnToUnicodeEx);
            if (g_pfnToUnicodeEx(uVirKey,                  // virtual-key code
                                 WORD(lParam >> 16),       // scan code
                                 abKbdState,               // key-state array
                                 &wc, 1,                   // translated key buffer, size
                                 0,                        // function option
                                 hKL) != 1)
            {
                wc = 0;
            }
        }
        else {
            WORD wChar;

            if (::ToAsciiEx(uVirKey,
                            (UINT)((lParam >> 16) & 0xffff),
                            abKbdState,
                            &wChar, 0,
                            hKL) == 1)
            {
                UINT uCodePage;
                _pActiveIME->GetCodePageA(&uCodePage);
                if (MultiByteToWideChar(uCodePage, 0, (char *)&wChar, 1, &wc, 1) != 1) {
                    wc = 0;
                }
            }
        }
        if (wc) {
            // ime wants translated char in high word of tae uVirKey param
            uVirKey |= ((DWORD)wc << 16);
        }
    }


    UINT  cMsg;
    DWORD dwSize = FIELD_OFFSET(TRANSMSGLIST, TransMsg)
                 + TRANSMSGCOUNT * sizeof(TRANSMSG);

    LPTRANSMSGLIST lpTransMsgList = (LPTRANSMSGLIST) new BYTE[dwSize];
    if (lpTransMsgList == NULL)
        return S_FALSE;

    lpTransMsgList->uMsgCount = TRANSMSGCOUNT;

    hr = S_FALSE;

    if (SUCCEEDED(hr=_pActiveIME->ToAsciiEx(uVirKey,             // virtual key code to be translated
                                                                 // HIWORD(uVirKey) : if IME_PROP_KBD_CHAR_FIRST property, then hiword is translated char code of VKey.
                                                                 // LOWORD(uVirKey) : Virtual Key code.
                                            HIWORD(lParam),      // hardware scan code of the key
                                            abKbdState,          // 256-byte array of keyboard status
                                            0,                   // active menu flag
                                            hActiveIMC,          // handle of the input context
                                            (DWORD*)lpTransMsgList,      // receives the translated result
                                            &cMsg))              // receives the number of messages
       ) {
        if (cMsg > TRANSMSGCOUNT) {

            //
            // The message buffer is not big enough. IME put messages
            // into hMsgBuf in the input context.
            //

            DIMM_IMCCLock<TRANSMSG> pdw(lpIMC->hMsgBuf);
            if (pdw.Valid()) {
                _AimmPostMessage(_hFocusWnd,
                                 cMsg,
                                 pdw,
                                 lpIMC);
            }

        }
        else if (cMsg > 0) {
            _AimmPostMessage(_hFocusWnd,
                             cMsg,
                             &lpTransMsgList->TransMsg[0],
                             lpIMC);
        }
    }

    delete [] lpTransMsgList;

    return hr;
}

void
CActiveIMM::_KbdTouchUp(
    BYTE *abKbdState,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // HACK!
    // win95 bug: VK_L*/VK_R* aren't being set...by any of the key state apis
    // consider: this needs to be fully investigated, instead of this incorrect hack,
    // which among other things is biased towards wParam
    //
    // Probably what's happening is GetKeyboardState is syncronous with the removal of
    // kbd msgs from the queue, so we're seeing the state at the last kbd msg.
    // Need to use async api.

    if (!IsOnNT())
    {
        switch (wParam)
        {
            case VK_CONTROL:
            case VK_MENU:
                if (HIWORD(lParam) & KF_EXTENDED)
                {
                    abKbdState[VK_RMENU] = abKbdState[VK_MENU];
                    abKbdState[VK_RCONTROL] = abKbdState[VK_CONTROL];
                }
                else
                {
                    abKbdState[VK_LMENU] = abKbdState[VK_MENU];
                    abKbdState[VK_LCONTROL] = abKbdState[VK_CONTROL];
                }
                break;
            case VK_SHIFT:
                if ((lParam & 0x00ff0000) == 0x002a0000) // scan code 0x2a == lshift, 0x36 == rshift
                {
                    abKbdState[VK_LSHIFT] = abKbdState[VK_SHIFT];
                }
                else
                {
                    abKbdState[VK_RSHIFT] = abKbdState[VK_SHIFT];
                }
                break;
        }
    }
}

/* static */
#if 0
LRESULT CALLBACK CActiveIMM::_GetMsgProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    /*
     * Hook
     *
     * Check IsRealIme() when receive WM_SETFOCUS/WM_KILLFOCUS and g_msgSetFocus.
     * We need call GetTeb()->SetFocusWindow() method when receive WM_SETFOCUS.
     */
    MSG *pmsg;
    UINT uMsg;

    pmsg = (MSG *)lParam;
    uMsg = pmsg->message;

    if (nCode == HC_ACTION &&
        (wParam & PM_REMOVE))  // bug 29656: sometimes w/ word wParam is set to PM_REMOVE | PM_NOYIELD
                               // PM_NOYIELD is meaningless in win32 and sould be ignored
    {
        if (uMsg == WM_SETFOCUS ||
            uMsg == WM_KILLFOCUS ||
            uMsg == g_msgSetFocus   )
        {
            _this->_OnFocusMessage(uMsg, pmsg->hwnd, pmsg->wParam, pmsg->lParam, _this->_IsRealIme());
        }
#if 0
        else if (uMsg == WM_MENUSELECT)
        {
            // we don't want to feed an ime keystrokes during menu operations
            _this->_fMenuSelected = (HIWORD(pmsg->wParam) != 0xffff || (HMENU)pmsg->lParam != 0);
        }
#endif
    }

    return CallNextHookEx(_this->_hHook[TH_GETMSG], nCode, wParam, lParam);
}
#endif

/*
 * Shell Hook
 */


#if 0
LRESULT
CCiceroIME::ShellHook(
    HHOOK hhk,
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CTeb* _pThread = GetTeb();

    Assert(!IsOnFE()); // only need this hook on non-fe (on fe trap WM_IME_SELECT)

    switch (nCode)
    {
        case HSHELL_LANGUAGE:
            // we need to deactivate any running aime now, before the thread hkl changes
            if (lParam && /* pTS->pid && */ GetIMEKeyboardLayout() != (HKL)lParam)
            {
                TraceMsg(TF_GENERAL, "_ShellProc (%x) shutting down aime", GetCurrentThreadId());
                // _ActivateIME();
            }
            break;
    }

    return CallNextHookEx(hhk, nCode, wParam, lParam);
}
#endif

BOOL
CActiveIMM::_OnFocusMessage(
    UINT uMsg,
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam,
    BOOL bIsRealIme
    )
{
    if (bIsRealIme) {
        switch (uMsg)
        {
            case WM_SETFOCUS:
                if (! _OnSetFocus(hWnd, bIsRealIme)) {
                    _hFocusWnd = hWnd;
                }
                break;

            case WM_KILLFOCUS:
                _OnKillFocus(hWnd, bIsRealIme);
                break;
        }
    }
    else {
        switch (uMsg)
        {
            case WM_SETFOCUS:
                _OnSetFocus(hWnd, bIsRealIme);
                break;

            case WM_KILLFOCUS:
                _OnKillFocus(hWnd, bIsRealIme);
                break;

                break;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _OnSetFocus
//
//----------------------------------------------------------------------------

BOOL CActiveIMM::_OnSetFocus(HWND hWnd, BOOL bIsRealIme)
{
    BOOL ret = FALSE;
    HIMC hIMC;
    HWND hFocusWnd;

    if (hWnd && (hFocusWnd = GetFocus()) && hWnd != hFocusWnd) // consider: prob this makes all tests below unnecessary...
    {
        return ret;
    }

    _hFocusWnd = hWnd;

    if (SUCCEEDED(_InputContext.GetContext(hWnd, &hIMC))) {
        if (IsPresent(hWnd, TRUE)) {
            //
            // In the case of DIM already associated but _mapWndFocus is not.
            //
            _SetMapWndFocus(hWnd);

            if (_InputContext._IsDefaultContext(hIMC)) {
                DIMM_IMCLock pIMC(hIMC);
                if (pIMC.Valid()) {
                    // set the hWnd since this is a default context
                    pIMC->hWnd = hWnd;
                }
            }

            if (bIsRealIme) {
                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
            }
            else {
                // update the current ime's IMMGWL_IMC
                _UIWindow.SetUIWindowContext(hIMC);

                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
                _SendUIMessage(WM_IME_SETCONTEXT, TRUE, ISC_SHOWUIALL, IsWindowUnicode(hWnd));
            }

            //
            // In the case of DIM associated with _AImeAssociateFocus
            //
            _SetMapWndFocus(hWnd);
        }
        else {
            if (hIMC)
                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS | AIMMP_AFF_SETNULLDIM);
            else
                _AImeAssociateFocus(hWnd, NULL, AIMMP_AFF_SETFOCUS);
        }
        ret = TRUE;
    }
    return ret;
}

void
CActiveIMM::_OnKillFocus(
    HWND hWnd,
    BOOL bIsRealIme
    )
{
    HIMC hIMC;

    if (SUCCEEDED(_InputContext.GetContext(hWnd, &hIMC))) {

        BOOL fPresent = IsPresent(hWnd, FALSE);

        if (fPresent) {
            if (bIsRealIme) {
                _AImeAssociateFocus(hWnd, hIMC, 0);

#ifdef NOLONGER_NEEDIT_BUT_MAYREFERIT_LATER
                /*
                 * Exception for "Internet Explorer_Server" window class.
                 * This window class doesn't have a window focus, so GetFocus() retrieve
                 * different window handle.
                 * In this case, ITfThreadMgr->AssociateFocus doesn't call _SetFocus(NULL),
                 * this code is recover ITfThreadMgr->SetFocus(NULL);
                 */
                if (hWnd != ::GetFocus() && _FilterList.IsExceptionPresent(hWnd)) {
                    _FilterList.OnExceptionKillFocus();
                }
#endif
            }
            else {
                _AImeAssociateFocus(hWnd, hIMC, 0);
                _SendUIMessage(WM_IME_SETCONTEXT, FALSE, ISC_SHOWUIALL, IsWindowUnicode(hWnd));
           }
        }
    }
}

void
CActiveIMM::_SetMapWndFocus(
    HWND hWnd
    )
{
    ITfDocumentMgr* pdim;
    if (_mapWndFocus.Lookup(hWnd, pdim)) { // consider: what is this code doing?
        if (pdim)
           pdim->Release();
    }
    _mapWndFocus.SetAt(hWnd, GetAssociated(hWnd));
}

void
CActiveIMM::_ResetMapWndFocus(
    HWND hWnd
    )
{
    ITfDocumentMgr* pdim;
    if (_mapWndFocus.Lookup(hWnd, pdim)) {
        _mapWndFocus.SetAt(hWnd, FALSE);
        if (pdim)
           pdim->Release();
    }
}


/*
 * Hook
 */


#ifdef CALLWNDPROC_HOOK
/* static */
LRESULT CALLBACK CActiveIMM::_CallWndProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    const CWPSTRUCT *pcwps;
    UINT uMsg;

    pcwps = (const CWPSTRUCT *)lParam;
    uMsg = pcwps->message;

    if (nCode == HC_ACTION)
    {
        if (uMsg == WM_SETFOCUS ||
            uMsg == WM_KILLFOCUS  )
        {
            _this->_OnFocusMessage(uMsg, pcwps->hwnd, pcwps->wParam, pcwps->lParam, _this->_IsRealIme());
        }
#if 0
        else if (uMsg == WM_MENUSELECT)
        {
            // we don't want to feed an ime keystrokes during menu operations
            _this->_fMenuSelected = (HIWORD(wParam) != 0xffff || (HMENU)lParam != 0);
        }
#endif
    }

    return CallNextHookEx(_this->_hHook[TH_WNDPROC], nCode, wParam, lParam);
}
#endif // CALLWNDPROC_HOOK

/* static */
LRESULT CALLBACK CActiveIMM::_DefImeWnd_CallWndProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    /*
     * Default IME Window class hook
     *
     * Never check IsRealIme().
     *
     */
    if (nCode == HC_ACTION) {
        const CWPRETSTRUCT *pcwprets;
        pcwprets = (const CWPRETSTRUCT *)lParam;

#ifndef CALLWNDPROC_HOOK
        if (pcwprets->message == WM_SETFOCUS ||
            pcwprets->message == WM_KILLFOCUS  )
        {
            _this->_OnFocusMessage(pcwprets->message, pcwprets->hwnd, pcwprets->wParam, pcwprets->lParam, _this->_IsRealIme());
        }
#if 0
        else if (pcwprets->message == WM_MENUSELECT)
        {
            // we don't want to feed an ime keystrokes during menu operations
            _this->_fMenuSelected = (HIWORD(wParam) != 0xffff || (HMENU)lParam != 0);
        }
#endif
        else
#endif // CALLWNDPROC_HOOK
            if (_this->_IsImeClass(pcwprets->hwnd)) {
            /*
             * This hook from IME window class
             */
            switch (pcwprets->message) {
                case WM_NCDESTROY:
                    _this->_DefaultIMEWindow.ImeDefWndHook(pcwprets->hwnd);
                    _this->_RemoveHookWndList(pcwprets->hwnd);
                    break;
            }
        }
        else {
            /*
             * This hook from unknown window class
             */
            switch (pcwprets->message) {
                case WM_CREATE:
                    _this->_SetHookWndList(pcwprets->hwnd);
                    break;
            }
        }
    }

    return CallNextHookEx(_this->_hHook[TH_DEFIMEWNDPROC], nCode, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\cdimm.h ===
//+---------------------------------------------------------------------------
//
//  File:       cdimm.h
//
//  Contents:   CActiveIMM
//
//----------------------------------------------------------------------------

#ifndef CDIMM_H
#define CDIMM_H

#include "msctfp.h"
#include "cimm32.h"
#include "uiwnd.h"
#include "context.h"
#include "imewnd.h"
#include "globals.h"

typedef struct tagSELECTCONTEXT_ENUM SCE, *PSCE;

#define CALLWNDPROC_HOOK

/*
 * Windows hook
 */
typedef enum {
    // array indices for thread hooks
#if 0
    TH_GETMSG,
#endif
    TH_DEFIMEWNDPROC,
#ifdef CALLWNDPROC_HOOK
    TH_WNDPROC,
#endif // CALLWNDPROC_HOOK
    TH_NUMHOOKS
} HookType;

typedef struct tagIMEINFOEX
{
    IMEINFO      ImeInfo;         // IMEINFO structure.
    WCHAR        achWndClass[16];
    DWORD        dwPrivate;
} IMEINFOEX;

//+---------------------------------------------------------------------------
//
// CActiveIMM
//
//----------------------------------------------------------------------------

class CActiveIMM : public IActiveIMMIME_Private,
                   public ITfSysHookSink
{
public:
    CActiveIMM();
    ~CActiveIMM();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IActiveIMMApp/IActiveIMM methods
    //

    /*
     * AIMM Input Context (hIMC) Methods.
     */
    STDMETHODIMP CreateContext(HIMC *phIMC);
    STDMETHODIMP DestroyContext(HIMC hIME);
    STDMETHODIMP AssociateContext(HWND hWnd, HIMC hIME, HIMC *phPrev);
    STDMETHODIMP AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags);
    STDMETHODIMP GetContext(HWND hWnd, HIMC *phIMC);
    STDMETHODIMP ReleaseContext(HWND hWnd, HIMC hIMC);
    STDMETHODIMP GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC);
    STDMETHODIMP UnlockIMC(HIMC hIMC);

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    STDMETHODIMP CreateIMCC(DWORD dwSize, HIMCC *phIMCC);
    STDMETHODIMP DestroyIMCC(HIMCC hIMCC);
    STDMETHODIMP GetIMCCSize(HIMCC hIMCC,  DWORD *pdwSize);
    STDMETHODIMP ReSizeIMCC(HIMCC hIMCC, DWORD dwSize,  HIMCC *phIMCC);
    STDMETHODIMP GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMCC(HIMCC hIMCC, void **ppv);
    STDMETHODIMP UnlockIMCC(HIMCC hIMCC);

    /*
     * AIMM Open Status API Methods
     */
    STDMETHODIMP GetOpenStatus(HIMC hIMC);
    STDMETHODIMP SetOpenStatus(HIMC hIMC, BOOL fOpen);

    /*
     * AIMM Conversion Status API Methods
     */
    STDMETHODIMP GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion,  DWORD *lpfdwSentence);
    STDMETHODIMP SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence);

    /*
     * AIMM Status Window Pos API Methods
     */
    STDMETHODIMP GetStatusWindowPos(HIMC hIMC, POINT *lpptPos);
    STDMETHODIMP SetStatusWindowPos(HIMC hIMC, POINT *lpptPos);

    /*
     * AIMM Composition String API Methods
     */
    STDMETHODIMP GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
    STDMETHODIMP SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);

    /*
     * AIMM Composition Font API Methods
     */
    STDMETHODIMP GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);
    STDMETHODIMP SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);

    /*
     * AIMM Composition Window API Methods
     */
    STDMETHODIMP GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);
    STDMETHODIMP SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);

    /*
     * AIMM Candidate List API Methods
     */
    STDMETHODIMP GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);
    STDMETHODIMP GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);

    /*
     * AIMM Candidate Window API Methods
     */
    STDMETHODIMP GetCandidateWindow(HIMC hIMC, DWORD dwBufLen, CANDIDATEFORM *lpCandidate);
    STDMETHODIMP SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate);

    /*
     * AIMM Guide Line API Methods
     */
    STDMETHODIMP GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult);
    STDMETHODIMP GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult);

    /*
     * AIMM Notify IME API Method
     */
    STDMETHODIMP NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    /*
     * AIMM Menu Items API Methods
     */
    STDMETHODIMP GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult);
    STDMETHODIMP GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult);

    /*
     * AIMM Register Word API Methods
     */
    STDMETHODIMP RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister);
    STDMETHODIMP RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister);
    STDMETHODIMP UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister);
    STDMETHODIMP UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister);
    STDMETHODIMP EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum);
    STDMETHODIMP EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum);
    STDMETHODIMP GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied);
    STDMETHODIMP GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied);

    /*
     * AIMM Configuration API Methods.
     */
    STDMETHODIMP ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
    STDMETHODIMP ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);
    STDMETHODIMP GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty);
    STDMETHODIMP IsIME(HKL hKL);

    // others
    STDMETHODIMP EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd);
    STDMETHODIMP GetVirtualKey(HWND hWnd, UINT *puVirtualKey);
    STDMETHODIMP IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);

    // ime helper methods
    STDMETHODIMP GenerateMessage(HIMC hIMC);

    // hot key manipulation api's
    STDMETHODIMP GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL);
    STDMETHODIMP SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL);
    STDMETHODIMP SimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

    // win98/nt5 apis
    STDMETHODIMP DisableIME(DWORD idThread);
    STDMETHODIMP RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum);

    // methods without corresponding IMM APIs

    //
    // IActiveIMMApp methods
    //

    HRESULT Activate(BOOL fRestoreLayout);
    HRESULT Deactivate();

    HRESULT OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    //
    // ITfPreFocusDIM methods
    //
    STDMETHODIMP OnPreFocusDIM(HWND hWnd);
    STDMETHODIMP OnSysKeyboardProc(WPARAM wParam, LPARAM lParam);
    STDMETHODIMP OnSysShellProc(int nCode, WPARAM wParam, LPARAM lParam);

    HRESULT QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IActiveIMMAppEx
    //
    STDMETHODIMP FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap);
    STDMETHODIMP FilterClientWindows(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);
    STDMETHODIMP GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom);
    STDMETHODIMP UnfilterClientWindowsEx(HWND hWnd);

    HRESULT SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
    {
        if (!_pActiveIME)
            return E_FAIL;

        return _pActiveIME->SetThreadCompartmentValue(rguid, pvar);
    }

    HRESULT GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
    {
        if (!_pActiveIME)
            return E_FAIL;

        return _pActiveIME->GetThreadCompartmentValue(rguid, pvar);
    }

    HRESULT _Init();

    void _ActivateLayout(HKL hSelKL = NULL, HKL hUnSelKL = NULL);
    void _DeactivateLayout(HKL hSelKL = NULL, HKL hUnSelKL = NULL);

    HRESULT _GetKeyboardLayout(HKL* phkl);

    HRESULT _AImeAssociateFocus(HWND hWnd, HIMC hIMC, DWORD dwFlags);

    BOOL _ContextLookup(HIMC hIMC, DWORD* pdwProcess, BOOL* pfUnicode = NULL)
    {
        return _InputContext.ContextLookup(hIMC, pdwProcess, pfUnicode);
    }
    BOOL _ContextLookup(HIMC hIMC, HWND* phImeWnd)
    {
        return _InputContext.ContextLookup(hIMC, phImeWnd);
    }

    void _ContextUpdate(HIMC hIMC, HWND& hImeWnd)
    {
        if (!_IsRealIme())
        {
            _InputContext.ContextUpdate(hIMC, hImeWnd);
        }
    }

    HRESULT GetContextInternal(HWND hWnd, HIMC *phIMC, BOOL fGetDefIMC);

    HRESULT _ResizePrivateIMCC(IN HIMC hIMC, IN DWORD dwPrivateSize);

    DWORD _GetIMEWndClassName(HKL hKL, LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate);

    LRESULT _CallWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT _ImeSelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, HIMC hIMC);
    void _ImeWndFinalDestroyHandler();

    LRESULT _SendUIMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE);

    BOOL _IsRealIme(HKL hkl = NULL);

    STDMETHODIMP IsRealImePublic(BOOL *pfReal);

private:

    // windows hooks
#if 0
    static LRESULT CALLBACK _GetMsgProc(int nCode, WPARAM wParam, LPARAM lParam);
#endif
    static LRESULT CALLBACK _CallWndProc(int nCode, WPARAM wParam, LPARAM lParam);

    // windows WH_CALLWNDPROCRET hook for Default IME Window
    static LRESULT CALLBACK _DefImeWnd_CallWndProc(int nCode, WPARAM wParam, LPARAM lParam);

    // EnumInputContext call back methods
    static BOOL _SelectContextProc(HIMC hIMC, LPARAM lParam);
    static BOOL _UnSelectContextProc(HIMC hIMC, LPARAM lParam);
    static BOOL _NotifyIMEProc(HIMC hIMC, LPARAM lParam);
    static BOOL _EnumContextProc(HIMC hIMC, LPARAM lParam);
#ifdef UNSELECTCHECK
    static BOOL _UnSelectCheckProc(HIMC hIMC, LPARAM lParam);
#endif UNSELECTCHECK

    HRESULT _ProcessKey(WPARAM *pwParam, LPARAM *plParam, BOOL fNoMsgPump);
    HRESULT _ToAsciiEx(WPARAM wParam, LPARAM lParam);
    void _KbdTouchUp(BYTE *abKbdState, WPARAM wParam, LPARAM lParam);


    void _AimmPostMessage(HWND, INT, LPTRANSMSG, DIMM_IMCLock&);
    void _AimmSendMessage(HWND, INT, LPTRANSMSG, DIMM_IMCLock&);
    void _AimmPostSendMessageA(HWND, UINT, WPARAM, LPARAM, DIMM_IMCLock&, BOOL fPost = FALSE);

    BOOL IsPresent(HWND hWnd, BOOL fExcludeAIMM)
    {
        BOOL fGuidMap;

        if (_mapFilterWndEx.Lookup(hWnd, fGuidMap)) {
            return TRUE;
        }
        if (g_ProcessIMM)
        {
            return g_ProcessIMM->_FilterList._IsPresent(hWnd, _mapWndFocus, fExcludeAIMM, GetAssociated(hWnd));
        }
        return FALSE;
    }

    BOOL IsGuidMapEnable(HWND hWnd)
    {
        if (_fEnableGuidMap) {
            BOOL fGuidMap;

            if (_mapFilterWndEx.Lookup(hWnd, fGuidMap)) {
                return fGuidMap;
            }
            if (g_ProcessIMM &&
                g_ProcessIMM->_FilterList._IsGuidMapEnable(hWnd, fGuidMap)) {
                return fGuidMap;
            }
        }

        return FALSE;
    }

    HIMC _GetActiveContext()
    {
        HIMC hIMC;

        if (_hFocusWnd == 0)
            return 0;

        return _InputContext.GetContext(_hFocusWnd, &hIMC) == S_OK ? hIMC : 0;
    }

    void _OnImeSelect(HKL hSelKL);
    void _OnImeUnselect(HKL hUnSelKL);
    void _OnImeActivateThreadLayout(HKL hSelKL);

    BOOL _InitHooks();
    void _UninitHooks();

    HRESULT _AImeSelect(HIMC hIMC, DWORD fSelect, BOOL bIsRealIme_SelKL = TRUE, BOOL bIsRealIme_UnSelKL = TRUE)
    {
        DWORD dwFlags = 0;

        if (hIMC == DEFAULT_HIMC)
            hIMC = _InputContext._GetDefaultHIMC();

        if (fSelect)
            dwFlags |= AIMMP_SE_SELECT;

        if (hIMC)
        {
            HRESULT hr;
            DIMM_IMCLock lpIMC(hIMC);
            if (FAILED(hr = lpIMC.GetResult()))
                return hr;

            if (IsPresent(lpIMC->hWnd, TRUE))
                dwFlags |= AIMMP_SE_ISPRESENT;
 
        }
        else
        {
            //
            // Select NULL-hIMC, aimm won't do nothing... So we don't need to
            // set this flag.
            //
            // dwFlags |= AIMMP_SE_ISPRESENT;
        }

        return _pActiveIME->SelectEx(hIMC, dwFlags, bIsRealIme_SelKL, bIsRealIme_UnSelKL);
    }

#ifdef UNSELECTCHECK
    HRESULT _AImeUnSelectCheck(HIMC hIMC)
    {

        if (hIMC == DEFAULT_HIMC)
            hIMC = _InputContext._GetDefaultHIMC();

        return _pActiveIME->UnSelectCheck(hIMC);
    }
#endif UNSELECTCHECK


    HRESULT _AImeNotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
    {
        return _pActiveIME->Notify(hIMC == DEFAULT_HIMC ? _InputContext._GetDefaultHIMC() : hIMC,
                                   dwAction, dwIndex, dwValue);
    }

    HRESULT _ToIMEWindow(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT*& plResult, BOOL fUnicode, BOOL fChkIMC = TRUE);

    void _SetMapWndFocus(HWND hWnd);
    void _ResetMapWndFocus(HWND hWnd);

    BOOL _SetHookWndList(HWND hwnd);
    void _RemoveHookWndList(HWND hwnd)
    {
        _HookWndList.RemoveKey(hwnd);
    }

    typedef enum {
        PROP_PRIVATE_DATA_SIZE,
        PROP_IME_PROPERTY,
        PROP_CONVERSION_CAPS,
        PROP_SENTENCE_CAPS,
        PROP_UI_CAPS,
        PROP_SCS_CAPS,
        PROP_SELECT_CAPS
    } PROPERTY_TYPE;

    DWORD _GetIMEProperty(PROPERTY_TYPE iType);

    DWORD _GetIMEWndClassName(LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate);

    BOOL _IsImeClass(HWND hwnd)
    {
        BOOL bIsImeClass;
        if (_HookWndList.Lookup(hwnd, bIsImeClass))
        {
            return bIsImeClass;
        }
        return _SetHookWndList(hwnd);
    }

    LONG _AddActivate()       { return InterlockedIncrement(&_ActivateRefCount); }
    LONG _ReleaseActivate()   { return InterlockedDecrement(&_ActivateRefCount); }
    BOOL _IsAlreadyActivate() { return (_ActivateRefCount != 0); }

    BOOL _OnSetFocus(HWND hWnd, BOOL bIsRealIme);
    void _OnKillFocus(HWND hWnd, BOOL bIsRealIme);

    BOOL _OnFocusMessage(UINT uMsg, HWND hWnd, WPARAM wParam, LPARAM lParam, BOOL bIsRealIme);

    HRESULT _SendIMENotify(HIMC hImc, HWND hWnd, DWORD dwAction, DWORD dwIndex, DWORD dwValue, WPARAM wParam, LPARAM lParam);

    HRESULT _GetCompositionString(HIMC hIMC,
                                  DWORD dwIndex,
                                  DWORD dwCompLen, LONG* lpCopied, LPVOID lpBuf,
                                  BOOL fUnicode);
    HRESULT _SetCompositionString(HIMC hIMC,
                                  DWORD dwIndex,
                                  LPVOID lpComp, DWORD dwCompLen,
                                  LPVOID lpRead, DWORD dwReadLen,
                                  BOOL fUnicode);

    HRESULT _Internal_SetCompositionString(HIMC hIMC,
                                           DWORD dwIndex,
                                           LPVOID lpComp, DWORD dwCompLen,
                                           LPVOID lpRead, DWORD dwReadLen,
                                           BOOL fUnicode,BOOL fNeedAWConversion);
    HRESULT _Internal_SetCompositionAttribute(HIMC hIMC,
                                              DWORD dwIndex,
                                              LPVOID lpComp, DWORD dwCompLen,
                                              LPVOID lpRead, DWORD dwReadLen,
                                              BOOL fUnicode, BOOL fNeedAWConversion);
    HRESULT _Internal_SetCompositionClause(HIMC hIMC,
                                           DWORD dwIndex,
                                           LPVOID lpComp, DWORD dwCompLen,
                                           LPVOID lpRead, DWORD dwReadLen,
                                           BOOL fUnicode, BOOL fNeedAWConversion);
    HRESULT _Internal_ReconvertString(HIMC hIMC,
                                      DWORD dwIndex,
                                      LPVOID lpComp, DWORD dwCompLen,
                                      LPVOID lpRead, DWORD dwReadLen,
                                      BOOL fUnicode, BOOL fNeedAWConversion,
                                      LRESULT* plResult = NULL);
    HRESULT _Internal_CompositionFont(DIMM_IMCLock& imc,
                                      WPARAM wParam, LPARAM lParam,
                                      BOOL fUnicode, BOOL fNeedAWConversion,
                                      LRESULT* plResult);
    HRESULT _Internal_QueryCharPosition(DIMM_IMCLock& imc,
                                        WPARAM wParam, LPARAM lParam,
                                        BOOL fUnicode, BOOL fNeedAWConversion,
                                        LRESULT* plResult);

    HRESULT _GetCompositionFont(HIMC hIMC, LOGFONTAW* lplf, BOOL fUnicode);
    HRESULT _SetCompositionFont(HIMC hIMC, LOGFONTAW* lplf, BOOL fUnicode);
    HRESULT _Escape(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult, BOOL fUnicode);
    HRESULT _ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
    HRESULT _ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);

    HRESULT _RequestMessage(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult, BOOL fUnicode);

    BOOL _CreateActiveIME();
    BOOL _DestroyActiveIME();

    void LFontAtoLFontW(LPLOGFONTA lpLogFontA, LPLOGFONTW lpLogFontW, UINT uCodePage);
    void LFontWtoLFontA(LPLOGFONTW lpLogFontW, LPLOGFONTA lpLogFontA, UINT uCodePage);


    CMap<HWND, HWND, ITfDocumentMgr *, ITfDocumentMgr *> _mapWndFocus;


public:
    void HideOrRestoreToolbarWnd(BOOL fRestore);

    VOID _EnableGuidMap(BOOL fEnableGuidMap)
    {
        _fEnableGuidMap = fEnableGuidMap;
    }

public:
    BOOL _ConnectTIM(IUnknown *punk)
    {
        ITfThreadMgr *tim = NULL;             
        IServiceProvider *psp;

        Assert(_timp == NULL);

        if (punk->QueryInterface(IID_IServiceProvider, (void **)&psp) == S_OK)
        {
            psp->QueryService(GUID_SERVICE_TF, IID_ITfThreadMgr, (void **)&tim);
            psp->Release();
        }

        if (tim)
        {
            tim->QueryInterface(IID_ITfThreadMgr_P, (void **)&_timp);
            tim->Release();
        }

        return _timp != NULL;
    }

    void _UnconnectTIM()
    {
        SafeReleaseClear(_timp);
    }

    ITfDocumentMgr *GetAssociated(HWND hWnd)
    {
        ITfDocumentMgr *dim = NULL;

        if (_timp != NULL)
        {
            _timp->GetAssociated(hWnd, &dim);
        }
        return dim;
    }

    VOID OnExceptionKillFocus()
    {
        if (_timp != NULL)
        {
            _timp->SetFocus(NULL);
        }
    }

    ITfThreadMgr_P *GetTimP() {return _timp;}

private:
    ITfThreadMgr_P *_timp;

public:
    LONG SetUIWindowContext(HIMC hIMC) {
        return _UIWindow.SetUIWindowContext(hIMC);
    }

private:
    CMap<HWND, HWND, BOOL, BOOL>                         _mapFilterWndEx;


    LONG                        _ActivateRefCount;      // Activate reference count.
#if 0
    BOOL                        _fMenuSelected : 1;     // TRUE: windows menu is opened
#endif
    BOOL                        _fEnableGuidMap : 1;    // TRUE: Enable GUID Map attribute

    HWND                        _hFocusWnd;
    HHOOK                       _hHook[TH_NUMHOOKS];
    CMap<HKL, HKL, BOOL, BOOL>  _RealImeList;

    IAImeProfile*               _AImeProfile;

    IActiveIME_Private *        _pActiveIME;
    CMap<HWND, HWND, BOOL, BOOL> _HookWndList;
    CUIWindow                   _UIWindow;
    CDefaultIMEWindow           _DefaultIMEWindow;
    CInputContext               _InputContext; // consider: take a back pointer, make this a derived class or merge
    IMEINFOEX                   _IMEInfoEx;

    LONG                        _cRef;

    // for HideOrRestoreToolbar
    DWORD _dwPrevToolbarStatus;
};

#endif // CDIMM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\context.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    context.cpp

Abstract:

    This file implements the Input Context Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"
#include "context.h"
#include "globals.h"
#include "defs.h"
#include "delay.h"
#include "computil.h"


BOOL
CInputContext::_CreateDefaultInputContext(
    IN DWORD dwPrivateSize,
    IN BOOL fUnicode,
    IN BOOL fCiceroActivated
    )

/*++

Routine Description:

    Create a default input context

Arguments:

    dwPrivateSize - [in] Unsigned integer long value that contains the size of private IMCC
                         data.

Return Value:

    Returns TRUE if successful, or an error code otherwise.

--*/

{
    // create a default IMC for this thread
    if (IsOnImm()) {
        // On FE systems, we use system allocated HIMCs
        // but here we want to use the thread default HIMC
        // which the system has already allocated.

        CActiveIMM *_pActiveIMM = GetTLS();
        if (_pActiveIMM == NULL)
            return FALSE;

        // consider: find a better way to get the def HIMC!
        HWND hWnd = CreateWindow(TEXT("STATIC"), TEXT(""), WS_DISABLED | WS_POPUP,
                                 0, 0, 0, 0, 0, 0, g_hInst, NULL);
        if (hWnd)
        {
            Imm32_GetContext(hWnd, &_hDefaultIMC);
            if (_hDefaultIMC)
                Imm32_ReleaseContext(hWnd, _hDefaultIMC);

            DestroyWindow(hWnd);
        }

        if (_hDefaultIMC == NULL)
            return FALSE;

        CContextList::CLIENT_IMC_FLAG client_flag = (fUnicode ? CContextList::IMCF_UNICODE
                                                              : CContextList::IMCF_NONE   );
        ContextList.SetAt(_hDefaultIMC, client_flag);

        // we can't create the cicero context until ITfThreadMgr::Activate has been called
        // we'll do this later if we need to
        if (fCiceroActivated)
        {
            if (FAILED(CreateAImeContext(_hDefaultIMC))) {
                ContextList.RemoveKey(_hDefaultIMC);
                return FALSE;
            }
        }

        _pActiveIMM->_ResizePrivateIMCC(_hDefaultIMC, dwPrivateSize);
    }
    else {
        if (FAILED(CreateContext(dwPrivateSize, fUnicode, &_hDefaultIMC, fCiceroActivated)))
            return FALSE;
    }

    return TRUE;
}

BOOL
CInputContext::_DestroyDefaultInputContext(
    )
{
    // destroy a default IMC for this thread
    if (! IsOnImm()) {
        if (FAILED(DestroyContext(_hDefaultIMC)))
            return FALSE;
    }
    else {
        if (FAILED(DestroyAImeContext(_hDefaultIMC)))
            return FALSE;
    }

    return TRUE;
}

HRESULT
CInputContext::UpdateInputContext(
    IN HIMC hIMC,
    IN DWORD dwPrivateDataSize
    )
{
    HRESULT hr;

    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    /*
     * hPrivate
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hPrivate, dwPrivateDataSize))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hRivate failure");
        return hr;
    }

    /*
     * hMsgBuf
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hMsgBuf, sizeof(UINT)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hMsgBuf failure");
        return hr;
    }

    lpIMC->dwNumMsgBuf = 0;

    /*
     * hGuideLine
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hGuideLine, sizeof(GUIDELINE)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hGuideLine failure");
        return hr;
    }

    DIMM_IMCCLock<GUIDELINE> pGuideLine(lpIMC->hGuideLine);
    if (FAILED(hr = pGuideLine.GetResult())) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: can not lock hGuideLine");
        return hr;
    }

    pGuideLine->dwSize = sizeof(GUIDELINE);

    /*
     * hCandInfo
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hCandInfo, sizeof(CANDIDATEINFO)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hCandInfo failure");
        return hr;
    }

    DIMM_IMCCLock<CANDIDATEINFO> pCandInfo(lpIMC->hCandInfo);
    if (FAILED(hr = pCandInfo.GetResult())) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: can not lock hCandInfo");
        return hr;
    }

    pCandInfo->dwSize = sizeof(CANDIDATEINFO);

    /*
     * hCompStr
     */
    if (FAILED(hr = UpdateIMCC(&lpIMC->hCompStr, sizeof(COMPOSITIONSTRING_AIMM12)))) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: hIMCC::hCompStr failure");
        return hr;
    }

    DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12> lpCompStr(lpIMC->hCompStr);
    if (FAILED(hr = lpCompStr.GetResult())) {
        TraceMsg(TF_ERROR, "CInputContext::UpdateInputContext: can not lock hCompStr");
        return hr;
    }

    lpCompStr->CompStr.dwSize = sizeof(COMPOSITIONSTRING_AIMM12);

    /*
     * AIME private context.
     */
    if (lpIMC->m_pContext != NULL) {
        hr = lpIMC->m_pContext->UpdateAImeContext(hIMC);
    }

    return hr;
}

HRESULT
CInputContext::ResizePrivateIMCC(
    IN HIMC hIMC,
    IN DWORD dwPrivateSize
    )
{
    HRESULT hr;

    // Make sure Private context data size
    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    return UpdateIMCC(&imc->hPrivate, dwPrivateSize);
}

HRESULT
CInputContext::UpdateIMCC(
    IN HIMCC* phIMCC,
    IN DWORD  dwRequestSize
    )
{
    HRESULT hr;
    DWORD dwSize;
    DWORD dwLockCount;
    const DWORD IMCC_ALLOC_TOOLARGE = 0x1000;

    if (*phIMCC == NULL) {
        hr = CreateIMCC(dwRequestSize, phIMCC);
    }
    else {

        hr = GetIMCCSize(*phIMCC, &dwSize);
        if (SUCCEEDED(hr)) {
            if (dwSize < dwRequestSize ||
                dwSize > IMCC_ALLOC_TOOLARGE) {
                hr = GetIMCCLockCount(*phIMCC, &dwLockCount);
                if (SUCCEEDED(hr)) {
                    ASSERT(dwLockCount == 0);
                    if (dwLockCount != 0) {
                        TraceMsg(TF_ERROR, "CInputContext::UpdateIMCC: Unlock resource");

                        do {
                            if (FAILED(hr = _UnlockIMCC(*phIMCC)))
                                return hr;

                            if (FAILED(hr = GetIMCCLockCount(*phIMCC, &dwLockCount)))
                                return hr;
                        } while(dwLockCount);

                        if (SUCCEEDED(hr = DestroyIMCC(*phIMCC)))
                            hr = CreateIMCC(dwRequestSize, phIMCC);
                    }
                    else {
                        HIMCC hResizeIMCC;
                        hr = ReSizeIMCC(*phIMCC, dwRequestSize, &hResizeIMCC);
                        if (SUCCEEDED(hr)) {
                            *phIMCC = hResizeIMCC;
                        }
                        else {
                            TraceMsg(TF_WARNING, "CInputContext::UpdateIMCC: Resize hIMCC %lX failure", dwRequestSize);

                            if (SUCCEEDED(hr = DestroyIMCC(*phIMCC)))
                                hr = CreateIMCC(dwRequestSize, phIMCC);
                        }
                    }
                }
            }
        }
    }

    return hr;
}


BOOL
CInputContext::EnumInputContext(
    DWORD idThread,
    IMCENUMPROC lpfn,
    LPARAM lParam
    )
{
    UINT cHimc;

    /*
     * Get the hIMC list. It is returned in a block of memory allocated.
     */
    if ((cHimc = BuildHimcList(idThread, NULL)) == 0) {
        return FALSE;
    }

    BOOL fSuccess = FALSE;

    HIMC* pHimc = new HIMC[cHimc];
    if (pHimc) {
        BuildHimcList(idThread, pHimc);

        /*
         * Loop through the input contexts, call the function pointer back for each one.
         * End loop if either FALSE is returned or the end-of-list is reached.
         */
        UINT index;
        for (index = 0; index < cHimc; index++) {
            if (! (fSuccess = (*lpfn)(pHimc[index], lParam)) )
                break;
        }

        /*
         * Free up buffer and return status - TRUE if entire list was enumerated,
         * FALSE otherwise.
         */
        delete [] pHimc;
    }

    return fSuccess;
}

DWORD
CInputContext::BuildHimcList(
    DWORD idThread,
    HIMC pHimc[]
    )
{
    if (idThread != 0 && idThread != GetCurrentThreadId())
        return 0;

    if (pHimc != NULL) {
        POSITION pos = ContextList.GetStartPosition();
        int index;
        for (index = 0; index < ContextList.GetCount(); index++) {
            ContextList.GetNextHimc(pos, &pHimc[index]);
        }
    }
    return (DWORD)(ContextList.GetCount());
}

/*
 * AIMM Input Context (hIMC) API Methods.
 */
HRESULT
CInputContext::CreateContext(
    IN DWORD dwPrivateSize,
    IN BOOL fUnicode,
    OUT HIMC *phIMC,
    IN BOOL fCiceroActivated,
    IN DWORD fdwInitConvMode,
    IN BOOL fInitOpen
    )
{
    TraceMsg(TF_API, TEXT("CInputContext::CreateContext"));

    *phIMC = NULL;

    if (IsOnImm()) {

        // defer to the system IMM
        HRESULT hr;
        CActiveIMM *_pActiveIMM = GetTLS();
        if (_pActiveIMM == NULL)
            return E_FAIL;

        if (FAILED(hr = Imm32_CreateContext(phIMC)))
            return hr;

        CContextList::CLIENT_IMC_FLAG client_flag = (fUnicode ? CContextList::IMCF_UNICODE
                                                              : CContextList::IMCF_NONE   );
        ContextList.SetAt(*phIMC, client_flag);

        // we can't create the cicero context until ITfThreadMgr::Activate has been called
        // we'll do this later if we need to
        if (fCiceroActivated)
        {
            if (FAILED(hr=CreateAImeContext(*phIMC))) {
                Imm32_DestroyContext(*phIMC);
                ContextList.RemoveKey(*phIMC);
                return hr;
            }
        }

        _pActiveIMM->_ResizePrivateIMCC(*phIMC, dwPrivateSize);
    }
    else {
        HIMC hIMC = static_cast<HIMC>(LocalAlloc(LHND, sizeof(INPUTCONTEXT_AIMM12)));

        CContextList::CLIENT_IMC_FLAG client_flag = (fUnicode ? CContextList::IMCF_UNICODE
                                                              : CContextList::IMCF_NONE   );
        ContextList.SetAt(hIMC, client_flag);

        /*
         * Ready to use hIMC
         */
        DIMM_IMCLock lpIMC(hIMC);
        if (lpIMC.Valid()) {
            //
            // Initialize context data.
            //
            lpIMC->dwNumMsgBuf = 0;
            lpIMC->fOpen = fInitOpen;
            lpIMC->fdwConversion = fdwInitConvMode;
            lpIMC->fdwSentence = 0;
            lpIMC->m_pContext = NULL;

            for (UINT i = 0; i < 4; i++) {
                lpIMC->cfCandForm[i].dwIndex = (DWORD)(-1);
            }

            HRESULT hr;

            // we can't create the cicero context until ITfThreadMgr::Activate has been called
            // we'll do this later if we need to
            if (fCiceroActivated)
            {
                if (FAILED(hr=CreateAImeContext(hIMC))) {
                    DestroyContext(hIMC);
                    return hr;
                }
            }

            if (FAILED(CreateIMCC(sizeof(COMPOSITIONSTRING_AIMM12), &lpIMC->hCompStr)) ||
                FAILED(CreateIMCC(sizeof(CANDIDATEINFO), &lpIMC->hCandInfo))           ||
                FAILED(CreateIMCC(sizeof(GUIDELINE), &lpIMC->hGuideLine))              ||
                FAILED(CreateIMCC(sizeof(DWORD), &lpIMC->hMsgBuf))                     ||
                FAILED(CreateIMCC(dwPrivateSize, &lpIMC->hPrivate))                       ) {

                DestroyContext((HIMC)lpIMC);

                return E_OUTOFMEMORY;
            }
            else {
                *phIMC = hIMC;
            }
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

HRESULT
CInputContext::DestroyContext(
    IN HIMC hIMC
    )
{
    TraceMsg(TF_API, "CInputContext::DestroyContext");

    if (IsOnImm()) {
        HRESULT hr;

        if (FAILED(hr=DestroyAImeContext(hIMC)))
            return hr;

        ContextList.RemoveKey(hIMC);

        return Imm32_DestroyContext(hIMC);
    }
    else {
        {
            DIMM_IMCLock pIMC(hIMC);
            if (!pIMC.Valid())
                return E_FAIL;

            if (FAILED(DestroyIMCC(pIMC->hCompStr))   ||
                FAILED(DestroyIMCC(pIMC->hCandInfo))  ||
                FAILED(DestroyIMCC(pIMC->hGuideLine)) ||
                FAILED(DestroyIMCC(pIMC->hMsgBuf))    ||
                FAILED(DestroyIMCC(pIMC->hPrivate))     ) {
                return E_FAIL;
            }
            HRESULT hr;
            if (FAILED(hr=DestroyAImeContext(hIMC)))
                return hr;

            ContextList.RemoveKey(hIMC);
        } // pIMC dtor called here!  We must unlock hIMC before calling LocalFree

        return LocalFree(hIMC) ? E_FAIL : S_OK;
    }
}

HRESULT
CInputContext::AssociateContext(
    IN HWND hWnd,
    IN HIMC hIMC,
    OUT HIMC *phPrev
    )
{
    TraceMsg(TF_API, "CInputContext::AssociateContext");

    if (!IsWindow(hWnd))
        return E_INVALIDARG;

    DWORD dwProcessId;
    if (hIMC && ! ContextLookup(hIMC, &dwProcessId))
        return E_ACCESSDENIED;

    HRESULT hr = GetContext(hWnd, phPrev);

    AssociateList.SetAt(hWnd, hIMC);

    return hr;
}

HRESULT
CInputContext::AssociateContextEx(
    IN HWND hWnd,
    IN HIMC hIMC,
    IN DWORD dwFlags
    )
{
    TraceMsg(TF_API, "CInputContext::AssociateContextEx");
    return E_NOTIMPL;
}

HRESULT
CInputContext::GetContext(
    IN HWND hWnd,
    OUT HIMC* phIMC
    )
{
    TraceMsg(TF_API, "CInputContext::GetContext");

    if (hWnd == NULL || ! IsWindow(hWnd)) {
        TraceMsg(TF_WARNING, "CInputContext::GetContext: Invalid window handle %x", hWnd);
        return E_FAIL;
    }

    HIMC hIMC = _hDefaultIMC;
    BOOL ret = AssociateList.Lookup(hWnd, hIMC);
    if (! ret) {
        if (IsOnImm()) {
            Imm32_GetContext(hWnd, &hIMC);

            if (hIMC) {
                /*
                 * Guaranty of Win98 IMM code that Win98 have a reference count
                 * of GetContext/ReleaseContext. If under ref cnt occurred, then
                 * apps had the AV in the IMM code.
                 * Because it ref cnt keeps the 32bit hIMC data segment for refer
                 * from 16bit code. When ref cnt is zero, hIMC's data segment has been freed.
                 * Of course, AIMM1.2's ReleaseContext nothing else to do.
                 */
                Imm32_ReleaseContext(hWnd, hIMC);
            }
        }
    }
    *phIMC = hIMC;

    return S_OK;
}

HRESULT
CInputContext::GetIMCLockCount(
    IN HIMC hIMC,
    OUT DWORD* pdwLockCount
    )
{
    TraceMsg(TF_API, "CInputContext::GetIMCLockCount");

    if (IsOnImm()) {
        return Imm32_GetIMCLockCount(hIMC, pdwLockCount);
    }
    else {
        *pdwLockCount = LocalFlags(hIMC) & LMEM_LOCKCOUNT;
        return S_OK;
    }
}

HRESULT
CInputContext::CreateAImeContext(
    HIMC hIMC
    )
{
    HRESULT hr;

    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    IAImeContext* pAImeContext;
    extern HRESULT CAImeContext_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    hr = CAImeContext_CreateInstance(NULL, IID_IAImeContext, (void**)&pAImeContext);

    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CreateAImeContext failed");
        return hr;
    }

    return pAImeContext->CreateAImeContext(hIMC, m_pActiveIME);
}

HRESULT
CInputContext::DestroyAImeContext(
    HIMC hIMC
    )
{
    HRESULT hr;
    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    // imc->m_pContext may be NULL if ITfThreadMgr::Activate has not been called
    if (imc->m_pContext == NULL)
        return S_OK;

    //
    // Backup IAImeContext pointer and NULL out in imc->m_pContext.
    // DestroyAImeContext::pdim->Pop maybe calls ActivateAssembly if it is in queueing.
    // ActivateAssembly maybe changes keyboard layout between Cicero and Real IME hKL.
    // It happens called ImeActivateLayout from IMM32 and this function updates input context.
    // However, imc->m_pContext's object already gone and occurred AV when touch NULL object.
    // This NULL out is previent AV in the imc->m_pContext object.
    //
    IAImeContext* pContext = imc->m_pContext;
    imc->m_pContext = NULL;

    hr = pContext->DestroyAImeContext(hIMC);

    pContext->Release();

    return hr;
}


/*
 * AIMM Input Context Components (hIMCC) API Methods.
 */
HRESULT
CInputContext::CreateIMCC(
    IN DWORD dwSize,
    OUT  HIMCC *phIMCC
    )
{
    TraceMsg(TF_API, "CInputContext::CreateIMCC");

    if (IsOnImm()) {
        return Imm32_CreateIMCC(dwSize, phIMCC);
    }
    else {
        if ((*phIMCC = static_cast<HIMCC>(LocalAlloc(LHND, dwSize+sizeof(DWORD)))) == NULL)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CInputContext::DestroyIMCC(
    IN HIMCC hIMCC
    )
{
    TraceMsg(TF_API, "CInputContext::DestroyIMCC");

    if (IsOnImm()) {
        return Imm32_DestroyIMCC(hIMCC);
    }
    else {
        return LocalFree(hIMCC) ? E_FAIL : S_OK;
    }

    return S_OK;
}

HRESULT
CInputContext::GetIMCCSize(
    IN HIMCC hIMCC,
    OUT DWORD *pdwSize
    )
{
    TraceMsg(TF_API, "CInputContext::GetIMCCSize");

    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    if (IsOnImm()) {
        return Imm32_GetIMCCSize(hIMCC, pdwSize);
    }
    else {
        *pdwSize = (DWORD)LocalSize(hIMCC);
    }

    return S_OK;
}

HRESULT
CInputContext::ReSizeIMCC(
    IN HIMCC hIMCC,
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )
{
    TraceMsg(TF_API, "CInputContext::ReSizeIMCC");

    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    if (IsOnImm()) {
        return Imm32_ReSizeIMCC(hIMCC, dwSize, phIMCC);
    }
    else {
        if ((*phIMCC = (HIMCC)LocalReAlloc(hIMCC, dwSize+sizeof(DWORD), LHND)) == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

HRESULT
CInputContext::GetIMCCLockCount(
    IN HIMCC hIMCC,
    OUT DWORD* pdwLockCount
    )
{
    TraceMsg(TF_API, "CInputContext::GetIMCLockCount");

    if (IsOnImm()) {
        return Imm32_GetIMCCLockCount(hIMCC, pdwLockCount);
    }
    else {
        *pdwLockCount = LocalFlags(hIMCC) & LMEM_LOCKCOUNT;
        return S_OK;
    }
}


/*
 * AIMM Open Status API Methods
 */
HRESULT
CInputContext::GetOpenStatus(
    IN HIMC hIMC
    )
{
    TraceMsg(TF_API, "CInputContext::GetOpenStatus");

    DIMM_IMCLock lpIMC(hIMC);
    if (lpIMC.Invalid())
        return E_FAIL;

    return (lpIMC->fOpen ? S_OK : S_FALSE);
}

HRESULT
CInputContext::SetOpenStatus(
    IN DIMM_IMCLock& lpIMC,
    IN BOOL fOpen,
    OUT BOOL* pfOpenChg
    )
{
    DWORD dwOpenStatus;
    DWORD dwConversion;

    TraceMsg(TF_API, "CInputContext::SetOpenStatus");

    *pfOpenChg = FALSE;

    if (lpIMC->fOpen != fOpen) {
        lpIMC->fOpen = fOpen;
        *pfOpenChg = TRUE;
    }

    if (*pfOpenChg) {
        dwOpenStatus = (DWORD)lpIMC->fOpen;
        dwConversion = (DWORD)lpIMC->fdwConversion;
    }

    return S_OK;
}

/*
 * AIMM Conversion Status API Methods
 */
HRESULT
CInputContext::GetConversionStatus(
    IN HIMC hIMC,
    OUT LPDWORD lpfdwConversion,
    OUT LPDWORD lpfdwSentence
    )
{
    TraceMsg(TF_API, "CInputContext::GetConversionStatus");

    if (IsOnImm()) {
        return Imm32_GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
    }

    DIMM_IMCLock pIMC(hIMC);
    if (pIMC.Invalid())
        return E_FAIL;

    *lpfdwSentence = pIMC->fdwSentence;
    *lpfdwConversion = pIMC->fdwConversion;

    return S_OK;
}

HRESULT
CInputContext::SetConversionStatus(
    IN DIMM_IMCLock& lpIMC,
    IN DWORD fdwConversion,
    IN DWORD fdwSentence,
    OUT BOOL* pfConvModeChg,
    OUT BOOL* pfSentenceChg,
    OUT DWORD* pfdwOldConversion,
    OUT DWORD* pfdwOldSentence
    )
{
    DWORD dwOpenStatus;
    DWORD dwConversion;

    TraceMsg(TF_API, "CInputContext::SetConversionStatus");

    if (fdwConversion != lpIMC->fdwConversion) {
        if ((fdwConversion & IME_CMODE_LANGUAGE) == IME_CMODE_KATAKANA) {
            TraceMsg(TF_WARNING, "SetConversionStatus: wrong fdwConversion");
        }
        *pfdwOldConversion = lpIMC->fdwConversion;
        lpIMC->fdwConversion = fdwConversion;
        *pfConvModeChg = TRUE;
    }

    if (fdwSentence != lpIMC->fdwSentence) {
        *pfdwOldSentence = lpIMC->fdwSentence;
        lpIMC->fdwSentence = fdwSentence;
        *pfSentenceChg = TRUE;
    }

    if (*pfConvModeChg) {
        dwOpenStatus = (DWORD)lpIMC->fOpen;
        dwConversion = lpIMC->fdwConversion;
    }

    return S_OK;
}

/*
 * AIMM Status Window Pos API Methods
 */
HRESULT WINAPI
CInputContext::GetStatusWindowPos(
    IN HIMC hIMC,
    OUT LPPOINT lpCandidate
    )
{
    TraceMsg(TF_API, "CInputContext::GetStatusWindowPos");

    if (IsOnImm()) {
        return Imm32_GetStatusWindowPos(hIMC, lpCandidate);
    }

    if (hIMC == NULL)
        return E_INVALIDARG;

    DIMM_IMCLock pIMC(hIMC);
    if (pIMC.Invalid())
        return E_FAIL;

    if (pIMC->fdwInit & INIT_STATUSWNDPOS) {
        *lpCandidate = pIMC->ptStatusWndPos;
        return S_OK;
    }

    return E_FAIL;
}

HRESULT
CInputContext::SetStatusWindowPos(
    IN DIMM_IMCLock& lpIMC,
    IN LPPOINT lpptPos
    )
{
    TraceMsg(TF_API, "CInputContext::SetStatusWindowPos");

    lpIMC->ptStatusWndPos = *lpptPos;
    lpIMC->fdwInit |= INIT_STATUSWNDPOS;

    return S_OK;
}

/*
 * AIMM Composition String API Methods
 */
HRESULT
CInputContext::GetCompositionString(
    IN DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
    IN DWORD dwIndex,
    IN LONG*& lpCopied,
    IN size_t size
    )
{
    HRESULT hr;

    TraceMsg(TF_API, "CInputContext::GetCompositionStringA(LONG*)");

    switch (dwIndex) {
        case GCS_COMPSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompStrLen, lpCopied);
            break;
        case GCS_COMPREADSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompReadStrLen, lpCopied);
            break;
        case GCS_RESULTSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultStrLen, lpCopied);
            break;
        case GCS_RESULTREADSTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultReadStrLen, lpCopied);
            break;

        case GCS_COMPATTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompAttrLen, lpCopied);
            break;
        case GCS_COMPREADATTR:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompReadAttrLen, lpCopied);
            break;
        case GCS_COMPREADCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompReadClauseLen, lpCopied);
            break;
        case GCS_RESULTCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultClauseLen, lpCopied);
            break;
        case GCS_RESULTREADCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwResultReadClauseLen, lpCopied);
            break;
        case GCS_COMPCLAUSE:
            hr = GetCompInfo(size, lpCompStr->CompStr.dwCompClauseLen, lpCopied);
            break;

        case GCS_CURSORPOS:
            *lpCopied = lpCompStr->CompStr.dwCursorPos;
            hr = S_OK;
            break;
        case GCS_DELTASTART:
            *lpCopied = lpCompStr->CompStr.dwDeltaStart;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            *lpCopied = IMM_ERROR_GENERAL; // ala Win32
            break;
    }

    return hr;
}


/*
 * AIMM Composition Font API Methods
 */
HRESULT
CInputContext::GetCompositionFont(
    IN DIMM_IMCLock& lpIMC,
    OUT LOGFONTAW* lplf,
    IN BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetCompositionFont");

    if ((lpIMC->fdwInit & INIT_LOGFONT) == INIT_LOGFONT) {
        if (fUnicode)
            *(&lplf->W) = lpIMC->lfFont.W;
        else
            *(&lplf->A) = lpIMC->lfFont.A;
        return S_OK;
    }

    return E_FAIL;
}

HRESULT
CInputContext::SetCompositionFont(
    IN DIMM_IMCLock& lpIMC,
    IN LOGFONTAW* lplf,
    IN BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::SetCompositionFont");

    if (fUnicode)
        lpIMC->lfFont.W = *(&lplf->W);
    else
        lpIMC->lfFont.A = *(&lplf->A);
    lpIMC->fdwInit |= INIT_LOGFONT;

    return S_OK;
}


/*
 * AIMM Composition Window API Method
 */
HRESULT
CInputContext::GetCompositionWindow(
    IN HIMC hIMC,
    OUT LPCOMPOSITIONFORM lpCompForm
    )
{
    TraceMsg(TF_API, "CInputContext::GetCompositionWindow");

    if (IsOnImm()) {
        return Imm32_GetCompositionWindow(hIMC, lpCompForm);
    }
    else {
        HRESULT hr;
        DIMM_IMCLock pIMC(hIMC);
        if (FAILED(hr = pIMC.GetResult()))
            return hr;

        if ((pIMC->fdwInit & INIT_COMPFORM) == INIT_COMPFORM) {
            *lpCompForm = pIMC->cfCompForm;
            return S_OK;
        }
    }
    return E_FAIL;

}

HRESULT
CInputContext::SetCompositionWindow(
    IN DIMM_IMCLock& lpIMC,
    IN LPCOMPOSITIONFORM lpCompForm
    )
{
    TraceMsg(TF_API, "CInputContext::SetCompositionWindow");

    lpIMC->cfCompForm = *lpCompForm;
    lpIMC->fdwInit |= INIT_COMPFORM;

    return S_OK;
}

/*
 * AIMM Candidate List API Methods
 */
HRESULT
CInputContext::GetCandidateList(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPCANDIDATELIST lpCandList,
    OUT UINT* puCopied,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetCandidateList");
    return E_NOTIMPL;
}

HRESULT
CInputContext::GetCandidateListCount(
    IN HIMC hIMC,
    OUT DWORD* lpdwListSize,
    OUT DWORD* pdwBufLen,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetCandidateListCount");
    return E_NOTIMPL;
}

/*
 * AIMM Candidate Window API Methods
 */
HRESULT
CInputContext::GetCandidateWindow(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    OUT LPCANDIDATEFORM lpCandidate
    )
{
    TraceMsg(TF_API, "CInputContext::GetCandidateWindow");

    if (IsOnImm()) {
        return Imm32_GetCandidateWindow(hIMC, dwIndex, lpCandidate);
    }
    else {
        HRESULT hr;
        DIMM_IMCLock pIMC(hIMC);
        if (FAILED(hr = pIMC.GetResult()))
            return hr;

        if (pIMC->cfCandForm[dwIndex].dwIndex == -1) {
            return E_FAIL;
        }

        *lpCandidate = pIMC->cfCandForm[dwIndex];
    }

    return S_OK;
}

HRESULT
CInputContext::SetCandidateWindow(
    IN DIMM_IMCLock& lpIMC,
    IN LPCANDIDATEFORM lpCandForm
    )
{
    TraceMsg(TF_API, "CInputContext::SetCandidateWindow");
    lpIMC->cfCandForm[lpCandForm->dwIndex] = *lpCandForm;
    return S_OK;
}

/*
 * AIMM Guide Line API Methods
 */
HRESULT
CInputContext::GetGuideLine(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT CHARAW* lpBuf,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetGuideLine");
    return E_NOTIMPL;
}


/*
 * AIMM Notify IME API Method
 */
HRESULT
CInputContext::NotifyIME(
    IN HIMC hIMC,
    IN DWORD dwAction,
    IN DWORD dwIndex,
    IN DWORD dwValue
    )
{
    TraceMsg(TF_API, "CInputContext::NotifyIME");

    if (IsOnImm()) {
        return Imm32_NotifyIME(hIMC, dwAction, dwIndex, dwValue);
    }
    return E_NOTIMPL;
}

/*
 * AIMM Menu Items API Methods
 */
HRESULT
CInputContext::GetImeMenuItems(
    IN HIMC hIMC,
    IN DWORD dwFlags,
    IN DWORD dwType,
    IN IMEMENUITEMINFOAW *pImeParentMenu,
    OUT IMEMENUITEMINFOAW *pImeMenu,
    IN DWORD dwSize,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    TraceMsg(TF_API, "CInputContext::GetImeMenuItems");
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\cimm32.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imm32.cpp

Abstract:

    This file implements the IMM32 class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cimm32.h"

HRESULT
Imm32_CreateContext(
    OUT HIMC *phIMC
    )
{
    HIMC hIMC = imm32::ImmCreateContext();
    if (hIMC) {
        *phIMC = hIMC;
        return S_OK;
    }
    return E_FAIL;
}

HRESULT
Imm32_DestroyContext(
    IN HIMC hIMC
    )
{
    return (imm32::ImmDestroyContext(hIMC)) ? S_OK
                                            : E_FAIL;
}

HRESULT
Imm32_LockIMC(
    HIMC hIMC,
    OUT INPUTCONTEXT **ppIMC
    )
{
    return (*ppIMC = imm32::ImmLockIMC(hIMC)) ? S_OK
                                              : E_FAIL;
}

HRESULT
Imm32_UnlockIMC(
    IN HIMC hIMC
    )
{
    imm32::ImmUnlockIMC(hIMC);
    return S_OK;
}

HRESULT
Imm32_GetIMCLockCount(
    IN HIMC hIMC,
    OUT DWORD* pdwLockCount
    )
{
    *pdwLockCount = imm32::ImmGetIMCLockCount(hIMC);
    return S_OK;
}

HRESULT
Imm32_AssociateContext(
    IN HWND hWnd,
    IN HIMC hIMC,
    OUT HIMC *phPrev
    )
{
    *phPrev = imm32::ImmAssociateContext(hWnd, hIMC);
    return S_OK;
}

HRESULT
Imm32_AssociateContextEx(
    IN HWND hWnd,
    IN HIMC hIMC,
    IN DWORD dwFlags
    )
{
    return (imm32::ImmAssociateContextEx(hWnd, hIMC, dwFlags)) ? S_OK
                                                               : E_FAIL;
}

HRESULT
Imm32_GetContext(
    IN HWND hWnd,
    OUT HIMC *phIMC
    )
{
    *phIMC = imm32::ImmGetContext(hWnd);
    return S_OK;
}

HRESULT
Imm32_ReleaseContext(
    IN HWND hWnd,
    IN HIMC hIMC
    )
{
    return (imm32::ImmReleaseContext(hWnd, hIMC)) ? S_OK
                                                  : E_FAIL;
}

HRESULT
Imm32_CreateIMCC(
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )
{
    HIMCC hIMCC = imm32::ImmCreateIMCC(dwSize);
    if (hIMCC) {
        *phIMCC = hIMCC;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_DestroyIMCC(
    IN HIMCC hIMCC
    )
{
    /*
     * ImmDestroyIMCC maped to LocalFree.
     *   if the function fails, the return value is equal to a handle to the local memory object.
     *   if the function succeeds, the return value is NULL.
     */
    return (imm32::ImmDestroyIMCC(hIMCC)) ? E_FAIL
                                          : S_OK;
}

HRESULT
Imm32_LockIMCC(
    IN HIMCC hIMCC,
    OUT void **ppv
    )
{
    return (*ppv = imm32::ImmLockIMCC(hIMCC)) ? S_OK
                                              : E_FAIL;
}

HRESULT
Imm32_UnlockIMCC(
    IN HIMCC hIMCC
    )
{
    if (imm32::ImmUnlockIMCC(hIMCC)) {
        // memory object still locked.
        return S_OK;
    }
    else {
        DWORD err = GetLastError();
        if (err == NO_ERROR)
            // memory object is unlocked.
            return S_OK;
        else if (err == ERROR_NOT_LOCKED)
            // memory object is already unlocked.
            return S_OK;
    }
    return E_FAIL;
}

HRESULT
Imm32_GetIMCCSize(
    IN HIMCC hIMCC,
    OUT DWORD *pdwSize
    )
{
    *pdwSize = imm32::ImmGetIMCCSize(hIMCC);
    return S_OK;
}

HRESULT
Imm32_ReSizeIMCC(
    IN HIMCC hIMCC,
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )
{
    HIMCC hNewIMCC = imm32::ImmReSizeIMCC(hIMCC, dwSize);
    if (hNewIMCC) {
        *phIMCC = hNewIMCC;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_GetIMCCLockCount(
    IN HIMCC hIMCC,
    OUT DWORD* pdwLockCount
    )
{
    *pdwLockCount = imm32::ImmGetIMCCLockCount(hIMCC);
    return S_OK;
}

HRESULT
Imm32_GetOpenStatus(
    IN HIMC hIMC
    )
{
    return imm32::ImmGetOpenStatus(hIMC) ? S_OK : S_FALSE;
}

HRESULT
Imm32_SetOpenStatus(
    HIMC hIMC,
    BOOL fOpen
    )
{
    return (imm32::ImmSetOpenStatus(hIMC, fOpen)) ? S_OK
                                                  : E_FAIL;
}

HRESULT
Imm32_GetConversionStatus(
    IN HIMC hIMC,
    OUT DWORD *lpfdwConversion,
    OUT DWORD *lpfdwSentence
    )
{
    return (imm32::ImmGetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence)) ? S_OK
                                                                                 : E_FAIL;
}

HRESULT
Imm32_SetConversionStatus(
    IN HIMC hIMC,
    IN DWORD fdwConversion,
    IN DWORD fdwSentence
    )
{
    return (imm32::ImmSetConversionStatus(hIMC, fdwConversion, fdwSentence)) ? S_OK
                                                                             : E_FAIL;
}

HRESULT
Imm32_GetStatusWindowPos(
    IN HIMC hIMC,
    OUT POINT *lpptPos
    )
{
    return (imm32::ImmGetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                         : E_FAIL;
}

HRESULT
Imm32_SetStatusWindowPos(
    IN HIMC hIMC,
    IN POINT *lpptPos
    )
{
    return (imm32::ImmSetStatusWindowPos(hIMC, lpptPos)) ? S_OK
                                                         : E_FAIL;
}

HRESULT
Imm32_GetCompositionString(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwCompLen,
    OUT LONG*& lpCopied,
    OUT LPVOID lpBuf,
    BOOL fUnicode
    )
{
    LONG lRet;
    lRet = fUnicode ? imm32::ImmGetCompositionStringW(hIMC, dwIndex, lpBuf, dwCompLen)
                    : imm32::ImmGetCompositionStringA(hIMC, dwIndex, lpBuf, dwCompLen);
    if (lRet < 0)
        return E_FAIL;
    else {
        *lpCopied = lRet;
        return S_OK;
    }
}

HRESULT
Imm32_SetCompositionString(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen,
    BOOL fUnicode
    )
{
    if (fUnicode ? imm32::ImmSetCompositionStringW(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen)
                 : imm32::ImmSetCompositionStringA(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen)
       )
        return S_OK;
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    BOOL fUnicode
    )
{
    if (fUnicode ? imm32::ImmGetCompositionFontW(hIMC, &lplf->W)
                 : imm32::ImmGetCompositionFontA(hIMC, &lplf->A)
       )
        return S_OK;
    else
        return E_FAIL;
}

HRESULT
Imm32_SetCompositionFont(
    IN HIMC hIMC,
    IN LOGFONTAW* lplf,
    BOOL fUnicode
    )
{
    if (fUnicode ? imm32::ImmSetCompositionFontW(hIMC, &lplf->W)
                 : imm32::ImmSetCompositionFontA(hIMC, &lplf->A)
       )
        return S_OK;
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCompositionWindow(
    IN HIMC hIMC,
    OUT COMPOSITIONFORM *lpCompForm
    )
{
    return (imm32::ImmGetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                              : E_FAIL;
}

HRESULT
Imm32_SetCompositionWindow(
    IN HIMC hIMC,
    IN COMPOSITIONFORM *lpCompForm
    )
{
    return (imm32::ImmSetCompositionWindow(hIMC, lpCompForm)) ? S_OK
                                                              : E_FAIL;
}

HRESULT
Imm32_GetCandidateList(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPCANDIDATELIST lpCandList,
    OUT UINT* puCopied,
    BOOL fUnicode
    )
{
    DWORD dwRet;
    dwRet = fUnicode ? imm32::ImmGetCandidateListW(hIMC, dwIndex, lpCandList, dwBufLen)
                     : imm32::ImmGetCandidateListA(hIMC, dwIndex, lpCandList, dwBufLen);
    if (dwRet) {
        *puCopied = dwRet;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCandidateListCount(
    IN HIMC hIMC,
    OUT DWORD* lpdwListSize,
    OUT DWORD* pdwBufLen,
    BOOL fUnicode
    )
{
    DWORD dwRet;
    dwRet = fUnicode ? imm32::ImmGetCandidateListCountW(hIMC, lpdwListSize)
                     : imm32::ImmGetCandidateListCountA(hIMC, lpdwListSize);
    if (dwRet) {
        *pdwBufLen = dwRet;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT
Imm32_GetCandidateWindow(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    OUT CANDIDATEFORM *lpCandidate
    )
{
    return (imm32::ImmGetCandidateWindow(hIMC, dwIndex, lpCandidate)) ? S_OK
                                                                      : E_FAIL;
}

HRESULT
Imm32_SetCandidateWindow(
    IN HIMC hIMC,
    IN CANDIDATEFORM *lpCandForm
    )
{
    return (imm32::ImmSetCandidateWindow(hIMC, lpCandForm)) ? S_OK
                                                            : E_FAIL;
}

HRESULT
Imm32_GetGuideLine(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT CHARAW* pBuf,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    *pdwResult = fUnicode ? imm32::ImmGetGuideLineW(hIMC, dwIndex, &pBuf->W, dwBufLen)
                          : imm32::ImmGetGuideLineA(hIMC, dwIndex, &pBuf->A, dwBufLen);
    return S_OK;
}

HRESULT
Imm32_NotifyIME(
    IN HIMC hIMC,
    IN DWORD dwAction,
    IN DWORD dwIndex,
    IN DWORD dwValue
    )
{
    return (imm32::ImmNotifyIME(hIMC, dwAction, dwIndex, dwValue)) ? S_OK
                                                                   : E_FAIL;
}

HRESULT
Imm32_GetImeMenuItems(
    IN HIMC hIMC,
    IN DWORD dwFlags,
    IN DWORD dwType,
    IN IMEMENUITEMINFOAW *pImeParentMenu,
    OUT IMEMENUITEMINFOAW *pImeMenu,
    IN DWORD dwSize,
    OUT DWORD* pdwResult,
    BOOL fUnicode
    )
{
    *pdwResult = fUnicode ? imm32::ImmGetImeMenuItemsW(hIMC, dwFlags, dwType, &pImeParentMenu->W, &pImeMenu->W, dwSize)
                          : imm32::ImmGetImeMenuItemsA(hIMC, dwFlags, dwType, &pImeParentMenu->A, &pImeMenu->A, dwSize);
    return S_OK;
}

HRESULT
Imm32_GenerateMessage(
    IN HIMC hIMC
    )
{
    return (imm32::ImmGenerateMessage(hIMC)) ? S_OK
                                             : E_FAIL;
}

/*
 * hWnd
 */
HRESULT
Imm32_GetDefaultIMEWnd(
    IN HWND hWnd,
    OUT HWND *phDefWnd
    )
{
    *phDefWnd = imm32::ImmGetDefaultIMEWnd(hWnd);
    return S_OK;
}

HRESULT
Imm32_GetVirtualKey(
    HWND hWnd,
    UINT* puVirtualKey
    )
{
    *puVirtualKey = imm32::ImmGetVirtualKey(hWnd);
    return S_OK;
}

HRESULT
Imm32_IsUIMessageA(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return imm32::ImmIsUIMessageA(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
}

HRESULT
Imm32_IsUIMessageW(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return imm32::ImmIsUIMessageW(hWndIME, msg, wParam, lParam) ? S_OK : S_FALSE;
}

HRESULT
Imm32_SimulateHotKey(
    HWND hWnd,
    DWORD dwHotKeyID
    )
{
    return imm32::ImmSimulateHotKey(hWnd, dwHotKeyID) ? S_OK : S_FALSE;
}


/*
 * hKL
 */
HRESULT
Imm32_GetProperty(
    HKL hKL,
    DWORD dwOffset,
    DWORD* pdwProperty
    )
{
    *pdwProperty = imm32::ImmGetProperty(hKL, dwOffset);
    return S_OK;
}

HRESULT
Imm32_Escape(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult,
    BOOL fUnicode
    )
{
    *plResult = (fUnicode) ? imm32::ImmEscapeW(hKL, hIMC, uEscape, lpData)
                           : imm32::ImmEscapeA(hKL, hIMC, uEscape, lpData);
    return S_OK;
}

HRESULT
Imm32_GetDescription(
    HKL hKL,
    UINT uBufLen,
    CHARAW* lpsz,
    UINT* puCopied,
    BOOL fUnicode
    )
{
    *puCopied = (fUnicode) ? imm32::ImmGetDescriptionW(hKL, &lpsz->W, uBufLen)
                           : imm32::ImmGetDescriptionA(hKL, &lpsz->A, uBufLen);
    return *puCopied ? S_OK : E_FAIL;
}

HRESULT
Imm32_IsIME(
    HKL hKL
    )
{
    return imm32::ImmIsIME(hKL) ? S_OK : E_FAIL;
}

/*
 * win98/nt5 apis
 */
HRESULT
Imm32_RequestMessage(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* plResult,
    BOOL fUnicode
    )
{
    *plResult = (fUnicode) ? imm32::ImmRequestMessageW(hIMC, wParam, lParam)
                           : imm32::ImmRequestMessageA(hIMC, wParam, lParam);
    return S_OK;
}

/*
 * Register Word
 */
HRESULT
Imm32_EnumRegisterWordA(
    HKL hKL,
    LPSTR szReading,
    DWORD dwStyle,
    LPSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordA **pEnum
    )
{
    return E_FAIL;
}

HRESULT
Imm32_EnumRegisterWordW(
    HKL hKL,
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordW **pEnum
    )
{
    return E_FAIL;
}

HRESULT
Imm32_GetRegisterWordStyleA(
    HKL hKL,
    UINT nItem,
    STYLEBUFA *lpStyleBuf,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetRegisterWordStyleA(hKL, nItem, lpStyleBuf);
    return S_OK;
}

HRESULT
Imm32_GetRegisterWordStyleW(
    HKL hKL,
    UINT nItem,
    STYLEBUFW *lpStyleBuf,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetRegisterWordStyleW(hKL, nItem, lpStyleBuf);
    return S_OK;
}

HRESULT
Imm32_RegisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszRegister
    )
{
    return imm32::ImmRegisterWordA(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
}

HRESULT
Imm32_RegisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszRegister
    )
{
    return imm32::ImmRegisterWordW(hKL, lpszReading, dwStyle, lpszRegister) ? S_OK : E_FAIL;
}

HRESULT
Imm32_UnregisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszUnregister
    )
{
    return imm32::ImmUnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
}

HRESULT
Imm32_UnregisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszUnregister
    )
{
    return imm32::ImmUnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister) ? S_OK : E_FAIL;
}

/*
 *
 */

HRESULT
Imm32_ConfigureIMEA(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDA *lpdata
    )
{
    return imm32::ImmConfigureIMEA(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
}

HRESULT
Imm32_ConfigureIMEW(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *lpdata
    )
{
    return imm32::ImmConfigureIMEW(hKL, hWnd, dwMode, lpdata) ? S_OK : E_FAIL;
}

HRESULT
Imm32_GetConversionListA(
    HKL hKL,
    HIMC hIMC,
    LPSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetConversionListA(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
    return S_OK;
}

HRESULT
Imm32_GetConversionListW(
    HKL hKL,
    HIMC hIMC,
    LPWSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetConversionListW(hKL, hIMC, lpSrc, lpDst, uBufLen, uFlag);
    return S_OK;
}

HRESULT
Imm32_GetDescriptionA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszDescription,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetDescriptionA(hKL, lpszDescription, uBufLen);
    return S_OK;
}

HRESULT
Imm32_GetDescriptionW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszDescription,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetDescriptionW(hKL, lpszDescription, uBufLen);
    return S_OK;
}

HRESULT
Imm32_GetIMEFileNameA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszFileName,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetIMEFileNameA(hKL, lpszFileName, uBufLen);
    return S_OK;
}

HRESULT
Imm32_GetIMEFileNameW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszFileName,
    UINT *puCopied
    )
{
    *puCopied = imm32::ImmGetIMEFileNameW(hKL, lpszFileName, uBufLen);
    return S_OK;
}

HRESULT
Imm32_InstallIMEA(
    LPSTR lpszIMEFileName,
    LPSTR lpszLayoutText,
    HKL *phKL
    )
{
    *phKL = imm32::ImmInstallIMEA(lpszIMEFileName, lpszLayoutText);
    return S_OK;
}

HRESULT
Imm32_InstallIMEW(
    LPWSTR lpszIMEFileName,
    LPWSTR lpszLayoutText,
    HKL *phKL
    )
{
    *phKL = imm32::ImmInstallIMEW(lpszIMEFileName, lpszLayoutText);
    return S_OK;
}

HRESULT
Imm32_DisableIME(
    DWORD idThread
    )
{
    return imm32::ImmDisableIME(idThread) ? S_OK : E_FAIL;
}

HRESULT
Imm32_GetHotKey(
    DWORD dwHotKeyID,
    UINT *puModifiers,
    UINT *puVKey,
    HKL *phKL
    )
{
    return E_FAIL;
}

HRESULT
Imm32_SetHotKey(
    DWORD dwHotKeyID,
    UINT uModifiers,
    UINT uVKey,
    HKL hKL
    )
{
    return E_FAIL;
}

HRESULT
Imm32_RequestMessageA(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    return E_FAIL;
}

HRESULT
Imm32_RequestMessageW(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\context.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    context.h

Abstract:

    This file defines the Input Context Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CONTEXT_H_
#define _CONTEXT_H_

#include "imclock2.h"
#include "template.h"
#include "delay.h"
#include "ctxtlist.h"
#include "imccomp.h"

const  HIMC  DEFAULT_HIMC = (HIMC)-2;

class CInputContext : public DIMM_IMCLock,
                      public DIMM_InternalIMCCLock
{
public:
    CInputContext();
    virtual ~CInputContext();

    BOOL _IsDefaultContext(IN HIMC hIMC) {
        return hIMC == _hDefaultIMC ? TRUE : FALSE;
    }

    /*
     * AIMM Input Context (hIMC) API Methods.
     */
    HRESULT CreateContext(IN DWORD dwPrivateSize, BOOL fUnicode, OUT HIMC *phIMC, IN BOOL fCiceroActivated, DWORD fdwInitConvMode = 0, BOOL fInitOpen = FALSE);
    HRESULT DestroyContext(IN HIMC hIMC);
    HRESULT AssociateContext(IN HWND, IN HIMC, OUT HIMC *phPrev);
    HRESULT AssociateContextEx(IN HWND, IN HIMC, IN DWORD);
    HRESULT GetContext(IN HWND, OUT HIMC*);
    HRESULT GetIMCLockCount(IN HIMC, OUT DWORD*);

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    HRESULT CreateIMCC(IN DWORD dwSize, OUT HIMCC *phIMCC);
    HRESULT DestroyIMCC(IN HIMCC hIMCC);
    HRESULT GetIMCCSize(IN HIMCC hIMCC, OUT DWORD *pdwSize);
    HRESULT ReSizeIMCC(IN HIMCC hIMCC, IN DWORD dwSize, OUT HIMCC *phIMCC);
    HRESULT GetIMCCLockCount(IN HIMCC, OUT DWORD*);

    /*
     * AIMM Open Status API Methods
     */
    HRESULT GetOpenStatus(IN HIMC);
    HRESULT SetOpenStatus(IN DIMM_IMCLock&, IN BOOL, OUT BOOL*);

    /*
     * AIMM Conversion Status API Methods
     */
    HRESULT GetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
    HRESULT SetConversionStatus(IN DIMM_IMCLock&, IN DWORD, IN DWORD, OUT BOOL*, OUT BOOL*, OUT DWORD*, OUT DWORD*);

    /*
     * AIMM Status Window Pos API Methods
     */
    HRESULT WINAPI GetStatusWindowPos(IN HIMC, OUT LPPOINT);
    HRESULT SetStatusWindowPos(IN DIMM_IMCLock&, IN LPPOINT);

    /*
     * AIMM Composition String API Methods
     */
    HRESULT GetCompositionString(IN DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>&,
                                 IN DWORD, IN LONG*&, IN size_t = sizeof(WORD));
 
    /*
     * AIMM Composition Font API Methods
     */
    HRESULT GetCompositionFont(IN DIMM_IMCLock&, OUT LOGFONTAW* lplf, BOOL fUnicode);
    HRESULT SetCompositionFont(IN DIMM_IMCLock&, IN LOGFONTAW* lplf, BOOL fUnicode);

    /*
     * AIMM Composition Window API Methods
     */
    HRESULT GetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
    HRESULT SetCompositionWindow(IN DIMM_IMCLock&, IN LPCOMPOSITIONFORM);

    /*
     * AIMM Candidate List API Methods
     */
    HRESULT GetCandidateList(IN HIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT LPCANDIDATELIST lpCandList, OUT UINT* puCopied, BOOL fUnicode);
    HRESULT GetCandidateListCount(IN HIMC, OUT DWORD* lpdwListSize, OUT DWORD* pdwBufLen, BOOL fUnicode);

    /*
     * AIMM Candidate Window API Methods
     */
    HRESULT GetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
    HRESULT SetCandidateWindow(IN DIMM_IMCLock&, IN LPCANDIDATEFORM);

    /*
     * AIMM Guide Line API Methods
     */
    HRESULT GetGuideLine(IN HIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT CHARAW* pBuf, OUT DWORD* pdwResult, BOOL fUnicode);

    /*
     * AIMM Notify IME API Method
     */
    HRESULT NotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

    /*
     * AIMM Menu Items API Methods
     */
    HRESULT GetImeMenuItems(IN HIMC, IN DWORD dwFlags, IN DWORD dwType, IN IMEMENUITEMINFOAW *pImeParentMenu, OUT IMEMENUITEMINFOAW *pImeMenu, IN DWORD dwSize, OUT DWORD* pdwResult, BOOL fUnicode);

    /*
     * Context Methods
     */
    BOOL ContextLookup(HIMC hIMC, DWORD* pdwProcess, BOOL* pfUnicode = NULL)
    {
        CContextList::CLIENT_IMC_FLAG client_imc;
        BOOL ret = ContextList.Lookup(hIMC, pdwProcess, &client_imc);
        if (ret && pfUnicode)
            *pfUnicode = (client_imc & CContextList::IMCF_UNICODE ? TRUE : FALSE);
        return ret;
    }

    BOOL ContextLookup(HIMC hIMC, HWND* phImeWnd)
    {
        return ContextList.Lookup(hIMC, phImeWnd);
    }

    VOID ContextUpdate(HIMC hIMC, HWND& hImeWnd)
    {
        ContextList.Update(hIMC, hImeWnd);
    }

    BOOL EnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

    HRESULT ResizePrivateIMCC(IN HIMC hIMC, IN DWORD dwPrivateSize);

public:
    BOOL _CreateDefaultInputContext(IN DWORD dwPrivateSize, BOOL fUnicode, BOOL fCiceroActivated);
    BOOL _DestroyDefaultInputContext();

    void _Init(IActiveIME_Private *pActiveIME)
    {
        Assert(m_pActiveIME == NULL);
        m_pActiveIME = pActiveIME;
        m_pActiveIME->AddRef();
    }

public:
    HRESULT UpdateInputContext(IN HIMC hIMC, DWORD dwPrivateSize);

public:
    HIMC _GetDefaultHIMC() {
        return _hDefaultIMC;
    }

    CContextList    ContextList;   // Context list of client IMC.

private:
    HRESULT UpdateIMCC(IN HIMCC* phIMCC, IN DWORD  dwRequestSize);
    DWORD BuildHimcList(DWORD idThread, HIMC pHimc[]);

    HRESULT CreateAImeContext(HIMC hIMC);
    HRESULT DestroyAImeContext(HIMC hIMC);

private:
    IActiveIME_Private*  m_pActiveIME;      // Pointer to IActiveIME interface.

    HIMC         _hDefaultIMC;     // Default input context handle.

    CMap<HWND,                     // class KEY
         HWND,                     // class ARG_KEY
         HIMC,                     // class VALUE
         HIMC                      // class ARG_VALUE
        > AssociateList;
};

inline CInputContext::CInputContext()
{
    m_pActiveIME = NULL;
    _hDefaultIMC = NULL;
}

inline CInputContext::~CInputContext(
    )
{
    SafeRelease(m_pActiveIME);
}

#endif // _CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include "ccstock.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "DIMM12"
#define SZ_MODULE       "DIMM12"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\cimm32.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imm32.h

Abstract:

    This file defines the IMM32 class.

Author:

Revision History:

Notes:

--*/

#ifndef _CIMM32_H_
#define _CIMM32_H_

#include "delay.h"

// consider: why not just not link imm32.lib, and implement the wrappers with the
// same API names?  We could get rid of the Imm32_ prefix, and we could get
// rid of the imm32 namespace in delay.h.
//
// This would also prevent anyone from accidently not delay loading a currently
// unused imm32 api -- they'd get a link error.

/*
 * IMM32 Input Context (hIMC) API Interface.
 */
HRESULT Imm32_CreateContext(OUT HIMC *phIMC);
HRESULT Imm32_DestroyContext(IN HIMC hIMC);
HRESULT Imm32_AssociateContext(IN HWND hWnd, IN HIMC hIMC, OUT HIMC *phPrev);
HRESULT Imm32_AssociateContextEx(IN HWND hWnd, IN HIMC hIMC, IN DWORD dwFlags);
HRESULT Imm32_GetContext(IN HWND hWnd, OUT HIMC *phIMC);
HRESULT Imm32_ReleaseContext(IN HWND hWnd, IN HIMC hIMC);
HRESULT Imm32_GetIMCLockCount(IN HIMC hIMC, OUT DWORD* pdwLockCount);
HRESULT Imm32_LockIMC(HIMC hIMC, OUT INPUTCONTEXT **ppIMC);
HRESULT Imm32_UnlockIMC(IN HIMC hIMC);

/*
 * IMM32 Input Context Components (hIMCC) API Interface.
 */
HRESULT Imm32_CreateIMCC(IN DWORD dwSize, OUT HIMCC *phIMCC);
HRESULT Imm32_DestroyIMCC(IN HIMCC hIMCC);
HRESULT Imm32_GetIMCCSize(IN HIMCC hIMCC, OUT DWORD *pdwSize);
HRESULT Imm32_ReSizeIMCC(IN HIMCC hIMCC, IN DWORD dwSize, OUT HIMCC *phIMCC);
HRESULT Imm32_GetIMCCLockCount(IN HIMCC, OUT DWORD*);
HRESULT Imm32_LockIMCC(IN HIMCC hIMCC, OUT void **ppv);
HRESULT Imm32_UnlockIMCC(IN HIMCC hIMCC);

/*
 * IMM32 Open Status API Interface
 */
HRESULT Imm32_GetOpenStatus(IN HIMC hIMC);
HRESULT Imm32_SetOpenStatus(HIMC hIMC, BOOL fOpen);

/*
 * IMM32 Conversion Status API Interface
 */
HRESULT Imm32_GetConversionStatus(IN HIMC hIMC, OUT DWORD *lpfdwConversion, OUT DWORD *lpfdwSentence);
HRESULT Imm32_SetConversionStatus(IN HIMC hIMC, IN DWORD fdwConversion, IN DWORD fdwSentence);

/*
 * IMM32 Status Window Pos API Interface
 */
HRESULT Imm32_GetStatusWindowPos(IN HIMC hIMC, OUT POINT *lpptPos);
HRESULT Imm32_SetStatusWindowPos(IN HIMC hIMC, IN POINT *lpptPos);

/*
 * IMM32 Composition Window API Interface
 */
HRESULT Imm32_GetCompositionWindow(IN HIMC hIMC, OUT COMPOSITIONFORM *lpCompForm);
HRESULT Imm32_SetCompositionWindow(IN HIMC hIMC, IN COMPOSITIONFORM *lpCompForm);

/*
 * IMM32 Candidate Window API Interface
 */
HRESULT Imm32_GetCandidateWindow(IN HIMC hIMC, IN DWORD dwIndex, OUT CANDIDATEFORM *lpCandidate);
HRESULT Imm32_SetCandidateWindow(IN HIMC hIMC, IN CANDIDATEFORM *lpCandForm);

/*
 * IMM32 Notify IME API Interface
 */
HRESULT Imm32_NotifyIME(IN HIMC hIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);



HRESULT Imm32_GetCompositionString(IN HIMC hIMC, IN DWORD dwIndex, IN DWORD dwCompLen, OUT LONG*& lpCopied, OUT LPVOID lpBuf, BOOL fUnicode);
HRESULT Imm32_SetCompositionString(IN HIMC hIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD dwCompLen, IN LPVOID lpRead, IN DWORD dwReadLen, BOOL fUnicode);
HRESULT Imm32_GetCompositionFont(IN HIMC hIMC, IN LOGFONTAW* lplf, BOOL fUnicode);
HRESULT Imm32_SetCompositionFont(IN HIMC hIMC, IN LOGFONTAW* lplf, BOOL fUnicode);
HRESULT Imm32_GetCandidateList(IN HIMC hIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT LPCANDIDATELIST lpCandList, OUT UINT* puCopied, BOOL fUnicode);
HRESULT Imm32_GetCandidateListCount(IN HIMC, OUT DWORD* lpdwListSize, OUT DWORD* pdwBufLen, BOOL fUnicode);
HRESULT Imm32_GetGuideLine(IN HIMC, IN DWORD dwIndex, IN DWORD dwBufLen, OUT CHARAW* pBuf, OUT DWORD* pdwResult, BOOL fUnicode);
HRESULT Imm32_GetImeMenuItems(IN HIMC hIMC, IN DWORD dwFlags, IN DWORD dwType, IN IMEMENUITEMINFOAW *pImeParentMenu, OUT IMEMENUITEMINFOAW *pImeMenu, IN DWORD dwSize, OUT DWORD* pdwResult, BOOL fUnicode);
HRESULT Imm32_GenerateMessage(IN HIMC hIMC);

/*
 * hWnd
 */
HRESULT Imm32_GetDefaultIMEWnd(IN HWND hWnd, OUT HWND *phDefWnd);
HRESULT Imm32_GetVirtualKey(HWND hWnd, UINT* puVirtualKey);
HRESULT Imm32_IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT Imm32_IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT Imm32_SimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

/*
 * hKL
 */
HRESULT Imm32_GetProperty(HKL hKL, DWORD dwOffset, DWORD* pdwProperty);
HRESULT Imm32_Escape(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult, BOOL fUnicode);
HRESULT Imm32_GetDescription(HKL hKL, UINT uBufLen, CHARAW* lpsz, UINT* puCopied, BOOL fUnicode);
HRESULT Imm32_IsIME(HKL hKL);

/*
 * soft kbd
 */
inline HRESULT Imm32_CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd)
{
    *phSoftKbdWnd = imm32::ImmCreateSoftKeyboard(uType, hOwner, x, y);
    return S_OK;
}
inline HRESULT Imm32_DestroySoftKeyboard(HWND hSoftKbdWnd)
{
    return imm32::ImmDestroySoftKeyboard(hSoftKbdWnd) ? S_OK : E_FAIL;
}
inline HRESULT Imm32_ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow)
{
    return imm32::ImmShowSoftKeyboard(hSoftKbdWnd, nCmdShow) ? S_OK : E_FAIL;
} 

/*
 * win98/nt5 apis
 */
HRESULT Imm32_RequestMessage(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL fUnicode);

/*
 * Register Word
 */
HRESULT Imm32_EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum);
HRESULT Imm32_EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum);
HRESULT Imm32_GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied);
HRESULT Imm32_GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied);
HRESULT Imm32_RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister);
HRESULT Imm32_RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister);
HRESULT Imm32_UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister);
HRESULT Imm32_UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister);

/*
 *
 */
HRESULT Imm32_ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
HRESULT Imm32_ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);

HRESULT Imm32_GetConversionListA(HKL hKL, HIMC hIMC, LPSTR pSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *pDst, UINT *puCopied);
HRESULT Imm32_GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);

HRESULT Imm32_GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied);
HRESULT Imm32_GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied);
HRESULT Imm32_GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied);
HRESULT Imm32_GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied);
HRESULT Imm32_InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL);
HRESULT Imm32_InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL);
HRESULT Imm32_DisableIME(DWORD idThread);

HRESULT Imm32_GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL);
HRESULT Imm32_SetHotKey(DWORD dwHotKeyID, UINT uModifiers, UINT uVKey, HKL hKL);

HRESULT Imm32_RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
HRESULT Imm32_RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

#endif // _CIMM32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

void *MemAlloc(UINT uCount); // util.cpp
void MemFree(void *ptr);

void *  __cdecl operator new(unsigned int nSize)
{
    return MemAlloc(nSize);
}

void  __cdecl operator delete(void *pv)
{
    MemFree(pv);
}

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\ctxtlist.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ctxtlist.h

Abstract:

    This file defines the CContextList Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CTXTLIST_H_
#define _CTXTLIST_H_

#include "template.h"

class CContextList
{
public:
    CContextList() { };
    virtual ~CContextList() { };

    enum CLIENT_IMC_FLAG {
        IMCF_NONE            = 0x0000,
        IMCF_UNICODE         = 0x0001,
        IMCF_CMODE_GUID_NULL = 0x0002,
        IMCF_SMODE_GUID_NULL = 0x0004
    };

    void SetAt(HIMC hIMC, CLIENT_IMC_FLAG client_flag)
    {
        CLIENTIMC clientimc;

        memset((void*)&clientimc, 0, sizeof(clientimc));

        clientimc.dwProcessId = GetCurrentProcessId();
        clientimc.flag = client_flag;

        ClientIMC_List.SetAt(hIMC, clientimc);
    }

    BOOL Lookup(HIMC hIMC, DWORD* pdwProcess, CLIENT_IMC_FLAG* pclient_flag = NULL) const
    {
        BOOL ret;
        CLIENTIMC clientimc;

        ret = ClientIMC_List.Lookup(hIMC, clientimc);
        if (ret) {
            *pdwProcess = clientimc.dwProcessId;
            if (pclient_flag)
                *pclient_flag  = clientimc.flag;
        }
        return ret;
    }

    BOOL Lookup(HIMC hIMC, HWND* phImeWnd)
    {
        BOOL ret;
        CLIENTIMC clientimc;

        ret = ClientIMC_List.Lookup(hIMC, clientimc);
        if (ret) {
            *phImeWnd = clientimc.hImeWnd;
        }
        return ret;
    }

    VOID Update(HIMC hIMC, HWND& hImeWnd)
    {
        CLIENTIMC clientimc;

        clientimc = ClientIMC_List[hIMC];
        clientimc.hImeWnd = hImeWnd;
    }

    BOOL RemoveKey(HIMC hIMC)
    {
        return ClientIMC_List.RemoveKey(hIMC);
    }

    INT_PTR GetCount() const
    {
        return ClientIMC_List.GetCount();
    }

    POSITION GetStartPosition() const
    {
        return ClientIMC_List.GetStartPosition();
    }

    void GetNextHimc(POSITION& rNextPosition, HIMC* hImc, CLIENT_IMC_FLAG* pclient_imc = NULL) const
    {
        HIMC _hIMC;
        CLIENTIMC clientimc;
        ClientIMC_List.GetNextAssoc(rNextPosition, _hIMC, clientimc);
        *hImc = _hIMC;
        if (pclient_imc)
            *pclient_imc  = clientimc.flag;
    }

    //
    // Copy constructor
    //
    CContextList(const CContextList& src)
    {
        POSITION pos = src.GetStartPosition();
        for (INT_PTR index = 0; index < src.GetCount(); index++) {
            HIMC hIMC;
            CLIENT_IMC_FLAG client_imc;
            src.GetNextHimc(pos, &hIMC, &client_imc);
            SetAt(hIMC, client_imc);
        }
    }

private:
    struct CLIENTIMC {
        DWORD            dwProcessId;         // Process ID.
        CLIENT_IMC_FLAG  flag;                // flags.
        HWND             hImeWnd;             // in use IME Window
    };

private:
    CMap<HIMC,                     // class KEY
         HIMC,                     // class ARG_KEY
         CLIENTIMC,                // class VALUE
         CLIENTIMC                 // class ARG_VALUE
        > ClientIMC_List;
};

#endif // _CTXTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\enum.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    enum.h

Abstract:

    This file defines the IEnumInputContext Class.

Author:

Revision History:

Notes:

--*/

#ifndef _ENUM_H_
#define _ENUM_H_

#include "ctxtlist.h"

class CEnumInputContext : public IEnumInputContext
{
public:
    CEnumInputContext(CContextList& _hIMC_List) : _list(_hIMC_List)
    {
        _cRef = 1;
        Reset();
    };
    ~CEnumInputContext() { };

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IEnumInputContext
    //
    STDMETHODIMP Clone(IEnumInputContext** ppEnum);
    STDMETHODIMP Next(ULONG ulCount, HIMC* rgInputContext, ULONG* pcFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG ulCount);

private:
    LONG            _cRef;

    POSITION        _pos;
    CContextList    _list;
};

#endif // _ENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\defs.h ===
//+---------------------------------------------------------------------------
//
//  File:       defs.h
//
//  Contents:   Constant definitions.
//
//----------------------------------------------------------------------------

#ifndef DEFS_H
#define DEFS_H

#undef MAX
#define MAX(a, b) ( (a) >= (b) ? a : b )
#undef MIN
#define MIN(a, b) ( (a) <= (b) ? a : b )

#ifndef ABS
#define ABS(x) ( (x) < 0 ? -(x) : x )
#endif

// debugging api calls
#define TF_API      0x10
#define TF_IMEAPI   0x20

#endif // DEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "globals.h"
#include "template.h"

TOUNICODEEX g_pfnToUnicodeEx = NULL;

CProcessIMM* g_ProcessIMM;



UINT  WM_MSIME_SERVICE;
UINT  WM_MSIME_UIREADY;
UINT  WM_MSIME_RECONVERTREQUEST;
UINT  WM_MSIME_RECONVERT;
UINT  WM_MSIME_DOCUMENTFEED;
UINT  WM_MSIME_QUERYPOSITION;
UINT  WM_MSIME_MODEBIAS;
UINT  WM_MSIME_SHOWIMEPAD;
UINT  WM_MSIME_MOUSE;
UINT  WM_MSIME_KEYMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\globals.h ===
//+---------------------------------------------------------------------------
//
//  File:       globals.h
//
//  Contents:   Global variable declarations.
//
//----------------------------------------------------------------------------

#ifndef GLOBALS_H
#define GLOBALS_H

#include "pimm.h"
#include "imtls.h"

extern HINSTANCE g_hInst;

extern CProcessIMM* g_ProcessIMM;

typedef struct tagSELECTCONTEXT_ENUM {
    HKL hSelKL;
    HKL hUnSelKL;
} SCE, *PSCE;


typedef int (*TOUNICODEEX)(UINT, UINT, CONST BYTE *, LPWSTR, int, UINT, HKL);
extern TOUNICODEEX g_pfnToUnicodeEx;



//+---------------------------------------------------------------------------
//
// WM_MSIME_xxxx
//
//----------------------------------------------------------------------------

extern UINT  WM_MSIME_SERVICE;
extern UINT  WM_MSIME_UIREADY;
extern UINT  WM_MSIME_RECONVERTREQUEST;
extern UINT  WM_MSIME_RECONVERT;
extern UINT  WM_MSIME_DOCUMENTFEED;
extern UINT  WM_MSIME_QUERYPOSITION;
extern UINT  WM_MSIME_MODEBIAS;
extern UINT  WM_MSIME_SHOWIMEPAD;
extern UINT  WM_MSIME_MOUSE;
extern UINT  WM_MSIME_KEYMAP;

//+---------------------------------------------------------------------------
//
// GetTLS
//
//----------------------------------------------------------------------------

class CActiveIMM;

inline CActiveIMM *GetTLS()
{
    return IMTLS_GetActiveIMM();
}

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\enum.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    enum.cpp

Abstract:

    This file implements the IEnumInputContext Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "enum.h"

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::QueryInterface(
    REFIID riid,
    void **ppvObj
    )
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumInputContext))
    {
        *ppvObj = SAFECAST(this, IEnumInputContext *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

ULONG
CEnumInputContext::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

ULONG
CEnumInputContext::Release()
{
    LONG cr = --_cRef;

    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// Clone
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Clone(
    IEnumInputContext** ppEnum
    )
{
    if (ppEnum == NULL)
        return E_INVALIDARG;

    *ppEnum = NULL;

    CEnumInputContext* pClone;
    if ((pClone = new CEnumInputContext(_list)) == NULL)
        return E_OUTOFMEMORY;

    *ppEnum = pClone;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Next
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Next(
    ULONG ulCount,
    HIMC* rgInputContext,
    ULONG* pcFetched
    )
{
    if (rgInputContext == NULL)
        return E_INVALIDARG;

    ULONG cFetched;
    if (pcFetched == NULL)
        pcFetched = &cFetched;

    if (_pos == NULL) {
        *pcFetched = 0;
        return S_FALSE;
    }

    for (*pcFetched = 0; *pcFetched < ulCount; *pcFetched++, rgInputContext++) {
        _list.GetNextHimc(_pos, rgInputContext);
        if (_pos == NULL)
            break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Reset
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Reset(
    )
{
    _pos = _list.GetStartPosition();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Skip
//
//----------------------------------------------------------------------------

HRESULT
CEnumInputContext::Skip(
    ULONG ulCount
    )
{
    POSITION backup = _pos;

    while (ulCount--) {
        HIMC imc;
        _list.GetNextHimc(_pos, &imc);
        if (_pos == NULL) {
            _pos = backup;
            return S_FALSE;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\delay.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    delay.h

Abstract:

    This file defines the IMM32 Namespace.

Author:

Revision History:

Notes:

--*/

#ifndef _DELAY_H_
#define _DELAY_H_

namespace imm32 {

    extern HINSTANCE g_hImm32;

    /*
     * IMM32 Input Context (hIMC) API Interface.
     */
    HIMC WINAPI ImmCreateContext(void);
    BOOL WINAPI ImmDestroyContext(IN HIMC);
    HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
    BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
    HIMC WINAPI ImmGetContext(IN HWND);
    BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
    DWORD WINAPI ImmGetIMCLockCount(IN HIMC);
    LPINPUTCONTEXT WINAPI ImmLockIMC(IN HIMC);
    BOOL  WINAPI ImmUnlockIMC(IN HIMC);

    /*
     * IMM32 Input Context Components (hIMCC) API Interface.
     */
    HIMCC  WINAPI ImmCreateIMCC(IN DWORD);
    HIMCC  WINAPI ImmDestroyIMCC(IN HIMCC);
    DWORD  WINAPI ImmGetIMCCSize(IN HIMCC);
    HIMCC  WINAPI ImmReSizeIMCC(IN HIMCC, IN DWORD);
    DWORD  WINAPI ImmGetIMCCLockCount(IN HIMCC);
    LPVOID WINAPI ImmLockIMCC(IN HIMCC);
    BOOL   WINAPI ImmUnlockIMCC(IN HIMCC);

    /*
     * IMM32 Composition String API Interface
     */
    LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
    BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);

    /*
     * IMM32 Composition Font API Interface
     */
    BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
    BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
    BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
    BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);

    /*
     * IMM32 Open Status API Interface
     */
    BOOL WINAPI ImmGetOpenStatus(IN HIMC);
    BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

    /*
     * IMM32 Conversion Status API Interface
     */
    BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
    BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);

    /*
     * IMM32 Status Window Pos API Interface
     */
    BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
    BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);


    /*
     * IMM32 Composition Window API Interface
     */
    BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
    BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);

    /*
     * IMM32 Candidate API Interface
     */
    BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
    BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);
    DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD dwIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
    DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);

    /*
     * IMM32 Generate Message API Interface
     */
    BOOL WINAPI ImmGenerateMessage(IN HIMC);

    /*
     * IMM32 Notify IME API Interface
     */
    BOOL WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

    /*
     * IMM32 Guide Line IME API Interface
     */
    DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
    DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);

    /*
     * IMM32 Menu items API Interface
     */
    DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
    DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);

    /*
     * IMM32 Default IME Window API Interface
     */
    HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);
    UINT WINAPI ImmGetVirtualKey(IN HWND);

    /*
     * IMM32 UI message API Interface
     */
    BOOL WINAPI ImmIsUIMessageA(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);
    BOOL WINAPI ImmIsUIMessageW(HWND hWnd, UINT u, WPARAM wParam, LPARAM lParam);

    /*
     * IMM32 Simulate hotkey API Interface
     */
    BOOL WINAPI ImmSimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

    /*
     * IMM32 Property API Interface
     */
    DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

    /*
     * IMM32 Description API Interface
     */
    UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameA(HKL hKL, LPSTR lpszFileName, UINT uBufLen);
    UINT WINAPI ImmGetIMEFileNameW(HKL hKL, LPWSTR lpszFileName, UINT uBufLen);

    /*
     * IMM32 Conversion List API Interface
     */
    DWORD WINAPI ImmGetConversionListA(HKL hKL, HIMC hIMC, LPCSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);
    DWORD WINAPI ImmGetConversionListW(HKL hKL, HIMC hIMC, LPCWSTR psz, LPCANDIDATELIST pCL, DWORD dwBufLen, UINT uFlag);

    /*
     * IMM32 IsIME API Interface
     */
    BOOL WINAPI ImmIsIME(HKL hKL);

    /*
     * IMM32 Escape API Interface
     */
    LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
    LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);

    /*
     * IMM32 Configure IME Interface
     */
    BOOL WINAPI ImmConfigureIMEA(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
    BOOL WINAPI ImmConfigureIMEW(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);

    /*
     * IMM32 Register Word IME Interface
     */
    BOOL WINAPI ImmRegisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszRegister);
    BOOL WINAPI ImmRegisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszRegister);
    BOOL WINAPI ImmUnregisterWordA(HKL hKL, LPCSTR lpszReading, DWORD dw, LPCSTR lpszUnregister);
    BOOL WINAPI ImmUnregisterWordW(HKL hKL, LPCWSTR lpszReading, DWORD dw, LPCWSTR lpszUnregister);
    UINT WINAPI ImmGetRegisterWordStyleA(HKL hKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
    UINT WINAPI ImmGetRegisterWordStyleW(HKL hKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);

    /*
     * IMM32 soft kbd API
     */
    HWND WINAPI ImmCreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y);
    BOOL WINAPI ImmDestroySoftKeyboard(HWND hSoftKbdWnd);
    BOOL WINAPI ImmShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    /*
     * IMM32 win98/nt5 apis
     */
    BOOL WINAPI ImmDisableIME(DWORD dwId);

    LRESULT WINAPI ImmRequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam);
    LRESULT WINAPI ImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam);

    HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
    HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
}

#endif // _DELAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\dimm.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       dimm.cpp
//
//  Contents:   CActiveIMM methods without win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "util.h"

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CActiveIMM::CActiveIMM()
{
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// _Init
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_Init()
{
    extern HRESULT CIME_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    HRESULT hr;

    if (FAILED(hr=CIME_CreateInstance(NULL, IID_IActiveIME_Private, (void **)&_pActiveIME)))
    {
        _pActiveIME = NULL;
        return hr;
    }

    _pActiveIME->ConnectIMM(this);

    _InputContext._Init(_pActiveIME);

    _ConnectTIM(_pActiveIME);

    return hr;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CActiveIMM::~CActiveIMM()
{
    //
    // unload the hooks
    //
    _UninitHooks();

    POSITION pos = _mapWndFocus.GetStartPosition();
    int index;
    for (index = 0; index < _mapWndFocus.GetCount(); index++) {
        HWND hWnd;
        ITfDocumentMgr* pdim;
        _mapWndFocus.GetNextAssoc(pos, hWnd, pdim);
        if (pdim)
        {
            pdim->Release();
        }
    }

    if (GetTimP())
    {
        _UnconnectTIM();
    }

    if (_pActiveIME != NULL)
    {
        _pActiveIME->UnconnectIMM();
        SafeReleaseClear(_pActiveIME);
    }

    IMTLS_SetActiveIMM(NULL);
}

//+---------------------------------------------------------------------------
//
// IsRealIme
//
//----------------------------------------------------------------------------

inline BOOL _IsIMEHKL(HKL hkl)
{
    return ((((DWORD)(UINT_PTR)hkl) & 0xf0000000) == 0xe0000000) ? TRUE : FALSE;
}

BOOL CActiveIMM::_IsRealIme(HKL hkl)
{
    if (! hkl) {
        HRESULT hr = _GetKeyboardLayout(&hkl);
        if (FAILED(hr))
            return FALSE;
    }

    if (!_IsIMEHKL(hkl))
        return FALSE;

    BOOL fRet;
    if (_RealImeList.Lookup(hkl, fRet))
        return fRet;

    char szDesc[MAX_PATH +1];
    char szDumbDesc[MAX_PATH +1];

    UINT uCopied;
    if (FAILED(Imm32_GetDescription(hkl, ARRAYSIZE(szDesc), (CHARAW*)szDesc, &uCopied, FALSE)))
        return FALSE;

    szDesc[ARRAYSIZE(szDesc) -1] = '\0';

    wsprintf(szDumbDesc, "hkl%04x", LOWORD((UINT_PTR)hkl));
    fRet = lstrcmp(szDumbDesc, szDesc) ? TRUE : FALSE;

    _RealImeList.SetAt(hkl, fRet);
    return fRet;
}

HRESULT CActiveIMM::IsRealImePublic(BOOL *pfReal)
{
    if (pfReal)
    {
        *pfReal = _IsRealIme(0);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr;
    IServiceProvider* pISP;

    Assert(ppv != NULL && *ppv == NULL);

    hr = E_FAIL;

    if (_pActiveIME->QueryInterface(IID_IServiceProvider, (void**)&pISP) == S_OK)
    {
        hr = pISP->QueryService(guidService, riid, ppv);
        pISP->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// _GetKeyboardLayout
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_GetKeyboardLayout(HKL* phkl)
{
    extern HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    HRESULT hr;

    if (_IsAlreadyActivate())
    {
        //
        // Already called IActiveIMMApp::Activate
        //
        if (_AImeProfile == NULL) {

            hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&_AImeProfile);

            if (FAILED(hr)) {
                TraceMsg(TF_ERROR, "CreateInstance(CAImeProfile) failed");
                return hr;
            }
        }
        return _AImeProfile->GetKeyboardLayout(phkl);
    }
    else {
        //
        // Not yet called IActiveIMMApp::Activate
        // or
        // called IActiveIMMApp::Deactivate
        //
        if (_AImeProfile == NULL) {
            hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&_AImeProfile);

            if (FAILED(hr)) {
                TraceMsg(TF_ERROR, "CreateInstance(CAImeProfile) failed");
                return hr;
            }
            hr = _AImeProfile->GetKeyboardLayout(phkl);
            //
            // Prevent memory leak when not ready Activate.
            //
            _AImeProfile->Release();
            _AImeProfile = NULL;
            //
            return hr;
        }
        else {
            return _AImeProfile->GetKeyboardLayout(phkl);
        }
    }
}

//+---------------------------------------------------------------------------
//
// _ImeSelectHandler
//
//----------------------------------------------------------------------------

LRESULT CActiveIMM::_ImeSelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, HIMC hIMC)

/*
 * If return TRUE: no call previous window procedure of IME window class.
 * In case of CCiceroIME::ActivateLayout/DeactivateLayout, return value might be
 * TRUE.
 * Otherwise, WM_IME_SELECT become from another module. In this case, should be
 * call previous window proc.
 */

{
    //
    // on FE-Win98, IMS_ACTIVATETHREADLAYOUT needs to be generate at ImeSelect.
    // otherwise we may update InputContext before IME get ImeSelect(FALSE);
    //
    if (wParam && !IsOnNT() && IsOnImm())
        _DefaultIMEWindow.SendIMEMessage(WM_IME_SYSTEM, (WPARAM)IMS_ACTIVATETHREADLAYOUT, lParam, IsWindowUnicode(_hFocusWnd), FALSE);

    if (!_IsRealIme((HKL)lParam)) {
        /*
         * We must re-create UI window of newly selected IME.
         */
        if ((BOOL)wParam == TRUE) {
            //
            // Create IME UI window.
            //
            if (_UIWindow.CreateUIWindow((HKL)lParam)) {
                //
                // Set context and send notification to UI window.
                //
                _UIWindow.SetUIWindowContext(hIMC);
                _UIWindow.SendUIMessage(uMsg, wParam, lParam, fUnicode);
            }
        }
        else {
            _UIWindow.SendUIMessage(uMsg, wParam, lParam, fUnicode);
            _UIWindow.DestroyUIWindow();
        }
        return TRUE;
    }
    else if (_DefaultIMEWindow.IsAIMEHandler())
        return TRUE;
    else
        return FALSE;
}

//+---------------------------------------------------------------------------
//
// _ImeWndFinalDestroyHandler
//
//----------------------------------------------------------------------------

void CActiveIMM::_ImeWndFinalDestroyHandler()
{
    if (!_IsRealIme()) {
        //
        // Destroy IME UI window.
        //
        _UIWindow.DestroyUIWindow();
    }
}

//+---------------------------------------------------------------------------
//
// _ActivateLayout
//
//----------------------------------------------------------------------------

void CActiveIMM::_ActivateLayout(HKL hSelKL, HKL hUnSelKL)
{
    BOOL fUnicode = IsWindowUnicode(_hFocusWnd);
    BOOL bIsRealIme = _IsRealIme(hSelKL);

    /*
     * Select input context(s).
     */
    SCE sce;
    sce.hSelKL   = hSelKL;
    sce.hUnSelKL = hUnSelKL;

    _InputContext.EnumInputContext(0, _SelectContextProc, (LPARAM)&sce);

    if (! bIsRealIme || ! IsOnImm()) {
        if (hSelKL == NULL) {
            HRESULT hr = _GetKeyboardLayout(&hSelKL);
        }

        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, TRUE, (LPARAM)(hSelKL), fUnicode);
    }
}

//+---------------------------------------------------------------------------
//
// _DeactivateLayout
//
//----------------------------------------------------------------------------

void CActiveIMM::_DeactivateLayout(HKL hSelKL, HKL hUnSelKL)
{
    BOOL fUnicode = IsWindowUnicode(_hFocusWnd); 
    BOOL bIsRealIme = _IsRealIme(hUnSelKL);

    if ((! bIsRealIme || ! IsOnImm()) &&
          (hUnSelKL != hSelKL ||
           (hUnSelKL == NULL && hSelKL == NULL))) {

#ifdef UNSELECTCHECK
        //
        // If hSelKL is real IME, All hIMC is already initialized by the IME
        // we can not touch them from now on. We should stop doing in next
        // NotifyIME calls.
        //
        if (_IsRealIme(hSelKL) && !IsOnNT())
        {
            _InputContext.EnumInputContext(0, _UnSelectCheckProc, 0);
        }
#endif UNSELECTCHECK

        DWORD dwCPS = _GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_COMPLETE_ON_UNSELECT ? CPS_COMPLETE : CPS_CANCEL;

        _InputContext.EnumInputContext(0, _NotifyIMEProc, dwCPS);

        if (hUnSelKL == NULL) {
            HRESULT hr = _GetKeyboardLayout(&hUnSelKL);
        }

        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, FALSE, (LPARAM)(hUnSelKL), fUnicode);
    }

    /*
     * Unselect input context(s).
     */
    SCE sce;
    sce.hSelKL   = hSelKL;
    sce.hUnSelKL = hUnSelKL;
    _InputContext.EnumInputContext(0, _UnSelectContextProc, (LPARAM)&sce);
}

//+---------------------------------------------------------------------------
//
// _InitHooks
//
//----------------------------------------------------------------------------

BOOL CActiveIMM::_InitHooks()
{
    GetTimP()->SetSysHookSink(this);

    DWORD dwThreadId = GetCurrentThreadId();

#if 0
    if (!_hHook[TH_GETMSG]) {
        _hHook[TH_GETMSG] = SetWindowsHookEx(WH_GETMESSAGE, _GetMsgProc, NULL, dwThreadId);
    }
#endif

#ifdef CALLWNDPROC_HOOK
    if (!_hHook[TH_WNDPROC]) {
        _hHook[TH_WNDPROC] = SetWindowsHookEx(WH_CALLWNDPROC, _CallWndProc, NULL, dwThreadId);
    }
#endif // CALLWNDPROC_HOOK

#ifdef CALLWNDPROC_HOOK
    if (!_hHook[TH_DEFIMEWNDPROC] &&
        _DefaultIMEWindow.IsNeedRecovIMEWndProc()) 
#else
    if (!_hHook[TH_DEFIMEWNDPROC])
#endif // CALLWNDPROC_HOOK
    {
        _hHook[TH_DEFIMEWNDPROC] = SetWindowsHookEx(WH_CALLWNDPROCRET,
                                                   _DefImeWnd_CallWndProc,
                                                   NULL,
                                                   dwThreadId);
    }

#if 0
    if (g_uACP != 932 && g_uACP != 949 && g_uACP != 950 && g_uACP != 936 &&
        ! hShellHook) {
        hShellHook = SetWindowsHookEx(WH_SHELL, _ShellProc, NULL, dwThreadId);
    }
#endif

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// _UninitHooks
//
//----------------------------------------------------------------------------

void CActiveIMM::_UninitHooks()
{
#if 0
    if (_hHook[TH_GETMSG]) {
        UnhookWindowsHookEx(_hHook[TH_GETMSG]);
        _hHook[TH_GETMSG] = NULL;
    }
#endif

#ifdef CALLWNDPROC_HOOK
    if (_hHook[TH_WNDPROC]) {
        UnhookWindowsHookEx(_hHook[TH_WNDPROC]);
        _hHook[TH_WNDPROC] = NULL;
    }
#endif // CALLWNDPROC_HOOK

    if (_hHook[TH_DEFIMEWNDPROC]) {
        UnhookWindowsHookEx(_hHook[TH_DEFIMEWNDPROC]);
        _hHook[TH_DEFIMEWNDPROC] = NULL;
    }

#if 0
    if (g_uACP != 932 && g_uACP != 949 && g_uACP != 950 && g_uACP != 936 &&
        hShellHook != NULL) {
        UnhookWindowsHookEx(hShellHook);
        hShellHook = NULL;
    }
#endif

    if (GetTimP())
    {
        GetTimP()->SetSysHookSink(NULL);
    }
}

//+---------------------------------------------------------------------------
//
// _OnImeSelect
//
//----------------------------------------------------------------------------

void CActiveIMM::_OnImeSelect(HKL hSelKL)
{
    if (!_IsRealIme(hSelKL))
    {
        // Don't check IMM32
        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, TRUE, (LPARAM)(hSelKL), IsWindowUnicode(_hFocusWnd), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
// _OnImeUnselect
//
//----------------------------------------------------------------------------

void CActiveIMM::_OnImeUnselect(HKL hUnSelKL)
{
    if (!_IsRealIme(hUnSelKL))
    {
        // Don't check IMM32
        _DefaultIMEWindow.SendIMEMessage(WM_IME_SELECT, FALSE, (LPARAM)(hUnSelKL), IsWindowUnicode(_hFocusWnd), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
// _OnImeActivateThreadLayout
//
//----------------------------------------------------------------------------

void CActiveIMM::_OnImeActivateThreadLayout(HKL hSelKL)
{
    //
    // on FE-Win98, IMS_ACTIVATETHREADLAYOUT needs to be generate at ImeSelect.
    // otherwise we may update InputContext before IME get ImeSelect(FALSE);
    //
    if (!IsOnNT() && IsOnImm())
        return;

    // Don't check IMM32
    _DefaultIMEWindow.SendIMEMessage(WM_IME_SYSTEM, (WPARAM)IMS_ACTIVATETHREADLAYOUT, (LPARAM)(hSelKL), IsWindowUnicode(_hFocusWnd), FALSE);
}

//+---------------------------------------------------------------------------
//
// _AImeAssociateFocus
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_AImeAssociateFocus(HWND hWnd, HIMC hIMC, DWORD dwFlags)
{
    if (hIMC)
    {
        DIMM_IMCLock lpIMC(hIMC);
        if (lpIMC.Invalid())
            return E_FAIL;

        lpIMC->hWnd = hWnd;
    }

    return _pActiveIME->AssociateFocus(hWnd, hIMC, dwFlags);
}

//+---------------------------------------------------------------------------
//
// _ResizePrivateIMCC
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_ResizePrivateIMCC(IN HIMC hIMC, IN DWORD dwPrivateSize)
{
    /*
     * Resize private IMCC method.
     *
     * If IsRealIme() was true, should not resize private IMCC to ActiveIME's size.
     * 
     */
    if (!_IsRealIme())
        return _InputContext.ResizePrivateIMCC(hIMC, dwPrivateSize);
    else
        return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetIMEWndClassName
//
//----------------------------------------------------------------------------

DWORD CActiveIMM::_GetIMEWndClassName(HKL hKL, LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate)
{
    return (!_IsRealIme(hKL)) ? _GetIMEWndClassName(lpsz, dwBufLen, pulPrivate)
                                              : 0L;
}

DWORD CActiveIMM::_GetIMEWndClassName(LPWSTR lpsz, DWORD dwBufLen, UINT_PTR *pulPrivate)
{
    DWORD len = wcslen(_IMEInfoEx.achWndClass);

    if (lpsz == NULL || dwBufLen < len) {
        return len;
    }
    else {
        wcscpy(lpsz, _IMEInfoEx.achWndClass);
        *pulPrivate = _IMEInfoEx.dwPrivate;
    }
    return len;
}

//+---------------------------------------------------------------------------
//
// _CallWindowProc
//
//----------------------------------------------------------------------------

LRESULT CActiveIMM::_CallWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return _DefaultIMEWindow.CallWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// _SendUIMessage
//
//----------------------------------------------------------------------------

LRESULT CActiveIMM::_SendUIMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode)
{
    return (!_IsRealIme()) ? _UIWindow.SendUIMessage(Msg, wParam, lParam, fUnicode)
                                           : 0L;
}

//+---------------------------------------------------------------------------
//
// _SetHookWndList
//
//----------------------------------------------------------------------------

BOOL CActiveIMM::_SetHookWndList(HWND hwnd)
{
    TCHAR achMyClassName[MAX_PATH + 1];
    int lenMyClassName = ::GetClassName(hwnd, achMyClassName, ARRAYSIZE(achMyClassName) - 1);
    achMyClassName[ARRAYSIZE(achMyClassName) -1] = TEXT('\0');
    if (lenMyClassName) {
        CString cls(achMyClassName);
        if (cls.CompareNoCase(TEXT("IME")) == 0) {
            _HookWndList.SetAt(hwnd, TRUE);
            return TRUE;
        }
    }

    DWORD dwStyle = GetClassLong(hwnd, GCL_STYLE);
    if (dwStyle & CS_IME) {
        _HookWndList.SetAt(hwnd, TRUE);
        return TRUE;
    }

    _HookWndList.SetAt(hwnd, FALSE);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
// OnPreFocusDIM
//
//----------------------------------------------------------------------------

HRESULT CActiveIMM::OnPreFocusDIM(HWND hWnd)
{
    HIMC hIMC;
    if (SUCCEEDED(_InputContext.GetContext(hWnd, &hIMC)))
    {
        if (IsPresent(hWnd, TRUE))
        {
            if (_InputContext._IsDefaultContext(hIMC)) 
            {
                DIMM_IMCLock pIMC(hIMC);
                if (pIMC.Valid()) 
                {
                    // set the hWnd since this is a default context
                    pIMC->hWnd = hWnd;
                }
            }
            _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
            _SetMapWndFocus(hWnd);
        }
        else if (hIMC)
        {
            _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS | AIMMP_AFF_SETNULLDIM);
        }
        else
        {
            _AImeAssociateFocus(hWnd, NULL, AIMMP_AFF_SETFOCUS);
        }
    }
    else
    {
        _AImeAssociateFocus(hWnd, NULL, AIMMP_AFF_SETFOCUS);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnSysKeybaordProc
//
//----------------------------------------------------------------------------

STDAPI CActiveIMM::OnSysKeyboardProc(WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return hr;

    BOOL bIsRealIme = _IsRealIme();

    BOOL fNoOnTrans;

    if ((wParam != VK_PROCESSKEY) && !bIsRealIme)
    {
        // fNoOnTrans = (pTS->uMsgPumpOwnerRef == 0); // check this once so it doesn't get changed during the op
        fNoOnTrans = TRUE;

        if (HIWORD(lParam) & KF_UP)
        {
            // if this a key up event, clear the KF_REPEAT flag
            lParam &= ~(KF_REPEAT << 16);
        }

        hr = _this->_ProcessKey(&wParam, &lParam, fNoOnTrans);

        // wParam will be set 0 if _ProcessKey wants to eat it without consulting the ime
        // (It might also be converted to VK_HANJA, etc.)
        if (hr == S_OK && fNoOnTrans && wParam)
        {
            // nobody's using OnTranslateMessage to finish off the key now
            hr = _this->_ToAsciiEx(wParam, lParam);
        }
    }
#ifdef CICERO_3564
    else if ((wParam == VK_PROCESSKEY) &&
             ! bIsRealIme)
    {
        /*
         * KOREAN:
         *  Send VK_PROCESSKEY to finalize current composition string (NT4 behavior)
         *  Post private message (WM_IME_SYSTEM::IMS_FINALIZE_COMPSTR) to let IMM finalize the composition string (NT5)
         */
        IMTLS *ptls = IMTLS_GetOrAlloc();
        if (ptls == NULL)
            return hr;

        if (ptls->pAImeProfile == NULL)
            return hr;

        LANGID langid;
        ptls->pAImeProfile->GetLangId(&langid);

        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            hr = _this->_ToAsciiEx(wParam, lParam);
        }
    }
#endif // CICERO_3564

    return hr;
}


//+---------------------------------------------------------------------------
//
// _SendIMENotify
//
// Inform IME and Apps Wnd about the change of composition window.
//----------------------------------------------------------------------------

HRESULT CActiveIMM::_SendIMENotify(
    HIMC hImc,
    HWND hWnd,
    DWORD dwAction,
    DWORD dwIndex,
    DWORD dwValue,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (dwAction != 0) {
        _AImeNotifyIME(hImc, dwAction, dwIndex, dwValue);
    }

    if (hWnd != NULL && wParam != 0) {
        SendMessage(hWnd, WM_IME_NOTIFY, wParam, lParam);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _GetIMEProperty
//
//----------------------------------------------------------------------------

DWORD CActiveIMM::_GetIMEProperty(PROPERTY_TYPE iType)
{
    switch (iType) {
        case PROP_PRIVATE_DATA_SIZE:  return _IMEInfoEx.ImeInfo.dwPrivateDataSize;  break;
        case PROP_IME_PROPERTY:       return _IMEInfoEx.ImeInfo.fdwProperty;        break;
        case PROP_CONVERSION_CAPS:    return _IMEInfoEx.ImeInfo.fdwConversionCaps;  break;
        case PROP_SENTENCE_CAPS:      return _IMEInfoEx.ImeInfo.fdwSentenceCaps;    break;
        case PROP_UI_CAPS:            return _IMEInfoEx.ImeInfo.fdwUICaps;          break;
        case PROP_SCS_CAPS:           return _IMEInfoEx.ImeInfo.fdwSCSCaps;         break;
        case PROP_SELECT_CAPS:        return _IMEInfoEx.ImeInfo.fdwSelectCaps;      break;
        default:                      return 0;
    }
}

//+---------------------------------------------------------------------------
//
// HideOrRestoreToolbarWnd
//
//----------------------------------------------------------------------------

void CActiveIMM::HideOrRestoreToolbarWnd(BOOL fRestore)
{
    ITfLangBarMgr *plbm;
    if (SUCCEEDED(TF_CreateLangBarMgr(&plbm)))
    {
        if (fRestore)
        {
            if (_dwPrevToolbarStatus)
            {
                plbm->ShowFloating(_dwPrevToolbarStatus);
                _dwPrevToolbarStatus = 0;
            }
        } 
        else
        {
            if (SUCCEEDED(plbm->GetShowFloatingStatus(&_dwPrevToolbarStatus)))
            {
                BOOL fHide = TRUE;
                if (_dwPrevToolbarStatus & TF_SFT_DESKBAND)
                    fHide = FALSE;
          
                //
                // mask for show/hide
                //
                _dwPrevToolbarStatus &= (TF_SFT_SHOWNORMAL |
                                         TF_SFT_DOCK |
                                         TF_SFT_MINIMIZED |
                                         TF_SFT_HIDDEN);

                if (fHide)
                    plbm->ShowFloating(TF_SFT_HIDDEN);
            } 
        } 
        plbm->Release();
    }
}

//+---------------------------------------------------------------------------
//
// OnSysShellProc
//
//----------------------------------------------------------------------------

STDAPI CActiveIMM::OnSysShellProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;
    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return hr;

    switch (nCode) {
        case HSHELL_LANGUAGE:
            if (IsOn98() || IsOn95()) {
                //
                // Windows 9x platform
                // Alternative of WM_IME_SYSTEM::IMS_ACTIVATETHREADLAYOUT
                //
                _this->_OnImeActivateThreadLayout((HKL)lParam);
            }
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\guidmap.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       guidmap.cpp
//
//  Contents:   IActiveIMMAppEx::GetGuidAtom routines
//
//----------------------------------------------------------------------------

#include "private.h"

#include "context.h"
#include "globals.h"
#include "cdimm.h"



//
// IActiveIMMAppEx::GetGuidAtom method
//

STDMETHODIMP CActiveIMM::GetGuidAtom(HIMC hIMC, BYTE bAttr, TfGuidAtom* pGuidAtom)
{
    if (pGuidAtom == NULL) {
        return E_INVALIDARG;
    }

    *pGuidAtom = TF_INVALID_GUIDATOM;

    HRESULT hr;

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        if (pActiveIMM->_IsRealIme(NULL))
            return E_FAIL;
    }
    else
        return E_UNEXPECTED;

    DIMM_IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult())) {
        return hr;
    }

    if (imc->m_pContext != NULL) {
        return imc->m_pContext->GetGuidAtom(hIMC, bAttr, pGuidAtom);
    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\imewnd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewnd.cpp

Abstract:

    This file implements the Default IME window Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "defs.h"
#include "imewnd.h"
#include "imewndhd.h"



BOOL
CDefaultIMEWindow::_CreateDefaultIMEWindow(
    HIMC hDefIMC
    )
{
#ifndef CICERO_4678
    //
    // If m_hDefaultIMEWnd's owner is IMM32, then this value always valid hWnd.
    // For CICERO_4678, we should remove this code because subclass window hook
    // never start after Deactivate() and Activate().
    // In Trident and go to another Web page, Trident calls Deactivate() and Activate(),
    // first Deactivate() calls CDefaultIMEWindow::Stop() and
    // next Activate() calls here, however m_hDefaultIMEWnd already exist, then
    // returns immediately. Never calls CDefaultIMEWindow::Start().
    // Note: Cicero bug d/b #4678
    //
    if (m_hDefaultIMEWnd)
        /*
         * already exist IME window.
         */
        return TRUE;
#endif

    if (IsOnImm()) {
        //
        // Create dummy default IME window.
        //
        // When the IsOnImm() is TRUE, this function could get the default IME window handle
        // by using imm32.Imm32_GetDefaultIMEWnd() function.
        // Imm32's GetDefaultIMEWnd might be return no IME window when no any parent window
        // in this thread.
        // However, we can assume that GetDefaultIMEWnd must return a valid IME window.
        // Because, _CreateIMEWindow() function always create a dummy default IME
        // window.
        //
        if (m_hDummyDefaultIMEWnd == NULL) {
            m_hDummyDefaultIMEWnd = _CreateIMEWindow(NULL);
        }

#ifdef CICERO_4678
        if (m_hDefaultIMEWnd == NULL) {
            Imm32_GetDefaultIMEWnd(NULL, &m_hDefaultIMEWnd);
        }
#else
        Imm32_GetDefaultIMEWnd(NULL, &m_hDefaultIMEWnd);
#endif

        if (IsWindow(m_hDefaultIMEWnd) &&
            //
            // Set subclass window procedure.
            //
            Start()
           ) {
            CIMEWindowHandler* pimeui = GetImeWndHandler(m_hDefaultIMEWnd, TRUE);
            if (pimeui == NULL)
                return FALSE;
            pimeui->ImeWndCreateHandler(GetWindowLong(m_hDefaultIMEWnd, GWL_STYLE),
                                        hDefIMC);
        }
    }
    else {
        /*
         * NT5 have a IME class.
         */
        if (! IsOnNT5()) {
            WNDCLASSEX wcWndCls;

            wcWndCls.cbSize        = sizeof(WNDCLASSEX);
            wcWndCls.cbClsExtra    = 0;
            wcWndCls.cbWndExtra    = 0;
            wcWndCls.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
            wcWndCls.hInstance     = g_hInst;
            wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
            wcWndCls.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
            wcWndCls.lpszMenuName  = (LPTSTR)NULL;
            wcWndCls.hIconSm       = NULL;

            wcWndCls.style         = CS_GLOBALCLASS;
            wcWndCls.lpfnWndProc   = ImeWndProcA;
            wcWndCls.lpszClassName = "IME";

            if (! RegisterClassEx(&wcWndCls)) {
                return FALSE;
            }

            m_bMyRegisterClass = TRUE;
        }

        if (m_hDefaultIMEWnd == NULL) {
            m_hDefaultIMEWnd = _CreateIMEWindow(hDefIMC);
            if (m_hDefaultIMEWnd)
                m_bMyCreateWindow = TRUE;
            else
                return FALSE;
        }

        if (IsOnNT5() && IsWindow(m_hDefaultIMEWnd) && ! m_bMyRegisterClass &&
            //
            // Set subclass window procedure.
            //
            Start()
           ) {
            CIMEWindowHandler* pimeui = GetImeWndHandler(m_hDefaultIMEWnd, TRUE);
            if (pimeui == NULL)
                return FALSE;
            pimeui->ImeWndCreateHandler(GetWindowLong(m_hDefaultIMEWnd, GWL_STYLE),
                                        hDefIMC);
        }
    }

    if (m_hDefaultIMEWnd == NULL)
        return FALSE;
    else
        return TRUE;
}

BOOL
CDefaultIMEWindow::_DestroyDefaultIMEWindow(
    )
{
    Stop();

    if (IsWindow(m_hDummyDefaultIMEWnd)) {
        DestroyWindow(m_hDummyDefaultIMEWnd);
    }

    if (m_bMyCreateWindow) {
        DestroyWindow(m_hDefaultIMEWnd);
        m_bMyCreateWindow = FALSE;
        m_hDefaultIMEWnd = NULL;
    }
    else if (IsWindow(m_hDefaultIMEWnd)) {
        //
        // This DefaultIMEWnd is owned by IMM32.
        // If still exist DefaultIMEWnd, then DIMM12 never receive WM_NCDESTROY message
        // in CIMEWindowHandler::ImeWndProcWorker.
        // We need clean up memory of CIMEWindowHandler.
        //
        CIMEWindowHandler* pimeui = GetImeWndHandler(m_hDefaultIMEWnd);
        if (pimeui == NULL)
            return FALSE;
        pimeui->ImeWndFinalDestroyHandler();
    }

    if (m_bMyRegisterClass) {
        UnregisterClass("IME", g_hInst);
        m_bMyRegisterClass = FALSE;
    }

    return TRUE;
};

HWND
CDefaultIMEWindow::_CreateIMEWindow(
    HIMC hDefIMC
    )
{
    return CreateWindow("IME",
                        "",
                        WS_DISABLED | WS_POPUP,
                        0, 0, 0, 0,                    // x, y, width, height
                        NULL,                          // parent
                        NULL,                          // menu
                        g_hInst,
                        hDefIMC);                      // lpParam
}

HRESULT
CDefaultIMEWindow::GetDefaultIMEWnd(
    IN HWND hWnd,
    OUT HWND *phDefWnd
    )
{
    if (IsOnImm()) {
        Imm32_GetDefaultIMEWnd(hWnd, phDefWnd);
    }
    else {
        if (hWnd == NULL) {
            *phDefWnd = m_hDefaultIMEWnd;
        }
        else {
            if (GetWindowThreadProcessId(hWnd, NULL) == GetCurrentThreadId()) {
                *phDefWnd = m_hDefaultIMEWnd;
            }
            else {
                return E_FAIL;
            }
        }
    }

    return S_OK;
}

LRESULT
CDefaultIMEWindow::CallWindowProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (m_SubclassWindowProc != 0) {
        switch (uMsg) {
            case WM_IME_SETCONTEXT:
            case WM_IME_SELECT:
            {
                WNDPROC pfn = Stop();
                LRESULT lRet = ::CallWindowProc(pfn, hWnd, uMsg, wParam, lParam);
                Start();
                return lRet;
            }
        }
        return ::CallWindowProc((WNDPROC)m_SubclassWindowProc, hWnd, uMsg, wParam, lParam);
    }
    else {
        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
}

LRESULT
ImeWndProcA(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CIMEWindowHandler* pimeui = GetImeWndHandler(hwnd);
    if (pimeui == NULL)
        return 0L;
    return pimeui->ImeWndProcWorker(uMsg, wParam, lParam, FALSE);
}

LRESULT
ImeWndProcW(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CIMEWindowHandler* pimeui = GetImeWndHandler(hwnd);
    if (pimeui == NULL)
        return 0L;
    return pimeui->ImeWndProcWorker(uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\imewndhd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewndhd.cpp

Abstract:

    This file implements the IME window handler Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"


#include "defs.h"
#include "cdimm.h"
#include "imewndhd.h"
#include "globals.h"

LPCTSTR IMEWndHandlerName = TEXT("IMEWindowHandler");


CIMEWindowHandler::CIMEWindowHandler(
    HWND hwnd,
    BOOL fDefault
    )
{
    m_imeui.hImeWnd = hwnd;
    m_imeui.hIMC = NULL;
    m_imeui.nCntInIMEProc = 0;
    m_imeui.fDefault = fDefault;

    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return;

    _pActiveIMM->_GetKeyboardLayout(&m_hKL_UnSelect);
}

CIMEWindowHandler::~CIMEWindowHandler(
    )
{
}

LRESULT
CIMEWindowHandler::ImeWndProcWorker(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    LRESULT lr;

    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return 0L;

    lr = _ImeWndProcWorker(uMsg, wParam, lParam, fUnicode, _pActiveIMM);

    return lr;
}

LRESULT
CIMEWindowHandler::_ImeWndProcWorker(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )

{
    /*
     * This is necessary to avoid recursion call from IME UI.
     */
    
    if (IsIMEHandler() > 1) {
        TraceMsg(TF_API, "ImeWndProcWorker: Recursive for hwnd=%08x, msg=%08x, wp=%08x, lp=%08x", m_imeui.hImeWnd, uMsg, wParam, lParam);
        switch (uMsg) {
            case WM_IME_STARTCOMPOSITION:
            case WM_IME_ENDCOMPOSITION:
            case WM_IME_COMPOSITION:
            case WM_IME_SETCONTEXT:
            case WM_IME_NOTIFY:
            case WM_IME_CONTROL:
            case WM_IME_COMPOSITIONFULL:
            case WM_IME_SELECT:
            case WM_IME_CHAR:
            case WM_IME_REQUEST:
                return 0L;
            default:
                return pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, uMsg, wParam, lParam);
        }
    }

    switch (uMsg) {
        case WM_CREATE:
            ImeWndCreateHandler((LPCREATESTRUCT)lParam);
            break;

        case WM_DESTROY:
            /*
             * We are destroying the IME window,
             * destroy any UI window that it owns.
             */
            ImeWndDestroyHandler();
            break;

        case WM_NCDESTROY:
        /* case WM_FINALDESTROY: */
            pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, uMsg, wParam, lParam);
            ImeWndFinalDestroyHandler();
            return 0L;

        case WM_IME_SYSTEM:
            if (ImeSystemHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM))
                return 0L;
            break;

        case WM_IME_SELECT:
            ImeSelectHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_CONTROL:
            ImeControlHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_SETCONTEXT:
            ImeSetContextHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_NOTIFY:
            ImeNotifyHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
            break;

        case WM_IME_REQUEST:
            break;

        case WM_IME_COMPOSITION:
        case WM_IME_ENDCOMPOSITION:
        case WM_IME_STARTCOMPOSITION:
        {
            LRESULT lret;
            lret = SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);

            if (!pActiveIMM->_IsRealIme())
                return lret;

            break;
        }

        default:
            if (IsMsImeMessage(uMsg)) {
                if (! pActiveIMM->_IsRealIme()) {
                    return ImeMsImeHandler(uMsg, wParam, lParam, fUnicode, pActiveIMM);
                }
            }
            break;
    }

    return pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, uMsg, wParam, lParam);
}

LRESULT
CIMEWindowHandler::ImeWndCreateHandler(
    DWORD style,
    HIMC hDefIMC
    )
{
    if ( !(style & WS_POPUP) || !(style & WS_DISABLED)) {
        TraceMsg(TF_WARNING, "IME should have WS_POPUP and WS_DISABLED!!");
        return -1L;
    }

    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return 0L;

    /*
     */
    if (hDefIMC != NULL) {
        if (ImeIsUsableContext(m_imeui.hImeWnd, hDefIMC, _pActiveIMM)) {
            /*
             * Store it for later use.
             */
            ImeSetImc(hDefIMC, _pActiveIMM);
        }
        else {
            ImeSetImc(NULL, _pActiveIMM);
        }
    }
    else {
        ImeSetImc(NULL, _pActiveIMM);
    }

    return 0L;
}

LRESULT
CIMEWindowHandler::ImeWndCreateHandler(
    LPCREATESTRUCT lpcs
    )
{
    HIMC hIMC;

    if (lpcs->hwndParent != NULL) {
        CActiveIMM *_pActiveIMM = GetTLS();
        if (_pActiveIMM == NULL)
            return 0L;

        _pActiveIMM->GetContextInternal(lpcs->hwndParent, &hIMC, FALSE);
    }
    else if (lpcs->lpCreateParams) {
        hIMC = (HIMC)lpcs->lpCreateParams;
    }
    else
        hIMC = NULL;
    return ImeWndCreateHandler(lpcs->style, hIMC);
}

VOID
CIMEWindowHandler::ImeWndDestroyHandler(
    )
{
}

VOID
CIMEWindowHandler::ImeWndFinalDestroyHandler(
    )
{
    CActiveIMM *_pActiveIMM = GetTLS();
    if (_pActiveIMM == NULL)
        return;

    _pActiveIMM->_ImeWndFinalDestroyHandler();

    SetProp(m_imeui.hImeWnd, IMEWndHandlerName, NULL);
    delete this;
}

LRESULT
CIMEWindowHandler::ImeSystemHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    LRESULT dwRet = 0L;

    switch (wParam) {
        case IMS_ACTIVATETHREADLAYOUT:
            return ImeActivateLayout((HKL)lParam, pActiveIMM);
#ifdef CICERO_3564
        case IMS_FINALIZE_COMPSTR:
            if (! pActiveIMM->_IsRealIme())
            {
                /*
                 * KOREAN:
                 *  Finalize current composition string
                 */
                HIMC hIMC = ImeGetImc();
                pActiveIMM->NotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
            }
            break;
#endif // CICERO_3564
    }

    return dwRet;
}

LRESULT
CIMEWindowHandler::ImeSelectHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    /*
     * Deliver this message to other IME windows in this thread.
     */
    if (! pActiveIMM->_IsRealIme((HKL)lParam) && m_imeui.fDefault)
        ImeBroadCastMsg(uMsg, wParam, lParam, fUnicode);

    /*
     * We must re-create UI window of newly selected IME.
     */
    return pActiveIMM->_ImeSelectHandler(uMsg, wParam, lParam, fUnicode, ImeGetImc());
}

LRESULT
CIMEWindowHandler::ImeControlHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    /*
     * Do nothing with NULL hIMC.
     */
    HIMC hIMC = ImeGetImc();

    switch (wParam) {
        case IMC_OPENSTATUSWINDOW:
        case IMC_CLOSESTATUSWINDOW:
            pActiveIMM->HideOrRestoreToolbarWnd(IMC_OPENSTATUSWINDOW == wParam);
            break;

        /*
         * ------------------------------------------------
         * IMC_SETCOMPOSITIONFONT,
         * IMC_SETCONVERSIONMODE,
         * IMC_SETOPENSTATUS
         * ------------------------------------------------
         * Don't pass these WM_IME_CONTROLs to UI window.
         * Call Imm in order to process these requests instead.
         * It makes message flows simpler.
         */
        case IMC_SETCOMPOSITIONFONT:
            if (hIMC != NULL)
            {
                LOGFONTAW* lplf = (LOGFONTAW*)lParam;
                if (fUnicode)
                {
                    if (FAILED(pActiveIMM->SetCompositionFontW(hIMC, (LOGFONTW *)lplf)))
                        return 1L;
                }
                else
                {
                    if (FAILED(pActiveIMM->SetCompositionFontA(hIMC, (LOGFONTA *)lplf)))
                        return 1L;
                }
            }
            break;

        case IMC_SETCONVERSIONMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(pActiveIMM->GetConversionStatus(hIMC, &dwConversion, &dwSentence)) ||
                    FAILED(pActiveIMM->SetConversionStatus(hIMC, (DWORD)lParam, dwSentence)))
                    return 1L;
            }
            break;

        case IMC_SETSENTENCEMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(pActiveIMM->GetConversionStatus(hIMC, &dwConversion, &dwSentence)) ||
                    FAILED(pActiveIMM->SetConversionStatus(hIMC, dwConversion, (DWORD)lParam)))
                    return 1L;
            }
            break;

        case IMC_SETOPENSTATUS:
            if (hIMC != NULL)
            {
                if (FAILED(pActiveIMM->SetOpenStatus(hIMC, (int)lParam)))
                    return 1L;
            }
            break;

#if 0   // internal
        case IMC_GETCONVERSIONMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(GetTeb()->GetConversionStatus(hIMC, &dwConversion, &dwSentence)))
                    return 1L;
                return dwConversion;
            }

        case IMC_GETSENTENCEMODE:
            if (hIMC != NULL)
            {
                DWORD dwConversion, dwSentence;
                if (FAILED(GetTeb()->GetConversionStatus(hIMC, &dwConversion, &dwSentence)))
                    return 1L;
                return dwSentence;
            }

        case IMC_GETOPENSTATUS:
            if (hIMC != NULL)
                return GetTeb()->GetOpenStatus(hIMC);
#endif

        case IMC_GETCOMPOSITIONFONT:
            if (hIMC != NULL)
            {
                LOGFONTAW* lplf = (LOGFONTAW*)lParam;
                if (fUnicode)
                {
                    if (FAILED(pActiveIMM->GetCompositionFontW(hIMC, (LOGFONTW *)lplf)))
                        return 1L;
                }
                else
                {
                    if (FAILED(pActiveIMM->GetCompositionFontA(hIMC, (LOGFONTA *)lplf)))
                        return 1L;
                }
            }
            break;

        case IMC_SETCOMPOSITIONWINDOW:
            if (hIMC != NULL)
            {
                if (FAILED(pActiveIMM->SetCompositionWindow(hIMC, (LPCOMPOSITIONFORM)lParam)))
                    return 1L;
            }
            break;

        case IMC_SETSTATUSWINDOWPOS:
            if (hIMC != NULL)
            {
                POINT ppt;
                ppt.x = (LONG)((LPPOINTS)&lParam)->x;
                ppt.y = (LONG)((LPPOINTS)&lParam)->y;
                if (FAILED(pActiveIMM->SetStatusWindowPos(hIMC, &ppt)))
                    return 1L;
            }
            break;

        case IMC_SETCANDIDATEPOS:
            if (hIMC != NULL)
            {
                if (FAILED(pActiveIMM->SetCandidateWindow(hIMC, (LPCANDIDATEFORM)lParam)))
                    return 1L;
            }
            break;

        /*
         * Followings are the messages to be sent to UI.
         */
        case IMC_GETCANDIDATEPOS:
        case IMC_GETSTATUSWINDOWPOS:
        case IMC_GETCOMPOSITIONWINDOW:
        case IMC_GETSOFTKBDPOS:
        case IMC_SETSOFTKBDPOS:
            if (hIMC != NULL)
                return SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);

        default:
            break;
    }

    return 0L;
}

LRESULT
CIMEWindowHandler::ImeSetContextHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    if (wParam) {
        /*
         * if it's being activated
         */
        if (GetWindowThreadProcessId(m_imeui.hImeWnd, NULL) != GetCurrentThreadId()) {
            TraceMsg(TF_WARNING, "ImeSetContextHandler: Can not access other thread's hIMC");
            return 0L;
        }

        HWND hwndFocus = GetFocus();
        HIMC hFocusImc;

        //
        // hFocusImc always need to set some valid hIMC for SetUIWindowContext().
        // When sets NULL hIMC in SetUIWindowContext(), message deliver to UI window
        // has been stop.
        //
        if (FAILED(pActiveIMM->GetContextInternal(hwndFocus, &hFocusImc, TRUE))) {
            TraceMsg(TF_WARNING, "ImeSetContextHandler: No hFocusImc");
            return 0L;
        }

        /*
         * Cannot share input context with other IME window.
         */
        if (hFocusImc != NULL &&
            ! ImeIsUsableContext(m_imeui.hImeWnd, hFocusImc, pActiveIMM)) {
            ImeSetImc(NULL, pActiveIMM);
            return 0L;
        }

        ImeSetImc(hFocusImc, pActiveIMM);

        /*
         * Store it to the window memory
         */
        pActiveIMM->SetUIWindowContext(hFocusImc);
    }

    return SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);
}

LRESULT
CIMEWindowHandler::ImeNotifyHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    LRESULT lRet = 0L;

    switch (wParam) {
        case IMN_PRIVATE:
            break;

        case IMN_SETCONVERSIONMODE:
        case IMN_SETOPENSTATUS:
            //
            // notify shell and keyboard the conversion mode change
            //

            /*** FALL THROUGH ***/
        default:
            lRet = SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);
    }

    return lRet;
}

LRESULT
CIMEWindowHandler::ImeMsImeHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    return SendMessageToUI(uMsg, wParam, lParam, fUnicode, pActiveIMM);
}

LRESULT
CIMEWindowHandler::SendMessageToUI(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode,
    CActiveIMM* pActiveIMM
    )
{
    LRESULT lRet;

    InterlockedIncrement(&m_imeui.nCntInIMEProc);    // Mark to avoid recursion.
    lRet = pActiveIMM->_SendUIMessage(uMsg, wParam, lParam);
    InterlockedDecrement(&m_imeui.nCntInIMEProc);
    return lRet;
}

LRESULT
CIMEWindowHandler::ImeActivateLayout(
    HKL hSelKL,
    CActiveIMM* pActiveIMM
    )
{
    if (hSelKL == m_hKL_UnSelect)
        //
        // Apps startup time, msctf!PostInputLangRequest may calls ActivateKeyboardLayout
        // with Cicero's hKL (04110411 or 08040804).
        // However, CIMEWindowHandle::m_hKL_UnSelect also have Cicero's hKL because
        // this class ask to ITfInputProcessorProfile.
        //
        return TRUE;

    HKL hUnSelKL = m_hKL_UnSelect;

    /*
     * Save IME_CMODE_GUID_NULL and IME_SMODE_GUID_NULL bit in the CContextList
     * When hSelKL is regacy IME, IMM32 SelectInputContext reset this flag.
     */
    CContextList _hIMC_MODE_GUID_NULL;

    Interface<IEnumInputContext> EnumInputContext;
    HRESULT hr = pActiveIMM->EnumInputContext(0,       // 0 = Current Thread
                                              EnumInputContext);
    if (SUCCEEDED(hr)) {
        CEnumrateValue<IEnumInputContext,
                       HIMC,
                       CContextList> Enumrate(EnumInputContext,
                                              EnumInputContextCallback,
                                              &_hIMC_MODE_GUID_NULL);

        Enumrate.DoEnumrate();
    }

    /*
     * Deactivate layout (hUnSelKL).
     */
    pActiveIMM->_DeactivateLayout(hSelKL, hUnSelKL);

    IMTLS *ptls;
    LANGID langid;

    if ((ptls = IMTLS_GetOrAlloc()) != NULL)
    {
        ptls->pAImeProfile->GetLangId(&langid);

        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            //
            // Save open and conversion status for Korean
            //
            if (_hIMC_MODE_GUID_NULL.GetCount() > 0)
            {
                POSITION pos = _hIMC_MODE_GUID_NULL.GetStartPosition();
                int index;
                for (index = 0; index < _hIMC_MODE_GUID_NULL.GetCount(); index++)
                {
                    HIMC hIMC;
                    CContextList::CLIENT_IMC_FLAG client_flag;
                    _hIMC_MODE_GUID_NULL.GetNextHimc(pos, &hIMC, &client_flag);
                    if (client_flag & (CContextList::IMCF_CMODE_GUID_NULL |
                                       CContextList::IMCF_SMODE_GUID_NULL  ))
                    {
                        DIMM_IMCLock imc(hIMC);
                        if (SUCCEEDED(imc.GetResult()))
                            imc->fdwHangul = imc->fdwConversion;
                    }
                }
            }
        }
    }


    // /*
    //  * If either hKL are regacy IME, then should call IMM32's handler.
    //  */
    // if (_pThread->IsRealIme(hSelKL) || _pThread->IsRealIme(hUnSelKL))
        pActiveIMM->_CallWindowProc(m_imeui.hImeWnd, 
                                    WM_IME_SYSTEM, 
                                    IMS_ACTIVATETHREADLAYOUT, 
                                    (LPARAM)hSelKL);

    /*
     * Activate layout (hSelKL).
     */
    pActiveIMM->_ActivateLayout(hSelKL, hUnSelKL);

    /*
     * Restore CContextList's IME_CMODE_GUID_NULL and IME_SMODE_GUID_NULL to each hIMC
     */
    if (_hIMC_MODE_GUID_NULL.GetCount() > 0) {
        POSITION pos = _hIMC_MODE_GUID_NULL.GetStartPosition();
        int index;
        for (index = 0; index < _hIMC_MODE_GUID_NULL.GetCount(); index++) {
            HIMC hIMC;
            CContextList::CLIENT_IMC_FLAG client_flag;
            _hIMC_MODE_GUID_NULL.GetNextHimc(pos, &hIMC, &client_flag);
            if (client_flag & (CContextList::IMCF_CMODE_GUID_NULL |
                               CContextList::IMCF_SMODE_GUID_NULL  )) {
                DIMM_IMCLock imc(hIMC);
                if (SUCCEEDED(imc.GetResult())) {
                    if (PRIMARYLANGID(langid) == LANG_KOREAN) {
                        //
                        // Restore open and conversion status value by changing IMM32
                        //
                            imc->fdwConversion = imc->fdwHangul;
                            if (imc->fdwConversion &
                                (IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE))
                                imc->fOpen = TRUE;
                            else
                                imc->fOpen = FALSE;
                     }
                     if (client_flag & CContextList::IMCF_CMODE_GUID_NULL)
                         imc->fdwConversion |= IME_CMODE_GUID_NULL;
                     if (client_flag & CContextList::IMCF_SMODE_GUID_NULL)
                         imc->fdwSentence   |= IME_SMODE_GUID_NULL;
                }
            }
        }
    }

    /*
     * Set unselect hKL value
     */
    m_hKL_UnSelect = hSelKL;

    return TRUE;
}

VOID
CIMEWindowHandler::ImeSetImc(
    HIMC hIMC,
    CActiveIMM* pActiveIMM
    )
{
    HIMC hOldImc = ImeGetImc();

    /*
     * return if nothing to change.
     */
    if (hIMC == hOldImc)
        return;

    /*
     * Unmark the old input context.
     */
    if (hOldImc != NULL)
        ImeMarkUsedContext(NULL, hOldImc, pActiveIMM);

    /*
     * Update the in use input context for this IME window.
     */
    m_imeui.hIMC = hIMC;

    /*
     * Mark the new input context.
     */
    if (hIMC != NULL)
        ImeMarkUsedContext(m_imeui.hImeWnd, hIMC, pActiveIMM);
}

VOID
CIMEWindowHandler::ImeMarkUsedContext(
    HWND hImeWnd,
    HIMC hIMC,
    CActiveIMM* pActiveIMM
    )

/*+++

    Some IME windows can not share same input context.
    This function marks the specified hIMC to be in used by the specified IME window.

---*/

{
    HWND hImcImeWnd;

    if (! pActiveIMM->_ContextLookup(hIMC, &hImcImeWnd)) {
        TraceMsg(TF_WARNING, "ImeMarkUsedContext: Invalid hImc (=%lx).", hIMC);
        return;
    }

    /*
     * Nothing to change?
     */
    if (hImcImeWnd == hImeWnd)
        return;

    pActiveIMM->_ContextUpdate(hIMC, hImeWnd);
    return;
}

BOOL
CIMEWindowHandler::ImeIsUsableContext(
    HWND hImeWnd,
    HIMC hIMC,
    CActiveIMM* pActiveIMM
    )

/*+++

    Some IME windows can not share the same input context.
    This function checks whether the specified hIMC can be used (means 'Set activated')
    by the specified IME window.

    Return: TRUE - OK to use the hIMC by hImeWnd.
            FALSE - otherwise.

---*/

{
    HWND hImcImeWnd;

    if (! pActiveIMM->_ContextLookup(hIMC, &hImcImeWnd)) {
        TraceMsg(TF_WARNING, "ImeIsUsableContext: Invalid hIMC (=%lx).", hIMC);
        return FALSE;
    }

    if (hImcImeWnd == NULL ||
        hImcImeWnd == hImeWnd ||
        ! IsWindow(hImcImeWnd))
        return TRUE;
    else
        return FALSE;
}

BOOL
CIMEWindowHandler::ImeBroadCastMsg(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    return TRUE;
}


ENUM_RET
CIMEWindowHandler::EnumInputContextCallback(
    HIMC hIMC,
    CContextList* pList
    )
{
    DIMM_IMCLock imc(hIMC);
    if (SUCCEEDED(imc.GetResult())) {
        CContextList::CLIENT_IMC_FLAG client_flag = CContextList::IMCF_NONE;

        if (imc->fdwConversion & IME_CMODE_GUID_NULL)
            client_flag = (CContextList::CLIENT_IMC_FLAG)(client_flag | CContextList::IMCF_CMODE_GUID_NULL);

        if (imc->fdwSentence   & IME_SMODE_GUID_NULL)
            client_flag = (CContextList::CLIENT_IMC_FLAG)(client_flag | CContextList::IMCF_SMODE_GUID_NULL);

        pList->SetAt(hIMC, client_flag);
    }

    return ENUM_CONTINUE;
}


CIMEWindowHandler*
GetImeWndHandler(
    HWND hwnd,
    BOOL fDefault
    )
{
    CIMEWindowHandler* pimeui = static_cast<CIMEWindowHandler*>(GetProp(hwnd, IMEWndHandlerName));
    if (pimeui == NULL) {
        pimeui = new CIMEWindowHandler(hwnd, fDefault);
        if (pimeui == NULL) {
            return NULL;
        }
        SetProp(hwnd, IMEWndHandlerName, pimeui);
    }

    pimeui->ImeSetWnd(hwnd);
    return pimeui;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\imewnd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewnd.h

Abstract:

    This file defines the Default IME Window Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMEWND_H_
#define _IMEWND_H_

#include "cstring.h"

extern "C" {
    // windows subclass
    LRESULT ImeWndProcA(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ImeWndProcW(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
}

class CDefaultIMEWindow
{
public:
    CDefaultIMEWindow() {
        m_hDefaultIMEWnd = NULL;
        m_hDummyDefaultIMEWnd = NULL;
        m_nCntInAIMEProc = 0;

        m_bMyRegisterClass = FALSE;
        m_bMyCreateWindow = FALSE;
        // m_bNeedRecoverIMEWndProc = FALSE;

        m_SubclassWindowProc = 0;
    }

    virtual ~CDefaultIMEWindow() {
        if (IsWindow(m_hDefaultIMEWnd) && m_SubclassWindowProc) {
            //
            // Set the wndproc pointer back to original WndProc.
            //
            // some other subclass window may keep my WndProc pointer.
            // but msctf.dll may be unloaded from memory so we don't want to
            // call him to set the wndproc pointer back to our Wndproc pointer.
            // The pointer will be bogus.
            //
            WNDPROC pfnOrgImeWndProc;
            pfnOrgImeWndProc = (WNDPROC)GetClassLongPtr(m_hDefaultIMEWnd, GCLP_WNDPROC);
            SetWindowLongPtr(m_hDefaultIMEWnd,
                             GWLP_WNDPROC,
                             (LONG_PTR)pfnOrgImeWndProc);
            m_SubclassWindowProc = NULL;
        }
    }

    HRESULT GetDefaultIMEWnd(IN HWND hWnd, OUT HWND *phDefWnd);
    LRESULT CallWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT  SendIMEMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE,
                            BOOL fCheckImm32 = TRUE) {
        if (fCheckImm32 && IsOnImm()) {
            return 0L;
        }

        LRESULT lRet;
        InterlockedIncrement(&m_nCntInAIMEProc);    // Mark to avoid recursion.
        if (fUnicode)
            lRet = SendMessageW(m_hDefaultIMEWnd, Msg, wParam, lParam);
        else
            lRet = SendMessageA(m_hDefaultIMEWnd, Msg, wParam, lParam);
        InterlockedDecrement(&m_nCntInAIMEProc);
        return lRet;
    }

    BOOL IsAIMEHandler()
    {
        return (m_nCntInAIMEProc > 0);
    }

public:
    BOOL _CreateDefaultIMEWindow(HIMC hDefIMC);
    BOOL _DestroyDefaultIMEWindow();

protected:
    HWND _CreateIMEWindow(HIMC hDefIMC);

public:
    BOOL IsNeedRecovIMEWndProc() {
#if 0
        return (m_bNeedRecoverIMEWndProc == TRUE);
#endif
        return FALSE;
    }

private:
#if 0
    BOOL InitDefIMEWndSubclass() {
        if (m_SubclassWindowProc == NULL) {
            m_SubclassWindowProc = SetWindowLongPtr(m_hDefaultIMEWnd,
                                                    GWLP_WNDPROC,
                                                    (LONG_PTR)ImeWndProcA);
            if (IsOnImm()) {
                LONG_PTR _OriginalWindowProc = GetWindowLongPtr(m_hDummyDefaultIMEWnd,
                                                                GWLP_WNDPROC);
                //
                // We assume the m_SubclassWindowProc and _OriginalWindowProc are
                // the same address of USER32!ImeWndProcA/W.
                //
                if (m_SubclassWindowProc != _OriginalWindowProc) {
                    //
                    // Anybody rewrote the default IME window procedure address.
                    // We know the MSIME9x/2K rewrote an address to MSIMEPrivateWindowProc.
                    // We should catch a recovery procedure address by the IME
                    // that using window call hook the _DefImeWnd_CallWndProc.
                    //
                    m_bNeedRecoverIMEWndProc = TRUE;
                }
            }
        }
        return (m_SubclassWindowProc != 0);
    }
#endif
    BOOL Start() {
        Assert(IsWindow(m_hDefaultIMEWnd));
        if (m_SubclassWindowProc == NULL) {
            m_SubclassWindowProc = SetWindowLongPtr(m_hDefaultIMEWnd,
                                                    GWLP_WNDPROC,
                                                    (LONG_PTR)ImeWndProcA);
        }
        return (m_SubclassWindowProc != 0);
    }

#if 0
    VOID UninitDefIMEWndSubclass() {
        if (m_SubclassWindowProc) {
            SetWindowLongPtr(m_hDefaultIMEWnd,
                             GWLP_WNDPROC,
                             m_SubclassWindowProc);
            m_SubclassWindowProc = NULL;
        }
    }
#endif
    WNDPROC Stop() {
        Assert(IsWindow(m_hDefaultIMEWnd));
        WNDPROC pfnBack = (WNDPROC)m_SubclassWindowProc;
        if (m_SubclassWindowProc != NULL) {
            //
            // unfortunately, we can not restore the wndproc pointer always.
            // someone else subclassed it after we did.
            //
            WNDPROC pfnCur = (WNDPROC)GetWindowLongPtr(m_hDefaultIMEWnd, GWLP_WNDPROC);
            if (pfnCur == ImeWndProcA) {
                SetWindowLongPtr(m_hDefaultIMEWnd,
                                 GWLP_WNDPROC,
                                 (LONG_PTR) m_SubclassWindowProc);
                m_SubclassWindowProc = NULL;
            }
        }
        return pfnBack;
    }

public:
    VOID ImeDefWndHook(HWND hWnd) {
#if 0
        LONG_PTR _WindowProc = GetWindowLongPtr(m_hDefaultIMEWnd,
                                                GWLP_WNDPROC);
        ASSERT(m_hDummyDefaultIMEWnd != NULL);
        LONG_PTR _OriginalWindowProc = GetWindowLongPtr(m_hDummyDefaultIMEWnd,
                                                        GWLP_WNDPROC);
        if (_WindowProc == _OriginalWindowProc) {
            //
            // Recovered procedure address.
            //
            m_SubclassWindowProc = SetWindowLongPtr(m_hDefaultIMEWnd,
                                                    GWLP_WNDPROC,
                                                    (LONG_PTR)ImeWndProcA);
        }
#endif
    }

private:
    HWND         m_hDefaultIMEWnd;          // Handle of default IME window.
    HWND         m_hDummyDefaultIMEWnd;     // Handle of Dummy default IME window.

    LONG         m_nCntInAIMEProc;          // Non-zero if hwnd has called into CCiceroIME::ActivateLayout/DeactivateLayout.

    BOOL         m_bMyRegisterClass;        // TRUE: RegisterClass("IME") myself.
    BOOL         m_bMyCreateWindow;         // TRUE: CreateWindow("IME") myself.
    // BOOL         m_bNeedRecoverIMEWndProc;  // TRUE: Need a recovery IME wnd proc addr.

    LONG_PTR     m_SubclassWindowProc;      // Address of subclass window procedure.
};

LRESULT ImeWndDestroyHandler(HWND hwnd);
LRESULT ImeSelectHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
LRESULT ImeControlHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
LRESULT ImeSetContextHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
LRESULT ImeNotifyHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

#endif // _IMEWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\imclock2.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    DIMM_IMCLock.cpp

Abstract:

    This file implements the DIMM_IMCLock / DIMM_IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"
#include "imclock2.h"
#include "defs.h"
#include "delay.h"
#include "globals.h"
#include "cdimm.h"

DIMM_IMCLock::DIMM_IMCLock(
    HIMC hImc
    ) : _IMCLock(hImc)
{
    if (hImc) {
        /*
         * Set m_fUnicde and m_uCodePage
         */
        DWORD dwProcessId;
        CActiveIMM *_this = GetTLS();
        if (_this == NULL)
            return;

        if (!_this->_ContextLookup(hImc, &dwProcessId, &m_fUnicode))
            return;

        m_hr = _LockIMC(hImc, &m_inputcontext);
    }
}

HRESULT
DIMM_IMCLock::_LockIMC(
    IN HIMC hIMC,
    OUT INPUTCONTEXT_AIMM12 **ppIMC
    )
{
    TraceMsg(TF_API, "_LockIMC");

    if (hIMC == NULL)
        return E_INVALIDARG;

    /*
     * Get Process ID
     */
    DWORD dwProcessId;

    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return E_FAIL;

    if (!_this->_ContextLookup(hIMC, &dwProcessId))
        return E_ACCESSDENIED;

    if (IsOnImm()) {
        return Imm32_LockIMC(hIMC, (INPUTCONTEXT**)ppIMC);
    }
    else {
        /*
         * Cannot access input context from other process.
         */
        if (dwProcessId != GetCurrentProcessId())
            return E_ACCESSDENIED;

        *ppIMC = (INPUTCONTEXT_AIMM12 *)LocalLock(hIMC);
    }

    return *ppIMC == NULL ? E_FAIL : S_OK;
}

HRESULT
DIMM_IMCLock::_UnlockIMC(
    IN HIMC hIMC
    )
{
    TraceMsg(TF_API, "_UnlockIMC");

    if (IsOnImm()) {
        return Imm32_UnlockIMC(hIMC);
    }
    else {
        // for now HIMC are LocalAlloc(LHND) handle
        if (LocalUnlock(hIMC)) {
            // memory object still locked.
            return S_OK;
        }
        else {
            DWORD err = GetLastError();
            if (err == NO_ERROR)
                // memory object is unlocked.
                return S_OK;
            else if (err == ERROR_NOT_LOCKED)
                // memory object is already unlocked.
                return S_OK;
        }
    }
    return E_FAIL;
}



DIMM_InternalIMCCLock::DIMM_InternalIMCCLock(
    HIMCC hImcc
    ) : _IMCCLock(hImcc)
{
    if (hImcc) {
        m_hr = _LockIMCC(m_himcc, (void**)&m_pimcc);
    }
}


HRESULT
DIMM_InternalIMCCLock::_LockIMCC(
    HIMCC hIMCC,
    void** ppv
    )
{
    TraceMsg(TF_API, "_LockIMCC");

    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    if (IsOnImm()) {
        return Imm32_LockIMCC(hIMCC, ppv);
    }
    else {
        *ppv = (void *)LocalLock(hIMCC);
    }

    return *ppv == NULL ? E_FAIL : S_OK;
}

HRESULT
DIMM_InternalIMCCLock::_UnlockIMCC(
    HIMCC hIMCC
    )
{
    TraceMsg(TF_API, "_UnlockIMCC");

    if (IsOnImm()) {
        return Imm32_UnlockIMCC(hIMCC);
    }
    else {
        if (LocalUnlock(hIMCC)) {
            // memory object still locked.
            return S_OK;
        }
        else {
            DWORD err = GetLastError();
            if (err == NO_ERROR)
                // memory object is unlocked.
                return S_OK;
            else if (err == ERROR_NOT_LOCKED)
                // memory object is already unlocked.
                return S_OK;
        }
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\imewndhd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imewndhd.h

Abstract:

    This file defines the IME window handler Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMEWNDHD_H_
#define _IMEWNDHD_H_

#include "ctxtlist.h"
#include "globals.h"

extern LPCTSTR IMEWndHandlerName;

class CIMEWindowHandler
{
public:
    CIMEWindowHandler(HWND hwnd = NULL, BOOL fDefault = FALSE);
    ~CIMEWindowHandler();

    LRESULT ImeWndCreateHandler(DWORD style, HIMC hDefIMC);
    LRESULT ImeWndCreateHandler(LPCREATESTRUCT lpcs);

    HIMC ImeGetImc()
    {
        return m_imeui.hIMC;
    }

    VOID ImeSetWnd(HWND hwnd)
    {
        m_imeui.hImeWnd = hwnd;
    }

    LRESULT ImeWndProcWorker(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE);

private:
    LRESULT _ImeWndProcWorker(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);

public:
    VOID    ImeWndFinalDestroyHandler();

private:
    VOID    ImeWndDestroyHandler();
    LRESULT ImeSystemHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeSelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeControlHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeSetContextHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeNotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);
    LRESULT ImeMsImeHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);

    LRESULT SendMessageToUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode, CActiveIMM* pActiveIMM);

    LRESULT ImeActivateLayout(HKL hSelKL, CActiveIMM* pActiveIMM);
    VOID ImeSetImc(HIMC hIMC, CActiveIMM* pActiveIMM);

    VOID ImeMarkUsedContext(HWND hImeWnd, HIMC hIMC, CActiveIMM* pActiveIMM);
    BOOL ImeIsUsableContext(HWND hImeWnd, HIMC hIMC, CActiveIMM* pActiveIMM);
    BOOL ImeBroadCastMsg(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

    int IsIMEHandler()
    {
        return (m_imeui.nCntInIMEProc);
    }

    BOOL IsMsImeMessage(UINT uMsg)
    {
        if (uMsg == WM_MSIME_SERVICE ||
            uMsg == WM_MSIME_UIREADY ||
            uMsg == WM_MSIME_RECONVERTREQUEST ||
            uMsg == WM_MSIME_RECONVERT ||
            uMsg == WM_MSIME_DOCUMENTFEED ||
            uMsg == WM_MSIME_QUERYPOSITION ||
            uMsg == WM_MSIME_MODEBIAS ||
            uMsg == WM_MSIME_SHOWIMEPAD ||
            uMsg == WM_MSIME_MOUSE ||
            uMsg == WM_MSIME_KEYMAP)
            return TRUE;
        else
            return FALSE;
    }

    //
    // Enumrate callbacks
    //
    static ENUM_RET EnumInputContextCallback(HIMC hIMC,
                                             CContextList* pList);

private:
    typedef struct tagIMEUI {
        HWND  hImeWnd;
        HIMC  hIMC;
        LONG  nCntInIMEProc;   // Non-zero if hwnd has called into ImeWndProc.
        BOOL  fDefault:1;      // TRUE if this is the default IME.
    } IMEUI;
    IMEUI     m_imeui;

    HKL   m_hKL_UnSelect;      // Use in ImeActivateLayout() for unselect hKL value.
};



CIMEWindowHandler* GetImeWndHandler(HWND hwnd, BOOL fDefault = FALSE);


#endif // _IMEWNDHD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\imclock2.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imclock2.h

Abstract:

    This file defines the DIMM_IMCLock / DIMM_IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#ifndef IMCLOCK2_H
#define IMCLOCK2_H

#define  _ENABLE_AIME_CONTEXT_
#include "imclock.h"

class DIMM_IMCLock : public _IMCLock
{
public:
    DIMM_IMCLock(HIMC hImc=NULL);
    virtual ~DIMM_IMCLock() {
        if (m_inputcontext) {
            _UnlockIMC(m_himc);
        }
    }

    // virtual DIMM_InternalIMCCLock
    HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT_AIMM12** ppIMC);
    HRESULT _UnlockIMC(HIMC hIMC);

private:
    // Do not allow to make a copy
    DIMM_IMCLock(DIMM_IMCLock&) { }
};


class DIMM_InternalIMCCLock : public _IMCCLock
{
public:
    DIMM_InternalIMCCLock(HIMCC hImcc=NULL);
    virtual ~DIMM_InternalIMCCLock() {
        if (m_pimcc) {
            _UnlockIMCC(m_himcc);
        }
    }

    // virtual DIMM_InternalIMCCLock
    HRESULT _LockIMCC(HIMCC hIMCC, void** ppv);
    HRESULT _UnlockIMCC(HIMCC hIMCC);

private:
    // Do not allow to make a copy
    DIMM_InternalIMCCLock(DIMM_InternalIMCCLock&) { }
};


template <class T>
class DIMM_IMCCLock : public DIMM_InternalIMCCLock
{
public:
    DIMM_IMCCLock(HIMCC hImcc=NULL) : DIMM_InternalIMCCLock(hImcc) {};

    T* GetBuffer() { return (T*)m_pimcc; }

    operator T*() { return (T*)m_pimcc; }

    T* operator->() {
        ASSERT(m_pimcc);
        return (T*)m_pimcc;
    }

private:
    // Do not allow to make a copy
    DIMM_IMCCLock(DIMM_IMCCLock<T>&) { }
};


#endif // IMCLOCK2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\imccomp.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imccomp.h

Abstract:

    This file defines the Context of Composition Class.

Author:

Revision History:

Notes:

    This implementation is almost identical to ..\inc\ctxtcmp.h.

--*/

#ifndef IMCCOMP_H
#define IMCCOMP_H

#include "template.h"

/////////////////////////////////////////////////////////////////////////////
// GetCompInfo

template<class T>
HRESULT
GetCompInfo(
    IN T size,
    IN DWORD len,
    IN LONG*& lpCopied
    )
{
    *lpCopied = (LONG)(len * size);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CompData

template<class TYPE, class ARG_TYPE>
class CompData
{
public:
    CompData(HIMC hIMC = NULL, ARG_TYPE* lpsz = NULL, DWORD dwLen = 0)
    {
        DIMM_IMCLock lpIMC(hIMC);
        if (lpIMC.Invalid())
            return;

        if (lpsz)
            WriteCompData(lpsz, dwLen);
    }

    CompData(DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr)
    {
    }

    CompData(DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr, DWORD dwIndex);

    DWORD WriteCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();
        if (!psz)
            return 0;

        DWORD index = dwLen;
        while (index--) {
            *psz++ = data;
        }

        return dwLen;
    }

    DWORD WriteCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();
        if (!psz)
            return 0;

        memcpy(psz, lpSrc, dwLen * sizeof(TYPE));
        return dwLen;
    }

    DWORD AddCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData();
        if (!psTemp)
            return 0;

        memcpy(psTemp+dwl, lpSrc, dwLen*sizeof(TYPE));

        return dwLen;
    }

    DWORD AddCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData();
        if (!psTemp)
            return 0;

        psTemp += dwl;

        DWORD index = dwLen;
        while (index--) {
            *psTemp++ = data;
        }

        return dwLen;
    }

    const INT_PTR ReadCompData(IN ARG_TYPE* lpDest = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_array.GetSize();
        }
        else {
            ARG_TYPE* psz = m_array.GetData();
            if ((INT_PTR)dwLen > m_array.GetSize()) {
                dwBufLen = m_array.GetSize();
            }
            else {
                dwBufLen = (INT_PTR)dwLen;
            }
            memcpy(lpDest, psz, dwBufLen * sizeof(TYPE));
        }
        return dwBufLen;
    }

    DWORD GetCompStrIndex(IN DWORD dwIndex) {
        switch(dwIndex) {
            case GCS_COMPATTR:         return GCS_COMPSTR;
            case GCS_COMPREADATTR:     return GCS_COMPREADSTR;
            case GCS_COMPCLAUSE:       return GCS_COMPSTR;
            case GCS_COMPREADCLAUSE:   return GCS_COMPREADSTR;
            case GCS_RESULTCLAUSE:     return GCS_RESULTSTR;
            case GCS_RESULTREADCLAUSE: return GCS_RESULTREADSTR;
            case GCS_CURSORPOS:        return GCS_COMPSTR;
            case GCS_DELTASTART:       return GCS_COMPSTR;
            default:                   break;
        }
        ASSERT(FALSE);
        return 0;
    }

    TYPE GetAt(INT_PTR nIndex) const
    {
        return  m_array.GetAt(nIndex);
    }

    void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
    {
        m_array.SetAtGrow(nIndex, newElement);
    }

    INT_PTR Add(ARG_TYPE newElement)
    {
        return m_array.Add(newElement);
    }

    INT_PTR GetSize() const
    {
        return m_array.GetSize();
    }

    void RemoveAll()
    {
        m_array.RemoveAll();
    }

    operator void* ()
    {
        return m_array.GetData();
    }

    TYPE operator[](INT_PTR nIndex)
    {
        return m_array.GetAt(nIndex);
    }

protected:
    CArray<TYPE, ARG_TYPE>    m_array;
};

template<class TYPE, class ARG_TYPE>
CompData<TYPE, ARG_TYPE>::CompData(
    DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
    DWORD dwIndex
    )
{
    switch (dwIndex) {
        case GCS_COMPSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompStrOffset),
                                                            lpCompStr->CompStr.dwCompStrLen);        // # of chars
            break;
        case GCS_COMPREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadStrOffset),
                                                            lpCompStr->CompStr.dwCompReadStrLen);    // # of chars
            break;
        case GCS_RESULTSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultStrOffset),
                                                            lpCompStr->CompStr.dwResultStrLen);      // # of chars
            break;
        case GCS_RESULTREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadStrOffset),
                                                            lpCompStr->CompStr.dwResultReadStrLen);  // # of chars
            break;

        case GCS_COMPATTR:        // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompAttrOffset),
                                                            lpCompStr->CompStr.dwCompAttrLen);
            break;
        case GCS_COMPREADATTR:    // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadAttrOffset),
                                                            lpCompStr->CompStr.dwCompReadAttrLen);
            break;

        case GCS_COMPREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadClauseOffset),
                                                            lpCompStr->CompStr.dwCompReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultClauseOffset),
                                                            lpCompStr->CompStr.dwResultClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadClauseOffset),
                                                            lpCompStr->CompStr.dwResultReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_COMPCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompClauseOffset),
                                                            lpCompStr->CompStr.dwCompClauseLen / sizeof(TYPE));    // # of bytes
            break;

        case GCS_CURSORPOS:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwCursorPos);
            break;
        case GCS_DELTASTART:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwDeltaStart);
            break;

        default:
            break;
    }
}


class CWCompString;


/////////////////////////////////////////////////////////////////////////////
// CBCompString

class CBCompString : public CompData<CHAR, CHAR>
{
public:
    CBCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<CHAR, CHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<CHAR, CHAR>(lpCompStr),
                                                              m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<CHAR, CHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CBCompString& operator=(CWCompString& wcompstr);

    const DWORD ConvertUnicodeString(IN OUT LPWSTR lpsz = NULL, DWORD cch = 0)
    {
        return _mbstowcs(lpsz, cch);
    }

    CHAR GetAt(IN DWORD dwIndex)
    {
        return CompData<CHAR, CHAR>::GetAt(dwIndex);
    }

    BOOL IsDBCSLeadByteEx(IN DWORD dwIndex)
    {
         CHAR c = GetAt(dwIndex);
         return ::IsDBCSLeadByteEx(m_cp, c);
    }

private:
    UINT      m_cp;            // code page value.

    int _mbstowcs(wchar_t* wcstr, size_t cch);
};

inline
int
CBCompString::_mbstowcs(
    wchar_t* wcstr,
    size_t cch
    )
{
    if (cch == 0 && wcstr != NULL)
        return 0;

    const char* mbstr = m_array.GetData();
    if (!mbstr)
        return 0;

    INT_PTR nSize = m_array.GetSize();

    int result = ::MultiByteToWideChar(m_cp,     // code page
                                       0,        // character-type option
                                       mbstr,    // address of string to map
                                       (int)nSize,    // number of bytes in string
                                       wcstr,    // address of wide-char buffer
                                       (int)cch);   // size of buffer, in wide character

    return result;
}



/////////////////////////////////////////////////////////////////////////////
// CWCompString

class CWCompString : public CompData<WCHAR, WCHAR>
{
public:
    CWCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPWSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<WCHAR, WCHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<WCHAR, WCHAR>(lpCompStr),
                                                              m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<WCHAR, WCHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CWCompString& operator=(CBCompString& bcompstr);

    const DWORD ConvertANSIString(IN OUT LPSTR lpsz = NULL, DWORD dwLen = 0)
    {
        return _wcstombs(lpsz, dwLen);
    }

    WCHAR GetAt(IN DWORD dwIndex)
    {
        return (WCHAR)CompData<WCHAR, WCHAR>::GetAt(dwIndex);
    }

    int UnicodeToMultiByteSize(IN DWORD dwIndex)
    {
        WCHAR wc = GetAt(dwIndex);
        return ::WideCharToMultiByte(m_cp,     // code page
                                     0,        // performance and mapping flags
                                     (const wchar_t*)&wc,     // address of wide-char string
                                     1,        // number of char string
                                     NULL,     // address of buffer for new string
                                     0,        // size of buffer
                                     NULL,     // default for unmappable char
                                     NULL);    // flag set when default char
    }

private:
    UINT      m_cp;            // code page value.

    int _wcstombs(char* mbstr, size_t count);
};

inline
int
CWCompString::_wcstombs(
    char* mbstr,
    size_t count
    )
{
    if (count == 0 && mbstr != NULL)
        return 0;

    const wchar_t* wcstr = m_array.GetData();
    if (!wcstr)
        return 0;

    INT_PTR nSize = m_array.GetSize();

    int result = ::WideCharToMultiByte(m_cp,     // code page
                                       0,        // performance and mapping flags
                                       wcstr,    // address of wide-char string
                                       (int)nSize,    // number of char string
                                       mbstr,    // address of buffer for new string
                                       (int)count,    // size of buffer
                                       NULL,     // default for unmappable char
                                       NULL);    // flag set when default char

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// CBCompStrin/CWCompString::operator=

inline
const CBCompString&
CBCompString::operator=(
    CWCompString& wcompstr
    )

/*+++
 *
 * Get ANSI string from Unicode composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = wcompstr.ConvertANSIString();
    m_array.SetSize(len);

    LPSTR psz = m_array.GetData();
    if (psz)
        len = wcompstr.ConvertANSIString(psz, len * sizeof(CHAR));

    return *this;
}

inline
const CWCompString&
CWCompString::operator=(
    CBCompString& bcompstr
    )

/*+++
 *
 * Get Unicode string from ANSI composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = bcompstr.ConvertUnicodeString();
    m_array.SetSize(len);

    LPWSTR psz = m_array.GetData();
    if (psz)
        len = bcompstr.ConvertUnicodeString(psz, len);

    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckAttribute template

template<class APPS_ATTR, class HIMC_ATTR, class HIMC_CLAUSE>
HRESULT
CheckAttribute(
    APPS_ATTR& apps_attr,                        // the attr from apps
    HIMC_ATTR& himc_attr,                        // the attr from IMC
    HIMC_CLAUSE& himc_clause                     // the clause from IMC
    )
{
    if (himc_clause.ReadCompData() == 0) {
        TraceMsg(TF_WARNING, "CheckAttribute: no Clause. Pass it to IME.");
    }
    else {
        if (himc_attr.ReadCompData() != 0) {
            if (apps_attr.GetSize() != himc_attr.GetSize()) {
                TraceMsg(TF_ERROR, "CheckAttribute: wrong length.");
                return E_FAIL;
            }

            /*
             * The attr. of chars of one clause have to be same.
             */
            DWORD dwAttrIndex = 0;
            DWORD dwClauseIndex;
            for (dwClauseIndex = 0;
                 (INT_PTR)himc_clause.GetAt(dwClauseIndex) < apps_attr.ReadCompData();
                 dwClauseIndex++
                ) {
                DWORD dwBound = himc_clause.GetAt(dwClauseIndex+1) - himc_clause.GetAt(dwClauseIndex);
                DWORD battr = apps_attr.GetAt(dwAttrIndex++);
                DWORD dwCnt;
                for (dwCnt = 1; dwCnt < dwBound; dwCnt++) {
                    if (battr != apps_attr.GetAt(dwAttrIndex++)) {
                        TraceMsg(TF_ERROR, "CheckAttribute: mismatch clause attribute.");
                        return E_FAIL;
                    }
                }
            }
        }
    }

    return S_OK;
}

class CWCompAttribute;

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute

class CBCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CBCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                              m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CBCompAttribute& operator=(CWCompAttribute& wcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompAttribute

class CWCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CWCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                              m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompAttribute(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CWCompAttribute& operator=(CBCompAttribute& bcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CWCompString    m_wcompstr;
};

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute/CWCompAttribute::operator=

inline
const CBCompAttribute&
CBCompAttribute::operator=(
    CWCompAttribute& wcompattr
    )

/*+++
 *
 * Get ANSI attribute from Unicode composition attribute.
 *
---*/

{
    m_bcompstr = wcompattr.m_wcompstr;
    INT_PTR dwAttrIndexW = 0;
    INT_PTR dwStrIndex = 0;
    while ( dwStrIndex   < m_bcompstr.ReadCompData() &&
            dwAttrIndexW <  wcompattr.ReadCompData() &&
            m_bcompstr.GetAt((DWORD)dwStrIndex) != '\0'
          ) {
        if (m_bcompstr.IsDBCSLeadByteEx((DWORD)dwStrIndex)) {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex += 2;
        }
        else {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex++;
        }
        dwAttrIndexW++;
    }
    return *this;
}

inline
const CWCompAttribute&
CWCompAttribute::operator=(
    CBCompAttribute& bcompattr
    )

/*+++
 *
 * Get Unicode attribute from ANSI composition attribute.
 *
---*/

{
    m_wcompstr = bcompattr.m_bcompstr;
    INT_PTR dwAttrIndexA = 0;
    INT_PTR dwStrIndex = 0;
    while ( dwStrIndex   < m_wcompstr.ReadCompData() &&
            dwAttrIndexA <  bcompattr.ReadCompData() &&
            m_wcompstr.GetAt((DWORD)dwStrIndex) != '\0' 
          ) {
        if (m_wcompstr.UnicodeToMultiByteSize((DWORD)dwStrIndex) == 2) {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA += 2;
        }
        else {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA++;
        }
        dwStrIndex++;
    }
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckClause template


template<class APPS_CLAUSE, class HIMC_CLAUSE>
HRESULT
CheckClause(
    APPS_CLAUSE& apps_clause,                 // the clause from apps
    HIMC_CLAUSE& himc_clause                  // the clause from IMC
    )
{
    if (apps_clause.ReadCompData() == 0 ||
        himc_clause.ReadCompData() == 0  ) {
        TraceMsg(TF_ERROR, "CheckClause: no Clause.");
        return E_FAIL;
    }

    if (apps_clause.GetAt(0) ||
        himc_clause.GetAt(0)   ) {
        TraceMsg(TF_ERROR, "CheckClause: clause[0] have to be ZERO.");
        return E_FAIL;
    }

    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < himc_clause.ReadCompData();
         dwClauseIndex++
        ) {
        if (apps_clause.GetAt((DWORD)dwClauseIndex) != himc_clause.GetAt((DWORD)dwClauseIndex)) {
            return E_FAIL;
        }
    }

    return S_OK;
}


class CWCompClause;


/////////////////////////////////////////////////////////////////////////////
// CBCompClause

class CBCompClause : public CompData<DWORD, DWORD>
{
public:
    CBCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CBCompClause& operator=(CWCompClause& wcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompClause

class CWCompClause : public CompData<DWORD, DWORD>
{
public:
    CWCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompClause(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CWCompClause& operator=(CBCompClause& bcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompClause/CWCompClause::operator=

inline
const CBCompClause&
CBCompClause::operator=(
    CWCompClause& wcompclause
    )

/*+++
 *
 * Get ANSI clause from Unicode composition clause.
 *
---*/

{
    m_bcompstr = wcompclause.m_wcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < wcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionWtoA( wcompclause.GetAt((DWORD)dwClauseIndex), &wcompclause.m_wcompstr ) );
    }
    return *this;
}

inline
const CWCompClause&
CWCompClause::operator=(
    CBCompClause& bcompclause
    )

/*+++
 *
 * Get Unicode clause from ANSI composition clause.
 *
---*/

{
    m_wcompstr = bcompclause.m_bcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < bcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionAtoW( bcompclause.GetAt((DWORD)dwClauseIndex), &bcompclause.m_bcompstr ) );
    }
    return *this;
}


class CWCompCursorPos;

/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos

class CBCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CBCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_bcompstr(cp, hIMC)
    {
    };

    CBCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CBCompCursorPos& operator=(CWCompCursorPos& wcompcursor);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompCursorPos

class CWCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CWCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(cp, hIMC)
    {
    };

    CWCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                              m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompCursorPos(
        UINT cp,
        DIMM_IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CWCompCursorPos& operator=(CBCompCursorPos& bcompcursorpos);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos/CWCompCursorPos::operator=

inline
const CBCompCursorPos&
CBCompCursorPos::operator=(
    CWCompCursorPos& wcompcursor
    )

/*+++
 *
 * Get ANSI cursor/delta start position from Unicode composition string.
 *
---*/

{
    if (wcompcursor.m_wcompstr.GetSize() > 0)
    {
        m_bcompstr = wcompcursor.m_wcompstr;
    
        m_array.SetAtGrow( 0, CalcCharacterPositionWtoA(wcompcursor.GetAt(0), &wcompcursor.m_wcompstr) );
    }
    return *this;
}

inline
const CWCompCursorPos&
CWCompCursorPos::operator=(
    CBCompCursorPos& bcompcursor
    )

/*+++
 *
 * Get Unicode cursor/delta start position from ANSI composition string.
 *
---*/

{
    if (bcompcursor.m_bcompstr.GetSize() > 0)
    {
        m_wcompstr = bcompcursor.m_bcompstr;
        m_array.SetAtGrow( 0, CalcCharacterPositionAtoW(bcompcursor.GetAt(0), &bcompcursor.m_bcompstr) );
    }
    return *this;
}


class CWReconvertString;

/////////////////////////////////////////////////////////////////////////////
// CBReconvetString

class CBReconvertString
{
public:
    CBReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_bcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;
        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_bcompstr.WriteCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset;
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset;
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_bcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_bcompstr.ReadCompData() * sizeof(CHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)(m_bcompstr.ReadCompData() * sizeof(CHAR));
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(CHAR));
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(CHAR));

            dwBufLen = m_bcompstr.ReadCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CBReconvertString& operator=(CWReconvertString& wReconvStr);

    void SetData(CWReconvertString& wReconvStr);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

public:
    CBCompString    m_bcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CBCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CBCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};


/////////////////////////////////////////////////////////////////////////////
// CWReconvertString

class CWReconvertString
{
public:
    CWReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_wcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;

        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_wcompstr.WriteCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset / sizeof(WCHAR);   // char count
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset / sizeof(WCHAR);  // char count
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPWSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_wcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_wcompstr.ReadCompData() * sizeof(WCHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)m_wcompstr.ReadCompData();
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(WCHAR));  // byte count
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(WCHAR));  // byte count

            dwBufLen = m_wcompstr.ReadCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CWReconvertString& operator=(CBReconvertString& bReconvStr);

    void SetData(CBReconvertString& bReconvStr);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

public:
    CWCompString    m_wcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CWCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CWCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};

/////////////////////////////////////////////////////////////////////////////
// CBCompReconvertString/CWCompReconvertString::operator=

inline
const CBReconvertString&
CBReconvertString::operator=(
    CWReconvertString& wReconvStr
    )
{
    m_bcompstr = wReconvStr.m_wcompstr;
    SetData(wReconvStr);
    return *this;
}

inline
const CWReconvertString&
CWReconvertString::operator=(
    CBReconvertString& bReconvStr
    )
{
    m_wcompstr = bReconvStr.m_bcompstr;
    SetData(bReconvStr);
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CBReconvertString/CWReconvertString::SetData

inline
void
CBReconvertString::SetData(
    CWReconvertString& wReconvStr
    )
{
    m_dwVersion = wReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex), &wReconvStr.m_wcompstr);
    m_CompStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen), &wReconvStr.m_wcompstr) - m_CompStrIndex;
    m_TargetStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex), &wReconvStr.m_wcompstr);
    m_TargetStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex + wReconvStr.m_TargetStrLen), &wReconvStr.m_wcompstr) - m_TargetStrIndex;
}

inline
void
CWReconvertString::SetData(
    CBReconvertString& bReconvStr
    )
{
    m_dwVersion = bReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex), &bReconvStr.m_bcompstr);
    m_CompStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex + bReconvStr.m_CompStrLen), &bReconvStr.m_bcompstr) - m_CompStrIndex);
    m_TargetStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex), &bReconvStr.m_bcompstr);
    m_TargetStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex + bReconvStr.m_TargetStrLen), &bReconvStr.m_bcompstr) - m_TargetStrIndex);
}













/////////////////////////////////////////////////////////////////////////////
// CWInterimString

class CWInterimString
{
public:
    CWInterimString(
        UINT cp,
        HIMC hIMC
        ) : m_wresultstr(cp, hIMC)
    {
        m_InterimChar = L'\0';
        m_InterimAttr = 0;
    }

    DWORD WriteResultStr(IN LPWSTR lpSrc, IN DWORD dwLen)
    {
        return m_wresultstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadResultStr(IN LPWSTR lpSrc = NULL, DWORD dwLen = 0)
    {
        return (DWORD)m_wresultstr.ReadCompData(lpSrc, dwLen);
    }

    VOID WriteInterimChar(WCHAR ch, BYTE attr)
    {
        m_InterimChar = ch;
        m_InterimAttr = attr;
    }

    void ReadInterimChar(WCHAR* ch, BYTE* attr)
    {
        *ch   = m_InterimChar;
        *attr = m_InterimAttr;
    }

public:
    CWCompString    m_wresultstr;

    WCHAR           m_InterimChar;
    BYTE            m_InterimAttr;
};




/////////////////////////////////////////////////////////////////////////////
// CWCompTfGuidAtom

class CWCompTfGuidAtom : public CompData<TfGuidAtom, TfGuidAtom>
{
public:
};




/////////////////////////////////////////////////////////////////////////////
// friend

inline
DWORD
CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    CBCompString* bcompstr
    )

/*+++

    Calculation Unicode character position to ANSI character position

---*/

{
    DWORD dwCharPosW = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosA != 0) {
        if (bcompstr->IsDBCSLeadByteEx(dwStrIndex)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            dwStrIndex += 2;
        }
        else {
            dwCharPosA--;
            dwStrIndex++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}

inline
DWORD
CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    CWCompString* wcompstr
    )

/*+++

    Calculate ANSI character position to Unicode character position.

---*/

{
    DWORD dwCharPosA = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosW != 0) {
        if (wcompstr->UnicodeToMultiByteSize(dwStrIndex) == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwStrIndex++;
        dwCharPosW--;
    }

    return dwCharPosA;
}

#endif // IMCCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\immapp.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       immapp.cpp
//
//  Contents:   IActiveIMM methods with application win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "globals.h"
#include "cdimm.h"
#include "defs.h"
#include "enum.h"

extern HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

//+---------------------------------------------------------------------------
//
//
//    Input Context Group
//
//
//----------------------------------------------------------------------------

STDAPI
CActiveIMM::CreateContext(
    OUT HIMC *phIMC
    )

/*++

Method:

    IActiveIMMApp::CreateContext
    IActiveIMMIME::CreateContext

Routine Description:

    Creates a new input context, allocating memory for the context and initializing it.

Arguments:

    phIMC - [out] Address of a handle to receive the new input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::CreateContext");

    HRESULT hr;

    if (FAILED(hr = _InputContext.CreateContext(_GetIMEProperty(PROP_PRIVATE_DATA_SIZE),
                                                (_GetIMEProperty(PROP_IME_PROPERTY) & IME_PROP_UNICODE) ? TRUE : FALSE,
                                                phIMC, _IsAlreadyActivate())))
    {
        return hr;
    }

    if (_IsAlreadyActivate() && !_IsRealIme())
    {
        _AImeSelect(*phIMC, TRUE);
    }

    return hr;
}


STDAPI
CActiveIMM::DestroyContext(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMApp::DestroyContext
    IActiveIMMIME::DestroyContext

Routine Description:

    Releases the input context and frees any memory associated with it.

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::DestroyContext");

    if (_IsAlreadyActivate() && !_IsRealIme()) {
        _AImeSelect(hIMC, FALSE);
    }

    return _InputContext.DestroyContext(hIMC);
}

STDAPI
CActiveIMM::AssociateContext(
    IN HWND hWnd,
    IN HIMC hIMC,
    OUT HIMC *phPrev
    )

/*++

Method:

    IActiveIMMApp::AssociateContext
    IActiveIMMIME::AssociateContext

Routine Description:

    Associates the specified input context with the specified window.

Arguments:

    hWnd - [in] Handle to the window to be associated with the input context.
    hIMC - [in] Handle to the input context. If hIMC is NULL, the method removed any
                association the window may have had with input context.
    phPrev - [out] Address of the handle to the input context previously associated
                   with the window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::AssociateContext");

    hr = _InputContext.AssociateContext(hWnd, hIMC, phPrev);

    if (FAILED(hr))
        return hr;

    if (!_IsRealIme())
    {
        if (_hFocusWnd == hWnd)
        {
            _AImeAssociateFocus(hWnd, *phPrev, 0);
            _ResetMapWndFocus(hWnd);
            _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
            _SetMapWndFocus(hWnd);
        }
    }

    return IsOnImm() ? Imm32_AssociateContext(hWnd, hIMC, phPrev) : hr;
}

STDAPI
CActiveIMM::AssociateContextEx(
    IN HWND hWnd,
    IN HIMC hIMC,
    IN DWORD dwFlags
    )

/*++

Method:

    IActiveIMMApp::AssociateContextEx
    IActiveIMMIME::AssociateContextEx

Routine Description:

    Changes the association between the input method context and the specified window
    or its children.

Arguments:

    hWnd - [in] Handle to the window to be associated with the input context.
    hIMC - [in] Handle to the input context.
    dwFlags - [in] Unsigned long integer value that contains the type of association
                   between the window and the input method context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    HIMC hImcFocusOld;

    TraceMsg(TF_API, "CActiveIMM::AssociateContextEx");

    hr = _InputContext.AssociateContextEx(hWnd, hIMC, dwFlags);

    if (FAILED(hr))
        return hr;

    if (!_IsRealIme())
    {
        hr = _InputContext.GetContext(hWnd, &hImcFocusOld);
        if (FAILED(hr))
            hImcFocusOld = NULL;

        hr = _InputContext.AssociateContextEx(hWnd, hIMC, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (_hFocusWnd == hWnd)
            {
                _AImeAssociateFocus(hWnd, hImcFocusOld, 0);
                _ResetMapWndFocus(hWnd);
                _AImeAssociateFocus(hWnd, hIMC, AIMMP_AFF_SETFOCUS);
                _SetMapWndFocus(hWnd);
            }
        }
    }

    if (FAILED(hr))
        return hr;

    return IsOnImm() ? Imm32_AssociateContextEx(hWnd, hIMC, dwFlags) : hr;
}

STDAPI
CActiveIMM::GetContext(
    HWND hWnd,
    HIMC *phIMC
    )

/*++

Method:

    IActiveIMMApp::GetContext
    IActiveIMMIME::GetContext

Routine Description:

    Retrieves the input context associated with the specified window. An application must
    release each context retrieved by calling IActiveIMMApp::ReleaseContext.

Arguments:

    hWnd - [in] Handle to the window that is retrieving an input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return GetContextInternal(hWnd, phIMC, TRUE);
}

HRESULT
CActiveIMM::GetContextInternal(
    HWND hWnd,
    HIMC *phIMC,
    BOOL fGetDefIMC
    )
{
    TraceMsg(TF_API, "CActiveIMM::GetContext");

    *phIMC = 0;

    if (!IsWindow(hWnd))
        return E_INVALIDARG;

    if (!fGetDefIMC && !IsPresent(hWnd, FALSE) && !_IsRealIme())
        return S_FALSE;

    return _InputContext.GetContext(hWnd, phIMC);
}


STDAPI
CActiveIMM::ReleaseContext(
    IN HWND hWnd,
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMApp::ReleaseContext
    IActiveIMMIME::ReleaseContext

Routine Description:

    Release the input context and unlocks the memory associated in the context.
    An application must call this method for each call to the IActiveIMMApp::GetContext
    method.

Arguments:

    hWnd - [in] Handle to the window for which the input context was previously retrieved.
    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::ReleaseContext");

    return S_OK;
}

STDAPI
CActiveIMM::GetOpenStatus(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMApp::GetOpenStatus
    IActiveIMMIME::GetOpenStatus

Routine Description:

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns a nonzero value if the IME is open, or zero otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetOpenStatus");

    if (_IsRealIme())
    {
        return Imm32_GetOpenStatus(hIMC);
    }

    return _InputContext.GetOpenStatus(hIMC);
}

STDAPI
CActiveIMM::SetOpenStatus(
    HIMC hIMC,
    BOOL fOpen
    )

/*++

Method:

    IActiveIMMApp::SetOpenStatus
    IActiveIMMIME::SetOpenStatus

Routine Description:

    Open or close the IME.

Arguments:

    hIMC - [in] Handle to the input context.
    fOpen - [in] Boolean value that contains the status. If TRUE, the IMM is opened:
                 otherwize the IMM is closed.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    BOOL fOpenChg;
    HWND hWnd;

    TraceMsg(TF_API, "CActiveIMM::SetOpenStatus");

    if (_IsRealIme())
    {
        return Imm32_SetOpenStatus(hIMC, fOpen);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetOpenStatus(lpIMC, fOpen, &fOpenChg);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the conversion mode changes.
     */
    if (SUCCEEDED(hr) && fOpenChg) {
        _SendIMENotify(hIMC, hWnd,
                       NI_CONTEXTUPDATED, (DWORD)0, IMC_SETOPENSTATUS,
                       IMN_SETOPENSTATUS, 0L);

        /*
         * notify shell and keyboard the conversion mode change
         */
        // NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    return hr;
}

STDAPI
CActiveIMM::GetConversionStatus(
    IN HIMC hIMC,
    OUT DWORD *lpfdwConversion,
    OUT DWORD *lpfdwSentence
    )

/*++

Method:

    IActiveIMMApp::GetConversionStatus
    IActiveIMMIME::GetConversionStatus

Routine Description:

    Retrieves the current conversion status.

Arguments:

    hIMC - [in] Handle to the input context for which to retrieve information.
    lpfdwConversion - [out] Address of an unsigned long integer value that receives a
                            combination of conversion mode.
    lpfwSentence - [out] Address of an unsigned long integer value that receives a sentence
                         mode value.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetConversionStatus");

    if (_IsRealIme())
    {
        return Imm32_GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
    }

    return _InputContext.GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
}

STDAPI
CActiveIMM::SetConversionStatus(
    IN HIMC hIMC,
    IN DWORD fdwConversion,
    IN DWORD fdwSentence
    )

/*++

Method:

    IActiveIMMApp::SetConversionStatus
    IActiveIMMIME::SetConversionStatus

Routine Description:

    Sets the current conversion status.

Arguments:

    hIMC - [in] Handle to the input context.
    fdwConversion - [in] Unsigned long value that contains the conversion mode values.
    fdwSentence - [in] Unsigned long integer value that contains the sentence mode values.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    BOOL fConvModeChg = FALSE;
    BOOL fSentenceChg = FALSE;
    HWND hWnd;
    DWORD fdwOldConversion;
    DWORD fdwOldSentence;
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::SetConversionStatus");

    if (_IsRealIme())
    {
        return Imm32_SetConversionStatus(hIMC, fdwConversion, fdwSentence);
    }

    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr = lpIMC.GetResult()))
        return hr;

    hr = _InputContext.SetConversionStatus(lpIMC, fdwConversion, fdwSentence,
                                           &fConvModeChg, &fSentenceChg, &fdwOldConversion, &fdwOldSentence);

    hWnd = lpIMC->hWnd;

    /*
     * inform IME and Apps Wnd about the conversion mode changes.
     */
    if (fConvModeChg) {
        _SendIMENotify(hIMC, hWnd,
                       NI_CONTEXTUPDATED, fdwOldConversion, IMC_SETCONVERSIONMODE,
                       IMN_SETCONVERSIONMODE, 0L);

        /*
         * notify shell and keyboard the conversion mode change
         */
        // NtUserNotifyIMEStatus( hWnd, dwOpenStatus, dwConversion );
    }

    /*
     * inform IME and Apps Wnd about the sentence mode changes.
     */
    if (fSentenceChg) {
        _SendIMENotify(hIMC, hWnd,
                       NI_CONTEXTUPDATED, fdwOldSentence, IMC_SETSENTENCEMODE,
                       IMN_SETSENTENCEMODE, 0L);
    }

    return hr;
}

STDAPI
CActiveIMM::GetStatusWindowPos(
    IN HIMC hIMC,
    OUT POINT *lpptPos
    )

/*++

Method:

    IActiveIMMApp::GetStatusWindowPos
    IActiveIMMIME::GetStatusWindowPos

Routine Description:

    Retrieves the position of the status window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpptPos - [out] Address of the POINT structure that receives the position coordinates.
                    These are screen coordinates, relative to the upper-left corner of the screen.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetStatusWindowPos");

    if (_IsRealIme())
    {
        return Imm32_GetStatusWindowPos(hIMC, lpptPos);
    }

    return _InputContext.GetStatusWindowPos(hIMC, lpptPos);
}

STDAPI
CActiveIMM::SetStatusWindowPos(
    IN HIMC hIMC,
    IN POINT *lpptPos
    )

/*++

Method:

    IActiveIMMApp::SetStatusWindowPos

Routine Description:

    Sets the position of the status window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpptPos - [in] Address of the POINT structure that receives the new position of the status
                   window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/
{
    HRESULT hr;
    HWND hWnd;

    TraceMsg(TF_API, "CActiveIMM::SetStatusWindowPos");

    if (_IsRealIme())
    {
        return Imm32_SetStatusWindowPos(hIMC, lpptPos);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetStatusWindowPos(lpIMC, lpptPos);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of  composition window position.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETSTATUSWINDOWPOS,
                   IMN_SETSTATUSWINDOWPOS, 0L);

    return hr;
}

STDAPI
CActiveIMM::GetCompositionStringA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LONG *plCopied,
    OUT LPVOID lpBuf
    )

/*++

Method:

    IActiveIMMApp::GetCompositionStringA
    IActiveIMMIME::GetCompositionStringA

Routine Description:

    Retrieves information about the composition string. ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the index of the information
                   to retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size of the buffer, in bytes.
    plCopied - [out] Address of long integer value that receives the number of bytes copied to
                     the buffer. If dwBufLen is zero, plCopied receives the number of bytes
                     needed to receive all of the requested information.
    lpBuf - [out] Address of the buffer to receive the information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionStringA");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    // Especially, GetCompositionString() calls from application when changed keyboard layout.
    // In this timing, Cicero's profile already updeted to Cicero's hKL but ImeSelectHandler(FALSE)
    // is not yet received in IMM32.
    // If IMM32 IME were ASCII style IME, then it hIMC is also ASCII and hIMC's A->W conversion
    // occurred by ImeSelectHandler().
    // For below ::GetKeyboardLayout() call, When IMM32 IME has been selected, we retreive
    // composition string from IMM32 even while changing keyboard layout.
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, FALSE);
    }

    return _GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, FALSE);
}

STDAPI
CActiveIMM::GetCompositionStringW(
    IN HIMC hIMC,
    IN  DWORD dwIndex,
    IN  DWORD dwBufLen,
    OUT LONG *plCopied,
    OUT LPVOID lpBuf
    )

/*++

Method:

    IActiveIMMApp::GetCompositionStringW
    IActiveIMMIME::GetCompositionStringW

Routine Description:

    Retrieves information about the composition string. Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the index of the information
                   to retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size of the buffer, in bytes.
    plCopied - [out] Address of long integer value that receives the number of bytes copied to
                     the buffer. If dwBufLen is zero, plCopied receives the number of bytes
                     needed to receive all of the requested information.
    lpBuf - [out] Address of the buffer to receive the information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionStringW");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, TRUE);
    }

    return _GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, TRUE);
}

STDAPI
CActiveIMM::SetCompositionStringA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen
    )

/*++

Method:

    IActiveIMMApp::SetCompositionStringA
    IActiveIMMIME::SetCompositionStringA

Routine Description:

    Sets the characters, attributes, and clauses of the composition and reading strings.
    ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the type of information
                   to set.
    lpComp - [in] Address of the buffer containing the information to set for the composition
                  string. The information is as specified by the dwIndex value.
    dwCompLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the composition string.
    lpRead - [in] Address of the buffer containing the information to set for the reading
                  string. The information is as specified by the dwIndex value.
    dwReadLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the reading string.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_FUNC, TEXT("CActiveIMM::SetCompositionStringA"));

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, FALSE);
    }

    return _SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, FALSE);
}

STDAPI
CActiveIMM::SetCompositionStringW(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN LPVOID lpComp,
    IN DWORD dwCompLen,
    IN LPVOID lpRead,
    IN DWORD dwReadLen
    )

/*++

Method:

    IActiveIMMApp::SetCompositionStringW
    IActiveIMMIME::SetCompositionStringW

Routine Description:

    Sets the characters, attributes, and clauses of the composition and reading strings.
    Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the type of information
                   to set.
    lpComp - [in] Address of the buffer containing the information to set for the composition
                  string. The information is as specified by the dwIndex value.
    dwCompLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the composition string.
    lpRead - [in] Address of the buffer containing the information to set for the reading
                  string. The information is as specified by the dwIndex value.
    dwReadLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                     information buffer for the reading string.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, TRUE);
    }

    return _SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, TRUE);
}

STDAPI
CActiveIMM::GetCompositionFontA(
    IN HIMC hIMC,
    OUT LOGFONTA *lplf
    )

/*++

Method:

    IActiveIMMApp::GetCompositeFontA
    IActiveIMMIME::GetCompositeFontA

Routine Description:

    Retrieves information about the logical font currently used to display character
    in the composition window. ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [out] Address of a LOGFONTA structure that receives the fontinformation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionFontA");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
    }

    return _GetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
}

STDAPI
CActiveIMM::GetCompositionFontW(
    IN HIMC hIMC,
    IN LOGFONTW *lplf
    )

/*++

Method:

    IActiveIMMApp::GetCompositeFontW
    IActiveIMMIME::GetCompositeFontW

Routine Description:

    Retrieves information about the logical font currently used to display character
    in the composition window. Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [out] Address of a LOGFONTW structure that receives the fontinformation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionFontW");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_GetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
    }

    return _GetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
}

STDAPI
CActiveIMM::SetCompositionFontA(
    IN HIMC hIMC,
    IN LOGFONTA *lplf
    )

/*++

Method:

    IActiveIMMApp::SetCompositionFontA
    IActiveIMMIME::SetCompositionFontA

Routine Description:

    Sets the logocal font used to display characters in the composition window.
    ANSI implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [in] Address of the LOGFONTA structure containing the font information to set.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::SetCompositionFontA");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
    }

    return _SetCompositionFont(hIMC, (LOGFONTAW*)lplf, FALSE);
}

STDAPI
CActiveIMM::SetCompositionFontW(
    IN HIMC hIMC,
    IN LOGFONTW *lplf
    )

/*++

Method:

    IActiveIMMApp::SetCompositionFontW
    IActiveIMMIME::SetCompositionFontW

Routine Description:

    Sets the logocal font used to display characters in the composition window.
    Unicode implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lplf - [in] Address of the LOGFONTW structure containing the font information to set.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::SetCompositionFontW");

    //
    // Specified hKL since hIMC updated by IME property and it synchronized by ImeSelectHandler().
    //
    if (_IsRealIme(::GetKeyboardLayout(0)))
    {
        return Imm32_SetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
    }

    return _SetCompositionFont(hIMC, (LOGFONTAW*)lplf, TRUE);
}

STDAPI
CActiveIMM::GetCompositionWindow(
    IN HIMC hIMC,
    OUT COMPOSITIONFORM *lpCompForm
    )

/*++

Method:

    IActiveIMMApp::GetCompositionWindow
    IActiveIMMIME::GetCompositionWindow

Routine Description:

    Retrieves information about the composition window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpCompForm - [out] Address of the COMPOSITIONFORM structure that receives information
                       about the composition.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCompositionWindow");

    if (_IsRealIme())
    {
        return Imm32_GetCompositionWindow(hIMC, lpCompForm);
    }

    return _InputContext.GetCompositionWindow(hIMC, lpCompForm);
}

STDAPI
CActiveIMM::SetCompositionWindow(
    IN HIMC hIMC,
    IN COMPOSITIONFORM *lpCompForm
    )

/*++

Method:

    IActiveIMMApp::SetCompositionWindow

Routine Description:

    Sets the position of the composition window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpCompForm - [in] Address of the COMPOSITIONFORM structure that contains the new position
                      and other related information about the composition window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HWND hWnd;
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::SetCompositionWindow");

    if (_IsRealIme())
    {
        return Imm32_SetCompositionWindow(hIMC, lpCompForm);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetCompositionWindow(lpIMC, lpCompForm);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of composition window.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETCOMPOSITIONWINDOW,
                   IMN_SETCOMPOSITIONWINDOW, 0L);

    return hr;
}

STDAPI
CActiveIMM::GetCandidateListA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN UINT uBufLen,
    OUT CANDIDATELIST *lpCandList,
    OUT UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListA
    IActiveIMMIME::GetCandidateListA

Routine Description:

    Retrieves a specified candidate list, copying the list to the specified buffer.
    ANSI implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the zero-based index of
                   the candidate list.
    uBufLen - [in] Unsigned integer value that contains the size of the buffer, in bytes.
                   If this is zero or if the buffer is insufficient to receive the candidate
                   list, the method returns the size in bytes required to receive the complete
                   candidate list to the variable specified by puCopied.
    lpCandList - [out] Address of the CANDIDATELIST structure that receives the candidate list.
    puCopied - [out] Address of an unsigned integer valiable that receives the number of bytes
                     copied to the specified buffer if the buffer is sufficient, otherwise it
                     receives the size in bytes required to receive the complete candidate list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListA");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, FALSE);
    }

    return _InputContext.GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, FALSE);
}

STDAPI
CActiveIMM::GetCandidateListW(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN UINT uBufLen,
    OUT CANDIDATELIST *lpCandList,
    OUT UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListW
    IActiveIMMIME::GetCandidateListW

Routine Description:

    Retrieves a specified candidate list, copying the list to the specified buffer.
    Unicode implementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the zero-based index of
                   the candidate list.
    uBufLen - [in] Unsigned integer value that contains the size of the buffer, in bytes.
                   If this is zero or if the buffer is insufficient to receive the candidate
                   list, the method returns the size in bytes required to receive the complete
                   candidate list to the variable specified by puCopied.
    lpCandList - [out] Address of the CANDIDATELIST structure that receives the candidate list.
    puCopied - [out] Address of an unsigned integer valiable that receives the number of bytes
                     copied to the specified buffer if the buffer is sufficient, otherwise it
                     receives the size in bytes required to receive the complete candidate list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListW");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, TRUE);
    }

    return _InputContext.GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, TRUE);
}

STDAPI
CActiveIMM::GetCandidateListCountA(
    IN HIMC hIMC,
    OUT DWORD *lpdwListSize,
    OUT DWORD *pdwBufLen
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListCountA
    IActiveIMMIME::GetCandidateListCountA

Routine Description:

    Retrieves the size, in bytes, of the candidate list. ANSI inplementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lpdwListSize - [out] Address of an unsigned long integer value that receives the size of
                         the candidate list.
    pdwBufLen - [out] Address of an unsigned long integer value that contains the number of
                      bytes required to receive all candidate lists.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListCountA");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, FALSE);
    }

    return _InputContext.GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, FALSE);
}

STDAPI
CActiveIMM::GetCandidateListCountW(
    IN HIMC hIMC,
    OUT DWORD *lpdwListSize,
    OUT DWORD *pdwBufLen
    )

/*++

Method:

    IActiveIMMApp::GetCandidateListCountW
    IActiveIMMIME::GetCandidateListCountW

Routine Description:

    Retrieves the size, in bytes, of the candidate list. Unicode inplementaion.

Arguments:

    hIMC - [in] Handle to the input context.
    lpdwListSize - [out] Address of an unsigned long integer value that receives the size of
                         the candidate list.
    pdwBufLen - [out] Address of an unsigned long integer value that contains the number of
                      bytes required to receive all candidate lists.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateListCountW");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, TRUE);
    }

    return _InputContext.GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, TRUE);
}

STDAPI
CActiveIMM::GetCandidateWindow(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    OUT CANDIDATEFORM *lpCandidate
    )

/*++

Method:

    IActiveIMMApp::GetCandidateWindow
    IActiveIMMIME::GetCandidateWindow

Routine Description:

    Retrieves information about the candidate list window.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the size, in byte, of the buffer.
    lpCandidate - [out] Address of a CANDIDATEFORM structire that receives information about
                        the candidate window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetCandidateWindow");

    if (_IsRealIme())
    {
        return Imm32_GetCandidateWindow(hIMC, dwIndex, lpCandidate);
    }

    return _InputContext.GetCandidateWindow(hIMC, dwIndex, lpCandidate);
}

STDAPI
CActiveIMM::SetCandidateWindow(
    IN HIMC hIMC,
    IN CANDIDATEFORM *lpCandForm
    )

/*++

Method:

    IActiveIMMApp::SetCandidateWindow
    IActiveIMMIME::SetCandidateWindow

Routine Description:

    Sets information about the candidate list window.

Arguments:

    hIMC - [in] Handle to the input context.
    lpCandForm - [in] Address of the CANDIDATEFORM structure that contains information about
                      the candidate window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HWND hWnd;
    HRESULT hr;

    TraceMsg(TF_API, "CActiveIMM::SetCandidateWindow");

    if (lpCandForm->dwIndex >= 4)       // over flow candidate index
        return E_INVALIDARG;

    if (_IsRealIme())
    {
        return Imm32_SetCandidateWindow(hIMC, lpCandForm);
    }

    {
        DIMM_IMCLock lpIMC(hIMC);
        if (FAILED(hr = lpIMC.GetResult()))
            return hr;

        hr = _InputContext.SetCandidateWindow(lpIMC, lpCandForm);

        hWnd = lpIMC->hWnd;
    }

    /*
     * inform IME and Apps Wnd about the change of composition window.
     */
    _SendIMENotify(hIMC, hWnd,
                   NI_CONTEXTUPDATED, 0L, IMC_SETCANDIDATEPOS,
                   IMN_SETCANDIDATEPOS, (LPARAM)(0x01 << lpCandForm->dwIndex));

    return hr;
}

STDAPI
CActiveIMM::GetGuideLineA(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPSTR pBuf,
    OUT DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetGuideLineA
    IActiveIMMIME::GetGuideLineA

Routine Description:

    Retrieves information about errors. Applications use this information to notify users.
    ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the guideline information to
                   retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                    buffer referenced by pBuf.
    pBuf - [out] Address of a string value that receives the error message string.
    pdwResult - [out] Address of an unsigned long integer value that receives the error level,
                      error index, or size of an error message string, depending on the value
                      of dwIndex. If dwBufLen is set to zero, pdwResult receives the buffer size,
                      in bytes, needed to receive the requested information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetGuideLineA");

    if (_IsRealIme())
    {
        return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, FALSE);
    }

    return _InputContext.GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, FALSE);
}

STDAPI
CActiveIMM::GetGuideLineW(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    IN DWORD dwBufLen,
    OUT LPWSTR pBuf,
    OUT DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetGuideLineW
    IActiveIMMIME::GetGuideLineW

Routine Description:

    Retrieves information about errors. Applications use this information to notify users.
    Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long integer value that contains the guideline information to
                   retrieve.
    dwBufLen - [in] Unsigned long integer value that contains the size, in bytes, of the
                    buffer referenced by pBuf.
    pBuf - [out] Address of a string value that receives the error message string.
    pdwResult - [out] Address of an unsigned long integer value that receives the error level,
                      error index, or size of an error message string, depending on the value
                      of dwIndex. If dwBufLen is set to zero, pdwResult receives the buffer size,
                      in bytes, needed to receive the requested information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetGuideLineW");

    if (_IsRealIme())
    {
        return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, TRUE);
    }

    return _InputContext.GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, TRUE);
}

STDAPI
CActiveIMM::NotifyIME(
    IN HIMC hIMC,
    IN DWORD dwAction,
    IN DWORD dwIndex,
    IN DWORD dwValue
    )

/*++

Method:

    IActiveIMMApp::NotifyIME

Routine Description:

    Notifies the IME about changes to the status of the input context.

Arguments:

    hIMC - [in] Handle to the input context.
    dwAction - [in] Unsigined long integer value that contains the notification code.
    dwIndex - [in] Unsigned long integer value that contains the index of a candidate list or,
                   if dwAction is set to NI_COMPOSITIONSTR, one of the following values:
                   CPS_CANCEL:  Clear the composition string and set the status to no composition
                                string.
                   CPS_COMPLETE: Set the composition string as the result string.
                   CPS_CONVERT: Convert the composition string.
                   CPS_REVERT: Cancel the current composition string and revert to the unconverted
                               string.
    dwValue - [in] Unsigned long integer value that contains the index of a candidate string or
                   is not used, depending on the value of the dwAction parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::NotifyIME");

    return (!_IsRealIme()) ? _AImeNotifyIME(hIMC, dwAction, dwIndex, dwValue) :
                             Imm32_NotifyIME(hIMC, dwAction, dwIndex, dwValue);
}

STDAPI
CActiveIMM::GetImeMenuItemsA(
    IN HIMC hIMC,
    IN DWORD dwFlags,
    IN DWORD dwType,
    IN IMEMENUITEMINFOA *pImeParentMenu,
    OUT IMEMENUITEMINFOA *pImeMenu,
    IN DWORD dwSize,
    OUT DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetImeMenuItemsA
    IActiveIMMIME::GetImeMenuItemsA

Routine Description:

    Retrieves the menu items that are registerd in the IME menu.
    ANSI implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwFlags - [in] Unsigned long integer value that contains the menu infomation flags.
    dwType - [in] Unsigned long integer value that contains the type of menu returned by this
                  method.
    pImeParentMenu - [in] Address of an IMEMENUITEMINFOA structure that has the fType member
                          set to MFT_SUBMENU to return informaion about the submenu items
                          of this parent menu, If this parameter is NULL, the function returns
                           only top-level menu items.
    pImeMenu - [out] Address of an array of IMEMENUITEMINFOA structure to reveive the 
                     contents of the memu items.
    dwSize - [in] Unsigned long integer value that contains the size of the buffer to receive
                  the structures.
    pdwResult - [out] Address of an unsigned long integer value that receives the number of
                      menu items copied into pImeMenu. If pImeMenu is null, the function returns
                      the number of registered menu items.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetImeMenuItemsA");

    if (_IsRealIme())
    {
        return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, FALSE);
    }

    return _InputContext.GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, FALSE);
}

STDAPI
CActiveIMM::GetImeMenuItemsW(
    HIMC hIMC,
    DWORD dwFlags,
    DWORD dwType,
    IMEMENUITEMINFOW *pImeParentMenu,
    IMEMENUITEMINFOW *pImeMenu,
    DWORD dwSize,
    DWORD *pdwResult
    )

/*++

Method:

    IActiveIMMApp::GetImeMenuItemsW
    IActiveIMMIME::GetImeMenuItemsW

Routine Description:

    Retrieves the menu items that are registerd in the IME menu.
    Unicode implementation.

Arguments:

    hIMC - [in] Handle to the input context.
    dwFlags - [in] Unsigned long integer value that contains the menu infomation flags.
    dwType - [in] Unsigned long integer value that contains the type of menu returned by this
                  method.
    pImeParentMenu - [in] Address of an IMEMENUITEMINFOW structure that has the fType member
                          set to MFT_SUBMENU to return informaion about the submenu items
                          of this parent menu, If this parameter is NULL, the function returns
                           only top-level menu items.
    pImeMenu - [out] Address of an array of IMEMENUITEMINFOW structure to reveive the 

                     controls of the memu items.
    dwSize - [in] Unsigned long integer value that contains the size of the buffer to receive
                  the structures.
    pdwResult - [out] Address of an unsigned long integer value that receives the number of
                      menu items copied into pImeMenu. If pImeMenu is null, the function returns
                      the number of registered menu items.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetImeMenuItemsW");

    if (_IsRealIme())
    {
        return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, TRUE);
    }

    return _InputContext.GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, TRUE);
}

STDAPI
CActiveIMM::EnumInputContext(
    DWORD idThread,
    IEnumInputContext **ppEnum
    )

/*++

Method:

    IActiveIMMApp::EnumInputContext
    IActiveIMMIME::EnumInputContext

Routine Description:

    Enumerates the input contexts on a thread.

Arguments:

    idThread - [in] Unsigned long integer value that specifies the thread.
    ppEnum - [out] Address of a pointer to the IEnumInputContext interface of the enumeration
                   object.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EnumInputContext");

    CContextList _hIMC_List;
    CEnumInputContext* pEnumInputContext = NULL;

    _InputContext.EnumInputContext(idThread, _EnumContextProc, (LPARAM)&_hIMC_List);

    if ((pEnumInputContext = new CEnumInputContext(_hIMC_List)) == NULL) {
        return E_OUTOFMEMORY;
    }

    *ppEnum = pEnumInputContext;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//
//    Window Handle Group
//
//
//----------------------------------------------------------------------------


STDAPI
CActiveIMM::GetDefaultIMEWnd(
    IN HWND hWnd,
    OUT HWND *phDefWnd
    )

/*++

Method:

    IActiveIMMApp::GetDefaultIMEWnd
    IActiveIMMIME::GetDefaultIMEWnd

Routine Description:

    Retrieves the default window handle to the IME class.

Arguments:

    hWnd     - [in] Handle to the window for the application.
    phDefWnd - [out] Address of the default window handle to the IME class.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetDefaultIMEWnd");

    if (_IsRealIme())
    {
        return Imm32_GetDefaultIMEWnd(hWnd, phDefWnd);
    }

    return _DefaultIMEWindow.GetDefaultIMEWnd(hWnd, phDefWnd);
}

STDAPI
CActiveIMM::GetVirtualKey(
    HWND hWnd,
    UINT *puVirtualKey
    )

/*++

Method:

    IActiveIMMApp::GetVirtualKey
    IActiveIMMIME::GetVirtualKey

Routine Description:

    Recovers the original virtual-key value associated with a key input message that has already
    been processed by the IME.

Arguments:

    hWnd     - [in] Handle to the window that receives the key message.
    puVirtualKey - [out] Address of an unsigned integer value that receives the original
                         virtual-key value.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetVirtualKey");

    if (_IsRealIme())
    {
        return Imm32_GetVirtualKey(hWnd, puVirtualKey);
    }

    return E_FAIL;
}

STDAPI
CActiveIMM::IsUIMessageA(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Method:

    IActiveIMMApp::IsUIMessageA
    IActiveIMMIME::IsUIMessageA

Routine Description:

    Checks for messages intended for the IME window and sends those messages to the specified
    window. ANSI implementation.

Arguments:

    hWndIME - [in] Handle to a window belonging to the IME window class.
    msg - [in] Unsigned integer value that contains the message to be checked.
    wParam - [in] Message-specific parameter.
    lParam - [in] Message-specific parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::IsUIMessageA");

    if (_IsRealIme())
    {
        return Imm32_IsUIMessageA(hWndIME, msg, wParam, lParam);
    }

    return E_FAIL;
}

STDAPI
CActiveIMM::IsUIMessageW(
    HWND hWndIME,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Method:

    IActiveIMMApp::IsUIMessageW
    IActiveIMMIME::IsUIMessageW

Routine Description:

    Checks for messages intended for the IME window and sends those messages to the specified
    window. Unicode implementation.

Arguments:

    hWndIME - [in] Handle to a window belonging to the IME window class.
    msg - [in] Unsigned integer value that contains the message to be checked.
    wParam - [in] Message-specific parameter.
    lParam - [in] Message-specific parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::IsUIMessageW");

    if (_IsRealIme())
    {
        return Imm32_IsUIMessageW(hWndIME, msg, wParam, lParam);
    }

    return E_FAIL;
}

STDAPI
CActiveIMM::SimulateHotKey(
    HWND hWnd,
    DWORD dwHotKeyID
    )

/*++

Method:

    IActiveIMMApp::SimulateHotKey
    IActiveIMMIME::SimulateHotKey

Routine Description:

    Simulates the specified IME hot key, causing the same response as if the user had pressed the
    hot key in the specified window.

Arguments:

    hWnd - [in] Handle to the window.
    dwHotKeyID - [in] Unsigned long integer value that contains the identifier for the IME hot key.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::SimulateHotKey");

    if (_IsRealIme())
    {
        return Imm32_SimulateHotKey(hWnd, dwHotKeyID);
    }

    return E_FAIL;
}



//+---------------------------------------------------------------------------
//
//
//    Keyboard Layout Group
//
//
//----------------------------------------------------------------------------


STDAPI
CActiveIMM::EnumRegisterWordA(
    HKL hKL,
    LPSTR szReading,
    DWORD dwStyle,
    LPSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordA **pEnum
    )

/*++

Method:

    IActiveIMMApp::EnumRegisterWordA
    IActiveIMMIME::EnumRegisterWordA

Routine Description:

    Creates an enumeration object that will enumerate the register strings having the specified
    reading string, style, and register string. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    szReading - [in] Address of a string value that contains the reading string to be enumerated.
                     If NULL, this method enumerates all available reading strings that match
                     with the values specified by dwStyle and szRegister.
    dwStyle - [in] Unsigned long integer value that contains the style to be enumerated. If set
                   to zero, this method enumerates all available styles that match with the
                   values specified by szReading and szRegister.
    szRegister - [in] Address of a string value that contains the register string to enumerate.
                      If NULL, this method enumerates all register strings that match with the
                      values specified by szReading and dwStyle.
    lpData - [in] Address of a buffer containing data supplied by the application.
    pEnum - [out] Address of a pointer to the IEnumRegisterWordA interface of the enumeration
                  object.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EnumRegisterWordA");

    if (_IsRealIme())
    {
        return Imm32_EnumRegisterWordA(hKL, szReading, dwStyle, szRegister, lpData, pEnum);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::EnumRegisterWordW(
    HKL hKL,
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szRegister,
    LPVOID lpData,
    IEnumRegisterWordW **pEnum
    )

/*++

Method:

    IActiveIMMApp::EnumRegisterWordW
    IActiveIMMIME::EnumRegisterWordW

Routine Description:

    Creates an enumeration object that will enumerate the register strings having the specified
    reading string, style, and register string. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    szReading - [in] Address of a string value that contains the reading string to be enumerated.
                     If NULL, this method enumerates all available reading strings that match
                     with the values specified by dwStyle and szRegister.
    dwStyle - [in] Unsigned long integer value that contains the style to be enumerated. If set
                   to zero, this method enumerates all available styles that match with the
                   values specified by szReading and szRegister.
    szRegister - [in] Address of a string value that contains the register string to enumerate.
                      If NULL, this method enumerates all register strings that match with the
                      values specified by szReading and dwStyle.
    lpData - [in] Address of a buffer containing data supplied by the application.
    pEnum - [out] Address of a pointer to the IEnumRegisterWordW interface of the enumeration
                  object.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EnumRegisterWordW");

    if (_IsRealIme())
    {
        return Imm32_EnumRegisterWordW(hKL, szReading, dwStyle, szRegister, lpData, pEnum);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetRegisterWordStyleA(
    HKL hKL,
    UINT nItem,
    STYLEBUFA *lpStyleBuf,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetRegisterWordStyleA
    IActiveIMMIME::GetRegisterWordStyleA

Routine Description:

    Retrieves a list of the styles supported by the IME associated with the specified keyboard
    layout. ANSI implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    nItem - [in] Unsigned integer value that contains the maximum number of styles that the buffer
                 can hold.
    lpStyleBuf - [out] Address of a STYLEBUFA structure that receives the style information.
    puCopied - [out] Address of an unsigned integer value that receives the number of layout
                     handles copied to the buffer, or if nItem is zero, receives the buffer size
                     in array elements needed to receive all available style information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetRegisterWordStyleA");

    if (_IsRealIme())
    {
        return Imm32_GetRegisterWordStyleA(hKL, nItem, lpStyleBuf, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetRegisterWordStyleW(
    HKL hKL,
    UINT nItem,
    STYLEBUFW *lpStyleBuf,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetRegisterWordStyleW
    IActiveIMMIME::GetRegisterWordStyleW

Routine Description:

    Retrieves a list of the styles supported by the IME associated with the specified keyboard
    layout. Unicode implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    nItem - [in] Unsigned integer value that contains the maximum number of styles that the buffer
                 can hold.
    lpStyleBuf - [out] Address of a STYLEBUFW structure that receives the style information.
    puCopied - [out] Address of an unsigned integer value that receives the number of layout
                     handles copied to the buffer, or if nItem is zero, receives the buffer size
                     in array elements needed to receive all available style information.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetRegisterWordStyleW");

    if (_IsRealIme())
    {
        return Imm32_GetRegisterWordStyleW(hKL, nItem, lpStyleBuf, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::RegisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszRegister
    )

/*++

Method:

    IActiveIMMApp::RegisterWordA
    IActiveIMMIME::RegisterWordA

Routine Description:

    Registers a string into the dictionary of the IME associated with the specified keyboard
    layout. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to register.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszRegister - [in] Address of a string value that contains a null-terminated string specifying
                        the string to register.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::RegisterWordA");

    if (_IsRealIme())
    {
        return Imm32_RegisterWordA(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::RegisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszRegister
    )

/*++

Method:

    IActiveIMMApp::RegisterWordW
    IActiveIMMIME::RegisterWordW

Routine Description:

    Registers a string into the dictionary of the IME associated with the specified keyboard
    layout. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to register.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszRegister - [in] Address of a string value that contains a null-terminated string specifying
                        the string to register.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::RegisterWordW");

    if (_IsRealIme())
    {
        return Imm32_RegisterWordW(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::UnregisterWordA(
    HKL hKL,
    LPSTR lpszReading,
    DWORD dwStyle,
    LPSTR lpszUnregister
    )

/*++

Method:

    IActiveIMMApp::UnregisterWordA
    IActiveIMMIME::UnregisterWordA

Routine Description:

    Removes a register string from the dictionary of the IME associated with the specified
    keyboard layout. ANSI implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to remove.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszUnregister - [in] Address of a string value that contains a null-terminated string
                          specifying the register string to remove.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::UnregisterWordA");

    if (_IsRealIme())
    {
        return Imm32_UnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::UnregisterWordW(
    HKL hKL,
    LPWSTR lpszReading,
    DWORD dwStyle,
    LPWSTR lpszUnregister
    )

/*++

Method:

    IActiveIMMApp::UnregisterWordW
    IActiveIMMIME::UnregisterWordW

Routine Description:

    Removes a register string from the dictionary of the IME associated with the specified
    keyboard layout. Unicode implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    lpszReading - [in] Address of a string value that contains a null-terminated string specifying
                       the reading string associated with the string to remove.
    dwStyle - [in] Unsigned long integer value that contains the style of the register string.
    lpszUnregister - [in] Address of a string value that contains a null-terminated string
                          specifying the register string to remove.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::UnregisterWordW");

    if (_IsRealIme())
    {
        return Imm32_UnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return E_NOTIMPL;
}



STDAPI
CActiveIMM::ConfigureIMEA(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDA *lpdata
    )

/*++

Method:

    IActiveIMMApp::ConfigureIMEA
    IActiveIMMIME::ConfigureIMEA

Routine Description:

    Displays the configuration dialog box for the IME. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hWnd - [in] Handle to the parent window for the dialog box.
    dwMode - [in] Unsigned long integer value that contains the type of dialog box to display.
                  This can be one of the following values:
                  IME_CONFIG_GENERAL: Displays the general purpose configuration dialog box.
                  IME_CONFIG_REGISTERWORD: Displays the register word dialog box.
                  IME_CONFIG_SELECTDICTIONARY: Displays the dictionary selection dialog box.
    lpdata - [in] Address of a REGISTERWORDA structure. This structure will be used if dwMode is
                  set to IME_CONFIG_REGISTERWORD. Otherwise this parameter is ignored.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::ConfigureIMEA");

    if (_IsRealIme())
    {
        return Imm32_ConfigureIMEA(hKL, hWnd, dwMode, lpdata);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(ConfigureIMEA) failed");
            return hr;
        }

        hr = _ConfigureIMEA(hKL, hWnd, dwMode, lpdata);

        pAImeProfile->Release();
        return hr;
    }
}

STDAPI
CActiveIMM::ConfigureIMEW(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *lpdata
    )

/*++

Method:

    IActiveIMMApp::ConfigureIMEW
    IActiveIMMIME::ConfigureIMEW

Routine Description:

    Displays the configuration dialog box for the IME. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hWnd - [in] Handle to the parent window for the dialog box.
    dwMode - [in] Unsigned long integer value that contains the type of dialog box to display.
                  This can be one of the following values:
                  IME_CONFIG_GENERAL: Displays the general purpose configuration dialog box.
                  IME_CONFIG_REGISTERWORD: Displays the register word dialog box.
                  IME_CONFIG_SELECTDICTIONARY: Displays the dictionary selection dialog box.
    lpdata - [in] Address of a REGISTERWORDW structure. This structure will be used if dwMode is
                  set to IME_CONFIG_REGISTERWORD. Otherwise this parameter is ignored.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::ConfigureIMEW");

    if (_IsRealIme())
    {
        return Imm32_ConfigureIMEW(hKL, hWnd, dwMode, lpdata);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(ConfigureIMEW) failed");
            return hr;
        }

        hr = _ConfigureIMEW(hKL, hWnd, dwMode, lpdata);

        pAImeProfile->Release();
        return hr;
    }
}

STDAPI
CActiveIMM::EscapeA(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult
    )

/*++

Method:

    IActiveIMMApp::EscapeA
    IActiveIMMIME::EscapeA

Routine Description:

    Executes IME-specific subfunctions and is used mainly for country-specific function.
    ANSI implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    uEscape - [in] Unsigned integer that contains the index of the subfunction.
    lpData - [in, out] Address of a buffer containing subfunction-specific data.
    plResult - [out] Address of the LRESULT variable that received the escape-specific value
                     returned by the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EscapeA");

    if (_IsRealIme())
    {
        return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(EscapeA) failed");
            return hr;
        }

        if (SUCCEEDED(hr=pAImeProfile->ChangeCurrentKeyboardLayout(hKL)))
        {
            hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
        }

        pAImeProfile->Release();
        return hr;
    }
}

STDAPI
CActiveIMM::EscapeW(
    HKL hKL,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult
    )

/*++

Method:

    IActiveIMMApp::EscapeW
    IActiveIMMIME::EscapeW

Routine Description:

    Executes IME-specific subfunctions and is used mainly for country-specific function.
    Unicode implementaion.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    uEscape - [in] Unsigned integer that contains the index of the subfunction.
    lpData - [in, out] Address of a buffer containing subfunction-specific data.
    plResult - [out] Address of the LRESULT variable that received the escape-specific value
                     returned by the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::EscapeW");

    if (_IsRealIme())
    {
        return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
    }
    else
    {
        HRESULT hr;
        IAImeProfile* pAImeProfile;

        hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CreateInstance(EscapeW) failed");
            return hr;
        }

        if (SUCCEEDED(hr=pAImeProfile->ChangeCurrentKeyboardLayout(hKL)))
        {
            hr = _Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
        }

        pAImeProfile->Release();
        return hr;
    }
}


STDAPI
CActiveIMM::GetConversionListA(
    HKL hKL,
    HIMC hIMC,
    LPSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetConversionListA
    IActiveIMMIME::GetConversionListA

Routine Description:

    Retrieves the list of characters or words from one character or word. ANSI implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    lpSrc - [in] Address of a string value containing a null-terminated character string.
    uBufLen - [in] Unsigned integer value that contains the size of the destination buffer,
                   in bytes.
    uFlag - [in] Unsigned integer value that contains action flags.
    lpDst - [out] Address of the CANDIDATELIST structure that receives the conversion result.
    puCopied - [out] Address of an unsigned integer value that receives the number of bytes
                     copied to the specified buffer. If uBufLen is zero, puCopied receives the
                     number of bytes needed to receive the list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetConversionListA");

    if (_IsRealIme())
    {
        return Imm32_GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetConversionListW(
    HKL hKL,
    HIMC hIMC,
    LPWSTR lpSrc,
    UINT uBufLen,
    UINT uFlag,
    CANDIDATELIST *lpDst,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetConversionListW
    IActiveIMMIME::GetConversionListW

Routine Description:

    Retrieves the list of characters or words from one character or word. Unicode implementation.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    hIMC - [in] Handle to the input context.
    lpSrc - [in] Address of a string value containing a null-terminated character string.
    uBufLen - [in] Unsigned integer value that contains the size of the destination buffer,
                   in bytes.
    uFlag - [in] Unsigned integer value that contains action flags.
    lpDst - [out] Address of the CANDIDATELIST structure that receives the conversion result.
    puCopied - [out] Address of an unsigned integer value that receives the number of bytes
                     copied to the specified buffer. If uBufLen is zero, puCopied receives the
                     number of bytes needed to receive the list.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetConversionListW");

    if (_IsRealIme())
    {
        return Imm32_GetConversionListW(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetDescriptionA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszDescription,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetDescriptionA
    IActiveIMMIME::GetDescriptionA

Routine Description:

    Copies the description of the IME to the specified buffer (ANSI implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned long integer value that contains the size of the buffer in characters.
    lpszDescription - [out] Address of a string buffer that receives the null-terminated string
                            describing the IME.
    puCopied - [out] Address of an unsigned long integer that receives the number of characters
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in characters, needed to receive the description.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetDescriptionA");

    if (_IsRealIme())
    {
        return Imm32_GetDescriptionA(hKL, uBufLen, lpszDescription, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetDescriptionW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszDescription,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetDescriptionW
    IActiveIMMIME::GetDescriptionW

Routine Description:

    Copies the description of the IME to the specified buffer (Unicode implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned long integer value that contains the size of the buffer in characters.
    lpszDescription - [out] Address of a string buffer that receives the null-terminated string
                            describing the IME.
    puCopied - [out] Address of an unsigned long integer that receives the number of characters
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in characters, needed to receive the description.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetDescriptionW");

    if (_IsRealIme())
    {
        return Imm32_GetDescriptionW(hKL, uBufLen, lpszDescription, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetIMEFileNameA(
    HKL hKL,
    UINT uBufLen,
    LPSTR lpszFileName,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetIMEFileNameA
    IActiveIMMIME::GetIMEFileNameA

Routine Description:

    Retrieves the file name of the IME associated with the specified keyboard layout
    (ANSI implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned integer value that contains the size, in bytes, of the buffer.
    lpszFileName - [out] Address of a string buffer that receives the file name.
    puCopied - [out] Address of an unsigned integer that receives the number of bytes
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in bytes, required to receive the file name.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetIMEFileNameA");

    if (_IsRealIme())
    {
        return Imm32_GetIMEFileNameA(hKL, uBufLen, lpszFileName, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetIMEFileNameW(
    HKL hKL,
    UINT uBufLen,
    LPWSTR lpszFileName,
    UINT *puCopied
    )

/*++

Method:

    IActiveIMMApp::GetIMEFileNameW
    IActiveIMMIME::GetIMEFileNameW

Routine Description:

    Retrieves the file name of the IME associated with the specified keyboard layout
    (Unicode implementation).

Arguments:

    hKL - [in] Handle to the keyboard layout.
    uBufLen - [in] Unsigned integer value that contains the size, in bytes, of the buffer.
    lpszFileName - [out] Address of a string buffer that receives the file name.
    puCopied - [out] Address of an unsigned integer that receives the number of bytes
                     copied to the buffer. If uBufLen is zero, puCopied receives the buffer size,
                     in bytes, required to receive the file name.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetIMEFileNameW");

    if (_IsRealIme())
    {
        return Imm32_GetIMEFileNameW(hKL, uBufLen, lpszFileName, puCopied);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::GetProperty(
    IN HKL hKL,
    IN DWORD dwIndex,
    OUT DWORD *pdwProperty
    )

/*++

Method:

    IActiveIMMApp::GetProperty
    IActiveIMMIME::GetProperty

Routine Description:

    Retrieves the property and capabilities of the IME associated with specified
    keyboard layout.

Arguments:

    hKL - [in] Handle of the keyboard layout.
    dwIndex - [in] Unsigned long integer value that contains the type of property
                   information to retrieve.
    pdwProperty - [out] Address of an unsigned long integer value that receives the
                        property or capability value, depending on the value of the
                        dwIndex parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::GetProperty");


    if (_IsRealIme(hKL))
    {
        return Imm32_GetProperty(hKL, dwIndex, pdwProperty);
    }

    if (dwIndex != IGP_GETIMEVERSION &&
        ( (dwIndex & 3) || dwIndex > IGP_LAST))
    {
        // bad fdwIndex
        return E_FAIL;
    }

    if (dwIndex == IGP_GETIMEVERSION) {
        *pdwProperty = IMEVER_0400;
        return S_OK;
    }

    // Inquire IME's information and UI class name.
    if (_pActiveIME)
        _pActiveIME->Inquire(FALSE, &_IMEInfoEx.ImeInfo, _IMEInfoEx.achWndClass, &_IMEInfoEx.dwPrivate);

    *pdwProperty = *(DWORD *)((BYTE *)&_IMEInfoEx.ImeInfo + dwIndex);
    return S_OK;
}

STDAPI
CActiveIMM::InstallIMEA(
    LPSTR lpszIMEFileName,
    LPSTR lpszLayoutText,
    HKL *phKL
    )

/*++

Method:

    IActiveIMMApp::InstallIMEA
    IActiveIMMIME::InstallIMEA

Routine Description:

    Installs an IME into the system. ANSI implementaion.

Arguments:

    lpszIMEFileName - [in] Address of a null-terminated string value that specifies the full path
                           of the IME.
    lpszLayoutText - [in] Address of a null-terminated string value that specifies the name of the
                          IME. This name also specifies the layout text of the IME.
    phKL - [out] Address of the handle to the keyboard layout for the IME.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::InstallIMEA");

    if (_IsRealIme())
    {
        return Imm32_InstallIMEA(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::InstallIMEW(
    LPWSTR lpszIMEFileName,
    LPWSTR lpszLayoutText,
    HKL *phKL
    )

/*++

Method:

    IActiveIMMApp::InstallIMEW
    IActiveIMMIME::InstallIMEW

Routine Description:

    Installs an IME into the system. Unicode implementaion.

Arguments:

    lpszIMEFileName - [in] Address of a null-terminated string value that specifies the full path
                           of the IME.
    lpszLayoutText - [in] Address of a null-terminated string value that specifies the name of the
                          IME. This name also specifies the layout text of the IME.
    phKL - [out] Address of the handle to the keyboard layout for the IME.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::InstallIMEW");

    if (_IsRealIme())
    {
        return Imm32_InstallIMEW(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::IsIME(
    HKL hKL
    )

/*++

Method:

    IActiveIMMApp::IsIME
    IActiveIMMIME::IsIME

Routine Description:

    Checks whether the specified handle identifies an IME.

Arguments:

    hKL - [in] Handle to the keyboard layout to check.

Return Value:

    Returns a S_OK value if the handle identifies an IME, or S_FALSE otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::IsIME");

    if (_IsRealIme(hKL))
    {
        return Imm32_IsIME(hKL);
    }

    HRESULT hr;
    IAImeProfile* pAImeProfile;
    extern HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

    hr = CAImmProfile_CreateInstance(NULL, IID_IAImeProfile, (void**)&pAImeProfile);

    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CreateInstance(IsIME) failed");
        return hr;
    }

    hr = pAImeProfile->IsIME(hKL);

    pAImeProfile->Release();
    return hr;
}


STDAPI
CActiveIMM::DisableIME(
    DWORD idThread
    )

/*++

Method:

    IActiveIMMApp::DisableIME
    IActiveIMMIME::DisableIME

Routine Description:

    Disables the Input Method Editor (IME) for a thread or all threads in a process.

Arguments:

    idThread - [in] Unsigned long integer value that contains the thread identifier for which
                    the IME will be disabled. If idThread is zero, the IME for the current thread
                    is disabled. If idThread is -1, the IME is disabled for all threads in the
                    current process.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    TraceMsg(TF_API, "CActiveIMM::DisableIME");

    if (_IsRealIme())
    {
        return Imm32_DisableIME(idThread);
    }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\list.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.cpp

Abstract:

    This file implements the CFilterList class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "list.h"
#include "defs.h"
#include "atlbase.h"
#include "globals.h"
#include "resource.h"
#include "msctfp.h"


//+---------------------------------------------------------------------------
//
// CFilterList
//
//----------------------------------------------------------------------------

LPCTSTR REG_DIMM12_KEY = TEXT("SOFTWARE\\Microsoft\\CTF\\DIMM12");
LPCTSTR REG_FILTER_LIST_VAL = TEXT("Filter List");

CFilterList::CFilterList(
    )
{
    //
    // Setup system defines filter list from registry value
    //
    CRegKey   Dimm12Reg;
    LONG      lRet;
    lRet = Dimm12Reg.Open(HKEY_LOCAL_MACHINE, REG_DIMM12_KEY, KEY_READ);
    if (lRet == ERROR_SUCCESS) {
        TCHAR  szValue[128];
        DWORD  dwCount = sizeof(szValue);
        lRet = Dimm12Reg.QueryValue(szValue, REG_FILTER_LIST_VAL, &dwCount);
        if (lRet == ERROR_SUCCESS && dwCount > 0) {

            //
            // REG_MULTI_SZ
            //
            // Format of Filter List:
            //    <Present>=<Current>,<Class Name>
            //        where:
            //            Present : Specify "Present" or "NotPresent".
            //                      If "Present" were specified, even apps didn't set class name
            //                      with IActiveIMMApp::FilterClientWindows,
            //                      this function return TRUE that correspond class name.
            //                      If "NotPresent" were specified, even apps do set class name,
            //                      this function return FALSE that correspond class name.
            //            Current : Specify "Current" or "Parent".
            //                      If "Current" were specified, called GetClassName with current hWnd.
            //                      If "Parent" were specified, called GetClassName with GetParent.
            //            Class Name : Specify class name string.
            //

            LPTSTR psz = szValue;
            while ((dwCount = lstrlen(psz)) > 0) {
                CString WholeText(psz);
                int sep1;
                if ((sep1 = WholeText.Find(TEXT('='))) > 0) {
                    CString Present(WholeText, sep1);
                    CParserTypeOfPresent TypeOfPresent;
                    if (TypeOfPresent.Parser(Present)) {

                        int sep2;
                        if ((sep2 = WholeText.Find(TEXT(','))) > 0) {
                            CString Parent(WholeText.Mid(sep1+1, sep2-sep1-1));
                            CParserTypeOfHwnd TypeOfHwnd;
                            if (TypeOfHwnd.Parser(Parent)) {

                                CString ClassName(WholeText.Mid(sep2+1));
                                if (TypeOfPresent.m_type == CParserTypeOfPresent::NOT_PRESENT_LIST)
                                    m_NotPresentList.SetAt(ClassName, TypeOfHwnd);
                                else if (TypeOfPresent.m_type == CParserTypeOfPresent::PRESENT_LIST)
                                    m_PresentList.SetAt(ClassName, TypeOfHwnd);
                            }
                        }
                    }
                }

                psz += dwCount + 1;
            }
        }
    }

    //
    // Setup default filter list from resource data (RCDATA)
    //
    LPTSTR   lpName = (LPTSTR) ID_FILTER_LIST;

    HRSRC hRSrc = FindResourceEx(g_hInst, RT_RCDATA, lpName, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    if (hRSrc == NULL)
        return;

    HGLOBAL hMem = LoadResource(g_hInst, hRSrc);
    if (hMem == NULL)
        return;

#pragma pack(push, 1)
    struct _RC_FILTER_LIST {
        WORD    NumberOfList;
        struct  _RC_ITEMS {
            WORD    Present;
            WORD    Current;
            BYTE    String[1];
        }        Item;
    };
#pragma pack(pop)

    struct _RC_FILTER_LIST* pData = (struct _RC_FILTER_LIST*)LockResource(hMem);

    WORD  NumberOfList = pData->NumberOfList;

    struct _RC_FILTER_LIST::_RC_ITEMS* pItem = &pData->Item;
    while (NumberOfList--) {
        //
        // RCDATA
        //
        // Format of Filter List:
        //    <WORD NumberOfList>
        //        where:
        //            NumberOfList : Number of list.
        //                           This is allocated one data in the fist of RCDATA.
        //
        //    <WORD Present>=<WORD Current>,<LPCSTR Class Name>
        //        where:
        //            Present : Specify "WORD:0 (Present)" or "WORD:1 (NotPresent)".
        //                      If "Present" were specified, even apps didn't set class name
        //                      with IActiveIMMApp::FilterClientWindows,
        //                      this function return TRUE that correspond class name.
        //                      If "NotPresent" were specified, even apps do set class name,
        //                      this function return FALSE that correspond class name.
        //            Current : Specify "WORD:0 (Current)" or "WORD:1 (Parent)".
        //                      If "Current" were specified, called GetClassName with current hWnd.
        //                      If "Parent" were specified, called GetClassName with GetParent.
        //            Class Name : Specify class name string with LPCSTR (ASCIIZ).
        //

        CParserTypeOfPresent TypeOfPresent;
        TypeOfPresent.m_type = pItem->Present ? CParserTypeOfPresent::NOT_PRESENT_LIST
                                              : CParserTypeOfPresent::PRESENT_LIST;

        CParserTypeOfHwnd TypeOfHwnd;
        TypeOfHwnd.m_type = pItem->Current ? CParserTypeOfHwnd::HWND_PARENT
                                           : CParserTypeOfHwnd::HWND_CURRENT;

        LPCSTR psz = (LPCSTR)pItem->String;
        CString ClassName(psz);
        if (TypeOfPresent.m_type == CParserTypeOfPresent::NOT_PRESENT_LIST)
            m_NotPresentList.SetAt(ClassName, TypeOfHwnd);
        else if (TypeOfPresent.m_type == CParserTypeOfPresent::PRESENT_LIST)
            m_PresentList.SetAt(ClassName, TypeOfHwnd);

        psz += lstrlen(psz) + 1;

        pItem = (struct _RC_FILTER_LIST::_RC_ITEMS*)(BYTE*)psz;
    }
}

HRESULT
CFilterList::_Update(
    ATOM *aaWindowClasses,
    UINT uSize,
    BOOL *aaGuidMap
    )
{
    if (aaWindowClasses == NULL && uSize > 0)
        return E_INVALIDARG;

    EnterCriticalSection(g_cs);

    while (uSize--) {
        FILTER_CLIENT filter;
        filter.fFilter = TRUE;
        filter.fGuidMap =  aaGuidMap != NULL ? *aaGuidMap++ : FALSE;
        m_FilterList.SetAt(*aaWindowClasses++, filter);
    }

    LeaveCriticalSection(g_cs);

    return S_OK;
}

BOOL
CFilterList::_IsPresent(
    HWND hWnd,
    CMap<HWND, HWND, ITfDocumentMgr *, ITfDocumentMgr *> &mapWndFocus,
    BOOL fExcludeAIMM,
    ITfDocumentMgr *dimAssoc
    )
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    //
    // If this is a native cicero aware window, we don't have to do 
    // anything.
    //
    // when hWnd is associated to NULL-hIMC, GetAssociated may return
    // empty DIM that is made by Win32 part. We want to compare it but
    // mapWndFocus does not know it so we return FALSE then. And it should be
    // ok.
    //
    if (! fExcludeAIMM && dimAssoc)
    {
        ITfDocumentMgr *dim = NULL;
        if (mapWndFocus.Lookup(hWnd, dim) && (dim == dimAssoc))
        {
            fRet = TRUE;
        }
        dimAssoc->Release();
    }
    else
    {
        fRet =  IsExceptionPresent(hWnd);
    }

    LeaveCriticalSection(g_cs);
    return fRet;
}

BOOL
CFilterList::IsExceptionPresent(
    HWND hWnd
    )
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    ATOM aClass = (ATOM)GetClassLong(hWnd, GCW_ATOM);
    FILTER_CLIENT filter = { 0 };
    BOOL ret = m_FilterList.Lookup(aClass, filter);

    TCHAR achMyClassName[MAX_PATH+1];
    TCHAR achParentClassName[MAX_PATH+1];
    int lenMyClassName = ::GetClassName(hWnd, achMyClassName, ARRAYSIZE(achMyClassName) - 1);
    int lenParentClassName = ::GetClassName(GetParent(hWnd), achParentClassName, ARRAYSIZE(achParentClassName) - 1);
    CParserTypeOfHwnd  TypeOfHwnd;

    // null termination
    achMyClassName[ARRAYSIZE(achMyClassName) - 1] = TEXT('\0');
    achParentClassName[ARRAYSIZE(achParentClassName) - 1] = TEXT('\0');

    if (! ret || (! ret && ! filter.fFilter))
        goto Exit;

    if (filter.fFilter) {
        //
        // fFilter = TRUE : Registered window class ATOM
        //
        if (ret) {
            //
            // Found ATOM in the list.
            //
            if (lenMyClassName) {
                if (m_NotPresentList.Lookup(achMyClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_CURRENT)
                    goto Exit;
            }
            if (lenParentClassName) {
                if (m_NotPresentList.Lookup(achParentClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_PARENT)
                    goto Exit;
            }
            fRet = TRUE;
        }
        else
        {
            //
            // Not found ATOM in the list.
            //
            if (lenMyClassName) {
                if (m_PresentList.Lookup(achMyClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_CURRENT)
                {
                    fRet = TRUE;
                    goto Exit;
                }
            }
            if (lenParentClassName) {
                if (m_PresentList.Lookup(achParentClassName, TypeOfHwnd) &&
                    TypeOfHwnd.m_type == CParserTypeOfHwnd::HWND_PARENT)
                {
                    fRet = TRUE;
                    goto Exit;
                }
            }
        }
    }

Exit:
    LeaveCriticalSection(g_cs);
    return fRet;
}

BOOL
CFilterList::_IsGuidMapEnable(
    HWND hWnd,
    BOOL& fGuidMap
    )
{
    BOOL fRet = FALSE;

    EnterCriticalSection(g_cs);

    ATOM aClass = (ATOM)GetClassLong(hWnd, GCW_ATOM);
    FILTER_CLIENT filter = { 0 };
    BOOL ret = m_FilterList.Lookup(aClass, filter);

    fGuidMap = filter.fGuidMap;

    LeaveCriticalSection(g_cs);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\immdevaw.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    immdevaw.h

Abstract:

    This file defines the A/W structure for IMM.

Author:

Revision History:

Notes:

--*/

#ifndef _IMMDEVAW_H_
#define _IMMDEVAW_H_


/////////////////////////////////////////////////////////////////////////////
// LOGFONTA  and  LOGFONTW

typedef union {
    LOGFONTA    A;
    LOGFONTW    W;
} LOGFONTAW;


/////////////////////////////////////////////////////////////////////////////
// CHAR  and  WCHAR

typedef union {
    char       A;
    WCHAR      W;
} CHARAW;


/////////////////////////////////////////////////////////////////////////////
// IMEMENUITEMINFOA  and  IMEMENUITEMINFOW

typedef union {
    IMEMENUITEMINFOA    A;
    IMEMENUITEMINFOW    W;
} IMEMENUITEMINFOAW;

#endif // _IMMDEVAW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\immcom.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       dimmcom.cpp
//
//  Contents:   CActiveIMM COM methods without win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "defs.h"
#include "util.h"

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CActiveIMM::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IActiveIMMIME_Private))
    {
        *ppvObj = SAFECAST(this, IActiveIMMIME_Private *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CActiveIMM::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CActiveIMM::Release()
{
    LONG cr = --_cRef;

    Assert(_cRef >= 0);

    if (_cRef == 0)
    {
        delete this;
    }

    return cr;
}

HRESULT CActiveIMM::Activate(BOOL fRestoreLayout)

/*++

Method:

    IActiveIMMApp::Activate

Routine Description:

    Starts the Active IMM service and sets the status of Active IMEs for the thread.

Arguments:

    fRestoreLayout - [in] Boolean value that determines wherher Active IMEs are enabled
                          for the thread. If TRUE, the method enables Active IMEs.
                          Otherwise it disables Active IMEs.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HKL hKL;

    TraceMsg(TF_GENERAL, "Activate called for %x", GetCurrentThreadId());

    //
    // If target thread doesn't activate the IActiveIME, then calls _ActivateIME.
    // Otherwise, if already activated then add reference count and returns S_OK.
    //

    //
    // Increment activate reference count.
    //
    if (_AddActivate() > 1)
    {
        return S_OK;
    }


    // init the thread focus wnd
    _hFocusWnd = GetFocus();

    if (_CreateActiveIME()) {

        //
        // setup the hooks
        //
        if (!_InitHooks()) {
            _ReleaseActivate();
            return E_UNEXPECTED;
        }

        /*
         * If hKL were regacy IME, then we should not call WM_IME_SELCT to Default IME window.
         * The wrapapi.h should check hKL.
         * The user32!ImeSelectHandler would like create new pimeui.
         */
        _GetKeyboardLayout(&hKL);
        _ActivateLayout(hKL, NULL);

        /*
         * If hKL were Cicero IME and IsOnImm() is true,
         * then we should call WM_IME_SELECT to Default IME window.
         * SendIMEMessage() doesn't send WM_IME_SELECT message when IsOnImm() is true
         * because imm32 also send it message to Default IME window.
         * However, when start new application, imm32 doesn't send message so in this case
         * win32 layer can not create UI window.
         */
        if ( (! _IsRealIme() && IsOnImm()) || ! IsOnImm()) {
            _OnImeSelect(hKL);
        }
    }

    _OnSetFocus(_hFocusWnd, _IsRealIme());

    // if everything went ok, and this is the first call on this thread
    // need to AddRef this
    AddRef();

    return S_OK;
}


HRESULT
CActiveIMM::Deactivate(
    )

/*++

Method:

    IActiveIMMApp::Deactivate

Routine Description:

    Stops the Activate IMM service.

Arguments:

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    HKL hUnSelKL;

    TraceMsg(TF_GENERAL, "Deactivate called for %x", GetCurrentThreadId());

    if (!_IsAlreadyActivate())
        return E_UNEXPECTED;

    hr = S_OK;

    if (_ReleaseActivate() == 0)
    {
        _OnKillFocus(_hFocusWnd, _IsRealIme());

        //hr = _pCiceroIME->Deactivate(_hFocusWnd, _IsRealIme());
        hr = _GetKeyboardLayout(&hUnSelKL);
        if (FAILED(hr))
            return hr;

        //
        // unload the hooks
        //
        _UninitHooks();

        _DeactivateLayout(NULL, hUnSelKL);

        if ( (! _IsRealIme() && IsOnImm()) || ! IsOnImm()) {
            _OnImeUnselect(hUnSelKL);
        }

        _DestroyActiveIME();
        SafeReleaseClear(_AImeProfile);

        // last call on this thread, delete this
        // NB: no this pointer after the following Release!
        Release();
    }

    return hr;
}







HRESULT
CActiveIMM::FilterClientWindows(
    ATOM *aaWindowClasses,
    UINT uSize,
    BOOL *aaGuidMap
    )

/*++

Method:

    IActiveIMMAppEx::FilterClientWindows

Routine Description:

    Creates a list of registered window class that support Active IMM.

Arguments:

    aaWindowClasses - [in] Address of a list of window classes.
    uSize - [in] Unsigned integer that contains the number of window classes in the list.
    aaGuidMap - [in] Address of a list of GUID map enable/disable flag.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    if (g_ProcessIMM)
    {
        hr = g_ProcessIMM->_FilterList._Update(aaWindowClasses, uSize, aaGuidMap);
    }
    else
    {
        hr = E_FAIL;
    }

    HWND hwndFocus = GetFocus();

    if (hwndFocus)
    {
        ATOM aClass = (ATOM)GetClassLong(hwndFocus, GCW_ATOM);
        UINT u = 0;
        while (u < uSize)
        {
            if (aClass == aaWindowClasses[u])
            {
                _OnSetFocus(hwndFocus, _IsRealIme());
                break;
            }
            u++;
        }
    }

    return hr;
}








HRESULT
CActiveIMM::FilterClientWindowsEx(
    HWND hWnd,
    BOOL fGuidMap
    )

/*++

Method:

    IActiveIMMAppEx::FilterClientWindowsEx

Routine Description:

    Register window handle that support Active IMM.

Arguments:

    hWnd - [in] Handle to the window.
    fGuidMap - [in] Boolean value that contains the GUID map flag.
                    If TRUE, the hIMC's attribute field contains GUID map attribute and application should get GUID atom by IActiveIMMAppEx::GetGuidMap method.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    _mapFilterWndEx.SetAt(hWnd, fGuidMap);

    HWND hwndFocus = GetFocus();

    if (hwndFocus == hWnd)
        _OnSetFocus(hWnd, _IsRealIme());

    return S_OK;
}


HRESULT
CActiveIMM::UnfilterClientWindowsEx(
    HWND hWnd
    )

/*++

Method:

    IActiveIMMAppEx::UnfilterClientWindowsEx

Routine Description:

    Unregister window handle that support Active IMM.

Arguments:

    hWnd - [in] Handle to the window.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    _mapFilterWndEx.RemoveKey(hWnd);

    HWND hwndFocus = GetFocus();

    if (hwndFocus == hWnd)
        _OnKillFocus(hWnd, _IsRealIme());

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\pimm.cpp ===
//
// pimm.cpp
//

#include "private.h"
#include "defs.h"
#include "pimm.h"
#include "cdimm.h"
#include "globals.h"
#include "util.h"
#include "immxutil.h"

extern void DllAddRef(void);
extern void DllRelease(void);

HRESULT CActiveIMM_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

LONG CProcessIMM::_cRef = -1;

//+---------------------------------------------------------------------------
//
// RunningInExcludedModule
//
// Exclude some processes from using the old aimm IIDs/CLSIDs.
//----------------------------------------------------------------------------

BOOL RunningInExcludedModule()
{
static const TCHAR c_szOutlookModule[] = TEXT("outlook.exe");
static const TCHAR c_szMsoobeModule[] = TEXT("msoobe.exe");

    DWORD dwHandle;
    void *pvData;
    VS_FIXEDFILEINFO *pffi;
    UINT cb;
    TCHAR ch;
    TCHAR *pch;
    TCHAR *pchFileName;
    BOOL fRet;
    TCHAR achModule[MAX_PATH+1];

    if (GetModuleFileName(NULL, achModule, ARRAYSIZE(achModule)-1) == 0)
        return FALSE;

    // null termination.
    achModule[ARRAYSIZE(achModule) - 1] = TEXT('\0');

    pch = pchFileName = achModule;

    while ((ch = *pch) != 0)
    {
        pch = CharNext(pch);

        if (ch == '\\')
        {
            pchFileName = pch;
        }
    }

    fRet = FALSE;

    if (lstrcmpi(pchFileName, c_szOutlookModule) == 0)
    {
        static BOOL s_fCached = FALSE;
        static BOOL s_fOldVersion = TRUE;

        // don't run aimm with versions of outlook before 10.0

        if (s_fCached)
        {
            return s_fOldVersion;
        }

        cb = GetFileVersionInfoSize(achModule, &dwHandle);

        if (cb == 0)
        {
            // can't get ver info...assume the worst
            return TRUE;
        }

        if ((pvData = cicMemAlloc(cb)) == NULL)
            return TRUE; // assume the worst

        if (GetFileVersionInfo(achModule, 0, cb, pvData) &&
            VerQueryValue(pvData, TEXT("\\"), (void **)&pffi, &cb))
        {
            fRet = s_fOldVersion = (HIWORD(pffi->dwProductVersionMS) < 10);
            s_fCached = TRUE; // set this last to be thread safe
        }
        else
        {
            fRet = TRUE; // something went wrong
        }

        cicMemFree(pvData);           
    }
    else if (lstrcmpi(pchFileName, c_szMsoobeModule) == 0)
    {
        //
        // #339234.
        //
        // MSOOBE.EXE starts before the end user logon. However it opens an 
        // interactive windows station ("WinSta0") and open a default 
        // desktop ("Default"). So MSIMTF.DLL thinks it is not winlogon 
        // desktop. But the fact is that the thread is running on 
        // ".Default user". So I think we may not want to start Cicero 
        // there because it could load 3rd vender TIP. 
        //
        // #626606
        // msoobe doesn't allow any creating new process under Windows
        // Product Activation wizard. That's the security reason to prevent 
        // people from replacing msoobe.exe with explorer.exe and running the
        // machine without activating.

        fRet = TRUE;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance - CLSID_CActiveIMM12
//
//----------------------------------------------------------------------------

// entry point for msimtf.dll
HRESULT CActiveIMM_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    CActiveIMM *pActiveIMM;
    HRESULT hr;
    BOOL fInitedTLS = FALSE;

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    //
    // Look up disabling Text Services status from the registry.
    // If it is disabled, return fail not to support Text Services.
    //
    if (IsDisabledTextServices())
        return E_FAIL;

    if (RunningInExcludedModule())
        return E_NOINTERFACE;

    if (!IsInteractiveUserLogon())
        return E_NOINTERFACE;

    if (NoTipsInstalled(NULL))
        return E_NOINTERFACE;

    // init the tls
    // nb: we also try to do this in Activate, but this is to preserve
    // existing behavior on the main thread (HACKHACK)
    if ((pActiveIMM = GetTLS()) == NULL)
    {
        if ((pActiveIMM = new CActiveIMM) == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(hr=pActiveIMM->_Init()) ||
            FAILED(hr=IMTLS_SetActiveIMM(pActiveIMM) ? S_OK : E_FAIL))
        {
            delete pActiveIMM;
            return hr;
        }

        fInitedTLS = TRUE;
    }

    // we return a per-process IActiveIMM
    // why?  because trident breaks the apt threaded rules
    // and uses a single per-process obj
    if (g_ProcessIMM)
    {
        hr = g_ProcessIMM->QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = E_FAIL;
    }

    if (fInitedTLS)
    {
        //
        // Tell CActiveIMM which interface created.
        //
        if (SUCCEEDED(hr)) {
            pActiveIMM->_EnableGuidMap( IsEqualIID(riid, IID_IActiveIMMAppEx) );
        }

        // dec the ref on the tls.  Normally it will drop from 2 -> 1
        // if QueryInterface failed, it will be deleted
        pActiveIMM->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance - CLSID_CActiveIMM12_Trident
//
//----------------------------------------------------------------------------

// entry point for msimtf.dll
HRESULT CActiveIMM_CreateInstance_Trident(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    HRESULT hr = CActiveIMM_CreateInstance(pUnkOuter, riid, ppvObj);
    if (SUCCEEDED(hr))
    {
        g_fAIMM12Trident = TRUE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
// QueryInterface
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::QueryInterface(REFIID riid, void **ppvObj)
{
    //
    // 4955DD32-B159-11d0-8FCF-00AA006BCC59
    //
    static const IID IID_IActiveIMMAppTrident4x = {
       0x4955DD32,
       0xB159,
       0x11d0,
       { 0x8F, 0xCF, 0x00, 0xaa, 0x00, 0x6b, 0xcc, 0x59 }
    };

    // 
    // c839a84c-8036-11d3-9270-0060b067b86e
    // 
    static const IID IID_IActiveIMMAppPostNT4 = { 
        0xc839a84c,
        0x8036,
        0x11d3,
        {0x92, 0x70, 0x00, 0x60, 0xb0, 0x67, 0xb8, 0x6e}
      };

    if (ppvObj == NULL)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IActiveIMMAppTrident4x) ||
        IsEqualIID(riid, IID_IActiveIMMAppPostNT4) ||
        IsEqualIID(riid, IID_IActiveIMMApp))
    {
        *ppvObj = SAFECAST(this, IActiveIMMApp *);
    }
    else if (IsEqualIID(riid, IID_IActiveIMMAppEx))
    {
        *ppvObj = SAFECAST(this, IActiveIMMAppEx*);
    }
    else if (IsEqualIID(riid, IID_IActiveIMMMessagePumpOwner))
    {
        *ppvObj = SAFECAST(this, IActiveIMMMessagePumpOwner *);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IAImmThreadCompartment))
    {
        *ppvObj = SAFECAST(this, IAImmThreadCompartment*);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
// AddRef
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CProcessIMM::AddRef()
{
    CActiveIMM *pActiveIMM;

    // nb: our ref count is special!
    // it is initialized to -1 so we can use InterlockedIncrement
    // correctly on win95
    if (InterlockedIncrement(&_cRef) == 0)
    {
        DllAddRef();
    }

    // inc the thread ref
    if (pActiveIMM = GetTLS())
    {
        pActiveIMM->AddRef();
    }
    else
    {
        Assert(0); // how did we get this far with no tls!?
    }

    return _cRef+1; // "diagnostic" unthread-safe return
}

//+---------------------------------------------------------------------------
//
// Release
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) CProcessIMM::Release()
{
    CActiveIMM *pActiveIMM;

    // dec the thread ref
    if (pActiveIMM = GetTLS())
    {
        pActiveIMM->Release();
    }
    else
    {
        Assert(0); // how did we get this far with no tls!?
    }

    // nb: our ref count is special!
    // it is initialized to -1 so we can use InterlockedIncrement
    // correctly on win95
    if (InterlockedDecrement(&_cRef) < 0)
    {
        DllRelease();
    }

    // this obj lives as long as the process does,
    // so no need for a delete
    return _cRef+1; // "diagnostic" unthread safe return
}


//+---------------------------------------------------------------------------
//
// Start
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Start()
{
    Assert(0); // who's calling this?
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// End
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::End()
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnTranslateMessage
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::OnTranslateMessage(const MSG *pMsg)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Pause
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Pause(DWORD *pdwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// Resume
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Resume(DWORD dwCookie)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// CreateContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::CreateContext(HIMC *phIMC)
{
    CActiveIMM *pActiveIMM;

    if (phIMC == NULL)
        return E_INVALIDARG;

    *phIMC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->CreateContext(phIMC);
    }

    return Imm32_CreateContext(phIMC);
}

//+---------------------------------------------------------------------------
//
// DestroyContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DestroyContext(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->DestroyContext(hIMC);
    }

    return Imm32_DestroyContext(hIMC);
}

//+---------------------------------------------------------------------------
//
// AssociateContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::AssociateContext(HWND hWnd, HIMC hIME, HIMC *phPrev)
{
    CActiveIMM *pActiveIMM;

    if (phPrev == NULL)
        return E_INVALIDARG;

    *phPrev = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->AssociateContext(hWnd, hIME, phPrev);
    }

    return Imm32_AssociateContext(hWnd, hIME, phPrev);
}

//+---------------------------------------------------------------------------
//
// AssociateContextEx
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->AssociateContextEx(hWnd, hIMC, dwFlags);
    }

    return Imm32_AssociateContextEx(hWnd, hIMC, dwFlags);
}

//+---------------------------------------------------------------------------
//
// GetContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetContext(HWND hWnd, HIMC *phIMC)
{
    CActiveIMM *pActiveIMM;

    if (phIMC == NULL)
        return E_INVALIDARG;

    *phIMC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetContext(hWnd, phIMC);
    }

    return Imm32_GetContext(hWnd, phIMC);
}

//+---------------------------------------------------------------------------
//
// ReleaseContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ReleaseContext(HWND hWnd, HIMC hIMC)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetIMCLockCount
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount)
{
    CActiveIMM *pActiveIMM;

    if (pdwLockCount == NULL)
        return E_INVALIDARG;

    *pdwLockCount = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMCLockCount(hIMC, pdwLockCount);
    }

    return Imm32_GetIMCLockCount(hIMC, pdwLockCount);
}

//+---------------------------------------------------------------------------
//
// LockIMC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC)
{
    CActiveIMM *pActiveIMM;

    if (ppIMC == NULL)
        return E_INVALIDARG;

    *ppIMC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->LockIMC(hIMC, ppIMC);
    }

    return Imm32_LockIMC(hIMC, ppIMC);
}

//+---------------------------------------------------------------------------
//
// UnlockIMC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnlockIMC(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnlockIMC(hIMC);
    }

    return Imm32_UnlockIMC(hIMC);
}

//+---------------------------------------------------------------------------
//
// CreateIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::CreateIMCC(DWORD dwSize, HIMCC *phIMCC)
{
    CActiveIMM *pActiveIMM;

    if (phIMCC == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->CreateIMCC(dwSize, phIMCC);
    }

    return Imm32_CreateIMCC(dwSize, phIMCC);
}

//+---------------------------------------------------------------------------
//
// DestroyIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DestroyIMCC(HIMCC hIMCC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->DestroyIMCC(hIMCC);
    }

    return Imm32_DestroyIMCC(hIMCC);
}

//+---------------------------------------------------------------------------
//
// GetIMCCSize
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMCCSize(HIMCC hIMCC, DWORD *pdwSize)
{
    CActiveIMM *pActiveIMM;

    if (pdwSize == NULL)
        return E_INVALIDARG;

    *pdwSize = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMCCSize(hIMCC, pdwSize);
    }

    return Imm32_GetIMCCSize(hIMCC, pdwSize);
}

//+---------------------------------------------------------------------------
//
// ReSizeIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ReSizeIMCC(HIMCC hIMCC, DWORD dwSize,  HIMCC *phIMCC)
{
    CActiveIMM *pActiveIMM;

    if (phIMCC == NULL)
        return E_INVALIDARG;

    *phIMCC = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->ReSizeIMCC(hIMCC, dwSize, phIMCC);
    }

    return Imm32_ReSizeIMCC(hIMCC, dwSize,  phIMCC);
}

//+---------------------------------------------------------------------------
//
// GetIMCCLockCount
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount)
{
    CActiveIMM *pActiveIMM;

    if (pdwLockCount == NULL)
        return E_INVALIDARG;

    *pdwLockCount = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMCCLockCount(hIMCC, pdwLockCount);
    }

    return Imm32_GetIMCCLockCount(hIMCC, pdwLockCount);
}

//+---------------------------------------------------------------------------
//
// LockIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::LockIMCC(HIMCC hIMCC, void **ppv)
{
    CActiveIMM *pActiveIMM;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->LockIMCC(hIMCC, ppv);
    }

    return Imm32_LockIMCC(hIMCC, ppv);
}

//+---------------------------------------------------------------------------
//
// UnlockIMCC
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnlockIMCC(HIMCC hIMCC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnlockIMCC(hIMCC);
    }

    return Imm32_UnlockIMCC(hIMCC);
}

//+---------------------------------------------------------------------------
//
// GetOpenStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetOpenStatus(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetOpenStatus(hIMC);
    }

    return Imm32_GetOpenStatus(hIMC);
}

//+---------------------------------------------------------------------------
//
// SetOpenStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetOpenStatus(HIMC hIMC, BOOL fOpen)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetOpenStatus(hIMC, fOpen);
    }

    return Imm32_SetOpenStatus(hIMC, fOpen);
}

//+---------------------------------------------------------------------------
//
// GetConversionStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion, DWORD *lpfdwSentence)
{
    CActiveIMM *pActiveIMM;

    if (lpfdwConversion != NULL)
    {
        *lpfdwConversion = 0;
    }
    if (lpfdwSentence != NULL)
    {
        *lpfdwSentence = 0;
    }
    if (lpfdwConversion == NULL || lpfdwSentence == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
    }

    return Imm32_GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence);
}

//+---------------------------------------------------------------------------
//
// SetConversionStatus
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetConversionStatus(hIMC, fdwConversion, fdwSentence);
    }

    return Imm32_SetConversionStatus(hIMC, fdwConversion, fdwSentence);
}

//+---------------------------------------------------------------------------
//
// GetStatusWindowPos
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
{
    CActiveIMM *pActiveIMM;

    if (lpptPos == NULL)
        return E_INVALIDARG;

    memset(lpptPos, 0, sizeof(POINT));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetStatusWindowPos(hIMC, lpptPos);
    }

    return Imm32_GetStatusWindowPos(hIMC, lpptPos);
}

//+---------------------------------------------------------------------------
//
// SetStatusWindowPos
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
{
    CActiveIMM *pActiveIMM;

    if (lpptPos == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetStatusWindowPos(hIMC, lpptPos);
    }

    return Imm32_SetStatusWindowPos(hIMC, lpptPos);
}

//+---------------------------------------------------------------------------
//
// GetCompositionStringA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
{
    CActiveIMM *pActiveIMM;

    if (plCopied == NULL)
        return E_INVALIDARG;

    *plCopied = 0;

    if (dwBufLen > 0 && lpBuf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionStringA(hIMC, dwIndex, dwBufLen, plCopied, lpBuf);
    }

    return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionStringW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf)
{
    CActiveIMM *pActiveIMM;

    if (plCopied == NULL)
        return E_INVALIDARG;

    *plCopied = 0;

    if (dwBufLen > 0 && lpBuf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionStringW(hIMC, dwIndex, dwBufLen, plCopied, lpBuf);
    }

    return Imm32_GetCompositionString(hIMC, dwIndex, dwBufLen, plCopied, lpBuf, TRUE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionStringA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
    CActiveIMM *pActiveIMM;

    if ((dwIndex & (SCS_SETSTR | SCS_CHANGEATTR | SCS_CHANGECLAUSE | SCS_SETRECONVERTSTRING | SCS_QUERYRECONVERTSTRING)) == 0)
        return E_INVALIDARG;

    if (lpComp == NULL && lpRead == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionStringA(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
    }

    return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, FALSE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionStringW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
    CActiveIMM *pActiveIMM;

    if ((dwIndex & (SCS_SETSTR | SCS_CHANGEATTR | SCS_CHANGECLAUSE | SCS_SETRECONVERTSTRING | SCS_QUERYRECONVERTSTRING)) == 0)
        return E_INVALIDARG;

    if (lpComp == NULL && lpRead == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionStringW(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
    }

    return Imm32_SetCompositionString(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionFontA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    memset(lplf, 0, sizeof(LOGFONTA));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionFontA(hIMC, lplf);
    }

    return Imm32_GetCompositionFont(hIMC, (LOGFONTAW *)lplf, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionFontW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    memset(lplf, 0, sizeof(LOGFONTW));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionFontW(hIMC, lplf);
    }

    return Imm32_GetCompositionFont(hIMC, (LOGFONTAW *)lplf, TRUE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionFontA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionFontA(hIMC, lplf);
    }

    return Imm32_SetCompositionFont(hIMC, (LOGFONTAW *)lplf, FALSE);
}

//+---------------------------------------------------------------------------
//
// SetCompositionFontW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf)
{
    CActiveIMM *pActiveIMM;

    if (lplf == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionFontW(hIMC, lplf);
    }

    return Imm32_SetCompositionFont(hIMC, (LOGFONTAW *)lplf, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCompositionWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
{
    CActiveIMM *pActiveIMM;

    if (lpCompForm == NULL)
        return E_INVALIDARG;

    memset(lpCompForm, 0, sizeof(COMPOSITIONFORM));

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCompositionWindow(hIMC, lpCompForm);
    }

    return Imm32_GetCompositionWindow(hIMC, lpCompForm);
}

//+---------------------------------------------------------------------------
//
// SetCompositionWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm)
{
    CActiveIMM *pActiveIMM;

    if (lpCompForm == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCompositionWindow(hIMC, lpCompForm);
    }

    return Imm32_SetCompositionWindow(hIMC, lpCompForm);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }
    if (uBufLen > 0 && lpCandList != NULL)
    {
        memset(lpCandList, 0, uBufLen);
    }

    if (puCopied == NULL)
        return E_INVALIDARG;
    if (uBufLen > 0 && lpCandList == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListA(hIMC, dwIndex, uBufLen, lpCandList, puCopied);
    }

    return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }
    if (uBufLen > 0 && lpCandList != NULL)
    {
        memset(lpCandList, 0, uBufLen);
    }

    if (puCopied == NULL)
        return E_INVALIDARG;
    if (uBufLen > 0 && lpCandList == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListW(hIMC, dwIndex, uBufLen, lpCandList, puCopied);
    }

    return Imm32_GetCandidateList(hIMC, dwIndex, uBufLen, lpCandList, puCopied, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListCountA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
{
    CActiveIMM *pActiveIMM;

    if (lpdwListSize != NULL)
    {
        *lpdwListSize = 0;
    }
    if (pdwBufLen != NULL)
    {
        *pdwBufLen = 0;
    }
    if (lpdwListSize == NULL || pdwBufLen == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListCountA(hIMC, lpdwListSize, pdwBufLen);
    }

    return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateListCountW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen)
{
    CActiveIMM *pActiveIMM;

    if (lpdwListSize != NULL)
    {
        *lpdwListSize = 0;
    }
    if (pdwBufLen != NULL)
    {
        *pdwBufLen = 0;
    }
    if (lpdwListSize == NULL || pdwBufLen == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateListCountW(hIMC, lpdwListSize, pdwBufLen);
    }

    return Imm32_GetCandidateListCount(hIMC, lpdwListSize, pdwBufLen, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetCandidateWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetCandidateWindow(HIMC hIMC, DWORD dwBufLen, CANDIDATEFORM *lpCandidate)
{
    CActiveIMM *pActiveIMM;

    if (lpCandidate == NULL)
        return E_INVALIDARG;

    memset(lpCandidate, 0, dwBufLen);

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetCandidateWindow(hIMC, dwBufLen, lpCandidate);
    }

    return Imm32_GetCandidateWindow(hIMC, dwBufLen, lpCandidate);
}

//+---------------------------------------------------------------------------
//
// SetCandidateWindow
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate)
{
    CActiveIMM *pActiveIMM;

    if (lpCandidate == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetCandidateWindow(hIMC, lpCandidate);
    }

    return Imm32_SetCandidateWindow(hIMC, lpCandidate);
}

//+---------------------------------------------------------------------------
//
// GetGuideLineA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetGuideLineA(hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
    }

    return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetGuideLineW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetGuideLineW(hIMC, dwIndex, dwBufLen, pBuf, pdwResult);
    }

    return Imm32_GetGuideLine(hIMC, dwIndex, dwBufLen, (CHARAW *)pBuf, pdwResult, TRUE);
}

//+---------------------------------------------------------------------------
//
// NotifyIME
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->NotifyIME(hIMC, dwAction, dwIndex, dwValue);
    }

    return Imm32_NotifyIME(hIMC, dwAction, dwIndex, dwValue);
}

//+---------------------------------------------------------------------------
//
// GetImeMenuItemsA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetImeMenuItemsA(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
    }

    return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, FALSE);
}

//+---------------------------------------------------------------------------
//
// GetImeMenuItemsW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetImeMenuItemsW(hIMC, dwFlags, dwType, pImeParentMenu, pImeMenu, dwSize, pdwResult);
    }

    return Imm32_GetImeMenuItems(hIMC, dwFlags, dwType, (IMEMENUITEMINFOAW *)pImeParentMenu, (IMEMENUITEMINFOAW *)pImeMenu, dwSize, pdwResult, TRUE);
}

//+---------------------------------------------------------------------------
//
// RegisterWordA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RegisterWordA(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return Imm32_RegisterWordA(hKL, lpszReading, dwStyle, lpszRegister);
}

//+---------------------------------------------------------------------------
//
// RegisterWordW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RegisterWordW(hKL, lpszReading, dwStyle, lpszRegister);
    }

    return Imm32_RegisterWordW(hKL, lpszReading, dwStyle, lpszRegister);
}

//+---------------------------------------------------------------------------
//
// UnregisterWordA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return Imm32_UnregisterWordA(hKL, lpszReading, dwStyle, lpszUnregister);
}

//+---------------------------------------------------------------------------
//
// UnregisterWordW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->UnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister);
    }

    return Imm32_UnregisterWordW(hKL, lpszReading, dwStyle, lpszUnregister);
}

//+---------------------------------------------------------------------------
//
// EnumRegisterWordA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **ppEnum)
{
    if (ppEnum != NULL)
    {
        *ppEnum = NULL;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EnumRegisterWordA(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
    }

    return Imm32_EnumRegisterWordA(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
}

//+---------------------------------------------------------------------------
//
// EnumRegisterWordW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **ppEnum)
{
    if (ppEnum != NULL)
    {
        *ppEnum = NULL;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EnumRegisterWordW(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
    }

    return Imm32_EnumRegisterWordW(hKL, szReading, dwStyle, szRegister, lpData, ppEnum);
}

//+---------------------------------------------------------------------------
//
// GetRegisterWordStyleA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied)
{
    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetRegisterWordStyleA(hKL, nItem, lpStyleBuf, puCopied);
    }

    return Imm32_GetRegisterWordStyleA(hKL, nItem, lpStyleBuf, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetRegisterWordStyleW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied)
{
    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetRegisterWordStyleW(hKL, nItem, lpStyleBuf, puCopied);
    }

    return Imm32_GetRegisterWordStyleW(hKL, nItem, lpStyleBuf, puCopied);
}

//+---------------------------------------------------------------------------
//
// ConfigureIMEA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->ConfigureIMEA(hKL, hWnd, dwMode, lpdata);
    }

    return Imm32_ConfigureIMEA(hKL, hWnd, dwMode, lpdata);
}

//+---------------------------------------------------------------------------
//
// ConfigureIMEW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->ConfigureIMEW(hKL, hWnd, dwMode, lpdata);
    }

    return Imm32_ConfigureIMEW(hKL, hWnd, dwMode, lpdata);
}

//+---------------------------------------------------------------------------
//
// GetDescriptionA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetDescriptionA(hKL, uBufLen, lpszDescription, puCopied);
    }

    return GetDescriptionA(hKL, uBufLen, lpszDescription, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetDescriptionW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetDescriptionW(hKL, uBufLen, lpszDescription, puCopied);
    }

    return Imm32_GetDescriptionW(hKL, uBufLen, lpszDescription, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetIMEFileNameA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMEFileNameA(hKL, uBufLen, lpszFileName, puCopied);
    }

    return Imm32_GetIMEFileNameA(hKL, uBufLen, lpszFileName, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetIMEFileNameW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetIMEFileNameW(hKL, uBufLen, lpszFileName, puCopied);
    }

    return Imm32_GetIMEFileNameW(hKL, uBufLen, lpszFileName, puCopied);
}

//+---------------------------------------------------------------------------
//
// InstallIMEA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->InstallIMEA(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return Imm32_InstallIMEA(lpszIMEFileName, lpszLayoutText, phKL);
}

//+---------------------------------------------------------------------------
//
// InstallIMEW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL)
{
    CActiveIMM *pActiveIMM;

    // consider: check params

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->InstallIMEW(lpszIMEFileName, lpszLayoutText, phKL);
    }

    return Imm32_InstallIMEW(lpszIMEFileName, lpszLayoutText, phKL);
}

//+---------------------------------------------------------------------------
//
// GetProperty
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty)
{
    CActiveIMM *pActiveIMM;

    if (pdwProperty == NULL)
        return E_INVALIDARG;

    *pdwProperty = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetProperty(hKL, fdwIndex, pdwProperty);
    }

    return Imm32_GetProperty(hKL, fdwIndex, pdwProperty);
}

//+---------------------------------------------------------------------------
//
// IsIME
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::IsIME(HKL hKL)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->IsIME(hKL);
    }

    return Imm32_IsIME(hKL);
}

//+---------------------------------------------------------------------------
//
// EscapeA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EscapeA(hKL, hIMC, uEscape, lpData, plResult);
    }

    return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, FALSE);
}

//+---------------------------------------------------------------------------
//
// EscapeW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EscapeW(hKL, hIMC, uEscape, lpData, plResult);
    }

    return Imm32_Escape(hKL, hIMC, uEscape, lpData, plResult, TRUE);
}

//+---------------------------------------------------------------------------
//
// GetConversionListA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return Imm32_GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetConversionListW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied)
{
    CActiveIMM *pActiveIMM;

    if (puCopied != NULL)
    {
        *puCopied = 0;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetConversionListW(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
    }

    return Imm32_GetConversionListW(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, puCopied);
}

//+---------------------------------------------------------------------------
//
// GetDefaultIMEWnd
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd)
{
    CActiveIMM *pActiveIMM;

    if (phDefWnd == NULL)
        return E_INVALIDARG;

    *phDefWnd = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetDefaultIMEWnd(hWnd, phDefWnd);
    }

    return Imm32_GetDefaultIMEWnd(hWnd, phDefWnd);
}

//+---------------------------------------------------------------------------
//
// GetVirtualKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetVirtualKey(HWND hWnd, UINT *puVirtualKey)
{
    CActiveIMM *pActiveIMM;

    if (puVirtualKey == NULL)
        return E_INVALIDARG;

    *puVirtualKey = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetVirtualKey(hWnd, puVirtualKey);
    }

    return Imm32_GetVirtualKey(hWnd, puVirtualKey);
}

//+---------------------------------------------------------------------------
//
// IsUIMessageA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->IsUIMessageA(hWndIME, msg, wParam, lParam);
    }

    return Imm32_IsUIMessageA(hWndIME, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// IsUIMessageW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->IsUIMessageW(hWndIME, msg, wParam, lParam);
    }

    return Imm32_IsUIMessageW(hWndIME, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// GenerateMessage
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GenerateMessage(HIMC hIMC)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GenerateMessage(hIMC);
    }

    return Imm32_GenerateMessage(hIMC);
}

//+---------------------------------------------------------------------------
//
// GetHotKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL)
{
    CActiveIMM *pActiveIMM;

    if (puModifiers != NULL)
    {
        *puModifiers = 0;
    }
    if (puVKey != NULL)
    {
        *puVKey = 0;
    }
    if (phKL != NULL)
    {
        *phKL = 0;
    }
    if (puModifiers == NULL || puVKey == NULL || phKL == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL);
    }

    return Imm32_GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL);
}

//+---------------------------------------------------------------------------
//
// SetHotKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SetHotKey(dwHotKeyID, uModifiers, uVKey, hKL);
    }

    return Imm32_SetHotKey(dwHotKeyID, uModifiers, uVKey, hKL);
}

//+---------------------------------------------------------------------------
//
// SimulateHotKey
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SimulateHotKey(HWND hWnd, DWORD dwHotKeyID)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->SimulateHotKey(hWnd, dwHotKeyID);
    }

    return Imm32_SimulateHotKey(hWnd, dwHotKeyID);
}

//+---------------------------------------------------------------------------
//
// CreateSoftKeyboard
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd)
{
    if (phSoftKbdWnd != NULL)
    {
        *phSoftKbdWnd = 0;
    }
        
    return Imm32_CreateSoftKeyboard(uType, hOwner, x, y, phSoftKbdWnd);
}

//+---------------------------------------------------------------------------
//
// DestroySoftKeyboard
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DestroySoftKeyboard(HWND hSoftKbdWnd)
{
    return Imm32_DestroySoftKeyboard(hSoftKbdWnd);
}

//+---------------------------------------------------------------------------
//
// ShowSoftKeyboard
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow)
{
    return Imm32_ShowSoftKeyboard(hSoftKbdWnd, nCmdShow);
}

//+---------------------------------------------------------------------------
//
// DisableIME
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::DisableIME(DWORD idThread)
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->DisableIME(idThread);
    }

    return Imm32_DisableIME(idThread);
}

//+---------------------------------------------------------------------------
//
// RequestMessageA
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RequestMessageA(hIMC, wParam, lParam, plResult);
    }

    return Imm32_RequestMessageA(hIMC, wParam, lParam, plResult);
}

//+---------------------------------------------------------------------------
//
// RequestMessageW
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->RequestMessageW(hIMC, wParam, lParam, plResult);
    }

    return Imm32_RequestMessageW(hIMC, wParam, lParam, plResult);
}

//+---------------------------------------------------------------------------
//
// EnumInputContext
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum)
{
    CActiveIMM *pActiveIMM;

    if (ppEnum != NULL)
    {
        *ppEnum = NULL;
    }

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->EnumInputContext(idThread, ppEnum);
    }

    Assert(0);
    return E_NOTIMPL; // consider: need code to wrap up HIMC's into enumerator
}

//+---------------------------------------------------------------------------
//
// Activate
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Activate(BOOL fRestoreLayout)
{
    PENDINGFILTER        *pPending;
    PENDINGFILTERGUIDMAP *pPendingGuidMap;
    PENDINGFILTEREX      *pPendingEx;
    IMTLS *ptls;
    CActiveIMM *pActiveIMM;
    HRESULT hr;
    BOOL fInitedTLS = FALSE;

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    // init the tls
    if ((pActiveIMM = ptls->pActiveIMM) == NULL)
    {
        if ((pActiveIMM = new CActiveIMM) == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(hr=pActiveIMM->_Init()) ||
            FAILED(hr=IMTLS_SetActiveIMM(pActiveIMM) ? S_OK : E_FAIL))
        {
            delete pActiveIMM;
            return hr;
        }

        fInitedTLS = TRUE;

        // handle any calls to FilterClientWindows that preceded the activate call
        // consider: is it safe to limit filter list to per-thread?  Shouldn't this be per-process
        // to make trident happy?
        while (ptls->pPendingFilterClientWindows != NULL)
        {               
            ptls->pActiveIMM->FilterClientWindows(ptls->pPendingFilterClientWindows->rgAtoms, ptls->pPendingFilterClientWindows->uSize, ptls->pPendingFilterClientWindowsGuidMap->rgGuidMap);

            pPending = ptls->pPendingFilterClientWindows->pNext;
            cicMemFree(ptls->pPendingFilterClientWindows);
            ptls->pPendingFilterClientWindows = pPending;

            pPendingGuidMap = ptls->pPendingFilterClientWindowsGuidMap->pNext;
            cicMemFree(ptls->pPendingFilterClientWindowsGuidMap);
            ptls->pPendingFilterClientWindowsGuidMap = pPendingGuidMap;
        }
        while (ptls->pPendingFilterClientWindowsEx != NULL)
        {
            ptls->pActiveIMM->FilterClientWindowsEx(ptls->pPendingFilterClientWindowsEx->hWnd,
                                                    ptls->pPendingFilterClientWindowsEx->fGuidMap);

            pPendingEx = ptls->pPendingFilterClientWindowsEx->pNext;
            cicMemFree(ptls->pPendingFilterClientWindowsEx);
            ptls->pPendingFilterClientWindowsEx = pPendingEx;
        }
    }

    hr = pActiveIMM->Activate(fRestoreLayout);

    if (fInitedTLS)
    {
        // the first Activate call on this thread will do an internal AddRef
        // on success, so we must release
        pActiveIMM->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Deactivate
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::Deactivate()
{
    CActiveIMM *pActiveIMM;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->Deactivate();
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// OnDefWindowProc
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    CActiveIMM *pActiveIMM;

    if (plResult == NULL)
        return E_INVALIDARG;

    *plResult = 0;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->OnDefWindowProc(hWnd, Msg, wParam, lParam, plResult);
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
// FilterClientWindows
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::FilterClientWindows(ATOM *aaWindowClasses, UINT uSize)
{
    return FilterClientWindowsGUIDMap(aaWindowClasses, uSize, NULL);
}

STDAPI CProcessIMM::FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap)
{
    IMTLS *ptls;
    PENDINGFILTER *pPending;
    PENDINGFILTERGUIDMAP *pPendingGuidMap;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->FilterClientWindows(aaWindowClasses, uSize, aaGuidMap);
    }

    // Activate hasn't been called yet on this thread
    // need to handle the call later
    
    pPending = (PENDINGFILTER *)cicMemAlloc(sizeof(PENDINGFILTER)+uSize*sizeof(ATOM)-sizeof(ATOM));
    if (pPending == NULL)
        return E_OUTOFMEMORY;

    pPendingGuidMap = (PENDINGFILTERGUIDMAP *)cicMemAlloc(sizeof(PENDINGFILTERGUIDMAP)+uSize*sizeof(BOOL)-sizeof(BOOL));
    if (pPendingGuidMap == NULL) {
        cicMemFree(pPending);
        return E_OUTOFMEMORY;
    }

    pPending->uSize = uSize;
    memcpy(pPending->rgAtoms, aaWindowClasses, uSize*sizeof(ATOM));

    pPendingGuidMap->uSize = uSize;
    if (aaGuidMap) {
        memcpy(pPendingGuidMap->rgGuidMap, aaGuidMap, uSize*sizeof(BOOL));
    }
    else {
        memset(pPendingGuidMap->rgGuidMap, FALSE, uSize*sizeof(BOOL));
    }

    pPending->pNext = ptls->pPendingFilterClientWindows;
    ptls->pPendingFilterClientWindows = pPending;

    pPendingGuidMap->pNext = ptls->pPendingFilterClientWindowsGuidMap;
    ptls->pPendingFilterClientWindowsGuidMap = pPendingGuidMap;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// FilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap)
{
    IMTLS *ptls;
    PENDINGFILTEREX *pPending;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->FilterClientWindowsEx(hWnd, fGuidMap);
    }

    // Activate hasn't been called yet on this thread
    // need to handle the call later
    
    pPending = (PENDINGFILTEREX *)cicMemAlloc(sizeof(PENDINGFILTEREX));

    if (pPending == NULL)
        return E_OUTOFMEMORY;

    pPending->hWnd = hWnd;
    pPending->fGuidMap = fGuidMap;

    pPending->pNext = ptls->pPendingFilterClientWindowsEx;
    ptls->pPendingFilterClientWindowsEx = pPending;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetGuidAtom
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom)
{
    IMTLS *ptls;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->GetGuidAtom(hImc, bAttr, pGuidAtom);
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// UnfilterClientWindowsEx
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::UnfilterClientWindowsEx(HWND hWnd)
{
    IMTLS *ptls;
    
    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    if (ptls->pActiveIMM != NULL)
    {
        return ptls->pActiveIMM->UnfilterClientWindowsEx(hWnd);
    }

    // Activate hasn't been called yet on this thread
    // need to remove a handle from the waiting list
    
    PENDINGFILTEREX *current = ptls->pPendingFilterClientWindowsEx;
    PENDINGFILTEREX *previous = NULL;

    while (current != NULL)
    {
        if (current->hWnd == hWnd)
        {
            PENDINGFILTEREX *pv;
            pv = current->pNext;
            cicMemFree(current);

            if (previous == NULL)
                ptls->pPendingFilterClientWindowsEx = pv;
            else
                previous->pNext = pv;

            current  = pv;
        }
        else
        {
            previous = current;
            current  = current->pNext;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetCodePageA
//
//----------------------------------------------------------------------------

extern UINT GetCodePageFromLangId(LCID lcid);

STDAPI CProcessIMM::GetCodePageA(HKL hKL, UINT *puCodePage)

/*++

Method:

    IActiveIMMApp::GetCodePageA
    IActiveIMMIME::GetCodePageA

Routine Description:

    Retrieves the code page associated with the given keyboard layout.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    puCodePage - [out] Address of an unsigned integer that receives the code page
                       identifier associated with the keyboard.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    if (puCodePage == NULL)
        return E_INVALIDARG;

    *puCodePage = CP_ACP;

    TraceMsg(TF_API, "CProcessIMM::GetCodePageA");

    if (_IsValidKeyboardLayout(hKL)) {
        *puCodePage = ::GetCodePageFromLangId(LOWORD(hKL));
        return S_OK;
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetLangId
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetLangId(HKL hKL, LANGID *plid)

/*++

Method:

    IActiveIMMApp::GetLangId
    IActiveIMMIME::GetLangId

Routine Description:

    Retrieves the language identifier associated with the given keyboard layout.

Arguments:

    hKL - [in] Handle to the keyboard layout.
    plid - [out] Address of the LANGID associated with the keyboard layout.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    if (plid == NULL)
        return E_INVALIDARG;

    *plid = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    TraceMsg(TF_API, "CProcessIMM::GetLangId");

    if (_IsValidKeyboardLayout(hKL)) {
        *plid = LOWORD(hKL);
        return S_OK;
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// QueryService
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    CActiveIMM *pActiveIMM;

    if (ppv == NULL)
        return E_INVALIDARG;

    *ppv = NULL;

    if (pActiveIMM = GetTLS())
    {
        return pActiveIMM->QueryService(guidService, riid, ppv);
    }

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// SetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
{
    CActiveIMM *pActiveIMM;

    if (pvar == NULL)
        return E_INVALIDARG;

    if (pActiveIMM = GetTLS())
        return pActiveIMM->SetThreadCompartmentValue(rguid, pvar);

    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// GetThreadCompartmentValue
//
//----------------------------------------------------------------------------

STDAPI CProcessIMM::GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar)
{
    CActiveIMM *pActiveIMM;

    if (pvar == NULL)
        return E_INVALIDARG;

    QuickVariantInit(pvar);

    if (pActiveIMM = GetTLS())
        return pActiveIMM->GetThreadCompartmentValue(rguid, pvar);

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\immime.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       immime.cpp
//
//  Contents:   IActiveIMM methods with ime win32 mappings.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "defs.h"

STDAPI
CActiveIMM::GenerateMessage(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMIME::GenerateMessage

Routine Description:

    Sends a message on the specified input context.

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    TraceMsg(TF_IMEAPI, "CActiveIMM::GenerateMessage");

    if (_IsRealIme())
    {
        return Imm32_GenerateMessage(hIMC);
    }

    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr=lpIMC.GetResult()))
        return hr;

    Assert(IsWindow(lpIMC->hWnd));

    DIMM_IMCCLock<TRANSMSG> pdw(lpIMC->hMsgBuf);
    if (FAILED(hr=pdw.GetResult()))
        return hr;

    _AimmSendMessage(lpIMC->hWnd,
                    lpIMC->dwNumMsgBuf,
                    pdw,
                    lpIMC);

    lpIMC->dwNumMsgBuf = 0;

    return S_OK;
}

STDAPI
CActiveIMM::LockIMC(
    IN HIMC hIMC,
    OUT INPUTCONTEXT **ppIMC
    )

/*++

Method:

    IActiveIMMIME::LockIMC

Routine Description:

    Retrieves the INPUTCONTEXT structure and increases the lock count for the input context.

Arguments:

    hIMC - [in] Handle to the input context to lock.
    pphIMCC - [out] Address of a pointer to an INPUTCONTEXT structure containing
                    the locked context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    DIMM_IMCLock lpIMC(hIMC);
    if (FAILED(hr=lpIMC.GetResult()))
        return hr;

    hr = _InputContext._LockIMC(hIMC, (INPUTCONTEXT_AIMM12 **)ppIMC);
    return hr;
}


STDAPI
CActiveIMM::UnlockIMC(
    IN HIMC hIMC
    )

/*++

Method:

    IActiveIMMIME::UnlockIMC

Routine Description:

    Decreases the lock count for the input context.

Arguments:

    hIMC - [in] Handle to the input context to unlock.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext._UnlockIMC(hIMC);
}


STDAPI
CActiveIMM::GetIMCLockCount(
    IN HIMC hIMC,
    OUT DWORD *pdwLockCount
    )

/*++

Method:

    IActiveIMMIME::GetIMCLockCount

Routine Description:

    Retrieves the lock count of the input context.

Arguments:

    hIMC - [in] Handle to the input context to unlock.
    pdwLockCount - [out] Address of an unsigned long integer value that receives the lock count.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.GetIMCLockCount(hIMC, pdwLockCount);
}

STDAPI
CActiveIMM::CreateIMCC(
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )

/*++

Method:

    IActiveIMMIME::CreateIMCC

Routine Description:

    Creates a new input context component.

Arguments:

    dwSize - [in] Unsigned long interger value that contains the size of the new input
                  context component.
    phIMCC - [out] Address of a handle to the new input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.CreateIMCC(dwSize, phIMCC);
}


STDAPI
CActiveIMM::DestroyIMCC(
    IN HIMCC hIMCC
    )

/*++

Method:

    IActiveIMMIME::DestroyIMCC

Routine Description:

    Destroys an input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.DestroyIMCC(hIMCC);
}


STDAPI
CActiveIMM::LockIMCC(
    IN HIMCC hIMCC,
    OUT void **ppv
    )

/*++

Method:

    IActiveIMMIME::LockIMCC

Routine Description:

    Retrieves the address of the input context component and increases its lock count.

Arguments:

    hIMCC - [in] Handle to the input context component.
    ppv - [out] Address of a pointer to the buffer that receives the input context
                component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext._LockIMCC(hIMCC, ppv);
}


STDAPI
CActiveIMM::UnlockIMCC(
    IN HIMCC hIMCC
    )

/*++

Method:

    IActiveIMMIME::UnlockIMCC

Routine Description:

    Decreases the lock count for the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext._UnlockIMCC(hIMCC);
}


STDAPI
CActiveIMM::ReSizeIMCC(
    IN HIMCC hIMCC,
    IN DWORD dwSize,
    OUT HIMCC *phIMCC
    )

/*++

Method:

    IActiveIMMIME::ReSizeIMCC

Routine Description:

    Changes the size of the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.
    dwSize - [in] Unsigned long integer value that contains the new
                  size of the component.
    phIMCC - [out] Address of a handle to the new input context component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.ReSizeIMCC(hIMCC, dwSize, phIMCC);
}


STDAPI
CActiveIMM::GetIMCCSize(
    IN HIMCC hIMCC,
    OUT DWORD *pdwSize
    )

/*++

Method:

    IActiveIMMIME::GetIMCCSize

Routine Description:

    Retrieves the size of the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.
    pdwSize - [out] Address of an unsigned long integer value that receives the
                    size of the component.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.GetIMCCSize(hIMCC, pdwSize);
}


STDAPI
CActiveIMM::GetIMCCLockCount(
    IN HIMCC hIMCC,
    OUT DWORD *pdwLockCount
    )

/*++

Method:

    IActiveIMMIME::GetIMCCLockCount

Routine Description:

    Retrieves the lock count for the input context component.

Arguments:

    hIMCC - [in] Handle to the input context component.
    pdwLockCount - [out] Address of an unsigned long integer value that receives the
                         lock count.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return _InputContext.GetIMCCLockCount(hIMCC, pdwLockCount);
}

STDAPI
CActiveIMM::GetHotKey(
    DWORD dwHotKeyID,
    UINT *puModifiers,
    UINT *puVKey,
    HKL *phKL
    )
{
    TraceMsg(TF_API, "CActiveIMM::GetHotKey");

    if (_IsRealIme())
    {
        return Imm32_GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::SetHotKey(
    DWORD dwHotKeyID,
    UINT uModifiers,
    UINT uVKey,
    HKL hKL
    )
{
    TraceMsg(TF_API, "CActiveIMM::SetHotKey");

    if (_IsRealIme())
    {
        return Imm32_SetHotKey(dwHotKeyID, uModifiers, uVKey, hKL);
    }

    return E_NOTIMPL;
}

STDAPI
CActiveIMM::RequestMessageA(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    TraceMsg(TF_API, "CActiveIMM::RequestMessageA");

    if (_IsRealIme())
    {
        return Imm32_RequestMessageA(hIMC, wParam, lParam, plResult);
    }

    return _RequestMessage(hIMC, wParam, lParam, plResult, FALSE);
}

STDAPI
CActiveIMM::RequestMessageW(
    HIMC hIMC,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult
    )
{
    TraceMsg(TF_API, "CActiveIMM::RequestMessageW");

    if (_IsRealIme())
    {
        return Imm32_RequestMessageW(hIMC, wParam, lParam, plResult);
    }

    return _RequestMessage(hIMC, wParam, lParam, plResult, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\list.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    list.h

Abstract:

    This file defines the CFilterList Class.

Author:

Revision History:

Notes:

--*/


#ifndef LIST_H
#define LIST_H

#include "template.h"
#include "cstring.h"

/////////////////////////////////////////////////////////////////////////////
// CParserTypeOfHwnd

struct CParserTypeOfHwnd {
    typedef enum {
        HWND_UNKNOWN = 0,
        HWND_CURRENT,
        HWND_PARENT
    } TYPE_OF_HWND;

    CParserTypeOfHwnd ()
    {
        m_type = HWND_UNKNOWN;
    }

    BOOL Parser(CString& str)
    {
        if (str.CompareNoCase(TEXT("current")) == 0) {
            m_type = HWND_CURRENT;
            return TRUE;
        }
        else if (str.CompareNoCase(TEXT("parent")) == 0) {
            m_type = HWND_PARENT;
            return TRUE;
        }
        return FALSE;
    }

    TYPE_OF_HWND  m_type;
};

/////////////////////////////////////////////////////////////////////////////
// CParserTypeOfPresent

struct CParserTypeOfPresent {
    typedef enum {
        UNKNOWN_PRESENT = 0,
        NOT_PRESENT_LIST,
        PRESENT_LIST
    } TYPE_OF_PRESENT;

    CParserTypeOfPresent()
    {
        m_type = UNKNOWN_PRESENT;
    }

    BOOL Parser(CString& str)
    {
        if (str.CompareNoCase(TEXT("present")) == 0) {
            m_type = PRESENT_LIST;
            return TRUE;
        }
        else if (str.CompareNoCase(TEXT("notpresent")) == 0) {
            m_type = NOT_PRESENT_LIST;
            return TRUE;
        }
        return FALSE;
    }

    TYPE_OF_PRESENT m_type;
};

/////////////////////////////////////////////////////////////////////////////
// CFilterList

class CFilterList
{
public:
    CFilterList();
    ~CFilterList() { }

    HRESULT _Update(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);
    BOOL _IsPresent(HWND hWnd, CMap<HWND, HWND, ITfDocumentMgr *, ITfDocumentMgr *> &mapWndFocus, BOOL fExcludeAIMM, ITfDocumentMgr *dimAssoc);

    BOOL _IsGuidMapEnable(HWND hWnd, BOOL& fGuidMap);

    BOOL IsExceptionPresent(HWND hWnd);

private:
    typedef struct {
        BOOL fFilter : 1;
        BOOL fGuidMap : 1;
    } FILTER_CLIENT;

    CMap<ATOM,                     // class KEY
         ATOM,                     // class ARG_KEY
         FILTER_CLIENT,            // class VALUE
         FILTER_CLIENT             // class ARG_VALUE
        > m_FilterList;

    CMapStringToOb<
         CParserTypeOfHwnd,        // class VALUE
         CParserTypeOfHwnd         // class ARG_VALUE
        > m_NotPresentList;
    CMapStringToOb<
         CParserTypeOfHwnd,        // class VALUE
         CParserTypeOfHwnd         // class ARG_VALUE
        > m_PresentList;
};

#endif // LIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\pimm.h ===
//+---------------------------------------------------------------------------
//
//  File:       pimm.h
//
//  Contents:   CProcessIMM
//
//----------------------------------------------------------------------------

#ifndef PIMM_H
#define PIMM_H

#include "private.h"
#include "list.h"

//+---------------------------------------------------------------------------
//
// CProcessIMM
//
//----------------------------------------------------------------------------

class CProcessIMM : public IActiveIMMAppEx,
                    public IActiveIMMMessagePumpOwner,
                    public IAImmThreadCompartment,
                    public IServiceProvider
{
public:
    CProcessIMM() {}

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IActiveIMMMessagePumpOwner
    //
    STDMETHODIMP Start();
    STDMETHODIMP End();
    STDMETHODIMP OnTranslateMessage(const MSG *pMsg);
    STDMETHODIMP Pause(DWORD *pdwCookie);
    STDMETHODIMP Resume(DWORD dwCookie);

    //
    // IActiveIMMApp/IActiveIMM methods
    //

    /*
     * AIMM Input Context (hIMC) Methods.
     */
    STDMETHODIMP CreateContext(HIMC *phIMC);
    STDMETHODIMP DestroyContext(HIMC hIME);
    STDMETHODIMP AssociateContext(HWND hWnd, HIMC hIME, HIMC *phPrev);
    STDMETHODIMP AssociateContextEx(HWND hWnd, HIMC hIMC, DWORD dwFlags);
    STDMETHODIMP GetContext(HWND hWnd, HIMC *phIMC);
    STDMETHODIMP ReleaseContext(HWND hWnd, HIMC hIMC);
    STDMETHODIMP GetIMCLockCount(HIMC hIMC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMC(HIMC hIMC, INPUTCONTEXT **ppIMC);
    STDMETHODIMP UnlockIMC(HIMC hIMC);

    /*
     * AIMM Input Context Components (hIMCC) API Methods.
     */
    STDMETHODIMP CreateIMCC(DWORD dwSize, HIMCC *phIMCC);
    STDMETHODIMP DestroyIMCC(HIMCC hIMCC);
    STDMETHODIMP GetIMCCSize(HIMCC hIMCC, DWORD *pdwSize);
    STDMETHODIMP ReSizeIMCC(HIMCC hIMCC, DWORD dwSize, HIMCC *phIMCC);
    STDMETHODIMP GetIMCCLockCount(HIMCC hIMCC, DWORD *pdwLockCount);
    STDMETHODIMP LockIMCC(HIMCC hIMCC, void **ppv);
    STDMETHODIMP UnlockIMCC(HIMCC hIMCC);

    /*
     * AIMM Open Status API Methods
     */
    STDMETHODIMP GetOpenStatus(HIMC hIMC);
    STDMETHODIMP SetOpenStatus(HIMC hIMC, BOOL fOpen);

    /*
     * AIMM Conversion Status API Methods
     */
    STDMETHODIMP GetConversionStatus(HIMC hIMC, DWORD *lpfdwConversion, DWORD *lpfdwSentence);
    STDMETHODIMP SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence);

    /*
     * AIMM Status Window Pos API Methods
     */
    STDMETHODIMP GetStatusWindowPos(HIMC hIMC, POINT *lpptPos);
    STDMETHODIMP SetStatusWindowPos(HIMC hIMC, POINT *lpptPos);

    /*
     * AIMM Composition String API Methods
     */
    STDMETHODIMP GetCompositionStringA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP GetCompositionStringW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LONG *plCopied, LPVOID lpBuf);
    STDMETHODIMP SetCompositionStringA(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
    STDMETHODIMP SetCompositionStringW(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);

    /*
     * AIMM Composition Font API Methods
     */
    STDMETHODIMP GetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP GetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);
    STDMETHODIMP SetCompositionFontA(HIMC hIMC, LOGFONTA *lplf);
    STDMETHODIMP SetCompositionFontW(HIMC hIMC, LOGFONTW *lplf);

    /*
     * AIMM Composition Window API Methods
     */
    STDMETHODIMP GetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);
    STDMETHODIMP SetCompositionWindow(HIMC hIMC, COMPOSITIONFORM *lpCompForm);

    /*
     * AIMM Candidate List API Methods
     */
    STDMETHODIMP GetCandidateListA(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListW(HIMC hIMC, DWORD dwIndex, UINT uBufLen, CANDIDATELIST *lpCandList, UINT *puCopied);
    STDMETHODIMP GetCandidateListCountA(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);
    STDMETHODIMP GetCandidateListCountW(HIMC hIMC, DWORD *lpdwListSize, DWORD *pdwBufLen);

    /*
     * AIMM Candidate Window API Methods
     */
    STDMETHODIMP GetCandidateWindow(HIMC hIMC, DWORD dwBufLen, CANDIDATEFORM *lpCandidate);
    STDMETHODIMP SetCandidateWindow(HIMC hIMC, CANDIDATEFORM *lpCandidate);

    /*
     * AIMM Guide Line API Methods
     */
    STDMETHODIMP GetGuideLineA(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPSTR pBuf, DWORD *pdwResult);
    STDMETHODIMP GetGuideLineW(HIMC hIMC, DWORD dwIndex, DWORD dwBufLen, LPWSTR pBuf, DWORD *pdwResult);

    /*
     * AIMM Notify IME API Method
     */
    STDMETHODIMP NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    /*
     * AIMM Menu Items API Methods
     */
    STDMETHODIMP GetImeMenuItemsA(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOA *pImeParentMenu, IMEMENUITEMINFOA *pImeMenu, DWORD dwSize, DWORD *pdwResult);
    STDMETHODIMP GetImeMenuItemsW(HIMC hIMC, DWORD dwFlags, DWORD dwType, IMEMENUITEMINFOW *pImeParentMenu, IMEMENUITEMINFOW *pImeMenu, DWORD dwSize, DWORD *pdwResult);

    /*
     * AIMM Register Word API Methods
     */
    STDMETHODIMP RegisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszRegister);
    STDMETHODIMP RegisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszRegister);
    STDMETHODIMP UnregisterWordA(HKL hKL, LPSTR lpszReading, DWORD dwStyle, LPSTR lpszUnregister);
    STDMETHODIMP UnregisterWordW(HKL hKL, LPWSTR lpszReading, DWORD dwStyle, LPWSTR lpszUnregister);
    STDMETHODIMP EnumRegisterWordA(HKL hKL, LPSTR szReading, DWORD dwStyle, LPSTR szRegister, LPVOID lpData, IEnumRegisterWordA **pEnum);
    STDMETHODIMP EnumRegisterWordW(HKL hKL, LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID lpData, IEnumRegisterWordW **pEnum);
    STDMETHODIMP GetRegisterWordStyleA(HKL hKL, UINT nItem, STYLEBUFA *lpStyleBuf, UINT *puCopied);
    STDMETHODIMP GetRegisterWordStyleW(HKL hKL, UINT nItem, STYLEBUFW *lpStyleBuf, UINT *puCopied);

    /*
     * AIMM Configuration API Methods.
     */
    STDMETHODIMP ConfigureIMEA(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDA *lpdata);
    STDMETHODIMP ConfigureIMEW(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *lpdata);
    STDMETHODIMP GetDescriptionA(HKL hKL, UINT uBufLen, LPSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetDescriptionW(HKL hKL, UINT uBufLen, LPWSTR lpszDescription, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameA(HKL hKL, UINT uBufLen, LPSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP GetIMEFileNameW(HKL hKL, UINT uBufLen, LPWSTR lpszFileName, UINT *puCopied);
    STDMETHODIMP InstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP InstallIMEW(LPWSTR lpszIMEFileName, LPWSTR lpszLayoutText, HKL *phKL);
    STDMETHODIMP GetProperty(HKL hKL, DWORD fdwIndex, DWORD *pdwProperty);
    STDMETHODIMP IsIME(HKL hKL);

    // others
    STDMETHODIMP EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP EscapeW(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);
    STDMETHODIMP GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetConversionListW(HKL hKL, HIMC hIMC, LPWSTR lpSrc, UINT uBufLen, UINT uFlag, CANDIDATELIST *lpDst, UINT *puCopied);
    STDMETHODIMP GetDefaultIMEWnd(HWND hWnd, HWND *phDefWnd);
    STDMETHODIMP GetVirtualKey(HWND hWnd, UINT *puVirtualKey);
    STDMETHODIMP IsUIMessageA(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP IsUIMessageW(HWND hWndIME, UINT msg, WPARAM wParam, LPARAM lParam);

    // ime helper methods
    STDMETHODIMP GenerateMessage(HIMC hIMC);

    // hot key manipulation api's
    STDMETHODIMP GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL);
    STDMETHODIMP SetHotKey(DWORD dwHotKeyID,  UINT uModifiers, UINT uVKey, HKL hKL);
    STDMETHODIMP SimulateHotKey(HWND hWnd, DWORD dwHotKeyID);

    // soft keyboard api's
    STDMETHODIMP CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y, HWND *phSoftKbdWnd);
    STDMETHODIMP DestroySoftKeyboard(HWND hSoftKbdWnd);
    STDMETHODIMP ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow);

    // win98/nt5 apis
    STDMETHODIMP DisableIME(DWORD idThread);
    STDMETHODIMP RequestMessageA(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP RequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHODIMP EnumInputContext(DWORD idThread, IEnumInputContext **ppEnum);

    // methods without corresponding IMM APIs

    //
    // IActiveIMMApp methods
    //

    STDMETHODIMP Activate(BOOL fRestoreLayout);
    STDMETHODIMP Deactivate();

    STDMETHODIMP OnDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);

    //
    // FilterClientWindows
    //
    STDMETHODIMP FilterClientWindows(ATOM *aaWindowClasses, UINT uSize);

    //
    //
    //
    STDMETHODIMP GetCodePageA(HKL hKL, UINT *uCodePage);
    STDMETHODIMP GetLangId(HKL hKL, LANGID *plid);

    //
    // IServiceProvider
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    //
    // IActiveIMMAppEx
    //
    STDMETHODIMP FilterClientWindowsEx(HWND hWnd, BOOL fGuidMap);
    STDMETHODIMP FilterClientWindowsGUIDMap(ATOM *aaWindowClasses, UINT uSize, BOOL *aaGuidMap);

    STDMETHODIMP GetGuidAtom(HIMC hImc, BYTE bAttr, TfGuidAtom *pGuidAtom);

    STDMETHODIMP UnfilterClientWindowsEx(HWND hWnd);

    //
    // IAImmThreadCompartment,
    //
    STDMETHODIMP SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);
    STDMETHODIMP GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);


public:
    CFilterList                 _FilterList;


private:
    BOOL _IsValidKeyboardLayout(HKL hkl)
    {
        BOOL ret = FALSE;
        UINT uSize = ::GetKeyboardLayoutList(0, NULL);
        if (uSize) {
            HKL* pList = new HKL [uSize];
            if (pList) {
                uSize = ::GetKeyboardLayoutList(uSize, pList);

                for (UINT i = 0; i < uSize; i++) {
                    if (hkl == pList[i]) {
                        ret = TRUE;
                        break;
                    }
                }
                delete [] pList;
            }
        }
        return ret;
    }

private:
    static LONG _cRef;
};

#endif // PIMM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <ole2.h>
#include <debug.h>
#include <ocidl.h>

#include <tchar.h>
#include <limits.h>

// New NT5 header
#include "immdev.h"
#define _IMM_
#define _DDKIMM_H_

#include "dimm.h"

#include "msctf.h"
#include "ctffunc.h"
#include "osver.h"
#include "ccstock.h"
#include "immxutil.h"
#include "xstring.h"
#include "regsvr.h"

#define _DDKIMM_H_
#include "aimm12.h"
#include "aimmex.h"
#include "aimmp.h"
#include "msuimw32.h"
#include "imeutil.h"

#include "immdevaw.h"
#include "helpers.h"

//
// include private header
//
#include "winuserp.h"    // define WM_IME_SYSTEM
#define  NOGDI           // no include tagINPUTCONTEXT
#pragma warning(disable:4200)
#include "immp.h"        // define IMS_ACTIVATETHREADLAYOUT
#pragma warning(default:4200)

#include "mem.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\util.h ===
//+---------------------------------------------------------------------------
//
//  File:       util.h
//
//  Contents:   Generic helpers.
//
//----------------------------------------------------------------------------

#ifndef UTIL_H
#define UTIL_H

#define AA_INC 0
#define AA_DEC 1
void AIMMAtom(UINT uCmd);

#endif // UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------

#include "private.h"

#include "cdimm.h"
#include "globals.h"
#include "util.h"
#include "imeapp.h"

BOOL DIMM12_DllProcessAttach()
{
    if (g_ProcessIMM == NULL)
    {
        g_ProcessIMM = new CProcessIMM;
        if (g_ProcessIMM == NULL)
        {
            return FALSE;
        }
    }

    if (IsOnNT())
    {
        HINSTANCE hUser32 = GetSystemModuleHandle(TEXT("user32.dll"));
        if (hUser32)
            g_pfnToUnicodeEx = (TOUNICODEEX)GetProcAddress(hUser32, TEXT("ToUnicodeEx"));
    }

    WM_MSIME_SERVICE          = RegisterWindowMessageA( RWM_SERVICE );
    WM_MSIME_UIREADY          = RegisterWindowMessageA( RWM_UIREADY );
    WM_MSIME_RECONVERTREQUEST = RegisterWindowMessageA( RWM_RECONVERTREQUEST );
    WM_MSIME_RECONVERT        = RegisterWindowMessageA( RWM_RECONVERT );
    WM_MSIME_DOCUMENTFEED     = RegisterWindowMessageA( RWM_DOCUMENTFEED );
    WM_MSIME_QUERYPOSITION    = RegisterWindowMessageA( RWM_QUERYPOSITION );
    WM_MSIME_MODEBIAS         = RegisterWindowMessageA( RWM_MODEBIAS );
    WM_MSIME_SHOWIMEPAD       = RegisterWindowMessageA( RWM_SHOWIMEPAD );
    WM_MSIME_MOUSE            = RegisterWindowMessageA( RWM_MOUSE );
    WM_MSIME_KEYMAP           = RegisterWindowMessageA( RWM_KEYMAP );

    if (!WM_MSIME_SERVICE          ||
        !WM_MSIME_UIREADY          ||
        !WM_MSIME_RECONVERTREQUEST ||
        !WM_MSIME_RECONVERT        ||
        !WM_MSIME_DOCUMENTFEED     ||
        !WM_MSIME_QUERYPOSITION    ||
        !WM_MSIME_MODEBIAS         ||
        !WM_MSIME_SHOWIMEPAD       ||
        !WM_MSIME_MOUSE            ||
        !WM_MSIME_KEYMAP)
        return FALSE;

    return TRUE;
}

void DIMM12_DllProcessDeatch()
{
    if (g_ProcessIMM != NULL)
    {
        delete g_ProcessIMM;
    }
}

HRESULT DIMM12_DllRegisterServer(void)
{
    TCHAR achPath[MAX_PATH+1];
    HRESULT hr = E_FAIL;

    if (GetModuleFileName(g_hInst, achPath, ARRAYSIZE(achPath)) == 0)
        goto Exit;

    if (!RegisterServer(CLSID_CActiveIMM, TEXT("Active IMM"), achPath, TEXT("Apartment"), NULL))
        goto Exit;

    if (!RegisterServer(CLSID_CActiveIMM12, TEXT("Active IMM"), achPath, TEXT("Apartment"), NULL))
        goto Exit;

    if (!RegisterServer(CLSID_CActiveIMM12_Trident, TEXT("Active IMM"), achPath, TEXT("Apartment"), NULL))
        goto Exit;

    hr = S_OK;

Exit:
    return hr;
}

HRESULT DIMM12_DllUnregisterServer(void)
{
    HRESULT hr;

    if (FAILED(hr = RegisterServer(CLSID_CActiveIMM, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

    if (FAILED(hr = RegisterServer(CLSID_CActiveIMM12, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

    if (FAILED(hr = RegisterServer(CLSID_CActiveIMM12_Trident, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\uiwnd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwnd.h

Abstract:

    This file defines the UI Window Class.

Author:

Revision History:

Notes:

--*/

#ifndef _UIWND_H_
#define _UIWND_H_


class CUIWindow
{
public:
    CUIWindow() {
        _hUIWnd = NULL;
    }

    BOOL     CreateUIWindow(HKL hKL);

    BOOL     DestroyUIWindow() {
        BOOL fRet = DestroyWindow(_hUIWnd);
        _hUIWnd = NULL;
        return fRet;
    }

    LONG     SetUIWindowContext(HIMC hIMC) {
        return (LONG)SetWindowLongPtr(_hUIWnd, IMMGWLP_IMC, (LONG_PTR)hIMC);
    }

    LRESULT  SendUIMessage(UINT Msg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE) {
        LRESULT lRet;
        if (fUnicode && IsOnNT())      // Because Win9x platform doesn't have SendMessageW
            lRet = SendMessageW(_hUIWnd, Msg, wParam, lParam);
        else
            lRet = SendMessageA(_hUIWnd, Msg, wParam, lParam);
        return lRet;
    }

private:
    HWND         _hUIWnd;          // Handle of UI window.
};

#endif // _UIWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\registry.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    registry.h

Abstract:

    This file defines the Registry Class.

Author:

Revision History:

Notes:

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_


class CRegistry
{
public:
    CRegistry() {
        _hKey = NULL;
        _iEnumKeyIndex = -1;
        _dwMaxSubKeyLen = 0;
        _pMemBlock = NULL;
    }

    ~CRegistry() {
        if (_hKey != NULL) {
            RegCloseKey(_hKey);
            _hKey = NULL;
        }
        Release();
    }

    DWORD CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, LPSECURITY_ATTRIBUTES lpSecAttr = NULL, LPDWORD pDisposition = NULL);
    DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS);

    typedef enum {
        REG_QUERY_NUMBER_OF_SUBKEYS,
        REG_QUERY_MAX_SUBKEY_LEN
    } REG_QUERY;

    DWORD QueryInfoKey(REG_QUERY iType, LPBYTE lpData);

    DWORD GetFirstSubKey(LPTSTR* lppStr, LPDWORD lpdwSize);
    DWORD GetNextSubKey(LPTSTR* lppStr, LPDWORD lpdwSize);

private:
    void* Allocate(DWORD dwSize);
    void Release();

    HKEY    _hKey;           // Handle of registry key.

    int     _iEnumKeyIndex;  // Index of enumration key.
    DWORD   _dwMaxSubKeyLen; // Longest subkey name length

    LPBYTE  _pMemBlock;      // Memory block for enumration.
};

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\uiwnd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwnd.cpp

Abstract:

    This file implements the UI Window Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "uiwnd.h"
#include "globals.h"
#include "cdimm.h"

BOOL
CUIWindow::CreateUIWindow(
    HKL hKL
    )
{
    WCHAR achIMEWndClass[16];
    UINT_PTR ulPrivate;

    // consider: BOGUS fix: we are sengin WM_IME_SELECT twice on non-fe
    // so we get here twice and create two windows, which can ultimately
    // crash the process....
    // real fix: stop aimm from sending x2 WM_IME_SELECT
    if (_hUIWnd != 0)
    {
        // Assert(0);
        return TRUE;
    }

    CActiveIMM *_this = GetTLS();
    if (_this == NULL)
        return 0;

    if (_this->_GetIMEWndClassName(hKL,
                                      achIMEWndClass,
                                      sizeof(achIMEWndClass)/sizeof(WCHAR),
                                      &ulPrivate) == 0) {
        ASSERT(FALSE);
        return FALSE;
    }


    char achMBCS[32];

    // consider: probably need to stipulate somewhere that ui class name must be in ascii
    // to avoid CP_ACP problems....
    AssertE(WideCharToMultiByte(CP_ACP, 0, achIMEWndClass, -1, achMBCS, sizeof(achMBCS), NULL, NULL) != 0);

    //
    // create the ime's ui window
    // we create an ANSI IME UI window because Win9x platform doesn't have Unicode function.
    //
    _hUIWnd = CreateWindowExA(0,
                              achMBCS,
                              achMBCS,
                              WS_POPUP | WS_DISABLED,
                              0, 0, 0, 0,
                              NULL, 0, g_hInst, (void *)ulPrivate);
    if (_hUIWnd == NULL) {
        GetLastError();
        ASSERT(_hUIWnd);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\dimm\registry.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This file implements the Registry Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "registry.h"

DWORD
CRegistry::CreateKey(
    IN HKEY hKey,
    IN LPCTSTR lpSubKey,
    IN REGSAM access,
    IN LPSECURITY_ATTRIBUTES lpSecAttr,
    OUT LPDWORD pDisposition
    )

/*++

Routine Description:

    Create the registry key specified.

Arguments:

Return Value:

--*/

{
    if (_hKey != NULL) {
        RegCloseKey(_hKey);
        _hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(hKey,               // handle of an open key.
                                  lpSubKey,           // address of subkey name.
                                  0,                  // reserved.
                                  NULL,               // address of class string.
                                  REG_OPTION_NON_VOLATILE,  // special options flag.
                                  access,             // desired security access.
                                  lpSecAttr,          // address of key security structure.
                                  &_hKey,             // address of buffer for opened handle.
                                  &dwDisposition);    // address of disposition value buffer
    if (lResult != ERROR_SUCCESS) {
        _hKey = NULL;
    }

    if (pDisposition) {
        *pDisposition = dwDisposition;
    }

    return lResult;
}

DWORD
CRegistry::OpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpSubKey,
    IN REGSAM access
    )

/*++

Routine Description:

    Open the registry key specified.

Arguments:

Return Value:

--*/

{
    if (_hKey != NULL) {
        RegCloseKey(_hKey);
        _hKey = NULL;
    }

    LONG lResult = RegOpenKeyEx(hKey,         // handle of open key.
                                lpSubKey,     // address of name of subkey to open
                                0,            // reserved
                                access,       // security access mask
                                &_hKey);      // address of handle of open key
    if (lResult != ERROR_SUCCESS) {
        _hKey = NULL;
    }

    return lResult;
}

DWORD
CRegistry::QueryInfoKey(
    IN REG_QUERY iType,
    OUT LPBYTE lpData
    )

/*++

Routine Description:

    Retrieves information about a specified registry key.

Arguments:

Return Value:

--*/

{
    DWORD cSubKeys, cbMaxSubKeyLen;

    LONG lResult = RegQueryInfoKey(_hKey,             // handle to key to query
                                   NULL,              // address of buffer for class string
                                   NULL,              // address of size of class string buffer
                                   NULL,              // reserved
                                   &cSubKeys,         // address of buffer for number of subkeys
                                   &cbMaxSubKeyLen,   // address of buffer for longest subkey name length
                                   NULL,              // address of buffer for longest class string length
                                   NULL,              // address of buffer for number of value entries
                                   NULL,              // address of buffer for longest value name length
                                   NULL,              // address of buffer for longest value data length
                                   NULL,              // address of buffer for security descriptor length.
                                   NULL);             // address of buffer for last write time

    switch (iType) {
        case REG_QUERY_NUMBER_OF_SUBKEYS:
            *((LPDWORD)lpData) = cSubKeys;         break;
        case REG_QUERY_MAX_SUBKEY_LEN:
            *((LPDWORD)lpData) = cbMaxSubKeyLen;   break;
    }

    return lResult;
}

DWORD
CRegistry::GetFirstSubKey(
    OUT LPTSTR* lppStr,
    OUT LPDWORD lpdwSize
    )

/*++

Routine Description:

    Reads a first subkey for the key.

Arguments:

Return Value:

--*/

{
    _iEnumKeyIndex = 0;

    DWORD dwRet = QueryInfoKey(REG_QUERY_MAX_SUBKEY_LEN, (LPBYTE)&_dwMaxSubKeyLen);
    if (dwRet != ERROR_SUCCESS) {
        return dwRet;
    }

    return GetNextSubKey(lppStr, lpdwSize);
}

DWORD
CRegistry::GetNextSubKey(
    OUT LPTSTR* lppStr,
    OUT LPDWORD lpdwSize
    )

/*++

Routine Description:

    Reads the next subkey for the key.

Arguments:

Return Value:

--*/

{
    *lpdwSize = 0;

    if (Allocate(*lpdwSize = (_dwMaxSubKeyLen+sizeof(TCHAR)) * sizeof(TCHAR)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD lResult = RegEnumKeyEx(_hKey,                 // handle of key to enumrate
                                 _iEnumKeyIndex,        // index of subkey to enumerate
                                 (LPTSTR)_pMemBlock,    // address of buffer for subkey name
                                 lpdwSize,              // address for size of subkey buffer
                                 0,                     // reserved
                                 NULL,                  // address of buffer for class string
                                 NULL,                  // address for sieze of class buffer
                                 NULL);                 // address for time key last written to

    *lpdwSize += sizeof(TCHAR);    // since null terminate is not included in the size.

    if (lResult == ERROR_SUCCESS) {
        *lppStr = (LPTSTR)_pMemBlock;
        _iEnumKeyIndex++;
    }

    return lResult;
}

void*
CRegistry::Allocate(
    IN DWORD dwSize
    )
{
    ASSERT(dwSize != 0);

    if (_pMemBlock) {
        Release();
    }

    _pMemBlock = new BYTE[dwSize];

    return _pMemBlock;
}

void
CRegistry::Release(
    )
{
    if (_pMemBlock) {
        delete [] _pMemBlock;
    }

    _pMemBlock = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\actdict.h ===
/*----------------------------------------------------------------------------
	%%File: ACTDICT.H
	%%Unit: ACTDICT
	%%Contact: seijia@microsoft.com

	Header file for the program dictionary interface.
----------------------------------------------------------------------------*/

#ifndef __PRGDIC__
#define  __PRGDIC__

#include "outpos.h"

#define DLLExport				__declspec( dllexport )

//HRESULT values
#define IPRG_S_LONGER_WORD			MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7400)
#define IPRG_S_NO_ENTRY				MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7401)

//Dictionary Category
typedef DWORD			IMEDICAT;

#define dicatNone			0x00000000
#define dicatGeneral		0x00000001
#define	dicatNamePlace		0x00000002
#define dicatSpeech			0x00000004
#define dicatReverse		0x00000008
#define	dicatEnglish		0x00000010
#define dicatALL			0x0000001f

//Index Type
typedef DWORD			IMEIDXTP;

#define	idxtpHiraKanji		0x0001
#define	idxtpKanjiHira		0x0002
#define	idxtpMix			(idxtpHiraKanji | idxtpKanjiHira)

//IImeActiveDict Interface Version
#define	verIImeActiveDict			0x0100

//Dictionary Data Disclosure
typedef enum _IMEDDISC
{
	ddiscNone,				//do not disclose data
	ddiscAll,				//show all contents
	ddiscPartial			//show partial data
} IMEDDISC;

// Shared Header dictionary File
typedef struct _IMESHF
{
	WORD 		cbShf;				//size of this struct
	WORD 		verDic;				//dictionary version
	CHAR 		szTitle[48];		//dictionary title
	CHAR 		szDescription[256];	//dictionary description
	CHAR 		szCopyright[128];	//dictionary copyright info
} IMESHF;

//Dictionary Info
typedef struct _IMEDINFO
{
	IMESHF		shf;		//header
	DWORD		ver;		//IImeActiveDict version number
	IMEDDISC	ddisc;		//disclosure permission type
	FILETIME	filestamp;	//file stamp at creation
	IMEDICAT	dicat;		//dictionary category
	IMEIDXTP	idxtp;		//index type
	BOOL		fLearn;		//support word learning
} IMEDINFO;

#define cwchWordMax			64

typedef DWORD		IMESTMP;			//word stamp

//Program Dictionary Tango
typedef struct _IMEPDT
{
	IMEIDXTP	idxtp;					//index type
	int			cwchInput;				//input string length
	int			cwchOutput;				//output string length
	WCHAR		wszInput[cwchWordMax];	//input string
	WCHAR		wszOutput[cwchWordMax];	//output string
	DWORD		nPos;					//part of speech
	IMESTMP		stmp;					//word time stamp
} IMEPDT;

///////////////////////////////
// The IImeActiveDict interface
///////////////////////////////

#undef  INTERFACE
#define INTERFACE   IImeActiveDict

DECLARE_INTERFACE_(IImeActiveDict, IUnknown)
{
	// IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IImeActiveDict members
    STDMETHOD(DicInquire)	(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicOpen)		(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicClose)		(THIS) PURE;
    STDMETHOD(DicSearchWord)(THIS_
							IMEPDT *ppdt, 				//(in/out) tango
							BOOL fFirst, 				//(in) first time flag
							BOOL fWildCard,				//(in) wildcard flag
							BOOL fPartial				//(in) disclosure flag
							) PURE;
    STDMETHOD(DicLearnWord)	(THIS_
							IMEPDT *ppdt,				//(in/out) tango
							BOOL fUserLearn	,			//(in) user learning option
							int nLevel					//(in) learning level
							) PURE;
    STDMETHOD(DicProperty)	(THIS_
							HWND hwnd					//(in) parent window handle
							) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

// The following API replaces CoCreateInstance() since we don't support class ID at this time.
typedef HRESULT (WINAPI *PFNCREATE)(VOID **, int);
DLLExport HRESULT WINAPI CreateIImeActiveDictInstance(VOID **ppvObj, int nid);

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__PRGDIC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\ctxtcomp.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ctxtcomp.h

Abstract:

    This file defines the Context of Composition Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CTXTCOMP_H_
#define _CTXTCOMP_H_

#include "template.h"

/////////////////////////////////////////////////////////////////////////////
// GetCompInfo

template<class T>
HRESULT
GetCompInfo(
    IN T size,
    IN DWORD len,
    IN LONG*& lpCopied
    )
{
    *lpCopied = (LONG)(len * size);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CompData

template<class TYPE, class ARG_TYPE>
class CompData
{
public:
    CompData(HIMC hIMC = NULL, ARG_TYPE* lpsz = NULL, DWORD dwLen = 0)
    {
        IMCLock lpIMC(hIMC);
        if (lpIMC.Invalid())
            return;

        if (lpsz)
            WriteCompData(lpsz, dwLen);
    }

    CompData(IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr)
    {
    }

    CompData(IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr, DWORD dwIndex);

    DWORD WriteCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();

        DWORD index = dwLen;
        while (index--) {
            *psz++ = data;
        }

        return dwLen;
    }

    DWORD WriteCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        m_array.SetSize(dwLen);
        ARG_TYPE* psz = m_array.GetData();

        memcpy(psz, lpSrc, dwLen * sizeof(TYPE));
        return dwLen;
    }

    DWORD AddCompData(IN ARG_TYPE* lpSrc, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData();
        memcpy(psTemp+dwl, lpSrc, dwLen*sizeof(TYPE));

        return dwLen;
    }

    DWORD AddCompData(IN const ARG_TYPE& data, IN DWORD dwLen)
    {
        DWORD dwl = (DWORD)m_array.GetSize();
        ARG_TYPE *psTemp;

        m_array.SetSize(dwLen+dwl);

        psTemp = m_array.GetData()+dwl;

        DWORD index = dwLen;
        while (index--) {
            *psTemp++ = data;
        }

        return dwLen;
    }

    const INT_PTR ReadCompData(IN ARG_TYPE* lpDest = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_array.GetSize();
        }
        else {
            ARG_TYPE* psz = m_array.GetData();
            if ((INT_PTR)dwLen > m_array.GetSize()) {
                dwBufLen = m_array.GetSize();
            }
            else {
                dwBufLen = (INT_PTR)dwLen;
            }
            memcpy(lpDest, psz, dwBufLen * sizeof(TYPE));
        }
        return dwBufLen;
    }

    DWORD GetCompStrIndex(IN DWORD dwIndex) {
        switch(dwIndex) {
            case GCS_COMPATTR:         return GCS_COMPSTR;
            case GCS_COMPREADATTR:     return GCS_COMPREADSTR;
            case GCS_COMPCLAUSE:       return GCS_COMPSTR;
            case GCS_COMPREADCLAUSE:   return GCS_COMPREADSTR;
            case GCS_RESULTCLAUSE:     return GCS_RESULTSTR;
            case GCS_RESULTREADCLAUSE: return GCS_RESULTREADSTR;
            case GCS_CURSORPOS:        return GCS_COMPSTR;
            case GCS_DELTASTART:       return GCS_COMPSTR;
            default:                   break;
        }
        ASSERT(FALSE);
        return 0;
    }

    TYPE GetAt(INT_PTR nIndex) const
    {
        return m_array.GetAt(nIndex);
    }

    void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
    {
        m_array.SetAtGrow(nIndex, newElement);
    }

    INT_PTR Add(ARG_TYPE newElement)
    {
        return m_array.Add(newElement);
    }

    INT_PTR GetSize() const
    {
        return m_array.GetSize();
    }

    void RemoveAll()
    {
        m_array.RemoveAll();
    }

    operator void* ()
    {
        return m_array.GetData();
    }

    TYPE operator[](INT_PTR nIndex)
    {
        return m_array.GetAt(nIndex);
    }

protected:
    CArray<TYPE, ARG_TYPE>    m_array;
};

template<class TYPE, class ARG_TYPE>
CompData<TYPE, ARG_TYPE>::CompData(
    IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
    DWORD dwIndex
    )
{
    switch (dwIndex) {
        case GCS_COMPSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompStrOffset),
                                                            lpCompStr->CompStr.dwCompStrLen);        // # of chars
            break;
        case GCS_COMPREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadStrOffset),
                                                            lpCompStr->CompStr.dwCompReadStrLen);    // # of chars
            break;
        case GCS_RESULTSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultStrOffset),
                                                            lpCompStr->CompStr.dwResultStrLen);      // # of chars
            break;
        case GCS_RESULTREADSTR:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadStrOffset),
                                                            lpCompStr->CompStr.dwResultReadStrLen);  // # of chars
            break;

        case GCS_COMPATTR:        // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompAttrOffset),
                                                            lpCompStr->CompStr.dwCompAttrLen);
            break;
        case GCS_COMPREADATTR:    // ANSI-only
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadAttrOffset),
                                                            lpCompStr->CompStr.dwCompReadAttrLen);
            break;

        case GCS_COMPREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompReadClauseOffset),
                                                            lpCompStr->CompStr.dwCompReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultClauseOffset),
                                                            lpCompStr->CompStr.dwResultClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_RESULTREADCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwResultReadClauseOffset),
                                                            lpCompStr->CompStr.dwResultReadClauseLen / sizeof(TYPE));    // # of bytes
            break;
        case GCS_COMPCLAUSE:
            WriteCompData((TYPE*)lpCompStr.GetOffsetPointer(lpCompStr->CompStr.dwCompClauseOffset),
                                                            lpCompStr->CompStr.dwCompClauseLen / sizeof(TYPE));    // # of bytes
            break;

        case GCS_CURSORPOS:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwCursorPos);
            break;
        case GCS_DELTASTART:
            SetAtGrow(0, (TYPE)lpCompStr->CompStr.dwDeltaStart);
            break;

        default:
            break;
    }
}


class CWCompString;


/////////////////////////////////////////////////////////////////////////////
// CBCompString

class CBCompString : public CompData<CHAR, CHAR>
{
public:
    CBCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<CHAR, CHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<CHAR, CHAR>(lpCompStr),
                                                         m_cp(cp)
    {
    };

    CBCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<CHAR, CHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CBCompString& operator=(CWCompString& wcompstr);

    const DWORD ConvertUnicodeString(IN OUT LPWSTR lpsz = NULL, DWORD cch = 0)
    {
        return _mbstowcs(lpsz, cch);
    }

    CHAR GetAt(IN DWORD dwIndex)
    {
        return CompData<CHAR, CHAR>::GetAt(dwIndex);
    }

    BOOL IsDBCSLeadByteEx(IN DWORD dwIndex)
    {
         CHAR c = GetAt(dwIndex);
         return ::IsDBCSLeadByteEx(m_cp, c);
    }

private:
    UINT      m_cp;            // code page value.

    int _mbstowcs(wchar_t* wcstr, size_t cch);
};

inline
int
CBCompString::_mbstowcs(
    wchar_t* wcstr,
    size_t cch
    )
{
    if (cch == 0 && wcstr != NULL)
        return 0;

    const char* mbstr = m_array.GetData();
    INT_PTR nSize = m_array.GetSize();

    int result = ::MultiByteToWideChar(m_cp,     // code page
                                       0,        // character-type option
                                       mbstr,    // address of string to map
                                       (int)nSize,    // number of bytes in string
                                       wcstr,    // address of wide-char buffer
                                       (int)cch);   // size of buffer, in wide character.

    return result;
}



/////////////////////////////////////////////////////////////////////////////
// CWCompString

class CWCompString : public CompData<WCHAR, WCHAR>
{
public:
    CWCompString(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        LPWSTR lpsz=NULL,
        DWORD dwLen=0) : CompData<WCHAR, WCHAR>(hIMC, lpsz, dwLen),
                         m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<WCHAR, WCHAR>(lpCompStr),
                                                         m_cp(cp)
    {
    };

    CWCompString(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<WCHAR, WCHAR>(lpCompStr, dwIndex),
                         m_cp(cp)
    {
    };

    const CWCompString& operator=(CBCompString& bcompstr);

    const DWORD ConvertANSIString(IN OUT LPSTR lpsz = NULL, DWORD dwLen = 0)
    {
        return _wcstombs(lpsz, dwLen);
    }

    WCHAR GetAt(IN DWORD dwIndex)
    {
        return (WCHAR)CompData<WCHAR, WCHAR>::GetAt(dwIndex);
    }

    int UnicodeToMultiByteSize(IN DWORD dwIndex)
    {
        WCHAR wc = GetAt(dwIndex);
        return ::WideCharToMultiByte(m_cp,     // code page
                                     0,        // performance and mapping flags
                                     (const wchar_t*)&wc,     // address of wide-char string
                                     1,        // number of char string
                                     NULL,     // address of buffer for new string
                                     0,        // size of buffer
                                     NULL,     // default for unmappable char
                                     NULL);    // flag set when default char
    }

private:
    UINT      m_cp;            // code page value.

    int _wcstombs(char* mbstr, size_t count);
};

inline
int
CWCompString::_wcstombs(
    char* mbstr,
    size_t count
    )
{
    if (count == 0 && mbstr != NULL)
        return 0;

    const wchar_t* wcstr = m_array.GetData();
    INT_PTR nSize = m_array.GetSize();

    int result = ::WideCharToMultiByte(m_cp,     // code page
                                       0,        // performance and mapping flags
                                       wcstr,    // address of wide-char string
                                       (int)nSize,    // number of char string
                                       mbstr,    // address of buffer for new string
                                       (int)count,    // size of buffer
                                       NULL,     // default for unmappable char
                                       NULL);    // flag set when default char

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// CBCompStrin/CWCompString::operator=

inline
const CBCompString&
CBCompString::operator=(
    CWCompString& wcompstr
    )

/*+++
 *
 * Get ANSI string from Unicode composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = wcompstr.ConvertANSIString();
    m_array.SetSize(len);

    LPSTR psz = m_array.GetData();
    len = wcompstr.ConvertANSIString(psz, len * sizeof(CHAR));

    return *this;
}

inline
const CWCompString&
CWCompString::operator=(
    CBCompString& bcompstr
    )

/*+++
 *
 * Get Unicode string from ANSI composition string.
 *
---*/

{
    m_array.RemoveAll();

    DWORD len = bcompstr.ConvertUnicodeString();
    m_array.SetSize(len);

    LPWSTR psz = m_array.GetData();
    len = bcompstr.ConvertUnicodeString(psz, len);

    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckAttribute template

template<class APPS_ATTR, class HIMC_ATTR, class HIMC_CLAUSE>
HRESULT
CheckAttribute(
    APPS_ATTR& apps_attr,                        // the attr from apps
    HIMC_ATTR& himc_attr,                        // the attr from IMC
    HIMC_CLAUSE& himc_clause                     // the clause from IMC
    )
{
    if (himc_clause.ReadCompData() == 0) {
        TraceMsg(TF_WARNING, "CheckAttribute: no Clause. Pass it to IME.");
    }
    else {
        if (himc_attr.ReadCompData() != 0) {
            if (apps_attr.GetSize() != himc_attr.GetSize()) {
                TraceMsg(TF_ERROR, "CheckAttribute: wrong length.");
                return E_FAIL;
            }

            /*
             * The attr. of chars of one clause have to be same.
             */
            DWORD dwAttrIndex = 0;
            DWORD dwClauseIndex;
            for (dwClauseIndex = 0;
                 (INT_PTR)himc_clause.GetAt(dwClauseIndex) < apps_attr.ReadCompData();
                 dwClauseIndex++
                ) {
                DWORD dwBound = himc_clause.GetAt(dwClauseIndex+1) - himc_clause.GetAt(dwClauseIndex);
                DWORD battr = apps_attr.GetAt(dwAttrIndex++);
                DWORD dwCnt;
                for (dwCnt = 1; dwCnt < dwBound; dwCnt++) {
                    if (battr != apps_attr.GetAt(dwAttrIndex++)) {
                        TraceMsg(TF_ERROR, "CheckAttribute: mismatch clause attribute.");
                        return E_FAIL;
                    }
                }
            }
        }
    }

    return S_OK;
}

class CWCompAttribute;

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute

class CBCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CBCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CBCompAttribute& operator=(CWCompAttribute& wcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompAttribute

class CWCompAttribute : public CompData<BYTE, BYTE>
{
public:
    CWCompAttribute(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        BYTE* lpsz=NULL,
        DWORD dwLen=0) : CompData<BYTE, BYTE>(hIMC, lpsz, dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<BYTE, BYTE>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompAttribute(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<BYTE, BYTE>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    const CWCompAttribute& operator=(CBCompAttribute& bcompattr);

    INT_PTR Add(IN BYTE newElement)
    {
        return CompData<BYTE, BYTE>::Add(newElement);
    }

    CWCompString    m_wcompstr;
};

/////////////////////////////////////////////////////////////////////////////
// CBCompAttribute/CWCompAttribute::operator=

inline
const CBCompAttribute&
CBCompAttribute::operator=(
    CWCompAttribute& wcompattr
    )

/*+++
 *
 * Get ANSI attribute from Unicode composition attribute.
 *
---*/

{
    m_bcompstr = wcompattr.m_wcompstr;
    INT_PTR dwAttrIndexW = 0;
    INT_PTR dwStrIndex = 0;
    while ( dwStrIndex   < m_bcompstr.ReadCompData() &&
            dwAttrIndexW <  wcompattr.ReadCompData() &&
            m_bcompstr.GetAt((DWORD)dwStrIndex) != '\0' 
          ) {
        if (m_bcompstr.IsDBCSLeadByteEx((DWORD)dwStrIndex)) {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex += 2;
        }
        else {
            Add( wcompattr.GetAt(dwAttrIndexW) );
            dwStrIndex++;
        }
        dwAttrIndexW++;
    }
    return *this;
}

inline
const CWCompAttribute&
CWCompAttribute::operator=(
    CBCompAttribute& bcompattr
    )

/*+++
 *
 * Get Unicode attribute from ANSI composition attribute.
 *
---*/

{
    m_wcompstr = bcompattr.m_bcompstr;
    INT_PTR dwAttrIndexA = 0;
    INT_PTR dwStrIndex = 0;

    while ( dwStrIndex   < m_wcompstr.ReadCompData() &&
            dwAttrIndexA <  bcompattr.ReadCompData() &&
            m_wcompstr.GetAt((DWORD)dwStrIndex) != L'\0' 
          ) {
        if (m_wcompstr.UnicodeToMultiByteSize((DWORD)dwStrIndex) == 2) {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA += 2;
        }
        else {
            Add( bcompattr.GetAt(dwAttrIndexA) );
            dwAttrIndexA++;
        }
        dwStrIndex++;
    }
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CheckClause template


template<class APPS_CLAUSE, class HIMC_CLAUSE>
HRESULT
CheckClause(
    APPS_CLAUSE& apps_clause,                 // the clause from apps
    HIMC_CLAUSE& himc_clause                  // the clause from IMC
    )
{
    if (apps_clause.ReadCompData() == 0 ||
        himc_clause.ReadCompData() == 0  ) {
        TraceMsg(TF_ERROR, "CheckClause: no Clause.");
        return E_FAIL;
    }

    if (apps_clause.GetAt(0) ||
        himc_clause.GetAt(0)   ) {
        TraceMsg(TF_ERROR, "CheckClause: clause[0] have to be ZERO.");
        return E_FAIL;
    }

    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < himc_clause.ReadCompData();
         dwClauseIndex++
        ) {
        if (apps_clause.GetAt(dwClauseIndex) != himc_clause.GetAt(dwClauseIndex)) {
            return E_FAIL;
        }
    }

    return S_OK;
}


class CWCompClause;


/////////////////////////////////////////////////////////////////////////////
// CBCompClause

class CBCompClause : public CompData<DWORD, DWORD>
{
public:
    CBCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_bcompstr(cp, hIMC)
    {
    };

    CBCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CBCompClause& operator=(CWCompClause& wcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompClause

class CWCompClause : public CompData<DWORD, DWORD>
{
public:
    CWCompClause(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL,
        DWORD* lpsz=NULL,
        DWORD dwLen=0) : CompData<DWORD, DWORD>(hIMC,lpsz,dwLen),
                         m_wcompstr(cp, hIMC)
    {
    };

    CWCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompClause(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    DWORD GetAt(IN DWORD dwIndex)
    {
        return (DWORD)CompData<DWORD, DWORD>::GetAt(dwIndex);
    }

    const CWCompClause& operator=(CBCompClause& bcompclause);

    INT_PTR Add(IN DWORD newElement)
    {
        return CompData<DWORD, DWORD>::Add(newElement);
    }

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompClause/CWCompClause::operator=

inline
const CBCompClause&
CBCompClause::operator=(
    CWCompClause& wcompclause
    )

/*+++
 *
 * Get ANSI clause from Unicode composition clause.
 *
---*/

{
    m_bcompstr = wcompclause.m_wcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < wcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionWtoA( wcompclause.GetAt((DWORD)dwClauseIndex), &wcompclause.m_wcompstr ) );
    }
    return *this;
}

inline
const CWCompClause&
CWCompClause::operator=(
    CBCompClause& bcompclause
    )

/*+++
 *
 * Get Unicode clause from ANSI composition clause.
 *
---*/

{
    m_wcompstr = bcompclause.m_bcompstr;
    INT_PTR dwClauseIndex;
    for (dwClauseIndex = 0;
         dwClauseIndex < bcompclause.ReadCompData();
         dwClauseIndex++
        ) {
        Add( CalcCharacterPositionAtoW( bcompclause.GetAt((DWORD)dwClauseIndex), &bcompclause.m_bcompstr ) );
    }
    return *this;
}


class CWCompCursorPos;

/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos

class CBCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CBCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_bcompstr(cp, hIMC)
    {
    };

    CBCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CBCompCursorPos& operator=(CWCompCursorPos& wcompcursor);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompCursorPos

class CWCompCursorPos : public CompData<DWORD, DWORD>
{
public:
    CWCompCursorPos(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(cp, hIMC)
    {
    };

    CWCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompCursorPos(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CWCompCursorPos& operator=(CBCompCursorPos& bcompcursorpos);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompCursorPos/CWCompCursorPos::operator=

inline
const CBCompCursorPos&
CBCompCursorPos::operator=(
    CWCompCursorPos& wcompcursor
    )

/*+++
 *
 * Get ANSI cursor/delta start position from Unicode composition string.
 *
---*/

{
    m_bcompstr = wcompcursor.m_wcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionWtoA(wcompcursor.GetAt(0), &wcompcursor.m_wcompstr) );
    return *this;
}

inline
const CWCompCursorPos&
CWCompCursorPos::operator=(
    CBCompCursorPos& bcompcursor
    )

/*+++
 *
 * Get Unicode cursor/delta start position from ANSI composition string.
 *
---*/

{
    m_wcompstr = bcompcursor.m_bcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionAtoW(bcompcursor.GetAt(0), &bcompcursor.m_bcompstr) );
    return *this;
}


class CWCompDeltaStart;

/////////////////////////////////////////////////////////////////////////////
// CBCompDeltaStart

class CBCompDeltaStart : public CompData<DWORD, DWORD>
{
public:
    CBCompDeltaStart(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_bcompstr(cp, hIMC)
    {
    };

    CBCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_bcompstr(cp, lpCompStr)
    {
    };

    CBCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_bcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CBCompDeltaStart& operator=(CWCompDeltaStart& wcompdeltastart);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

    CBCompString    m_bcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CWCompDeltaStart

class CWCompDeltaStart : public CompData<DWORD, DWORD>
{
public:
    CWCompDeltaStart(
        UINT cp=CP_ACP,
        HIMC hIMC=NULL) : CompData<DWORD, DWORD>(hIMC),
                          m_wcompstr(cp, hIMC)
    {
    };

    CWCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr) : CompData<DWORD, DWORD>(lpCompStr),
                                                         m_wcompstr(cp, lpCompStr)
    {
    };

    CWCompDeltaStart(
        UINT cp,
        IMCCLock<COMPOSITIONSTRING_AIMM12>& lpCompStr,
        DWORD dwIndex) : CompData<DWORD, DWORD>(lpCompStr, dwIndex),
                         m_wcompstr(cp, lpCompStr, GetCompStrIndex(dwIndex))
    {
    };

    void Set(IN DWORD newElement)
    {
        CompData<DWORD, DWORD>::SetAtGrow(0, newElement);
    }

    const CWCompDeltaStart& operator=(CBCompDeltaStart& bcompdeltastart);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

    CWCompString    m_wcompstr;
};


/////////////////////////////////////////////////////////////////////////////
// CBCompDeltaStart/CWCompDeltaStart::operator=

inline
const CBCompDeltaStart&
CBCompDeltaStart::operator=(
    CWCompDeltaStart& wcompdeltastart
    )

/*+++
 *
 * Get ANSI cursor/delta start position from Unicode composition string.
 *
---*/

{
    m_bcompstr = wcompdeltastart.m_wcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionWtoA(wcompdeltastart.GetAt(0), &wcompdeltastart.m_wcompstr) );
    return *this;
}

inline
const CWCompDeltaStart&
CWCompDeltaStart::operator=(
    CBCompDeltaStart& bcompdeltastart
    )

/*+++
 *
 * Get Unicode cursor/delta start position from ANSI composition string.
 *
---*/

{
    m_wcompstr = bcompdeltastart.m_bcompstr;
    m_array.SetAtGrow( 0, CalcCharacterPositionAtoW(bcompdeltastart.GetAt(0), &bcompdeltastart.m_bcompstr) );
    return *this;
}



class CWReconvertString;

/////////////////////////////////////////////////////////////////////////////
// CBReconvetString

class CBReconvertString
{
public:
    CBReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_bcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;
        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_bcompstr.WriteCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset;
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset;
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_bcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_bcompstr.ReadCompData() * sizeof(CHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)(m_bcompstr.ReadCompData() * sizeof(CHAR));
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(CHAR));
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(CHAR));

            dwBufLen = m_bcompstr.ReadCompData((CHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CBReconvertString& operator=(CWReconvertString& wReconvStr);

    void SetData(CWReconvertString& wReconvStr);

    friend DWORD CalcCharacterPositionAtoW(DWORD dwCharPosA, CBCompString* bcompstr);

public:
    CBCompString    m_bcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CBCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CBCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};


/////////////////////////////////////////////////////////////////////////////
// CWReconvertString

class CWReconvertString
{
public:
    CWReconvertString(
        UINT cp,
        HIMC hIMC,
        LPRECONVERTSTRING lpReconv=NULL,
        DWORD dwLen=0) : m_wcompstr(cp, hIMC)
    {
        m_dwVersion      = 0;
        m_CompStrIndex   = 0;
        m_CompStrLen     = 0;
        m_TargetStrIndex = 0;
        m_TargetStrLen   = 0;

        if (lpReconv) {
            m_dwVersion = lpReconv->dwVersion;
            if (dwLen && lpReconv->dwStrOffset) {
                m_wcompstr.WriteCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                         lpReconv->dwStrLen);    // # of chars
                m_CompStrIndex = lpReconv->dwCompStrOffset / sizeof(WCHAR);   // char count
                m_CompStrLen   = lpReconv->dwCompStrLen;
                m_TargetStrIndex = lpReconv->dwTargetStrOffset / sizeof(WCHAR);  // char count
                m_TargetStrLen   = lpReconv->dwTargetStrLen;
            }
        }
    }

    DWORD WriteCompData(IN LPWSTR lpSrc, IN DWORD dwLen)
    {
        m_CompStrLen = dwLen;
        m_TargetStrLen = dwLen;
        return m_wcompstr.WriteCompData(lpSrc, dwLen);
    }

    const DWORD ReadCompData(IN LPRECONVERTSTRING lpReconv = NULL, DWORD dwLen = 0) {
        INT_PTR dwBufLen;
        if (! dwLen) {
            // query required buffer size. not inculde \0.
            dwBufLen = m_wcompstr.ReadCompData() * sizeof(WCHAR) + sizeof(RECONVERTSTRING);
        }
        else {
            lpReconv->dwSize            = dwLen;
            lpReconv->dwVersion         = m_dwVersion;
            lpReconv->dwStrLen          = (DWORD)m_wcompstr.ReadCompData();
            lpReconv->dwStrOffset       = (DWORD)sizeof(RECONVERTSTRING);
            lpReconv->dwCompStrLen      = (DWORD)m_CompStrLen;
            lpReconv->dwCompStrOffset   = (DWORD)(m_CompStrIndex * sizeof(WCHAR));  // byte count
            lpReconv->dwTargetStrLen    = (DWORD)m_TargetStrLen;
            lpReconv->dwTargetStrOffset = (DWORD)(m_TargetStrIndex * sizeof(WCHAR));  // byte count

            dwBufLen = m_wcompstr.ReadCompData((WCHAR*)((LPBYTE)lpReconv + lpReconv->dwStrOffset),
                                               lpReconv->dwStrLen);    // # of chars
        }
        return (DWORD)dwBufLen;
    }

    const CWReconvertString& operator=(CBReconvertString& bReconvStr);

    void SetData(CBReconvertString& bReconvStr);

    friend DWORD CalcCharacterPositionWtoA(DWORD dwCharPosW, CWCompString* wcompstr);

public:
    CWCompString    m_wcompstr;

    DWORD    m_dwVersion;        // Version number. Must be zero.
    INT_PTR  m_CompStrIndex;     // Index in the CWCompString::<string array> that will be the composition string.
    INT_PTR  m_CompStrLen;       // Character count length of the string that will be the composition string.
    INT_PTR  m_TargetStrIndex;   // Index in the CWCompString::<string array> that is related to the target clause in the composition string.
    INT_PTR  m_TargetStrLen;     // Character count length of the string that is related to the target clause.
};

/////////////////////////////////////////////////////////////////////////////
// CBCompReconvertString/CWCompReconvertString::operator=

inline
const CBReconvertString&
CBReconvertString::operator=(
    CWReconvertString& wReconvStr
    )
{
    m_bcompstr = wReconvStr.m_wcompstr;
    SetData(wReconvStr);
    return *this;
}

inline
const CWReconvertString&
CWReconvertString::operator=(
    CBReconvertString& bReconvStr
    )
{
    m_wcompstr = bReconvStr.m_bcompstr;
    SetData(bReconvStr);
    return *this;
}


/////////////////////////////////////////////////////////////////////////////
// CBReconvertString/CWReconvertString::SetData

inline
void
CBReconvertString::SetData(
    CWReconvertString& wReconvStr
    )
{
    m_dwVersion = wReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex), &wReconvStr.m_wcompstr);
    m_CompStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen), &wReconvStr.m_wcompstr) - m_CompStrIndex;
    m_TargetStrIndex = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex), &wReconvStr.m_wcompstr);
    m_TargetStrLen   = CalcCharacterPositionWtoA((DWORD)(wReconvStr.m_TargetStrIndex + wReconvStr.m_TargetStrLen), &wReconvStr.m_wcompstr) - m_TargetStrIndex;
}

inline
void
CWReconvertString::SetData(
    CBReconvertString& bReconvStr
    )
{
    m_dwVersion = bReconvStr.m_dwVersion;
    m_CompStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex), &bReconvStr.m_bcompstr);
    m_CompStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_CompStrIndex + bReconvStr.m_CompStrLen), &bReconvStr.m_bcompstr) - m_CompStrIndex);
    m_TargetStrIndex = CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex), &bReconvStr.m_bcompstr);
    m_TargetStrLen   = (CalcCharacterPositionAtoW((DWORD)(bReconvStr.m_TargetStrIndex + bReconvStr.m_TargetStrLen), &bReconvStr.m_bcompstr) - m_TargetStrIndex);
}













/////////////////////////////////////////////////////////////////////////////
// CWInterimString

class CWInterimString : public CWCompString
{
public:
    CWInterimString(
        UINT cp,
        HIMC hIMC
        ) : CWCompString(cp, hIMC)
    {
        m_InterimChar = L'\0';
        m_InterimAttr = 0;
    }

    VOID WriteInterimChar(WCHAR ch, BYTE attr)
    {
        m_InterimChar = ch;
        m_InterimAttr = attr;
    }

    void ReadInterimChar(WCHAR* ch, BYTE* attr)
    {
        *ch   = m_InterimChar;
        *attr = m_InterimAttr;
    }

    void ReadInterimChar(CWCompString* ch, CWCompAttribute* attr)
    {
        ch->WriteCompData(&m_InterimChar, 1);
        attr->WriteCompData(&m_InterimAttr, 1);
    }

public:
    WCHAR           m_InterimChar;
    BYTE            m_InterimAttr;
};




/////////////////////////////////////////////////////////////////////////////
// CWCompTfGuidAtom

class CWCompTfGuidAtom : public CompData<TfGuidAtom, TfGuidAtom>
{
public:
};




/////////////////////////////////////////////////////////////////////////////
// friend

inline
DWORD
CalcCharacterPositionAtoW(
    DWORD dwCharPosA,
    CBCompString* bcompstr
    )

/*+++

    Calculation Unicode character position to ANSI character position

---*/

{
    DWORD dwCharPosW = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosA != 0) {
        if (bcompstr->IsDBCSLeadByteEx(dwStrIndex)) {
            if (dwCharPosA >= 2) {
                dwCharPosA -= 2;
            }
            else {
                dwCharPosA--;
            }
            dwStrIndex += 2;
        }
        else {
            dwCharPosA--;
            dwStrIndex++;
        }
        dwCharPosW++;
    }

    return dwCharPosW;
}

inline
DWORD
CalcCharacterPositionWtoA(
    DWORD dwCharPosW,
    CWCompString* wcompstr
    )

/*+++

    Calculate ANSI character position to Unicode character position.

---*/

{
    DWORD dwCharPosA = 0;
    DWORD dwStrIndex = 0;

    while (dwCharPosW != 0) {
        if (wcompstr->UnicodeToMultiByteSize(dwStrIndex) == 2) {
            dwCharPosA += 2;
        }
        else {
            dwCharPosA++;
        }
        dwStrIndex++;
        dwCharPosW--;
    }

    return dwCharPosA;
}

#endif // _CTXTCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\imeutil.h ===
//
// imeutil.h
//

#ifndef IMEUTIL_H
#define IMEUTIL_H

#include <windows.h>


#ifdef __cplusplus
extern "C" {
#endif

DWORD HexStrToDWORD(TCHAR *pStr);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif // IMEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\imtls.h ===
//
// imtls.h
//

#ifndef IMTLS_H
#define IMTLS_H

#include "private.h"
#include "ciccs.h"
#include "imtls.h"

extern DWORD g_dwTLSIndex;

class CActiveIMM;

struct ITfThreadMgr_P;
struct IActiveIMMIME_Private;
struct IAImeProfile;

typedef struct _PENDINGFILTER
{
    struct _PENDINGFILTER *pNext;
    UINT uSize;
    ATOM rgAtoms[1];
} PENDINGFILTER;

typedef struct _PENDINGFILTERGUIDMAP
{
    struct _PENDINGFILTERGUIDMAP *pNext;
    UINT uSize;
    BOOL rgGuidMap[1];
} PENDINGFILTERGUIDMAP;

typedef struct _PENDINGFILTEREX
{
    struct _PENDINGFILTEREX *pNext;
    HWND hWnd;
    BOOL fGuidMap;
} PENDINGFILTEREX;

typedef struct _PrivateUIWndMsg
{
    HWND hWnd;
    UINT uMsgOnLayoutChange;
    UINT uMsgOnClearDocFeedBuffer;
} PrivateUIWndMsg;

typedef struct _IMTLS
{
    // dimm
    CActiveIMM *pActiveIMM;
    PENDINGFILTER        *pPendingFilterClientWindows;          // IActiveIMMApp::FilterClientWindows
    PENDINGFILTERGUIDMAP *pPendingFilterClientWindowsGuidMap;   // IActiveIMMAppEx::FilterClientWindows
    PENDINGFILTEREX      *pPendingFilterClientWindowsEx;        // IActiveIMMAppEx::FilterClientWindowsEx

    // win32
    // consider: perf: this is so lame.  We could put almost all of this directly
    // into ImmIfIme, the per-thread object, rather using TLS everywhere.
    ITfThreadMgr_P *tim;
    HIMC hIMC;
    IActiveIMMIME_Private *pAImm; // consider: this could be merged with pActiveIMM
    IAImeProfile *pAImeProfile;
    PrivateUIWndMsg prvUIWndMsg; // consider: is this constant per-process?

    BOOL   m_fMyPushPop : 1;                  // TRUE: This is AIMM1.2's Push/Pop call.

} IMTLS;

extern CCicCriticalSectionStatic g_cs;
extern BOOL  g_fInLegacyClsid;
extern BOOL  g_fTrident55;
extern BOOL  g_fAIMM12Trident;

#ifdef DEBUG
extern DWORD g_dwCacheThreadId;
#endif

inline IMTLS *IMTLS_GetOrAlloc()
{
    IMTLS *ptls;
 
    ptls = (IMTLS *)TlsGetValue(g_dwTLSIndex);

    if (ptls == NULL)
    {
        if ((ptls = (IMTLS *)cicMemAllocClear(sizeof(IMTLS))) == NULL)
            return NULL;

        if (!TlsSetValue(g_dwTLSIndex, ptls))
        {
            cicMemFree(ptls);
            return NULL;
        }
    }

    return ptls;
}

inline void IMTLS_Free()
{
    PENDINGFILTER *pPending;
    PENDINGFILTEREX *pPendingEx;
    IMTLS *ptls;

    ptls = (IMTLS *)TlsGetValue(g_dwTLSIndex);

    if (ptls == NULL)
        return;

    Assert(ptls->pActiveIMM == NULL);
    Assert(ptls->tim == NULL);
    Assert(ptls->pAImeProfile == NULL);

    while (ptls->pPendingFilterClientWindows != NULL)
    {
        pPending = ptls->pPendingFilterClientWindows->pNext;
        cicMemFree(ptls->pPendingFilterClientWindows);
        ptls->pPendingFilterClientWindows = pPending;
    }
    while (ptls->pPendingFilterClientWindowsEx != NULL)
    {
        pPendingEx = ptls->pPendingFilterClientWindowsEx->pNext;
        cicMemFree(ptls->pPendingFilterClientWindowsEx);
        ptls->pPendingFilterClientWindowsEx = pPendingEx;
    }

    cicMemFree(ptls);
    TlsSetValue(g_dwTLSIndex, NULL);
}

inline CActiveIMM *IMTLS_GetActiveIMM()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
    {
        return NULL;
    }

    return ptls->pActiveIMM;
}

inline BOOL IMTLS_SetActiveIMM(CActiveIMM *pActiveIMM)
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return FALSE;

    ptls->pActiveIMM = pActiveIMM;

    return TRUE;
}

#endif // IMTLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\resource.h ===
//
// resource.h
//

#ifndef RESOURCE_H
#define RESOURCE_H

/////////////////////////////////////////////////////////////////////////////
// Editing VK

#define ID_EDITING 100

#define EDIT_ID_FINALIZE    1
#define EDIT_ID_HANJA       2

/////////////////////////////////////////////////////////////////////////////
// Filter list

#define ID_FILTER_LIST 200

/////////////////////////////////////////////////////////////////////////////
// Known EXE module list for Trident aware applications.

#define ID_KNOWN_EXE   300

/////////////////////////////////////////////////////////////////////////////
// String ID

#define IDS_FUNCPRV_CONVERSION          0x0202

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\imeapp.h ===
//
//	%%Title: IMEAPP
//	%%Unit: COM
//	%%Contact: TakeshiF/SeijiA
//	%%Date: 97/06/20
//	%%File: imeapp.h
//
//	Private API / Message service
//

#ifndef __IMEUP_H__
#define __IMEUP_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#include "actdict.h"

//// START

/***********************************************************************
    IME Version IDs
 ***********************************************************************/
#define VERSION_ID_JAPANESE                 0x01000000
#define VERSION_ID_KOREAN                   0x02000000
#define VERSION_ID_CHINESE_TRADITIONAL      0x04000000
#define VERSION_ID_CHINESE_SIMPLIFIED       0x08000000

#define VERSION_ID_IMEJP98  (VERSION_ID_JAPANESE | 0x980)
#define VERSION_ID_IMEJP98A (VERSION_ID_JAPANESE | 0x98a)

/***********************************************************************
    Msg:    WM_MSIME_SERVICE
    Desc:   service functions
    Dir:    Apps to IME
    wParam: reserved
    lParam: reserved
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_SERVICE     TEXT("MSIMEService")

//getting version number (wParam)
#define FID_MSIME_VERSION       0

/***********************************************************************
    Msg:    WM_MSIME_UIREADY
    Desc:   service functions
    Dir:    IME to Apps
    wParam: Version ID
    lParam: reserved
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_UIREADY     TEXT("MSIMEUIReady")


//getting class id
#define FID_MSIME_GETCLSID		2

typedef struct _IMECLSID
{
	int			cbSize;		//size of this structure
	CLSID		clsid;		//class id
} IMECLSID;


/***********************************************************************
	Msg:	WM_MSIME_AUTOCOMPLETE
	Desc: 	use IImeActiveDict to support auto-complete
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_AUTOCOMPLETE 		TEXT("MSIMEAutoComplete")

// AutoComplete Version
#define VERSION_AUTOCOMPETE		1

// Dictionary Structure
typedef struct _IMEDICT
{
	int				cbSize;			//size of this structure
	HIMC			hIMC;			//IME context
	IImeActiveDict	*pdict;			//program dictionary
} IMEDICT;

//WParam definition
#define FID_AUTO_VERSION		1
#define FID_AUTO_ACTIVATE		2
#define FID_AUTO_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_WORDSTAT
	Desc: 	use IImeActiveDict to get word statistics
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_WORDSTAT 		TEXT("MSIMEWordStatistics")

// WordStat Version
#define VERSION_WORDSTAT		1

// WParam definition
#define FID_STAT_VERSION		1
#define FID_STAT_GIVESTAT		2


/***********************************************************************
	Msg:	WM_MSIME_DOCKDICT
	Desc: 	use IImeActiveDict to dock dictionary
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_DOCKDICT 		TEXT("MSIMEDockActiveDict")

// Dictionary Docking Version
#define VERSION_DOCKDICT		1

// WParam definition
#define FID_DOCK_VERSION		1
#define FID_DOCK_ACTIVATE		2
#define FID_DOCK_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_MOUSE
	Desc: 	mouse operation definition                
	Owner: 	kentu				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MOUSE 		TEXT("MSIMEMouseOperation")

// Mouse Operation Version (return value of IMEMOUSE_VERSION)
#define VERSION_MOUSE_OPERATION		1

// Mouse operation result
#define IMEMOUSERET_NOTHANDLED		(-1)

//WParam definition for WM_IME_MOUSE.
#define IMEMOUSE_VERSION	0xff	// mouse supported?

#define IMEMOUSE_NONE		0x00	// no mouse button was pushed
#define IMEMOUSE_LDOWN		0x01
#define IMEMOUSE_RDOWN		0x02
#define IMEMOUSE_MDOWN		0x04
#define IMEMOUSE_WUP		0x10	// wheel up
#define IMEMOUSE_WDOWN		0x20	// wheel down


/***********************************************************************
	Msg:	WM_MSIME_RECONVERT/WM_MSIME_RECONVERTREQUEST
	Desc: 	reconversion
	Owner: 	takeshif				
 ***********************************************************************/

// wParam of WM_MSIME_RECONVERTREQUEST
#define FID_RECONVERT_VERSION	0x10000000

// Private reconversion Version
#define VERSION_RECONVERSION		1

// Label for RegisterWindowMessage
#define	RWM_RECONVERT			TEXT("MSIMEReconvert")
#define	RWM_RECONVERTREQUEST	TEXT("MSIMEReconvertRequest")

/***********************************************************************
	Msg:	WM_MSIME_DOCUMENTFEED
	Desc: 	reconversion
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_DOCUMENTFEED, VERSION_DOCUMENTFEED,
				(RECONVERTSTRING*)pReconv );
	wParam: VERSION_DOCUMENTFEED
	lParam: Pointer of RECONVERTSTRING structure
	return: size of RECONVERTSTRING structure
 ***********************************************************************/

// wParam of WM_MSIME_DOCUMENTFEED (set current docfeed version)
#define VERSION_DOCUMENTFEED		1

// lParam is pointer of RECONVERTSTRING structure

// Label for RegisterWindowMessage
#define	RWM_DOCUMENTFEED	TEXT("MSIMEDocumentFeed")

/***********************************************************************
	Msg:	WM_MSIME_QUERYHIDECARET
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndDefUI, WM_MSIME_QUERYHIDECARET, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = shows caret. Zero = hide caret.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYHIDECARET
#define VERSION_QUERYHIDECARET		1

// Label for RegisterWindowMessage
#define	RWM_QUERYHIDECARET	TEXT("MSIMEQueryHideCaret")

/***********************************************************************
	Msg:	WM_MSIME_QUERYPOSITION
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_QUERYPOSITION, VERSION_QUERYPOSITION, (IMEPOSITION*)pPs );
	wParam: reserved. must be 0.
	lParam: pointer of IMEPOSITION structure
	return: Non-zero = success. Zero = error.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYPOSITION
#define VERSION_QUERYPOSITION		1

// Label for RegisterWindowMessage
#define	RWM_QUERYPOSITION	TEXT("MSIMEQueryPosition")


/***********************************************************************
	Msg:	WM_MSIME_MODEBIAS
	Desc: 	input mode bias
	Owner: 	takeshif
	Usage: SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, MODEBIASMODE_xxxx );
	wParam: operation of bias
	lParam: bias mode
	return: If wParam is MODEBIAS_GETVERSION,returns version number of interface.
			If wParam is MODEBIAS_SETVALUE : return non-zero value if succeeded. Returns 0 if fail.
			If wParam is MODEBIAS_GETVALUE : returns current bias mode.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS			TEXT("MSIMEModeBias")

// Current version
#define VERSION_MODEBIAS		1

// Set or Get (wParam)
#define MODEBIAS_GETVERSION		0
#define MODEBIAS_SETVALUE		1
#define MODEBIAS_GETVALUE		2

// Bias (lParam)
#define MODEBIASMODE_DEFAULT				0x00000000	// reset all of bias setting
#define MODEBIASMODE_FILENAME				0x00000001	// filename
#define MODEBIASMODE_READING				0x00000002	// reading recommended
#define MODEBIASMODE_DIGIT					0x00000004	// ANSI-Digit Recommended Mode


/***********************************************************************
	Msg:	WM_MSIME_SHOWIMEPAD
	Desc: 	show ImePad
	Owner: 	toshiaK
	Usage: SendMessage( hwndDefUI, WM_MSIME_SHOWIMEPAD, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SHOWIMEPAD			TEXT("MSIMEShowImePad")


/***********************************************************************
	Msg:	WM_MSIME_KEYMAP
	Desc: 	key map sharing with apps
	Owner: 	HiroakiK
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_KEYMAP				TEXT("MSIMEKeyMap")
#define	RWM_CHGKEYMAP			TEXT("MSIMEChangeKeyMap")
#define	RWM_NTFYKEYMAP			TEXT("MSIMENotifyKeyMap")


#define FID_MSIME_KMS_VERSION		1
#define FID_MSIME_KMS_INIT			2
#define FID_MSIME_KMS_TERM			3
#define FID_MSIME_KMS_DEL_KEYLIST	4
#define FID_MSIME_KMS_NOTIFY		5
#define FID_MSIME_KMS_GETMAP		6
#define FID_MSIME_KMS_INVOKE		7
#define FID_MSIME_KMS_SETMAP		8
#define FID_MSIME_KMS_FUNCDESC		9


#define IMEKMS_NOCOMPOSITION        0
#define IMEKMS_COMPOSITION          1
#define IMEKMS_SELECTION            2
#define IMEKMS_IMEOFF               3
#define IMEKMS_2NDLEVEL             4
#define IMEKMS_INPTGL               5



typedef struct tagIMEKMSINIT {
	INT			cbSize;
	HWND		hWnd;	// Window which receives notification from IME.
						// If hWnd is NULL, no notification is posted
						// to Input context.
} IMEKMSINIT;


typedef struct tagIMEKMSKEY {
	DWORD dwStatus;		//Shift-Control combination status.
						//Any combination of constants below
						//(defined in IMM.H)
						// 0x0000 (default)
						// MOD_CONTROL     0x0002
						// MOD_SHIFT       0x0004
						// Alt key and Win key is not processed by IME. 
	
	DWORD dwCompStatus;	//Composition string status
						//One of the constants below
						// IMEKMS_NOCOMPOSITION  No composition string      
						// IMEKMS_COMPOSITION    Some composition string
						// IMEKMS_SELECTION      Selection exists in apps
						// IMEKMS_IMEOFF         IME Off state
						// IMEKMS_2NDLEVEL       2nd stage on 2 stroke key operation
						
	
	DWORD dwVKEY;		// VKEY code defined in IMM.H
	union {
		DWORD dwControl;// IME Functionality ID
		DWORD dwNotUsed;
	};
	union {
		WCHAR pwszDscr[31];// The pointer to string of description of this functionalify
		WCHAR pwszNoUse[31];
	};
} IMEKMSKEY;

typedef struct tagIMEKMS {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		cKeyList;
	IMEKMSKEY	*pKeyList;
} IMEKMS;

typedef struct tagIMEKMSNTFY {
	INT			cbSize;
	HIMC		hIMC;
	BOOL		fSelect;
} IMEKMSNTFY;

typedef struct tagIMEKMSKMP {
	INT			cbSize;			//[in] size of this structure
	HIMC		hIMC;			//[in] Input context
	LANGID		idLang;			//[in] Language ID
	WORD		wVKStart;		//[in] VKEY start
	WORD		wVKEnd;			//[in] VKEY end
	INT			cKeyList;		//[out] number of IMEKMSKEY
	IMEKMSKEY	*pKeyList;		//[out] retrieve buffer of IMEKMSKEY
								//      Must be GlobalMemFree by clients
} IMEKMSKMP;

typedef struct tagIMEKMSINVK {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		dwControl;
} IMEKMSINVK;

typedef struct tagIMEKMSFUNCDESC {
	INT			cbSize;			//[in] size of this structure
	LANGID		idLang;			//[in] Language ID
	DWORD		dwControl;		//[in] IME Functionality ID
	WCHAR		pwszDescription[128]; //[out] Description of the functionality
} IMEKMSFUNCDESC;

/***********************************************************************
    Msg:    WM_MSIME_RECONVERTOPTIONS
    Desc:   Set reconversion options
    Usage: SendMessage( hwndDefUI, WM_MSIME_RECONVERTOPTIONS, dwOpt, (LPARAM)(HIMC)hIMC );
    wParam: options
    lParam: Input context handle
    return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_RECONVERTOPTIONS          TEXT("MSIMEReconvertOptions")

//WParam definition for WM_IME_RECONVERTOPTIONS.
#define RECONVOPT_NONE              0x00000000  // default
#define RECONVOPT_USECANCELNOTIFY   0x00000001  // cancel notify

// parameter of ImmGetCompositionString
#define GCSEX_CANCELRECONVERT       0x10000000

//// END

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif	// __cplusplus


#endif // __IMEUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\imclock.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    imclock.h

Abstract:

    This file defines the _IMCLock/_IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMCLOCK_H_
#define _IMCLOCK_H_

typedef struct tagINPUTCONTEXT_AIMM12 {
    HWND                hWnd;
    BOOL                fOpen;
    POINT               ptStatusWndPos;
    POINT               ptSoftKbdPos;
    DWORD               fdwConversion;
    DWORD               fdwSentence;
    union   {
        LOGFONTA        A;
        LOGFONTW        W;
    } lfFont;
    COMPOSITIONFORM     cfCompForm;
    CANDIDATEFORM       cfCandForm[4];
    HIMCC               hCompStr;
    HIMCC               hCandInfo;
    HIMCC               hGuideLine;
    HIMCC               hPrivate;
    DWORD               dwNumMsgBuf;
    HIMCC               hMsgBuf;
    DWORD               fdwInit;
    //
    // Use dwReserve[0] area for AIMM12
    //
    union {
        DWORD               m_dwReserve0;
#ifdef  _ENABLE_AIME_CONTEXT_
        IAImeContext*       m_pContext;
#endif
#ifdef  _ENABLE_CAIME_CONTEXT_
        CAImeContext*       m_pAImeContext;
#endif
    };

    //
    // Use dwReserve[1] area for AIMM12(Hangul mode tracking)
    //
    DWORD               fdwHangul;

    DWORD               dwReserve[1];
} INPUTCONTEXT_AIMM12, *PINPUTCONTEXT_AIMM12, NEAR *NPINPUTCONTEXT_AIMM12, FAR *LPINPUTCONTEXT_AIMM12;

// bit field for extended conversion mode
#define IME_CMODE_GUID_NULL    0x80000000
#define IME_SMODE_GUID_NULL    0x00008000


typedef struct tagCOMPOSITIONSTRING_AIMM12 {
    COMPOSITIONSTRING   CompStr;
    //
    // IME share of GUID map attribute.
    //
    DWORD               dwTfGuidAtomLen;
    DWORD               dwTfGuidAtomOffset;
    //
    DWORD               dwGuidMapAttrLen;
    DWORD               dwGuidMapAttrOffset;
} COMPOSITIONSTRING_AIMM12, *PCOMPOSITIONSTRING_AIMM12, NEAR *NPCOMPOSITIONSTRING_AIMM12, FAR *LPCOMPOSITIONSTRING_AIMM12;

// bits of fdwInit of INPUTCONTEXT
#define INIT_GUID_ATOM    0x00000040


//
// AIMM12 Compatibility flag
//
extern LPCTSTR REG_MSIMTF_KEY;

#define AIMM12_COMP_WINWORD 0x00000001




class _IMCLock
{
public:
    _IMCLock(HIMC hImc=NULL);
    virtual ~_IMCLock() {};

    bool    Valid()     { return m_inputcontext != NULL ? m_hr == S_OK : FALSE; }
    bool    Invalid()   { return !Valid(); }
    HRESULT GetResult() { return m_inputcontext ? m_hr : E_FAIL; }

    operator INPUTCONTEXT_AIMM12*() { return m_inputcontext; }

    INPUTCONTEXT_AIMM12* operator->() {
        ASSERT(m_inputcontext);
        return m_inputcontext;
    }

    operator HIMC() { return m_himc; }

    BOOL IsUnicode() { return m_fUnicode; }

protected:
    INPUTCONTEXT_AIMM12* m_inputcontext;
    HIMC                 m_himc;
    HRESULT              m_hr;
    BOOL                 m_fUnicode;

    virtual HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT_AIMM12 **ppIMC) = 0;
    virtual HRESULT _UnlockIMC(HIMC hIMC) = 0;

private:
    // Do not allow to make a copy
    _IMCLock(_IMCLock&) { }
};

inline
_IMCLock::_IMCLock(
    HIMC hImc
    )
{
    m_inputcontext = NULL;
    m_himc         = hImc;
    m_hr           = S_OK;
    m_fUnicode     = FALSE;
}


class _IMCCLock
{
public:
    _IMCCLock(HIMCC himcc = NULL);
    virtual ~_IMCCLock() {};

    bool Valid() { return m_pimcc != NULL; }
    bool Invalid() { return !Valid(); }
    HRESULT GetResult() { return m_pimcc ? m_hr : E_FAIL; }

    void ReleaseBuffer() { }

    void* GetOffsetPointer(DWORD dwOffset) {
        return (void*)( (LPBYTE)m_pimcc + dwOffset );
    }

protected:
    union {
        void*                      m_pimcc;
        COMPOSITIONSTRING_AIMM12*  m_pcomp;
#ifdef  _ENABLE_PRIVCONTEXT_
        PRIVCONTEXT*               m_ppriv;
#endif
    };

    HIMCC         m_himcc;
    HRESULT       m_hr;

    virtual HRESULT _LockIMCC(HIMCC hIMCC, void **ppv) = 0;
    virtual HRESULT _UnlockIMCC(HIMCC hIMCC) = 0;

private:
    void init(HIMCC hImcc);

    // Do not allow to make a copy
    _IMCCLock(_IMCCLock&) { }
};

inline
_IMCCLock::_IMCCLock(
    HIMCC hImcc
    )
{
    init(hImcc);
}

inline
void
_IMCCLock::init(
    HIMCC hImcc
    )
{
    m_pimcc = NULL;
    m_himcc        = hImcc;
    m_hr           = S_OK;
}

#endif // _IMCLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\inc\outpos.h ===
/*----------------------------------------------------------------------------
	%%File: OUTPOS.H
	%%Unit: OUTPOS
	%%Contact: seijia

	mapping from public and private pos
----------------------------------------------------------------------------*/

#ifndef __OUTPOS_H__
#define __OUTPOS_H__

#define POS_UNDEFINED			0

#define JPOS_UNDEFINED			POS_UNDEFINED

#define JPOS_MEISHI_FUTSU		100		//
#define JPOS_MEISHI_SAHEN		101		//
#define JPOS_MEISHI_ZAHEN		102		//
#define JPOS_MEISHI_KEIYOUDOUSHI		103		//`
#define JPOS_HUKUSIMEISHI		104		//I
#define JPOS_MEISA_KEIDOU		105		//`
#define JPOS_JINMEI		106		//l
#define JPOS_JINMEI_SEI		107		//
#define JPOS_JINMEI_MEI		108		//
#define JPOS_CHIMEI		109		//n
#define JPOS_CHIMEI_KUNI		110		//
#define JPOS_CHIMEI_KEN		111		//
#define JPOS_CHIMEI_GUN		112		//S
#define JPOS_CHIMEI_KU		113		//
#define JPOS_CHIMEI_SHI		114		//s
#define JPOS_CHIMEI_MACHI		115		//
#define JPOS_CHIMEI_MURA		116		//
#define JPOS_CHIMEI_EKI		117		//w
#define JPOS_SONOTA		118		//L
#define JPOS_SHAMEI		119		//
#define JPOS_SOSHIKI		120		//gD
#define JPOS_KENCHIKU		121		//z
#define JPOS_BUPPIN		122		//i
#define JPOS_DAIMEISHI		123		//
#define JPOS_DAIMEISHI_NINSHOU		124		//l
#define JPOS_DAIMEISHI_SHIJI		125		//w
#define JPOS_KAZU		126		//
#define JPOS_KAZU_SURYOU		127		//
#define JPOS_KAZU_SUSHI		128		//
#define JPOS_5DAN_AWA		200		//s
#define JPOS_5DAN_KA		201		//s
#define JPOS_5DAN_GA		202		//s
#define JPOS_5DAN_SA		203		//s
#define JPOS_5DAN_TA		204		//s
#define JPOS_5DAN_NA		205		//s
#define JPOS_5DAN_BA		206		//s
#define JPOS_5DAN_MA		207		//s
#define JPOS_5DAN_RA		208		//s
#define JPOS_5DAN_AWAUON		209		//s
#define JPOS_5DAN_KASOKUON		210		//s
#define JPOS_5DAN_RAHEN		211		//si
#define JPOS_4DAN_HA		212		//sli
#define JPOS_1DAN		213		//i
#define JPOS_TOKUSHU_KAHEN		214		//
#define JPOS_TOKUSHU_SAHENSURU		215		//
#define JPOS_TOKUSHU_SAHEN		216		//si
#define JPOS_TOKUSHU_ZAHEN		217		//si
#define JPOS_TOKUSHU_NAHEN		218		//si
#define JPOS_KURU_KI		219		//
#define JPOS_KURU_KITA		220		//
#define JPOS_KURU_KITARA		221		//
#define JPOS_KURU_KITARI		222		//
#define JPOS_KURU_KITAROU		223		//
#define JPOS_KURU_KITE		224		//
#define JPOS_KURU_KUREBA		225		//
#define JPOS_KURU_KO		226		//ij
#define JPOS_KURU_KOI		227		//
#define JPOS_KURU_KOYOU		228		//
#define JPOS_SURU_SA		229		//
#define JPOS_SURU_SI		230		//
#define JPOS_SURU_SITA		231		//
#define JPOS_SURU_SITARA		232		//
#define JPOS_SURU_SIATRI		233		//
#define JPOS_SURU_SITAROU		234		//
#define JPOS_SURU_SITE		235		//
#define JPOS_SURU_SIYOU		236		//
#define JPOS_SURU_SUREBA		237		//
#define JPOS_SURU_SE		238		//
#define JPOS_SURU_SEYO		239		//^
#define JPOS_KEIYOU		300		//`e
#define JPOS_KEIYOU_GARU		301		//`e
#define JPOS_KEIYOU_GE		302		//`e
#define JPOS_KEIYOU_ME		303		//`e
#define JPOS_KEIYOU_YUU		304		//`e
#define JPOS_KEIYOU_U		305		//`e
#define JPOS_KEIDOU		400		//`e
#define JPOS_KEIDOU_NO		401		//`e
#define JPOS_KEIDOU_TARU		402		//`e
#define JPOS_KEIDOU_GARU		403		//`e
#define JPOS_FUKUSHI		500		//
#define JPOS_FUKUSHI_SAHEN		501		//
#define JPOS_FUKUSHI_NI		502		//
#define JPOS_FUKUSHI_NANO		503		//
#define JPOS_FUKUSHI_DA		504		//
#define JPOS_FUKUSHI_TO		505		//
#define JPOS_FUKUSHI_TOSURU		506		//
#define JPOS_RENTAISHI		600		//A
#define JPOS_RENTAISHI_SHIJI		601		//wA
#define JPOS_SETSUZOKUSHI		650		//
#define JPOS_KANDOUSHI		670		//
#define JPOS_SETTOU		700		//
#define JPOS_SETTOU_KAKU		701		//P
#define JPOS_SETTOU_SAI		702		//Q
#define JPOS_SETTOU_FUKU		703		//R
#define JPOS_SETTOU_MI		704		//S
#define JPOS_SETTOU_DAISHOU		705		//T
#define JPOS_SETTOU_KOUTEI		706		//U
#define JPOS_SETTOU_CHOUTAN		707		//V
#define JPOS_SETTOU_SHINKYU		708		//W
#define JPOS_SETTOU_JINMEI		709		//l
#define JPOS_SETTOU_CHIMEI		710		//n
#define JPOS_SETTOU_SONOTA		711		//L
#define JPOS_SETTOU_JOSUSHI		712		//Ou
#define JPOS_SETTOU_TEINEI_O		713		//JP
#define JPOS_SETTOU_TEINEI_GO		714		//JQ
#define JPOS_SETTOU_TEINEI_ON		715		//JR
#define JPOS_SETSUBI		800		//
#define JPOS_SETSUBI_TEKI		801		//P
#define JPOS_SETSUBI_SEI		802		//Q
#define JPOS_SETSUBI_KA		803		//R
#define JPOS_SETSUBI_CHU		804		//S
#define JPOS_SETSUBI_FU		805		//T
#define JPOS_SETSUBI_RYU		806		//U
#define JPOS_SETSUBI_YOU		807		//V
#define JPOS_SETSUBI_KATA		808		//W
#define JPOS_SETSUBI_MEISHIRENDAKU		809		//A
#define JPOS_SETSUBI_JINMEI		810		//l
#define JPOS_SETSUBI_CHIMEI		811		//n
#define JPOS_SETSUBI_KUNI		812		//
#define JPOS_SETSUBI_KEN		813		//
#define JPOS_SETSUBI_GUN		814		//S
#define JPOS_SETSUBI_KU		815		//
#define JPOS_SETSUBI_SHI		816		//s
#define JPOS_SETSUBI_MACHI		817		//P
#define JPOS_SETSUBI_CHOU		818		//Q
#define JPOS_SETSUBI_MURA		819		//P
#define JPOS_SETSUBI_SON		820		//Q
#define JPOS_SETSUBI_EKI		821		//w
#define JPOS_SETSUBI_SONOTA		822		//L
#define JPOS_SETSUBI_SHAMEI		823		//
#define JPOS_SETSUBI_SOSHIKI		824		//gD
#define JPOS_SETSUBI_KENCHIKU		825		//z
#define JPOS_RENYOU_SETSUBI		826		//Ap
#define JPOS_SETSUBI_JOSUSHI		827		//u
#define JPOS_SETSUBI_JOSUSHIPLUS		828		//u{
#define JPOS_SETSUBI_JIKAN		829		//
#define JPOS_SETSUBI_JIKANPLUS		830		//{
#define JPOS_SETSUBI_TEINEI		831		//J
#define JPOS_SETSUBI_SAN		832		//JP
#define JPOS_SETSUBI_KUN		833		//JQ
#define JPOS_SETSUBI_SAMA		834		//JR
#define JPOS_SETSUBI_DONO		835		//JS
#define JPOS_SETSUBI_FUKUSU		836		//
#define JPOS_SETSUBI_TACHI		837		//P
#define JPOS_SETSUBI_RA		838		//Q
#define JPOS_TANKANJI		900		//P
#define JPOS_TANKANJI_KAO		901		//
#define JPOS_KANYOUKU		902		//p
#define JPOS_DOKURITSUGO		903		//
#define JPOS_FUTEIGO		904		//s
#define JPOS_KIGOU		905		//L
#define JPOS_EIJI		906		//p
#define JPOS_KUTEN		907		//_
#define JPOS_TOUTEN		908		//_
#define JPOS_KANJI		909		//s\
#define JPOS_OPENBRACE		910		//J
#define JPOS_CLOSEBRACE		911		//


#pragma pack (push, 1)
//POS table data structure
typedef struct _POSTBL
{
	WORD		nPos;					//pos number
	BYTE		*szName;				//name of pos
} POSTBL;
#pragma pack (pop)

#ifdef __cplusplus
extern "C" {
#endif

//function prototypes
extern POSTBL *ObtainPosTable(int *pcPos);
extern WORD WPosExtFromIn(WORD wPos);
extern WORD WPosInFromExt(WORD wPos);
BOOL FRegistExtPos(WORD wPos);
#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__OUTPOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\lib\imeutil.c ===
//
// imeutil.c
//

#include "imeutil.h"
#include "debug.h"

DWORD HexStrToDWORD(TCHAR *pStr)
{
    DWORD dw;
    TCHAR c;

    dw = 0;

    while (c = *pStr++)
    {
        dw *= 16;

        if (c >= '0' && c <= '9')
        {
            dw += c - '0';
        }
        else if (c >= 'a' && c <= 'f')
        {
            dw += c - 'a' + 10;
        }
        else if (c >= 'A' && c <= 'F')
        {
            dw += c - 'A' + 10;
        }
        else
        {
            break;
        }
    }

    return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\a_cime.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_cimc.cpp

Abstract:

    This file implements the ImmIfIME Class's public method.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "globals.h"
#include "immif.h"
#include "ico.h"
#include "langct.h"
#include "template.h"
#include "imeapp.h"
#include "profile.h"
#include "funcprv.h"
#include "a_wrappers.h"
#include "computil.h"
#include "korimx.h"


extern HRESULT CAImeContext_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);


//+---------------------------------------------------------------------------
//
// Class Factory's CreateInstance
//
//----------------------------------------------------------------------------

HRESULT
CIME_CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    DebugMsg(TF_FUNC, "CIME_CreateInstance called. TID=%x", GetCurrentThreadId());

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    ImmIfIME *pIME = new ImmIfIME;
    if (pIME == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = pIME->QueryInterface(riid, ppvObj);
    pIME->Release();

    if (SUCCEEDED(hr)) {
        hr = pIME->InitIMMX();
        if (FAILED(hr)) {
            pIME->Release();
            *ppvObj = NULL;
        }
    }

    return hr;
}

ImmIfIME::ImmIfIME()
{
    Dbg_MemSetThisName(TEXT("ImmIfIME"));

    m_fCicInit    = FALSE;
    m_fOnSetFocus = FALSE;

    m_tim = NULL;
    m_tfClientId = TF_CLIENTID_NULL;
    m_pkm = NULL;
    m_AImeProfile = NULL;
    m_dimEmpty = NULL;

    m_fAddedProcessAtom = FALSE;
}

ImmIfIME::~ImmIfIME()
{
    UnInitIMMX();
}


STDAPI
ImmIfIME::ConnectIMM(IActiveIMMIME_Private *pActiveIMM)

/*++

Method:

    IActiveIME::ConnectIMM

Routine Description:

    Accepts an IActiveIMMIME pointer from the dimm layer.

Arguments:

    pActiveIMM - [in] the imm layer

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    IMTLS *ptls;

    Assert(m_pIActiveIMMIME == NULL);

    // DON'T AddRef, this would create a circular ref.
    // We can get away with this because this is an internal
    // only object.
    // (This hack is necessary so that we can hook up dimm HIMCs
    // with cicero dim's before anyone calls Activate, which
    // we want to support.  We could avoid the cicular ref
    // problem by doing the hookup in IActiveIMMApp::Activate,
    // but then the ime layer is useless before the Activate
    // call.)
    m_pIActiveIMMIME = pActiveIMM;

    // Set IActiveIMMIME instance in the TLS data.
    if (ptls = IMTLS_GetOrAlloc())
    {
        Assert(ptls->pAImm == NULL);
        ptls->pAImm = pActiveIMM;
    }

    return S_OK;
}

STDAPI
ImmIfIME::UnconnectIMM()

/*++

Method:

    IActiveIME::UnconnectIMM

Routine Description:

    Releases the IActiveIMMIME pointer from the dimm layer.

Arguments:

    pActiveIMM - [in] the imm layer

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    IMTLS *ptls;

    Assert(m_pIActiveIMMIME != NULL);

    // nb: non-standard, won't Release pointer
    // we didn't AddRef in ConnectIMM
    m_pIActiveIMMIME = NULL;

    // Set IActiveIMMIME instance in the TLS data.
    if (ptls = IMTLS_GetOrAlloc())
    {
        ptls->pAImm = NULL;
    }

    return S_OK;
}

HRESULT
ImmIfIME::GetCodePageA(
    UINT *puCodePage
    )

/*++

Method:

    IActiveIME::GetCodePageA

Routine Description:

    Retrieves the code page associated with this Active IME.

Arguments:

    uCodePage - [out] Address of an unsigned integer that receives the code page identifier
                      associated with the keyboard layout.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::GetCodePageA");

    if (puCodePage == NULL) {
        return E_INVALIDARG;
    }

    return m_AImeProfile->GetCodePageA(puCodePage);
}

HRESULT
ImmIfIME::GetLangId(
    LANGID *plid
    )

/*++

Method:

    IActiveIME::GetLangId

Routine Description:

    Retrieves the language identifier associated with this Active IME.

Arguments:

    plid - [out] Address of the LANGID associated with the keyboard layout.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::GetLangId");

    if (plid == NULL) {
        return E_INVALIDARG;
    }

    return m_AImeProfile->GetLangId(plid);
}


STDAPI
ImmIfIME::Inquire(
    DWORD dwSystemInfoFlags,
    IMEINFO *pIMEInfo,
    LPWSTR szWndClass,
    DWORD *pdwPrivate
    )

/*++

Method:

    IActiveIME::Inquire

Routine Description:

    Handles the initialization of the Active IME.

Arguments:

    dwSystemInfoFlags - [in] Unsigned long integer value that specifies the system info flags.
                            FALSE : Inquire IME property and class name
                            TRUE  : Also Activate thread manager and input processor profile.
    pIMEInfo - [out] Address of the IMEINFO structure that receives information about the Active
                     IME.
    szWndClass - [out] Address of a string value that receives the window class name.
    pdwPrivate - [out] Reserved. Must be set to NULL.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;
    HWND hWndDummy = NULL;

    DebugMsg(TF_FUNC, "ImmIfIME::Inquire :: TID=%x", GetCurrentThreadId());

    if (pIMEInfo == NULL || pdwPrivate == NULL)
        return E_POINTER;

    *pdwPrivate = 0;

    if (!_ImeInquire(pIMEInfo, szWndClass, dwSystemInfoFlags))
        return E_FAIL;

    //
    // Inquire IME property and class name
    //
    if (dwSystemInfoFlags == FALSE)
        return S_OK;

    //
    // Activate thread manager and input processor profile.
    //
    Assert(m_tfClientId == TF_CLIENTID_NULL);
    
    // Set Activate flag in the CAImeProfile.
    m_AImeProfile->Activate();

    if (IsOn98() || IsOn95()) {
        /*
         * The ITfThreadMgr->Activate method calls win32 ActivateKeyboardLayout() function.
         * However if Windows9x platforms, this function require hWnd for succeed function call.
         * In this code, we prevent fail return from ActivateKeyboardLayout() by create dummy hWnd.
         */
        hWndDummy = CreateWindowA(TEXT("STATIC"),
                                  TEXT(""),
                                  WS_POPUP,                // Do not set WS_DISABLED flag
                                                           // due to ActivateKeyboardLayout fail
                                  0, 0, 0, 0,              // x, y, width, height
                                  NULL,                    // parent
                                  NULL,                    // menu
                                  GetInstance(),
                                  NULL);                   // lpParam

        if (hWndDummy == NULL)
            return E_FAIL;
    }

    hr = m_tim->Activate(&m_tfClientId);

    ITfSourceSingle *pSourceSingle;

    if (m_tim->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
    {
        CFunctionProvider *pFunc = new CFunctionProvider(this, m_tfClientId);
        if (pFunc)
        {
            pSourceSingle->AdviseSingleSink(m_tfClientId, IID_ITfFunctionProvider, (ITfFunctionProvider *)pFunc);
            pFunc->Release();
        }
        pSourceSingle->Release();
    }


    if (hWndDummy != NULL)
    {
        DestroyWindow(hWndDummy);
    }

    if (hr != S_OK)
    {
        Assert(0); // couldn't activate thread!
        m_tfClientId = TF_CLIENTID_NULL;
        return E_FAIL;
    }

    if (!m_dimEmpty && FAILED(hr = m_tim->CreateDocumentMgr(&m_dimEmpty)))
        return E_FAIL;

    return S_OK;
}


const char ImmIfIME::s_szUIClassName[16] = "IMMIF UI";

BOOL
ImmIfIME::_ImeInquire(
    LPIMEINFO lpImeInfo,
    LPWSTR pwszWndClass,
    DWORD dwSystemInfoFlags
    )
{
    DebugMsg(TF_FUNC, "ImmIfIME::ImeInquire");

    if (lpImeInfo == NULL) {
        DebugMsg(TF_ERROR, "ImeInquire: lpImeInfo is NULL.");
        return FALSE;
    }

    lpImeInfo->dwPrivateDataSize = 0;

    lpImeInfo->fdwProperty = 0;
    lpImeInfo->fdwConversionCaps = 0;
    lpImeInfo->fdwSentenceCaps = 0;
    lpImeInfo->fdwSCSCaps = 0;
    lpImeInfo->fdwUICaps = 0;

    // IME want to decide conversion mode on ImeSelect
    lpImeInfo->fdwSelectCaps = (DWORD)NULL;

#ifdef UNICODE
    lstrcpy(pwszWndClass, s_szUIClassName);
#else
    MultiByteToWideChar(CP_ACP, 0, s_szUIClassName, -1, pwszWndClass,  16);
#endif

    //
    // Per language property
    //
    LANGID LangId;
    HRESULT hr = GetLangId(&LangId);
    if (SUCCEEDED(hr)) {
        CLanguageCountry language(LangId);
        hr = language.GetProperty(&lpImeInfo->fdwProperty,
                                  &lpImeInfo->fdwConversionCaps,
                                  &lpImeInfo->fdwSentenceCaps,
                                  &lpImeInfo->fdwSCSCaps,
                                  &lpImeInfo->fdwUICaps);
    }
    return TRUE;
}




STDAPI
ImmIfIME::SelectEx(
    HIMC hIMC,
    DWORD dwFlags,
    BOOL bIsRealIme_SelKL,
    BOOL bIsRealIme_UnSelKL
    )

/*++

Method:

    IActiveIME::Select

Routine Description:

    Initializes and frees the Active Input Method Editor private context.

Arguments:

    hIMC - [in] Handle to the input context.
    dwFlags - [in] dword value that specifies the action. 

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::Select(%x, %x)", hIMC, dwFlags);

    HRESULT hr;
    IMTLS *ptls;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    if (_pAImeContext == NULL && (dwFlags & AIMMP_SE_SELECT))
    {
        // this happens if the context is created before Activate was called
        // we need to create the CAImeContext now
        if (CAImeContext_CreateInstance(NULL, IID_IAImeContext, (void**)&_pAImeContext) != S_OK)
            return E_FAIL;

        if (_pAImeContext->CreateAImeContext(hIMC, this) != S_OK)
        {
            _pAImeContext->Release();
            return E_FAIL;
        }
    }

    ptls = IMTLS_GetOrAlloc();

    HKL          _hkl;
    _hkl = ::GetKeyboardLayout(0);
    LANGID langid = LANGIDFROMLCID(PtrToUlong(_hkl));

    //
    // Chinese Legacy IME hack code for near caret IME.
    //
    if (PRIMARYLANGID(langid) == LANG_CHINESE)
    {
        imc->cfCandForm[0].dwStyle = CFS_DEFAULT;
        imc->cfCandForm[0].dwIndex = (DWORD)-1;
    }

#ifdef UNSELECTCHECK
    if (_pAImeContext)
        _pAImeContext->m_fSelected = (dwFlags & AIMMP_SE_SELECT) ? TRUE : FALSE;
#endif UNSELECTCHECK

    if (dwFlags & AIMMP_SE_SELECT) {

        Assert(_pAImeContext->lModeBias == MODEBIASMODE_DEFAULT /* => 0 */); // make sure lModeBias is init'd correctly

        if (hIMC == ImmGetContext(ptls, GetFocus())) {
            /*
             * Current focus window and hIMC matched.
             * Set current active hIMC in the *this->m_hImc
             */
            if (ptls != NULL)
            {
                ptls->hIMC = hIMC;
            }
        }

        if (! imc.ClearCand()) {
            return E_FAIL;
        }

        if ((imc->fdwInit & INIT_CONVERSION) == 0) {

            DWORD fdwConvForLang = (imc->fdwConversion & IME_CMODE_SOFTKBD); // = IME_CMODE_ALPHANUMERIC
            if (langid)
            {
                switch(PRIMARYLANGID(langid))
                {
                    case LANG_JAPANESE:
                        //
                        // Roman-FullShape-Native is a major convmode to 
                        // initialize.
                        //
                        fdwConvForLang |= IME_CMODE_ROMAN | 
                                          IME_CMODE_FULLSHAPE | 
                                          IME_CMODE_NATIVE;
                        break;

                    case LANG_KOREAN:
                        // IME_CMODE_ALPHANUMERIC
                        break;

#ifdef CICERO_4428
                    case LANG_CHINESE:
                        switch(SUBLANGID(langid))
                        {
                            case SUBLANG_CHINESE_TRADITIONAL:
                                // IME_CMODE_ALPHANUMERIC
                                break;
                            default:
                                fdwConvForLang |= IME_CMODE_NATIVE;
                                break;
                        }
                        break;
#endif

                    default:
                        fdwConvForLang |= IME_CMODE_NATIVE;
                        break;
                }
            }
            imc->fdwConversion |= fdwConvForLang;

            imc->fdwInit |= INIT_CONVERSION;
        }

        // Initialize extended fdwConversion flag.
        // While set IME_CMODE_GUID_NULL bit in fdwConversion, ICO_ATTR returns GUID_NULL.
        imc->fdwConversion |= IME_CMODE_GUID_NULL;

        //
        // Also, initialize extended fdwSentence flag.
        // While set IME_SMODE_GUID_NULL bit in fdwSentence, ICO_ATTR returns GUID_NULL.
        //
        imc->fdwSentence |= IME_SMODE_PHRASEPREDICT | IME_SMODE_GUID_NULL;

        if ((imc->fdwInit & INIT_LOGFONT) == 0) {
            HDC hDC;
            HGDIOBJ hSysFont;

            hDC = ::GetDC(imc->hWnd);
            hSysFont = ::GetCurrentObject(hDC, OBJ_FONT);
            LOGFONTA font;
            ::GetObjectA(hSysFont, sizeof(LOGFONTA), &font);
            ::ReleaseDC(NULL, hDC);

            if (ptls != NULL &&
                SUCCEEDED(ptls->pAImm->SetCompositionFontA(hIMC, &font)))
            {
                imc->fdwInit |= INIT_LOGFONT;
            }
        }

        imc.InitContext();

        // if this IME is run under Chicago Simplified Chinese version
        imc->lfFont.W.lfCharSet = GetCharsetFromLangId(LOWORD(HandleToUlong(_hkl)));


        //
        // Retrieve imc->fOpen status.
        //
        Interface_Attach<ITfContext> ic(GetInputContext(imc));

        if (ptls != NULL && ptls->hIMC == hIMC) {
            /*
             * Selecting hIMC has been current active hIMC,
             * then associate this DIM with the TIM.
             */
            if (dwFlags & AIMMP_SE_ISPRESENT) {
                Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc));
                SetFocus(imc->hWnd, dim.GetPtr(), TRUE);
            }
            else {
                SetFocus(imc->hWnd, NULL, TRUE);
            }
        }

        hr = GetCompartmentDWORD(m_tim,
                                 GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                 (DWORD*)&imc->fOpen, FALSE);

    }
    else {  // being unselected
        DebugMsg(TF_FUNC, "ImmIf is being unselected.");

        if (IsOnNT())
        {
            //
            // Switch hKL from Cicero KL to Legacy KL in Unselect handler.
            // We needs to call postponed lock so release all queueing request for edit session here.
            // Especially, ESCB_UPDATECOMPOSITIONSTRING should handle before switch to Legacy IME,
            // because this edit session possible to rewrite hIMC->hCompStr buffer.
            // Some Legacy IME have dependency of size and each offset with hCompStr.
            //
            // IsOn98 is CIMEUIWindowHandler::ImeUISelectHandler()
            //
            if ((! bIsRealIme_UnSelKL) && bIsRealIme_SelKL)
            {
                Interface_Attach<ITfContext> ic(GetInputContext(imc));
                if (ic.Valid())
                    m_tim->RequestPostponedLock(ic.GetPtr());
            }
        }

        Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc));

        //
        // Reset INIT_GUID_ATOM flag here.
        //
#ifdef CICERO_4428
        imc->fdwInit &= ~(INIT_GUID_ATOM);
#else
        imc->fdwInit &= ~(INIT_CONVERSION | INIT_GUID_ATOM);
#endif

        if (dim.GetPtr()) {
            if (ptls != NULL && ptls->hIMC == hIMC) {
                /*
                 * Selecting hIMC has been current active hIMC,
                 * then associate this DIM with the TIM.
                 */

                //
                // This call made Cicero to think the window was no Cicero aware
                // any more when hKL was changed to a real IME.
                //
                // SetFocus(imc->hWnd, NULL);
                //
                ptls->hIMC = (HIMC)NULL;
            }
        }
    }

    return hr;
}

STDAPI
ImmIfIME::UnSelectCheck(
    HIMC hIMC
    )

/*++

Method:

    IActiveIME::UnSelectCheck

Routine Description:

    Initializes and frees the Active Input Method Editor private context.

Arguments:

    hIMC - [in] Handle to the input context.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::UnSelectCheck(%x)", hIMC);

#ifdef UNSELECTCHECK
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    if (_pAImeContext)
    {
        _pAImeContext->m_fSelected = FALSE;
    }

#else
    //
    // none should call this without UNSELECTCHECK.
    //
    Assert(0);
#endif UNSELECTCHECK
    return S_OK;
}

void
ImmIfIME::SetFocus(
    HWND hWnd,
    ITfDocumentMgr* pdim,
    BOOL fSetFocus
    )
{
    if (m_fOnSetFocus) {
        /*
         * Prevent reentrance call from m_tim->AssociateFocus.
         */
        return;
    }

    m_fOnSetFocus = TRUE;

    if (::IsWindow(hWnd) && m_fCicInit != FALSE) {
        ITfDocumentMgr  *pdimPrev; // just to receive prev for now
        m_tim->AssociateFocus(hWnd, pdim, &pdimPrev);
        if (fSetFocus) {
            m_tim->SetFocus(pdim);
        }
        if (pdimPrev)
            pdimPrev->Release();

    }

    m_fOnSetFocus = FALSE;
}


STDAPI
ImmIfIME::AssociateFocus(
    HWND hWnd,
    HIMC hIMC,
    DWORD dwFlags
    )

/*++

Method:

    IActiveIME::AssociateFocus

Routine Description:

    Notifies the current Active Input Method Editor of the active input context.

Arguments:

    hIMC - [in] Handle to the input context.
    fActive - [in] Boolean value that specifies the status of the input context. TRUE indicates
                   the input context is activated, and FALSE indicates the input contest is
                   deactivated.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    DebugMsg(TF_FUNC, "ImmIfIME::AssociateFocus(%x, %x, %x)", hWnd, hIMC, dwFlags);

    HRESULT hr;
    IMTLS *ptls;
    BOOL fFocus = (dwFlags & AIMMP_AFF_SETFOCUS) ? TRUE : FALSE;
    HIMC hOldIMC = NULL;

    if (fFocus)
    {
        if (ptls = IMTLS_GetOrAlloc())
        {
            hOldIMC = ptls->hIMC;
            ptls->hIMC = hIMC;
        }
    }

    if (dwFlags & AIMMP_AFF_SETNULLDIM) {
        //
        // set  null dim so legacy IME start running.
        //
        SetFocus(hWnd, NULL, fFocus);

    }
    else if (hIMC) {
        IMCLock imc(hIMC);
        if (FAILED(hr = imc.GetResult()))
            return hr;

        Interface_Attach<ITfDocumentMgr> dim(GetDocumentManager(imc));
        SetFocus(imc->hWnd, dim.GetPtr(), fFocus);

    }
    else {
        //
        // this new focus change performance improvement breaks some
        // assumption of IsRealIME() in AssociateContext in dimm\immapp.cpp.
        // Associate NULL dim under IsPresent() window has not been the case
        // AIMM1.2 handles. In fact, this breaks IE that calls
        // AssociateContext on the focus window that is IsPresent().
        //
#ifdef FOCUSCHANGE_PERFORMANCE
        //
        // set empty dim so no text store to simulate NULL-HIMC.
        //
        BOOL fUseEmptyDIM = FALSE;
        ITfDocumentMgr  *pdimPrev; // just to receive prev for now
        if (SUCCEEDED(m_tim->GetFocus(&pdimPrev)) && pdimPrev)
        {
            fUseEmptyDIM = TRUE;
            pdimPrev->Release();
                
        }
        
        SetFocus(hWnd, fUseEmptyDIM ? m_dimEmpty : NULL, fFocus);
#else
        SetFocus(hWnd, m_dimEmpty, fFocus);
#endif
    }

    //
    // we want to finish ActivateAssemblyItem when we move between
    // Cicero aware and Non Cicero aware control.
    //
    // Async Edit Session may cause the hKL activate order problem.
    //
    if (fFocus && hOldIMC)
    {
        IMCLock imc(hOldIMC);
        if (FAILED(hr = imc.GetResult()))
            return hr;

        Interface_Attach<ITfContext> ic(GetInputContext(imc));

        if (ic.Valid())
            m_tim->RequestPostponedLock(ic.GetPtr());
    }

    return S_OK;
}



HRESULT
ImmIfIME::Notify(
    HIMC        hIMC,
    DWORD       dwAction,
    DWORD       dwIndex,
    DWORD       dwValue
    )

/*++

Method:

    IActiveIME::Notify

Routine Description:

    Notifies the Active IME about changes to the status of the input context.

Arguments:

    hIMC - [in] Handle to the input context.
    dwAction - [in] Unsigined long integer value that specifies the notification code.
    dwIndex - [in] Unsigned long integer value that specifies the index of a candidate list or,
                   if dwAction is set to NI_COMPOSITIONSTR, one of the following values:
                   CPS_CANCEL:  Clear the composition string and set the status to no composition
                                string.
                   CPS_COMPLETE: Set the composition string as the result string.
                   CPS_CONVERT: Convert the composition string.
                   CPS_REVERT: Cancel the current composition string and revert to the unconverted
                               string.
    dwValue - [in] Unsigned long integer value that specifies the index of a candidate string or
                   is not used, depending on the value of the dwAction parameter.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    IMCLock imc(hIMC);
    if (imc.Invalid())
        return E_FAIL;

    DebugMsg(TF_FUNC, "ImmIfIME::Notify(hIMC=%x, dwAction=%x, dwIndex=%x, dwValue=%x)", hIMC, dwAction, dwIndex, dwValue);

    switch (dwAction) {

        case NI_CONTEXTUPDATED:
            switch (dwValue) {
                case IMC_SETOPENSTATUS:
                    return OnSetOpenStatus(imc);

                case IMC_SETCONVERSIONMODE:
                case IMC_SETSENTENCEMODE:
                    return OnSetConversionSentenceMode(imc);

                case IMC_SETCOMPOSITIONWINDOW:
                case IMC_SETCOMPOSITIONFONT:
                    return E_NOTIMPL;

                case IMC_SETCANDIDATEPOS:
                    return OnSetCandidatePos(imc);

                default:
                    return E_FAIL;
            }
            break;

        case NI_COMPOSITIONSTR:
            switch (dwIndex) {
                case CPS_COMPLETE:
                    _CompComplete(imc);
                    return S_OK;

                case CPS_CONVERT:
                case CPS_REVERT:
                    return E_NOTIMPL;

                case CPS_CANCEL:
                    _CompCancel(imc);
                    return S_OK;

                default:
                    return E_FAIL;
            }
            break;

        case NI_OPENCANDIDATE:
        case NI_CLOSECANDIDATE:
        case NI_SELECTCANDIDATESTR:
        case NI_CHANGECANDIDATELIST:
        case NI_SETCANDIDATE_PAGESIZE:
        case NI_SETCANDIDATE_PAGESTART:
        case NI_IMEMENUSELECTED:
            return E_NOTIMPL;

        default:
            break;
    }
    return E_FAIL;
}

HRESULT
ImmIfIME::SetCompositionString(
    HIMC hIMC,
    DWORD dwIndex,
    void *pComp,
    DWORD dwCompLen,
    void *pRead,
    DWORD dwReadLen
    )

/*++

Method:

    IActiveIME::SetCompositionString

Routine Description:

    Sets the characters, attributes, and clauses of the composition and reading strings.

Arguments:

    hIMC - [in] Handle to the input context.
    dwIndex - [in] Unsigned long interger value that specifies the type of information to set.
    pComp - [in] Address of the buffer that contains the information to set for composition string.
                 The information is as specified by the dwIndex value.
    dwCompLen - [in] Unsigned long interger value that specifies the size, in bytes, of the
                     information buffer for the composition string.
    pRead - [in] Address of the buffer that contains the information to set for the reading string.
                 The information is as specified by the dwIndex value.
    dwReadLen - [in] Unsigned long interger value that specifies the size, in bytes, of the
                     information buffer for the reading string.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    UINT cp = CP_ACP;
    GetCodePageA(&cp);

    switch (dwIndex) {
        case SCS_SETSTR:
            {
                CWCompString wCompStr(cp, hIMC, (LPWSTR)pComp, dwCompLen);
                CWCompString wCompReadStr(cp, hIMC, (LPWSTR)pRead, dwReadLen);
                hr = Internal_SetCompositionString(wCompStr, wCompReadStr);
            }
            break;
        case SCS_CHANGEATTR:
        case SCS_CHANGECLAUSE:
            hr = E_NOTIMPL;
            break;
        case SCS_SETRECONVERTSTRING:
            {
                CWReconvertString wReconvStr(cp, hIMC, (LPRECONVERTSTRING)pComp, dwCompLen);
                CWReconvertString wReconvReadStr(cp, hIMC, (LPRECONVERTSTRING)pRead, dwReadLen);
                hr = Internal_ReconvertString(imc, wReconvStr, wReconvReadStr);
            }
            break;
        case SCS_QUERYRECONVERTSTRING:
            // AdjustZeroCompLenReconvertString((LPRECONVERTSTRING)pComp, cp, FALSE);
            // hr = S_OK;

            hr = Internal_QueryReconvertString(imc, (LPRECONVERTSTRING)pComp, cp, FALSE);
            break;
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}

HRESULT
ImmIfIME::Destroy(
    UINT uReserved
    )

/*++

Method:

    IActiveIME::Destroy

Routine Description:

    Terminates the Active Input Method Editor (IME).

Arguments:

    uReserved - [in] Reserved. Must be set to zero.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    //
    // clear empty dim
    //
    SafeReleaseClear(m_dimEmpty);

    // Deactivate thread manager.
    if (m_tfClientId != TF_CLIENTID_NULL)
    {
        ITfSourceSingle *pSourceSingle;

        if (m_tim->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
        {
            pSourceSingle->UnadviseSingleSink(m_tfClientId, IID_ITfFunctionProvider);
            pSourceSingle->Release();
        }

        m_tfClientId = TF_CLIENTID_NULL;
        m_tim->Deactivate();

    }

    return S_OK;
}


HRESULT
ImmIfIME::Escape(
    HIMC hIMC,
    UINT uEscape,
    void *pData,
    LRESULT *plResult
    )

/*++

Method:

    IActiveIME::Escape

Routine Description:

    Allows an application to access capabilities of a particular Active Input Method Editor (IME)
    not directly available through other methods.

Arguments:

    hIMC - [in] Handle to the input context.
    uEscape - [in] Unsigned integer value that specifies the escape function to be performed.
    pData - [in, out] Address of a buffer that contains the data required by the specified
                      escape function.
    plResult - [out] Address of a buffer that receives the result of the operation.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    LANGID LangId;
    HRESULT hr = GetLangId(&LangId);
    if (SUCCEEDED(hr)) {
        CLanguageCountry language(LangId);

        UINT cp = CP_ACP;
        GetCodePageA(&cp);

        hr = language.Escape(cp, hIMC, uEscape, pData, plResult);
    }
    return hr;
}

STDAPI
ImmIfIME::ConversionList(
    HIMC hIMC,
    LPWSTR szSource,
    UINT uFlag,
    UINT uBufLen,
    CANDIDATELIST *pDest,
    UINT *puCopied
    )
{
    if (puCopied == NULL)
        return E_POINTER;

    *puCopied = 0;

    // really not implemented
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::Configure(
    HKL hKL,
    HWND hWnd,
    DWORD dwMode,
    REGISTERWORDW *pRegisterWord
    )
{
    IMTLS *ptls;
    TF_LANGUAGEPROFILE LanguageProfile;

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    HRESULT hr = ptls->pAImeProfile->GetActiveLanguageProfile(hKL,
                                                        GUID_TFCAT_TIP_KEYBOARD,
                                                        &LanguageProfile);
    if (FAILED(hr))
        return hr;

    Interface<ITfFunctionProvider> pFuncProv;
    hr = ptls->tim->GetFunctionProvider(LanguageProfile.clsid,    // CLSID of tip
                                   pFuncProv);
    if (FAILED(hr))
        return hr;

    if (dwMode & IME_CONFIG_GENERAL) {
        Interface<ITfFnConfigure> pFnConfigure;
        hr = pFuncProv->GetFunction(GUID_NULL,
                                    IID_ITfFnConfigure,
                                    (IUnknown**)(ITfFnConfigure**)pFnConfigure);
        if (FAILED(hr))
            return hr;

        hr = pFnConfigure->Show(hWnd,
                                LanguageProfile.langid,
                                LanguageProfile.guidProfile);
        return hr;
    }
    else if (dwMode & IME_CONFIG_REGISTERWORD) {
        Interface<ITfFnConfigureRegisterWord> pFnRegisterWord;
        hr = pFuncProv->GetFunction(GUID_NULL,
                                    IID_ITfFnConfigureRegisterWord,
                                    (IUnknown**)(ITfFnConfigureRegisterWord**)pFnRegisterWord);
        if (FAILED(hr))
            return hr;

        if (!pRegisterWord)
        {
            hr = pFnRegisterWord->Show(hWnd,
                                       LanguageProfile.langid,
                                       LanguageProfile.guidProfile,
                                       NULL);
        }
        else
        {
            BSTR bstrWord = SysAllocString(pRegisterWord->lpWord);
            if (!bstrWord)
                return E_OUTOFMEMORY;
    
            hr = pFnRegisterWord->Show(hWnd,
                                       LanguageProfile.langid,
                                       LanguageProfile.guidProfile,
                                       bstrWord);

            SysFreeString(bstrWord);
        }
        return hr;
    }
    else {
        return E_NOTIMPL;
    }
}

STDAPI
ImmIfIME::RegisterWord(
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szString
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::UnregisterWord(
    LPWSTR szReading,
    DWORD  dwStyle,
    LPWSTR szString
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::GetRegisterWordStyle(
    UINT nItem,
    STYLEBUFW *pStyleBuf,
    UINT *puBufSize
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

STDAPI
ImmIfIME::EnumRegisterWord(
    LPWSTR szReading,
    DWORD dwStyle,
    LPWSTR szRegister,
    LPVOID pData,
    IEnumRegisterWordW **ppEnum
    )
{
    ASSERT(0); // consider: add code
    return E_NOTIMPL;
}

//
// Notification
//
HRESULT
ImmIfIME::OnSetOpenStatus(
    IMCLock& imc
    )
{
    if (! imc->fOpen && imc.ValidCompositionString())
        _CompCancel(imc);

    Interface_Attach<ITfContext> ic(GetInputContext(imc));
    m_ulOpenStatusChanging++;
    HRESULT hr =  SetCompartmentDWORD(m_tfClientId,
                                      m_tim,
                                      GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                      imc->fOpen,
                                      FALSE);
    m_ulOpenStatusChanging--;
    return hr;
}

HRESULT
ImmIfIME::OnSetKorImxConversionMode(
    IMCLock& imc
    )
{
    DWORD fdwConvMode = 0;

    Interface_Attach<ITfContext> ic(GetInputContext(imc));

    m_ulKorImxModeChanging++;

    if (imc->fdwConversion & IME_CMODE_HANGUL)
    {
        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
            fdwConvMode = KORIMX_HANGULJUNJA_MODE;
        else
            fdwConvMode = KORIMX_HANGUL_MODE;
    }
    else
    {
        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
            fdwConvMode = KORIMX_JUNJA_MODE;
        else
            fdwConvMode = KORIMX_ALPHANUMERIC_MODE;
    }

    HRESULT hr =  SetCompartmentDWORD(m_tfClientId,
                                      m_tim,
                                      GUID_COMPARTMENT_KORIMX_CONVMODE,
                                      fdwConvMode,
                                      FALSE);
    m_ulKorImxModeChanging--;

    return hr;
}

HRESULT
ImmIfIME::OnSetConversionSentenceMode(
    IMCLock& imc
    )
{
    IMTLS *ptls;

    Interface_Attach<ITfContextOwnerServices> iccb(GetInputContextOwnerSink(imc));

    // let cicero know the mode bias has changed
    // consider: perf: we could try to filter out false-positives here
    // (sometimes a bit that cicero ignores changes, we could check and avoid the call,
    // but it would complicate the code)
    iccb->OnAttributeChange(GUID_PROP_MODEBIAS);

    //
    // let Korean Tip sync up the current mode status changing...
    //
    if ((ptls = IMTLS_GetOrAlloc()) != NULL)
    {
        LANGID langid;

        ptls->pAImeProfile->GetLangId(&langid);

        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            OnSetKorImxConversionMode(imc);
        }
    }

    return S_OK;
}

HRESULT
ImmIfIME::OnSetCandidatePos(
    IMCLock& imc
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    //
    // When this is in the reconvert session, candidate window position is
    // not caret position of cfCandForm->ptCurrentPos.
    //
    if (! _pAImeContext->IsInReconvertEditSession()) {
        IMTLS *ptls;
        if (ptls = IMTLS_GetOrAlloc())
        {
            /*
             * A-Synchronize call ITfContextOwnerServices::OnLayoutChange
             * because this method had a protected.
             */
            PostMessage(ptls->prvUIWndMsg.hWnd,
                        ptls->prvUIWndMsg.uMsgOnLayoutChange, (WPARAM)(HIMC)imc, 0);
        }
    }
    return S_OK;
}


STDAPI 
ImmIfIME::SetThreadCompartmentValue(
    REFGUID rguid, 
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;


    HRESULT hr = E_FAIL;
    if (m_tim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)m_tim, rguid, &pComp, FALSE)))
        {
            hr = pComp->SetValue(m_tfClientId, pvar);
            pComp->Release();
        }
    }

    return hr;
}

STDAPI 
ImmIfIME::GetThreadCompartmentValue(
    REFGUID rguid, 
    VARIANT *pvar
    )
{
    if (pvar == NULL)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    QuickVariantInit(pvar);

    if (m_tim)
    {
        ITfCompartment *pComp;
        if (SUCCEEDED(GetCompartment((IUnknown *)m_tim, rguid, &pComp, FALSE)))
        {
            hr = pComp->GetValue(pvar);
            pComp->Release();
        }
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\lib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define NOIME
#include <windows.h>
#include <ole2.h>
#include <debug.h>
#include <ocidl.h>


// New NT5 header
#include "immdev.h"
#define _IMM_
#define _DDKIMM_H_

#include "msctf.h"

//#include <shlwapi.h>
//#include <advpub.h>
#include <ccstock.h>
//#include <inetreg.h>
//#include <comcat.h>
//#include <olectl.h>

#define _DDKIMM_H_
#include "aimm12.h"
#include "aimmp.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\uuid\aimm_g.c ===
#ifdef __cplusplus
extern "C"{
#endif


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#define GUID IID

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#if 0
/* aa80e7f1-2021-11d2-93e0-0060b067b86e */
const CLSID CLSID_CActiveIMM = {
    0x4955DD33,
    0xB159,
    0x11d0,
    {0x8f, 0xcf, 0x00, 0xaa, 0x00, 0x6b, 0xcc, 0x59}
  };
#endif

/* c1ee01f2-b3b6-4a6a-9ddd-e988c088ec82 */
const CLSID CLSID_CActiveIMM12 = { 
    0xc1ee01f2,
    0xb3b6,
    0x4a6a,
    {0x9d, 0xdd, 0xe9, 0x88, 0xc0, 0x88, 0xec, 0x82}
  };

/* 50D5107A-D278-4871-8989-F4CEAAF59CFC */
const CLSID CLSID_CActiveIMM12_Trident = {
    0x50d5107a,
    0xd278,
    0x4871,
    {0x89, 0x89, 0xf4, 0xce, 0xaa, 0xf5, 0x9c, 0xfc}
   };

// {B676DB87-64DC-4651-99EC-91070EA48790}
const CLSID CLSID_CAImmLayer = {
    0xb676db87,
    0x64dc,
    0x4651,
    { 0x99, 0xec, 0x91, 0x7, 0xe, 0xa4, 0x87, 0x90 }
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\a_context.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_context.h

Abstract:

    This file defines the CAImeContext Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CONTEXT_H_
#define _CONTEXT_H_

#include "cime.h"
#include "icocb.h"
#include "txtevcb.h"
#include "tmgrevcb.h"
#include "cmpevcb.h"
#include "reconvcb.h"
#include "globals.h"
#include "template.h"
#include "atlbase.h"
#include "imeapp.h"

class ImmIfIME;
class CBReconvertString;
class CWCompString; class CBCompString;
class CWCompAttribute; class CBCompAttribute;
class CWCompCursorPos;

//
// The smallest value for bAttr to map to guidatom.
// We reserve the lower values for IMM32's IME. So there is no confilict.
//
const BYTE ATTR_LAYER_GUID_START  =  (ATTR_FIXEDCONVERTED + 1);

class CAImeContext : public IAImeContext,
                     public ITfCleanupContextSink,
                     public ITfContextOwnerCompositionSink
{
public:
    CAImeContext();
    virtual ~CAImeContext();

public:
    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IAImeContext methods
    //
    STDMETHODIMP CreateAImeContext(HIMC hIMC, IActiveIME_Private* pActiveIME);
    STDMETHODIMP DestroyAImeContext(HIMC hIMC);
    STDMETHODIMP UpdateAImeContext(HIMC hIMC);
    STDMETHODIMP MapAttributes(HIMC hIMC);
    STDMETHODIMP GetGuidAtom(HIMC hIMC, BYTE bAttr, TfGuidAtom* pGuidAtom);


    //
    // ITfCleanupContextSink methods
    //
    STDMETHODIMP OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic);

    //
    // ITfContextOwnerCompositionSink
    //
    STDMETHODIMP OnStartComposition(ITfCompositionView *pComposition, BOOL *pfOk);
    STDMETHODIMP OnUpdateComposition(ITfCompositionView *pComposition, ITfRange *pRangeNew);
    STDMETHODIMP OnEndComposition(ITfCompositionView *pComposition);

public:
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

protected:
    long m_ref;

public:
    // HRESULT AssociateFocus(HIMC hIMC, BOOL fActive);

    ITfDocumentMgr* GetDocumentManager()
    {
        return m_pdim;
    }

    ITfContext* GetInputContext()
    {
        return m_pic;
    }

    ITfContextOwnerServices* GetInputContextOwnerSink()
    {
        return m_piccb;
    }

    //
    // Reconvert Edit Session
    //
public:
    HRESULT SetupReconvertString();
    HRESULT SetupReconvertString(UINT uPrivMsg);
    HRESULT EndReconvertString();

    HRESULT SetupUndoCompositionString();
    HRESULT EndUndoCompositionString();

    HRESULT SetReconvertEditSession(BOOL bSet);
    BOOL    IsInReconvertEditSession() {return m_fInReconvertEditSession;}
    HRESULT SetClearDocFeedEditSession(BOOL bSet);
    BOOL    IsInClearDocFeedEditSession() {return m_fInClearDocFeedEditSession;}

    //
    // GetTextAndAttribute Edit Session
    //
public:
    HRESULT GetTextAndAttribute(HIMC hIMC, CWCompString* wCompString, CWCompAttribute* wCompAttribute);
    HRESULT GetTextAndAttribute(HIMC hIMC, CBCompString* bCompString, CBCompAttribute* bCompAttribute);

    //
    // GetCursorPosition Edit Session
    //
public:
    HRESULT GetCursorPosition(HIMC hIMC, CWCompCursorPos* wCursorPosition);

    //
    // GetSelection Edit Session
    //
public:
    HRESULT GetSelection(HIMC hIMC, CWCompCursorPos& wStartSelection, CWCompCursorPos& wEndSelection);

public:
    BOOL IsTopNow()
    {
        BOOL bRet = FALSE;
        ITfContext *pic;
        if (SUCCEEDED(m_pdim->GetTop(&pic)))
        {
            bRet = (pic == m_pic) ? TRUE : FALSE;
            pic->Release();
        }
        return bRet;
    }

    //
    // Get ImmIfIME interface pointer.
    //
public:
    ImmIfIME* const GetImmIfIME()
    {
        return m_pImmIfIME;
    }

    //
    // QueryCharPos
    //
public:
    typedef enum {
        IME_QUERY_POS_UNKNOWN = 0,
        IME_QUERY_POS_NO      = 1,
        IME_QUERY_POS_YES     = 2
    } IME_QUERY_POS;

    HRESULT InquireIMECharPosition(HIMC hIMC, IME_QUERY_POS* pfQueryPos);
    HRESULT RetrieveIMECharPosition(HIMC hIMC, IMECHARPOSITION* ip);
    HRESULT ResetIMECharPosition(HIMC hIMC)
    {
        m_fQueryPos = IME_QUERY_POS_UNKNOWN;
        return S_OK;
    }

private:
    BOOL QueryCharPos(HIMC hIMC, IMECHARPOSITION* position);


private:
    HIMC                      m_hImc;

    //
    // IActiveIME context
    //
    ImmIfIME                  *m_pImmIfIME;

    //
    // Cicero's context
    //
    ITfDocumentMgr            *m_pdim;           // Document Manager
    ITfContext                *m_pic;            // Input Context
    ITfContextOwnerServices   *m_piccb;          // Context owner service from m_pic

    //
    // Cicero's event sink callback
    //
    CInputContextOwnerCallBack      *m_pICOwnerSink;          // IC owner call back

    CTextEventSinkCallBack          *m_pTextEventSink;        // Text event sink callback

    CThreadMgrEventSinkCallBack     *m_pThreadMgrEventSink;   // Thread manager event sink callback

    CCompartmentEventSinkCallBack   *m_pCompartmentEventSink; // Compartment event sink callback

    CStartReconversionNotifySink    *m_pStartReconvSink;

    //
    // Generate message
    //
public:
    UINT TranslateImeMessage(HIMC hIMC, LPTRANSMSGLIST lpTransMsgList = NULL);

    CFirstInFirstOut<TRANSMSG, TRANSMSG>    *m_pMessageBuffer;

    //
    // Mouse sink
    //
    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, HIMC hIMC);

    //
    // Editing VK list.
    //
public:
    BOOL IsVKeyInKeyList(UINT uVKey, UINT uEditingId = 0)
    {
        UINT uRetEditingId;

        if (uRetEditingId = _IsVKeyInKeyList(uVKey, m_pEditingKeyList)) {
            if (uEditingId == 0 ||
                uEditingId == uRetEditingId)
                return TRUE;
        }

        return FALSE;
    }

private:
    HRESULT SetupEditingKeyList(LANGID LangId);

    VOID QueryRegKeyValue(CRegKey& reg, LPCTSTR lpszRegVal, UINT uEditingId)
    {
        TCHAR  szValue[128];
        DWORD  dwCount = sizeof(szValue);
        LONG   lRet;
        lRet = reg.QueryValue(szValue, lpszRegVal, &dwCount);
        if (lRet == ERROR_SUCCESS && dwCount > 0) {

            LPTSTR psz = szValue;
            while ((dwCount = lstrlen(psz)) > 0) {
                UINT uVKey = atoi(psz);
                if (uVKey != 0) {
                    m_pEditingKeyList->SetAt(uVKey, uEditingId);
                }
                psz += dwCount + 1;
            }
        }
    }

    VOID QueryResourceDataValue(LANGID LangId, DWORD dwID, UINT uEditingId)
    {
        HINSTANCE hInstance = GetInstance();
        LPTSTR    lpName = (LPTSTR) (ULONG_PTR)dwID;

        HRSRC hRSrc = FindResourceEx(hInstance, RT_RCDATA, lpName, LangId);
        if (hRSrc == NULL) {
            return;
        }

        HGLOBAL hMem = LoadResource(hInstance, hRSrc);
        if (hMem == NULL)
            return;

        WORD* pwData = (WORD*)LockResource(hMem);

        while (*pwData) {
            if (*(pwData+1) == uEditingId) {
                m_pEditingKeyList->SetAt(*pwData, uEditingId);
            }
            pwData += 2;
        }
    }

    UINT _IsVKeyInKeyList(UINT uVKey, CMap<UINT, UINT, UINT, UINT>* map)
    {
        UINT flag;
        if (map && map->Lookup(uVKey, flag))
            return flag;
        else
            return 0;
    }

    TfClientId GetClientId();

private:
    CMap<UINT,                     // class KEY       <Virtual Key>
         UINT,                     // class ARG_KEY
         UINT,                     // class VALUE     <Editing Identification>
         UINT                      // class ARG_VALUE
        >* m_pEditingKeyList;

private:
    // void AssocFocus(HWND hWnd, ITfDocumentMgr* pdim);

    //
    // Mode bias
    //
public:
    LPARAM lModeBias;

    //
    // Flags
    //
public:
    BOOL   m_fStartComposition : 1;        // TRUE: already sent WM_IME_STARTCOMPOSITION.
    BOOL   m_fOpenCandidateWindow : 1;     // TRUE: opening candidate list window.
    BOOL   m_fInReconvertEditSession : 1;  // TRUE: In reconvert edit session.
    BOOL   m_fInClearDocFeedEditSession : 1;  // TRUE: In ClearDocFeed edit session.
#ifdef CICERO_4732
    BOOL   m_fInCompComplete : 1;             // TRUE: In CompComplete running.
#endif

    BOOL   m_fHanjaReConversion;
#ifdef UNSELECTCHECK
    BOOL   m_fSelected : 1;   // TRUE: if this context is selected.
#endif UNSELECTCHECK

    IME_QUERY_POS   m_fQueryPos;           // Apps support QueryCharPos().

    int _cCompositions;
    BOOL _fModifyingDoc;

    //
    // IME share.
    //
    USHORT      usGuidMapSize;
    TfGuidAtom  aGuidMap[256];    // GUIDATOM map to IME Attribute

};

#endif // _CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\a_comp.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_comp.cpp

Abstract:

    This file implements the ImmIfIME Class's key handling routine and make an edit session.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "immif.h"
#include "template.h"
#include "editses.h"
#include "resource.h"




inline
BOOL
ImmIfIME::_WantThisKey(
    IMCLock& imc,
    UINT uVKey,
    BOOL* pfNextHook     // default value is NULL
    )

/*+++

Routine Description:

    Check essential virtual key code for the win32 layer's key handling routine.

Arguments:

    uVKey - [in] Unsigned integer value that virtual key code.
    pfNextHool - [out] Address of bool that flag for next hook.
                       Specifies TRUE,  dimm12!CCiceroIME::KeyboardHook calls CallNextHookEx.
                       Specifies FALSE, dimm12!CCiceroIME::KeyboardHook doesn't call CallNextHookEx.
                                        This means this key code eaten by dimm.

Return Value:

    Returns true if essential vkey, or false unessential.

---*/

{
    LANGID langid;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (pfNextHook != NULL)
        *pfNextHook = FALSE;

    if (ptls == NULL)
        return false;

    ptls->pAImeProfile->GetLangId(&langid);
    if (PRIMARYLANGID(langid) == LANG_KOREAN)
        return false;

    //
    // Finalize the composition string
    // Cancel the composition string
    //
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);
    if (_pAImeContext == NULL)
        return false;

    if (!_pAImeContext->IsTopNow())
        return false;

    if (_pAImeContext->IsVKeyInKeyList(uVKey) ||
        BYTE(uVKey) == VK_BACK ||
        BYTE(uVKey) == VK_DELETE ||
        BYTE(uVKey) == VK_LEFT ||
        BYTE(uVKey) == VK_RIGHT)
    {
        /*
         * If we don't have a composition string, then we should calls next hook.
         */
        if (! _pAImeContext->m_fStartComposition) {
            if (pfNextHook != NULL &&
                (_pAImeContext->IsVKeyInKeyList(uVKey, EDIT_ID_HANJA) ||
                 BYTE(uVKey) == VK_LEFT ||
                 BYTE(uVKey) == VK_RIGHT) ) {
                *pfNextHook = TRUE;
            }
            return false;
        }

        return true;
    }

    return false;
}

STDAPI
ImmIfIME::ProcessKey(
    HIMC hIMC,
    UINT uVKey,
    DWORD lKeyData,
    LPBYTE lpbKeyState
    )

/*++

Method:

    IActiveIME::ProcessKey

Routine Description:

    Preprocesses all the keystrokes given through the Active Input Method Manager.

Arguments:

    hIMC - [in] Handle to the input context.
    uVKey - [in] Unsigned integer value that specifies the virtual key to be processed.
    lKeyData - [in] Unsigned long integer value that specifies additional message information.
                    This is the repeat count, scan code, extended-key flag, context code,
                    previous key-state flag, and transition-state flag.
                        0-15 : Specifies the repeat count.
                       16-23 : Specifies the scan code.
                          24 : Specifies whether the key is an extended key.
                       25-28 : Reserved.
                          29 : Specifies the context code.
                          30 : Specifies the previous key state.
                          31 : Specifies the transition state.
    lpbKeyState - [in] Address of a 256-byte array that contains the current keyboard state.
                       The Active Input Method Editor should not modify the content of the key
                       state.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    BOOL fEaten;
    BOOL fKeysEnabled;
    HRESULT hr;

    // has anyone disabled system key feeding?
    if (m_tim->IsKeystrokeFeedEnabled(&fKeysEnabled) == S_OK && !fKeysEnabled)
        return S_FALSE;

    if (HIWORD(lKeyData) & KF_UP)
        hr = m_pkm->TestKeyUp(uVKey, lKeyData, &fEaten);
    else
        hr = m_pkm->TestKeyDown(uVKey, lKeyData, &fEaten);

    if (hr == S_OK && fEaten) {
        return S_OK;
    }

    if (!fEaten)
    {
        IMCLock imc(hIMC);
        if (SUCCEEDED(hr=imc.GetResult()))
        {
           if (imc->m_pAImeContext)
               m_tim->RequestPostponedLock(imc->m_pAImeContext->GetInputContext());
        }
    }


    if ((HIWORD(lKeyData) & KF_UP) ||
        (HIWORD(lKeyData) & KF_ALTDOWN)) {
        return S_FALSE;
    }

    if (! (HIWORD(lKeyData) & KF_UP)) {
        if (_WantThisKey(hIMC, uVKey)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


HRESULT
ImmIfIME::ToAsciiEx(
    UINT uVirKey,
    UINT uScanCode,
    BYTE *pbKeyState,
    UINT fuState,
    HIMC hIMC,
    DWORD* pdwTransBuf,
    UINT *puSize
    )

/*++

Method:

    IActiveIME::ToAsciiEx

Routine Description:

    Generates a conversion result through the Active Input Method Editor (IME) conversion
    engine according to the hIMC parameter.

Arguments:

    uVirKey - [in] Unsigned integer value that specifies the virtual key code to be translated.
                   // HIWORD(uVirKey) : if IME_PROP_KBD_CHAR_FIRST property,
                                        then hiword is translated char code of VKey.
                   // LOWORD(uVirKey) : Virtual Key code.
    uScanCode - [in] Unsigned integer value that specifies the hardware scan code of the key to
                     be translated.
    pbKeyState - [in] Address of a 256-byte array that contains the current keyboard state.
                      The Active IME should not modify the content of the key state.
    fuState - [in] Unsigned integer value that specifies the active menu flag.
    hIMC - [in] Handle to the input context.
    pdwTransBuf - [out] Address of an unsigned long integer value that receives the translated
                        result.
    puSize - [out] Address of an unsigned integer value that receives the number of messages.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

{
    return ToAsciiEx(uVirKey,
                     uScanCode,
                     pbKeyState,
                     fuState,
                     hIMC,
                     (TRANSMSGLIST*)pdwTransBuf,
                     puSize);
}

HRESULT
ImmIfIME::ToAsciiEx(
    UINT uVirKey,
    UINT uScanCode,
    BYTE *pbKeyState,
    UINT fuState,
    HIMC hImc,
    TRANSMSGLIST *pdwTransBuf,
    UINT *puSize
    )
{
    *puSize = 0;
    return _ToAsciiEx(hImc, uVirKey, uScanCode,
                      pdwTransBuf, puSize);
}


HRESULT
ImmIfIME::_ToAsciiEx(
    HIMC hImc,
    UINT uVKey,
    UINT uScanCode,
    TRANSMSGLIST *pdwTransBuf,
    UINT *puSize
    )

/*+++

Arguments:

    uVKey - [in] Unsigned integer value that specifies the virtual key code to be translated.
                 // HIWORD(uVirKey) : if IME_PROP_KBD_CHAR_FIRST property,
                                      then hiword is translated char code of VKey.
                 // LOWORD(uVirKey) : Virtual Key code.

Return Value:

    Returns S_FALSE, dimm12!CCiceroIME::KeyboardHook calls CallNextHookEx.
    Returns S_OK,    dimm12!CCiceroIME::KeyboardHook doesn't call CallNextHookEx.
                     This means this key code eaten by dimm.

---*/

{
    BOOL fEaten;
    HRESULT hr;

    IMCLock imc(hImc);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);
    if (! _pAImeContext)
        return S_FALSE;

    //
    // Backup the m_fOpenCandidateWindow flag.
    // If open the candidate list and press "Cancel" key, Kana TIP would want to
    // close candidate UI window in the KeyDown() action.
    // Candidate UI calss maybe call m_pdim->Pop() and this function notify to
    // the ThreadMgrEventSinkCallback.
    // Win32 layer advised this callback and toggled m_fOpenCandidateWindow flag.
    // Win32 layer doesn't know candidate status after KeyDown() call.
    //
    BOOL fOpenCandidateWindow = _pAImeContext->m_fOpenCandidateWindow;

    //
    // If candidate window were open, send IMN_CHANGECANDIDATE message.
    // In the case of PPT's centering composition string, it expect IMN_CHANGECANDIDATE.
    //
    if (fOpenCandidateWindow &&
        *puSize < pdwTransBuf->uMsgCount) {
        TRANSMSG* pTransMsg = &pdwTransBuf->TransMsg[*puSize];
        pTransMsg->message = WM_IME_NOTIFY;
        pTransMsg->wParam  = IMN_CHANGECANDIDATE;
        pTransMsg->lParam  = 1;  // bit 0 to first candidate list.
        (*puSize)++;
    }

    //
    // AIMM put char code in hiword. So we need to bail it out.
    //
    // if we don't need charcode, we may want to 
    // remove IME_PROP_KBD_CHAR_FIRST.
    //
    uVKey = uVKey & 0xffff;

#ifdef CICERO_3564
    if ((uVKey == VK_PROCESSKEY) &&
        _pAImeContext->m_fStartComposition)
    {
        /*
         * KOREAN:
         *  Finalize current composition string
         */
        IMTLS *ptls = IMTLS_GetOrAlloc();
        if (ptls == NULL)
            return S_FALSE;
        if (ptls->pAImeProfile == NULL)
            return S_FALSE;

        LANGID langid;
        ptls->pAImeProfile->GetLangId(&langid);
        if (PRIMARYLANGID(langid) == LANG_KOREAN)
        {
            //
            // Composition complete.
            //
            _CompComplete(imc, FALSE);    // ASYNC
            return S_OK;
        }
    }
#endif // CICERO_3564

    //
    // consider: dimm12 set high bit oflower WORD at keyup.
    //
    if (uScanCode & KF_UP)
        hr = m_pkm->KeyUp(uVKey, (uScanCode << 16), &fEaten);
    else
        hr = m_pkm->KeyDown(uVKey, (uScanCode << 16), &fEaten);

    if (hr == S_OK && fEaten) {
        return S_OK;
#if 0
        // We don't need EDIT_ID_FINALIZE anymore
        // since AIMM1.2 detect composition object by GUID_PROP_COMPOSING 

        //
        // If press the Enter key, AIMM layer finalize composition string.
        // or
        // If press the Escape key, AIMM layer cancel composition string.
        //
        if (! _pAImeContext->IsVKeyInKeyList(uVKey))
            //
            // Neither Finalize nor Cancel this key eaten.
            //
            return S_OK;
        else if (fOpenCandidateWindow)
            //
            // If candidate list opend, we don't want finalize a string.
            //
            return S_OK;
#endif
    }


    //
    // we want to process all events that were requested by pAimeContext
    // during KeyDwon() or KeyUp, if TIP did not eat the key.
    //
    // This can keep WM_IME_COMPOSITION/WM_IME_ENDCOMPOSITION message
    // order.
    //
    if (!fEaten)
        m_tim->RequestPostponedLock(_pAImeContext->GetInputContext());

    if (!(HIWORD(uScanCode) & KF_UP)) {
        BOOL fNextHook;
        if (_WantThisKey(imc, uVKey, &fNextHook)) {
            _HandleThisKey(imc, uVKey);
        }
        hr = fNextHook ? S_FALSE    // Call next hook
                       : S_OK;      // Stop next hook
    }

    return hr;
}



HRESULT
ImmIfIME::_HandleThisKey(
    IMCLock& imc,
    UINT uVKey
    )

/*+++

Routine Description:

    Handle the virtual key in the edit session.

Arguments:

---*/

{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_HANDLETHISKEY,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                        uVKey);
}







HRESULT
ImmIfIME::_CompCancel(
    IMCLock& imc
    )

/*+++

Routine Description:

    Cancel the composition string in the hIMC.

Arguments:

---*/

{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_COMPCANCEL,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC);
}




HRESULT
ImmIfIME::_CompComplete(
    IMCLock& imc,
    BOOL fSync        // defalut value is TRUE
    )

/*+++

Routine Description:

    Complete the composition string in the hIMC.

Arguments:

    fSync - [in] TRUE,  Create synchronized edit session.
                 FALSE, Create ansynchronized edit session.

---*/

{
    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_COMPCOMPLETE,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    return _pEditSession->RequestEditSession(TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0), fSync == TRUE);
}




HRESULT
ImmIfIME::Internal_SetCompositionString(
    CWCompString& wCompStr,
    CWCompString& wCompReadStr
    )
{
    HRESULT hr;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_REPLACEWHOLETEXT,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                      &wCompStr);
    if (FAILED(hr))
        return hr;

    return _UpdateCompositionString();
}


//
// Get all text and attribute from TOM and update the composition
// string.
//
HRESULT
ImmIfIME::_UpdateCompositionString(
    DWORD dwDeltaStart
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();
    HRESULT hr;

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_UPDATECOMPOSITIONSTRING,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)

    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    //
    // This method should not set synchronize mode becuase the edit session call back routine
    // modify a text in the input context.
    //
    return _pEditSession->RequestEditSession(TF_ES_READWRITE,
                                        (UINT)dwDeltaStart);
}





//
// Internal Reconvert String
//
HRESULT
ImmIfIME::Internal_ReconvertString(
    IMCLock& imc,
    CWReconvertString& wReconvStr,
    CWReconvertString& wReconvReadStr
    )
{
    HRESULT hr;
    Interface<ITfRange> Selection;
    Interface<ITfFunctionProvider> FuncProv;
    Interface<ITfFnReconversion> Reconversion;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_RECONVERTSTRING,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    _pAImeContext->SetReconvertEditSession(TRUE);

    hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                      &wReconvStr, &Selection, FALSE);
    if (FAILED(hr))
        goto Exit;

    hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
    if (FAILED(hr))
        goto Exit;

    hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
    if (SUCCEEDED(hr)) {
        Interface<ITfRange> RangeNew;
        BOOL fConvertable;
        hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
        if (SUCCEEDED(hr) && fConvertable) {
            hr = Reconversion->Reconvert(RangeNew);
        }
        else {
            DebugMsg(TF_ERROR, "Internal__ReconvertString: QueryRange failed so the compoisiton string will be completed.");
            _CompComplete(imc, TRUE);
            hr = E_FAIL;
        }
    }

Exit:
    _pAImeContext->SetReconvertEditSession(FALSE);
    return hr;
}

// static
HRESULT
ImmIfIME::Internal_QueryReconvertString_ICOwnerSink(
    UINT uCode,
    ICOARGS *pargs,
    VOID *pv
    )
{
    switch (uCode)
    {
        case ICO_STATUS:
            pargs->status.pdcs->dwDynamicFlags = 0;
            pargs->status.pdcs->dwStaticFlags = TF_SS_TRANSITORY;
            break;
    }

    return S_OK;
}

//
// Internal Query Reconvert String
//
HRESULT
ImmIfIME::Internal_QueryReconvertString(
    IMCLock& imc,
    RECONVERTSTRING *pReconv,
    UINT cp,
    BOOL fNeedAW
    )
{
    HRESULT hr;

    CWReconvertString wReconvStr(cp, 
                                 imc, 
                                 !fNeedAW ? pReconv : NULL, 
                                 !fNeedAW ? pReconv->dwSize : 0);
    if (fNeedAW)
    {
        //
        // convert Ansi to Unicode.
        //
        CBReconvertString bReconvStr(cp, imc, pReconv, pReconv->dwSize);
        wReconvStr = bReconvStr;
    }

    IMTLS *ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    //
    // Create document manager.
    //
    Interface<ITfDocumentMgr> pdim;           // Document Manager
    if (FAILED(hr = m_tim->CreateDocumentMgr(pdim)))
        return hr;

    //
    // Create input context
    //
    Interface<ITfContext> pic;                // Input Context
    TfEditCookie ecTmp;
    hr = pdim->CreateContext(m_tfClientId, 0, NULL, pic, &ecTmp);
    if (FAILED(hr))
        return hr;

    //
    // Create Input Context Owner Callback
    //
    CInputContextOwner *_pICOwnerSink;          // IC owner call back

    _pICOwnerSink = new CInputContextOwner(Internal_QueryReconvertString_ICOwnerSink, NULL);
    if (_pICOwnerSink == NULL) {
        DebugMsg(TF_ERROR, "Couldn't create ICOwnerSink tim!");
        Assert(0); // couldn't activate thread!
        return E_FAIL;
    }

    //
    // Advise IC.
    //
    _pICOwnerSink->_Advise(pic);

    //
    // Push IC.
    //
    ptls->m_fMyPushPop = TRUE;
    hr = pdim->Push(pic);
    ptls->m_fMyPushPop = FALSE;
    if (SUCCEEDED(hr)) {

        Interface<ITfDocumentMgr> priv_dim;
        if (SUCCEEDED(hr=m_tim->GetFocus(priv_dim)) &&
            SUCCEEDED(hr=m_tim->SetFocus(pdim)))
        {

            Interface_Attach<ITfContext> _pic(pic);
            Interface_Creator<ImmIfEditSession> _pEditSessionQueryConvertString(
                new ImmIfEditSession(ESCB_QUERYRECONVERTSTRING,
                                     m_tfClientId,
                                     GetCurrentInterface(),
                                     imc,
                                     _pic)
            );
            if (_pEditSessionQueryConvertString.Invalid()) {
                hr = E_FAIL;
            }
            else {

                Interface<ITfRange> Selection;
                hr = _pEditSessionQueryConvertString->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                                  &wReconvStr, &Selection, FALSE);

                if (S_OK == hr)
                {
                    Interface<ITfFunctionProvider> FuncProv;
                    Interface<ITfFnReconversion> Reconversion;
                    hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
                    if (S_OK == hr)
                    {
                        hr = FuncProv->GetFunction(GUID_NULL,
                                       IID_ITfFnReconversion,
                                       (IUnknown**)(ITfFnReconversion**)Reconversion);
                    }
                    if (S_OK == hr) {
                        Interface<ITfRange> RangeNew;
                        BOOL fConvertable;
                        hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                        if (SUCCEEDED(hr) && fConvertable) {
                            //
                            // Calcurate start position of RangeNew on text store
                            //
                            Interface_Creator<ImmIfEditSession> _pEditSession(
                                new ImmIfEditSession(ESCB_CALCRANGEPOS,
                                                     m_tfClientId,
                                                     GetCurrentInterface(),
                                                     imc,
                                                     _pic)
                            );
                            if (_pEditSession.Valid()) {
                                hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                                                  &wReconvStr, &RangeNew, FALSE);
                            }
                            else {
                                hr = E_FAIL;
                            }
                        }
                        else {
                            hr = E_FAIL;
                        }
                    }
                }
            }
        }

        if (S_OK == hr)
        {
            if (fNeedAW) {
                //
                // Back to convert Unicode to Ansi.
                //
                CBReconvertString bReconvStr(cp, imc, NULL, 0);
                bReconvStr = wReconvStr;

                bReconvStr.ReadCompData(pReconv, pReconv->dwSize);
            }
            else {
                wReconvStr.ReadCompData(pReconv, pReconv->dwSize);
            }
        }

        m_tim->SetFocus(priv_dim);

        m_tim->RequestPostponedLock(pic);
        if (imc->m_pAImeContext)
            m_tim->RequestPostponedLock(imc->m_pAImeContext->GetInputContext());

        ptls->m_fMyPushPop = TRUE;
        pdim->Pop(TF_POPF_ALL);
        ptls->m_fMyPushPop = FALSE;
    }

    // ic owner is auto unadvised during the Pop by cicero
    // in any case, it must not be unadvised before the pop
    // since it will be used to handle mouse sinks, etc.
    if (_pICOwnerSink) {
        _pICOwnerSink->_Unadvise();
        _pICOwnerSink->Release();
        _pICOwnerSink = NULL;
    }

    return hr;
}




//
// Setup reconversion string
//
// This function called from
//   1. CFnDocFeed::StartReconvert
//   2. CStartReconversionNotifySink::StartReconversion
//   3. CIMEUIWindowHandler::ImeUIMsImeHandler(WM_MSIME_RECONVERTREQUEST)
//
// If Cicero's text store were not cleared, then compositioning and unessential query
// RECONVERTSTRING to apprication. Also edit session (ImmIfReconvertString::ReconvertString)
// doesn't set RECONVERTSTRING text string to hIMC's text store.
//

HRESULT 
ImmIfIME::SetupReconvertString(
    ITfContext *pic,
    IMCLock& imc,
    UINT  uPrivMsg        // is WM_MSIME_RECONVERTREQUEST or 0
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    _pAImeContext->SetReconvertEditSession(TRUE);

    if (_pAImeContext->m_fStartComposition)
        return _ReconvertStringTextStore(pic, imc, uPrivMsg);
    else
        return _ReconvertStringNegotiation(pic, imc, uPrivMsg);
}

//
// End reconversion string
//
HRESULT 
ImmIfIME::EndReconvertString(
    IMCLock& imc
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    _pAImeContext->SetReconvertEditSession(FALSE);
    return S_OK;
}

HRESULT
ImmIfIME::_ReconvertStringNegotiation(
    ITfContext *pic,
    IMCLock& imc,
    UINT  uPrivMsg
    )
{
    RECONVERTSTRING *pReconv = NULL;
    HRESULT hr = E_FAIL;
    int nSize;

    UINT uReconvMsg = uPrivMsg != 0 ? uPrivMsg : WM_IME_REQUEST;

    Assert(IsWindow(imc->hWnd));

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    nSize = (int)SendMessage(imc->hWnd,  uReconvMsg, IMR_RECONVERTSTRING, NULL);
    if (!nSize)
    {
        return S_OK;
    }

    pReconv = (RECONVERTSTRING *)cicMemAllocClear(nSize);
    if (!pReconv)
    {
        return E_OUTOFMEMORY;
    }

    pReconv->dwSize = nSize;

    if (SendMessage(imc->hWnd, uReconvMsg, IMR_RECONVERTSTRING, (LPARAM)pReconv) || (uPrivMsg != 0 && pReconv->dwCompStrLen > 0))
    {
        UINT cp = CP_ACP;
        GetCodePageA(&cp);

        //
        // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
        // Any string data doesn't convert between ASCII <--> Unicode.
        // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
        // If ASCII wnd proc, then returns ASCII string.
        // Otherwise if Unicode wnd proc, returns Unicode string.
        //
        BOOL fNeedAW = ( !(IsOnNT() && IsWindowUnicode(imc->hWnd)) && uPrivMsg == 0);

        //
        // backup RECOVNERTSTRING in case IMR_CONFIRMCONVERTSTRING fails.
        //
        RECONVERTSTRING rsBackUp;
        memcpy(&rsBackUp, pReconv, sizeof(RECONVERTSTRING));

        // AdjustZeroCompLenReconvertString(pReconv, cp, fNeedAW);
        hr = Internal_QueryReconvertString(imc, pReconv, cp, fNeedAW);
        if (FAILED(hr))
            goto Exit;

        if (!SendMessage(imc->hWnd, uReconvMsg, IMR_CONFIRMRECONVERTSTRING, (LPARAM)pReconv))
        {
            memcpy(pReconv, &rsBackUp, sizeof(RECONVERTSTRING));
        }

        Interface<ITfRange> Selection;


        CWReconvertString wReconvStr(cp, 
                                     imc, 
                                     !fNeedAW ? pReconv : NULL, 
                                     !fNeedAW ? nSize : 0);
        if (fNeedAW)
        {
            //
            // convert Ansi to Unicode.
            //
            CBReconvertString bReconvStr(cp, imc, pReconv, nSize);
            wReconvStr = bReconvStr;
        }

        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_RECONVERTSTRING,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Invalid())
        {
            hr = E_FAIL;
            goto Exit;
        }

        hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                          &wReconvStr, &Selection, FALSE);

        if (S_OK == hr && uPrivMsg != 0)
        {
            Interface<ITfFunctionProvider> FuncProv;
            Interface<ITfFnReconversion> Reconversion;
            hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
            if (S_OK == hr)
            {

                hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
            }
            if (S_OK == hr) {
                Interface<ITfRange> RangeNew;
                BOOL fConvertable;
                hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                if (SUCCEEDED(hr) && fConvertable) {
                    hr = Reconversion->Reconvert(RangeNew);
                }
                else {
                    _CompComplete(imc, TRUE);
                    hr = E_FAIL;
                    goto Exit;
                }
            }
        }
    }

Exit:
    if (pReconv)
        cicMemFree(pReconv);

    return hr;
}

HRESULT
ImmIfIME::_ReconvertStringTextStore(
    ITfContext *pic,
    IMCLock& imc,
    UINT  uPrivMsg
    )
{
    //
    // Clear DocFeed buffer
    //
    ClearDocFeedBuffer(pic, imc);

    if (uPrivMsg != 0) {
        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_GETSELECTION,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Invalid())
            return E_FAIL;

        Interface<ITfRange> Selection;
        HRESULT hr =  _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                                   &Selection);
        if (S_OK == hr)
        {
            Interface<ITfFunctionProvider> FuncProv;
            Interface<ITfFnReconversion> Reconversion;
            hr = m_tim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, FuncProv);
            if (S_OK == hr)
            {
                hr = FuncProv->GetFunction(GUID_NULL,
                               IID_ITfFnReconversion,
                               (IUnknown**)(ITfFnReconversion**)Reconversion);
            }
            if (S_OK == hr) {
                Interface<ITfRange> RangeNew;
                BOOL fConvertable;
                hr = Reconversion->QueryRange(Selection, RangeNew, &fConvertable);
                if (SUCCEEDED(hr) && fConvertable) {
                    hr = Reconversion->Reconvert(RangeNew);
                }
                else {
                    _CompComplete(imc, TRUE);
                    return E_FAIL;
                }
            }
        }
    }
    return S_OK;
}

//
// Setup docfeed string
//
HRESULT 
ImmIfIME::SetupDocFeedString(
    ITfContext *pic,
    IMCLock& imc)
{
    RECONVERTSTRING *pReconv = NULL;
    HRESULT hr = E_FAIL;
    int nSize;

    Assert(IsWindow(imc->hWnd));

    nSize = (int)SendMessage(imc->hWnd, WM_IME_REQUEST, IMR_DOCUMENTFEED, NULL);
    if (!nSize)
    {
        return S_OK;
    }

    pReconv = (RECONVERTSTRING *)cicMemAllocClear(nSize);
    if (!pReconv)
    {
        return E_OUTOFMEMORY;
    }

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    if (SendMessage(imc->hWnd, WM_IME_REQUEST, IMR_DOCUMENTFEED, (LPARAM)pReconv))
    {
        UINT cp = CP_ACP;
        GetCodePageA(&cp);
        Interface<ITfRange> Selection;

        //
        // NT4 and Win2K doesn't have thunk routine of WM_IME_REQUEST message.
        // Any string data doesn't convert between ASCII <--> Unicode.
        // Responsibility of string data type have receiver window proc (imc->hWnd) of this message.
        // If ASCII wnd proc, then returns ASCII string.
        // Otherwise if Unicode wnd proc, returns Unicode string.
        //
        BOOL fNeedAW = !(IsOnNT() && IsWindowUnicode(imc->hWnd));

        CWReconvertString wReconvStr(cp, 
                                     imc, 
                                     !fNeedAW ? pReconv : NULL, 
                                     !fNeedAW ? nSize : 0);
        if (fNeedAW)
        {
            //
            // convert Ansi to Unicode.
            //
            CBReconvertString bReconvStr(cp, imc, pReconv, nSize);
            wReconvStr = bReconvStr;
        }

        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_RECONVERTSTRING,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Invalid())
        {
            hr = E_FAIL;
            goto Exit;
        }

        hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                          &wReconvStr, &Selection, TRUE);

    }

Exit:
    if (pReconv)
        cicMemFree(pReconv);

    return S_OK;
}

//
// Setup docfeed string
//
HRESULT 
ImmIfIME::ClearDocFeedBuffer(
    ITfContext *pic,
    IMCLock& imc,
    BOOL fSync        // defalut value is TRUE
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_CLEARDOCFEEDBUFFER,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
    {
        goto Exit;
    }

    _pAImeContext->SetClearDocFeedEditSession(TRUE);
    hr = _pEditSession->RequestEditSession(TF_ES_READWRITE | (fSync ? TF_ES_SYNC : 0));
    _pAImeContext->SetClearDocFeedEditSession(FALSE);

Exit:
    return hr;
}

//
// GetTextAndString Edit Session
//
HRESULT
ImmIfIME::GetTextAndAttribute(
    IMCLock& imc,
    CWCompString* wCompString,
    CWCompAttribute* wCompAttribute
    )
{
    HRESULT hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GETTEXTANDATTRIBUTE,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                      wCompString, wCompAttribute);
    return hr;
}

HRESULT
ImmIfIME::GetTextAndAttribute(
    IMCLock& imc,
    CBCompString* bCompString,
    CBCompAttribute* bCompAttribute
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    UINT cp;
    ptls->pAImeProfile->GetCodePageA(&cp);

    CWCompString wCompString(cp);
    CWCompAttribute wCompAttribute(cp);

    HRESULT hr = GetTextAndAttribute(imc,
                                     &wCompString, &wCompAttribute);
    if (SUCCEEDED(hr)) {
        //
        // Convert Unicode to ASCII.
        //
        LONG num_of_written = (LONG)wCompString.ReadCompData();
        WCHAR* buffer = new WCHAR[ num_of_written ];
        if (buffer != NULL) {
            wCompString.ReadCompData(buffer, num_of_written);

            wCompAttribute.m_wcompstr.WriteCompData(buffer, num_of_written);

            *bCompString = wCompString;
            *bCompAttribute = wCompAttribute;

            delete [] buffer;
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//
// GetCursorPosition Edit Session
//
HRESULT
ImmIfIME::GetCursorPosition(
    IMCLock& imc,
    CWCompCursorPos* wCursorPosition
    )
{
    HRESULT hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GET_CURSOR_POSITION,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                      wCursorPosition);
    return hr;
}


//
// GetSelection Edit Session
//
HRESULT
ImmIfIME::GetSelection(
    IMCLock& imc,
    CWCompCursorPos& wStartSelection,
    CWCompCursorPos& wEndSelection
    )
{
    HRESULT hr;

    Interface_Creator<ImmIfEditSession> _pEditSession(
        new ImmIfEditSession(ESCB_GETSELECTION,
                             m_tfClientId,
                             GetCurrentInterface(),
                             imc)
    );
    if (_pEditSession.Invalid())
        return E_FAIL;

    Interface<ITfRange> Selection;
    hr = _pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                      &Selection);
    if (S_OK == hr) {
        //
        // Calcurate start position of RangeNew on text store
        //
        Interface_Creator<ImmIfEditSession> _pEditSession2(
            new ImmIfEditSession(ESCB_CALCRANGEPOS,
                                 m_tfClientId,
                                 GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession2.Valid()) {
            UINT cp = CP_ACP;
            GetCodePageA(&cp);
            CWReconvertString wReconvStr(cp, imc);
            hr = _pEditSession2->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                               &wReconvStr, &Selection, FALSE);
            if (S_OK == hr) {
                wStartSelection.Set((DWORD) wReconvStr.m_CompStrIndex);
                wEndSelection.Set((DWORD)(wReconvStr.m_CompStrIndex + wReconvStr.m_CompStrLen));
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\a_server.cpp ===
#include "private.h"

#include "globals.h"
#include "immif.h"

const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_PROPSTYLE_STATICCOMPACT, &GUID_PROP_MSIMTF_READONLY},
    {&GUID_TFCAT_PROPSTYLE_STATIC, &GUID_PROP_MSIMTF_TRACKCOMPOSITION},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM, &GUID_PROP_MSIMTF_PREPARE_RECONVERT},
    {NULL, NULL}
};

HRESULT WIN32LR_DllRegisterServer(void)
{
    TRACE0("DllRegisterServer.");

    HRESULT hr;

    hr = RegisterCategories(CLSID_CActiveIMM12, c_rgRegCat);
    if (FAILED(hr)) {
        TRACE0("RegisterCategory: f3");
        goto Exit;
    }

Exit:

    TRACE1("DllRegisterServer: returning with hr=0x%x", hr);
    return hr;
}

HRESULT WIN32LR_DllUnregisterServer(void)
{
    TRACE0("DllUnregisterServer");

    HRESULT hr;

    hr = UnregisterCategories(CLSID_CActiveIMM12, c_rgRegCat);
    if (FAILED(hr)) {
        TRACE0("RegisterCategory: f3");
        goto Exit;
    }

Exit:

    TRACE1("DllUnregisterServer: hr=%x", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\a_context.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    a_context.cpp

Abstract:

    This file implements the CAImeContext Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cime.h"
#include "a_context.h"
#include "editses.h"
#include "immif.h"
#include "idebug.h"
#include "resource.h"
#include "a_wrappers.h"
#include "langct.h"
#include "korimx.h"


//
// Create instance
//

// entry point for msimtf.dll
HRESULT CAImeContext_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return CAImeContext::CreateInstance(pUnkOuter, riid, ppvObj);
}

HRESULT
CAImeContext::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    DebugMsg(TF_FUNC, "CAImeContext::CreateInstance called.");

    *ppvObj = NULL;
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    CAImeContext* pImeContext = new CAImeContext;
    if (pImeContext) {
        HRESULT hr = pImeContext->QueryInterface(riid, ppvObj);

        if (SUCCEEDED(hr)) {
            pImeContext->Release();
        }

        return hr;
    }

    return E_OUTOFMEMORY;
}

//
// Initialization, destruction and standard COM stuff
//

CAImeContext::CAImeContext(
    )
{
    m_ref = 1;

    m_hImc = NULL;

    m_pdim = NULL;           // Document Manager
    m_pic = NULL;            // Input Context
    m_piccb = NULL;          // Context owner service from m_pic

    m_fInReconvertEditSession = FALSE;
#ifdef CICERO_4732
    m_fInCompComplete = FALSE;
#endif

    m_fHanjaReConversion = FALSE;

    m_fQueryPos = IME_QUERY_POS_UNKNOWN;

    _cCompositions = 0;
}

CAImeContext::~CAImeContext()
{
}

HRESULT
CAImeContext::QueryInterface(
    REFIID riid,
    void **ppvObj
    )
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IAImeContext) ||
        IsEqualIID(riid, IID_IUnknown)) {
        *ppvObj = static_cast<IAImeContext*>(this);
    }
    else if (IsEqualIID(riid, IID_ITfCleanupContextSink))
    {
        *ppvObj = static_cast<ITfCleanupContextSink*>(this);
    }
    else if (IsEqualGUID(riid, IID_ITfContextOwnerCompositionSink))
    {
        *ppvObj = static_cast<ITfContextOwnerCompositionSink*>(this);
    }
    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
CAImeContext::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CAImeContext::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

TfClientId CAImeContext::GetClientId()
{ 
    Assert(m_pImmIfIME != NULL);
    return m_pImmIfIME->GetClientId();
}

HRESULT
CAImeContext::CreateAImeContext(
    HIMC hIMC,
    IActiveIME_Private* pActiveIME
    )
{
    TfEditCookie ecTmp;
    ITfSourceSingle *pSourceSingle;
    HRESULT hr;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (hIMC == m_hImc)
        return S_OK;
    else if (m_hImc)
        return E_FAIL;

    m_hImc = hIMC;

    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    m_pImmIfIME = (ImmIfIME*)pActiveIME;
    m_pImmIfIME->AddRef();

    imc->m_pAImeContext = this;

    // do this once for the life time of this context
    m_fStartComposition = FALSE;

    //
    // Create document manager.
    //
    if (m_pdim == NULL) {

        if (FAILED(hr = ptls->tim->CreateDocumentMgr(&m_pdim)))
        {
            m_pImmIfIME->Release();
            return hr;
        }
    }

    // tim should already be activated
    Assert(GetClientId() != TF_CLIENTID_NULL);

    Assert(m_pic == NULL);

    //
    // Create input context
    //
    hr = m_pdim->CreateContext(GetClientId(), 0, (ITfContextOwnerCompositionSink*)this, &m_pic, &ecTmp);
    if (FAILED(hr)) {
        DestroyAImeContext(hIMC);
        return hr;
    }

    //
    // set AppProp mapping
    //
    ITfContext_P *picp;
    if (SUCCEEDED(m_pic->QueryInterface(IID_ITfContext_P, (void **)&picp)))
    {
        picp->MapAppProperty(TSATTRID_Text_ReadOnly, GUID_PROP_MSIMTF_READONLY);
        picp->Release();
    }

    //
    // Create Input Context Owner Callback
    //
    if (m_pICOwnerSink == NULL) {
        m_pICOwnerSink = new CInputContextOwnerCallBack(m_pImmIfIME->_GetLibTLS());
        if (m_pICOwnerSink == NULL) {
            DebugMsg(TF_ERROR, "Couldn't create ICOwnerSink tim!");
            Assert(0); // couldn't activate thread!
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }

        if (!m_pICOwnerSink->Init()) {
            DebugMsg(TF_ERROR, TEXT("Couldn't initialize ICOwnerSink tim!"));
            Assert(0); // couldn't activate thread!
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }

        m_pICOwnerSink->SetCallbackDataPointer(m_pICOwnerSink);
    }

    //
    // Advise IC.
    //
    m_pICOwnerSink->_Advise(m_pic);

    if (m_pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
    {
        // setup a cleanup callback
        // nb: a real tip doesn't need to be this aggressive, for instance
        // kimx probably only needs this sink on the focus ic.
        pSourceSingle->AdviseSingleSink(GetClientId(), IID_ITfCleanupContextSink, (ITfCleanupContextSink *)this);
        pSourceSingle->Release();
    }

    //
    // Push IC.
    //
    ptls->m_fMyPushPop = TRUE;
    hr = m_pdim->Push(m_pic);
    ptls->m_fMyPushPop = FALSE;

    if (m_piccb == NULL) {
        m_pic->QueryInterface(IID_ITfContextOwnerServices,
                              (void **)&m_piccb);
    }

    //
    // Create Text Event Sink Callback
    //
    if (m_pTextEventSink == NULL) {
        m_pTextEventSink = new CTextEventSinkCallBack(m_pImmIfIME, hIMC);
        if (m_pTextEventSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pTextEventSink->SetCallbackDataPointer(m_pTextEventSink);

        Interface_Attach<ITfContext> ic(GetInputContext());
        m_pTextEventSink->_Advise(ic.GetPtr(), ICF_TEXTDELTA);
    }

    //
    // Create Thread Manager Event Sink Callback
    //
    if (m_pThreadMgrEventSink == NULL) {
        m_pThreadMgrEventSink = new CThreadMgrEventSinkCallBack();
        if (m_pThreadMgrEventSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pThreadMgrEventSink->SetCallbackDataPointer(m_pThreadMgrEventSink);
        m_pThreadMgrEventSink->_Advise(ptls->tim);
    }

    //
    // Create Compartment Event Sink Callback
    //
    if (m_pCompartmentEventSink == NULL) {
        m_pCompartmentEventSink = new CCompartmentEventSinkCallBack(m_pImmIfIME);
        if (m_pCompartmentEventSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pCompartmentEventSink->SetCallbackDataPointer(m_pCompartmentEventSink);
        m_pCompartmentEventSink->_Advise(ptls->tim, GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, FALSE);
        m_pCompartmentEventSink->_Advise(ptls->tim, GUID_COMPARTMENT_KORIMX_CONVMODE, FALSE);
    }

    //
    // Create Start reconversion notify Sink
    //
    if (m_pStartReconvSink == NULL) {
        m_pStartReconvSink = new CStartReconversionNotifySink(this);
        if (m_pStartReconvSink == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
        m_pStartReconvSink->_Advise(m_pic);
    }

    //
    // Create Message Buffer
    //
    if (m_pMessageBuffer == NULL) {
        m_pMessageBuffer = new CFirstInFirstOut<TRANSMSG, TRANSMSG>;
        if (m_pMessageBuffer == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
    }

    //
    // Create Editing Key List.
    //
    if (m_pEditingKeyList == NULL) {
        m_pEditingKeyList = new CMap<UINT, UINT, UINT, UINT>;
        if (m_pEditingKeyList == NULL) {
            DestroyAImeContext(hIMC);
            return E_FAIL;
        }
    }

    //
    // Set up Editing key list.
    //
    LANGID langid;
    hr = ptls->pAImeProfile->GetLangId(&langid);
    if (FAILED(hr))
        langid = LANG_NEUTRAL;

    SetupEditingKeyList(langid);

    return hr;
}

HRESULT
CAImeContext::DestroyAImeContext(
    HIMC hIMC
    )
{
    ITfSourceSingle *pSourceSingle;

    if (hIMC != m_hImc)
        return E_FAIL;
    else if (m_hImc == NULL)
        return S_OK;

    IMTLS *ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(hIMC);
    HRESULT hr;
    if (FAILED(hr=imc.GetResult()))
        return hr;

    if (m_pic && m_pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
    {
        pSourceSingle->UnadviseSingleSink(GetClientId(), IID_ITfCleanupContextSink);
        pSourceSingle->Release();
    }

    if (m_pImmIfIME)
    {
        m_pImmIfIME->Release();
        m_pImmIfIME = NULL;
    }

    if (m_pMessageBuffer) {
        delete m_pMessageBuffer;
        m_pMessageBuffer = NULL;
    }

    if (m_pEditingKeyList) {
        delete m_pEditingKeyList;
        m_pEditingKeyList = NULL;
    }

    if (m_pTextEventSink) {
        m_pTextEventSink->_Unadvise();
        m_pTextEventSink->Release();
        m_pTextEventSink = NULL;
    }

    if (m_pThreadMgrEventSink) {
        m_pThreadMgrEventSink->_Unadvise();
        m_pThreadMgrEventSink->Release();
        m_pThreadMgrEventSink = NULL;
    }

    if (m_pCompartmentEventSink) {
        m_pCompartmentEventSink->_Unadvise();
        m_pCompartmentEventSink->Release();
        m_pCompartmentEventSink = NULL;
    }

    if (m_pStartReconvSink) {
        m_pStartReconvSink->_Unadvise();
        m_pStartReconvSink->Release();
        m_pStartReconvSink = NULL;
    }


    if (m_pic) {
        m_pic->Release();
        m_pic = NULL;
    }

    if (m_piccb) {
        m_piccb->Release();
        m_piccb = NULL;
    }

    ptls->m_fMyPushPop = TRUE;
    if (m_pdim)
    {
        hr = m_pdim->Pop(TF_POPF_ALL);
    }
    ptls->m_fMyPushPop = FALSE;


    // ic owner is auto unadvised during the Pop by cicero
    // in any case, it must not be unadvised before the pop
    // since it will be used to handle mouse sinks, etc.
    if (m_pICOwnerSink) {
        m_pICOwnerSink->_Unadvise();
        m_pICOwnerSink->Release();
        m_pICOwnerSink = NULL;
    }

    if (m_pdim)
    {
        m_pdim->Release();
        m_pdim = NULL;
    }

    return S_OK;
}


HRESULT
CAImeContext::UpdateAImeContext(
    HIMC hIMC
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    //
    // Update Editing key list.
    //
    LANGID langid;
    HRESULT hr = ptls->pAImeProfile->GetLangId(&langid);
    if (FAILED(hr))
        langid = LANG_NEUTRAL;

    if (m_pEditingKeyList)
    {
       m_pEditingKeyList->RemoveAll();    // Remove old Editing key list.

       SetupEditingKeyList(langid);
    }

    return S_OK;
}

#if 0
HRESULT
CAImeContext::AssociateFocus(
    HIMC hIMC,
    BOOL fActive
    )
{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    if (fActive) {
        AssocFocus(imc->hWnd, m_pdim);
    }
    else {
        AssocFocus(imc->hWnd, NULL);
    }

    return S_OK;
}
#endif

HRESULT
CAImeContext::MapAttributes(
    HIMC hIMC
    )
{
    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    IMCCLock<COMPOSITIONSTRING_AIMM12> comp(imc->hCompStr);
    if (FAILED(hr = comp.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (! _pAImeContext)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    if (_pAImeContext->usGuidMapSize == 0) {
        //
        // Make transration table.
        //
        _pAImeContext->usGuidMapSize = ATTR_LAYER_GUID_START;

        for (USHORT i = 0; i < comp->dwTfGuidAtomLen; ++i) {
            // Check if this GUID is already registered
            for (USHORT j = ATTR_LAYER_GUID_START; j < _pAImeContext->usGuidMapSize; ++j) {
                if (_pAImeContext->aGuidMap[j] == ((TfGuidAtom*)comp.GetOffsetPointer(comp->dwTfGuidAtomOffset))[i]) {
                    break;
                }
            }

            BYTE bAttr;
            if (j >= _pAImeContext->usGuidMapSize) {
                // Couldn't find the GUID registered.
                if (_pAImeContext->usGuidMapSize < ARRAYSIZE(_pAImeContext->aGuidMap) - 1) {
                    bAttr = static_cast<BYTE>(_pAImeContext->usGuidMapSize);
                    _pAImeContext->aGuidMap[_pAImeContext->usGuidMapSize++] = ((TfGuidAtom*)comp.GetOffsetPointer(comp->dwTfGuidAtomOffset))[i];
                }
                else {
                    // # of GUID exceeds the # of available attribute...
                    // Maybe it should fail, but for now give it a bogus attirbute.
                    bAttr = ATTR_TARGET_CONVERTED;
                }
            }
            else {
                bAttr = static_cast<BYTE>(j);
            }

            ((BYTE*)comp.GetOffsetPointer(comp->dwGuidMapAttrOffset))[i] = bAttr;
        }

        comp->dwGuidMapAttrLen = comp->dwTfGuidAtomLen;
    }

    return S_OK;
}

HRESULT
CAImeContext::GetGuidAtom(HIMC hIMC, BYTE bAttr, TfGuidAtom* pGuidAtom)
{
    if (bAttr < ATTR_LAYER_GUID_START) {
        return E_INVALIDARG;
    }

    HRESULT hr;

    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult())) {
        return hr;
    }

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);
    if (_pAImeContext == NULL)
        return E_UNEXPECTED;

    if (bAttr < _pAImeContext->usGuidMapSize) {
        *pGuidAtom = _pAImeContext->aGuidMap[bAttr];
    }
    return S_OK;
}

#if 0
void
CAImeContext::AssocFocus(
    HWND hWnd,
    ITfDocumentMgr* pdim
    )
{
    if (! ::IsWindow(hWnd))
        /*
         * Return invalid hWnd.
         */
        return;

    rTIM _tim;

    ITfDocumentMgr  *pdimPrev; // just to receive prev for now
    _tim->AssociateFocus(hWnd, pdim, &pdimPrev);
    if (pdimPrev)
        pdimPrev->Release();
}
#endif

UINT
CAImeContext::TranslateImeMessage(
    HIMC hIMC,
    TRANSMSGLIST* lpTransMsgList
    )
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    IMCLock imc(hIMC);
    HRESULT hr;
    if (FAILED(hr=imc.GetResult()))
        return hr;

    if (m_pMessageBuffer == NULL)
        return 0;

    INT_PTR NumMsg = m_pMessageBuffer->GetSize();
    if (NumMsg == 0)
        return 0;

    UINT retNumMsg = 0;

    if (lpTransMsgList && NumMsg < (INT_PTR)lpTransMsgList->uMsgCount) {
        LPTRANSMSG lpTransMsg = &lpTransMsgList->TransMsg[0];
        while (NumMsg--) {
            if (! m_pMessageBuffer->GetData(*lpTransMsg++))
                break;
            retNumMsg++;
        }
    }
    else {
        if (imc->hMsgBuf == NULL) {
            imc->hMsgBuf = ImmCreateIMCC(ptls, (DWORD)(NumMsg * sizeof(TRANSMSG)));
        }
        else if (ImmGetIMCCSize(ptls, imc->hMsgBuf) < NumMsg * sizeof(TRANSMSG)) {
            imc->hMsgBuf = ImmReSizeIMCC(ptls, imc->hMsgBuf, (DWORD)(NumMsg * sizeof(TRANSMSG)));
        }

        imc->dwNumMsgBuf = 0;

        IMCCLock<TRANSMSG> pdw(imc->hMsgBuf);
        if (pdw.Valid()) {
            LPTRANSMSG lpTransMsg = pdw;
            while (NumMsg--) {
                if (! m_pMessageBuffer->GetData(*lpTransMsg++))
                    break;
                retNumMsg++;
            }
            imc->dwNumMsgBuf = retNumMsg;
        }
    }

    return retNumMsg;
}


LPCTSTR REG_MSIMTF_KEY = TEXT("SOFTWARE\\Microsoft\\CTF\\MSIMTF\\");
LPCTSTR REG_EDITING_VAL = TEXT("Editing VK");

HRESULT
CAImeContext::SetupEditingKeyList(
    LANGID LangId
    )
{
    //
    // Setup user defines finalize key from registry value
    //
    TCHAR     MsImtfKey[128];
    lstrcpy(MsImtfKey, REG_MSIMTF_KEY);
    _itoa(LangId, MsImtfKey + lstrlen(MsImtfKey), 16);

    CRegKey   MsimtfReg;
    LONG      lRet;
    lRet = MsimtfReg.Open(HKEY_CURRENT_USER, MsImtfKey);
    if (lRet == ERROR_SUCCESS) {
        QueryRegKeyValue(MsimtfReg, REG_EDITING_VAL, EDIT_ID_FINALIZE);
    }

    //
    // Setup default editing key from resource data (RCDATA)
    //
    QueryResourceDataValue(LangId, ID_EDITING, EDIT_ID_FINALIZE);
    QueryResourceDataValue(LangId, ID_EDITING, EDIT_ID_HANJA);

    return S_OK;
}

LRESULT
CAImeContext::MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, HIMC hIMC)
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return IMEMOUSERET_NOTHANDLED;

    LRESULT ret = m_pICOwnerSink->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc,
                                                    m_pImmIfIME);

    if (dwBtnStatus & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) {
        m_pImmIfIME->_UpdateCompositionString();
    }

    return ret;
}

HRESULT CAImeContext::SetupReconvertString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->SetupReconvertString(m_pic, imc);
}

HRESULT CAImeContext::SetupReconvertString(UINT uPrivMsg)
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->SetupReconvertString(m_pic, imc, uPrivMsg);
}

HRESULT CAImeContext::EndReconvertString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->EndReconvertString(imc);
}

HRESULT CAImeContext::SetupUndoCompositionString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->SetupReconvertString(m_pic, imc, 0); /* 0 == Don't need ITfFnReconvert */
}

HRESULT CAImeContext::EndUndoCompositionString()
{
    IMCLock imc(m_hImc);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->EndReconvertString(imc);
}

HRESULT
CAImeContext::SetReconvertEditSession(
    BOOL bSet
    )
{
    m_fInReconvertEditSession = (bSet ? TRUE : FALSE);
    return S_OK;
}

HRESULT
CAImeContext::SetClearDocFeedEditSession(
    BOOL bSet
    )
{
    m_fInClearDocFeedEditSession = (bSet ? TRUE : FALSE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnCleanupContext
//
//----------------------------------------------------------------------------

HRESULT CAImeContext::OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic)
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (ptls->pAImeProfile == NULL)
        return E_FAIL;

    LANGID LangId;
    HRESULT hr = ptls->pAImeProfile->GetLangId(&LangId);
    if (FAILED(hr))
        LangId = LANG_NEUTRAL;

    //
    // Check IME_PROP_COMPLETE_ON_UNSELECT property on current language property
    //
    DWORD fdwProperty, fdwConversionCaps, fdwSentenceCaps, fdwSCSCaps, fdwUICaps;
    CLanguageCountry language(LangId);
    hr = language.GetProperty(&fdwProperty,
                              &fdwConversionCaps,
                              &fdwSentenceCaps,
                              &fdwSCSCaps,
                              &fdwUICaps);

    if (fdwProperty & IME_PROP_COMPLETE_ON_UNSELECT)
    {
#if 0
        ImmIfCompositionComplete *pImmIfCallBack = new ImmIfCompositionComplete;
        if (!pImmIfCallBack)
            return E_OUTOFMEMORY;

        pImmIfCallBack->CompComplete(ecWrite, m_hImc, FALSE, pic, m_pImmIfIME);

        delete pImmIfCallBack;
#else
        //
        // Remove GUID_PROP_COMPOSING
        //
        ITfRange *rangeFull = NULL;
        ITfProperty *prop;
        ITfRange *rangeTmp;
        if (SUCCEEDED(pic->GetProperty(GUID_PROP_COMPOSING, &prop)))
        {
            IEnumTfRanges *enumranges;
            if (SUCCEEDED(prop->EnumRanges(ecWrite, &enumranges, rangeFull)))
            {
                while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
                {
                    VARIANT var;
                    QuickVariantInit(&var);
                    prop->GetValue(ecWrite, rangeTmp, &var);
                    if ((var.vt == VT_I4) && (var.lVal != 0))
                    {
                        prop->Clear(ecWrite, rangeTmp);
                    }
                    rangeTmp->Release();
                }
                enumranges->Release();
            }
            prop->Release();
        }
#endif
    }
    return S_OK;
}

HRESULT CAImeContext::OnStartComposition(ITfCompositionView *pComposition, BOOL *pfOk)
{
    if (_cCompositions > 0 && !_fModifyingDoc)
    {
        *pfOk = FALSE;
    }
    else
    {
        *pfOk = TRUE;
        _cCompositions++;
    }

    return S_OK;
}

HRESULT CAImeContext::OnUpdateComposition(ITfCompositionView *pComposition, ITfRange *pRangeNew)
{
    return S_OK;
}

HRESULT CAImeContext::OnEndComposition(ITfCompositionView *pComposition)
{
    _cCompositions--;
    return S_OK;
}

HRESULT
CAImeContext::GetTextAndAttribute(
    HIMC hIMC,
    CWCompString* wCompString,
    CWCompAttribute* wCompAttribute
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetTextAndAttribute(imc, wCompString, wCompAttribute);
}

HRESULT
CAImeContext::GetTextAndAttribute(
    HIMC hIMC,
    CBCompString* bCompString,
    CBCompAttribute* bCompAttribute
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetTextAndAttribute(imc, bCompString, bCompAttribute);
}

HRESULT
CAImeContext::GetCursorPosition(
    HIMC hIMC,
    CWCompCursorPos* wCursorPosition
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetCursorPosition(imc, wCursorPosition);
}

HRESULT
CAImeContext::GetSelection(
    HIMC hIMC,
    CWCompCursorPos& wStartSelection,
    CWCompCursorPos& wEndSelection
    )
{
    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return E_FAIL;

    return m_pImmIfIME->GetSelection(imc, wStartSelection, wEndSelection);
}

HRESULT
CAImeContext::InquireIMECharPosition(
    HIMC hIMC,
    IME_QUERY_POS* pfQueryPos
    )
{
    if (m_fQueryPos == IME_QUERY_POS_UNKNOWN) {
        //
        // Is apps support "query positioning" ?
        //
        IMECHARPOSITION ip = {0};
        ip.dwSize = sizeof(IMECHARPOSITION);

        m_fQueryPos = QueryCharPos(hIMC, &ip) ? IME_QUERY_POS_YES : IME_QUERY_POS_NO;
    }

    if (pfQueryPos) {
        *pfQueryPos = m_fQueryPos;
    }

    return S_OK;
}

HRESULT
CAImeContext::RetrieveIMECharPosition(
    HIMC hIMC,
    IMECHARPOSITION* ip
    )
{
    return QueryCharPos(hIMC, ip) ? S_OK : E_FAIL;
}

BOOL
CAImeContext::QueryCharPos(
    HIMC hIMC,
    IMECHARPOSITION* position
    )
{
    IMTLS *ptls;

    ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return FALSE;

    IMCLock imc(hIMC);
    if (FAILED(imc.GetResult()))
        return FALSE;

    LRESULT lRet;

    //
    // First Step. Query by local method.
    //
    lRet = ::SendMessage(imc->hWnd,
                         WM_MSIME_QUERYPOSITION,
                         VERSION_QUERYPOSITION,
                         (LPARAM)position);
    if (lRet) {
        return TRUE;
    }

    //
    // Second Step. Query by IMM method.
    //
    if (IsOnNT5() || IsOn98()) {
        if (SUCCEEDED(ptls->pAImm->RequestMessageW((HIMC)imc,
                                                   IMR_QUERYCHARPOSITION,
                                                   (LPARAM)position,
                                                   &lRet)) && lRet) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\a_wrappers.cpp ===
//
// a_wrapper.cpp
//

#include "private.h"

#include "globals.h"
#include "cime.h"
#include "imtls.h"

#define IsAIMM() (ptls && ptls->pAImm)

HINSTANCE hIMM = NULL;   // temporary: do not call IMM32 for now

#define _GETPROC(name) \
        static t ## name lpProc = NULL; \
        if (lpProc == NULL) { \
            lpProc = (t ## name)GetProcAddress(hIMM, #name); \
        } \
        ASSERT(lpProc); \
        if (lpProc)

#define CALLPROCRET(name) \
    _GETPROC(name) \
        return lpProc

#define GETPROC(name, val, param) \
    {   \
        _GETPROC(name) { \
            (val) = lpProc param; \
        } \
    }



typedef HKL   (WINAPI * tImmInstallIMEA)(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
typedef HWND  (WINAPI * tImmGetDefaultIMEWnd)(HWND);
typedef UINT  (WINAPI * tImmGetDescriptionA)(HKL, LPSTR, UINT uBufLen);
typedef UINT  (WINAPI * tImmGetDescriptionW)(HKL, LPWSTR, UINT uBufLen);
typedef UINT  (WINAPI * tImmGetIMEFileNameA)(HKL, LPSTR, UINT uBufLen);
typedef UINT  (WINAPI * tImmGetIMEFileNameW)(HKL, LPWSTR, UINT uBufLen);
typedef DWORD  (WINAPI * tImmGetProperty)(HKL, DWORD);
typedef BOOL  (WINAPI * tImmIsIME)(HKL);
typedef BOOL  (WINAPI * tImmSimulateHotKey)(HWND, DWORD);
typedef HIMC  (WINAPI * tImmCreateContext)(void);
typedef BOOL  (WINAPI * tImmDestroyContext)(HIMC);
typedef HIMC  (WINAPI * tImmGetContext)(HWND);
typedef BOOL  (WINAPI * tImmReleaseContext)(HWND, HIMC);
typedef HIMC  (WINAPI * tImmAssociateContext)(HWND, HIMC);
typedef LONG   (WINAPI * tImmGetCompositionStringA)(HIMC, DWORD, LPVOID, DWORD);
typedef LONG   (WINAPI * tImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD);
typedef BOOL   (WINAPI * tImmSetCompositionStringA)(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
typedef BOOL   (WINAPI * tImmSetCompositionStringW)(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);
typedef DWORD  (WINAPI * tImmGetCandidateListCountA)(HIMC, LPDWORD lpdwListCount);
typedef DWORD  (WINAPI * tImmGetCandidateListA)(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);
typedef DWORD  (WINAPI * tImmGetGuideLineA)(HIMC, DWORD dwIndex, LPSTR, DWORD dwBufLen);
typedef DWORD  (WINAPI * tImmGetGuideLineW)(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen);
typedef BOOL  (WINAPI * tImmGetConversionStatus)(HIMC, LPDWORD, LPDWORD);
typedef BOOL  (WINAPI * tImmSetConversionStatus)(HIMC, DWORD, DWORD);
typedef BOOL  (WINAPI * tImmGetOpenStatus)(HIMC);
typedef BOOL  (WINAPI * tImmSetOpenStatus)(HIMC, BOOL);
typedef BOOL  (WINAPI * tImmGetCompositionFontA)(HIMC, LPLOGFONTA);
typedef BOOL  (WINAPI * tImmSetCompositionFontA)(HIMC, LPLOGFONTA);
typedef BOOL  (WINAPI * tImmConfigureIMEA)(HKL, HWND, DWORD, LPVOID);
typedef LRESULT  (WINAPI * tImmEscapeA)(HKL, HIMC, UINT, LPVOID);
typedef DWORD    (WINAPI * tImmGetConversionListA)(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
typedef DWORD    (WINAPI * tImmGetConversionListW)(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
typedef BOOL  (WINAPI * tImmNotifyIME) (HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
typedef BOOL  (WINAPI * tImmGetStatusWindowPos)(HIMC, LPPOINT);
typedef BOOL  (WINAPI * tImmSetStatusWindowPos)(HIMC, LPPOINT);
typedef BOOL  (WINAPI * tImmGetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
typedef BOOL  (WINAPI * tImmSetCompositionWindow)(HIMC, LPCOMPOSITIONFORM);
typedef BOOL  (WINAPI * tImmGetCandidateWindow)(HIMC, DWORD, LPCANDIDATEFORM);
typedef BOOL  (WINAPI * tImmSetCandidateWindow)(HIMC, LPCANDIDATEFORM);
typedef BOOL  (WINAPI * tImmIsUIMessageA)(HWND, UINT, WPARAM, LPARAM);
typedef UINT  (WINAPI * tImmGetVirtualKey)(HWND);
typedef BOOL  (WINAPI * tImmRegisterWordA)(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
typedef BOOL  (WINAPI * tImmRegisterWordW)(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);
typedef BOOL  (WINAPI * tImmUnregisterWordA)(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
typedef BOOL  (WINAPI * tImmUnregisterWordW)(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);
typedef UINT  (WINAPI * tImmGetRegisterWordStyleA)(HKL, UINT nItem, LPSTYLEBUFA);
typedef UINT (WINAPI * tImmEnumRegisterWordA)(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
typedef UINT (WINAPI * tImmEnumRegisterWordW)(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);

typedef LPINPUTCONTEXT (WINAPI* tImmLockIMC)(HIMC);
typedef BOOL (WINAPI* tImmUnlockIMC)(HIMC);

typedef HIMCC (WINAPI* tImmCreateIMCC)(DWORD);
typedef HIMCC (WINAPI* tImmDestroyIMCC)(HIMCC);
typedef LPVOID (WINAPI* tImmLockIMCC)(HIMCC);
typedef BOOL (WINAPI* tImmUnlockIMCC)(HIMCC);
typedef HIMCC (WINAPI* tImmReSizeIMCC)(HIMCC, DWORD);
typedef DWORD (WINAPI* tImmGetIMCCSize)(HIMCC);
typedef DWORD (WINAPI* tImmGetIMCCLockCount)(HIMCC);

typedef BOOL (WINAPI* tImmGenerateMessage)(HIMC);

typedef LRESULT (WINAPI* tImmEscapeA)(HKL hKL, HIMC hIMC, UINT uFunc, LPVOID lpData);
typedef LRESULT (WINAPI* tImmEscapeW)(HKL hKL, HIMC hIMC, UINT uFunc, LPVOID lpData);

typedef BOOL (WINAPI* tImmEnumInputContext)(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

UINT WINAPI RawImmGetDescriptionA(HKL hkl, LPSTR lpstr, UINT uBufLen)
{
    UINT rUINT = 0;
    GETPROC(ImmGetDescriptionA, rUINT, (hkl, lpstr, uBufLen));
    return rUINT;
}

BOOL WINAPI RawImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam)
{
    BOOL ret = FALSE;
    GETPROC(ImmEnumInputContext, ret, (idThread, lpfn, lParam));
    return ret;
}

HIMC ImmGetContext(IMTLS *ptls, HWND hwnd)
{
    HIMC rHIMC = NULL;

    if (IsAIMM()) {
        ptls->pAImm->GetContext(hwnd, &rHIMC);
    }
    else if (hIMM) {
        GETPROC(ImmGetContext, rHIMC, (hwnd));
    }
    else {
        ASSERT(FALSE);
    }

    return rHIMC;

}

BOOL ImmSetCompositionStringW(IMTLS *ptls, HIMC himc, DWORD dwIndex, LPVOID lpComp, DWORD dword, LPVOID lpRead, DWORD dword2)
{
    if (IsAIMM()) {
        return ptls->pAImm->SetCompositionStringW( himc, dwIndex, (LPVOID)lpComp, dword, (LPVOID)lpRead, dword2) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionStringW)(himc, dwIndex, lpComp, dword, lpRead, dword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL ImmSetConversionStatus(IMTLS *ptls, HIMC himc, DWORD dword, DWORD dword2)
{
    if (IsAIMM()) {
        return ptls->pAImm->SetConversionStatus(himc,dword, dword2) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetConversionStatus)(himc, dword, dword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

LPINPUTCONTEXT ImmLockIMC(IMTLS *ptls, HIMC himc)
{
    if (IsAIMM()) {
        LPINPUTCONTEXT lpimc;
        if (ptls->pAImm->LockIMC(himc, &lpimc) == S_OK) {
            return lpimc;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmLockIMC)(himc);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

BOOL ImmUnlockIMC(IMTLS *ptls, HIMC himc)
{
    if (IsAIMM()) {
        return ptls->pAImm->UnlockIMC(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnlockIMC)(himc);
    }
    ASSERT(FALSE);

    return FALSE;
}

HIMCC ImmCreateIMCC(IMTLS *ptls, DWORD dwSize)
{
    if (IsAIMM()) {
        HIMCC himcc;
        if (ptls->pAImm->CreateIMCC(dwSize, &himcc) == S_OK) {
            return himcc;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmCreateIMCC)(dwSize);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

HIMCC ImmDestroyIMCC(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        return ptls->pAImm->DestroyIMCC(himcc) == S_OK ? NULL : himcc;
    }

    if (hIMM) {
        CALLPROCRET(ImmDestroyIMCC)(himcc);
    }
    ASSERT(FALSE);

    return himcc;
}

LPVOID ImmLockIMCC(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        LPVOID lpv;
        if (ptls->pAImm->LockIMCC(himcc, &lpv) == S_OK) {
            return lpv;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmLockIMCC)(himcc);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

BOOL ImmUnlockIMCC(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        return ptls->pAImm->UnlockIMCC(himcc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnlockIMCC)(himcc);
    }
    ASSERT(FALSE);

    return FALSE;
}

HIMCC ImmReSizeIMCC(IMTLS *ptls, HIMCC himcc, DWORD dwSize)
{
    if (IsAIMM()) {
        HIMCC himccr;
        if (ptls->pAImm->ReSizeIMCC(himcc, dwSize, &himccr) == S_OK) {
            return himccr;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmReSizeIMCC)(himcc, dwSize);
    }
    else {
        ASSERT(FALSE);
    }

    return NULL;
}

DWORD ImmGetIMCCSize(IMTLS *ptls, HIMCC himcc)
{
    if (IsAIMM()) {
        DWORD dwSize;
        if (ptls->pAImm->GetIMCCSize(himcc, &dwSize) == S_OK) {
            return dwSize;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmGetIMCCSize)(himcc);
    }
    else {
        ASSERT(FALSE);
    }

    return 0;
}

#ifdef DEBUG
namespace debug {
void DumpMessages(HIMC himc)
{
    IMCLock imc(himc);
    ASSERT(imc.Valid());

    IMCCLock<TRANSMSG> msgbuf(imc->hMsgBuf);

    for (DWORD i = 0; i < imc->dwNumMsgBuf; ++i) {
        TRANSMSG* msg = &msgbuf[i];
    }
}
}
#endif

BOOL ImmGenerateMessage(IMTLS *ptls, HIMC himc)
{
#ifdef DEBUG
    debug::DumpMessages(himc);
#endif

    if (IsAIMM()) {
        return ptls->pAImm->GenerateMessage(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGenerateMessage)(himc);
    }
    else {
        ASSERT(FALSE);
    }

    return FALSE;
}

#ifdef UNUSED

HWND WINAPI ImmGetDefaultIMEWnd(HWND hwnd)
{
    HWND rHwnd = NULL;

    if (IsAIMM()) {
        ActiveIMM->GetDefaultIMEWnd(hwnd, &rHwnd);
    }
    else if (hIMM) {
        GETPROC(ImmGetDefaultIMEWnd, rHwnd, (hwnd));
    }

    return rHwnd;
}

HIMC WINAPI ImmCreateContext(void)
{
    HIMC rHIMC = NULL;

    if (IsAIMM()) {
        ActiveIMM->CreateContext(&rHIMC);
    }
    else if (hIMM) {
        GETPROC(ImmCreateContext, rHIMC, ());
    }

    return rHIMC;
}


HKL  WINAPI ImmInstallIMEA(LPSTR lpszIMEFileName, LPSTR lpszLayoutText)
{
    HKL rHKL = 0;

    if (IsAIMM()) {
        ActiveIMM->InstallIMEA(lpszIMEFileName, lpszLayoutText, &rHKL);
    }
    else if (hIMM) {
        GETPROC(ImmInstallIMEA, rHKL, (lpszIMEFileName, lpszLayoutText));
    }
    else {
        ASSERT(FALSE);
    }

    return rHKL;
}


UINT WINAPI ImmGetDescriptionA(HKL hkl, LPSTR lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetDescriptionA(hkl, uBufLen, lpstr, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetDescriptionA, rUINT, (hkl, lpstr, uBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmGetDescriptionW(HKL hkl, WCHAR* lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetDescriptionW(hkl, uBufLen, lpstr, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetDescriptionW, rUINT, (hkl, lpstr, uBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmGetIMEFileNameA(HKL hkl, LPSTR lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        HRESULT hres = ActiveIMM->GetIMEFileNameA(hkl, uBufLen, lpstr, &rUINT);
        if (hres == E_NOTIMPL) {
            return -1L;
        }
    }
    else if (hIMM) {
        GETPROC(ImmGetIMEFileNameA, rUINT, (hkl, lpstr, uBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmGetIMEFileNameW(HKL hkl, WCHAR* lpstr, UINT uBufLen)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        HRESULT hres = ActiveIMM->GetIMEFileNameW(hkl, uBufLen, lpstr, &rUINT);
        if (hres == E_NOTIMPL) {
            return -1L;
        }
    }
    else if (hIMM) {
        GETPROC(ImmGetIMEFileNameW, rUINT, (hkl, lpstr, uBufLen));
    } else {
        ASSERT(FALSE);
    }

    return rUINT;
}

DWORD WINAPI ImmGetProperty(HKL hkl, DWORD dword)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        ActiveIMM->GetProperty(hkl, dword, &rDWORD);
    }
    else if (hIMM) {
        GETPROC(ImmGetProperty, rDWORD, (hkl, dword));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}

BOOL WINAPI ImmIsIME(HKL hkl)
{
    if (IsAIMM()) {
        return ActiveIMM->IsIME(hkl) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmIsIME)(hkl);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSimulateHotKey(HWND hwnd, DWORD dword)
{

    if (IsAIMM()) {
        return ActiveIMM->SimulateHotKey(hwnd, dword) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSimulateHotKey)(hwnd, dword);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmDestroyContext(HIMC himc)
{

    if (IsAIMM()) {
        return ActiveIMM->DestroyContext(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmDestroyContext)(himc);
    }
    ASSERT(FALSE);


    return FALSE;
}

BOOL WINAPI ImmReleaseContext(HWND hwnd, HIMC himc)
{
    if (IsAIMM()) {
        return(ActiveIMM->ReleaseContext(hwnd, himc)==S_OK);
    }

    if (hIMM) {
        CALLPROCRET(ImmReleaseContext)(hwnd, himc);
    }
    ASSERT(FALSE);

    return FALSE;
}


HIMC WINAPI ImmAssociateContext(HWND hwnd, HIMC himc)
{
    HIMC rHIMC = NULL;

    if (IsAIMM()) {
        ActiveIMM->AssociateContext(hwnd, himc, &rHIMC);
    }
    else if (hIMM) {
        GETPROC(ImmAssociateContext, rHIMC, (hwnd, himc));
    }
    else {
        ASSERT(FALSE);
    }

    return rHIMC;
}


LONG WINAPI ImmGetCompositionStringA(HIMC himc, DWORD dword, LPVOID lpvoid, DWORD dword2)
{
    LONG rLONG = 0;

    if (IsAIMM()) {
        ActiveIMM->GetCompositionStringA(himc, dword, dword2,  &rLONG, lpvoid);
    }
    else if (hIMM) {
        GETPROC(ImmGetCompositionStringA, rLONG, (himc, dword, lpvoid, dword2));
    }

    return rLONG;
}

LONG  WINAPI ImmGetCompositionStringW(HIMC himc, DWORD dword, LPVOID lpvoid, DWORD dword2)
{
    LONG rLONG = 0;

    if (IsAIMM()) {
        ActiveIMM->GetCompositionStringW(himc, dword, dword2,  &rLONG, lpvoid);
    }
    else if (hIMM) {
        GETPROC(ImmGetCompositionStringW, rLONG, (himc, dword, lpvoid, dword2));
    }

    return rLONG;
}

BOOL  WINAPI ImmSetCompositionStringA(HIMC himc, DWORD dwIndex, LPVOID lpComp, DWORD dword, LPVOID lpRead, DWORD dword2)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCompositionStringA( himc, dwIndex, (LPVOID)lpComp, dword, (LPVOID)lpRead, dword2) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionStringA)(himc, dwIndex, lpComp, dword, lpRead, dword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

DWORD WINAPI ImmGetCandidateListCountA(HIMC himc, LPDWORD lpdwListCount)
{
    DWORD rDWORD = 0;
    HRESULT hres = 0;

    if (IsAIMM()) {
        hres = ActiveIMM->GetCandidateListCountA(himc, lpdwListCount, &rDWORD);
        if (hres == E_NOTIMPL)
            return -1L;
    }
    else if (hIMM) {
        GETPROC(ImmGetCandidateListCountA, rDWORD, (himc, lpdwListCount));
    }
    else {
        ASSERT(FALSE);
    }


    return rDWORD;
}

DWORD WINAPI ImmGetCandidateListA(HIMC himc, DWORD dwIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        UINT rUINT = 0;
        HRESULT hres = ActiveIMM->GetCandidateListA(himc, dwIndex,  dwBufLen, lpCandList, &rUINT);
        rDWORD = rUINT;

        if (hres == E_NOTIMPL) {
            return -1L;
        }
    }
    else if (hIMM) {
        GETPROC(ImmGetCandidateListA, rDWORD, (himc, dwIndex, lpCandList, dwBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}


DWORD WINAPI ImmGetGuideLineA(HIMC himc, DWORD dwIndex, LPSTR lpstr, DWORD dwBufLen)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        ActiveIMM->GetGuideLineA(himc, dwIndex, dwBufLen, lpstr,  &rDWORD);
    }
    else if (hIMM) {
        GETPROC(ImmGetGuideLineA, rDWORD, (himc, dwIndex, lpstr, dwBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}

DWORD WINAPI ImmGetGuideLineW(HIMC himc, DWORD dwIndex, LPWSTR lpstr, DWORD dwBufLen)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        ActiveIMM->GetGuideLineW(himc, dwIndex, dwBufLen, lpstr,  &rDWORD);
    }
    else if (hIMM) {
        GETPROC(ImmGetGuideLineW, rDWORD, (himc, dwIndex, lpstr, dwBufLen));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}


BOOL WINAPI ImmGetConversionStatus(HIMC himc, LPDWORD lpdword, LPDWORD lpdword2)
{
    if (IsAIMM()) {
        return ActiveIMM->GetConversionStatus(himc, lpdword, lpdword2);
    }

    if (hIMM) {
        CALLPROCRET(ImmGetConversionStatus)(himc, lpdword, lpdword2);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmGetOpenStatus(HIMC himc)
{
    if (IsAIMM()) {
        return ActiveIMM->GetOpenStatus(himc) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetOpenStatus)(himc);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSetOpenStatus(HIMC himc, BOOL bvalue)
{
    if (IsAIMM()) {
        return ActiveIMM->SetOpenStatus(himc, bvalue) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetOpenStatus)(himc, bvalue);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmGetCompositionFontA(HIMC himc, LPLOGFONTA lplogfonta)
{
    if (IsAIMM()) {
        HRESULT hres = ActiveIMM->GetCompositionFontA(himc, lplogfonta);

        return (hres == S_OK) ? TRUE : FALSE;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetCompositionFontA)(himc, lplogfonta);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmSetCompositionFontA(HIMC himc, LPLOGFONTA lplogfonta)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCompositionFontA(himc, lplogfonta) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionFontA)(himc, lplogfonta);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmConfigureIMEA(HKL hkl, HWND hwnd, DWORD dword, LPVOID lpvoid)
{
    if (IsAIMM()) {
        return ActiveIMM->ConfigureIMEA(hkl,  hwnd, dword, (REGISTERWORDA*) lpvoid) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmConfigureIMEA)(hkl, hwnd, dword, lpvoid);
    }
    ASSERT(FALSE);

    return FALSE;
}

LRESULT WINAPI ImmEscapeA(HKL hkl, HIMC himc, UINT uFunc, LPVOID lpData)
{
    LRESULT rLRESULT = 0;

    if (IsAIMM()) {
        ActiveIMM->EscapeA(hkl, himc, uFunc, lpData,  &rLRESULT);
    }
    else if (hIMM) {
        GETPROC(ImmEscapeA, rLRESULT, (hkl, himc, uFunc, lpData));
    }
    else {
        ASSERT(FALSE);
    }

    return rLRESULT;
}


LRESULT WINAPI ImmEscapeW(HKL hkl, HIMC himc, UINT uFunc, LPVOID lpData)
{
    LRESULT lr = 0;

    if (IsAIMM()) {
        ActiveIMM->EscapeW(hkl, himc, uFunc, lpData, &lr);
    }
    else if (hIMM) {
        GETPROC(ImmEscapeW, lr, (hkl, himc, uFunc, lpData));
    }
    else {
        ASSERT(FALSE);
    }

    return lr;
}

DWORD WINAPI ImmGetConversionListA(HKL hkl, HIMC himc, LPCSTR lpcstr, LPCANDIDATELIST lpcandlist, DWORD dwBufLen, UINT uFlag)
{
    DWORD rDWORD = 0;

    if (IsAIMM()) {
        UINT    rUINT = 0;
        ActiveIMM->GetConversionListA( hkl, himc, (LPSTR)lpcstr, dwBufLen, uFlag, lpcandlist, &rUINT);
        rDWORD = rUINT;
    }
    else if (hIMM) {
        GETPROC(ImmGetConversionListA, rDWORD, (hkl, himc, lpcstr, lpcandlist, dwBufLen, uFlag));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}

DWORD WINAPI ImmGetConversionListW(HKL hkl, HIMC himc, LPCWSTR lpcstr, LPCANDIDATELIST lpcandlist, DWORD dwBufLen, UINT uFlag)
{
    DWORD rDWORD = 0;

    if (IsAIMM())
    {
        UINT rUINT = 0;
        ActiveIMM->GetConversionListW( hkl, himc, (LPWSTR)lpcstr, dwBufLen, uFlag, lpcandlist, &rUINT);
        rDWORD = rUINT;
    }
    else if (hIMM) {
        GETPROC(ImmGetConversionListW, rDWORD, (hkl, himc, lpcstr, lpcandlist, dwBufLen, uFlag));
    }
    else {
        ASSERT(FALSE);
    }

    return rDWORD;
}


BOOL WINAPI ImmNotifyIME(HIMC himc, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    if (IsAIMM()) {
        return ActiveIMM->NotifyIME(himc,  dwAction,  dwIndex,  dwValue) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmNotifyIME)(himc,  dwAction,  dwIndex,  dwValue);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmGetStatusWindowPos(HIMC himc, LPPOINT lppoint)
{
    if (IsAIMM()) {
        return ActiveIMM->GetStatusWindowPos(himc,  lppoint) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetStatusWindowPos)(himc, lppoint);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmSetStatusWindowPos(HIMC himc, LPPOINT lppoint)
{
    if (IsAIMM()) {
        return ActiveIMM->SetStatusWindowPos( himc,  lppoint) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetStatusWindowPos)(himc, lppoint);
    }
    ASSERT(FALSE);

    return FALSE;
}


BOOL WINAPI ImmGetCompositionWindow(HIMC himc, LPCOMPOSITIONFORM lpcompositionform)
{
    HRESULT hres=0;

    if (IsAIMM()) {
        return ActiveIMM->GetCompositionWindow( himc,  lpcompositionform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetCompositionWindow)(himc, lpcompositionform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSetCompositionWindow(HIMC himc, LPCOMPOSITIONFORM lpcompositionform)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCompositionWindow( himc,  lpcompositionform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCompositionWindow)(himc, lpcompositionform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmGetCandidateWindow(HIMC himc, DWORD dword, LPCANDIDATEFORM lpcandidateform)
{
    if (IsAIMM()) {
        return ActiveIMM->GetCandidateWindow( himc,  dword, lpcandidateform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmGetCandidateWindow)(himc, dword, lpcandidateform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmSetCandidateWindow(HIMC himc, LPCANDIDATEFORM lpcandidateform)
{
    if (IsAIMM()) {
        return ActiveIMM->SetCandidateWindow( himc,  lpcandidateform) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmSetCandidateWindow)(himc, lpcandidateform);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmIsUIMessageA(HWND hwnd, UINT uint, WPARAM wparam, LPARAM lparam)
{
    if (IsAIMM()) {
        return ActiveIMM->IsUIMessageA( hwnd,  uint,  wparam,  lparam) == S_OK;
    }
    else if (hIMM) {
        CALLPROCRET(ImmIsUIMessageA)(hwnd,  uint,  wparam,  lparam);
    }
    ASSERT(FALSE);

    return FALSE;
}

UINT WINAPI ImmGetVirtualKey(HWND hwnd)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetVirtualKey(hwnd, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetVirtualKey, rUINT, (hwnd));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}

UINT WINAPI ImmEnumRegisterWordA(HKL hkl, REGISTERWORDENUMPROCA registerwordenumproca, LPCSTR lpszReading, DWORD dword, LPCSTR lpszRegister, LPVOID lpvoid)
{
    //
    // HY: ???
    //
    UINT rUINT = 0;
    IEnumRegisterWordA *pEnum = NULL;

    if (IsAIMM()) {
        ActiveIMM->EnumRegisterWordA(hkl, (LPSTR)lpszReading, dword, (LPSTR)lpszRegister, lpvoid, &pEnum);
    }
    else if (hIMM) {
        GETPROC(ImmEnumRegisterWordA, rUINT, (hkl, registerwordenumproca, lpszReading, dword, lpszRegister, lpvoid));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}


UINT WINAPI ImmGetRegisterWordStyleA(HKL hkl, UINT nItem, LPSTYLEBUFA lpstylebufa)
{
    UINT rUINT = 0;

    if (IsAIMM()) {
        ActiveIMM->GetRegisterWordStyleA( hkl,  nItem,  lpstylebufa, &rUINT);
    }
    else if (hIMM) {
        GETPROC(ImmGetRegisterWordStyleA, rUINT, (hkl,  nItem,  lpstylebufa));
    }
    else {
        ASSERT(FALSE);
    }

    return rUINT;
}


BOOL WINAPI ImmRegisterWordA(HKL hkl, LPCSTR lpszReading, DWORD dword, LPCSTR lpszRegister)
{
    if (IsAIMM()) {
        return ActiveIMM->RegisterWordA( hkl, (LPSTR) lpszReading, dword, (LPSTR) lpszRegister) == S_OK;
    }
    else if (hIMM) {
        CALLPROCRET(ImmRegisterWordA)(hkl, lpszReading, dword, lpszRegister);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmRegisterWordW(HKL hkl, LPCWSTR lpszReading, DWORD dword, LPCWSTR lpszRegister)
{
    if (IsAIMM()) {
        return ActiveIMM->RegisterWordW( hkl, (LPWSTR) lpszReading, dword, (LPWSTR) lpszRegister) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmRegisterWordW)(hkl, lpszReading, dword, lpszRegister);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmUnregisterWordA(HKL hkl, LPCSTR lpszReading, DWORD dword, LPCSTR lpszUnregister)
{
    if (IsAIMM()) {
        return ActiveIMM->UnregisterWordA( hkl, (LPSTR) lpszReading, dword, (LPSTR) lpszUnregister) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnregisterWordA)(hkl, lpszReading, dword, lpszUnregister);
    }
    ASSERT(FALSE);

    return FALSE;
}

BOOL WINAPI ImmUnregisterWordW(HKL hkl, LPCWSTR lpszReading, DWORD dword, LPCWSTR lpszUnregister)
{
    if (IsAIMM()) {
        return ActiveIMM->UnregisterWordW( hkl, (LPWSTR) lpszReading, dword, (LPWSTR) lpszUnregister) == S_OK;
    }

    if (hIMM) {
        CALLPROCRET(ImmUnregisterWordW)(hkl, lpszReading, dword, lpszUnregister);
    }
    ASSERT(FALSE);

    return FALSE;
}

DWORD WINAPI ImmGetIMCCLockCount(HIMCC himcc)
{
    if (IsAIMM()) {
        DWORD dw;
        if (ActiveIMM->GetIMCCLockCount(himcc, &dw) == S_OK) {
            return dw;
        }
    }
    else if (hIMM) {
        CALLPROCRET(ImmGetIMCCLockCount)(himcc);
    }
    else {
        ASSERT(FALSE);
    }

    return 0;
}
#endif // UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\caime.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       caime.cpp
//
//  Contents:   CAIME
//
//----------------------------------------------------------------------------

#include "private.h"

#include "globals.h"
#include "idebug.h"
#include "globals.h"
#include "caime.h"


CAIME::CAIME()
{
    m_pIActiveIMMIME = NULL;
    _pPauseCookie = NULL;

    DllAddRef();
    _cRef = 1;
}

CAIME::~CAIME()
{
    Assert(_pPauseCookie == NULL);
    DllRelease();
}

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CAIME::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IActiveIME_Private))
    {
        *ppvObj = SAFECAST(this, IActiveIME_Private *);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider)) {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
#if 0
    else if (IsEqualIID(ridd, IID_IAImmLayer)) {
        *ppvObj = SAFECAST(this, IAImmLayer*);
    }
#endif

    if (*ppvObj == NULL)
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDAPI_(ULONG) CAIME::AddRef()
{
    _cRef++;
    return _cRef;
}

STDAPI_(ULONG) CAIME::Release()
{
    _cRef--;
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\candpos.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    candpos.cpp

Abstract:

    This file implements the CCandidatePosition Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"
#include "candpos.h"
#include "a_context.h"
#include "ctxtcomp.h"

HRESULT
CCandidatePosition::GetCandidatePosition(
    OUT RECT* out_rcArea
    )
{
    IMTLS *ptls;

    ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    HRESULT hr;
    IMCLock imc(ptls->hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    ::SetRect(out_rcArea, 0, 0, 0, 0);

    LANGID langid;
    ptls->pAImeProfile->GetLangId(&langid);
#if 0
    //
    // Simplified Chinese TIP's Candidate window create ic and Push it.
    // AIMM can know candidate window status.
    // If it opened, we returns position of imc->cfCandForm.
    // Not use QueryCharPos() because it returns position of Reading window.
    //
    if (langid == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (_pAImeContext == NULL)
            return E_FAIL;

        if (_pAImeContext->m_fOpenCandidateWindow) {
            if (imc->cfCandForm[0].dwStyle != CFS_DEFAULT && imc->cfCandForm[0].dwStyle != CFS_EXCLUDE) {

#if 0
                //
                // Chinese TIP needs rectangle
                //
                IMECHARPOSITION ip = {0};
                ip.dwSize = sizeof(IMECHARPOSITION);

                if (QueryCharPos(ptls, imc, &ip)) {
                    //
                    // Sure. Support "query positioning".
                    //
                    RECT rect;
                    hr = GetRectFromApp(ptls,
                                        imc,
                                        &rect);    // rect = screen coordinate.
                    if (SUCCEEDED(hr)) {
                        MapWindowPoints(HWND_DESKTOP, imc->hWnd, (LPPOINT)&rect, sizeof(RECT)/sizeof(POINT));
                        hr = GetRectFromHIMC(imc,
                                             CFS_EXCLUDE,
                                             &imc->cfCandForm[0].ptCurrentPos,
                                             &rect,
                                             out_rcArea);
                        if (SUCCEEDED(hr))
                            return hr;
                    }
                }
#endif
                //
                // Chinese TIP needs rectangle
                //
                hr = GetRectFromCompFont(ptls,
                                         imc,
                                         &imc->cfCandForm[0].ptCurrentPos,
                                         out_rcArea);
                if (SUCCEEDED(hr))
                    return hr;

            }

            hr = GetRectFromHIMC(imc,
                                 imc->cfCandForm[0].dwStyle,
                                 &imc->cfCandForm[0].ptCurrentPos,
                                 &imc->cfCandForm[0].rcArea,
                                 out_rcArea);

            return hr;
        }
    }
#endif

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    //
    // Is apps support "query positioning" ?
    //
    CAImeContext::IME_QUERY_POS qpos;
    if (SUCCEEDED(_pAImeContext->InquireIMECharPosition(imc, &qpos)) &&
        qpos == CAImeContext::IME_QUERY_POS_YES) {
        //
        // Sure. Support "query positioning".
        //
        hr = GetRectFromApp(ptls,
                            imc,
                            langid,
                            out_rcArea);
        if (SUCCEEDED(hr))
            return hr;
        else
            _pAImeContext->ResetIMECharPosition(imc);
    }

    if ( (PRIMARYLANGID(langid) == LANG_CHINESE) &&
         (imc->cfCandForm[0].dwIndex == -1))
    {
        //
        // Assume CHT/CHS's Reading Window Position.
        //
        hr = GetRectFromHIMC(imc,
                             imc->cfCompForm.dwStyle,
                             &imc->cfCompForm.ptCurrentPos,
                             &imc->cfCompForm.rcArea,
                             out_rcArea);
        return hr;
    }

    hr = GetRectFromHIMC(imc,
                         imc->cfCandForm[0].dwStyle,
                         &imc->cfCandForm[0].ptCurrentPos,
                         &imc->cfCandForm[0].rcArea,
                         out_rcArea);

    return hr;
}

HRESULT
CCandidatePosition::GetRectFromApp(
    IN IMTLS* ptls,
    IN IMCLock& imc,
    IN LANGID langid,
    OUT RECT* out_rcArea
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    IMECHARPOSITION ip = {0};
    ip.dwSize = sizeof(IMECHARPOSITION);

    CWCompCursorPos wCursorPosition;
    HRESULT hr;

    if (PRIMARYLANGID(langid) == LANG_JAPANESE &&
        (hr = FindAttributeInCompositionString(imc,
                                               ATTR_TARGET_CONVERTED,
                                               wCursorPosition)) == S_OK) {
        ip.dwCharPos = wCursorPosition.GetAt(0);
    }
    else {
        if (SUCCEEDED(hr = GetCursorPosition(imc,
                                             wCursorPosition))) {
            CWCompCursorPos wStartSelection;
            CWCompCursorPos wEndSelection;
            if (SUCCEEDED(hr = GetSelection(imc,
                                            wStartSelection, wEndSelection))) {
                ip.dwCharPos = min(wCursorPosition.GetAt(0),
                                   wStartSelection.GetAt(0));
            }
            else {
                ip.dwCharPos = wCursorPosition.GetAt(0);
            }
        }
        else {
            ip.dwCharPos = 0;
        }
    }

    if (SUCCEEDED(hr = _pAImeContext->RetrieveIMECharPosition(imc, &ip))) {
        switch (DocumentDirection(imc)) {
            case DIR_TOP_BOTTOM:
                ::SetRect(out_rcArea,
                          ip.pt.x - ip.cLineHeight,               // left
                          ip.pt.y,                                // top
                          ip.pt.x,                                // right
                          max(ip.pt.y, ip.rcDocument.bottom));    // bottom
                break;
            case DIR_BOTTOM_TOP:
                ::SetRect(out_rcArea,
                          ip.pt.x - ip.cLineHeight,               // left
                          min(ip.pt.y, ip.rcDocument.top),        // top
                          ip.pt.x,                                // right
                          ip.pt.y);                               // bottom
                break;
            case DIR_RIGHT_LEFT:
                ::SetRect(out_rcArea,
                          min(ip.pt.x, ip.rcDocument.left),       // left
                          ip.pt.y,                                // top
                          ip.pt.x,                                // right
                          ip.pt.y + ip.cLineHeight);              // bottom
                break;
            case DIR_LEFT_RIGHT:
                ::SetRect(out_rcArea,
                          ip.pt.x,                                // left
                          ip.pt.y,                                // top
                          max(ip.pt.x, ip.rcDocument.right),      // right
                          ip.pt.y + ip.cLineHeight);              // bottom
                break;
        }
    }

    return hr;
}

HRESULT
CCandidatePosition::GetRectFromHIMC(
    IN IMCLock& imc,
    IN DWORD  dwStyle,
    IN POINT* ptCurrentPos,
    IN RECT*  rcArea,
    OUT RECT*  out_rcArea
    )
{
    HWND hWnd = imc->hWnd;

    POINT pt;

    if (dwStyle == CFS_DEFAULT)
    {
        ::SystemParametersInfo(SPI_GETWORKAREA,
                               0,
                               out_rcArea,
                               0);
        out_rcArea->left   = out_rcArea->right;
        out_rcArea->top    = out_rcArea->bottom;
    }
    else if (dwStyle == CFS_RECT)
    {
        out_rcArea->left   = ptCurrentPos->x;
        out_rcArea->right  = ptCurrentPos->x;
        out_rcArea->top    = ptCurrentPos->y;
        out_rcArea->bottom = ptCurrentPos->y;
    }
    else if (dwStyle == CFS_CANDIDATEPOS)
    {
        IMTLS *ptls;

        ptls = IMTLS_GetOrAlloc();
        if (ptls == NULL)
            return E_FAIL;

        //
        // We needs rectangle
        //
        return GetRectFromCompFont(ptls,
                                   imc,
                                   ptCurrentPos,
                                   out_rcArea);
    }
    else if (dwStyle == CFS_EXCLUDE)
    {
        GetCandidateArea(imc, dwStyle, ptCurrentPos, rcArea, out_rcArea);
    }

    pt.x = pt.y = 0;
    ClientToScreen(hWnd, &pt);
    out_rcArea->left   += pt.x;
    out_rcArea->right  += pt.x;
    out_rcArea->top    += pt.y;
    out_rcArea->bottom += pt.y;

    return S_OK;
}

HRESULT
CCandidatePosition::GetRectFromCompFont(
    IN IMTLS* ptls,
    IN IMCLock& imc,
    IN POINT* ptCurrentPos,
    OUT RECT* out_rcArea
    )
{
    HRESULT hr = E_FAIL;

    HDC dc = ::GetDC(imc->hWnd);
    if (dc != NULL) {

        LOGFONTA logfont;
        if (SUCCEEDED(ptls->pAImm->GetCompositionFontA((HIMC)imc, &logfont))) {

            HFONT font = ::CreateFontIndirectA( &logfont );
            if (font != NULL) {

                HFONT prev_font;
                prev_font = (HFONT)::SelectObject(dc, font);

                TEXTMETRIC metric;
                if (::GetTextMetrics(dc, &metric)) {

                    int font_cx = metric.tmMaxCharWidth;
                    int font_cy = metric.tmHeight;

                    switch (DocumentDirection(imc)) {
                        case DIR_TOP_BOTTOM:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x - font_cx,              // left
                                      ptCurrentPos->y,                        // top
                                      ptCurrentPos->x,                        // right
                                      ptCurrentPos->y + font_cy);             // bottom
                            break;
                        case DIR_BOTTOM_TOP:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x,                        // left
                                      ptCurrentPos->y - font_cy,              // top
                                      ptCurrentPos->x + font_cx,              // right
                                      ptCurrentPos->y);                       // bottom
                            break;
                        case DIR_RIGHT_LEFT:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x - font_cx,              // left
                                      ptCurrentPos->y - font_cy,              // top
                                      ptCurrentPos->x,                        // right
                                      ptCurrentPos->y);                       // bottom
                            break;
                        case DIR_LEFT_RIGHT:
                            ::SetRect(out_rcArea,
                                      ptCurrentPos->x,                        // left
                                      ptCurrentPos->y,                        // top
                                      ptCurrentPos->x + font_cx,              // right
                                      ptCurrentPos->y + font_cy);             // bottom
                            break;
                    }

                    POINT pt;
                    pt.x = pt.y = 0;
                    ClientToScreen(imc->hWnd, &pt);
                    out_rcArea->left   += pt.x;
                    out_rcArea->right  += pt.x;
                    out_rcArea->top    += pt.y;
                    out_rcArea->bottom += pt.y;

                    hr = S_OK;
                }

                ::SelectObject(dc, prev_font);
                ::DeleteObject(font);
            }
        }

        ::ReleaseDC(imc->hWnd, dc);
    }

    return hr;
}


/*
 *
 *  dwStyle == CFS_EXCLUDE
 *
 */

HRESULT
CCandidatePosition::GetCandidateArea(
    IN IMCLock& imc,
    IN DWORD dwStyle,
    IN POINT* ptCurrentPos,
    IN RECT* rcArea,
    OUT RECT* out_rcArea
    )
{
    POINT pt = *ptCurrentPos;
    RECT rc = *rcArea;

    switch (DocumentDirection(imc)) {
        case DIR_TOP_BOTTOM:
            ::SetRect(out_rcArea,
                      min(pt.x, rcArea->left),     // left
                      max(pt.y, rcArea->top),      // top
                      max(pt.x, rcArea->right),    // right
                      rcArea->bottom);             // bottom
            break;
        case DIR_BOTTOM_TOP:
            ::SetRect(out_rcArea,
                      min(pt.x, rcArea->left),     // left
                      rcArea->top,                 // top
                      max(pt.x, rcArea->right),    // right
                      min(pt.y, rcArea->bottom));  // bottom
            break;
        case DIR_RIGHT_LEFT:
            ::SetRect(out_rcArea,
                      rcArea->left,                // left
                      min(pt.y, rcArea->top),      // top
                      min(pt.x, rcArea->right),    // right
                      max(pt.y, rcArea->bottom));  // bottom
            break;
        case DIR_LEFT_RIGHT:
            ::SetRect(out_rcArea,
                      max(pt.x, rcArea->left),     // left
                      min(pt.y, rcArea->top),      // top
                      rcArea->right,               // right
                      max(pt.y, rcArea->bottom));  // bottom
            break;
    }

    return S_OK;
}

HRESULT
CCandidatePosition::FindAttributeInCompositionString(
    IN IMCLock& imc,
    IN BYTE target_attribute,
    OUT CWCompCursorPos& wCursorPosition
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext != NULL) {

        CWCompString    wCompString;
        CWCompAttribute wCompAttribute;

        if (SUCCEEDED(hr = _pAImeContext->GetTextAndAttribute((HIMC)imc,
                                                              &wCompString, &wCompAttribute))) {

            LONG num_of_written = (LONG)wCompAttribute.ReadCompData();
            if (num_of_written == 0)
                return E_FAIL;

            BYTE* attribute = new BYTE[ num_of_written ];
            if (attribute != NULL) {
                //
                // Get attribute data.
                //
                wCompAttribute.ReadCompData(attribute, num_of_written);

                LONG start_position = 0;

                LONG ich = 0;
                LONG attr_size = num_of_written;
                while (ich < attr_size && attribute[ich] != target_attribute)
                    ich++;

                if (ich < attr_size) {
                    start_position = ich;
                }
                else {
                    //
                    // If not hit with target_attribute, then returns S_FALSE.
                    // 
                    hr = S_FALSE;
                }

                wCursorPosition.Set(start_position);

                delete [] attribute;
            }
        }
    }

    return hr;
}

HRESULT
CCandidatePosition::GetCursorPosition(
    IN IMCLock& imc,
    OUT CWCompCursorPos& wCursorPosition
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext != NULL) {
        hr = _pAImeContext->GetCursorPosition((HIMC)imc, &wCursorPosition);
    }

    return hr;
}

HRESULT
CCandidatePosition::GetSelection(
    IN IMCLock& imc,
    OUT CWCompCursorPos& wStartSelection,
    OUT CWCompCursorPos& wEndSelection
    )
{
    HRESULT hr = E_FAIL;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext != NULL) {
        hr = _pAImeContext->GetSelection((HIMC)imc, wStartSelection, wEndSelection);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\a_wrappers.h ===
//
// a_wrappers.h
//

#ifndef A_WRAPPERS_H
#define A_WRAPPERS_H

#include "private.h"
#include "imtls.h"

HIMC ImmGetContext(IMTLS *ptls, HWND hwnd);
BOOL ImmSetCompositionStringW(IMTLS *ptls, HIMC himc, DWORD dwIndex, LPVOID lpComp, DWORD dword, LPVOID lpRead, DWORD dword2);
BOOL ImmSetConversionStatus(IMTLS *ptls, HIMC himc, DWORD dword, DWORD dword2);
LPINPUTCONTEXT ImmLockIMC(IMTLS *ptls, HIMC himc);
BOOL ImmUnlockIMC(IMTLS *ptls, HIMC himc);
HIMCC ImmCreateIMCC(IMTLS *ptls, DWORD dwSize);
HIMCC ImmDestroyIMCC(IMTLS *ptls, HIMCC himcc);
LPVOID ImmLockIMCC(IMTLS *ptls, HIMCC himcc);
BOOL ImmUnlockIMCC(IMTLS *ptls, HIMCC himcc);
HIMCC ImmReSizeIMCC(IMTLS *ptls, HIMCC himcc, DWORD dwSize);
DWORD ImmGetIMCCSize(IMTLS *ptls, HIMCC himcc);
BOOL ImmGenerateMessage(IMTLS *ptls, HIMC himc);

#endif // A_WRAPPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\cime.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cime.cpp

Abstract:

    This file implements the IMCLock / IMCCLock Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cime.h"
#include "template.h"
#include "imedefs.h"
#include "a_wrappers.h"
#include "a_context.h"

/////////////////////////////////////////////////////////////////////////////
// IMCLock

IMCLock::IMCLock(
    HIMC hImc
    ) : _IMCLock(hImc)
{
    if (hImc) {
        m_hr = _LockIMC(hImc, &m_inputcontext);
    }
}

HRESULT
IMCLock::_LockIMC(
    IN HIMC hIMC,
    OUT INPUTCONTEXT_AIMM12 **ppIMC
    )
{
    if (hIMC == NULL) {
        return E_INVALIDARG;
    }

    *ppIMC = (INPUTCONTEXT_AIMM12*)ImmLockIMC(IMTLS_GetOrAlloc(), hIMC);
    return *ppIMC == NULL ? E_FAIL : S_OK;
}

HRESULT
IMCLock::_UnlockIMC(
    IN HIMC hIMC
    )
{
    return ImmUnlockIMC(IMTLS_GetOrAlloc(), hIMC) ? S_OK : E_FAIL;
}

BOOL
IMCLock::ValidCompositionString(
    )
{
    if (ImmGetIMCCSize(IMTLS_GetOrAlloc(), m_inputcontext->hCompStr) < sizeof(COMPOSITIONSTRING))
        return FALSE;

    IMCCLock<COMPOSITIONSTRING> lpCompStr(m_inputcontext->hCompStr);
    if (lpCompStr.Invalid())
        return FALSE;

    return (lpCompStr->dwCompStrLen > 0);
}

//
// Initialize the context
//
void
IMCLock::InitContext(
    )
{
    CAImeContext* _pAImeContext = m_inputcontext->m_pAImeContext;
    if (_pAImeContext)
        _pAImeContext->m_fOpenCandidateWindow = FALSE;     // TRUE: opening candidate list window.


    if (!(m_inputcontext->fdwInit & INIT_COMPFORM)) {
        m_inputcontext->cfCompForm.dwStyle = CFS_DEFAULT;
    }

    for (UINT i = 0; i < 4; i++) {
        m_inputcontext->cfCandForm[i].dwStyle = CFS_DEFAULT;
    }

    return;
}

//
// clear candidate list
//
BOOL
IMCLock::ClearCand(
    )
{
    HIMCC           hMem;
    LPCANDIDATELIST lpCandList;
    IMTLS *ptls = IMTLS_GetOrAlloc();
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND) +
        // string plus NULL terminator
        (sizeof(WCHAR) + sizeof(TCHAR)) * MAXCAND;

    if (! m_inputcontext->hCandInfo) {
        // it maybe free by other IME, init it
        m_inputcontext->hCandInfo = ImmCreateIMCC(ptls, dwSize);
    } else if (hMem = ImmReSizeIMCC(ptls, m_inputcontext->hCandInfo, dwSize)) {
        m_inputcontext->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(ptls, m_inputcontext->hCandInfo);
        m_inputcontext->hCandInfo = ImmCreateIMCC(ptls, dwSize);
        return (FALSE);
    }

    if (! m_inputcontext->hCandInfo) {
        return (FALSE);
    }


    IMCCLock<CANDIDATEINFO> lpCandInfo(m_inputcontext->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(IMTLS_GetOrAlloc(), m_inputcontext->hCandInfo);
        m_inputcontext->hCandInfo = ImmCreateIMCC(ptls, dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)lpCandInfo.GetOffsetPointer( lpCandInfo->dwOffset[0] );
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND - 1);

    return (TRUE);
}

//
// generate message
//
void
IMCLock::GenerateMessage(
    )
{
    CAImeContext* _pAImeContext = m_inputcontext->m_pAImeContext;

    if (_pAImeContext &&
        _pAImeContext->TranslateImeMessage((HIMC)*this))
        ImmGenerateMessage(IMTLS_GetOrAlloc(), (HIMC)*this);
}

/////////////////////////////////////////////////////////////////////////////
// InternalIMCCLock

InternalIMCCLock::InternalIMCCLock(
    HIMCC hImcc
    ) : _IMCCLock(hImcc)
{
    if (hImcc) {
        m_hr = _LockIMCC(m_himcc, (void**)&m_pimcc);
    }
}


HRESULT
InternalIMCCLock::_LockIMCC(
    IN HIMCC hIMCC,
    OUT void **ppv
    )
{
    if (hIMCC == NULL) {
        return E_INVALIDARG;
    }

    *ppv = ImmLockIMCC(IMTLS_GetOrAlloc(), hIMCC);
#if defined(DEBUG)
    if (*ppv) {
        HeapValidate( GetProcessHeap(), 0, *ppv);
    }
#endif
    return *ppv == NULL ? E_FAIL : S_OK;
}

HRESULT
InternalIMCCLock::_UnlockIMCC(
    IN HIMCC hIMCC
    )
{
    return ImmUnlockIMCC(IMTLS_GetOrAlloc(), hIMCC) ? S_OK :
        GetLastError() == NO_ERROR ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\caime.h ===
//+---------------------------------------------------------------------------
//
//  File:       caime.h
//
//  Contents:   CAIME
//
//----------------------------------------------------------------------------

#ifndef CAIME_H
#define CAIME_H

#include "imtls.h"

typedef struct _PauseCookie
{
    DWORD dwCookie;
    struct _PauseCookie *next;
} PauseCookie;

//+---------------------------------------------------------------------------
//
// CAIME
//
//----------------------------------------------------------------------------

class __declspec(novtable) CAIME : public IActiveIME_Private,
                                   public IServiceProvider
{
public:
    CAIME();
    virtual ~CAIME();

    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

#if 0
    //
    // Wrappers
    //

    HIMC GetContext(HWND hWnd)
    {
        HIMC hIMC;

        _pActiveIMM->GetContext(hWnd, &hIMC);

        return hIMC;
    }

    HIMC CreateContext()
    {
        HIMC hIMC;

        _pActiveIMM->CreateContext(&hIMC);

        return hIMC;
    }

    BOOL DestroyContext(HIMC hIMC)
    {
        return SUCCEEDED(_pActiveIMM->DestroyContext(hIMC));
    }

    HIMC AssociateContext(HWND hWnd, HIMC hIMC)
    {
        HIMC hOrgIMC;

        _pActiveIMM->AssociateContext(hWnd, hIMC, &hOrgIMC);

        return hOrgIMC;
    }

    LPINPUTCONTEXT LockIMC(HIMC hIMC)
    {
        LPINPUTCONTEXT pic;

        _pActiveIMM->LockIMC(hIMC, &pic);

        return pic;
    }

    BOOL UnlockIMC(HIMC hIMC)
    {
        return (_pActiveIMM->UnlockIMC(hIMC) == S_OK);
    }

    LPVOID LockIMCC(HIMCC hIMCC)
    {
        void *pv;

        _pActiveIMM->LockIMCC(hIMCC, &pv);

        return pv;
    }

    BOOL UnlockIMCC(HIMCC hIMCC)
    {
        return (_pActiveIMM->UnlockIMCC(hIMCC) == S_OK);
    }

    HIMCC CreateIMCC(DWORD dwSize)
    {
        HIMCC hIMCC;

        _pActiveIMM->CreateIMCC(dwSize, &hIMCC);

        return hIMCC;
    }

    HIMCC DestroyIMCC(HIMCC hIMCC)
    {
        return SUCCEEDED(_pActiveIMM->DestroyIMCC(hIMCC)) ? NULL : hIMCC;
    }

    DWORD GetIMCCSize(HIMCC hIMCC)
    {
        DWORD dwSize;

        _pActiveIMM->GetIMCCSize(hIMCC, &dwSize);

        return dwSize;
    }

    HIMCC ReSizeIMCC(HIMCC hIMCC, DWORD dwSize)
    {
        HIMCC hIMCC2;

        _pActiveIMM->ReSizeIMCC(hIMCC, dwSize, &hIMCC2);

        return hIMCC2;
    }

    BOOL GenerateMessage(HIMC hIMC)
    {
        return (_pActiveIMM->GenerateMessage(hIMC) == S_OK);
    }

    DWORD GetGuideLineA(HIMC hIMC, DWORD dwIndex, LPSTR szBuffer, DWORD dwBufLen)
    {
        DWORD dwResult;

        _pActiveIMM->GetGuideLineA(hIMC, dwIndex, dwBufLen, szBuffer, &dwResult);

        return dwResult;
    }

    BOOL SetCandidateWindow(HIMC hIMC, LPCANDIDATEFORM lpCandidateForm)
    {
        return (_pActiveIMM->SetCandidateWindow(hIMC, lpCandidateForm) == S_OK);
    }

    BOOL GetOpenStatus(HIMC hIMC)
    {
        return (_pActiveIMM->GetOpenStatus(hIMC) == S_OK);
    }

    BOOL SetOpenStatus(HIMC hIMC, BOOL fOpen)
    {
        return (_pActiveIMM->SetOpenStatus(hIMC, fOpen) == S_OK);
    }

    BOOL GetConversionStatus(HIMC hIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence)
    {
        return (_pActiveIMM->GetConversionStatus(hIMC, lpfdwConversion, lpfdwSentence) == S_OK);
    }

    BOOL SetConversionStatus(HIMC hIMC, DWORD fdwConversion, DWORD fdwSentence)
    {
        return (_pActiveIMM->SetConversionStatus(hIMC, fdwConversion, fdwSentence) == S_OK);
    }

    HWND GetDefaultIMEWnd(HWND hWnd)
    {
        HWND hDefWnd;

        _pActiveIMM->GetDefaultIMEWnd(hWnd, &hDefWnd);

        return hDefWnd;
    }

    BOOL GetHotKey(DWORD dwHotKeyID, UINT *puModifiers, UINT *puVKey, HKL *phKL)
    {
        return SUCCEEDED(_pActiveIMM->GetHotKey(dwHotKeyID, puModifiers, puVKey, phKL));
    }

    HWND CreateSoftKeyboard(UINT uType, HWND hOwner, int x, int y)
    {
        HWND hWnd;

        _pActiveIMM->CreateSoftKeyboard(uType, hOwner, x, y, &hWnd);

        return hWnd;
    }

    BOOL DestroySoftKeyboard(HWND hSoftKbdWnd)
    {
        return SUCCEEDED(_pActiveIMM->DestroySoftKeyboard(hSoftKbdWnd));
    }

    BOOL ShowSoftKeyboard(HWND hSoftKbdWnd, int nCmdShow)
    {
        return SUCCEEDED(_pActiveIMM->ShowSoftKeyboard(hSoftKbdWnd, nCmdShow));
    }

    UINT GetConversionListA(HKL hKL, HIMC hIMC, LPSTR lpSrc, CANDIDATELIST *lpDst, UINT uBufLen, UINT uFlag)
    {
        UINT uCopied;

        _pActiveIMM->GetConversionListA(hKL, hIMC, lpSrc, uBufLen, uFlag, lpDst, &uCopied);

        return uCopied;
    }

    LRESULT EscapeA(HKL hKL, HIMC hIMC, UINT uEscape, LPVOID lpData)
    {
        LRESULT lResult;

        _pActiveIMM->EscapeA(hKL, hIMC, uEscape, lpData, &lResult);

        return lResult;
    }

    BOOL SetStatusWindowPos(HIMC hIMC, POINT *lpptPos)
    {
        return SUCCEEDED(_pActiveIMM->SetStatusWindowPos(hIMC, lpptPos));
    }
#endif

protected:

    IActiveIMMIME_Private* m_pIActiveIMMIME;

    PauseCookie *_pPauseCookie;
    int _cRef;

public:
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv) = 0;
};

#endif // CAIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\candpos.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    candpos.h

Abstract:

    This file defines the CCandidatePosition Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CANDPOS_H_
#define _CANDPOS_H_

#include "cime.h"
#include "imtls.h"
#include "ctxtcomp.h"

class CCandidatePosition
{
public:
    HRESULT GetCandidatePosition(OUT RECT* out_rcArea);

private:
    HRESULT GetRectFromApp(IN IMTLS* ptls,
                           IN IMCLock& imc,
                           IN LANGID langid,
                           OUT RECT* out_rcArea);

    HRESULT GetRectFromHIMC(IN IMCLock& imc,
                            IN DWORD dwStyle,
                            IN POINT* ptCurrentPos,
                            IN RECT* rcArea,
                            OUT RECT* out_rcArea);

    HRESULT GetCandidateArea(IN IMCLock& imc,
                             IN DWORD dwStyle,
                             IN POINT* ptCurrentPos,
                             IN RECT* rcArea,
                             OUT RECT* out_rcArea);

    HRESULT GetRectFromCompFont(IN IMTLS* ptls,
                                IN IMCLock& imc,
                                IN POINT* ptCurrentPos,
                                OUT RECT* out_rcArea);

    HRESULT FindAttributeInCompositionString(IN IMCLock& imc,
                                             IN BYTE target_attribute,
                                             OUT CWCompCursorPos& wCursorPosition);

    HRESULT GetCursorPosition(IN IMCLock& imc,
                              OUT CWCompCursorPos& wCursorPosition);

    HRESULT GetSelection(IN IMCLock& imc,
                         OUT CWCompCursorPos& wStartSelection,
                         OUT CWCompCursorPos& wEndSelection);

    typedef enum {
        DIR_LEFT_RIGHT = 0,        // normal
        DIR_TOP_BOTTOM = 1,        // vertical
        DIR_RIGHT_LEFT = 2,        // right to left
        DIR_BOTTOM_TOP = 3         // vertical
    } DOC_DIR;

    DOC_DIR DocumentDirection(IN IMCLock& imc)
    {
        if (imc->lfFont.A.lfEscapement == 2700 ||
            imc->lfFont.A.lfEscapement == 900) {
            //
            // Vertical writting.
            //
            if (imc->lfFont.A.lfEscapement == 900 ||
                imc->lfFont.A.lfEscapement == 1800) {
                return DIR_BOTTOM_TOP;
            }
            else {
                return DIR_TOP_BOTTOM;
            }
        }
        else {
            //
            // Horizontal writting.
            //
            if (imc->lfFont.A.lfEscapement == 1800) {
                return DIR_RIGHT_LEFT;
            }
            else {
                return DIR_LEFT_RIGHT;
            }
        }
    }
};

#endif // _CANDPOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\cic.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cic.cpp

Abstract:

    This file implements the ImmIfIME Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "globals.h"
#include "imeapp.h"
#include "immif.h"
#include "profile.h"


HRESULT
ImmIfIME::QueryService(
    REFGUID guidService,
    REFIID riid,
    void **ppv
    )
{
    if (ppv == NULL) {
        return E_INVALIDARG;
    }

    *ppv = NULL;

    if (!IsEqualGUID(guidService, GUID_SERVICE_TF))
        return E_INVALIDARG /*SVC_E_UNKNOWNSERVICE*/; // SVC_E_UNKNOWNSERVICE is in msdn, but not any nt source/headers

    if (IsEqualIID(riid, IID_ITfThreadMgr)) {
        if (m_tim) {
            *ppv = SAFECAST(m_tim, ITfThreadMgr*);
            m_tim->AddRef();
            return S_OK;
        }
    }
    else {
        IMTLS *ptls = IMTLS_GetOrAlloc();

        if (ptls == NULL)
            return E_FAIL;

        IMCLock imc(ptls->hIMC);
        HRESULT hr;
        if (FAILED(hr=imc.GetResult()))
            return hr;

        if (IsEqualIID(riid, IID_ITfDocumentMgr)) {
            ITfDocumentMgr *pdim = GetDocumentManager(imc).GetPtr();
            if (pdim) {
                *ppv = SAFECAST(pdim, ITfDocumentMgr*);
                pdim->AddRef();
                return S_OK;
            }
        }
        else if (IsEqualIID(riid, IID_ITfContext)) {
            ITfContext *pic = GetInputContext(imc).GetPtr();

            if (pic) {
                *ppv = SAFECAST(pic, ITfContext*);
                pic->AddRef();
                return S_OK;
            }
        }
    }

    DebugMsg(TF_ERROR, "QueryService: cannot find the interface. riid=%p", riid);

    return E_NOINTERFACE;
}


HRESULT
ImmIfIME::InitIMMX(
    )
{
    ITfThreadMgr *tim;
    IMTLS *ptls;

    DebugMsg(TF_FUNC, "InitIMMX: entered. :: TID=%x", GetCurrentThreadId());

    HRESULT hr;

    if (m_fCicInit)
        return S_OK;

    Assert(m_tim == NULL);
    Assert(m_AImeProfile == NULL);
    Assert(m_pkm == NULL);
    Assert(m_tfClientId == TF_CLIENTID_NULL);

    ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    //
    // Create ITfThreadMgr instance.
    //
    if (ptls->tim == NULL)
    {
        if (FindAtom(TF_ENABLE_PROCESS_ATOM) && ! FindAtom(AIMM12_PROCESS_ATOM))
        {
            //
            // This is CTF aware application.
            //
            return E_NOINTERFACE;
        }

        //
        // This is AIMM1.2 aware application.
        //
        AddAtom(AIMM12_PROCESS_ATOM);
        m_fAddedProcessAtom = TRUE;

        //
        // ITfThreadMgr is per thread instance.
        //
        hr = TF_CreateThreadMgr(&tim);

        if (hr != S_OK)
        {
            Assert(0); // couldn't create tim!
            goto ExitError;
        }

        hr = tim->QueryInterface(IID_ITfThreadMgr_P, (void **)&m_tim);
        tim->Release();

        if (hr != S_OK || m_tim == NULL)
        {
            Assert(0); // couldn't find ITfThreadMgr_P
            m_tim = NULL;
            goto ExitError;
        }
        Assert(ptls->tim == NULL);
        ptls->tim = m_tim;                    // Set ITfThreadMgr instance in the TLS data.
        ptls->tim->AddRef();
    }
    else
    {
        m_tim = ptls->tim;
        m_tim->AddRef();
    }

    //
    // Create CAImeProfile instance.
    //
    if (ptls->pAImeProfile == NULL)
    {
        //
        // IAImeProfile is per thread instance.
        //
        hr = CAImeProfile::CreateInstance(NULL,
                                          IID_IAImeProfile,
                                          (void**) &m_AImeProfile);
        if (FAILED(hr))
        {
            Assert(0); // couldn't create profile
            m_AImeProfile = NULL;
            goto ExitError;
        }
        Assert(ptls->pAImeProfile == m_AImeProfile); // CreateInst will set tls
    }
    else
    {
        m_AImeProfile = ptls->pAImeProfile;
        m_AImeProfile->AddRef();
    }

    //
    // get the keystroke manager ready
    //
    if (FAILED(::GetService(m_tim, IID_ITfKeystrokeMgr, (IUnknown **)&m_pkm))) {
        Assert(0); // couldn't get ksm!
        goto ExitError;
    }

    // cleanup/error code assumes this is the last thing we do, doesn't call
    // UninitDAL on error
    if (FAILED(InitDisplayAttrbuteLib(&_libTLS)))
    {
        Assert(0); // couldn't init lib!
        goto ExitError;
    }

    m_fCicInit = TRUE;

    return S_OK;

ExitError:
    UnInitIMMX();
    return E_FAIL;
}


void
ImmIfIME::UnInitIMMX(
    )
{
    IMTLS *ptls;

    DebugMsg(TF_FUNC, TEXT("ImmIfIME::UnInitIMMX :: TID=%x"), GetCurrentThreadId());

    // clear the display lib
    UninitDisplayAttrbuteLib(&_libTLS);

    TFUninitLib_Thread(&_libTLS);

    // clear the keystroke mgr
    SafeReleaseClear(m_pkm);

    ptls = IMTLS_GetOrAlloc();

    // clear the profile
    if (m_AImeProfile != NULL)
    {
        SafeReleaseClear(m_AImeProfile);
        if (ptls != NULL)
        {
            SafeReleaseClear(ptls->pAImeProfile);
        }
    }

    // clear empty dim.
    SafeReleaseClear(m_dimEmpty);

    // clear the thread mgr
    if (m_tim != NULL)
    {
        SafeReleaseClear(m_tim);
        if (ptls != NULL)
        {
            SafeReleaseClear(ptls->tim);
        }

        //
        // Remove AIMM1.2 aware application ATOM.
        //
        ATOM atom;
        if (m_fAddedProcessAtom &&
            (atom = FindAtom(AIMM12_PROCESS_ATOM)))
        {
            DeleteAtom(atom);
            m_fAddedProcessAtom = FALSE;
        }
    }

    m_fCicInit = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping
// this).

#include <windows.h>
#include "ccstock.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "MSIMTF"
#define SZ_MODULE       "MSIMTF"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\cime.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cime.h

Abstract:

    This file defines the IMCLock / IMCCLock Class.

Author:

Revision History:

Notes:

--*/


#ifndef CIME_H
#define CIME_H

#include "idebug.h"
#include "template.h"

class CAImeContext;

#define  _ENABLE_CAIME_CONTEXT_
#include "imclock.h"


const int MAXCAND = 256;
const int CANDPERPAGE = 9;


class IMCLock : public _IMCLock
{
public:
    IMCLock(HIMC hImc=NULL);
    virtual ~IMCLock() {
        if (m_inputcontext) {
            _UnlockIMC(m_himc);
        }
    }

    // virtual InternalIMCCLock
    HRESULT _LockIMC(HIMC hIMC, INPUTCONTEXT_AIMM12** ppIMC);
    HRESULT _UnlockIMC(HIMC hIMC);

    void InitContext();
    BOOL ClearCand();

    void GenerateMessage();

    BOOL ValidCompositionString();

private:
    // Do not allow to make a copy
    IMCLock(IMCLock&) { }
};


class InternalIMCCLock : public _IMCCLock
{
public:
    InternalIMCCLock(HIMCC hImcc = NULL);
    virtual ~InternalIMCCLock() {
        if (m_pimcc) {
            _UnlockIMCC(m_himcc);
        }
    }

    // virtual InternalIMCCLock
    HRESULT _LockIMCC(HIMCC hIMCC, void** ppv);
    HRESULT _UnlockIMCC(HIMCC hIMCC);

private:
    // Do not allow to make a copy
    InternalIMCCLock(InternalIMCCLock&) { }
};


template <class T>
class IMCCLock : public InternalIMCCLock
{
public:
    IMCCLock(HIMCC hImcc) : InternalIMCCLock(hImcc) {};

    T* GetBuffer() { return (T*)m_pimcc; }

    operator T*() { return (T*)m_pimcc; }

    T* operator->() {
        ASSERT(m_pimcc);
        return (T*)m_pimcc;
    }

private:
    // Do not allow to make a copy
    IMCCLock(IMCCLock<T>&) { }
};


#endif // CIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\cmpevcb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmpevcb.h

Abstract:

    This file defines the CCompartmentEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _CMPEVCB_H_
#define _CMPEVCB_H_

class ImmIfIME;

class CCompartmentEventSinkCallBack : public CCompartmentEventSink
{
public:
    CCompartmentEventSinkCallBack(ImmIfIME* pImmIfIME);
    virtual ~CCompartmentEventSinkCallBack();

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    //
    // Callbacks
    //
private:
    static HRESULT CompartmentEventSinkCallback(void* pv, REFGUID rguid);

    ImmIfIME     *m_pImmIfIME;
};

#endif // _CMPEVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\cmpevcb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmpevcb.cpp

Abstract:

    This file implements the CCompartmentEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cmpevcb.h"
#include "cime.h"
#include "immif.h"
#include "korimx.h"


// static
HRESULT
CCompartmentEventSinkCallBack::CompartmentEventSinkCallback(
    void* pv,
    REFGUID rguid
    )
{
    DebugMsg(TF_FUNC, "CompartmentEventSinkCallback");

    IMTLS *ptls;
    HRESULT hr = S_OK;
    LANGID langid;
    BOOL fOpenChanged;

    CCompartmentEventSinkCallBack* _this = (CCompartmentEventSinkCallBack*)pv;
    ASSERT(_this);

    ImmIfIME* _ImmIfIME = _this->m_pImmIfIME;
    ASSERT(_ImmIfIME);

    fOpenChanged = _ImmIfIME->IsOpenStatusChanging();

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;

    ptls->pAImeProfile->GetLangId(&langid);

    if ((PRIMARYLANGID(langid) != LANG_KOREAN) && fOpenChanged)
        return S_OK;

    IMCLock imc(ptls->hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    if (!fOpenChanged)
    {
        DWORD fOnOff;
        hr = GetCompartmentDWORD(ptls->tim,
                                 GUID_COMPARTMENT_KEYBOARD_OPENCLOSE,
                                 &fOnOff, FALSE);
        if (SUCCEEDED(hr)) {


            if (!_ImmIfIME->IsRealIme())
            {
                imc->fOpen = (BOOL) ! ! fOnOff;

                SendMessage(imc->hWnd, WM_IME_NOTIFY, IMN_SETOPENSTATUS, 0L);
            }

            //
            // Direct input mode support for Satori.
            // When user switch to direct input mode with composition string,
            // we want finalize composition string.
            //
            if (! imc->fOpen) {
                CAImeContext* _pAImeContext = imc->m_pAImeContext;
                ASSERT(_pAImeContext != NULL);
                if (_pAImeContext == NULL)
                    return E_FAIL;

                if (_pAImeContext->m_fStartComposition) {
                    //
                    // finalize the composition before letting the world see this keystroke
                    //
                    _ImmIfIME->_CompComplete(imc);
                }
            }
        }
    }

    if ((PRIMARYLANGID(langid) == LANG_KOREAN))
    {
        DWORD fdwConvMode;

        hr = GetCompartmentDWORD(ptls->tim,
                                 GUID_COMPARTMENT_KORIMX_CONVMODE,
                                 &fdwConvMode,
                                 FALSE);
        if (SUCCEEDED(hr))
        {
            switch (fdwConvMode)
            {
                // Korean TIP ALPHANUMERIC Mode
                case KORIMX_ALPHANUMERIC_MODE:
                    imc->fdwConversion = IME_CMODE_ALPHANUMERIC;
                    break;

                // Korean TIP HANGUL Mode
                case KORIMX_HANGUL_MODE:
                    imc->fdwConversion = IME_CMODE_HANGUL;
                    break;

                // Korean TIP JUNJA Mode
                case KORIMX_JUNJA_MODE:
                    imc->fdwConversion = IME_CMODE_FULLSHAPE;
                    break;

                // Korean TIP HANGUL/JUNJA Mode
                case KORIMX_HANGULJUNJA_MODE:
                    imc->fdwConversion = IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE;
                    break;
            }
        }
    }

    return hr;
}

CCompartmentEventSinkCallBack::CCompartmentEventSinkCallBack(
    ImmIfIME* pImmIfIME) : m_pImmIfIME(pImmIfIME),
                           CCompartmentEventSink(CompartmentEventSinkCallback, NULL)
{
    m_pImmIfIME->AddRef();
};

CCompartmentEventSinkCallBack::~CCompartmentEventSinkCallBack(
    )
{
    m_pImmIfIME->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\compstr.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    compstr.cpp

Abstract:

    This file implements the CCompStrFactory Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "compstr.h"
#include "a_wrappers.h"

HRESULT
CCompStrFactory::CreateCompositionString(
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompTfGuidAtom* CompGuid,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause
    )
{
    DWORD dwCompSize = (CompStr          ? Align(CompStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (CompAttr         ? Align(CompAttr->GetSize()   * sizeof(BYTE))  : 0) +
                       (CompClause       ? Align(CompClause->GetSize() * sizeof(DWORD)) : 0) +
                       (CompReadStr      ? Align(CompReadStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (CompReadAttr     ? Align(CompReadAttr->GetSize()   * sizeof(BYTE))  : 0) +
                       (CompReadClause   ? Align(CompReadClause->GetSize() * sizeof(DWORD)) : 0) +
                       (ResultStr        ? Align(ResultStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (ResultClause     ? Align(ResultClause->GetSize() * sizeof(DWORD)) : 0) +
                       (ResultReadStr    ? Align(ResultReadStr->GetSize()    * sizeof(WCHAR)) : 0) +
                       (ResultReadClause ? Align(ResultReadClause->GetSize() * sizeof(DWORD)) : 0) +
                       (CompGuid         ? Align(CompGuid->GetSize() * sizeof(TfGuidAtom)) : 0) +      // COMPSTRING_AIMM12->dwTfGuidAtom
                       (CompGuid && CompAttr
                                         ? Align(CompAttr->GetSize() * sizeof(BYTE)) : 0);             // COMPSTRING_AIMM12->dwGuidMapAttr

#ifdef CICERO_4678
    //
    // This is another workaround instead of dimm\imewnd.cpp.
    // Even subclass window hook off, AIMM won't resize hCompStr if dwCompSize is zero.
    //
    return (dwCompSize ? _CreateCompositionString(dwCompSize) : S_OK);
#else
    return _CreateCompositionString(dwCompSize);
#endif
}

HRESULT
CCompStrFactory::CreateCompositionString(
    CWInterimString* InterimStr
    )
{
    DWORD dwCompSize = (InterimStr ? Align(InterimStr->GetSize() * sizeof(WCHAR))      : 0) +
                       Align(sizeof(WCHAR)) +    // Interim char
                       Align(sizeof(BYTE));      // Interim attr
    return _CreateCompositionString(dwCompSize);
}

HRESULT
CCompStrFactory::_CreateCompositionString(
    DWORD dwCompSize
    )

/*+++

Return Value:

    Returns S_FALSE, dwCompSize is zero.
    Returns S_OK,    dwCompSize is valid size.

---*/

{
    IMTLS *ptls = IMTLS_GetOrAlloc();
    HRESULT hr = (dwCompSize != 0 ? S_OK : S_FALSE);

    dwCompSize += sizeof(COMPOSITIONSTRING_AIMM12);

    if (m_himcc == NULL) {
        //
        // First creation. Let's initialize it now
        //
        m_himcc = ImmCreateIMCC(ptls, dwCompSize);
        if (m_himcc != NULL) {
            m_hr = _LockIMCC(m_himcc, (void**)&m_pcomp);
        }
    }
    else if (ImmGetIMCCSize(ptls, m_himcc) != dwCompSize) {
        //
        // If already have m_himcc, then recreate it.
        //
        if (m_pcomp) {
            _UnlockIMCC(m_himcc);
        }

        HIMCC hMem;

        if ((hMem = ImmReSizeIMCC(ptls, m_himcc, dwCompSize)) != NULL) {
            m_himcc = hMem;
        }
        else {
            ImmDestroyIMCC(ptls, m_himcc);
            m_himcc = ImmCreateIMCC(ptls, dwCompSize);
        }

        if (m_himcc != NULL) {
            m_hr = _LockIMCC(m_himcc, (void**)&m_pcomp);
        }
    }

    if (FAILED(m_hr))
        return m_hr;

    if (m_himcc == NULL)
        return E_OUTOFMEMORY;

    memset(m_pcomp, 0, dwCompSize);                 // clear buffer with zero.

    m_pcomp->CompStr.dwSize = dwCompSize;           // set buffer size.

    m_pEndOfData = (BYTE*)m_pcomp + sizeof(COMPOSITIONSTRING_AIMM12); // set end of the data pointer.

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\compstr.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    compstr.h

Abstract:

    This file defines the CCompStrFactory Class.

Author:

Revision History:

Notes:

--*/


#ifndef _COMPSTR_H_
#define _COMPSTR_H_

#include "cime.h"
#include "template.h"
#include "ctxtcomp.h"

class CCompStrFactory : public IMCCLock<COMPOSITIONSTRING_AIMM12>
{
public:
    CCompStrFactory(HIMCC hCompStr) : IMCCLock<COMPOSITIONSTRING_AIMM12>(hCompStr)
    {
        m_pEndOfData = NULL;
    }

    HIMCC GetHandle()
    {
        return m_himcc;
    }

    HRESULT CreateCompositionString(CWCompString* CompStr,
                                    CWCompAttribute* CompAttr,
                                    CWCompClause* CompClause,
                                    CWCompTfGuidAtom* CompGuid,
                                    CWCompString* CompReadStr,
                                    CWCompAttribute* CompReadAttr,
                                    CWCompClause* CompReadClause,
                                    CWCompString* ResultStr,
                                    CWCompClause* ResultClause,
                                    CWCompString* ResultReadStr,
                                    CWCompClause* ResultReadClause
                                   );

    HRESULT CreateCompositionString(CWInterimString* InterimStr);

    template<class CONTEXT_SRC, class ARG_TYPE>
    HRESULT WriteData(CONTEXT_SRC& context_src,
                      DWORD* context_dest_len,
                      DWORD* context_dest_off
                     )
    {
        DWORD dwLen = (DWORD)context_src.GetSize();
        DWORD dwRemainBufferSize = GetRemainBufferSize();

        if (dwLen > dwRemainBufferSize)
            return E_OUTOFMEMORY;

        *context_dest_len = dwLen;
        *context_dest_off = (DWORD)(m_pEndOfData - (BYTE*)m_pcomp);

        context_src.ReadCompData((ARG_TYPE*)m_pEndOfData, dwRemainBufferSize);
        m_pEndOfData += Align(dwLen * sizeof(ARG_TYPE));

        return S_OK;
    }

private:
    HRESULT _CreateCompositionString(DWORD dwCompSize);

    DWORD GetRemainBufferSize()
    {
        if (m_pEndOfData == NULL)
            return 0;

        return (DWORD)(m_pcomp->CompStr.dwSize > (DWORD)(m_pEndOfData - (BYTE*)m_pcomp) ? m_pcomp->CompStr.dwSize - (m_pEndOfData - (BYTE*)m_pcomp) : 0);
    }

    size_t Align(size_t a)
    {
        return (size_t) ((a + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));
    }

    BYTE*    m_pEndOfData;
};

#endif // _COMPSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\editcomp.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editcomp.h

Abstract:

    This file defines the EditCompositionString Class.

Author:

Revision History:

Notes:

--*/

#ifndef _EDITCOMP_H_
#define _EDITCOMP_H_

/////////////////////////////////////////////////////////////////////////////
// EditCompositionString

class EditCompositionString
{
public:
    HRESULT SetString(IMCLock& imc,
                      CWCompString* CompStr,
                      CWCompAttribute* CompAttr,
                      CWCompClause* CompClause,
                      CWCompCursorPos* CompCursorPos,
                      CWCompDeltaStart* CompDeltaStart,
                      CWCompTfGuidAtom* CompGuid,
                      OUT BOOL* lpbBufferOverflow,
                      CWCompString* CompReadStr = NULL,
                      CWCompAttribute* CompReadAttr = NULL,
                      CWCompClause* CompReadClause = NULL,
                      CWCompString* ResultStr = NULL,
                      CWCompClause* ResultClause = NULL,
                      CWCompString* ResultReadStr = NULL,
                      CWCompClause* ResultReadClause = NULL,
                      CWInterimString* InterimStr = NULL,
                      // n.b. ResultRead is not supported for now...
                      BOOL fGenerateMessage = TRUE);

private:

    HRESULT _MakeCompositionData(IMCLock& imc,
                                 CWCompString* CompStr,
                                 CWCompAttribute* CompAttr,
                                 CWCompClause* CompClause,
                                 CWCompCursorPos* CompCursorPos,
                                 CWCompDeltaStart* CompDeltaStart,
                                 CWCompTfGuidAtom* CompGuid,
                                 CWCompString* CompReadStr,
                                 CWCompAttribute* CompReadAttr,
                                 CWCompClause* CompReadClause,
                                 CWCompString* ResultStr,
                                 CWCompClause* ResultClause,
                                 CWCompString* ResultReadStr,
                                 CWCompClause* ResultReadClause,
                                 OUT LPARAM* lpdwFlag,
                                 OUT BOOL* lpbBufferOverflow);

    HRESULT _MakeInterimData(IMCLock& imc,
                             CWInterimString* InterimStr,
                             LPARAM* lpdwFlag);

    HRESULT _GenerateHanja(IMCLock& imc,
                           CWCompString*,
                           BOOL fGenerateMessage);

};

#endif // _EDITCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\editcomp.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editcomp.cpp

Abstract:

    This file implements the EditCompositionString Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "immif.h"
#include "editcomp.h"
#include "template.h"
#include "compstr.h"

static BOOL fHanjaRequested = FALSE; // consider: this is not thread safe

/////////////////////////////////////////////////////////////////////////////
// EditCompositionString

//
// Set (almost) all in composition string
//

HRESULT
EditCompositionString::SetString(
    IMCLock& imc,
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompCursorPos* CompCursorPos,
    CWCompDeltaStart* CompDeltaStart,
    CWCompTfGuidAtom* CompGuid,
    OUT BOOL* lpbBufferOverflow,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause,
    CWInterimString* InterimStr,
    // n.b. ResultRead is not supported for now...
    BOOL fGenerateMessage
    )
{
    HRESULT hr;
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

#ifdef UNSELECTCHECK
    if (!_pAImeContext->m_fSelected)
        return S_OK;
#endif UNSELECTCHECK

    if (_pAImeContext->m_fHanjaReConversion ||
        _pAImeContext->IsInClearDocFeedEditSession())
    {
        if (g_fTrident55 && _pAImeContext->m_fHanjaReConversion)
            fHanjaRequested = TRUE;

        return S_OK;
    }

    //
    // Clear the contents of candidate list
    //
    imc.ClearCand();

    TRANSMSG msg;
    if (InterimStr) {
        hr = _MakeInterimData(imc,
                              InterimStr,
                              &msg.lParam);
    }
    else {
        hr = _MakeCompositionData(imc,
                                  CompStr, CompAttr, CompClause,
                                  CompCursorPos, CompDeltaStart,
                                  CompGuid,
                                  CompReadStr, CompReadAttr, CompReadClause,
                                  ResultStr, ResultClause,
                                  ResultReadStr, ResultReadClause,
                                  &msg.lParam,
                                  lpbBufferOverflow);
    }
    if ( hr == S_OK ||     // In case of valid dwCompSize in the CCompStrFactory::CreateCompositionString
        (hr == S_FALSE && _pAImeContext->m_fStartComposition)
                           // In case of empty dwCompSize but still m_fStartComposition
       ) {
        //
        // Is available compstr/attr/clause, compread, result or resultread ?
        //
        bool fNoCompResultData = false;
        if (! (msg.lParam & (GCS_COMP | GCS_COMPREAD | GCS_RESULT | GCS_RESULTREAD))) {
            DebugMsg(TF_GENERAL, "EditCompositionString::SetString: No data in compstr, compread, result or resultread.");
            fNoCompResultData = true;
            if (  _pAImeContext &&
                ! _pAImeContext->m_fStartComposition) {
                DebugMsg(TF_ERROR, "EditCompositionString::SetString: No send WM_IME_STARTCOMPOSITION yet.");
                return S_FALSE;
            }
        }

        //
        // New Trident(5.5 & 6.0) had a bug to convert Hanja.
        // So _GenerateHanja() funtion try to generate message like as Korean
        // legacy IME behavior.
        //
        // Send WM_IME_ENDCOMPOSITION and then WM_IME_COMPOSITION GCS_RESULT msg.
        //
        if (g_fTrident55 && fHanjaRequested &&
            !fNoCompResultData && (msg.lParam & GCS_RESULT))
        {
            LANGID langid;
            IMTLS *ptls = IMTLS_GetOrAlloc();

            fHanjaRequested = FALSE;

            if (ptls != NULL)
                ptls->pAImeProfile->GetLangId(&langid);

            if (PRIMARYLANGID(langid) == LANG_KOREAN)
            {
                return _GenerateHanja(imc, ResultStr,  fGenerateMessage);
            }
        }

        fHanjaRequested = FALSE;

        //
        // set private input context
        //
        bool fSetStartComp = false;

        if (  _pAImeContext &&
            ! _pAImeContext->m_fStartComposition) {
            _pAImeContext->m_fStartComposition = TRUE;
            TRANSMSG start_msg;
            start_msg.message = WM_IME_STARTCOMPOSITION;
            start_msg.wParam  = (WPARAM) 0;
            start_msg.lParam  = (LPARAM) 0;
            if (_pAImeContext->m_pMessageBuffer) {
                _pAImeContext->m_pMessageBuffer->SetData(start_msg);
                fSetStartComp = true;
            }
        }

        if (! fNoCompResultData) {
            msg.message = WM_IME_COMPOSITION;

            IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);

            if (msg.lParam & GCS_RESULT)
                msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset));
            else
                msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwCompStrOffset));

            if (_pAImeContext &&
                _pAImeContext->m_pMessageBuffer) {
                _pAImeContext->m_pMessageBuffer->SetData(msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then calls QueryCharPos().
                //
                if (fSetStartComp) {
                    TRANSMSG notify_msg;
                    notify_msg.message = WM_IME_NOTIFY;
                    notify_msg.wParam = (WPARAM)WM_IME_STARTCOMPOSITION;
                    notify_msg.lParam = 0;
                    _pAImeContext->m_pMessageBuffer->SetData(notify_msg);
                }
            }
        }
        else {
            msg.message = WM_IME_COMPOSITION;
            msg.wParam = (WPARAM)VK_ESCAPE;
            msg.lParam = (LPARAM)(GCS_COMPREAD | GCS_COMP | GCS_CURSORPOS | GCS_DELTASTART);
            if (_pAImeContext &&
                _pAImeContext->m_pMessageBuffer)
                _pAImeContext->m_pMessageBuffer->SetData(msg);
        }

        if ((ResultStr && ResultStr->GetSize() && !(msg.lParam & GCS_COMP)) 
           || fNoCompResultData) {
            //
            // We're ending the composition
            //
            if (_pAImeContext)
                _pAImeContext->m_fStartComposition = FALSE;
            TRANSMSG end_msg;
            end_msg.message = WM_IME_ENDCOMPOSITION;
            end_msg.wParam  = (WPARAM) 0;
            end_msg.lParam  = (LPARAM) 0;
            if (_pAImeContext &&
                _pAImeContext->m_pMessageBuffer) {
                _pAImeContext->m_pMessageBuffer->SetData(end_msg);

                //
                // Internal notification to UI window
                // When receive this msg in UI wnd, then clear QueryCharPos's flag.
                //
                TRANSMSG notify_msg;
                notify_msg.message = WM_IME_NOTIFY;
                notify_msg.wParam = (WPARAM)WM_IME_ENDCOMPOSITION;
                notify_msg.lParam = 0;
                _pAImeContext->m_pMessageBuffer->SetData(notify_msg);
            }
        }

#ifdef DEBUG
        IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
#endif

        if (fGenerateMessage) {
            imc.GenerateMessage();
        }
    }

    return hr;
}


//
// Make composition string data in the IMCCLock<_COMPOSITIONSTRING> comp.
//

HRESULT
EditCompositionString::_MakeCompositionData(
    IMCLock& imc,
    CWCompString* CompStr,
    CWCompAttribute* CompAttr,
    CWCompClause* CompClause,
    CWCompCursorPos* CompCursorPos,
    CWCompDeltaStart* CompDeltaStart,
    CWCompTfGuidAtom* CompGuid,
    CWCompString* CompReadStr,
    CWCompAttribute* CompReadAttr,
    CWCompClause* CompReadClause,
    CWCompString* ResultStr,
    CWCompClause* ResultClause,
    CWCompString* ResultReadStr,
    CWCompClause* ResultReadClause,
    OUT LPARAM* lpdwFlag,
    OUT BOOL* lpbBufferOverflow
    )
{
    DebugMsg(TF_FUNC, "EditCompositionString::MakeCompositionData");

    *lpdwFlag = (LPARAM) 0;

    HRESULT hr;

    CCompStrFactory compstrfactory(imc->hCompStr);
    if (FAILED(hr=compstrfactory.GetResult()))
        return hr;

    hr = compstrfactory.CreateCompositionString(CompStr,
                                                CompAttr,
                                                CompClause,
                                                CompGuid,
                                                CompReadStr,
                                                CompReadAttr,
                                                CompReadClause,
                                                ResultStr,
                                                ResultClause,
                                                ResultReadStr,
                                                ResultReadClause
                                              );
    if (FAILED(hr))
        return hr;

    //
    // Composition string
    //
    if (lpbBufferOverflow != NULL)
        *lpbBufferOverflow = FALSE;

    if (CompStr && CompStr->GetSize()) {
#if 0
        /*
         * If composition string length over the buffer of COMPOSITIONSTRING.compstr[NMAXKEY],
         * then we want to finalize this composition string.
         */
        if ((*comp)->dwCompStrLen >= NMAXKEY) {
            if (lpbBufferOverflow != NULL)
                *lpbBufferOverflow = TRUE;
            //
            // Clear compsition string length.
            //
            (*comp)->dwCompStrLen = 0;
            //
            // Make result string.
            //
            (*comp)->dwResultStrLen = NMAXKEY;
            CompStr->ReadCompData((*comp)->W.resultstr, ARRAYSIZE((*comp)->W.resultstr));
            *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
        }
        else
#endif
        {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*CompStr,
                                                               &compstrfactory->CompStr.dwCompStrLen,
                                                               &compstrfactory->CompStr.dwCompStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_COMPSTR;
        }
    }

    if ((lpbBufferOverflow == NULL) ||
        (lpbBufferOverflow != NULL && (! *lpbBufferOverflow))) {

        //
        // Compoition attribute
        //
        if (CompAttr && CompAttr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompAttr,
                                                                 &compstrfactory->CompStr.dwCompAttrLen,
                                                                 &compstrfactory->CompStr.dwCompAttrOffset
                                                                );
            *lpdwFlag |= (LPARAM) GCS_COMPATTR;
        }

        //
        // Compoition clause
        //
        if (CompClause && CompClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*CompClause,
                                                               &compstrfactory->CompStr.dwCompClauseLen,
                                                               &compstrfactory->CompStr.dwCompClauseOffset
                                                              );
            compstrfactory->CompStr.dwCompClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_COMPCLAUSE;
        }

        //
        // Composition Reading string
        //
        if (CompReadStr && CompReadStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*CompReadStr,
                                                               &compstrfactory->CompStr.dwCompReadStrLen,
                                                               &compstrfactory->CompStr.dwCompReadStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_COMPREADSTR;
        }

        //
        // Compoition Reading attribute
        //
        if (CompReadAttr && CompReadAttr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompReadAttr,
                                                                 &compstrfactory->CompStr.dwCompReadAttrLen,
                                                                 &compstrfactory->CompStr.dwCompReadAttrOffset
                                                                );
            *lpdwFlag |= (LPARAM) GCS_COMPREADATTR;
        }

        //
        // Composition Reading clause
        //
        if (CompReadClause && CompReadClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*CompReadClause,
                                                               &compstrfactory->CompStr.dwCompReadClauseLen,
                                                               &compstrfactory->CompStr.dwCompReadClauseOffset
                                                              );
            compstrfactory->CompStr.dwCompReadClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_COMPREADCLAUSE;
        }

        //
        // Result String
        //
        if (ResultStr && ResultStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*ResultStr,
                                                               &compstrfactory->CompStr.dwResultStrLen,
                                                               &compstrfactory->CompStr.dwResultStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
        }

        //
        // Result clause
        //
        if (ResultClause && ResultClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*ResultClause,
                                                               &compstrfactory->CompStr.dwResultClauseLen,
                                                               &compstrfactory->CompStr.dwResultClauseOffset
                                                              );
            compstrfactory->CompStr.dwResultClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_RESULTCLAUSE;
        }

        //
        // Result Reading string
        //
        if (ResultReadStr && ResultReadStr->GetSize()) {
            hr = compstrfactory.WriteData<CWCompString, WCHAR>(*ResultReadStr,
                                                               &compstrfactory->CompStr.dwResultReadStrLen,
                                                               &compstrfactory->CompStr.dwResultReadStrOffset
                                                              );
            *lpdwFlag |= (LPARAM) GCS_RESULTREADSTR;
        }

        //
        // Result Reading clause
        //
        if (ResultReadClause && ResultReadClause->GetSize()) {
            hr = compstrfactory.WriteData<CWCompClause, DWORD>(*ResultReadClause,
                                                               &compstrfactory->CompStr.dwResultReadClauseLen,
                                                               &compstrfactory->CompStr.dwResultReadClauseOffset
                                                              );
            compstrfactory->CompStr.dwResultReadClauseLen *= sizeof(DWORD);
            *lpdwFlag |= (LPARAM) GCS_RESULTREADCLAUSE;
        }

        //
        // TfGuidAtom
        //
        if (CompGuid && CompGuid->GetSize()) {

            // set INIT_GUID_ATOM flag in the fdwInit.
            imc->fdwInit |= INIT_GUID_ATOM;

            hr = compstrfactory.WriteData<CWCompTfGuidAtom, TfGuidAtom>(*CompGuid,
                                                                        &compstrfactory->dwTfGuidAtomLen,
                                                                        &compstrfactory->dwTfGuidAtomOffset
                                                                       );
            // temporary make a buffer of dwGuidMapAttr
            if (CompAttr && CompAttr->GetSize()) {
                hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(*CompAttr,
                                                                     &compstrfactory->dwGuidMapAttrLen,
                                                                     &compstrfactory->dwGuidMapAttrOffset
                                                                    );
            }
        }
    }

    //
    // Composition Cursor Position
    //
    if (CompCursorPos && CompCursorPos->GetSize()) {
        CompCursorPos->ReadCompData(&compstrfactory->CompStr.dwCursorPos, 1);
        *lpdwFlag |= (LPARAM) GCS_CURSORPOS;
    }

    //
    // Delta Start
    //
    if (CompDeltaStart && CompDeltaStart->GetSize()) {
        CompDeltaStart->ReadCompData(&compstrfactory->CompStr.dwDeltaStart, 1);
        *lpdwFlag |= (LPARAM) GCS_DELTASTART;
    }

    //
    // Copy back hCompStr to the Input Context
    //
    imc->hCompStr = compstrfactory.GetHandle();

    return hr;
}

//
// Make interim string data in the IMCCLock<_COMPOSITIONSTRING> comp.
//

HRESULT
EditCompositionString::_MakeInterimData(
    IMCLock& imc,
    CWInterimString* InterimStr,
    LPARAM* lpdwFlag
    )
{
    DebugMsg(TF_FUNC, "EditCompositionString::MakeInterimData");

    *lpdwFlag = (LPARAM) 0;

    //
    // Interim character and result string
    //

    HRESULT hr;

    CCompStrFactory compstrfactory(imc->hCompStr);
    if (FAILED(hr=compstrfactory.GetResult()))
        return hr;

    hr = compstrfactory.CreateCompositionString(InterimStr);
    if (FAILED(hr))
        return hr;

    //
    // Result string
    //
    if (InterimStr && InterimStr->GetSize()) {
        hr = compstrfactory.WriteData<CWInterimString, WCHAR>(*InterimStr,
                                                              &compstrfactory->CompStr.dwResultStrLen,
                                                              &compstrfactory->CompStr.dwResultStrOffset
                                                             );
        *lpdwFlag |= (LPARAM) GCS_RESULTSTR;
    }

    //
    // Composition string (Interim character)
    // Compoition attribute
    //
    CWCompString ch;
    CWCompAttribute attr;
    InterimStr->ReadInterimChar(&ch, &attr);
    if (ch.GetSize() && ch.GetAt(0)) {
        hr = compstrfactory.WriteData<CWCompString, WCHAR>(ch,
                                                           &compstrfactory->CompStr.dwCompStrLen,
                                                           &compstrfactory->CompStr.dwCompStrOffset
                                                          );
        *lpdwFlag |= (LPARAM) GCS_COMPSTR;

        hr = compstrfactory.WriteData<CWCompAttribute, BYTE>(attr,
                                                             &compstrfactory->CompStr.dwCompAttrLen,
                                                             &compstrfactory->CompStr.dwCompAttrOffset
                                                            );
        *lpdwFlag |= (LPARAM) GCS_COMPATTR;

        *lpdwFlag |= (LPARAM) CS_INSERTCHAR | CS_NOMOVECARET;
    }

    //
    // Copy back hCompStr to the Input Context
    //
    imc->hCompStr = compstrfactory.GetHandle();

    return hr;
}

//
// Generate WM_IME_ENDCOMPOSITION and WM_IME_COMPOSITION message for
// Trident 5.5 version. Since Trident 5.5 always expect WM_IME_ENDCOMPOSITION
// first in case of Hanja conversion.
//

HRESULT
EditCompositionString::_GenerateHanja(IMCLock& imc,
    CWCompString* ResultStr,
    BOOL fGenerateMessage)
{
    HRESULT hr = S_OK;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    if (_pAImeContext == NULL)
        return E_FAIL;

    if (ResultStr && ResultStr->GetSize())
    {
        //
        // We're ending the composition
        //
        if (_pAImeContext)
            _pAImeContext->m_fStartComposition = FALSE;

        TRANSMSG end_msg;
        end_msg.message = WM_IME_ENDCOMPOSITION;
        end_msg.wParam  = (WPARAM) 0;
        end_msg.lParam  = (LPARAM) 0;

        if (_pAImeContext &&
            _pAImeContext->m_pMessageBuffer)
        {
            _pAImeContext->m_pMessageBuffer->SetData(end_msg);

            //
            // Internal notification to UI window
            // When receive this msg in UI wnd, then clear QueryCharPos's flag.
            //
            TRANSMSG notify_msg;

            notify_msg.message = WM_IME_NOTIFY;
            notify_msg.wParam = (WPARAM)WM_IME_ENDCOMPOSITION;
            notify_msg.lParam = 0;
            _pAImeContext->m_pMessageBuffer->SetData(notify_msg);
        }

        TRANSMSG result_msg;
        result_msg.message = WM_IME_COMPOSITION;
        result_msg.lParam = GCS_RESULT;

        IMCCLock<COMPOSITIONSTRING> pCompStr((HIMCC)imc->hCompStr);

        result_msg.wParam  = (WPARAM)(*(WCHAR*)pCompStr.GetOffsetPointer(pCompStr->dwResultStrOffset));

        if (_pAImeContext &&
            _pAImeContext->m_pMessageBuffer)
        {
            _pAImeContext->m_pMessageBuffer->SetData(result_msg);
        }
    }


#ifdef DEBUG
    IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);
#endif

    if (fGenerateMessage)
    {
        imc.GenerateMessage();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\editses.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editses.cpp

Abstract:

    This file implements the EditSession Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "ctffunc.h"

#include "editses.h"
#include "globals.h"
#include "resource.h"
#include "candpos.h"

#include "proputil.h"

/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSessionCallBack

HRESULT
ImmIfEditSessionCallBack::GetAllTextRange(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>* range,
    LONG* lpTextLength,
    TF_HALTCOND* lpHaltCond
    )
{
    ITfRange *rangeFull = NULL;
    HRESULT hr;
    BOOL fFound = FALSE;
    BOOL fIsReadOnlyRange = FALSE;
    ITfProperty *prop;
    ITfRange *rangeTmp;
    LONG cch;

    //
    // init lpTextLength first.
    //
    *lpTextLength = 0;

    //
    // Create the range that covers all the text.
    //
    if (FAILED(hr=ic->GetStart(ec, &rangeFull)))
        return hr;

    if (FAILED(hr=rangeFull->ShiftEnd(ec, LONG_MAX, &cch, lpHaltCond)))
        return hr;

    //
    // find the first non readonly range in the text store.
    //
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, rangeFull)))
        {
            while(!fFound && (enumranges->Next(1, &rangeTmp, NULL) == S_OK))
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_EMPTY) || (var.lVal == 0))
                {
                    fFound = TRUE;
                    hr = rangeTmp->Clone(*range);
                    rangeTmp->Release();
                    break;
                }

                fIsReadOnlyRange = TRUE;
                rangeTmp->Release();
            }
            enumranges->Release();
        }
        prop->Release();
    }

    if (FAILED(hr))
        return hr;

    if (!fFound)
    {
        if (fIsReadOnlyRange)
        {
            //
            // all text store is readonly. So we just return an empty range.
            //
            if (FAILED(hr = GetSelectionSimple(ec, ic.GetPtr(), *range)))
                return hr;

            if (FAILED(hr = (*range)->Collapse(ec, TF_ANCHOR_START)))
                return hr;

        }
        else 
        {
            if (FAILED(hr = rangeFull->Clone(*range)))
                return hr;

            *lpTextLength = cch;
        }
    }
    else
    {
        *lpTextLength = 0;

        if (SUCCEEDED((*range)->Clone(&rangeTmp)))
        {
            BOOL fEmpty;
            WCHAR wstr[256 + 1];
            ULONG ul = 0;

            while (rangeTmp->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
            {
                ULONG ulcch;
                rangeTmp->GetText(ec, 
                                  TF_TF_MOVESTART, 
                                  wstr, 
                                  ARRAYSIZE(wstr) - 1, 
                                  &ulcch);
                ul += ulcch;
            }

            rangeTmp->Release();

            *lpTextLength = (LONG)ul;
        }
    }

    SafeRelease(rangeFull);

    return S_OK;
}


HRESULT
ImmIfEditSessionCallBack::SetTextInRange(
    TfEditCookie ec,
    ITfRange* range,
    LPWSTR psz,
    DWORD len,
    CAImeContext* pAImeContext
    )
{
    pAImeContext->_fModifyingDoc = TRUE;

    //
    // Set the text in Cicero TOM
    //
    HRESULT hr = range->SetText(ec, 0, psz, len);

    pAImeContext->_fModifyingDoc = FALSE;

    return hr;
}


HRESULT
ImmIfEditSessionCallBack::ClearTextInRange(
    TfEditCookie ec,
    ITfRange* range,
    CAImeContext* pAImeContext
    )
{
    //
    // Clear the text in Cicero TOM
    //
    return SetTextInRange(ec, range, NULL, 0, pAImeContext);
}


HRESULT
ImmIfEditSessionCallBack::GetReadingString(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    CWCompString& reading_string,
    CWCompClause& reading_clause
    )
{
    HRESULT hr;

    Interface<ITfRange> range;
    LONG l;
    if (FAILED(hr=GetAllTextRange(ec, ic, &range, &l)))
        return hr;

    return GetReadingString(ec, ic, range, reading_string, reading_clause);
}

HRESULT
ImmIfEditSessionCallBack::GetReadingString(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    ITfRange* range,
    CWCompString& reading_string,
    CWCompClause& reading_clause
    )
{
    HRESULT hr;

    EnumReadingPropertyArgs args;
    if (FAILED(hr=ic->GetProperty(GUID_PROP_READING, args.Property)))
        return hr;

    Interface<IEnumTfRanges> EnumReadingProperty;
    hr = args.Property->EnumRanges(ec, EnumReadingProperty, range);
    if (FAILED(hr))
        return hr;

    args.ec = ec;
    args.reading_string = &reading_string;
    args.reading_clause = &reading_clause;
    args.ulClausePos = (reading_clause.GetSize() > 0 ? reading_clause[ reading_clause.GetSize() - 1]
                                                     : 0);

    CEnumrateInterface<IEnumTfRanges,
                       ITfRange,
                       EnumReadingPropertyArgs>  Enumrate(EnumReadingProperty,
                                                          EnumReadingPropertyCallback,
                                                          &args);      // Argument of callback func.
    Enumrate.DoEnumrate();

    return S_OK;
}

//
// Enumrate callbacks
//

/* static */
ENUM_RET
ImmIfEditSessionCallBack::EnumReadingPropertyCallback(
    ITfRange* pRange,
    EnumReadingPropertyArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, pRange, &var);
    if (SUCCEEDED(hr)) {
        if (V_VT(&var) == VT_BSTR) {
            BSTR bstr = V_BSTR(&var);
            LONG cch = SysStringLen(bstr);
            pargs->reading_string->AddCompData(bstr, cch);

            if (pargs->reading_clause->GetSize() == 0)
                pargs->reading_clause->Add(0);

            pargs->reading_clause->Add( pargs->ulClausePos += cch );
        }
        VariantClear(&var);
    }

    return ret;
}


HRESULT
ImmIfEditSessionCallBack::CompClauseToResultClause(
    IMCLock& imc,
    CWCompClause& result_clause,
    UINT          cch
    )
{
    LONG num_of_written;
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls && ptls->pAImm) {

        // Check GCS_COMPCLAUSE office set
        IMCCLock<COMPOSITIONSTRING> lpCompStr(imc->hCompStr);
        if (lpCompStr.Invalid())
            return E_FAIL;

        if (lpCompStr->dwCompClauseOffset > lpCompStr->dwSize)
            return E_FAIL;

        if (lpCompStr->dwCompClauseOffset + lpCompStr->dwCompClauseLen > lpCompStr->dwSize)
            return E_FAIL;

        if (SUCCEEDED(ptls->pAImm->GetCompositionStringW((HIMC)imc,
                                               GCS_COMPCLAUSE,
                                               0, &num_of_written, NULL))) {
            DWORD* buffer = new DWORD[ num_of_written / sizeof(DWORD) ];
            if (buffer != NULL) {
                ptls->pAImm->GetCompositionStringW((HIMC)imc,
                                             GCS_COMPCLAUSE,
                                             num_of_written, &num_of_written, buffer);
 
                int idx = num_of_written / sizeof(DWORD);
                if (idx > 1)
                {
                    idx -= 1;
                    if (buffer[idx] == cch)
                    {
                        result_clause.WriteCompData(buffer, num_of_written / sizeof(DWORD));
                    }
                    else
                    {
                        // this is the case comp clause is corrupted
                        // it is the least we can do for the failure case
                        buffer[0] = 0;
                        buffer[1] = cch;
                        result_clause.WriteCompData(buffer, 2);
                    }
                }

                delete [] buffer;
            }
        }
    }
    return S_OK;
}


//
// Get cursor position
//
HRESULT
ImmIfEditSessionCallBack::_GetCursorPosition(
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    CWCompCursorPos& CompCursorPos,
    CWCompAttribute& CompAttr
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    CAImeContext::IME_QUERY_POS qpos = CAImeContext::IME_QUERY_POS_UNKNOWN;

    if (_pAImeContext->m_fStartComposition) {
        //
        // This method should not call before sending WM_IME_STARTCOMPOSITION
        // because some apps confusing to receive QUERYCHARPOSITION due to
        // no composing.
        //
        _pAImeContext->InquireIMECharPosition(imc, &qpos);
    }

    //
    // Is apps support "query positioning" ?
    //
    if ((g_fInLegacyClsid || g_fAIMM12Trident) &&
        qpos != CAImeContext::IME_QUERY_POS_YES) {

        //
        // IE5.0 candidate window positioning code.
        // They except of it position from COMPOSITIONSTRING.dwCursorPos.
        //
        INT_PTR ich = 0;
        INT_PTR attr_size;

        if (attr_size = CompAttr.GetSize()) {
            while (ich < attr_size && CompAttr[ich] != ATTR_TARGET_CONVERTED)
                ich++;
            if (ich < attr_size) {
                CompCursorPos.Set((DWORD)ich);
                return S_OK;
            }
        }
    }

    HRESULT hr;
    Interface_TFSELECTION sel;
    ULONG cFetched;

    if (SUCCEEDED(hr = ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched))) {
        Interface<ITfRange> start;
        LONG ich;
        TF_HALTCOND hc;

        hc.pHaltRange = sel->range;
        hc.aHaltPos = (sel->style.ase == TF_AE_START) ? TF_ANCHOR_START : TF_ANCHOR_END;
        hc.dwFlags = 0;

        if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &ich, &hc))) {
            CompCursorPos.Set(ich);
        }
    }

    return hr;
}




//
// Get text and attribute in given range
//
//                                ITfRange::range
//   TF_ANCHOR_START
//    |======================================================================|
//                        +--------------------+          #+----------+
//                        |ITfRange::pPropRange|          #|pPropRange|
//                        +--------------------+          #+----------+
//                        |     GUID_ATOM      |          #
//                        +--------------------+          #
//    ^^^^^^^^^^^^^^^^^^^^                      ^^^^^^^^^^#
//    ITfRange::gap_range                       gap_range #
//                                                        #
//                                                        V
//                                                        ITfRange::no_display_attribute_range
//                                                   result_comp
//                                          +1   <-       0    ->     -1
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttribute(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& rangeIn,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& CompReadStr,
    CWCompClause& CompReadClause,
    CWCompString& ResultStr,
    CWCompClause& ResultClause,
    CWCompString& ResultReadStr,
    CWCompClause& ResultReadClause,
    BOOL bInWriteSession
    )
{
    //
    // Get no display attribute range if there exist.
    // Otherwise, result range is the same to input range.
    //
    LONG result_comp;
    Interface<ITfRange> no_display_attribute_range;
    if (FAILED(rangeIn->Clone(no_display_attribute_range)))
        return E_FAIL;

    if (FAILED(_GetNoDisplayAttributeRange(pLibTLS,
                                           ec,
                                           ic,
                                           rangeIn,
                                           no_display_attribute_range)))
        return E_FAIL;

     
    Interface<ITfProperty> propComp;
    Interface<IEnumTfRanges> enumComp;
    VARIANT var;

    HRESULT hr;
    if (FAILED(hr = ic->GetProperty(GUID_PROP_COMPOSING, propComp)))
        return hr;

    if (FAILED(hr = propComp->EnumRanges(ec, enumComp, rangeIn)))
        return hr;

    CompClause.Add(0);         // setup composition clause at 0
    ResultClause.Add(0);       // setup result clause at 0

    Interface<ITfRange>  range;
    while(enumComp->Next(1, range, NULL) == S_OK)
    {

        BOOL fCompExist = FALSE;

        hr = propComp->GetValue(ec, range, &var);
        if (S_OK == hr)
        {
            if (var.vt == VT_I4 && var.lVal != 0)
                fCompExist = TRUE;
        }

        ULONG ulNumProp;

        //
        // Get display attribute track property range
        //
        Interface<IEnumTfRanges> enumProp;
        Interface<ITfReadOnlyProperty> prop;
        if (FAILED(GetDisplayAttributeTrackPropertyRange(ec, ic.GetPtr(), range, prop, enumProp, &ulNumProp))) {
            return E_FAIL;
        }
    
        // use text range for get text
        Interface<ITfRange> textRange;
        if (FAILED(range->Clone(textRange)))
            return E_FAIL;

        // use text range for gap text (no property range).
        Interface<ITfRange> gap_range;
        if (FAILED(range->Clone(gap_range)))
            return E_FAIL;


        ITfRange* pPropRange = NULL;
        while (enumProp->Next(1, &pPropRange, NULL) == S_OK) {

            // pick up the gap up to the next property
            gap_range->ShiftEndToRange(ec, pPropRange, TF_ANCHOR_START);

            //
            // GAP range
            //
            no_display_attribute_range->CompareStart(ec,
                                                     gap_range,
                                                     TF_ANCHOR_START,
                                                     &result_comp);
            _GetTextAndAttributeGapRange(pLibTLS,
                                         ec,
                                         imc,
                                         gap_range,
                                         result_comp,
                                         CompStr, CompAttr, CompClause, CompGuid,
                                         ResultStr, ResultClause);

            //
            // Get display attribute data if some GUID_ATOM exist.
            //
            TF_DISPLAYATTRIBUTE da;
            TfGuidAtom guidatom = TF_INVALID_GUIDATOM;

            GetDisplayAttributeData(pLibTLS, ec, prop, pPropRange, &da, &guidatom, ulNumProp);

            
            //
            // Property range
            //
            no_display_attribute_range->CompareStart(ec,
                                                     pPropRange,
                                                     TF_ANCHOR_START,
                                                     &result_comp);

            // Adjust GAP range's start anchor to the end of proprty range.
            gap_range->ShiftStartToRange(ec, pPropRange, TF_ANCHOR_END);
    
            //
            // Get reading string from property.
            //
            if (fCompExist == TRUE && result_comp <= 0)
                GetReadingString(ec, ic, pPropRange, CompReadStr, CompReadClause);
            else
                GetReadingString(ec, ic, pPropRange, ResultReadStr, ResultReadClause);
    
            //
            // Get property text
            //
            _GetTextAndAttributePropertyRange(pLibTLS,
                                              ec,
                                              imc,
                                              pPropRange,
                                              fCompExist,
                                              result_comp,
                                              bInWriteSession,
                                              da,
                                              guidatom,
                                              CompStr, CompAttr, CompClause, CompGuid,
                                              ResultStr, ResultClause);

            SafeReleaseClear(pPropRange);

        } // while

        // the last non-attr
        textRange->ShiftStartToRange(ec, gap_range, TF_ANCHOR_START);
        textRange->ShiftEndToRange(ec, range, TF_ANCHOR_END);

        LONG ulClausePos = 0;
        BOOL fEmpty;
        while (textRange->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
        {
            WCHAR wstr0[256 + 1];
            ULONG ulcch0 = ARRAYSIZE(wstr0) - 1;
            textRange->GetText(ec, TF_TF_MOVESTART, wstr0, ulcch0, &ulcch0);

            TfGuidAtom guidatom;
            guidatom = TF_INVALID_GUIDATOM;

            TF_DISPLAYATTRIBUTE da;
            da.bAttr = TF_ATTR_INPUT;

            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
            ulClausePos += ulcch0;
        }

        if (ulClausePos) {
            DWORD last_clause;
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        textRange->Collapse(ec, TF_ANCHOR_END);

        range->Release();
        *(ITfRange **)(range) = NULL;

    } // out-most while for GUID_PROP_COMPOSING

    //
    // Fix up empty clause
    //
    if (CompClause.GetSize() <= 1)
        CompClause.RemoveAll();
    if (ResultClause.GetSize() <= 1)
        ResultClause.RemoveAll();


    return S_OK;
}

//
// Retrieve text from gap range
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttributeGapRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface<ITfRange>& gap_range,
    LONG result_comp,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& ResultStr,
    CWCompClause& ResultClause
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    TfGuidAtom guidatom;
    guidatom = TF_INVALID_GUIDATOM;

    TF_DISPLAYATTRIBUTE da;
    da.bAttr = TF_ATTR_INPUT;

    ULONG ulClausePos = 0;
    BOOL fEmpty;
    WCHAR wstr0[256 + 1];
    ULONG ulcch0;


    while (gap_range->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        Interface<ITfRange> backup_range;
        if (FAILED(gap_range->Clone(backup_range)))
            return E_FAIL;

        //
        // Retrieve gap text if there exist.
        //
        ulcch0 = ARRAYSIZE(wstr0) - 1;
        if (FAILED(gap_range->GetText(ec,
                           TF_TF_MOVESTART,    // Move range to next after get text.
                           wstr0,
                           ulcch0, &ulcch0)))
            return E_FAIL;

        ulClausePos += ulcch0;

        if (result_comp <= 0) {
            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
        }
        else {
            ResultStr.AddCompData(wstr0, ulcch0);
            if (_pAImeContext)
                ClearTextInRange(ec, backup_range, _pAImeContext);
        }
    }

    if (ulClausePos) {
        DWORD last_clause;
        if (result_comp <= 0) {
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        else {
            if (ResultClause.GetSize() > 0) {
                last_clause = ResultClause[ ResultClause.GetSize() - 1 ];
                ResultClause.Add( last_clause + ulClausePos );
            }
        }
    }

    return S_OK;
}

//
// Retrieve text from property range
//

HRESULT
ImmIfEditSessionCallBack::_GetTextAndAttributePropertyRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    ITfRange* pPropRange,
    BOOL fCompExist,
    LONG result_comp,
    BOOL bInWriteSession,
    TF_DISPLAYATTRIBUTE da,
    TfGuidAtom guidatom,
    CWCompString& CompStr,
    CWCompAttribute& CompAttr,
    CWCompClause& CompClause,
    CWCompTfGuidAtom& CompGuid,
    CWCompString& ResultStr,
    CWCompClause& ResultClause
    )
{
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    ULONG ulClausePos = 0;
    BOOL fEmpty;
    WCHAR wstr0[256 + 1];
    ULONG ulcch0;

    while (pPropRange->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
    {
        Interface<ITfRange> backup_range;
        if (FAILED(pPropRange->Clone(backup_range)))
            return E_FAIL;

        //
        // Retrieve property text if there exist.
        //
        ulcch0 = ARRAYSIZE(wstr0) - 1;
        if (FAILED(pPropRange->GetText(ec,
                            TF_TF_MOVESTART,    // Move range to next after get text.
                            wstr0,
                            ulcch0, &ulcch0)))
            return E_FAIL;

        ulClausePos += ulcch0;  // we only need to addup the char position for clause info

        // see if there is a valid disp attribute
        if (fCompExist == TRUE && result_comp <= 0)
        {
            if (guidatom == TF_INVALID_GUIDATOM) {
                da.bAttr = TF_ATTR_INPUT;
            }
            CompGuid.AddCompData(guidatom, ulcch0);
            CompAttr.AddCompData(_ConvertAttributeToImm32(da.bAttr), ulcch0);
            CompStr.AddCompData(wstr0, ulcch0);
        }
        else if (bInWriteSession)
        {
            // if there's no disp attribute attached, it probably means 
            // the part of string is finalized.
            //
            ResultStr.AddCompData(wstr0, ulcch0);
            
            // it was a 'determined' string
            // so the doc has to shrink
            //
            if (_pAImeContext)
                ClearTextInRange(ec, backup_range, _pAImeContext);
        }
        else
        {
            //
            // Prevent infinite loop
            //
            break;
        }
    }

    if (ulClausePos) {
        DWORD last_clause;
        if (fCompExist == TRUE && result_comp <= 0) {
            if (CompClause.GetSize() > 0) {
                last_clause = CompClause[ CompClause.GetSize() - 1 ];
                CompClause.Add( last_clause + ulClausePos );
            }
        }
        else if (result_comp == 0) {
            //
            // Copy CompClause data to ResultClause
            //
            CompClauseToResultClause(imc, ResultClause, ulcch0);
        }
        else {
            if (ResultClause.GetSize() > 0) {
                last_clause = ResultClause[ ResultClause.GetSize() - 1 ];
                ResultClause.Add( last_clause + ulClausePos );
            }
        }
    }

    return S_OK;
}

HRESULT
ImmIfEditSessionCallBack::_GetNoDisplayAttributeRange(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& rangeIn,
    Interface<ITfRange>& no_display_attribute_range
    )
{
    Interface<ITfProperty> propComp;
    Interface<IEnumTfRanges> enumComp;
    VARIANT var;

    HRESULT hr = ic->GetProperty(GUID_PROP_COMPOSING, propComp);
    if (S_OK == hr)
    {
        hr = propComp->EnumRanges(ec, enumComp, rangeIn);
    }
    else
        return hr;

    ITfRange *pRange;

    while(enumComp->Next(1, &pRange, NULL) == S_OK)
    {

        BOOL fCompExist = FALSE;

        hr = propComp->GetValue(ec, pRange, &var);
        if (S_OK == hr)
        {
            if (var.vt == VT_I4 && var.lVal != 0)
                fCompExist = TRUE;
        }

        if (!fCompExist) {

            // Adjust GAP range's start anchor to the end of proprty range.
            no_display_attribute_range->ShiftStartToRange(ec, pRange, TF_ANCHOR_START);
        }
        pRange->Release();
    }


    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSession

ImmIfEditSession::ImmIfEditSession(
    ESCB escb,
    TfClientId tid,
    Interface_Attach<ImmIfIME> ImmIfIme,
    IMCLock& imc
    ) : m_ImmIfIme(ImmIfIme), m_ic(ImmIfIme->GetInputContext(imc)), m_tid(tid),
        m_state((HIMC)imc)
{
    _Init(escb);
}

ImmIfEditSession::ImmIfEditSession(
    ESCB escb,
    TfClientId tid,
    Interface_Attach<ImmIfIME> ImmIfIme,
    IMCLock& imc,
    Interface_Attach<ITfContext> pic
    ) : m_ImmIfIme(ImmIfIme), m_ic(pic), m_tid(tid),
        m_state((HIMC)imc)
{
    _Init(escb);
}

void 
ImmIfEditSession::_Init(
    ESCB escb
    )
{
    m_pfnCallback = EditSessionCallBack;
    m_cRef        = 1;

    m_ImmIfCallBack  = NULL;

    switch(escb) {
        case ESCB_HANDLETHISKEY:
            m_ImmIfCallBack = new ImmIfHandleThisKey;
            break;
        case ESCB_COMPCOMPLETE:
            m_ImmIfCallBack = new ImmIfCompositionComplete;
            break;
        case ESCB_COMPCANCEL:
            m_ImmIfCallBack = new ImmIfCompositionCancel;
            break;
        case ESCB_UPDATECOMPOSITIONSTRING:
            m_ImmIfCallBack = new ImmIfUpdateCompositionString;
            break;
        case ESCB_REPLACEWHOLETEXT:
            m_ImmIfCallBack = new ImmIfReplaceWholeText;
            break;
        case ESCB_RECONVERTSTRING:
            m_ImmIfCallBack = new ImmIfReconvertString;
            break;
        case ESCB_CLEARDOCFEEDBUFFER:
            m_ImmIfCallBack = new ImmIfClearDocFeedBuffer;
            break;
        case ESCB_GETTEXTANDATTRIBUTE:
            m_ImmIfCallBack = new ImmIfGetTextAndAttribute;
            break;
        case ESCB_QUERYRECONVERTSTRING:
            m_ImmIfCallBack = new ImmIfQueryReconvertString;
            break;
        case ESCB_CALCRANGEPOS:
            m_ImmIfCallBack = new ImmIfCalcRangePos;
            break;
        case ESCB_GETSELECTION:
            m_ImmIfCallBack = new ImmIfGetSelection;
            break;
        case ESCB_GET_READONLY_PROP_MARGIN:
            m_ImmIfCallBack = new ImmIfGetReadOnlyPropMargin;
            break;
        case ESCB_GET_CURSOR_POSITION:
            m_ImmIfCallBack = new ImmIfGetCursorPosition;
            break;
        case ESCB_GET_ALL_TEXT_RANGE:
            m_ImmIfCallBack = new ImmIfGetAllTextRange;
            break;
    }
}

ImmIfEditSession::~ImmIfEditSession(
    )
{
    if (m_ImmIfCallBack)
        delete m_ImmIfCallBack;
}

bool
ImmIfEditSession::Valid(
    )
{
    return (m_ImmIfIme.Valid() && m_ic.Valid()) ? true : false;
}


// ImmIfEditSession::ITfEditCallback method

STDAPI
ImmIfEditSession::DoEditSession(
    TfEditCookie ec
    )
{
    return m_pfnCallback(ec, this);
}


// ImmIfEditSession::IUnknown

STDAPI
ImmIfEditSession::QueryInterface(
    REFIID riid,
    void** ppvObj
    )
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfEditSession)) {
        *ppvObj = SAFECAST(this, ImmIfEditSession*);
    }

    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG)
ImmIfEditSession::AddRef(
    )
{
    return ++m_cRef;
}

STDAPI_(ULONG)
ImmIfEditSession::Release(
    )
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0) {
        delete this;
    }

    return cr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfHandleThisKey

HRESULT
ImmIfHandleThisKey::HandleThisKey(
    TfEditCookie ec,
    UINT uVKey,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    Interface_TFSELECTION sel;
    BOOL fEmpty;
    ULONG cFetched;

    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr=imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    //
    // Finalize the composition string
    //
    if (_pAImeContext &&
        _pAImeContext->IsVKeyInKeyList(uVKey, EDIT_ID_FINALIZE)) {
        return ImmIfIme->_CompComplete(imc);
    }

    //
    // Keys that change its behavior on selection
    //

    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
        return E_FAIL;

    sel->range->IsEmpty(ec, &fEmpty);

    if (!fEmpty) {
        //
        // Selection is not empty.
        //

        switch (uVKey) {
        case VK_BACK:
        case VK_DELETE:
            //
            // Delete the selection
            //
            ClearTextInRange(ec, sel->range, _pAImeContext);
            return ImmIfIme->_UpdateCompositionString();
        }
    }

    switch (uVKey) {
    case VK_BACK:
        // Make selection
        if (SUCCEEDED(ShiftSelectionToLeft(ec, sel->range, false))) {
            // Clear the current selection
            if (SUCCEEDED(ClearTextInRange(ec, sel->range, _pAImeContext))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;

    case VK_DELETE:
        if (SUCCEEDED(ShiftSelectionToRight(ec, sel->range, false))) {
            if (SUCCEEDED(ClearTextInRange(ec, sel->range, _pAImeContext))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;

    case VK_LEFT:
        sel->style.ase = TF_AE_START;

        if (::GetKeyState(VK_SHIFT) >= 0 &&
            ::GetKeyState(VK_CONTROL) >= 0) {
            if (SUCCEEDED(ShiftSelectionToLeft(ec, sel->range)) &&
                SUCCEEDED(ic->SetSelection(ec, 1, sel))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;

    case VK_RIGHT:
        sel->style.ase = TF_AE_END;

        if (::GetKeyState(VK_SHIFT) >= 0 &&
            ::GetKeyState(VK_CONTROL) >= 0) {
            if (SUCCEEDED(ShiftSelectionToRight(ec, sel->range)) &&
                SUCCEEDED(ic->SetSelection(ec, 1, sel))) {
                return ImmIfIme->_UpdateCompositionString();
            }
        }
        break;
    }

    return E_FAIL;
}

HRESULT
ImmIfHandleThisKey::ShiftSelectionToLeft(
    TfEditCookie ec,
    ITfRange *range,
    bool fShiftEnd
    )
{
    LONG cch;

    if (SUCCEEDED(range->ShiftStart(ec, -1, &cch, NULL))) {
        HRESULT hr = S_OK;
        if (fShiftEnd) {
            hr = range->Collapse(ec, TF_ANCHOR_START);
        }
        return hr;
    }

    return E_FAIL;
}

HRESULT
ImmIfHandleThisKey::ShiftSelectionToRight(
    TfEditCookie ec,
    ITfRange *range,
    bool fShiftStart
    )
{
    LONG cch;

    if (SUCCEEDED(range->ShiftEnd(ec, 1, &cch, NULL))) {
        HRESULT hr = S_OK;
        if (fShiftStart) {
            hr = range->Collapse(ec, TF_ANCHOR_END);
        }
        return hr;
    }

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionComplete

HRESULT
ImmIfCompositionComplete::CompComplete(
    TfEditCookie ec,
    HIMC hIMC,
    BOOL fTerminateComp,
    Interface_Attach<ITfContext> ic,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;

    if (fTerminateComp == TRUE)
    {
        Interface<ITfContextOwnerCompositionServices> icocs;

        hr = ic->QueryInterface(IID_ITfContextOwnerCompositionServices, (void **)icocs);

        if (S_OK == hr)
        {
            icocs->TerminateComposition(NULL);
        }
    }

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    //
    // Get the whole text, finalize it, and set empty string in TOM
    //
    Interface<ITfRange> start;
    LONG cch;

    if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &cch))) {

        //
        // If there is no string in TextStore and we havenot sent 
        // WM_IME_STARTCOMPOSITION, we don't have to do anything.
        //
        if (!cch) {
            if (_pAImeContext && !(_pAImeContext->m_fStartComposition))
                return S_OK;
        }

        LPWSTR wstr = new WCHAR[ cch + 1 ];
        Interface<ITfProperty> prop;
        //
        // Get the whole text, finalize it, and erase the whole text.
        //
        if (SUCCEEDED(start->GetText(ec, TF_TF_IGNOREEND, wstr, (ULONG)cch, (ULONG*)&cch))) {
            //
            // Make Result String.
            //
            UINT cp = CP_ACP;
            ImmIfIme->GetCodePageA(&cp);

            CWCompString ResultStr(cp, hIMC, wstr, cch);

            CWCompString ResultReadStr;
            CWCompClause ResultReadClause;
            CWCompClause ResultClause;

            if (cch) {

                //
                // Get reading string from property.
                //
                GetReadingString(ec, ic, ResultReadStr, ResultReadClause);


                //
                // Copy CompClause data to ResultClause
                //
                CompClauseToResultClause(imc, ResultClause, cch);
            }

#ifdef CICERO_4732
            if (_pAImeContext && ! _pAImeContext->m_fInCompComplete)
            {
                //
                // Prevent reentrance call of CPS_COMPLETE.
                //
                _pAImeContext->m_fInCompComplete = TRUE;
#endif

                //
                // set composition string
                //
                hr = _SetCompositionString(imc,
                                           &ResultStr, &ResultClause,
                                           &ResultReadStr, &ResultReadClause);

#ifdef CICERO_4732
                _pAImeContext->m_fInCompComplete = FALSE;
            }
#endif

            //
            // Clear the TOM
            //
            if (SUCCEEDED(hr))
            {
                if (_pAImeContext)
                    hr = ClearTextInRange(ec, start, _pAImeContext);
            }

        }
        delete [] wstr;
    }
    else {
        ImmIfIme->_CompCancel(imc);
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionCancel


HRESULT
ImmIfCompositionCancel::CompCancel(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    if (_pAImeContext &&
        _pAImeContext->m_fStartComposition) {
        IMCCLock<COMPOSITIONSTRING> comp(imc->hCompStr);

        if (SUCCEEDED(hr = comp.GetResult())) {
            TRANSMSG msg;
            msg.message = WM_IME_COMPOSITION;
            msg.wParam = (WPARAM)VK_ESCAPE;
            msg.lParam = (LPARAM)(GCS_COMPREAD | GCS_COMP | GCS_CURSORPOS | GCS_DELTASTART);
            if (_pAImeContext->m_pMessageBuffer)
                _pAImeContext->m_pMessageBuffer->SetData(msg);

            _pAImeContext->m_fStartComposition = FALSE;

            msg.message = WM_IME_ENDCOMPOSITION;
            msg.wParam = (WPARAM) 0;
            msg.lParam = (LPARAM) 0;
            if (_pAImeContext->m_pMessageBuffer)
                _pAImeContext->m_pMessageBuffer->SetData(msg);

            //
            // Clear the text in Cicero TOM
            //
            Interface<ITfRange> range;
            LONG l;
            if (SUCCEEDED(GetAllTextRange(ec, ic, &range, &l))) {
                hr = ClearTextInRange(ec, range, _pAImeContext);
            }
        }

        imc.GenerateMessage();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfUpdateCompositionString

HRESULT
ImmIfUpdateCompositionString::UpdateCompositionString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    DWORD dwDeltaStart,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ImmIfIme->GetClientId(), &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    Interface<ITfRange> InterimRange;
    BOOL fInterim = FALSE;
    if (FAILED(hr = _IsInterimSelection(ec, ic, &InterimRange, &fInterim)))
        return hr;

    if (fInterim) {
        UINT cp = CP_ACP;
        ImmIfIme->GetCodePageA(&cp);

        return _MakeInterimString(ImmIfIme->_GetLibTLS(),
                                  ec, imc, ic, FullTextRange,
                                  InterimRange, lTextLength, cp,
                                  bInWriteSession);
    }
    else {
        return _MakeCompositionString(ImmIfIme->_GetLibTLS(),
                                      ec, imc, ic, FullTextRange,
                                      dwDeltaStart,
                                      bInWriteSession);
    }

}


HRESULT
ImmIfUpdateCompositionString::_IsInterimSelection(
    TfEditCookie ec,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>* pInterimRange,
    BOOL *pfInterim
    )
{
    Interface_TFSELECTION sel;
    ULONG cFetched;

    *pfInterim = FALSE;
    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
    {
        // no selection. we can return S_OK.
        return S_OK;
    }

    if (sel->style.fInterimChar) {
        HRESULT hr;
        if (FAILED(hr = sel->range->Clone(*pInterimRange)))
            return hr;

        *pfInterim = TRUE;
    }

    return S_OK;
}


HRESULT
ImmIfUpdateCompositionString::_MakeCompositionString(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& FullTextRange,
    DWORD dwDeltaStart,
    BOOL bInWriteSession
    )
{
    HRESULT hr;
    CWCompString CompStr;
    CWCompAttribute CompAttr;
    CWCompClause CompClause;
    CWCompTfGuidAtom CompGuid;
    CWCompCursorPos CompCursorPos;
    CWCompDeltaStart CompDeltaStart;
    CWCompString CompReadStr;
    CWCompClause CompReadClause;
    CWCompString ResultStr;
    CWCompClause ResultClause;
    CWCompString ResultReadStr;
    CWCompClause ResultReadClause;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic, FullTextRange,
                                         CompStr, CompAttr, CompClause,
                                         CompGuid,
                                         CompReadStr, CompReadClause,
                                         ResultStr, ResultClause,
                                         ResultReadStr, ResultReadClause,
                                         bInWriteSession
                                        ))) {
        return hr;
    }

    if (FAILED(hr = _GetCursorPosition(ec, imc, ic, CompCursorPos, CompAttr))) {
        return hr;
    }

    if (FAILED(hr = _GetDeltaStart(CompDeltaStart, CompStr, dwDeltaStart))) {
        return hr;
    }

    //
    // Clear the GUID attribute map array
    //
    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

    _pAImeContext->usGuidMapSize = 0;
    memset(&_pAImeContext->aGuidMap, 0, sizeof _pAImeContext->aGuidMap);

    BOOL bBufferOverflow = FALSE;
    
    // handle result string
    hr = _SetCompositionString(imc,
                               &CompStr, &CompAttr, &CompClause,
                               &CompCursorPos, &CompDeltaStart,
                               &CompGuid,
                               &bBufferOverflow,
                               &CompReadStr,
                               &ResultStr, &ResultClause,
                               &ResultReadStr, &ResultReadClause);
                                   
    if (SUCCEEDED(hr) && bBufferOverflow) {
        //
        // Buffer overflow in COMPOSITIONSTRING.compstr[NMAXKEY],
        // Then, Clear the TOM
        //
        //
        // Get the whole text, finalize it, and set empty string in TOM
        //
        Interface<ITfRange> start;
        LONG cch;
        if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &start, &cch))) {
            hr = ClearTextInRange(ec, start, _pAImeContext);
        }
    }

    return hr;
}


HRESULT
ImmIfUpdateCompositionString::_MakeInterimString(
    LIBTHREAD *pLibTLS,
    TfEditCookie ec,
    IMCLock& imc,
    Interface_Attach<ITfContext>& ic,
    Interface<ITfRange>& FullTextRange,
    Interface<ITfRange>& InterimRange,
    LONG lTextLength,
    UINT cp,
    BOOL bInWriteSession
    )
{
    LONG lStartResult;
    LONG lEndResult;

    FullTextRange->CompareStart(ec, InterimRange, TF_ANCHOR_START, &lStartResult);
    if (lStartResult > 0) {
        return E_FAIL;
    }

    FullTextRange->CompareEnd(ec, InterimRange, TF_ANCHOR_END, &lEndResult);
    if (lEndResult < 0) {
        return E_FAIL;
    }
    if (lEndResult > 1) {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    CWInterimString InterimStr(cp, (HIMC)imc);

    if (lStartResult < 0) {
        //
        // Make result string.
        //
#if 0
        BOOL fEqual;
        do {
            LONG cch;
            FullTextRange->ShiftEnd(ec, -1, &cch, NULL);
            if (cch == 0) {
                return E_FAIL;
            }
            lTextLength -= abs(cch);
            FullTextRange->IsEqualEnd(ec, InterimRange, TF_ANCHOR_START, &fEqual);
        } while(! fEqual);
#endif
        if (FAILED(hr=FullTextRange->ShiftEndToRange(ec, InterimRange, TF_ANCHOR_START)))
            return hr;

        //
        // Interim char assume 1 char length.
        // Full text length - 1 means result string length.
        //
        lTextLength --;
        ASSERT(lTextLength > 0);

        if (lTextLength > 0) {

            LPWSTR wstr = new WCHAR[ lTextLength + 1 ];

            //
            // Get the result text, finalize it, and erase the result text.
            //
            if (SUCCEEDED(FullTextRange->GetText(ec, TF_TF_IGNOREEND, wstr, (ULONG)lTextLength, (ULONG*)&lTextLength))) {
                //
                // Clear the TOM
                //
                CAImeContext* _pAImeContext = imc->m_pAImeContext;
                ASSERT(_pAImeContext != NULL);

                if (_pAImeContext) {
                    if (SUCCEEDED(hr = ClearTextInRange(ec, FullTextRange, _pAImeContext))) {
                        InterimStr.WriteCompData(wstr, lTextLength);
                    }
                }
            }
            delete [] wstr;
        }
    }

    //
    // Make interim character
    //
    CWCompString CompStr;
    CWCompAttribute CompAttr;
    CWCompClause CompClause;
    CWCompTfGuidAtom CompGuid;
    CWCompString CompReadStr;
    CWCompClause CompReadClause;
    CWCompString ResultStr;
    CWCompClause ResultClause;
    CWCompString ResultReadStr;
    CWCompClause ResultReadClause;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic, InterimRange,
                                         CompStr, CompAttr, CompClause,
                                         CompGuid,
                                         CompReadStr, CompReadClause,
                                         ResultStr, ResultClause,
                                         ResultReadStr, ResultReadClause,
                                         bInWriteSession
                                        ))) {
        return hr;
    }

    WCHAR ch = L'\0';
    BYTE  attr = 0;
    if (CompStr.GetSize() > 0) {
        CompStr.ReadCompData(&ch, 1);
    }
    if (CompAttr.GetSize() > 0) {
        CompAttr.ReadCompData(&attr, 1);
    }

    InterimStr.WriteInterimChar(ch, attr);
    hr = _SetCompositionString(imc, &InterimStr);

    return hr;
}


//
// Get delta start
//
HRESULT
ImmIfUpdateCompositionString::_GetDeltaStart(
    CWCompDeltaStart& CompDeltaStart,
    CWCompString& CompStr,
    DWORD dwDeltaStart
    )
{
    if (dwDeltaStart < (DWORD)CompStr.GetSize())
        CompDeltaStart.Set(dwDeltaStart);    // Set COMPOSITIONSTRING.dwDeltaStart.
    else
        CompDeltaStart.Set(0);

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ImmIfReplaceWholeText

HRESULT
ImmIfReplaceWholeText::ReplaceWholeText(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompString* lpwCompStr
    )
{
    HRESULT hr;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    ASSERT(_pAImeContext != NULL);

    DWORD dwSize = (DWORD)lpwCompStr->GetSize();
    LPWSTR lpszComp = new WCHAR[dwSize + 1];

    if (!lpszComp)
        return hr;

    lpwCompStr->ReadCompData(lpszComp, dwSize + 1);
    lpszComp[dwSize] = L'\0';

    Interface<ITfRange> whole;
    LONG cch;
    if (SUCCEEDED(hr=GetAllTextRange(ec, ic, &whole, &cch))) {
        if (_pAImeContext)
            hr = SetTextInRange(ec, whole, lpszComp, 0, _pAImeContext);
    }
    delete [] lpszComp;

    return hr;
}


void SetReadOnlyRange(TfEditCookie ec,
                      Interface_Attach<ITfContext> ic,
                      ITfRange *range,
                      BOOL fSet)
{
    ITfProperty *prop;
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        if (fSet)
        {
            VARIANT var;
            var.vt = VT_I4;
            var.lVal = 1;
            prop->SetValue(ec, range, &var);
        }
        else
        {
            prop->Clear(ec, range);
        }
        prop->Release();
    }
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfReconvertString

HRESULT
ImmIfReconvertString::ReconvertString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    BOOL fDocFeedOnly,
    CWReconvertString* lpwReconvStr,
    Interface_Attach<ImmIfIME> ImmIfIme
    )

/*+++

    LPRECONVERTSTRING structure:
      +00  DWORD dwSize               // Sizeof data (include this structure size) with byte count.
      +04  DWORD dwVersion
      +08  DWORD dwStrLen             // String length with character count.
      +0C  DWORD dwStrOffset          // Offset from start of this structure with byte count.
      +10  DWORD dwCompStrLen         // Comp Str length with character count.
      +14  DWORD dwCompStrOffset      // Offset from this->dwStrOffset with byte count.
      +18  DWORD dwTargetStrLen       // Target Str length with character count.
      +1C  DWORD dwTargetStrOffset    // Offset from this->dwStrOffset with byte count.
      +20

---*/

{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    DWORD dwLen;
    dwLen = lpwReconvStr->ReadCompData();
    if (dwLen) {
        LPRECONVERTSTRING lpReconvertString;
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];

        if (lpReconvertString == NULL)
            return hr;

        lpwReconvStr->ReadCompData(lpReconvertString, dwLen);


        if (lpReconvertString->dwStrLen) {
            hr = ic->GetStart(ec, *rangeSrc);
            if (SUCCEEDED(hr)) {
                LONG cch;
                hr = (*rangeSrc)->ShiftEnd(ec, LONG_MAX, &cch, NULL);
                SetReadOnlyRange(ec, ic, *rangeSrc, FALSE);
                BOOL fSkipSetText = FALSE;

                if (SUCCEEDED(hr)) {

                    Interface<ITfRange> rangeOrgSelection;

                    if (lpReconvertString->dwCompStrLen)
                    {
                        WCHAR *pwstr = NULL;
                        ULONG ul = 0;
                        Interface<ITfRange> rangeTmp;
    
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeTmp)))
                        {
                            UINT uSize = lpReconvertString->dwCompStrLen + 2;
                            pwstr = new WCHAR[uSize + 1];
                            if (pwstr)
                            {
                                ULONG ulcch;
                                rangeTmp->GetText(ec, 0, pwstr, uSize, &ulcch);

                                if ((lpReconvertString->dwCompStrLen == ulcch) &&
                                     !memcmp(((LPBYTE)lpReconvertString +
                                                lpReconvertString->dwStrOffset +
                                                lpReconvertString->dwCompStrOffset),
                                            pwstr,
                                            lpReconvertString->dwCompStrLen * sizeof(WCHAR)))
                                    fSkipSetText = TRUE;
                
                                delete [] pwstr;
                            }
                        }

                        if (!fSkipSetText && fDocFeedOnly)
                        {
                            TraceMsg(TF_WARNING, "ImmIfReconvertString::ReconvertString   the current text store does not match with the string from App.");
                            goto Exit;
                        }
    
                        if (!fSkipSetText)
                            hr = SetTextInRange(ec,
                                                *rangeSrc,
                                                (LPWSTR)((LPBYTE)lpReconvertString +
                                                                 lpReconvertString->dwStrOffset +
                                                                 lpReconvertString->dwCompStrOffset),
                                                lpReconvertString->dwCompStrLen,
                                                _pAImeContext);
                        else
                        {
                            GetSelectionSimple(ec, ic.GetPtr(), rangeOrgSelection);
                            hr = S_OK;
                        }

#if 0
                        //
                        // set disp attribute for the reconvert
                        //
                        if (S_OK == hr)
                        {
    
                            ITfProperty *pProp = NULL;
    
                            hr = ic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);
                            if (S_OK == hr)
                            {
                               SetAttrPropertyData(ImmIfIme->_GetLibTLS(),
                                                   ec, 
                                                   pProp, 
                                                   *rangeSrc, 
                                                   GUID_ATTR_MSIMTF_INPUT);
                            }
                            pProp->Release();
                        } 
#endif
                    } 
                    else
                    {
                        BOOL fEmpty;
 
                        if (SUCCEEDED((*rangeSrc)->IsEmpty(ec, &fEmpty)) && !fEmpty)
                        {
                            if (fDocFeedOnly)
                            {
                                TraceMsg(TF_WARNING, "ImmIfReconvertString::ReconvertString   the current text store does not match with the string from App.");
                                goto Exit;
                            }

                            hr = ClearTextInRange(ec, *rangeSrc, _pAImeContext);
                        }
                    } 


                    //
                    // set read only string
                    //
                    if (lpReconvertString->dwCompStrOffset)
                    {
                        //
                        // keep rangeSrc and rangeOrgSelection
                        //
                        (*rangeSrc)->SetGravity(ec, 
                                                  TF_GRAVITY_FORWARD,
                                                  TF_GRAVITY_FORWARD);

                        if (rangeOrgSelection.Valid())
                            rangeOrgSelection->SetGravity(ec, 
                                                        TF_GRAVITY_FORWARD,
                                                        TF_GRAVITY_FORWARD);
                        Interface<ITfRange> rangeStart;
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeStart)))
                        {
                            if (SUCCEEDED(rangeStart->Collapse(ec, TF_ANCHOR_START)))
                            {
                                rangeStart->SetGravity(ec, 
                                                       TF_GRAVITY_BACKWARD,
                                                       TF_GRAVITY_FORWARD);
                                hr = SetTextInRange(ec,
                                                    rangeStart,
                                                    (LPWSTR)((LPBYTE)lpReconvertString +
                                                                     lpReconvertString->dwStrOffset),
                                                    lpReconvertString->dwCompStrOffset / sizeof(WCHAR),
                                                    _pAImeContext);

                                if (SUCCEEDED(hr))
                                    SetReadOnlyRange(ec, ic, rangeStart, TRUE);
                            }
                        }
                    }


                    if ((lpReconvertString->dwCompStrOffset + lpReconvertString->dwCompStrLen * sizeof(WCHAR)) < lpReconvertString->dwStrLen * sizeof(WCHAR))
                    {
                        //
                        // keep rangeSrc and rangeOrgSelection
                        //
                        (*rangeSrc)->SetGravity(ec, 
                                                  TF_GRAVITY_BACKWARD,
                                                  TF_GRAVITY_BACKWARD);

                        if (rangeOrgSelection.Valid())
                            rangeOrgSelection->SetGravity(ec, 
                                                        TF_GRAVITY_BACKWARD,
                                                        TF_GRAVITY_BACKWARD);

                        Interface<ITfRange> rangeEnd;
                        if (SUCCEEDED((*rangeSrc)->Clone(rangeEnd)))
                        {
                            if (SUCCEEDED(rangeEnd->Collapse(ec, TF_ANCHOR_END)))
                            {
                                rangeEnd->SetGravity(ec, 
                                                     TF_GRAVITY_BACKWARD,
                                                     TF_GRAVITY_FORWARD);

                                hr = SetTextInRange(ec,
                                                    rangeEnd,
                                                    (LPWSTR)((LPBYTE)lpReconvertString +
                                                                     lpReconvertString->dwStrOffset +
                                                                     lpReconvertString->dwCompStrOffset +
                                                                    (lpReconvertString->dwCompStrLen * sizeof(WCHAR))),
                                                    ((lpReconvertString->dwStrLen  * sizeof(WCHAR)) -
                                                     (lpReconvertString->dwCompStrOffset +
                                                     (lpReconvertString->dwCompStrLen * sizeof(WCHAR)))) / sizeof(WCHAR),
                                                    _pAImeContext);
                                if (SUCCEEDED(hr))
                                    SetReadOnlyRange(ec, ic, rangeEnd, TRUE);
                            }
                        }
                    }

                    (*rangeSrc)->SetGravity(ec, 
                                              TF_GRAVITY_FORWARD,
                                              TF_GRAVITY_BACKWARD);


                    //
                    // we just set a selection to the target string.
                    //
                    Interface<ITfRange> range;
                    if (fSkipSetText)
                    {
                        if (rangeOrgSelection.Valid())
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = rangeOrgSelection;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);
                        }
                    }
                    else if (SUCCEEDED((*rangeSrc)->Clone(range)))
                    {
                        LONG cchStart;
                        LONG cchEnd;

                        if (lpReconvertString->dwTargetStrOffset == 0 &&
                            lpReconvertString->dwTargetStrLen == 0      ) {
                            cchStart = lpReconvertString->dwCompStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwCompStrOffset / sizeof(WCHAR) + lpReconvertString->dwCompStrLen;
                        }
                        else {
                            cchStart = (lpReconvertString->dwTargetStrOffset - lpReconvertString->dwCompStrOffset) / sizeof(WCHAR);
                            cchEnd = (lpReconvertString->dwTargetStrOffset - lpReconvertString->dwCompStrOffset) / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                            // cchStart = (lpReconvertString->dwTargetStrOffset) / sizeof(WCHAR);
                            // cchEnd = (lpReconvertString->dwTargetStrOffset) / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                        }

                        range->Collapse(ec, TF_ANCHOR_START);

                        //
                        // shift end first then shift start.
                        //
                        if ((SUCCEEDED(range->ShiftEnd(ec, 
                                                      cchEnd,
                                                      &cch, 
                                                      NULL))) &&
                            (SUCCEEDED(range->ShiftStart(ec,
                                                         cchStart,
                                                         &cch, 
                                                         NULL))))
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = range;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);
                        }
                    }

                    //
                    // it's time to generate WM_IME_COMPOSITION.
                    //
                    ImmIfIme->_UpdateCompositionString();
                }
            }
        }
Exit:
        delete [] lpReconvertString;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfClearDocFeedBuffer

HRESULT
ImmIfClearDocFeedBuffer::ClearDocFeedBuffer(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ITfRange *rangeFull = NULL;
    ITfProperty *prop;
    ITfRange *rangeTmp;
    LONG cch;

    //
    // Create the range that covers all the text.
    //
    if (FAILED(hr=ic->GetStart(ec, &rangeFull)))
        return hr;

    if (FAILED(hr=rangeFull->ShiftEnd(ec, LONG_MAX, &cch, NULL)))
        return hr;

    //
    // find the first non readonly range in the text store.
    //
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, rangeFull)))
        {
            while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_I4) && (var.lVal != 0))
                {
                    prop->Clear(ec, rangeTmp);
                    ClearTextInRange(ec, rangeTmp, _pAImeContext);
                }
                rangeTmp->Release();
            }
            enumranges->Release();
        }
        prop->Release();
    }


    rangeFull->Release();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ImmIfGetTextAndAttribute

HRESULT
ImmIfGetTextAndAttribute::GetTextAndAttribute(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompString* lpwCompString,
    CWCompAttribute* lpwCompAttribute,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    LIBTHREAD *pLibTLS = ImmIfIme->_GetLibTLS();

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ImmIfIme->GetClientId(), &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic,
                                         FullTextRange,
                                         *lpwCompString,
                                         *lpwCompAttribute,
                                         bInWriteSession))) {
        return hr;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfQueryReconvertString

HRESULT
ImmIfQueryReconvertString::QueryReconvertString(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeQuery,
    CWReconvertString* lpwReconvStr,
    Interface_Attach<ImmIfIME> ImmIfIme
    )

/*+++

    LPRECONVERTSTRING structure:
      +00  DWORD dwSize               // Sizeof data (include this structure size) with byte count.
      +04  DWORD dwVersion
      +08  DWORD dwStrLen             // String length with character count.
      +0C  DWORD dwStrOffset          // Offset from start of this structure with byte count.
      +10  DWORD dwCompStrLen         // Comp Str length with character count.
      +14  DWORD dwCompStrOffset      // Offset from this->dwStrOffset with byte count.
      +18  DWORD dwTargetStrLen       // Target Str length with character count.
      +1C  DWORD dwTargetStrOffset    // Offset from this->dwStrOffset with byte count.
      +20

---*/

{
    HRESULT hr = E_FAIL;
    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    DWORD dwLen;
    dwLen = lpwReconvStr->ReadCompData();
    if (dwLen) {
        LPRECONVERTSTRING lpReconvertString;
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];

        if (lpReconvertString == NULL)
            return hr;

        lpwReconvStr->ReadCompData(lpReconvertString, dwLen);

        if (lpReconvertString->dwStrLen) {
            Interface<ITfRange> rangeSrc;
            hr = ic->GetStart(ec, rangeSrc);
            if (SUCCEEDED(hr)) {
                LONG cch;
                hr = rangeSrc->ShiftEnd(ec, LONG_MAX, &cch, NULL);
                if (SUCCEEDED(hr)) {

                    hr = SetTextInRange(ec,
                                        rangeSrc,
                                        (LPWSTR)((LPBYTE)lpReconvertString +
                                                         lpReconvertString->dwStrOffset),
                                        lpReconvertString->dwStrLen,
                                        _pAImeContext);

#if 0
                    //
                    // set disp attribute for the query reconvert
                    //
                    if (S_OK == hr)
                    {

                        ITfProperty *pProp = NULL;

                        hr = ic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);
                        if (S_OK == hr)
                        {
                           SetAttrPropertyData(ImmIfIme->_GetLibTLS(),
                                               ec, 
                                               pProp, 
                                               rangeSrc, 
                                               GUID_ATTR_MSIMTF_INPUT);
                        }
                        pProp->Release();
                    } 
                    else
                    {
                        BOOL fEmpty;
 
                        if (SUCCEEDED(rangeSrc->IsEmpty(ec, &fEmpty)) && !fEmpty)
                        {
                            hr = ClearTextInRange(ec, rangeSrc, _pAImeContext);
                        }
                    } 
#endif


                    //
                    // we just set a selection to the target string.
                    //
                    Interface<ITfRange> range;
                    if (SUCCEEDED(rangeSrc->Clone(range)))
                    {
                        LONG cchStart;
                        LONG cchEnd;

                        if (lpReconvertString->dwTargetStrOffset == 0 &&
                            lpReconvertString->dwTargetStrLen == 0      ) {
                            cchStart = lpReconvertString->dwCompStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwCompStrOffset / sizeof(WCHAR) + lpReconvertString->dwCompStrLen;
                        }
                        else {
                            cchStart = lpReconvertString->dwTargetStrOffset / sizeof(WCHAR);
                            cchEnd = lpReconvertString->dwTargetStrOffset / sizeof(WCHAR) + lpReconvertString->dwTargetStrLen;
                        }

                        range->Collapse(ec, TF_ANCHOR_START);

                        //
                        // shift end first then shift start.
                        //
                        if ((SUCCEEDED(range->ShiftEnd(ec, 
                                                      cchEnd,
                                                      &cch, 
                                                      NULL))) &&
                            (SUCCEEDED(range->ShiftStart(ec,
                                                         cchStart,
                                                         &cch, 
                                                         NULL))))
                        {
                            //
                            //
                            //
                            TF_SELECTION sel;
                            sel.range = range;
                            sel.style.ase = TF_AE_NONE;
                            sel.style.fInterimChar = FALSE;
                            ic->SetSelection(ec, 1, &sel);

                            hr = range->Clone(*rangeQuery);
                        }
                    }
                }
            }
        }
        delete [] lpReconvertString;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfCalcRangePos

HRESULT
ImmIfCalcRangePos::CalcRangePos(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    CWReconvertString* lpwReconvStr,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    Interface<ITfRange> pFullRange;

    hr = ic->GetStart(ec, pFullRange);
    if (SUCCEEDED(hr)) {
        lpwReconvStr->m_CompStrIndex = 0;
        lpwReconvStr->m_TargetStrIndex = 0;

        BOOL equal = FALSE;
        while (SUCCEEDED(hr=(*rangeSrc)->IsEqualStart(ec, pFullRange, TF_ANCHOR_START, &equal)) &&
               ! equal) {
            LONG cch;
            hr = pFullRange->ShiftStart(ec, 1, &cch, NULL);
            if (FAILED(hr))
                break;

            lpwReconvStr->m_CompStrIndex++;
            lpwReconvStr->m_TargetStrIndex++;
        }

        if (S_OK == hr) {
            lpwReconvStr->m_CompStrLen = 0;
            lpwReconvStr->m_TargetStrLen = 0;

            Interface<ITfRange> rangeTmp;

            if (SUCCEEDED(hr=(*rangeSrc)->Clone(rangeTmp)))
            {
                BOOL fEmpty;
                WCHAR wstr[256 + 1];
                ULONG ul = 0;

                while (rangeTmp->IsEmpty(ec, &fEmpty) == S_OK && !fEmpty)
                {
                    ULONG ulcch;
                    rangeTmp->GetText(ec, 
                                      TF_TF_MOVESTART, 
                                      wstr, 
                                      ARRAYSIZE(wstr) - 1, 
                                      &ulcch);
                    ul += ulcch;
                }

                //
                // Hack for Satori
                // Satori receives empty range with Reconversion->QueryRange().
                // Apps couldn't call reconversion.
                //
                if (ul == 0) {
                    ul++;
                }

                lpwReconvStr->m_CompStrLen = (LONG)ul;
                lpwReconvStr->m_TargetStrLen = (LONG)ul;
            }
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetSelection

HRESULT
ImmIfGetSelection::GetSelection(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRange>* rangeSrc,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    Interface_TFSELECTION sel;
    ULONG cFetched;

    if (ic->GetSelection(ec, TF_DEFAULT_SELECTION, 1, sel, &cFetched) != S_OK)
        return E_FAIL;

    return sel->range->Clone(*rangeSrc);
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetReadOnlyPropMargin

HRESULT
ImmIfGetReadOnlyPropMargin::GetReadOnlyPropMargin(
    TfEditCookie ec,
    Interface_Attach<ITfContext> ic,
    Interface<ITfRangeACP>* rangeSrc,
    INT_PTR* cch,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    Interface<ITfRange> range_readonly_prop;

    *cch = 0;

    //
    // Create the range that covers start of text to rangeSrc.
    //
    if (FAILED(hr=ic->GetStart(ec, range_readonly_prop)))
        return hr;

    if (FAILED(hr=range_readonly_prop->ShiftEndToRange(ec, *rangeSrc, TF_ANCHOR_START)))
        return hr;

    //
    // same ?
    //
    BOOL empty;
    if (FAILED(hr=range_readonly_prop->IsEmpty(ec, &empty)))
        return hr;

    if (empty)
        return S_OK;

    //
    // find the first non readonly range in the text store.
    //
    ITfProperty *prop;
    if (SUCCEEDED(ic->GetProperty(GUID_PROP_MSIMTF_READONLY, &prop)))
    {
        IEnumTfRanges *enumranges;
        if (SUCCEEDED(prop->EnumRanges(ec, &enumranges, range_readonly_prop)))
        {
            ITfRange *rangeTmp;
            while (enumranges->Next(1, &rangeTmp, NULL) == S_OK)
            {
                VARIANT var;
                QuickVariantInit(&var);
                prop->GetValue(ec, rangeTmp, &var);
                if ((var.vt == VT_I4) && (var.lVal != 0))
                {
                    while (rangeTmp->IsEmpty(ec, &empty) == S_OK && !empty)
                    {
                        WCHAR wstr[256 + 1];
                        ULONG ulcch;
                        rangeTmp->GetText(ec, 
                                          TF_TF_MOVESTART, 
                                          wstr, 
                                          ARRAYSIZE(wstr) - 1, 
                                          &ulcch);
                        *cch += ulcch;
                    }
                }
                rangeTmp->Release();
            }
            enumranges->Release();
        }
        prop->Release();
    }

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

HRESULT
ImmIfGetCursorPosition::GetCursorPosition(
    TfEditCookie ec,
    HIMC hIMC,
    Interface_Attach<ITfContext> ic,
    CWCompCursorPos* lpwCursorPosition,
    Interface_Attach<ImmIfIME> ImmIfIme
    )
{
    HRESULT hr;
    LIBTHREAD *pLibTLS = ImmIfIme->_GetLibTLS();

    IMCLock imc(hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    BOOL bInWriteSession;
    if (FAILED(hr = ic->InWriteSession(ImmIfIme->GetClientId(), &bInWriteSession)))
         return hr;

    Interface<ITfRange> FullTextRange;
    LONG lTextLength;
    if (FAILED(hr=GetAllTextRange(ec, ic, &FullTextRange, &lTextLength)))
        return hr;

    CWCompString CompStr;
    CWCompAttribute CompAttr;

    if (FAILED(hr = _GetTextAndAttribute(pLibTLS, ec, imc, ic,
                                         FullTextRange,
                                         CompStr,
                                         CompAttr,
                                         bInWriteSession))) {
        return hr;
    }

    if (FAILED(hr = _GetCursorPosition(ec, imc, ic, *lpwCursorPosition, CompAttr))) {
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\editses.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    editses.h

Abstract:

    This file defines the EditSession Class.

Author:

Revision History:

Notes:

--*/

#ifndef _EDITSES_H_
#define _EDITSES_H_

#include "immif.h"
#include "editcomp.h"


typedef enum {
    ESCB_HANDLETHISKEY = 1,
    ESCB_COMPCOMPLETE,
    ESCB_COMPCANCEL,
    ESCB_UPDATECOMPOSITIONSTRING,
    ESCB_REPLACEWHOLETEXT,
    ESCB_RECONVERTSTRING,
    ESCB_CLEARDOCFEEDBUFFER,
    ESCB_GETTEXTANDATTRIBUTE,
    ESCB_QUERYRECONVERTSTRING,
    ESCB_CALCRANGEPOS,
    ESCB_GETSELECTION,
    ESCB_GET_READONLY_PROP_MARGIN,
    ESCB_GET_CURSOR_POSITION,
    ESCB_GET_ALL_TEXT_RANGE
} ESCB;


/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSessionCallBack

class ImmIfEditSession;

class ImmIfEditSessionCallBack
{
public:
    ImmIfEditSessionCallBack() { };
    virtual ~ImmIfEditSessionCallBack() { };

    virtual HRESULT CallBackRoutine(TfEditCookie ec,
                                    ImmIfEditSession* pes,
                                    Interface_Attach<ImmIfIME> ImmIfIme) = 0;
protected:
    HRESULT GetAllTextRange(TfEditCookie ec,
                            Interface_Attach<ITfContext>& ic,
                            Interface<ITfRange>* range,
                            LONG* lpTextLength,
                            TF_HALTCOND* lpHaltCond=NULL);

    HRESULT SetTextInRange(TfEditCookie ec,
                           ITfRange* range,
                           LPWSTR psz,
                           DWORD len,
                           CAImeContext* pAImeContext);

    HRESULT ClearTextInRange(TfEditCookie ec,
                             ITfRange* range,
                             CAImeContext* pAImeContext);

    HRESULT GetReadingString(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             CWCompString& reading_string,
                             CWCompClause& reading_clause);

    HRESULT GetReadingString(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             ITfRange* range,
                             CWCompString& reading_string,
                             CWCompClause& reading_clause);

    HRESULT CompClauseToResultClause(IMCLock& imc,
                                     CWCompClause& result_clause, UINT cch);

    HRESULT _GetTextAndAttribute(LIBTHREAD *pLibTLS,
                                 TfEditCookie ec,
                                 IMCLock& imc,
                                 Interface_Attach<ITfContext>& ic,
                                 Interface<ITfRange>& range,
                                 CWCompString& CompStr,
                                 CWCompAttribute& CompAttr,
                                 BOOL bInWriteSession)
    {
        CWCompClause CompClause;
        CWCompTfGuidAtom CompGuid;
        CWCompString CompReadStr;
        CWCompClause CompReadClause;
        CWCompString ResultStr;
        CWCompClause ResultClause;
        CWCompString ResultReadStr;
        CWCompClause ResultReadClause;
        return _GetTextAndAttribute(pLibTLS, ec, imc, ic, range,
                                    CompStr, CompAttr, CompClause,
                                    CompGuid,
                                    CompReadStr, CompReadClause,
                                    ResultStr, ResultClause,
                                    ResultReadStr, ResultReadClause,
                                    bInWriteSession);
    }

    HRESULT _GetTextAndAttribute(LIBTHREAD *pLibTLS,
                                 TfEditCookie ec,
                                 IMCLock& imc,
                                 Interface_Attach<ITfContext>& ic,
                                 Interface<ITfRange>& range,
                                 CWCompString& CompStr,
                                 CWCompAttribute& CompAttr,
                                 CWCompClause& CompClause,
                                 CWCompTfGuidAtom& CompGuid,
                                 CWCompString& CompReadStr,
                                 CWCompClause& CompReadCls,
                                 CWCompString& ResultStr,
                                 CWCompClause& ResultClause,
                                 CWCompString& ResultReadStr,
                                 CWCompClause& ResultReadClause,
                                 BOOL bInWriteSession);

    HRESULT _GetTextAndAttributeGapRange(LIBTHREAD *pLibTLS,
                                         TfEditCookie ec,
                                         IMCLock& imc,
                                         Interface<ITfRange>& gap_range,
                                         LONG result_comp,
                                         CWCompString& CompStr,
                                         CWCompAttribute& CompAttr,
                                         CWCompClause& CompClause,
                                         CWCompTfGuidAtom& CompGuid,
                                         CWCompString& ResultStr,
                                         CWCompClause& ResultClause);

    HRESULT _GetTextAndAttributePropertyRange(LIBTHREAD *pLibTLS,
                                              TfEditCookie ec,
                                              IMCLock& imc,
                                              ITfRange* pPropRange,
                                              BOOL fDispAttribute,
                                              LONG result_comp,
                                              BOOL bInWriteSession,
                                              TF_DISPLAYATTRIBUTE da,
                                              TfGuidAtom guidatom,
                                              CWCompString& CompStr,
                                              CWCompAttribute& CompAttr,
                                              CWCompClause& CompClause,
                                              CWCompTfGuidAtom& CompGuid,
                                              CWCompString& ResultStr,
                                              CWCompClause& ResultClause);

    HRESULT _GetNoDisplayAttributeRange(LIBTHREAD *pLibTLS,
                                        TfEditCookie ec,
                                        Interface_Attach<ITfContext>& ic,
                                        Interface<ITfRange>& range,
                                        Interface<ITfRange>& no_display_attribute_range);

    HRESULT _GetCursorPosition(TfEditCookie ec,
                               IMCLock& imc,
                               Interface_Attach<ITfContext>& ic,
                               CWCompCursorPos& CompCursorPos,
                               CWCompAttribute& CompAttr);

private:
    typedef struct _EnumReadingPropertyArgs
    {
        Interface<ITfProperty> Property;
        TfEditCookie ec;
        CWCompString*          reading_string;
        CWCompClause*          reading_clause;
        LONG ulClausePos;
    } EnumReadingPropertyArgs;

    //
    // Enumrate callbacks
    //
    static ENUM_RET EnumReadingPropertyCallback(ITfRange* pRange, EnumReadingPropertyArgs *pargs);

    BYTE _ConvertAttributeToImm32(TF_DA_ATTR_INFO attribute)
    {
        if (attribute == TF_ATTR_OTHER || attribute > TF_ATTR_FIXEDCONVERTED) {
            return ATTR_TARGET_CONVERTED;
        }
        else {
            return (BYTE)attribute;
        }
    }
};




/////////////////////////////////////////////////////////////////////////////
// ImmIfEditSession

class ImmIfEditSession : public ITfEditSession
{
public:
    ImmIfEditSession(ESCB escb,
                     TfClientId tid,
                     Interface_Attach<ImmIfIME> ImmIfIme,
                     IMCLock& imc);
    ImmIfEditSession(ESCB escb,
                     TfClientId tid,
                     Interface_Attach<ImmIfIME> ImmIfIme,
                     IMCLock& imc,
                     Interface_Attach<ITfContext> pic);
private:
    void _Init(ESCB escb);

public:
    virtual ~ImmIfEditSession();

    bool Valid();
    bool Invalid() { return ! Valid(); }

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfEditCallback method
    //
    STDMETHODIMP DoEditSession(TfEditCookie ec);

    //
    // ImmIfEditSession methods
    //
    static HRESULT EditSessionCallBack(TfEditCookie ec, ImmIfEditSession* pes)
    {
        if (pes->m_ImmIfCallBack)
            return pes->m_ImmIfCallBack->CallBackRoutine(ec, pes, pes->m_ImmIfIme);
        else
            return E_FAIL;
    }

    //
    // EditSession methods.
    //
    HRESULT RequestEditSession(DWORD dwFlags,
                               UINT uVKey=0)
    {
        HRESULT hr;
        m_state.uVKey = uVKey;
        m_ic->RequestEditSession(m_tid, this, dwFlags, &hr);
        return hr;
    }

    HRESULT RequestEditSession(DWORD dwFlags, CWCompString* pwCompStr,
                          CWCompString* pwReadCompStr=NULL, Interface<ITfRange>* pRange=NULL)
    {
        m_state.lpwCompStr     = pwCompStr;
        m_state.lpwReadCompStr = pwReadCompStr;
        m_pRange               = pRange;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags, Interface<ITfRange>* pSelection)
    {
        m_pRange             = pSelection;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWReconvertString* pwReconvStr, Interface<ITfRange>* pSelection, BOOL fDocFeedOnly)
    {
        m_state.lpwReconvStr = pwReconvStr;
        m_pRange             = pSelection;
        m_fDocFeedOnly       = fDocFeedOnly;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          Interface<ITfRangeACP>* pMouseRangeACP, LPMOUSE_RANGE_RECT pv)
    {
        m_pRangeACP          = pMouseRangeACP;
        m_state.pv           = (INT_PTR)pv;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWCompString* pwCompStr, CWCompAttribute* pwCompAttr)
    {
        m_state.lpwCompStr  = pwCompStr;
        m_state.lpwCompAttr = pwCompAttr;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags, BOOL fTerminateComp)
    {
        m_state.fTerminateComp             = fTerminateComp;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          Interface<ITfRangeACP>* pRange, LONG* cch)
    {
        m_pRangeACP = pRange;
        m_state.pv  = (INT_PTR)cch;
        return RequestEditSession(dwFlags);
    }

    HRESULT RequestEditSession(DWORD dwFlags,
                          CWCompCursorPos* pwCursorPosition)
    {
        m_state.lpwCursorPosition = pwCursorPosition;
        return RequestEditSession(dwFlags);
    }

public:
    ImmIfEditSessionCallBack*     m_ImmIfCallBack;

    Interface_Attach<ImmIfIME>    m_ImmIfIme;
    Interface_Attach<ITfContext>  m_ic;
    Interface<ITfRange>*          m_pRange;
    Interface<ITfRangeACP>*       m_pRangeACP;
    BOOL                          m_fDocFeedOnly;

    struct state {
        state(HIMC hd) : hIMC(hd) { };

        UINT                uVKey;
        HIMC                hIMC;
        CWCompString*       lpwCompStr;
        CWCompString*       lpwReadCompStr;
        CWCompAttribute*    lpwCompAttr;
        CWReconvertString*  lpwReconvStr;
        CWCompCursorPos*    lpwCursorPosition;
        INT_PTR             pv;
        BOOL                fTerminateComp;
    } m_state;

    TfClientId              m_tid;
    HRESULT                 (*m_pfnCallback)(TfEditCookie ec, ImmIfEditSession*);
    int                     m_cRef;
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfHandleThisKey

class ImmIfHandleThisKey : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return HandleThisKey(ec,
                             pes->m_state.uVKey,
                             pes->m_state.hIMC,
                             pes->m_ic,
                             ImmIfIme);
    }

    HRESULT HandleThisKey(TfEditCookie ec,
                          UINT uVKey,
                          HIMC hIMC,
                          Interface_Attach<ITfContext> ic,
                          Interface_Attach<ImmIfIME> ImmIfIme);

private:
    HRESULT ShiftSelectionToLeft(TfEditCookie rc, ITfRange *range, bool fShiftEnd = true);
    HRESULT ShiftSelectionToRight(TfEditCookie rc, ITfRange *range, bool fShiftStart = true);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionComplete

class ImmIfCompositionComplete : public ImmIfEditSessionCallBack,
                                 private EditCompositionString
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return CompComplete(ec,
                            pes->m_state.hIMC,
                            pes->m_state.fTerminateComp,
                            pes->m_ic,
                            ImmIfIme);
    }

    HRESULT CompComplete(TfEditCookie ec,
                         HIMC hIMC,
                         BOOL fTerminateComp,
                         Interface_Attach<ITfContext> ic,
                         Interface_Attach<ImmIfIME> ImmIfIme);

private:
    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWCompString* ResultStr,
                                  CWCompClause* ResultClause,
                                  CWCompString* ResultReadStr,
                                  CWCompClause* ResultReadClause)
    {
        return SetString(imc,
                         NULL, NULL, NULL,    // CompStr, CompAttr, CompCls
                         NULL, NULL,          // CompCursor, CompDeltaStart
                         NULL,                // CompGuid
                         NULL,                // lpbBufferOverflow
                         NULL, NULL, NULL,    // CompReadStr, CompReadAttr, CompReadCls
                         ResultStr, ResultClause,           // ResultStr, ResultCls
                         ResultReadStr, ResultReadClause);  // ResultReadStr, ResultReadCls
    }

};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCompositionCancel

class ImmIfCompositionCancel : public ImmIfEditSessionCallBack,
                               private EditCompositionString
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return CompCancel(ec,
                          pes->m_state.hIMC,
                          pes->m_ic);
    }

    HRESULT CompCancel(TfEditCookie ec,
                       HIMC hIMC,
                       Interface_Attach<ITfContext> ic);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfUpdateCompositionString

class ImmIfUpdateCompositionString : public ImmIfEditSessionCallBack,
                                     private EditCompositionString
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return UpdateCompositionString(ec,
                                       pes->m_state.hIMC,
                                       pes->m_ic,
                                       pes->m_state.uVKey,
                                       ImmIfIme);
    }

    HRESULT UpdateCompositionString(TfEditCookie ec,
                                    HIMC hIMC,
                                    Interface_Attach<ITfContext> ic,
                                    DWORD dwDeltaStart,
                                    Interface_Attach<ImmIfIME> ImmIfIme);

private:
    HRESULT _IsInterimSelection(TfEditCookie ec,
                             Interface_Attach<ITfContext>& ic,
                             Interface<ITfRange>* pInterimRange,
                             BOOL *pfInterim);

    HRESULT _MakeCompositionString(LIBTHREAD *pLibTLS,
                                   TfEditCookie ec,
                                   IMCLock& imc,
                                   Interface_Attach<ITfContext>& ic,
                                   Interface<ITfRange>& FullTextRange,
                                   DWORD dwDeltaStart,
                                   BOOL bInWriteSession);

    HRESULT _MakeInterimString(LIBTHREAD *pLibTLS,
                               TfEditCookie ec,
                               IMCLock& imc,
                               Interface_Attach<ITfContext>& ic,
                               Interface<ITfRange>& FullTextRange,
                               Interface<ITfRange>& InterimRange,
                               LONG lTextLength,
                               UINT cp,
                               BOOL bInWriteSession);

    HRESULT _GetDeltaStart(CWCompDeltaStart& CompDeltaStart,
                           CWCompString& CompStr,
                           DWORD dwDeltaStart);

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWCompString* CompStr,
                                  CWCompAttribute* CompAttr,
                                  CWCompClause* CompClause,
                                  CWCompCursorPos* CompCursorPos,
                                  CWCompDeltaStart* CompDeltaStart,
                                  CWCompTfGuidAtom* CompGuid,
                                  OUT BOOL* lpbBufferOverflow,
                                  CWCompString* CompReadStr)
    {
        return SetString(imc,
                         CompStr, CompAttr, CompClause,
                         CompCursorPos, CompDeltaStart,
                         CompGuid,
                         lpbBufferOverflow,
                         CompReadStr);
    }

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWCompString* CompStr,
                                  CWCompAttribute* CompAttr,
                                  CWCompClause* CompClause,
                                  CWCompCursorPos* CompCursorPos,
                                  CWCompDeltaStart* CompDeltaStart,
                                  CWCompTfGuidAtom* CompGuid,
                                  OUT BOOL* lpbBufferOverflow,
                                  CWCompString* CompReadStr,
                                  CWCompString* ResultStr,
                                  CWCompClause* ResultClause,
                                  CWCompString* ResultReadStr,
                                  CWCompClause* ResultReadClause)
    {
        return SetString(imc,
                         CompStr, CompAttr, CompClause,
                         CompCursorPos, CompDeltaStart,
                         CompGuid,
                         lpbBufferOverflow,
                         CompReadStr, NULL, NULL,     // CompReadStr, CompReadAttr, CompReadCls
                         ResultStr, ResultClause,
                         ResultReadStr, ResultReadClause);
    }

    HRESULT _SetCompositionString(IMCLock& imc,
                                  CWInterimString* InterimStr)
    {
        return SetString(imc,
                         NULL, NULL, NULL,    // CompStr, CompAttr, CompCls
                         NULL, NULL,          // CompCursor, CompDeltaStart
                         NULL,                // CompGuid
                         NULL,                // lpbBufferOverflow
                         NULL, NULL, NULL,    // CompReadStr, CompReadAttr, CompReadCls
                         NULL, NULL,          // ResultStr, ResultCls
                         NULL, NULL,          // ResultReadStr, ResultReadCls
                         InterimStr);
    }
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfReplaceWholeText

class ImmIfReplaceWholeText : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return ReplaceWholeText(ec,
                                pes->m_state.hIMC,
                                pes->m_ic,
                                pes->m_state.lpwCompStr);
    }

    HRESULT ReplaceWholeText(TfEditCookie ec,
                             HIMC hIMC,
                             Interface_Attach<ITfContext> ic,
                             CWCompString* lpwCompStr);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfReconvertString

class ImmIfReconvertString : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return ReconvertString(ec,
                               pes->m_state.hIMC,
                               pes->m_ic,
                               pes->m_pRange,
                               pes->m_fDocFeedOnly,
                               pes->m_state.lpwReconvStr,
                               ImmIfIme);
    }

    HRESULT ReconvertString(TfEditCookie ec,
                            HIMC hIMC,
                            Interface_Attach<ITfContext> ic,
                            Interface<ITfRange>* rangeSrc,
                            BOOL fDocFeedOnly,
                            CWReconvertString* lpwReconvStr,
                            Interface_Attach<ImmIfIME> ImmIfIme);
};

/////////////////////////////////////////////////////////////////////////////
// ImmIfClearDocFeedBuffer

class ImmIfClearDocFeedBuffer : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return ClearDocFeedBuffer(ec,
                                  pes->m_state.hIMC,
                                  pes->m_ic,
                                  ImmIfIme);
    }

    HRESULT ClearDocFeedBuffer(TfEditCookie ec,
                            HIMC hIMC,
                            Interface_Attach<ITfContext> ic,
                            Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetTextAndAttribute

class ImmIfGetTextAndAttribute : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetTextAndAttribute(ec,
                                   pes->m_state.hIMC,
                                   pes->m_ic,
                                   pes->m_state.lpwCompStr,
                                   pes->m_state.lpwCompAttr,
                                   ImmIfIme);
    }

    HRESULT GetTextAndAttribute(TfEditCookie ec,
                                HIMC hIMC,
                                Interface_Attach<ITfContext> ic,
                                CWCompString* lpwCompString,
                                CWCompAttribute* lpwCompAttribute,
                                Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfQueryReconvertString

class ImmIfQueryReconvertString : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return QueryReconvertString(ec,
                                    pes->m_state.hIMC,
                                    pes->m_ic,
                                    pes->m_pRange,
                                    pes->m_state.lpwReconvStr,
                                    ImmIfIme);
    }

    HRESULT QueryReconvertString(TfEditCookie ec,
                                 HIMC hIMC,
                                 Interface_Attach<ITfContext> ic,
                                 Interface<ITfRange>* rangeQuery,
                                 CWReconvertString* lpwReconvStr,
                                 Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfCalcRangePos

class ImmIfCalcRangePos : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return CalcRangePos(ec,
                            pes->m_ic,
                            pes->m_pRange,
                            pes->m_state.lpwReconvStr,
                            ImmIfIme);
    }

    HRESULT CalcRangePos(TfEditCookie ec,
                         Interface_Attach<ITfContext> ic,
                         Interface<ITfRange>* rangeSrc,
                         CWReconvertString* lpwReconvStr,
                         Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetSelection

class ImmIfGetSelection : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetSelection(ec,
                            pes->m_ic,
                            pes->m_pRange,
                            ImmIfIme);
    }

    HRESULT GetSelection(TfEditCookie ec,
                         Interface_Attach<ITfContext> ic,
                         Interface<ITfRange>* rangeSrc,
                         Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetReadOnlyPropMargin

class ImmIfGetReadOnlyPropMargin : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetReadOnlyPropMargin(ec,
                                     pes->m_ic,
                                     pes->m_pRangeACP,
                                     (INT_PTR*)pes->m_state.pv,
                                     ImmIfIme);
    }

    HRESULT GetReadOnlyPropMargin(TfEditCookie ec,
                                  Interface_Attach<ITfContext> ic,
                                  Interface<ITfRangeACP>* rangeSrc,
                                  INT_PTR* cch,
                                  Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

class ImmIfGetCursorPosition : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        return GetCursorPosition(ec,
                                 pes->m_state.hIMC,
                                 pes->m_ic,
                                 pes->m_state.lpwCursorPosition,
                                 ImmIfIme);
    }

    HRESULT GetCursorPosition(TfEditCookie ec,
                              HIMC hIMC,
                              Interface_Attach<ITfContext> ic,
                              CWCompCursorPos* lpwCursorPosition,
                              Interface_Attach<ImmIfIME> ImmIfIme);
};


/////////////////////////////////////////////////////////////////////////////
// ImmIfGetCursorPosition

class ImmIfGetAllTextRange : public ImmIfEditSessionCallBack
{
public:
    HRESULT CallBackRoutine(TfEditCookie ec,
                            ImmIfEditSession *pes,
                            Interface_Attach<ImmIfIME> ImmIfIme)
    {
        LONG cch;

        return GetAllTextRange(ec,
                               pes->m_ic,
                               pes->m_pRange,
                               &cch);
    }
};


#endif // _EDITSES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\funcprv.h ===
//
// funcprv.h
//

#ifndef FUNCPRV_H
#define FUNCPRV_H

#include "private.h"
#include "immif.h"
#include "fnprbase.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

class CFunctionProvider :  public CFunctionProviderBase
{
public:
    CFunctionProvider(ImmIfIME *pImmIfIME, TfClientId tid);

    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    ImmIfIME* _ImmIfIME;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnDocFeed
//
//////////////////////////////////////////////////////////////////////////////

class CFnDocFeed : public IAImmFnDocFeed
{
public:
    CFnDocFeed(CFunctionProvider *pFuncPrv);
    ~CFnDocFeed();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    //
    // ITfFnDocFeed
    //
    STDMETHODIMP DocFeed();
    STDMETHODIMP ClearDocFeedBuffer();
    STDMETHODIMP StartReconvert();

    STDMETHODIMP StartUndoCompositionString();

private:
    CFunctionProvider *_pFuncPrv;
    long _cRef;
};


#endif // FUNCPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\funcprv.cpp ===
//
// funcprv.cpp
//

#include "private.h"
#include "helpers.h"
#include "immxutil.h"
#include "funcprv.h"
#include "cresstr.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunctionProvider::CFunctionProvider(ImmIfIME *pImmIfIME, TfClientId tid) : CFunctionProviderBase(tid)
{
    Init(CLSID_CAImmLayer, L"AIMM12 Function Provider");
    _ImmIfIME = pImmIfIME;
}

//+---------------------------------------------------------------------------
//
// GetFunction
//
//----------------------------------------------------------------------------

STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_NOINTERFACE;

    if (IsEqualIID(riid, IID_IAImmFnDocFeed))
    {
        *ppunk = new CFnDocFeed(this);
    }

    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnDocFeed
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IAImmFnDocFeed))
    {
        *ppvObj = SAFECAST(this, CFnDocFeed *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnDocFeed::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnDocFeed::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnDocFeed::CFnDocFeed(CFunctionProvider *pFuncPrv)
{
    _cRef = 1;
    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnDocFeed::~CFnDocFeed()
{
    _pFuncPrv->Release();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::GetDisplayName(BSTR *pbstrName)
{
    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = SysAllocString(CRStr2(IDS_FUNCPRV_CONVERSION));
    if (!*pbstrName)
        return E_OUTOFMEMORY;

    return S_OK;
}
//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::IsEnabled(BOOL *pfEnable)
{
    if (!pfEnable)
        return E_INVALIDARG;

    *pfEnable = TRUE;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// CFnDocFeed::DocFeed
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::DocFeed()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    _pFuncPrv->_ImmIfIME->SetupDocFeedString(pAImeContext->GetInputContext(), imc);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::ClearDocFeedBuffer
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::ClearDocFeedBuffer()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    _pFuncPrv->_ImmIfIME->ClearDocFeedBuffer(pAImeContext->GetInputContext(), imc);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::StartReconvert
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::StartReconvert()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    pAImeContext->SetupReconvertString();
    pAImeContext->EndReconvertString();
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnDocFeed::StartUndoCompositionString
//
//----------------------------------------------------------------------------

STDAPI CFnDocFeed::StartUndoCompositionString()
{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    IMCLock imc(ptls->hIMC);
    if (imc.Invalid())
        return E_FAIL;

    CAImeContext* pAImeContext = imc->m_pAImeContext;
    if (!pAImeContext)
        return E_FAIL;

    Assert(_pFuncPrv);
    pAImeContext->SetupUndoCompositionString();
    pAImeContext->EndUndoCompositionString();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\globals.cpp ===
//
// globals.cpp
//

#include "private.h"

#include "idebug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\globals.h ===
//
// globals.h
//


#ifndef IMMIF_GLOBALS_H
#define IMMIF_GLOBALS_H

#include "template.h"

void WINAPI DllAddRef(void);
void WINAPI DllRelease(void);

BYTE GetCharsetFromLangId(LCID lcid);
UINT GetCodePageFromLangId(LCID lcid);

/////////////////////////////////////////////////////////////////////////////
// Module instance

__inline HINSTANCE GetInstance()
{
    extern HINSTANCE g_hInst;
    return g_hInst;
}

/////////////////////////////////////////////////////////////////////////////
// Mouse sink

typedef struct tagPRIVATE_MOUSESINK {
    Interface<ITfRangeACP> range;
    HIMC         hImc;
} PRIVATE_MOUSESINK, *LPPRIVATE_MOUSESINK;


typedef struct tagMOUSE_RANGE_RECT {
    ULONG uStartRangeEdge;
    ULONG uStartRangeQuadrant;
    ULONG uEndRangeEdge;
    ULONG uEndRangeQuadrant;
} MOUSE_RANGE_RECT, *LPMOUSE_RANGE_RECT;


/////////////////////////////////////////////////////////////////////////////
// WM_MSIME_xxxx

extern    UINT  WM_MSIME_SERVICE;
extern    UINT  WM_MSIME_UIREADY;
extern    UINT  WM_MSIME_RECONVERTREQUEST;
extern    UINT  WM_MSIME_RECONVERT;
extern    UINT  WM_MSIME_DOCUMENTFEED;
extern    UINT  WM_MSIME_QUERYPOSITION;
extern    UINT  WM_MSIME_MODEBIAS;
extern    UINT  WM_MSIME_SHOWIMEPAD;
extern    UINT  WM_MSIME_MOUSE;
extern    UINT  WM_MSIME_KEYMAP;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\idebug.cpp ===
//
// debug.cpp
//

#include "private.h"

#include <stdio.h>
#include "debug.h"

namespace immif_debug {

	void debug_printf(const char* fmt, ...)
	{
		char buff[512];
		va_list arglist;

		va_start(arglist, fmt);
		_vsnprintf(buff, ARRAYSIZE(buff) - 1, fmt, arglist);
		va_end(arglist);
		buff[ARRAYSIZE(buff) - 1] = 0;
		OutputDebugStringA("[ImmIf] ");
		OutputDebugStringA(buff);
		OutputDebugStringA("\n");
	}

} // end of debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\icocb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    icocb.h

Abstract:

    This file defines the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _ICOCB_H_
#define _ICOCB_H_

#include "cime.h"

class CMouseSink;
class ImmIfIME;

class CInputContextOwnerCallBack : public CInputContextOwner
{
public:
    CInputContextOwnerCallBack(LIBTHREAD *pLibTLS);
    virtual ~CInputContextOwnerCallBack();

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    BOOL Init();

    //
    // Mouse sink
    //
    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, IMCLock& imc,
                              ImmIfIME* ImmIfIme);

    //
    // Callbacks
    //
private:
    static HRESULT ICOwnerSinkCallback(UINT uCode, ICOARGS *pargs, void *pv);

    HRESULT GetAttribute(const GUID *pguid, VARIANT *pvarValue);

    //
    // Mouse sink
    //
    CMouseSink                      *m_pMouseSink;

    LIBTHREAD                       *m_pLibTLS;
};

#endif // _ICOCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\icocb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    icocb.cpp

Abstract:

    This file implements the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "icocb.h"
#include "cime.h"
#include "imeapp.h"
#include "mouse.h"
#include "tsattrs.h"
#include "imtls.h"
#include "a_context.h"
#include "candpos.h"


CInputContextOwnerCallBack::CInputContextOwnerCallBack(LIBTHREAD *pLibTLS
    ) : CInputContextOwner(ICOwnerSinkCallback, NULL)
{
    m_pMouseSink = NULL;

    m_pLibTLS = pLibTLS;
}

CInputContextOwnerCallBack::~CInputContextOwnerCallBack(
    )
{
    if (m_pMouseSink) {
        m_pMouseSink->InternalRelease();
        m_pMouseSink = NULL;
    }
}

BOOL CInputContextOwnerCallBack::Init()
{
    //
    // Create Mouse Sink
    //
    Assert(!m_pMouseSink);

    m_pMouseSink = new CMouseSink;
    if (m_pMouseSink == NULL)
        return FALSE;

    if (!m_pMouseSink->Init())
    {
        delete m_pMouseSink;
        m_pMouseSink = NULL;
        return FALSE;
    }

    return TRUE;
}


// static
HRESULT
CInputContextOwnerCallBack::ICOwnerSinkCallback(
    UINT uCode,
    ICOARGS *pargs,
    void *pv
    )
{
    DebugMsg(TF_FUNC, "ICOwnerSinkCallback");

    POINT pt;
    IMTLS *ptls;

    CInputContextOwnerCallBack* _this = (CInputContextOwnerCallBack*)pv;

    switch (uCode)
    {
        case ICO_POINT_TO_ACP:
            Assert(0);
            return E_NOTIMPL;

        case ICO_KEYDOWN:
        case ICO_KEYUP:
            *pargs->key.pfEaten = FALSE;
            break;

        case ICO_SCREENEXT:
            {
            ptls = IMTLS_GetOrAlloc();
            if (ptls == NULL)
                break;
            IMCLock imc(ptls->hIMC);
            if (imc.Invalid())
                break;

            GetClientRect(imc->hWnd, pargs->scr_ext.prc);
            pt.x = pt.y = 0;
            ClientToScreen(imc->hWnd, &pt);

            pargs->scr_ext.prc->left += pt.x;
            pargs->scr_ext.prc->right += pt.x;
            pargs->scr_ext.prc->top += pt.y;
            pargs->scr_ext.prc->bottom += pt.y;
            }

            break;

        case ICO_TEXTEXT:
            //
            // consider.
            //
            // hack TextExtent from CANDIDATEFORM of HIMC.
            //
            // more hacks
            //   - may want to send WM_OPENCANDIDATEPOS to let apps
            //     call ImmSetCandidateWindow().
            //   - may need to calculate the actual point from rcArea.
            //
            {
                CCandidatePosition cand_pos;
                cand_pos.GetCandidatePosition(pargs->text_ext.prc);
            }
            break;

        case ICO_STATUS:
            pargs->status.pdcs->dwDynamicFlags = 0;
            pargs->status.pdcs->dwStaticFlags = TF_SS_TRANSITORY;
            break;

        case ICO_WND:
            {
                ptls = IMTLS_GetOrAlloc();
                if (ptls == NULL)
                    break;
                IMCLock imc(ptls->hIMC);
                *(pargs->hwnd.phwnd) = NULL;
                if (imc.Invalid())
                    break;

                *(pargs->hwnd.phwnd) = imc->hWnd;
            }
            break;

        case ICO_ATTR:
            return _this->GetAttribute(pargs->sys_attr.pguid, pargs->sys_attr.pvar);

        case ICO_ADVISEMOUSE:
            {
                ptls = IMTLS_GetOrAlloc();
                if (ptls == NULL)
                    break;
                _this->m_pMouseSink->InternalAddRef();
                return _this->m_pMouseSink->AdviseMouseSink(ptls->hIMC,
                                                            pargs->advise_mouse.rangeACP,
                                                            pargs->advise_mouse.pSink,
                                                            pargs->advise_mouse.pdwCookie);
            }
            break;

        case ICO_UNADVISEMOUSE:
            {
                HRESULT hr = _this->m_pMouseSink->UnadviseMouseSink(pargs->unadvise_mouse.dwCookie);
                _this->m_pMouseSink->InternalRelease();
                return hr;
            }
            break;

        default:
            Assert(0); // shouldn't ever get here
            break;
    }

    return S_OK;
}

/*++

Method:

    CInputContextOwnerCallBack::GetAttribute

Routine Description:

    Implementation of ITfContextOwner::GetAttribute.  Returns the value of a cicero
    app property attribute.

Arguments:


    pguid - [in] GUID of the attrib in question.
    pvarValue - [out] VARIANT, receives the value.  VT_EMPTY if we don't support it.

Return Value:

    Returns S_OK if successful, or an error code otherwise.

--*/

HRESULT
CInputContextOwnerCallBack::GetAttribute(
    const GUID *pguid,
    VARIANT *pvarValue
    )
{
    TfGuidAtom ga;
    const GUID *pguidValue;
    IMTLS *ptls;

    QuickVariantInit(pvarValue);

    ptls = IMTLS_GetOrAlloc();
    if (ptls == NULL)
        return E_FAIL;

    if (IsEqualGUID(*pguid, GUID_PROP_MODEBIAS))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        IMCLock imc(ptls->hIMC);
        if (imc.Invalid())
            return E_FAIL;

        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        ASSERT(_pAImeContext != NULL);
        if (_pAImeContext == NULL)
            return E_FAIL;

        if (_pAImeContext->lModeBias == MODEBIASMODE_FILENAME)
        {
            pguidValue = &GUID_MODEBIAS_FILENAME;
        }
        else if (_pAImeContext->lModeBias == MODEBIASMODE_DIGIT)
        {
            pguidValue = &GUID_MODEBIAS_NUMERIC;
        }
        else
        {
            if (imc->fdwConversion & IME_CMODE_GUID_NULL) {
                //
                // If extended conversion mode were set on,
                // returns GUID_NULL.
                // No returns any MODEBIAS.
                //
                pguidValue = &GUID_NULL;
            }
            else

            //
            // existing logic:
            //
            // if imcp->lModeBias == MODEBIASMODE_DEFAULT
            //      IME_SMODE_CONVERSATION -> GUID_MODEBIAS_CONVERSATION
            //      otherwise -> GUID_MODEBIAS_NONE
            // otherwise
            //      -> MODEBIASMODE_FILENAME -> GUID_MODEBIAS_FILENAME
            //

            if (_pAImeContext->lModeBias == MODEBIASMODE_DEFAULT)
            {
                pguidValue = &GUID_MODEBIAS_NONE;

                if (imc->fdwConversion & IME_CMODE_KATAKANA)
                {
                    if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                        pguidValue = &GUID_MODEBIAS_KATAKANA;
                    else
                        pguidValue = &GUID_MODEBIAS_HALFWIDTHKATAKANA;
                }
                else if (imc->fdwConversion & IME_CMODE_NATIVE)
                {
                    pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                    LANGID langid;
                    ptls->pAImeProfile->GetLangId(&langid);
                    if (langid == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))
                    {
                        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                            pguidValue = &GUID_MODEBIAS_HIRAGANA;
                        else
                            pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                    }
                    else if (langid == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT))
                    {
                        if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                            pguidValue = &GUID_MODEBIAS_FULLWIDTHHANGUL;
                        else
                            pguidValue = &GUID_MODEBIAS_HANGUL;
                    }
                    else if (PRIMARYLANGID(langid) == LANG_CHINESE)
                    {
                        pguidValue = &GUID_MODEBIAS_CHINESE;
                    }
                }
                else
                {
                    if (imc->fdwConversion & IME_CMODE_FULLSHAPE)
                        pguidValue = &GUID_MODEBIAS_FULLWIDTHALPHANUMERIC;
                    else
                        pguidValue = &GUID_MODEBIAS_HALFWIDTHALPHANUMERIC;
                }
            }

            //
            // We overwrite modebias here....
            //
            if (imc->fdwSentence & IME_SMODE_GUID_NULL) {
                //
                // If extended sentence mode were set on,
                // returns GUID_NULL.
                // No returns any MODEBIAS.
                //
                // Nothing to do. pguidValue might be changed with CMODE
                // pguidValue = &GUID_NULL;
            }
            else if (imc->fdwSentence & IME_SMODE_CONVERSATION)
                pguidValue = &GUID_MODEBIAS_CONVERSATION;
            else if (imc->fdwSentence & IME_SMODE_PLAURALCLAUSE)
                pguidValue = &GUID_MODEBIAS_NAME;
        }

        if (!GetGUIDATOMFromGUID(m_pLibTLS, *pguidValue, &ga))
            return E_FAIL;

        pvarValue->vt = VT_I4; // for TfGuidAtom
        pvarValue->lVal = ga;
    }
    if (IsEqualGUID(*pguid, TSATTRID_Text_Orientation))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        IMCLock imc(ptls->hIMC);
        if (imc.Invalid())
            return E_FAIL;

        pvarValue->vt = VT_I4; 
        pvarValue->lVal = imc->lfFont.A.lfEscapement;
    }
    if (IsEqualGUID(*pguid, TSATTRID_Text_VerticalWriting))
    {
        // xlate conversion mode, sentence mode to cicero mode bias
        IMCLock imc(ptls->hIMC);
        if (imc.Invalid())
            return E_FAIL;

        LOGFONTW font;
        if (SUCCEEDED(ptls->pAImm->GetCompositionFontW(ptls->hIMC, &font))) {
            pvarValue->vt = VT_BOOL; 
            pvarValue->lVal = (imc->lfFont.W.lfFaceName[0] == L'@' ? TRUE : FALSE);
        }
    }


    return S_OK;
}

LRESULT
CInputContextOwnerCallBack::MsImeMouseHandler(
    ULONG uEdge,
    ULONG uQuadrant,
    ULONG dwBtnStatus,
    IMCLock& imc,
    ImmIfIME* ImmIfIme
    )
{
    return m_pMouseSink->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, imc, ImmIfIme);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\idebug.h ===
//
// debug.h
//

#ifndef IMMIF_DEBUG_H
#define IMMIF_DEBUG_H

#include "debug.h"

#if DBG

    #define D(x)    x

//    namespace immif_debug {
//        extern void debug_printf(const char* fmt, ...);
//    };

#else

    #define D(x)

#endif


#if DBG
#define VERIFY(x)   D(ASSERT(x))
#else
#define VERIFY(x)   (x)
#endif

#define TRACE0(s)               D(DebugMsg(TF_ALWAYS, "%s", s))
#define TRACE1(fmt, a)          D(DebugMsg(TF_ALWAYS, fmt, a))
#define TRACE2(fmt, a, b)       D(DebugMsg(TF_ALWAYS, fmt, a, b))
#define TRACE3(fmt, a, b, c)    D(DebugMsg(TF_ALWAYS, fmt, a, b, c))
#define TRACE4(fmt, a, b, c, d) D(DebugMsg(TF_ALWAYS, fmt, a, b, c, d))
#define TRACE5(fmt, a, b, c, d, e) \
                                D(DebugMsg(TF_ALWAYS, fmt, a, b, c, d, e))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\korimx.h ===
#ifndef _KORIMX_H_
#define _KORIMX_H_


const GUID GUID_COMPARTMENT_KORIMX_CONVMODE =
	{ 
	0x91656349, 
	0x4ba9, 
	0x4143, 
	{ 0xa1, 0xae, 0x7f, 0xbc, 0x20, 0xb6, 0x31, 0xbc } 
	};

//
//  Korean TIP Conversion modes
//
#define KORIMX_ALPHANUMERIC_MODE           0
#define KORIMX_HANGUL_MODE                 1
#define KORIMX_JUNJA_MODE                  2
#define KORIMX_HANGULJUNJA_MODE            3

#endif // _KORIMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\init.cpp ===
/**********************************************************************/
/* Copyright (C) 1993-1995 Microsoft Corporation                      */
/**********************************************************************/

#include "private.h"

#include "immif.h"
// #include "commctrl.h"
// #include "cuilib.h"

/**********************************************************************/
/* RegisterImeClass()                                                 */
/**********************************************************************/
// class static
BOOL WINAPI ImmIfIME::_RegisterImeClass(
    WNDPROC     lpfnUIWndProc
    )
{
    WNDCLASSEXA wcWndCls;

    // IME UI class
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(LONG_PTR) * 2;
    wcWndCls.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wcWndCls.hInstance     = GetInstance();
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPTSTR)NULL;
    wcWndCls.hIconSm       = NULL;

    // IME UI class
    if (!GetClassInfoExA(GetInstance(), s_szUIClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME | CS_GLOBALCLASS;
        wcWndCls.lpfnWndProc   = lpfnUIWndProc;
        wcWndCls.lpszClassName = s_szUIClassName;

        ATOM atom = RegisterClassExA(&wcWndCls);
        if (!atom)
            return FALSE;
    }

    return TRUE;
}

void WINAPI ImmIfIME::_UnRegisterImeClass()
{
    WNDCLASSEX wcWndCls;

    GetClassInfoEx(GetInstance(), s_szUIClassName, &wcWndCls);
    UnregisterClass(s_szUIClassName, GetInstance());

    DestroyIcon(wcWndCls.hIcon);
    DestroyIcon(wcWndCls.hIconSm);
}

/**********************************************************************/
/* AttachIME() / UniAttachMiniIME()                                   */
/**********************************************************************/
BOOL PASCAL AttachIME(
    WNDPROC     lpfnUIWndProc
    )
{
    BOOL bRet;

    bRet = ImmIfIME::_RegisterImeClass(lpfnUIWndProc);

    return bRet;
}


/**********************************************************************/
/* DetachIME() / UniDetachMiniIME()                                   */
/**********************************************************************/
void PASCAL DetachIME()
{
    ImmIfIME::_UnRegisterImeClass();
}

BOOL WIN32LR_DllProcessAttach()
{
#if !defined( OLD_AIMM_ENABLED )
    //
    // Might be required by some library function, so let's initialize
    // it as the first thing.
    //
    TFInitLib();
#endif // OLD_AIMM_ENABLED

    if (!AttachIME(UIWndProcA)) {
        return FALSE;
    }

    return TRUE;
}

void WIN32LR_DllThreadAttach()
{
}

void WIN32LR_DllThreadDetach()
{
}

void WIN32LR_DllProcessDetach()
{
    DetachIME();
#if !defined( OLD_AIMM_ENABLED )
    TFUninitLib();
#endif // OLD_AIMM_ENABLED
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\imedefs.h ===
#ifndef IMMIF_IMEDEFS_H
#define IMMIF_IMEDEFS_H




// debug flag
#define DEB_FATAL               0
#define DEB_ERR                 1
#define DEB_WARNING             2
#define DEB_TRACE               3

#ifdef _WIN32
void FAR cdecl _DebugOut(UINT, LPCSTR, ...);
#endif

#define NATIVE_CHARSET          ANSI_CHARSET




// state of composition
#define CST_INIT                0
#define CST_INPUT               1



// IME specific constants






void    PASCAL CreateCompWindow(HWND);                          // compui.c

LRESULT CALLBACK UIWndProcA(HWND, UINT, WPARAM, LPARAM);        // ui.c

LRESULT CALLBACK CompWndProc(HWND, UINT, WPARAM, LPARAM);       // compui.c





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\immif.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    immif.h

Abstract:

    This file defines the IMM Interface Class.

Author:

Revision History:

Notes:

--*/

#ifndef _IMMIF_H_
#define _IMMIF_H_

#include "imedefs.h"
#include "cime.h"
#include "ctxtcomp.h"
#include "caime.h"
#include "ico.h"
#include "globals.h"
#include "immxutil.h"
#include "a_context.h"

class ImmIfIME : public CAIME
{
public:
    ImmIfIME();
    ~ImmIfIME();

    //
    // IActiveIME methods
    //

    STDMETHODIMP ConnectIMM(IActiveIMMIME_Private *pActiveIMM);
    STDMETHODIMP UnconnectIMM();
    STDMETHODIMP Inquire(DWORD dwSystemInfoFlags, IMEINFO *pIMEInfo, LPWSTR szWndClass, DWORD *pdwPrivate);
    STDMETHODIMP ConversionList(HIMC hIMC, LPWSTR szSource, UINT uFlag, UINT uBufLen, CANDIDATELIST *pDest, UINT *puCopied);
    STDMETHODIMP Configure(HKL hKL, HWND hWnd, DWORD dwMode, REGISTERWORDW *pRegisterWord);
    STDMETHODIMP Destroy(UINT uReserved);
    STDMETHODIMP Escape(HIMC hIMC, UINT uEscape, void *pData, LRESULT *plResult);
    STDMETHODIMP ProcessKey(HIMC hIMC, UINT uVirKey, DWORD lParam, BYTE *pbKeyState);
    STDMETHODIMP Notify(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
    STDMETHODIMP SelectEx(HIMC hIMC, DWORD dwFlags, BOOL bIsRealIme_SelKL, BOOL bIsRealIme_UnSelKL);
    STDMETHODIMP UnSelectCheck(HIMC hIMC);
    STDMETHODIMP SetCompositionString(HIMC hIMC, DWORD dwIndex, void *pComp, DWORD dwCompLen, void *pRead, DWORD dwReadLen);
    STDMETHODIMP ToAsciiEx(UINT uVirKey, UINT uScanCode, BYTE *pbKeyState, UINT fuState, HIMC hIMC, DWORD *pdwTransBuf, UINT *puSize);
    STDMETHODIMP RegisterWord(LPWSTR szReading, DWORD dwStyle, LPWSTR szString);
    STDMETHODIMP UnregisterWord(LPWSTR szReading, DWORD  dwStyle, LPWSTR szString);
    STDMETHODIMP GetRegisterWordStyle(UINT nItem, STYLEBUFW *pStyleBuf, UINT *puBufSize);
    STDMETHODIMP EnumRegisterWord(LPWSTR szReading, DWORD dwStyle, LPWSTR szRegister, LPVOID pData, IEnumRegisterWordW **ppEnum);
    STDMETHODIMP GetCodePageA(UINT *uCodePage);
    STDMETHODIMP GetLangId(LANGID *plid);
    STDMETHODIMP AssociateFocus(HWND hWnd, HIMC hIMC, DWORD dwFlags);
    STDMETHODIMP SetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);
    STDMETHODIMP GetThreadCompartmentValue(REFGUID rguid, VARIANT *pvar);

    HRESULT ToAsciiEx(UINT uVirKey, UINT uScanCode, BYTE* pbKeyState, UINT fuState, HIMC hIMC, TRANSMSGLIST* pTransBuf, UINT* puSize);

    //
    // AIMM1.2 interface
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

public:
    BOOL _ImeInquire(LPIMEINFO, LPWSTR, DWORD);

    //
    // Helpers
    //
    static BOOL WINAPI _RegisterImeClass(WNDPROC lpfnUIWndProc);
    static void WINAPI _UnRegisterImeClass();

    LIBTHREAD *_GetLibTLS()
    {
        return &_libTLS;
    }

    BOOL IsRealIme()
    {
        BOOL fReal = FALSE;
        if (m_pIActiveIMMIME)
        {
            m_pIActiveIMMIME->IsRealImePublic(&fReal);
        }

        return fReal;
    }

private:
    BOOL WINAPI _NotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    HRESULT WINAPI _ToAsciiEx(HIMC hImc, UINT uVKey, UINT uScanCode, TRANSMSGLIST* pTransBuf, UINT* puSize);

    BOOL WINAPI _WantThisKey(HIMC hImc, UINT uVKey, BOOL* pfNextHook = NULL)
    {
        IMCLock imc(hImc);
        if (imc.Invalid())
            return false;

        return _WantThisKey(imc, uVKey, pfNextHook);
    }
    BOOL WINAPI _WantThisKey(IMCLock& imc, UINT uVKey, BOOL* pfNextHook = NULL);

    HRESULT _HandleThisKey(IMCLock& imc, UINT uVKey);

public:
    HRESULT _UpdateCompositionString(DWORD dwDeltaStart = 0);

    HRESULT _CompCancel(IMCLock& imc);
    HRESULT _CompComplete(IMCLock& imc, BOOL fSync = TRUE);


public:
    //
    // Cicero stuff
    //
    HRESULT InitIMMX();
    void UnInitIMMX();

private:
    BOOL IsCheckAtom();

public:
    Interface_Attach<ITfContext> GetInputContext(IMCLock& imc) const
    {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (!_pAImeContext)
            return NULL;
        Interface_Attach<ITfContext> ic(_pAImeContext->GetInputContext());
        return ic;
    }

    Interface_Attach<ITfDocumentMgr> GetDocumentManager(IMCLock& imc) const
    {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (!_pAImeContext)
            return NULL;
        Interface_Attach<ITfDocumentMgr> dim(_pAImeContext->GetDocumentManager());
        return dim;
    }

    Interface_Attach<ITfContextOwnerServices> GetInputContextOwnerSink(IMCLock& imc) const
    {
        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (!_pAImeContext)
            return NULL;
        Interface_Attach<ITfContextOwnerServices> iccb(_pAImeContext->GetInputContextOwnerSink());
        return iccb;
    }

    Interface_Attach<ITfThreadMgr_P> GetThreadManagerInternal() const
    {
        Interface_Attach<ITfThreadMgr_P> tim(m_tim);
        return tim;
    }

    Interface_Attach<ImmIfIME> GetCurrentInterface()
    {
        Interface_Attach<ImmIfIME> ImmIfIme(this);
        return ImmIfIme;
    }

    TfClientId GetClientId() {return m_tfClientId;}
    bool   IsOpenStatusChanging() {return m_ulOpenStatusChanging > 0;}

protected:
    static const char s_szUIClassName[16];

protected:
    bool             m_fCicInit : 1;
    bool             m_fOnSetFocus : 1;
    ULONG            m_ulOpenStatusChanging;
    ULONG            m_ulKorImxModeChanging;

    ITfThreadMgr_P  *m_tim;
    ITfDocumentMgr  *m_dimEmpty;   // empty dim for NULL hIMC.
    TfClientId       m_tfClientId;

    ITfKeystrokeMgr *m_pkm;

    IAImeProfile    *m_AImeProfile;

    LIBTHREAD       _libTLS; // tls for the helper library. Since this object is apt threaded,
                             // all members are accessed in a single thread
                             // also, cicero will only create a single instance of this obj per thread
    
    BOOL            m_fAddedProcessAtom : 1;

private:

    HRESULT Internal_SetCompositionString(CWCompString& wCompStr, CWCompString& wCompReadStr);
    HRESULT Internal_ReconvertString(IMCLock& imc, CWReconvertString& wReconvStr, CWReconvertString& wReconvReadStr);

    static HRESULT Internal_QueryReconvertString_ICOwnerSink(UINT uCode, ICOARGS *pargs, VOID *pv);
    HRESULT Internal_QueryReconvertString(IMCLock& imc, RECONVERTSTRING* pReconv, UINT cp, BOOL fNeedAW);

    void SetFocus(HWND hWnd, ITfDocumentMgr* pdim, BOOL fSetFocus);

public:
    // void  AdjustZeroCompLenReconvertString(RECONVERTSTRING *pReconv, UINT cp, BOOL fAnsi);
    HRESULT SetupReconvertString(ITfContext *pic, IMCLock& imc, UINT uPrivMsg = 0);
    HRESULT EndReconvertString(IMCLock& imc);

    HRESULT SetupDocFeedString(ITfContext *pic, IMCLock& imc);
    HRESULT ClearDocFeedBuffer(ITfContext *pic, IMCLock& imc, BOOL fSync = TRUE);

private:
    HRESULT _ReconvertStringNegotiation(ITfContext *pic, IMCLock& imc, UINT uPrivMsg);
    HRESULT _ReconvertStringTextStore(ITfContext *pic, IMCLock& imc, UINT uPrivMsg);

public:
    HRESULT GetTextAndAttribute(IMCLock& imc,
                                CWCompString* wCompString, CWCompAttribute* wCompAttribute);
    HRESULT GetTextAndAttribute(IMCLock& imc,
                                CBCompString* bCompString, CBCompAttribute* bCompAttribute);
public:
    HRESULT GetCursorPosition(IMCLock& imc, CWCompCursorPos* wCursorPosition);
public:
    HRESULT GetSelection(IMCLock& imc, CWCompCursorPos& wStartSelection, CWCompCursorPos& wEndSelection);

    //
    // Notification
    //
public:
    HRESULT OnSetOpenStatus(IMCLock& imc);
    HRESULT OnSetConversionSentenceMode(IMCLock& imc);
    HRESULT OnSetCandidatePos(IMCLock& imc);
    HRESULT OnSetKorImxConversionMode(IMCLock& imc);

};

inline void SetThis(HWND hWnd, LPARAM lParam)
{
    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
}

inline ImmIfIME *GetThis(HWND hWnd)
{
    ImmIfIME *pIME = (ImmIfIME *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    ASSERT(pIME != NULL);

    return pIME;
}

#endif // _IMMIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\makefile.inc ===
imm.h : $(OAK_INC_PATH)\immdev.h
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\langct.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langct.h

Abstract:

    This file defines the LanguageCountry Class for each country.

Author:

Revision History:

Notes:

--*/

#ifndef _LANGCT_H_
#define _LANGCT_H_

#include "language.h"

class CLanguageCountry
{
public:
    CLanguageCountry(LANGID LangId);
    ~CLanguageCountry();

    CLanguage* language;

    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        if (language)
            return language->Escape(cp, hIMC, uEscape, lpData, plResult);
        else
            return E_NOTIMPL;
    }

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        if (language)
            return language->GetProperty(property, conversion_caps, sentence_caps, SCSCaps, UICaps);
        else {
            *property =
            IME_PROP_UNICODE |       // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
            IME_PROP_AT_CARET;       // If set, conversion window is at the caret position.
            *conversion_caps = 0;
            *sentence_caps = 0;
            *SCSCaps = 0;
            *UICaps = 0;

            return S_OK;
        }
    }
};

#endif // _LANGCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\langct.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langct.cpp

Abstract:

    This file implements the LanguageCountry Class for each country.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "langct.h"
#include "langchx.h"
#include "langjpn.h"
#include "langkor.h"


CLanguageCountry::CLanguageCountry(
    LANGID LangId
    )
{
    language = NULL;

    switch(PRIMARYLANGID(LangId)) {
        case LANG_CHINESE:
            language = new CLanguageChinese;
            break;
        case LANG_JAPANESE:
            language = new CLanguageJapanese;
            break;
        case LANG_KOREAN:
            language = new CLanguageKorean;
            break;
    }
}

CLanguageCountry::~CLanguageCountry(
    )
{
    if (language)
        delete language;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\langkor.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langkor.cpp

Abstract:

    This file implements the Language for Korean Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cime.h"
#include "ctxtcomp.h"
#include "langkor.h"
#include "a_wrappers.h"
#include "a_context.h"

HRESULT
CLanguageKorean::Escape(
    UINT cp,
    HIMC hIMC,
    UINT uEscape,
    LPVOID lpData,
    LRESULT *plResult
    )
{
    TRACE0("CLanguageKorean::Escape");

    HRESULT hr;

    if (!lpData)
        return E_FAIL;

    switch (uEscape) {
        case IME_ESC_QUERY_SUPPORT:
            switch (*(LPUINT)lpData) {
                case IME_ESC_HANJA_MODE: hr = S_OK; *plResult = TRUE; break;
                default:                 hr = E_NOTIMPL; break;
            }
            break;

        case IME_ESC_HANJA_MODE:
            hr = EscHanjaMode(cp, hIMC, (LPWSTR)lpData, plResult);
#if 0
            if (SUCCEEDED(hr)) {
                IMCLock lpIMC(hIMC);
                if (SUCCEEDED(hr=lpIMC.GetResult())) {
                    SendMessage(lpIMC->hWnd, WM_IME_NOTIFY, IMN_OPENCANDIDATE, 1L);
                }
            }
#endif
            break;

        default:
            hr = E_NOTIMPL;
            break;
    }
    return hr;
}

HRESULT
CLanguageKorean::EscHanjaMode(
    UINT cp,
    HIMC hIMC,
    LPWSTR lpwStr,
    LRESULT* plResult
    )
{
    HRESULT hr;
    IMCLock lpIMC(hIMC);

    if (FAILED(hr=lpIMC.GetResult()))
        return hr;

    CAImeContext* pAImeContext = lpIMC->m_pAImeContext;
    if (pAImeContext)
    {
        //
        // This is for only Excel since Excel calling Hanja escape function two
        // times. we going to just ignore the second request not to close Hanja
        // candidate window.
        //
        if (pAImeContext->m_fOpenCandidateWindow)
        {
            //
            // Need to set the result value since some apps(Trident) also call
            // Escape() twice and expect the right result value.
            //
            *plResult = TRUE;
            return S_OK;
        }

        pAImeContext->m_fHanjaReConversion = TRUE;
    }

    CWReconvertString wReconvStr(cp, hIMC);
    wReconvStr.WriteCompData(lpwStr, wcslen(lpwStr));

    BOOL fCompMem = FALSE;
    LPRECONVERTSTRING lpReconvertString = NULL;
    DWORD dwLen = wReconvStr.ReadCompData();
    if (dwLen) {
        lpReconvertString = (LPRECONVERTSTRING) new BYTE[ dwLen ];
        if (lpReconvertString) {
            fCompMem = TRUE;
            wReconvStr.ReadCompData(lpReconvertString, dwLen);
        }
    }

    IMTLS *ptls = IMTLS_GetOrAlloc();

    *plResult = ImmSetCompositionStringW(ptls, hIMC, SCS_QUERYRECONVERTSTRING, lpReconvertString, dwLen, NULL, 0);
    if (*plResult) {
        *plResult = ImmSetCompositionStringW(ptls, hIMC, SCS_SETRECONVERTSTRING, lpReconvertString, dwLen, NULL, 0);
        if (*plResult) {
            *plResult = ImmSetConversionStatus(ptls, hIMC, lpIMC->fdwConversion | IME_CMODE_HANJACONVERT,
                                                     lpIMC->fdwSentence);
        }
    }

    if (pAImeContext)
        pAImeContext->m_fHanjaReConversion = FALSE;


    if (fCompMem)
        delete [] lpReconvertString;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\language.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    language.h

Abstract:

    This file defines the Language Class for pure virtual function.

Author:

Revision History:

Notes:

--*/

#ifndef _LANGUAGE_H_
#define _LANGUAGE_H_

class CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    virtual HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult) = 0;

    /*
     * Local
     */
    virtual HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps) = 0;
};

#endif // _LANGUAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\langchx.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langchx.h

Abstract:

    This file defines the Language for Chinese Class.

Author:

Revision History:

Notes:

--*/

#ifndef _LANG_CHX_H_
#define _LANG_CHX_H_

#include "language.h"
#include "idebug.h"

class CLanguageChinese : public CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        TRACE0("CLanguageChinese::Escape");
        return E_NOTIMPL;
    }

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        *property =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY;        // This IME needs the ALT key to be passed to ImmProcessKey.

        *conversion_caps =
        IME_CMODE_CHINESE |          // This bit on indicates IME is in CHINESE(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_FULLSHAPE;

        *sentence_caps =
        IME_SMODE_PLAURALCLAUSE;

        *SCSCaps =
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.

        *UICaps = UI_CAP_ROT90;

        return S_OK;
    }

private:

};

#endif // _LANG_CHX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\langjpn.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langjpn.h

Abstract:

    This file defines the Language for Japanese Class.

Author:

Revision History:

Notes:

--*/

#ifndef _LANG_JPN_H_
#define _LANG_JPN_H_

#include "language.h"
#include "idebug.h"

class CLanguageJapanese : public CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult)
    {
        TRACE0("CLanguageJapanese::Escape");
        return E_NOTIMPL;
    }

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        *property =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY |              // This IME needs the ALT key to be passed to ImmProcessKey.
        IME_PROP_COMPLETE_ON_UNSELECT;      // Windows 98 and Windows 2000:
                                            // If set, the IME will complete the composition
                                            // string when the IME is deactivated.
                                            // If clear, the IME will cancel the composition
                                            // string when the IME is deactivated.
                                            // (for example, from a keyboard layout change).

        *conversion_caps =
        IME_CMODE_JAPANESE |         // This bit on indicates IME is in JAPANESE(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_KATAKANA |         // 
        IME_CMODE_FULLSHAPE;

        *sentence_caps =
        IME_SMODE_PLAURALCLAUSE |
        IME_SMODE_CONVERSATION;

        *SCSCaps =
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.

        *UICaps = UI_CAP_ROT90;

        return S_OK;
    }

private:

};

#endif // _LANG_JPN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\langkor.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    langkor.h

Abstract:

    This file defines the Language for Korean Class.

Author:

Revision History:

Notes:

--*/

#ifndef _LANG_KOR_H_
#define _LANG_KOR_H_

#include "language.h"

class CLanguageKorean : public CLanguage
{
public:


    /*
     * IActiveIME methods.
     */
public:
    HRESULT Escape(UINT cp, HIMC hIMC, UINT uEscape, LPVOID lpData, LRESULT *plResult);

    /*
     * Local
     */
public:
    HRESULT GetProperty(DWORD* property, DWORD* conversion_caps, DWORD* sentence_caps, DWORD* SCSCaps, DWORD* UICaps)
    {
        *property =
        IME_PROP_KBD_CHAR_FIRST |    // This bit on indicates the system translates the character
                                     // by keyboard first. This character is passed to IME as aid
                                     // information. No aid information is provided when this bit
                                     // is off.
        IME_PROP_UNICODE |           // If set, the IME is viewed as a Unicode IME. The system and
                                     // the IME will communicate through the Unicode IME interface.
                                     // If clear, IME will use the ANSI interface to communicate
                                     // with the system.
        IME_PROP_AT_CARET |          // If set, conversion window is at the caret position.
                                     // If clear, the window is near caret position.
        IME_PROP_CANDLIST_START_FROM_1 |    // If set, strings in the candidate list are numbered
                                            // starting at 1. If clear, strings start at 0.
        IME_PROP_NEED_ALTKEY |              // This IME needs the ALT key to be passed to ImmProcessKey.
        IME_PROP_COMPLETE_ON_UNSELECT;      // Windows 98 and Windows 2000:
                                            // If set, the IME will complete the composition
                                            // string when the IME is deactivated.
                                            // If clear, the IME will cancel the composition
                                            // string when the IME is deactivated.
                                            // (for example, from a keyboard layout change).

        *conversion_caps =
        IME_CMODE_HANGUL |           // This bit on indicates IME is in HANGUL(NATIVE) mode. Otherwise, the
                                     // IME is in ALPHANUMERIC mode.
        IME_CMODE_FULLSHAPE;

        *sentence_caps = 0;

        *SCSCaps =
        SCS_CAP_COMPSTR;     // This IME can generate the composition string by SCS_SETSTR.
#if 0
        SCS_CAP_COMPSTR |    // This IME can generate the composition string by SCS_SETSTR.
        SCS_CAP_MAKEREAD |   // When calling ImmSetCompositionString with SCS_SETSTR, the IME can
                             // create the reading of composition string without lpRead. Under IME
                             // that has this capability, the application does not need to set
                             // lpRead for SCS_SETSTR.
        SCS_CAP_SETRECONVERTSTRING;    // This IME can support reconversion. Use ImmSetComposition
                                       // to do reconversion.
#endif

        *UICaps = UI_CAP_ROT90;

        return S_OK;
    }

private:
    HRESULT EscHanjaMode(UINT cp, HIMC hIMC, LPWSTR lpwStr, LRESULT* plResult);

};

#endif // _LANG_KOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\misc.cpp ===
//
// misc.c
//

#include "private.h"
#include "immif.h"
#pragma warning(disable: 4005)
#include <wingdip.h>

BYTE GetCharsetFromLangId(LCID lcid)
{
    CHARSETINFO csInfo;

    if (!TranslateCharsetInfo((DWORD *)(ULONG_PTR)lcid, &csInfo, TCI_SRCLOCALE))
        return DEFAULT_CHARSET;
    return (BYTE) csInfo.ciCharset;
}

UINT GetCodePageFromLangId(LCID lcid)
{
    TCHAR buf[8];   // maxmum may be six

    if (GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, buf, ARRAYSIZE(buf))) {
        return _ttoi(buf);
    }

    return CP_ACP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\mouse.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    mouse.h

Abstract:

    This file defines the CMouseSink Class.

Author:

Revision History:

Notes:

--*/

#ifndef _MOUSE_H_
#define _MOUSE_H_

#include "cime.h"

class ImmIfIME;

class CMouseSink
{
public:
    CMouseSink()
    {
        m_ref = 1;

        m_prgMouseSinks = NULL;
    }
    virtual ~CMouseSink()
    {
        if (m_prgMouseSinks)
        {
            delete m_prgMouseSinks;
            m_prgMouseSinks = NULL;
        }
    }

    BOOL Init()
    {
        Assert(!m_prgMouseSinks);
        m_prgMouseSinks = new CStructArray<GENERICSINK>;
        if (!m_prgMouseSinks)
            return FALSE;

        return TRUE;
    }
public:
    ULONG InternalAddRef(void);
    ULONG InternalRelease(void);

public:
    //
    // Mouse sink
    //
public:
    HRESULT AdviseMouseSink(HIMC hImc, ITfRangeACP* range, ITfMouseSink* pSink, DWORD* pdwCookie);
    HRESULT UnadviseMouseSink(DWORD dwCookie);

    LRESULT MsImeMouseHandler(ULONG uEdge, ULONG uQuadrant, ULONG dwBtnStatus, IMCLock& imc,
                              ImmIfIME* ImmIfIme);

public:
    CStructArray<GENERICSINK> *m_prgMouseSinks;

protected:
    long        m_ref;

};

#endif // _MOUSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\profile.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    profile.h

Abstract:

    This file defines the CActiveIMMProfiles Class.

Author:

Revision History:

Notes:

--*/

#ifndef _PROFILE_H
#define _PROFILE_H

#include "ats.h"
#include "template.h"
#include "imtls.h"

class CAImeProfile : public IAImeProfile
{
public:
    CAImeProfile();
    virtual ~CAImeProfile();

public:
    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IAImeProfile methods
    //
    STDMETHODIMP Activate(void);

    STDMETHODIMP Deactivate(void);

    STDMETHODIMP ChangeCurrentKeyboardLayout(HKL hKL);

    STDMETHODIMP GetLangId(LANGID *plid);

    STDMETHODIMP GetCodePageA(UINT* puCodePage);

    STDMETHODIMP GetKeyboardLayout(HKL* phkl);

    STDMETHODIMP IsIME(HKL hKL);

    STDMETHODIMP GetActiveLanguageProfile(IN HKL hKL,
                                          IN GUID catid,
                                          OUT TF_LANGUAGEPROFILE* pLanguageProfile);

public:
    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);

protected:
    long m_ref;

    ITfInputProcessorProfiles*         m_profile;
    CActiveLanguageProfileNotifySink*   m_pActiveLanguageProfileNotifySink;

    //
    // Callbacks
    //
    static HRESULT ActiveLanguageProfileNotifySinkCallback(REFGUID rguid, REFGUID rguidProfile, BOOL fActivated, void *pv);

    //
    // Enumrate callbacks
    //
    struct LANG_PROF_ENUM_ARG {
        IN GUID catid;
        OUT TF_LANGUAGEPROFILE LanguageProfile;
    };
    static ENUM_RET LanguageProfilesCallback(TF_LANGUAGEPROFILE  LanguageProfile,
                                             LANG_PROF_ENUM_ARG* pLangProfEnumArg);

private:
    LANGID LangIdFromKL(HKL hKL)
    {
        return LOWORD(hKL);
    }

    HRESULT InitProfileInstance();

    void ResetCache(void)
    {
        m_fInitCP     = FALSE;
        m_fInitLangID = FALSE;
        m_fInitHKL    = FALSE;
    }

private:
    LANGID  m_SavedLangId;

    BOOL    m_fActivateThread : 1;    // TRUE: Activate this thread.
    BOOL    m_fInitCP         : 1;    // TRUE: initialized CodePage value.
    BOOL    m_fInitLangID     : 1;    // TRUE: initialized LangID value.
    BOOL    m_fInitHKL        : 1;    // TRUE: initialized hKL value.

    UINT    m_cp;
    LANGID  m_LangID;
    HKL     m_hKL;

};

#endif // _PROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\reconvcb.cpp ===
//
// pkes.cpp
//

#include "private.h"
#include "reconvcb.h"
#include "a_context.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CStartReconversionNotifySink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfStartReconversionNotifySink))
    {
        *ppvObj = SAFECAST(this, CStartReconversionNotifySink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CStartReconversionNotifySink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CStartReconversionNotifySink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CStartReconversionNotifySink::CStartReconversionNotifySink(CAImeContext *pAImeContext)
{
    Dbg_MemSetThisName(TEXT("CStartReconversionNotifySink"));

    _cRef = 1;
    _pAImeContext = pAImeContext;
}

//+---------------------------------------------------------------------------
//
// CStartReconversionNotifySink::Advise
//
//----------------------------------------------------------------------------

HRESULT CStartReconversionNotifySink::_Advise(ITfContext *pic)
{
    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfStartReconversionNotifySink, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CStartReconversionNotifySink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CStartReconversionNotifySink::_Unadvise()
{
    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        goto Exit;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(_pic);
    return hr;
}

//+---------------------------------------------------------------------------
//
// StartReconversionNotifySink::StartReconversion
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::StartReconversion()
{
    _pAImeContext->SetupReconvertString();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// StartReconversionNotifySink::EndReconversion
//
//----------------------------------------------------------------------------

STDAPI CStartReconversionNotifySink::EndReconversion()
{
    _pAImeContext->EndReconvertString();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\reconvcb.h ===
//
// pkes.h
//
// Generic ITfPreservedKeyNotifySink object
//

#ifndef RECONVCB_H
#define RECONVCB_H

#include "private.h"

class CAImeContext;

class CStartReconversionNotifySink : public ITfStartReconversionNotifySink
{
public:
    CStartReconversionNotifySink(CAImeContext *pAImeContext);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfStartReconversionNotifySink
    //
    STDMETHODIMP StartReconversion();
    STDMETHODIMP EndReconversion();

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:
    long _cRef;
    ITfContext *_pic;
    CAImeContext *_pAImeContext;
    DWORD _dwCookie;
};

#endif // RECONVCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for AIMM1.2 project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#define NOIME
#include <windows.h>
#include <ole2.h>
#include <debug.h>
#include <ocidl.h>
#include <olectl.h>

#include <stdio.h>
#include <tchar.h>
#include <limits.h>
#include <initguid.h>

// New NT5 header
#include "immdev.h"
#define _IMM_
#define _DDKIMM_H_

#include "msctf.h"
#include "msctfp.h"
#include "osver.h"
#include "ico.h"
#include "tes.h"
#include "computil.h"
#include "timsink.h"
#include "sink.h"
#include "dispattr.h"
#include "ccstock.h"
#include "helpers.h"
#include "immxutil.h"
#include "xstring.h"
#include "regsvr.h"
#include "tsattrs.h"

#define _DDKIMM_H_
#include "aimm12.h"
#include "aimmp.h"
#include "aimmex.h"
#include "msuimw32.h"


#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof(x)/sizeof(x)[0])
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    ARRAY_SIZE(x)
#endif

#if defined(_DEBUG) || defined(DEBUG)
#define DBG 1
#endif

#include "mem.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\mouse.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    mouse.cpp

Abstract:

    This file implements the mouse sink in the ImmIfIME Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "mouse.h"
#include "template.h"
#include "immif.h"
#include "editses.h"
#include "sink.h"
#include "imeapp.h"

ULONG
CMouseSink::InternalAddRef(
    )
{
    return ++m_ref;
}

ULONG
CMouseSink::InternalRelease(
    )
{
    ULONG cr = --m_ref;

    if (cr == 0) {
        delete this;
    }

    return cr;
}


HRESULT
CMouseSink::AdviseMouseSink(
    HIMC hImc,
    ITfRangeACP* range,
    ITfMouseSink* pSink,
    DWORD* pdwCookie
    )
{
    if (m_prgMouseSinks == NULL)
        return E_FAIL;

    const IID *rgiid = &IID_ITfMouseSink;
    GENERICSINK *pgs;
    HRESULT hr;

    hr = GenericAdviseSink(IID_ITfMouseSink, pSink, &rgiid, m_prgMouseSinks, 1, pdwCookie, &pgs);
    if (hr == S_OK) {
        pgs->uPrivate = (UINT_PTR) new tagPRIVATE_MOUSESINK;
        if (pgs->uPrivate) {
            ((LPPRIVATE_MOUSESINK)pgs->uPrivate)->range.Attach(range);
            range->AddRef();
            ((LPPRIVATE_MOUSESINK)pgs->uPrivate)->hImc  = hImc;
        }
    }

    return hr;
}

HRESULT
CMouseSink::UnadviseMouseSink(
    DWORD dwCookie
    )
{
    if (m_prgMouseSinks == NULL)
        return E_FAIL;

    HRESULT hr;
    LPPRIVATE_MOUSESINK pPrivMouseSink = NULL;

    hr = GenericUnadviseSink(m_prgMouseSinks, 1, dwCookie, (UINT_PTR *)&pPrivMouseSink);
    if (hr == S_OK) {
        if (pPrivMouseSink) {
            delete pPrivMouseSink;
        }
    }

    return hr;
}

LRESULT
CMouseSink::MsImeMouseHandler(
    ULONG uEdge,
    ULONG uQuadrant,
    ULONG dwBtnStatus,
    IMCLock& imc,
    ImmIfIME* ImmIfIme
    )
{
    LONG acpStart;
    LONG cch;
    ULONG uRangeEdgeMin;
    ULONG uRangeEdgeMax;
    HRESULT hr;

    /*
     * Find out specified range in whole text's range
     */
    BOOL fEaten = FALSE;

    for (int i = 0; i < m_prgMouseSinks->Count(); i++) {
        GENERICSINK* pgs;
        LPPRIVATE_MOUSESINK pPrivMouseSink;

        pgs = m_prgMouseSinks->GetPtr(i);
        pPrivMouseSink = (LPPRIVATE_MOUSESINK)pgs->uPrivate;

        if ((HIMC)imc != pPrivMouseSink->hImc)
            continue;

        // test: does this sink cover the specified edge?

        pPrivMouseSink->range->GetExtent(&acpStart, &cch);

        uRangeEdgeMin = acpStart;
        uRangeEdgeMax = acpStart + cch;

        //
        // Get GUID_PROP_MSIMTF_READONLY margin.
        //
        Interface_Creator<ImmIfEditSession> _pEditSession(
            new ImmIfEditSession(ESCB_GET_READONLY_PROP_MARGIN,
                                 ImmIfIme->GetClientId(),
                                 ImmIfIme->GetCurrentInterface(),
                                 imc)
        );
        if (_pEditSession.Valid())
        {
            if (SUCCEEDED(_pEditSession->RequestEditSession(TF_ES_READWRITE | TF_ES_SYNC,
                                                       &pPrivMouseSink->range, &cch)))
            {
                uEdge += cch;
            }
        }

        if (uEdge < uRangeEdgeMin)
            continue;
        if (uEdge == uRangeEdgeMin && uQuadrant < 2)
            continue;

        if (uEdge > uRangeEdgeMax)
            continue;
        if (uEdge == uRangeEdgeMax && uQuadrant > 1)
            continue;

        //
        // Call OnMouseEvent
        //
        hr = ((ITfMouseSink*)pgs->pSink)->OnMouseEvent(uEdge - uRangeEdgeMin /* adjust uEdge for this range's frame of reference */,
                                                       uQuadrant, dwBtnStatus, &fEaten);

        if (hr == S_OK && fEaten)
            return 1L;

        break; // we already found a covered range, don't bother querying any others
    }

    return IMEMOUSERET_NOTHANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\profile.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    profile.cpp

Abstract:

    This file implements the CActiveIMMProfiles Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "globals.h"
#include "profile.h"
#include "idebug.h"

UINT WINAPI RawImmGetDescriptionA(HKL hkl, LPSTR lpstr, UINT uBufLen);

//
// Callbacks
//
HRESULT
CAImeProfile::ActiveLanguageProfileNotifySinkCallback(
    REFGUID rguid,
    REFGUID rguidProfile,
    BOOL fActivated,
    void *pv
    )
{
    DebugMsg(TF_FUNC, "ActiveLanguageProfileNotifySinkCallback");

    CAImeProfile* _this = (CAImeProfile*)pv;

    _this->ResetCache();

    return S_OK;
}

//
// Create instance
//

// entry point for msimtf.dll
HRESULT CAImmProfile_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    return CAImeProfile::CreateInstance(pUnkOuter, riid, ppvObj);
}

/* static */
HRESULT
CAImeProfile::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    IMTLS *ptls;

    DebugMsg(TF_FUNC, "CAImeProfile::CreateInstance called.");

    *ppvObj = NULL;
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (ptls->pAImeProfile != NULL) {
        /*
         * CAImeProfile instance already have in a thread.
         */
        return ptls->pAImeProfile->QueryInterface(riid, ppvObj);
    }
    else {
        /*
         * Create an new CAImeProfile instance.
         */
        CAImeProfile* pImeProfile = new CAImeProfile;
        if (pImeProfile) {
            HRESULT hr = pImeProfile->QueryInterface(riid, ppvObj);

            if (SUCCEEDED(hr)) {
                hr = pImeProfile->InitProfileInstance();
                if (hr != S_OK) {
                    DebugMsg(TF_ERROR, "CAImeProfile::CreateInstance: Couldn't create tim!");
                    Assert(0); // couldn't create tim!
                }

                pImeProfile->Release();
            }

            Assert(ptls->pAImeProfile == NULL);
            ptls->pAImeProfile = pImeProfile;    // Set CAImeProfile instance in the TLS data.
            ptls->pAImeProfile->AddRef();

            return hr;
        }
    }

    return E_OUTOFMEMORY;
}

//
// Initialization, destruction and standard COM stuff
//

CAImeProfile::CAImeProfile(
    )
{
    DllAddRef();
    m_ref = 1;

    m_profile = NULL;
    m_pActiveLanguageProfileNotifySink = NULL;

    m_SavedLangId       = LANG_NEUTRAL;

    m_fActivateThread   = FALSE;
    ResetCache();

    m_cp     = CP_ACP;
    m_LangID = LANG_NEUTRAL;
    m_hKL    = 0;
}

CAImeProfile::~CAImeProfile()
{
    if (m_profile) {
        if (m_SavedLangId != LANG_NEUTRAL) {
            HRESULT hr = m_profile->ChangeCurrentLanguage(m_SavedLangId);
            if (FAILED(hr)) {
                TraceMsg(TF_ERROR, "CAImeProfile::~CAImeProfile: failed for ChangeCurrentLanguage");
            }
        }
        m_profile->Release();
        m_profile = NULL;
    }

    if (m_pActiveLanguageProfileNotifySink) {
        m_pActiveLanguageProfileNotifySink->_Unadvise();
        m_pActiveLanguageProfileNotifySink->Release();
        m_pActiveLanguageProfileNotifySink = NULL;
    }

    DllRelease();
}

HRESULT
CAImeProfile::QueryInterface(
    REFIID riid,
    void **ppvObj
    )
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IAImeProfile) ||
        IsEqualIID(riid, IID_IUnknown)) {
        *ppvObj = static_cast<IAImeProfile*>(this);
    }

    if (*ppvObj) {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG
CAImeProfile::AddRef(
    )
{
    return InterlockedIncrement(&m_ref);
}

ULONG
CAImeProfile::Release(
    )
{
    ULONG cr = InterlockedDecrement(&m_ref);

    if (cr == 0) {
        delete this;
    }

    return cr;
}

HRESULT
CAImeProfile::InitProfileInstance(
    )
{
    HRESULT hr;
    IMTLS *ptls;

    hr = TF_CreateInputProcessorProfiles(&m_profile);

    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CAImeProfile::InitProfileInstance: failed for CoCreate");
    }
    else if (m_pActiveLanguageProfileNotifySink == NULL) {
        m_pActiveLanguageProfileNotifySink = new CActiveLanguageProfileNotifySink(CAImeProfile::ActiveLanguageProfileNotifySinkCallback, this);
        if (m_pActiveLanguageProfileNotifySink == NULL) {
            DebugMsg(TF_ERROR, "Couldn't create ActiveLanguageProfileNotifySink!");

            m_profile->Release();
            m_profile = NULL;
            return E_FAIL;
        }

        if ((ptls = IMTLS_GetOrAlloc()) && ptls->tim != NULL)
        {
            m_pActiveLanguageProfileNotifySink->_Advise(ptls->tim);
        }
    }

    return hr;
}

HRESULT
CAImeProfile::Activate(
    void
    )
{
    m_fActivateThread   = TRUE;
    ResetCache();
    return S_OK;
}

HRESULT
CAImeProfile::Deactivate(
    void
    )
{
    m_fActivateThread   = FALSE;
    return S_OK;
}


HRESULT
CAImeProfile::ChangeCurrentKeyboardLayout(
    HKL hKL
    )
{
    HRESULT hr;

    LANGID CurrentLangId;
    hr = m_profile->GetCurrentLanguage(&CurrentLangId);
    if (FAILED(hr)) {
        TraceMsg(TF_ERROR, "CAImeProfile::ChangeCurrentKeyboardLayout: failed for GetCurrentLanguage");
    }
    else if (hKL != NULL) {
        LANGID LangId = LangIdFromKL(hKL);
        if (LangId != CurrentLangId) {
            hr = m_profile->ChangeCurrentLanguage(LangId);
            if (FAILED(hr)) {
                m_SavedLangId = LANG_NEUTRAL;
                TraceMsg(TF_ERROR, "CAImeProfile::ChangeCurrentKeyboardLayout: failed for ChangeCurrentLanguage");
            }
            m_SavedLangId = LangId;
        }
    }
    return hr;
}

HRESULT 
CAImeProfile::GetLangId(
    LANGID *plid
    )
{
    if (!m_profile)
        return E_FAIL;

    if (!plid)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    if (m_fInitLangID) {
        *plid = m_LangID;
    }
    else {
        *plid = LANG_NEUTRAL;

        hr = m_profile->GetCurrentLanguage(plid);
        if (FAILED(hr)) {
            TraceMsg(TF_ERROR, "CAImeProfile::GetLangId: failed for GetCurrentLanguage");
        }
        else {
            m_LangID = *plid;
            m_fInitLangID = TRUE;
        }
    }

    return hr;
}

HRESULT 
CAImeProfile::GetCodePageA(
    UINT *puCodePage
    )
{
    if (!puCodePage)
        return E_INVALIDARG;

    if (m_fInitCP) {
        *puCodePage = m_cp;
    }
    else {
        *puCodePage = CP_ACP;

        LANGID langid;
        if (FAILED(GetLangId(&langid)))
            return E_FAIL;

        CHAR szCodePage[12];
        int ret = GetLocaleInfo(MAKELCID(langid, SORT_DEFAULT),
                                LOCALE_IDEFAULTANSICODEPAGE,
                                szCodePage,
                                sizeof(szCodePage));
        if (ret) {
            szCodePage[ARRAYSIZE(szCodePage)-1] = '\0';
            *puCodePage = strtoul(szCodePage, NULL, 10);
            m_cp = *puCodePage;
            m_fInitCP = TRUE;
        }
    }
    return S_OK;
}

#if 1
//
// TEST CODE
//
    #include "osver.h"

    extern HINSTANCE hIMM;   // temporary: do not call IMM32 for now

    BOOL IsIMEHKL(HKL hkl) {
       return ((((DWORD)(UINT_PTR)hkl) & 0xf0000000) == 0xe0000000) ? TRUE : FALSE;
    }
#endif

HRESULT 
CAImeProfile::GetKeyboardLayout(
    HKL* phkl
    )
{
    if (! phkl)
        return E_INVALIDARG;

    *phkl = NULL;

    if (m_fInitHKL) {
        *phkl = m_hKL;
    }
    else if (! m_fActivateThread) {
        return E_FAIL;
    }
    else {
        LANGID langid;
        GUID guidProfile;
        HRESULT hr = m_profile->GetActiveLanguageProfile(GUID_TFCAT_TIP_KEYBOARD,
                                                         &langid,
                                                         &guidProfile);
        if (FAILED(hr))
            return hr;

        //
        // Instead of (!IsEqualGUID(guidProfil, GUID_NULL)), we check
        // 2nd, 3r and 4th DWORD of guidProfile. Because
        // GetActivelanguageProfile(category guid) may return hKL in 
        // guidProfile
        //
        if ((((unsigned long *) &guidProfile)[1] != 0) ||
            (((unsigned long *) &guidProfile)[2] != 0) ||
            (((unsigned long *) &guidProfile)[3] != 0)) {
            /*
             * Current keyboard layout is Cicero.
             */
            m_hKL = (HKL)LongToHandle(langid);          // Don't use ::GetKeyboardLayout(0);
                                                        // Cicero awre doesn't case hKL.

#if 1
            //
            // check the dummy hkl
            //
            HKL fake_hKL = ::GetKeyboardLayout(0);
            if (IsIMEHKL(fake_hKL)) {
                //
                // fake hKL is IME hKL.
                //
                hIMM = GetSystemModuleHandle("imm32.dll");
                if (hIMM != NULL) {
                    char szDesc[256];
                    char szDumbDesc[256];

                    DWORD ret = RawImmGetDescriptionA(fake_hKL, szDesc, sizeof(szDesc));
                    if (ret != 0) {
                        wsprintf(szDumbDesc, "hkl%04x", LOWORD((UINT_PTR)fake_hKL));
                        if (lstrcmp(szDumbDesc, szDesc) != 0) {
                            //
                            // fake hKL is regacy IME hKL.
                            //
                            if (IsOnNT()) {
                                char szKLID[256];

                                wsprintf(szKLID, "%08x", LOWORD((UINT_PTR) m_hKL));
                                HKL win32_hKL = LoadKeyboardLayout(szKLID, KLF_NOTELLSHELL);
                            }
                            else {
                            }
                        }
                        else {
                            //
                            // Dummy Cicero hKL for Win9x.
                            //
                            UINT n = GetKeyboardLayoutList(0, NULL);
                            if (n) {
                                HKL* phKL = new HKL [n];
                                if (phKL) {
                                    HKL* p = phKL;

                                    GetKeyboardLayoutList(n, phKL);

                                    while (n--) {
                                        if (IsIMEHKL(*p)) {
                                            ret = RawImmGetDescriptionA(*p, szDesc, sizeof(szDesc));
                                            if (ret != 0) {
                                                wsprintf(szDumbDesc, "hkl%04x", LOWORD((UINT_PTR)*p));
                                                if (lstrcmp(szDumbDesc, szDesc) == 0) {
                                                    //
                                                    // Dummy Cicero hKL for Win9x.
                                                    //
                                                    char szKLID[256];

                                                    wsprintf(szKLID, "%08x", LOWORD((UINT_PTR) *p));
                                                    HKL win32_hKL = LoadKeyboardLayout(szKLID, KLF_NOTELLSHELL);
                                                    break;
                                                }
                                            }
                                        }

                                        p++;
                                    }

                                    delete [] phKL;
                                }
                            }
                        }
                    }

                    FreeLibrary(hIMM);
                    hIMM = NULL;
                }
            }
#endif
        }
        else if (!IsEqualGUID(guidProfile, GUID_NULL)) {
            /*
             * Current keyboard layout is regacy IME.
             */
            m_hKL = (HKL)LongToHandle(*(DWORD *)&guidProfile);
        }
        else {
            m_hKL = 0;
        }

        *phkl = m_hKL;
        m_fInitHKL = TRUE;
    }
    return S_OK;
}

HRESULT 
CAImeProfile::IsIME(
    HKL hKL
    )
{
    LANGID LangId = LangIdFromKL(hKL);

    Interface<IEnumTfLanguageProfiles> LanguageProfiles;
    HRESULT hr = m_profile->EnumLanguageProfiles(LangId, 
                                                 LanguageProfiles);
    if (FAILED(hr))
        return S_FALSE;

    CEnumrateValue<IEnumTfLanguageProfiles,
                   TF_LANGUAGEPROFILE,
                   LANG_PROF_ENUM_ARG> Enumrate(LanguageProfiles,
                                                LanguageProfilesCallback);

    ENUM_RET ret = Enumrate.DoEnumrate();
    if (ret != ENUM_FIND)
        return S_FALSE;
    else
        return S_OK;
}

HRESULT
CAImeProfile::GetActiveLanguageProfile(
    IN HKL hKL,
    IN GUID catid,
    OUT TF_LANGUAGEPROFILE* pLanguageProfile
    )
{
    LANGID LangId = LangIdFromKL(hKL);

    Interface<IEnumTfLanguageProfiles> LanguageProfiles;
    HRESULT hr = m_profile->EnumLanguageProfiles(LangId, 
                                                 LanguageProfiles);
    if (FAILED(hr))
        return S_FALSE;

    LANG_PROF_ENUM_ARG LangProfEnumArg;
    LangProfEnumArg.catid = catid;

    CEnumrateValue<IEnumTfLanguageProfiles,
                   TF_LANGUAGEPROFILE,
                   LANG_PROF_ENUM_ARG> Enumrate(LanguageProfiles,
                                                LanguageProfilesCallback,
                                                &LangProfEnumArg);

    ENUM_RET ret = Enumrate.DoEnumrate();
    if (ret != ENUM_FIND || pLanguageProfile == NULL)
        return S_FALSE;
    else {
        *pLanguageProfile = LangProfEnumArg.LanguageProfile;
        return S_OK;
    }
}

ENUM_RET
CAImeProfile::LanguageProfilesCallback(
    TF_LANGUAGEPROFILE   LanguageProfile,
    LANG_PROF_ENUM_ARG* pLangProfEnumArg
    )
{
    if (LanguageProfile.fActive &&
        ! IsEqualGUID(LanguageProfile.clsid, GUID_NULL)) {
        if (pLangProfEnumArg) {
            if (! IsEqualGUID(LanguageProfile.catid, pLangProfEnumArg->catid)) {
                return ENUM_CONTINUE;
            }
            pLangProfEnumArg->LanguageProfile = LanguageProfile;
        }
        return ENUM_FIND;
    }

    return ENUM_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\tmgrevcb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    tmgrevcb.h

Abstract:

    This file defines the CThreadMgrEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TMGREVCB_H_
#define _TMGREVCB_H_


class CThreadMgrEventSinkCallBack : public CThreadMgrEventSink
{
public:
    CThreadMgrEventSinkCallBack() : CThreadMgrEventSink(NULL, ThreadMgrEventSinkCallback, NULL) {};

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    //
    // Callbacks
    //
private:
    static HRESULT ThreadMgrEventSinkCallback(UINT uCode, ITfContext* pic, void* pv);

};

#endif // _TMGREVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\tmgrevcb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    tmgrevcb.cpp

Abstract:

    This file implements the CInputContextOwnerCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "tmgrevcb.h"
#include "cime.h"
#include "imtls.h"

// static
HRESULT
CThreadMgrEventSinkCallBack::ThreadMgrEventSinkCallback(
    UINT uCode,
    ITfContext* pic,
    void* pv
    )
{
    DebugMsg(TF_FUNC, "ThreadMgrEventSinkCallback");

    IMTLS *ptls;
    HRESULT hr = S_OK;

    switch (uCode) {
        case TIM_CODE_INITIC:
        case TIM_CODE_UNINITIC:
            {
                if ((ptls = IMTLS_GetOrAlloc()) == NULL)
                    break;

                IMCLock imc(ptls->hIMC);
                if (SUCCEEDED(hr=imc.GetResult())) {
                    if (! ptls->m_fMyPushPop) {
                        SendMessage(imc->hWnd, WM_IME_NOTIFY,
                                    (uCode == TIM_CODE_INITIC) ? IMN_OPENCANDIDATE : IMN_CLOSECANDIDATE, 1L);
                    }
                }
            }
            break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\crtfree.cpp ===
#include "private.h"

#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\uiwndhd.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwndhd.h

Abstract:

    This file defines the IME UI window handler Class.

Author:

Revision History:

Notes:

--*/

#ifndef _UIWNDHD_H_
#define _UIWNDHD_H_

#include "globals.h"
#include "imtls.h"

extern LPCTSTR IMEUIWndHandlerName;

class CIMEUIWindowHandler
{
public:
    CIMEUIWindowHandler(HWND hwnd = NULL);

    LRESULT ImeUIWndProcWorker(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode = TRUE);

private:
    LRESULT UIWndCreateHandler(LPCREATESTRUCT lpcs);
    VOID    UIWndDestroyHandler();
    VOID    UIWndFinalDestroyHandler();

    LRESULT ImeUINotifyHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
    LRESULT ImeUISelectHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

    LRESULT ImeUIMsImeHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
    LRESULT ImeUIMsImeMouseHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);
    LRESULT ImeUIMsImeModeBiasHandler(WPARAM wParam, LPARAM lParam);

    BOOL IsMsImeMessage(UINT uMsg)
    {
        if (uMsg == WM_MSIME_SERVICE ||
            uMsg == WM_MSIME_UIREADY ||
            uMsg == WM_MSIME_RECONVERTREQUEST ||
            uMsg == WM_MSIME_RECONVERT ||
            uMsg == WM_MSIME_DOCUMENTFEED ||
            uMsg == WM_MSIME_QUERYPOSITION ||
            uMsg == WM_MSIME_MODEBIAS ||
            uMsg == WM_MSIME_SHOWIMEPAD ||
            uMsg == WM_MSIME_MOUSE ||
            uMsg == WM_MSIME_KEYMAP)
            return TRUE;
        else
            return FALSE;
    }

    LRESULT ImeUIPrivateHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL fUnicode);

    BOOL IsPrivateMessage(UINT uMsg)
    {
        IMTLS *ptls = IMTLS_GetOrAlloc();

        if (ptls == NULL)
            return FALSE;

        if (uMsg == ptls->prvUIWndMsg.uMsgOnLayoutChange ||
            uMsg == ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer)
            return TRUE;
        else
            return FALSE;
    }

private:
    static BOOL EnumUnSelectCallback(HIMC hIMC, LPARAM lParam);

private:
    typedef struct tagUIEXTRA {
        HWND  hImeUIWnd;
    } UIEXTRA;
    UIEXTRA      m_imeuiextra;

};


CIMEUIWindowHandler* GetImeUIWndHandler(HWND hwnd);


#endif // _UIWNDHD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\ui.cpp ===
#include "private.h"

#include "imedefs.h"
#include "uiwndhd.h"


/**********************************************************************/
/*                                                                    */
/* UIWndProc()                                                        */
/*                                                                    */
/* IME UI window procedure                                            */
/*                                                                    */
/**********************************************************************/

LRESULT CALLBACK
UIWndProcA(
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CIMEUIWindowHandler* pimeui = GetImeUIWndHandler(hUIWnd);
    return pimeui->ImeUIWndProcWorker(uMsg, wParam, lParam, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\txtevcb.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    txtevcb.h

Abstract:

    This file defines the CTextEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/

#ifndef _TXTEVCB_H_
#define _TXTEVCB_H_

class ImmIfIME;

class CTextEventSinkCallBack : public CTextEventSink
{
public:
    CTextEventSinkCallBack(ImmIfIME* pImmIfIME, HIMC hIMC);
    virtual ~CTextEventSinkCallBack();

    void SetCallbackDataPointer(void* pv)
    {
        SetCallbackPV(pv);
    };

    BOOL _IsSapiFeedbackUIPresent(Interface_Attach<ITfContext>& ic, TESENDEDIT *ee);

    //
    // Callbacks
    //
private:
    static HRESULT TextEventSinkCallback(UINT uCode, void *pv, void *pvData);

    typedef struct _EnumROPropertyArgs
    {
        Interface<ITfProperty> Property;
        TfEditCookie ec;
        GUID         comp_guid;
        LIBTHREAD    *pLibTLS;
    } EnumROPropertyArgs;

    //
    // Enumrate callbacks
    //
    typedef struct _EnumPropertyUpdateArgs
    {
        _EnumPropertyUpdateArgs(ITfContext* pv, ImmIfIME* p1, IMCLock& p2) : ic(pv), immif(p1), imc(p2) { }

        Interface<ITfProperty> Property;
        TfEditCookie           ec;
        Interface_Attach<ITfContext> ic;
        ImmIfIME*              immif;
        IMCLock&               imc;
        DWORD                  dwDeltaStart;
    } EnumPropertyUpdateArgs;
    static ENUM_RET EnumReadOnlyRangeCallback(ITfRange* pRange, EnumROPropertyArgs *pargs);

    //
    // Enumrate property update
    //
    static ENUM_RET EnumPropertyUpdateCallback(ITfRange* update_range, EnumPropertyUpdateArgs *pargs);

    ImmIfIME     *m_pImmIfIME;
    HIMC         m_hIMC;
};

#endif // _TXTEVCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\txtevcb.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    txtevcb.cpp

Abstract:

    This file implements the CTextEventSinkCallBack Class.

Author:

Revision History:

Notes:

--*/


#include "private.h"

#include "cime.h"
#include "txtevcb.h"
#include "immif.h"
#include "editses.h"


// from ctf\sapilayr\globals.cpp
const GUID GUID_ATTR_SAPI_GREENBAR =
{
    0xc3a9e2e8,
    0x738c,
    0x48e0,
    {0xac, 0xc8, 0x43, 0xee, 0xfa, 0xbf, 0x83, 0xc8}
};

BOOL CTextEventSinkCallBack::_IsSapiFeedbackUIPresent(
    Interface_Attach<ITfContext>& ic,
    TESENDEDIT *ee
    )
{
    EnumROPropertyArgs args;

    args.comp_guid = GUID_ATTR_SAPI_GREENBAR;
    if (FAILED(ic->GetProperty(GUID_PROP_ATTRIBUTE, args.Property)))
        return FALSE;

    Interface<IEnumTfRanges> EnumReadOnlyProperty;
    if (FAILED(args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, NULL)))
        return FALSE;

    args.ec = ee->ecReadOnly;
    args.pLibTLS = m_pImmIfIME->_GetLibTLS();

    CEnumrateInterface<IEnumTfRanges,
                       ITfRange,
                       EnumROPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                     EnumReadOnlyRangeCallback,
                                                     &args);        // Argument of callback func.
    ENUM_RET ret_prop_attribute = Enumrate.DoEnumrate();
    if (ret_prop_attribute == ENUM_FIND)
        return TRUE;

    return FALSE;
}

// static
HRESULT
CTextEventSinkCallBack::TextEventSinkCallback(
    UINT uCode,
    void *pv,
    void *pvData
    )
{
    IMTLS *ptls;

    DebugMsg(TF_FUNC, "TextEventSinkCallback");

    ASSERT(uCode == ICF_TEXTDELTA); // the pvData cast only works in this case
    if (uCode != ICF_TEXTDELTA)
        return S_OK;

    CTextEventSinkCallBack* _this = (CTextEventSinkCallBack*)pv;
    ASSERT(_this);

    ImmIfIME* _ImmIfIME = _this->m_pImmIfIME;
    ASSERT(_ImmIfIME);

    TESENDEDIT* ee = (TESENDEDIT*)pvData;
    ASSERT(ee);

    HRESULT hr;

    IMCLock imc(_this->m_hIMC);
    if (FAILED(hr = imc.GetResult()))
        return hr;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return E_FAIL;

    ASSERT(_pAImeContext != NULL);

#ifdef UNSELECTCHECK
    if (!_pAImeContext->m_fSelected)
        return S_OK;
#endif UNSELECTCHECK

    Interface_Attach<ITfContext> ic(_pAImeContext->GetInputContext());

#if 0
    //
    // What we want to do here is a check of reentrancy of this event sink.
    //
    BOOL fInWrite;
    if (FAILED(hr = ic->InWriteSession(_ImmIfIME->GetClientId(), &fInWrite)))
         return hr;

    Assert(!fInWrite);
#endif

    BOOL     fLangEA       = TRUE;
    BOOL     fComp         = TRUE;
    BOOL     fSapiFeedback = TRUE;

    /*
     * if EA language, then we have composition text.
     */

    if ((ptls = IMTLS_GetOrAlloc()) == NULL)
        return E_FAIL;
    
    LANGID langid;
    ptls->pAImeProfile->GetLangId(&langid);
    if (PRIMARYLANGID(langid) == LANG_JAPANESE ||
        PRIMARYLANGID(langid) == LANG_KOREAN   ||
        PRIMARYLANGID(langid) == LANG_CHINESE    ) {

        // need to check speech feedback UI for these lang too
        BOOL fFeedback = _this->_IsSapiFeedbackUIPresent(ic, ee);

        /*
         * This is automatic detection code of the Hangul + alphanumeric input
         * If detected a Hangul + alphanumeric, then we finalized all text.
         */
        EnumROPropertyArgs args;
        args.comp_guid = GUID_NULL;
        if (FAILED(hr=ic->GetProperty(GUID_PROP_COMPOSING, args.Property)))
            return hr;

        Interface<IEnumTfRanges> EnumReadOnlyProperty;
        hr = args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, NULL);
        if (FAILED(hr))
            return hr;

        args.ec = ee->ecReadOnly;
        args.pLibTLS = _ImmIfIME->_GetLibTLS();

        CEnumrateInterface<IEnumTfRanges,
                           ITfRange,
                           EnumROPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                         EnumReadOnlyRangeCallback,
                                                         &args);        // Argument of callback func.
        ENUM_RET ret_prop_composing = Enumrate.DoEnumrate();
        if (!fFeedback && ret_prop_composing != ENUM_FIND)
            fComp = FALSE;
    }
    else {
        /*
         * if not EA language and not SAPI, then we immediately finalize the text.
         */

        fLangEA = FALSE;

        EnumROPropertyArgs args;
        args.comp_guid = GUID_ATTR_SAPI_GREENBAR;
        if (FAILED(hr=ic->GetProperty(GUID_PROP_ATTRIBUTE, args.Property)))
            return hr;

        Interface<IEnumTfRanges> EnumReadOnlyProperty;
        hr = args.Property->EnumRanges(ee->ecReadOnly, EnumReadOnlyProperty, NULL);
        if (FAILED(hr))
            return hr;

        args.ec = ee->ecReadOnly;
        args.pLibTLS = _ImmIfIME->_GetLibTLS();

        CEnumrateInterface<IEnumTfRanges,
                           ITfRange,
                           EnumROPropertyArgs>  Enumrate(EnumReadOnlyProperty,
                                                         EnumReadOnlyRangeCallback,
                                                         &args);        // Argument of callback func.
        ENUM_RET ret_prop_attribute = Enumrate.DoEnumrate();
        if (ret_prop_attribute != ENUM_FIND)
            fSapiFeedback = FALSE;
    }

    //
    // Update composition and generate WM_IME_COMPOSITION
    //
    //    if EA lang and there is composition property range.
    //        - EA has a hIMC composition by default.
    //
    //    if non EA lang and there is SAPI green bar.
    //        - there is only hIMC composition if there is Speech Green bar.
    //
    //    if Reconversion just started.
    //        - because some tip may not change the text yet.
    //          then there is no composition range yet.
    //
    //    if now clearing DocFeed buffer.
    //        - because the change happens in read-only text
    //          nothing in hIMC changes.
    //
    if ((fLangEA && fComp) || 
        (!fLangEA && fSapiFeedback) ||
        _pAImeContext->IsInReconvertEditSession() ||
        _pAImeContext->IsInClearDocFeedEditSession())
    {
        //
        // Retreive text delta
        //
        const GUID guid = GUID_PROP_COMPOSING;
        const GUID *pguid = &guid;

        Interface<IEnumTfRanges> EnumPropertyUpdate;
        hr = ee->pEditRecord->GetTextAndPropertyUpdates(0,          // dwFlags
                                                        &pguid, 1,
                                                        EnumPropertyUpdate);
        if (SUCCEEDED(hr)) {
            EnumPropertyUpdateArgs args(ic.GetPtr(), _ImmIfIME, imc);

            if (FAILED(hr=ic->GetProperty(GUID_PROP_COMPOSING, args.Property)))
                return hr;

            args.ec = ee->ecReadOnly;
            args.dwDeltaStart = 0;

            CEnumrateInterface<IEnumTfRanges,
                               ITfRange,
                               EnumPropertyUpdateArgs> Enumrate(EnumPropertyUpdate,
                                                                EnumPropertyUpdateCallback,
                                                                &args);        // Argument of callback func.
            ENUM_RET ret_prop_update = Enumrate.DoEnumrate();
            if (ret_prop_update == ENUM_FIND) {
                //
                // Update composition string with delta start position
                //
                return _ImmIfIME->_UpdateCompositionString(args.dwDeltaStart);
            }
        }

        //
        // Update composition string
        //
        return _ImmIfIME->_UpdateCompositionString();
    }
    else {
#if 0
        //
        // Review: 
        //  
        //   need to be reviewed by Matsubara-san.
        //   Why we need this? We can not assume tip always set the new 
        //   selection.
        //
        BOOL fChanged;
        hr = ee->pEditRecord->GetSelectionStatus(&fChanged);
        if (FAILED(hr))
            return hr;

        if (! fChanged)
            /*
             * If no change selection status, then return it.
             */
            return S_FALSE;

#endif
        //
        // Clear DocFeed range's text store.
        // Find GUID_PROP_MSIMTF_READONLY property and SetText(NULL).
        //
        // ImmIfIME::ClearDocFeedBuffer() essential function for all ESCB_RECONVERTSTRING's edit
        // session except only ImmIfIME::SetupDocFeedString() since this is provided for keyboard
        // TIP's DocFeeding.
        //
        _ImmIfIME->ClearDocFeedBuffer(_pAImeContext->GetInputContext(), imc, FALSE);  // No TF_ES_SYNC
        //
        // Composition complete.
        //
        return _ImmIfIME->_CompComplete(imc, FALSE);    //  No TF_ES_SYNC
    }
}

// static
ENUM_RET
CTextEventSinkCallBack::EnumReadOnlyRangeCallback(
    ITfRange* pRange,
    EnumROPropertyArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, pRange, &var);
    if (SUCCEEDED(hr)) {
        if (IsEqualIID(pargs->comp_guid, GUID_NULL)) {
            if ((V_VT(&var) == VT_I4 && V_I4(&var) != 0))
                ret = ENUM_FIND;
        }
        else if (V_VT(&var) == VT_I4) {
            TfGuidAtom guid = V_I4(&var);
            if (IsEqualTFGUIDATOM(pargs->pLibTLS, guid, pargs->comp_guid))
                ret = ENUM_FIND;
        }
    }

    VariantClear(&var);
    return ret;
}


// static
ENUM_RET
CTextEventSinkCallBack::EnumPropertyUpdateCallback(
    ITfRange* update_range,
    EnumPropertyUpdateArgs *pargs
    )
{
    ENUM_RET ret = ENUM_CONTINUE;
    VARIANT var;
    QuickVariantInit(&var);

    HRESULT hr = pargs->Property->GetValue(pargs->ec, update_range, &var);
    if (SUCCEEDED(hr)) {
        if ((V_VT(&var) == VT_I4 && V_I4(&var) != 0)) {

            Interface_Creator<ImmIfEditSession> _pEditSession(
                new ImmIfEditSession(ESCB_GET_ALL_TEXT_RANGE,
                                     pargs->immif->GetClientId(),
                                     pargs->immif->GetCurrentInterface(),
                                     pargs->imc)
            );
            if (_pEditSession.Valid()) {

                Interface<ITfRange> full_range;

                if (SUCCEEDED(_pEditSession->RequestEditSession(TF_ES_READ | TF_ES_SYNC,
                                                           &full_range))) {

                    if (SUCCEEDED(full_range->ShiftEndToRange(pargs->ec, update_range, TF_ANCHOR_START))) {
                        Interface<ITfRangeACP> unupdate_range;
                        if (SUCCEEDED(full_range->QueryInterface(IID_ITfRangeACP, unupdate_range))) {
                            LONG acpStart;
                            LONG cch;
                            if (SUCCEEDED(unupdate_range->GetExtent(&acpStart, &cch))) {
                                pargs->dwDeltaStart = cch;
                                ret = ENUM_FIND;
                            }
                        }
                    }
                }
            }
        }
    }

    VariantClear(&var);
    return ret;
}


CTextEventSinkCallBack::CTextEventSinkCallBack(
    ImmIfIME* pImmIfIME,
    HIMC hIMC
    ) : m_pImmIfIME(pImmIfIME),
        CTextEventSink(TextEventSinkCallback, NULL)
{
    m_pImmIfIME->AddRef();
    m_hIMC = hIMC;
}

CTextEventSinkCallBack::~CTextEventSinkCallBack(
    )
{
    m_pImmIfIME->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\aimm1.2\win32\uiwndhd.cpp ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    uiwndhd.cpp

Abstract:

    This file implements the IME UI window handler Class.

Author:

Revision History:

Notes:

--*/

#include "private.h"

#include "cime.h"
#include "template.h"
#include "uiwndhd.h"
#include "editses.h"
#include "imeapp.h"


LPCTSTR IMEUIWndHandlerName = TEXT("IMEUIWindowHandler");


CIMEUIWindowHandler::CIMEUIWindowHandler(
    HWND hwnd
    )
{
    IMTLS *ptls;

    m_imeuiextra.hImeUIWnd = hwnd;

    if (ptls = IMTLS_GetOrAlloc())
    {
        ptls->prvUIWndMsg.hWnd = hwnd;
        ptls->prvUIWndMsg.uMsgOnLayoutChange = RegisterWindowMessageA( TEXT("PrivateUIWndMsg OnLayoutChange") );
        ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer = RegisterWindowMessageA( TEXT("PrivateUIWndMsg OnClearDocFeedBuffer") );
    }
}



LRESULT
CIMEUIWindowHandler::ImeUIWndProcWorker(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    LONG lRet = 0L;

    switch (uMsg) {
        case WM_CREATE:
            return UIWndCreateHandler((LPCREATESTRUCT)lParam);

        case WM_DESTROY:
            /*
             * We are destroying the IME UI window,
             * destroy any related window that it owns.
             */
            UIWndDestroyHandler();
            return 0L;

        case WM_NCDESTROY:
            UIWndFinalDestroyHandler();
            return 0L;

        case WM_IME_NOTIFY:
            return ImeUINotifyHandler(uMsg, wParam, lParam, fUnicode);

        case WM_IME_SELECT:
            return ImeUISelectHandler(uMsg, wParam, lParam, fUnicode);

        default:
            if (IsMsImeMessage(uMsg))
                return ImeUIMsImeHandler(uMsg, wParam, lParam, fUnicode);
            else if (IsPrivateMessage(uMsg))
                return ImeUIPrivateHandler(uMsg, wParam, lParam, fUnicode);
            else
                return fUnicode ? DefWindowProcW(m_imeuiextra.hImeUIWnd, uMsg, wParam, lParam)
                                : DefWindowProcA(m_imeuiextra.hImeUIWnd, uMsg, wParam, lParam);
    }

    return lRet;
}


LRESULT
CIMEUIWindowHandler::UIWndCreateHandler(
    LPCREATESTRUCT lpcs
    )
{
    return 0L;
}


VOID
CIMEUIWindowHandler::UIWndDestroyHandler(
    )
{
}


VOID
CIMEUIWindowHandler::UIWndFinalDestroyHandler(
    )
{
    SetProp(m_imeuiextra.hImeUIWnd, IMEUIWndHandlerName, NULL);
    delete this;
}

LRESULT
CIMEUIWindowHandler::ImeUINotifyHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    IMCLock imc((HIMC)GetWindowLongPtr(m_imeuiextra.hImeUIWnd, IMMGWLP_IMC));
    if (imc.Invalid())
        return 0L;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return 0L;

    ImmIfIME* const _pImmIfIME = _pAImeContext->GetImmIfIME();
    if (_pImmIfIME == NULL)
        return 0L;

    switch (wParam) {
        case IMN_SETOPENSTATUS:
            //
            // we can track this in SetOpenStatus().
            // Don't have to sync when IMM32 is called.
            //
            // _pImmIfIME->OnSetOpenStatus(imc);
            break;
        case IMN_SETSTATUSWINDOWPOS:
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
            break;
        case IMN_SETCONVERSIONMODE:
        case IMN_SETSENTENCEMODE:
            //
            // we can track this in SetConversionMode().
            // Don't have to sync when IMM32 is called.
            //
            // _pImmIfIME->OnSetConversionSentenceMode(imc);
            break;
        case IMN_SETCANDIDATEPOS:
        case IMN_CHANGECANDIDATE:
            _pImmIfIME->OnSetCandidatePos(imc);
            break;
        case IMN_OPENCANDIDATE:
            _pAImeContext->m_fOpenCandidateWindow = TRUE;
            break;
        case IMN_CLOSECANDIDATE:
            _pAImeContext->m_fOpenCandidateWindow = FALSE;
            {
                /*
                 * A-Synchronize call ImmIfIME::ClearDocFeedBuffer
                 * because this method had a protected.
                 */
                IMTLS *ptls;
                if (ptls = IMTLS_GetOrAlloc())
                {
                    PostMessage(ptls->prvUIWndMsg.hWnd,
                                ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer, (WPARAM)(HIMC)imc, 0);
                }
            }
            break;
        case IMN_SETCOMPOSITIONFONT:
        case IMN_SETCOMPOSITIONWINDOW:
        case IMN_GUIDELINE:
            break;
        case WM_IME_STARTCOMPOSITION:
            _pAImeContext->InquireIMECharPosition(imc, NULL);
            break;
        case WM_IME_ENDCOMPOSITION:
            _pAImeContext->ResetIMECharPosition(imc);
            break;
    }

    return 0L;
}

LRESULT
CIMEUIWindowHandler::ImeUIMsImeHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    IMTLS *ptls;

    if (uMsg == WM_MSIME_MOUSE) {
        return ImeUIMsImeMouseHandler(uMsg, wParam, lParam, fUnicode);
    }
    else if (uMsg == WM_MSIME_MODEBIAS)
    {
        return ImeUIMsImeModeBiasHandler(wParam, lParam);
    }
    else if (uMsg == WM_MSIME_RECONVERTREQUEST)
    {

        if (wParam == FID_RECONVERT_VERSION)
        {
            // they're asking for version # so return something
            return 1L;
        }

        ptls = IMTLS_GetOrAlloc();

        if (ptls && ptls->pAImm)
        {
            HIMC himc;
            HWND hwnd = (HWND)lParam;

            if (S_OK == ptls->pAImm->GetContext(hwnd, &himc))
            {
                IMCLock imc((HIMC)himc);
                if (!imc.Invalid())
                {
                    CAImeContext* _pAImeContext = imc->m_pAImeContext;
                    if (_pAImeContext == NULL)
                        return 0L;

                    _pAImeContext->SetupReconvertString(WM_MSIME_RECONVERT);
                    _pAImeContext->EndReconvertString();
                    return 1L;
                }
            }
        }
    }
    else if (uMsg ==  WM_MSIME_SERVICE)
    {
        ptls = IMTLS_GetOrAlloc();

        if (ptls != NULL)
        {
            LANGID langid;

            ptls->pAImeProfile->GetLangId(&langid);

            if (PRIMARYLANGID(langid) == LANG_KOREAN)
                return 0L;
        }

        return 1L;    // Win32 Layer support WM_MSIME_xxxx message.
    }

    return 0L;
}

LRESULT
CIMEUIWindowHandler::ImeUIMsImeMouseHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )

/*++

Method:

    WM_MSIME_MOUSE

Routine Description:

    Mouse Operation on Composition String

Arguments:

    wParam - Mouse operation code.
                 LOBYTE(LOWORD(wParam))
                     IMEMOUSE_VERSION
                     IMEMOUSE_NONE
                     IMEMOUSE_LDOWN
                     IMEMOUSE_RDOWN
                     IMEMOUSE_MDOWN
                     IMEMOUSE_WUP
                     IMEMOUSE_WDOWN
                 HIBYTE(LOWORD(wParam))
                     Mouse Position
                 HIWORD(wParam)
                     Clicked position
    lParam - Input Context handle (HIMC).

Return Value:

    Returns 1 if IME handled this message.
    IMEMOUSERET_NOTHANDLED if IME did not handled this message.

--*/

{
    ULONG dwBtnStatus;

    // special case: version check
    if (LOBYTE(LOWORD(wParam)) == IMEMOUSE_VERSION)
        return 1; // we support version 1.0

    IMCLock imc((HIMC)lParam);
    if (imc.Invalid())
        return IMEMOUSERET_NOTHANDLED;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return IMEMOUSERET_NOTHANDLED;

    ULONG uEdge       = HIWORD(wParam);
    ULONG uQuadrant   = HIBYTE(LOWORD(wParam));
    ULONG dwBtnStatusIme = LOBYTE(LOWORD(wParam));

    //
    // need to xlate dwBtnStatus from WM_MSIME_MOUSE flags to WM_MOUSE flags
    //
    dwBtnStatus = 0;

    if (dwBtnStatusIme & IMEMOUSE_LDOWN)
    {
        dwBtnStatus |= MK_LBUTTON;
    }
    if (dwBtnStatusIme & IMEMOUSE_MDOWN)
    {
        dwBtnStatus |= MK_MBUTTON;
    }
    if (dwBtnStatusIme & IMEMOUSE_RDOWN)
    {
        dwBtnStatus |= MK_RBUTTON;
    }

    // mouse wheel needs to be xlated from IMEMOUSE_WUP/IMEMOUSE_WDOWN to WHEEL_DELTA units 
    if (dwBtnStatusIme & IMEMOUSE_WUP)
    {
        dwBtnStatus |= (WHEEL_DELTA << 16);
    }
    else if (dwBtnStatusIme & IMEMOUSE_WDOWN)
    {
        dwBtnStatus |= (((unsigned long)(-WHEEL_DELTA)) << 16);
    }

    return _pAImeContext->MsImeMouseHandler(uEdge, uQuadrant, dwBtnStatus, (HIMC)lParam);
}

/*++

Method:

    CIMEUIWindowHandler::ImeUIMsImeModeBiasHandler

Routine Description:

    Handles WM_MSIME_MODEBIAS messages sent to the ui window.

Arguments:

    wParam - [in] operation: get version, get mode, set mode
    lParam - [in] for set mode, the new bias
                  otherwise ignored

Return Value:

    If wParam is MODEBIAS_GETVERSION, returns version number of interface.
    If wParam is MODEBIAS_SETVALUE, returns non-zero value if succeeded. Returns 0 if fail.
    If wParam is MODEBIAS_GETVALUE, returns current bias mode.
    
--*/

LRESULT CIMEUIWindowHandler::ImeUIMsImeModeBiasHandler(WPARAM wParam, LPARAM lParam)
{
    if (wParam == MODEBIAS_GETVERSION)
        return 1; // version 1
       
    IMCLock imc((HIMC)GetWindowLongPtr(m_imeuiextra.hImeUIWnd, IMMGWLP_IMC));
    if (imc.Invalid())
        return 0;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;

    switch (wParam)
    {
        case MODEBIAS_GETVALUE:
            return _pAImeContext ? _pAImeContext->lModeBias : 0L;

        case MODEBIAS_SETVALUE:
            // check lParam
            if (lParam != MODEBIASMODE_DEFAULT &&
                lParam != MODEBIASMODE_FILENAME &&
                lParam != MODEBIASMODE_DIGIT)
            {
                Assert(0); // bogus mode bias!
                return 0;  // failure
            }

            // set the new value
            if (_pAImeContext)
            {
                _pAImeContext->lModeBias = lParam;

                // let cicero know the mode bias has changed
                Interface_Attach<ITfContextOwnerServices> iccb = _pAImeContext->GetInputContextOwnerSink();
                iccb->OnAttributeChange(GUID_PROP_MODEBIAS);
            }

            return 1; // success
    }

    Assert(0); // should never get here; bogus wParam
    return 0;
}

LRESULT
CIMEUIWindowHandler::ImeUIPrivateHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )

/*++

Method:

    CIMEUIWindowHandler::ImeUIPrivateHandler

Routine Description:

    Handles WM_PRIVATE_xxx messages sent to the ui window.

Arguments:

    wParam - [in] HIMC : input context handle
    lParam - [in] N/A

Return Value:

--*/

{
    IMTLS *ptls = IMTLS_GetOrAlloc();

    if (ptls == NULL)
        return E_FAIL;

    if (uMsg == ptls->prvUIWndMsg.uMsgOnLayoutChange) {
        IMCLock imc((HIMC)wParam);
        if (imc.Invalid())
            return E_FAIL;

        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (_pAImeContext == NULL)
            return E_FAIL;

        Interface_Attach<ITfContextOwnerServices> iccb = _pAImeContext->GetInputContextOwnerSink();

        iccb->AddRef();

        /*
         * Repositioning candidate window
         */
        iccb->OnLayoutChange();
        iccb->Release();
    }
    else if (uMsg == ptls->prvUIWndMsg.uMsgOnClearDocFeedBuffer) {
        IMCLock imc((HIMC)wParam);
        if (imc.Invalid())
            return E_FAIL;

        CAImeContext* _pAImeContext = imc->m_pAImeContext;
        if (_pAImeContext == NULL)
            return E_FAIL;

        ImmIfIME* const _pImmIfIME = _pAImeContext->GetImmIfIME();
        if (_pImmIfIME == NULL)
            return E_FAIL;

        //
        // Clear DocFeed buffer
        // Find GUID_PROP_MSIMTF_READONLY property and SetText(NULL).
        //
        _pImmIfIME->ClearDocFeedBuffer(_pAImeContext->GetInputContext(), imc);  // TF_ES_SYNC
    }

    return S_OK;
}

extern HINSTANCE hIMM;   // temporary: do not call IMM32 for now
BOOL WINAPI RawImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);

LRESULT
CIMEUIWindowHandler::ImeUISelectHandler(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL fUnicode
    )
{
    if ((! wParam) && (! IsOnNT()) )
    {
        //
        // Unselect Cicero keyboard layout.
        //
        // We needs to call postponed lock so release all queueing request for edit session here.
        // Especially, ESCB_UPDATECOMPOSITIONSTRING should handle before switch to Legacy IME,
        // because this edit session possible to rewrite hIMC->hCompStr buffer.
        // Some Legacy IME have dependency of size and each offset with hCompStr.
        //
        // IsOnNT is ImmIfIME::SelectEx()
        //
        hIMM = GetSystemModuleHandle("imm32.dll");
        if (hIMM != NULL) {
            RawImmEnumInputContext(0,                        // Current thread
                                   EnumUnSelectCallback,     // enumerate callback function
                                   NULL);                    // lParam
        }
    }
    return 0L;
}

/* static */
BOOL
CIMEUIWindowHandler::EnumUnSelectCallback(
    HIMC hIMC,
    LPARAM lParam
    )
{
    IMCLock imc(hIMC);
    if (imc.Invalid())
        return TRUE;

    CAImeContext* _pAImeContext = imc->m_pAImeContext;
    if (_pAImeContext == NULL)
        return TRUE;

    ImmIfIME* const _pImmIfIME = _pAImeContext->GetImmIfIME();
    if (_pImmIfIME == NULL)
        return TRUE;

    Interface_Attach<ITfThreadMgr_P> tim(_pImmIfIME->GetThreadManagerInternal());
    if (tim.Valid())
    {
        Interface_Attach<ITfContext> ic(_pAImeContext->GetInputContext());
        if (ic.Valid())
        {
            tim->RequestPostponedLock(ic.GetPtr());
        }
    }

    return TRUE;
}

CIMEUIWindowHandler*
GetImeUIWndHandler(
    HWND hwnd
    )
{
    CIMEUIWindowHandler* pimeui = static_cast<CIMEUIWindowHandler*>(GetProp(hwnd, IMEUIWndHandlerName));
    if (pimeui == NULL) {
        pimeui = new CIMEUIWindowHandler(hwnd);
        SetProp(hwnd, IMEUIWndHandlerName, pimeui);
    }

    return pimeui;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\cicload.h ===
//
// aimmlaod.h
//


#define ID_ICON_INDICATOR   1000


// Indicator Menu Item IDs
#define IDM_INDIC_CANCEL      2000
#define IDM_INDIC_UNLOADAIMM  2001
#define IDM_INDIC_IMXSTART    2100
#define IDM_INDIC_IMXEND      2199
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "CTFMON"
#define SZ_MODULE       "CTFMON"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\cicload.cpp ===
//
// cicload.cpp
//

#include "private.h"
#include "cicload.h"
#include "loader.h"
#include "immxutil.h"
#include "osver.h"
#include "regwatch.h"
#include "mem.h"
#include "msutbapi.h"
#include "ciccs.h"

DECLARE_OSVER();

typedef BOOL (WINAPI *PFNSETPROCESSSHUTDOWNPARAMETERS)( DWORD dwLevel, DWORD dwFlags);

LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

CLoaderWnd *g_pLoaderWnd;

HINSTANCE g_hInst;

HANDLE g_hInstanceMutex;

BOOL g_fWinLogon = FALSE;
BOOL g_fRunOnceMode = FALSE;
BOOL g_bOnWow64 = FALSE;
BOOL g_fNoRunKey = FALSE;

#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

CCicCriticalSectionStatic g_cs;

extern "C" HANDLE WINAPI TF_CreateCicLoadMutex(BOOL *pfWinLogon);

extern "C" HRESULT WINAPI TF_GetGlobalCompartment(ITfCompartmentMgr **pCompMgr);

HRESULT GetGlobalCompartment(REFGUID rguidComp, ITfCompartment **ppComp)
{
    HRESULT hr = E_FAIL;
    ITfCompartmentMgr *pCompMgr = NULL;

    *ppComp = NULL;

    if (FAILED(hr = TF_GetGlobalCompartment(&pCompMgr)))
    {
         Assert(0);
         goto Exit;
    }

    if (SUCCEEDED(hr) && pCompMgr)
    {
        hr = pCompMgr->GetCompartment(rguidComp, ppComp);
        pCompMgr->Release();
    }
    else
        hr = E_FAIL;

Exit:
    return hr;
}

HRESULT SetGlobalCompartmentDWORD(REFGUID rguidComp, DWORD dw)
{
    HRESULT hr;
    ITfCompartment *pComp;
    VARIANT var;

    if (SUCCEEDED(hr = GetGlobalCompartment(rguidComp, &pComp)))
    {
        var.vt = VT_I4;
        var.lVal = dw;
        hr = pComp->SetValue(0, &var);
        pComp->Release();
    }
    return hr;
}


HRESULT STDAPICALLTYPE StubCoCreateInstance(REFCLSID rclsid, LPUNKNOWN punkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
    // we should never get here!  This function is a stub to keep the library happy, so it won't actually
    // load ole32.dll.  ctfmon.exe should never be loading ole32.dll!
    Assert(0);
    if (ppv != NULL)
    {
        *ppv = NULL;
    }
    return E_UNEXPECTED;
}

void AddRunRegkey()
{
    HKEY hkeyRun;
    const static TCHAR c_szCTFMon[] = TEXT("ctfmon.exe");

    if (g_fNoRunKey)
        return;

    if (RegCreateKey( HKEY_CURRENT_USER,
                      REGSTR_PATH_RUN,
                      &hkeyRun ) == ERROR_SUCCESS)
    {
        CicSystemModulePath pathCTFMon;

        if (pathCTFMon.Init(c_szCTFMon))
        {
            RegSetValueEx(hkeyRun,
                          c_szCTFMon,
                          0,
                          REG_SZ,
                          (LPBYTE)pathCTFMon.GetPath(),
                          pathCTFMon.GetLength() * sizeof(TCHAR));

            RegCloseKey(hkeyRun);
        }
    }
}

BOOL InitApp(HINSTANCE hInstance)
{

    g_hInstanceMutex = TF_CreateCicLoadMutex(&g_fWinLogon);

    if (!g_hInstanceMutex)
        return FALSE;

    AddRunRegkey();

    g_hInst = hInstance;
    if (!g_cs.Init())
        return FALSE;

    TFInitLib_PrivateForCiceroOnly(StubCoCreateInstance);
    InitOSVer();

    //
    // Specify the shutdown order of the progman process.
    //
    // Progman (level = 2)
    // taskman (level = 1)
    // ntsd or windbg (level = 0)
    //
    // Ctfmon is enough to have 0xf0 after any programs..
    //
    if (IsOnNT())
    {
        static PFNSETPROCESSSHUTDOWNPARAMETERS pfnSetShutdownParam;
        static HINSTANCE hLibKernel32 = NULL;
        hLibKernel32 = GetSystemModuleHandle( TEXT("kernel32.dll") );
        if (hLibKernel32)
        {
            pfnSetShutdownParam = (PFNSETPROCESSSHUTDOWNPARAMETERS)GetProcAddress(hLibKernel32, TEXT("SetProcessShutdownParameters"));
            if (pfnSetShutdownParam)
                pfnSetShutdownParam(0xf0, SHUTDOWN_NORETRY);
        }
        
    }

    // rev up default Cicero support for the system
    TF_InitSystem();

    if (! g_bOnWow64)
    {
        CRegWatcher::Init();
    }

    g_pLoaderWnd = new CLoaderWnd();
    if (!g_pLoaderWnd)
    {
       return FALSE;
    }

    if (!g_pLoaderWnd->Init())
    {
       return FALSE;
    }

    g_pLoaderWnd->CreateWnd();

    //
    // locate this window at the bottom of z-order list.
    // so we can delay WM_QUERYENDSESSION under Win9x platform.
    //
    if (g_pLoaderWnd->GetWnd())
        SetWindowPos(g_pLoaderWnd->GetWnd(), HWND_BOTTOM, 0, 0, 0, 0,
                     SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

    return TRUE;
}

void UninitApp(void)
{
    ClosePopupTipbar();
    TFUninitLib();
    CloseHandle(g_hInstanceMutex);
    if (! g_bOnWow64)
    {
        CRegWatcher::Uninit();
    }
}

void CheckCmdLine(PSTR pszCmdLine)
{
    PSTR psz = pszCmdLine;

    while (*psz)
    {
        if (*psz == ' ')
        {
            psz++;
            if (!*psz)
                return;

            if ((*psz == '-') || (*psz == '/'))
            {
                psz++;
                if (!*psz)
                    return;
 

                switch (*psz)
                {
                    case 'r':
                    case 'R':
                        g_fRunOnceMode = TRUE;
                        break;

                    case 'n':
                    case 'N':
                        g_fNoRunKey = TRUE;
                        break;

                    default:
                        break;
                }
            }
        }
        psz++;
    }

}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pszCmdLine, int iCmdShow)
{
    MSG msg;
    DWORD dwWaitObj;

    CcshellGetDebugFlags();
    Dbg_MemInit(TEXT("CTFMON"), NULL);

    //
    // Retrive WOW64
    //
    g_bOnWow64 = RunningOnWow64();


    CheckCmdLine(pszCmdLine);
    

    if (g_fRunOnceMode)
    {
        AddRunRegkey();
        Dbg_MemUninit();
        return 1;
    }

    if (!InitApp(hInstance))
    {
        Dbg_MemUninit();
        return 0;
    }

    if (! g_bOnWow64)
    {
        //
        // Load MSUTB.DLL
        //
        GetPopupTipbar(g_pLoaderWnd->GetWnd(), g_fWinLogon ? UTB_GTI_WINLOGON : 0);
    }

    //
    // For 64bit only.
    // Launch ctfmon(32).
    //
    {
        SYSTEM_INFO sys;
        GetSystemInfo(&sys);
        if ((sys.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||
            (sys.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64))
        {
            HMODULE h = GetSystemModuleHandle("kernel32.dll");
            if (h)
            {
                const char c_szCtfMonExe[] = "\\ctfmon.exe";
                PGET_SYSTEM_WOW64_DIRECTORY_A lpfn;
                lpfn = (PGET_SYSTEM_WOW64_DIRECTORY_A)GetProcAddress(h, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A);
                if (lpfn)
                {
                    char buf[MAX_PATH];
                    UINT len;
                    len = (lpfn)(buf, sizeof(buf)/sizeof(char));
                    if (len && 
                        (ARRAYSIZE(buf) > len + ARRAYSIZE(c_szCtfMonExe)))
                    {
                        PROCESS_INFORMATION process;
                        STARTUPINFO si;
                        memset(&si, 0, sizeof(si));
                        si.cb = sizeof(si);
                        si.wShowWindow = SW_SHOWMINNOACTIVE;

                        lstrcat(buf, c_szCtfMonExe);

                        if (CreateProcess(buf,            // application name
                                          pszCmdLine,     // command line
                                          NULL,           // process SD
                                          NULL,           // thread SD
                                          FALSE,          // inherit handle
                                          0,              // creation flags
                                          NULL,           // environment
                                          NULL,           // current directory
                                          &si,            // startup info
                                          &process))      // process information
                        {
                            CloseHandle(process.hProcess);
                            CloseHandle(process.hThread);
                        }
                    }
                }
            }
        }
    }

    HANDLE hEventWS0 = 0;
    if (! g_bOnWow64)
        hEventWS0 = OpenEvent(SYNCHRONIZE, FALSE, _T("WinSta0_DesktopSwitch"));

    while (TRUE)
    {
        if (! g_bOnWow64)
        {
            HANDLE rgAllEvents[NUM_REG_WATCH+1];
            const HANDLE *prgRegEvents = CRegWatcher::GetEvents();
            memcpy(rgAllEvents, prgRegEvents, NUM_REG_WATCH*sizeof(HANDLE));

            #define IDX_EVENT_WS  NUM_REG_WATCH

            #define NUM_ALL_EVENTS (NUM_REG_WATCH+1)

            rgAllEvents[IDX_EVENT_WS] = hEventWS0;

            dwWaitObj = MsgWaitForMultipleObjects(NUM_ALL_EVENTS, rgAllEvents, FALSE, INFINITE, QS_ALLINPUT);

            if (dwWaitObj == WAIT_OBJECT_0 + NUM_ALL_EVENTS)
            {
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (msg.message == WM_QUIT)
                        goto Exit;
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            else if (dwWaitObj == WAIT_OBJECT_0 + IDX_EVENT_WS)
            {
                // win station switching event

                // set mic off
                SetGlobalCompartmentDWORD(GUID_COMPARTMENT_SPEECH_OPENCLOSE, 0);

                // reset the event (needed? not sure if this is auto-reset)
                ::ResetEvent(rgAllEvents[IDX_EVENT_WS]);
            }
            else if (dwWaitObj < WAIT_OBJECT_0 + NUM_REG_WATCH)
            {
                CRegWatcher::OnEvent(dwWaitObj - WAIT_OBJECT_0);
            }
            else
            {
                Assert(0); // error
                msg.wParam = 0;
                break;
            }
        }
        else
        {
            while (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            break;
        }
    }

Exit:
    delete g_pLoaderWnd;


    if (!CLoaderWnd::_bUninitedSystem)
    {
        UninitApp();

        // it is over!
        TF_UninitSystem();
    }

    g_cs.Delete();

    Dbg_MemUninit();

    return (int)(msg.wParam);
}


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, GetCommandLine(), si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\loader.h ===
//
// loader.h
//

#ifndef LOADER_H
#define LOADER_H

#include "private.h"

// from msuim.dll
extern "C" BOOL WINAPI TF_InitSystem(void);
extern "C" BOOL WINAPI TF_UninitSystem(void);



class CLoaderWnd
{
public:
    CLoaderWnd();
    ~CLoaderWnd();

    BOOL Init();
    HWND CreateWnd();
    HWND GetWnd() {return _hWnd;}
    void DestroyWnd() {DestroyWindow(_hWnd);}

    static BOOL _bUninitedSystem;
private:
    static LRESULT CALLBACK _WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static BOOL _bWndClassRegistered;
    HWND _hWnd;
};

#endif // LOADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for aimmload project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_
#define WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY

#include <windows.h>
#include <regstr.h>
#include <ccstock.h>
#include <debug.h>
#include "msctf.h"
#include "mem.h" // must be last
#include "tchar.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\loader.cpp ===
//
// loader.cpp
//

#include "private.h"
#include "loader.h"
#include "regwatch.h"
#include "msutbapi.h"

extern HINSTANCE g_hInst;
extern BOOL g_fWinLogon;
extern BOOL g_bOnWow64;

const TCHAR c_szLoaderWndClass[] = TEXT("CicLoaderWndClass");

extern void UninitApp(void);

BOOL CLoaderWnd::_bWndClassRegistered = FALSE;
BOOL CLoaderWnd::_bUninitedSystem = FALSE;

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CLoaderWnd::CLoaderWnd()
{
    _hWnd = NULL;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CLoaderWnd::~CLoaderWnd()
{
}

//+---------------------------------------------------------------------------
//
// Init
//
//----------------------------------------------------------------------------

BOOL CLoaderWnd::Init()
{
    if (!_bWndClassRegistered)
    {
        WNDCLASSEX wc;
        memset(&wc, 0, sizeof(wc));
        wc.cbSize = sizeof(wc);
        wc.style = CS_HREDRAW | CS_VREDRAW ;
        wc.hInstance = g_hInst;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.lpfnWndProc = _WndProc;
        wc.lpszClassName = c_szLoaderWndClass;
        if (RegisterClassEx(&wc))
            _bWndClassRegistered = TRUE;
    }

    return _bWndClassRegistered ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
// CreateWnd
//
//----------------------------------------------------------------------------

HWND CLoaderWnd::CreateWnd()
{
    _hWnd = CreateWindowEx(0, c_szLoaderWndClass, TEXT(""), 
                           WS_DISABLED, 
                           0, 0, 0, 0, 
                           NULL, 0, g_hInst, 0);

    return _hWnd;
}

//+---------------------------------------------------------------------------
//
// _WndProc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK CLoaderWnd::_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_CREATE:
            break;

        case WM_DESTROY :
            PostQuitMessage(0);
            break;

        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
            if (! g_bOnWow64)
            {
                CRegWatcher::StartSysColorChangeTimer();
            }
            break;

        case WM_QUERYENDSESSION:
            if (g_fWinLogon && (lParam & ENDSESSION_LOGOFF))
                return 1;

            if (!IsOnNT())
            {
                //
                // uninit system.
                //

                ClosePopupTipbar();
                TF_UninitSystem();
                _bUninitedSystem = TRUE;
            }

            return 1;

        case WM_ENDSESSION:
            if (!wParam)
            {
                //
                // need to restore Cicero and Toolbar.
                //
                if (_bUninitedSystem)
                {
                   TF_InitSystem();
                   if (! g_bOnWow64)
                   {
                       GetPopupTipbar(hWnd, g_fWinLogon ? UTB_GTI_WINLOGON : 0);
                   }
                   _bUninitedSystem = FALSE;
                }
            }
            else // Do cleanup always no matter if this is from Winlogon session or not.
            {
                if (!_bUninitedSystem)
                {
                    UninitApp();
                    TF_UninitSystem();
                    _bUninitedSystem = TRUE;
                }
            }
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\regwatch.h ===
//
// regwatch.h
//


#ifndef REGdWATCH_H
#define REGdWATCH_H

#include "private.h"
//#include "smblock.h"
#include "cregkey.h"

#define REG_WATCH_KBDTOGGLE           0
#define REG_WATCH_HKLM_IMX            1
#define REG_WATCH_KBDPRELOAD          2
#define REG_WATCH_RUN                 3
#define REG_WATCH_HKCU_IMX            4
#define REG_WATCH_HKCU_SPEECH         5
#define REG_WATCH_HKCU_CPL_APPEARANCE 6
#define REG_WATCH_HKCU_CPL_COLORS     7
#define REG_WATCH_HKCU_CPL_METRICS    8
#define REG_WATCH_HKLM_SPEECH         9
#define REG_WATCH_KBDLAYOUT          10
#define REG_WATCH_HKCU_ASSEMBLIES    11
#define NUM_REG_WATCH                12

typedef struct _REGWATCH
{
    HKEY hKeyRoot;
    const char *pszKey;
    HKEY hKey;
} REGWATCH;

class CRegWatcher
{
public:
    CRegWatcher() {}

    static BOOL Init();
    static void Uninit();

    static const HANDLE *GetEvents()
    {
        return _rgEvent;
    }

    static void OnEvent(DWORD dwEventId);
    static void StartSysColorChangeTimer();

private:
    static BOOL InitEvent(int nId, BOOL fReset = FALSE);
    static BOOL PostAllThreadMsg(WPARAM wParam);

    static UINT_PTR nRegImxTimerId;
    static void RegImxTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static UINT_PTR nSysColorTimerId;
    static void SysColorTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static UINT_PTR nKbdToggleTimerId;
    static void KbdToggleTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static UINT_PTR nKbdLayoutTimerId;
    static void KbdLayoutTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    static void KillInternat();
    static void UpdateSpTip();
    static BOOL CALLBACK EnumWndProc(HWND hwnd, LPARAM lparam);

    static REGWATCH _rgRegWatch[NUM_REG_WATCH];
    static HANDLE _rgEvent[NUM_REG_WATCH];
};

#endif // REGdWATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicsthkl\inc\cicsthkl.h ===
//
// cicsthkl.h
//
// Cicero Library to retreive the substitute keyboard layout of the 
// current active keyboard TIP.
//

//
// CicSubstGetKeyboardLayout
//
// If the current focus is on Cicero aware (including AIMM1.2
// or CUAS), This function returns the substitute HKL of
// the current active keyboard TIP. And the keyboard layout
// name of the hKL that is returned in pszKLID.
// If the current focus is not on Cicero aware, it just returns
// the current keyboard layout and keyboard layout name in 
// pszKLID.
// pszKLID can be NULL.
//
extern "C" HKL WINAPI CicSubstGetKeyboardLayout(char *pszKLID);

//
// CicSubstGetDefaultKeyboardLayout
//
// This function returns the substitute hKL of the default item
// of the given langage.
//
extern "C" HKL WINAPI CicSubstGetDefaultKeyboardLayout(LANGID langid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicmem\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#include <windows.h>
#include <ccstock.h>
#include <debug.h>
#include "mem.h" // must be last

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicsthkl\lib\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for dimm project.
//
//----------------------------------------------------------------------------

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#define _OLEAUT32_

#include <nt.h>    // for NtQuery
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <ole2.h>
#include <advpub.h>
#include <ccstock.h>
#include <debug.h>
#include <inetreg.h>
#include <ocidl.h>
#include <comcat.h>
#include <olectl.h>
#include <limits.h>
#include "msctf.h"

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicmem\mem.cpp ===
//
// mem.cpp
//

#include "private.h"
#include "ciccs.h"
#include "mem.h"
#ifdef USECRT
#include <malloc.h>
#endif

#ifndef DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// RETAIL memory functions.
//
///////////////////////////////////////////////////////////////////////////////

extern "C" void *cicMemAlloc(UINT uCount)
{
#ifdef USECRT
    return malloc(uCount);
#else
    return LocalAlloc(LMEM_FIXED, uCount);
#endif
}

extern "C" void *cicMemAllocClear(UINT uCount)
{
#ifdef USECRT
    return calloc(uCount, 1);
#else
    return LocalAlloc(LPTR, uCount);
#endif
}

extern "C" void cicMemFree(void *pv)
{
    if (pv == NULL)
        return;

#ifdef USECRT
    free(pv);
#else
    HLOCAL hLocal;

    hLocal = LocalFree(pv);

    Assert(hLocal == NULL);
#endif
}

extern "C" void *cicMemReAlloc(void *pv, UINT uCount)
{
#ifdef USECRT
    return realloc(pv, uCount);
#else
    return LocalReAlloc((HLOCAL)pv, uCount, LMEM_MOVEABLE | LMEM_ZEROINIT);
#endif
}

extern "C" UINT cicMemSize(void *pv)
{
#ifdef USECRT
    return _msize(pv);
#else
    return (UINT)LocalSize((HLOCAL)pv);
#endif
}

#else // DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// DEBUG memory functions.
//
///////////////////////////////////////////////////////////////////////////////

#define MEM_SUSPICIOUSLY_LARGE_ALLOC    0x1000000 // 16MB

// All the debug state goes here.
// Be thread safe: make sure you hold s_Dbg_cs before touching/reading anything!

DBG_MEMSTATS s_Dbg_MemStats = { 0 };

DBG_MEM_COUNTER *s_rgCounters = NULL;

static CCicCriticalSectionStatic s_Dbg_cs;

static void *s_Dbg_pvBreak = (void *)-1; // set this to something to break on at runtime in MemAlloc/MemAllocClear/MemReAlloc

extern "C" TCHAR *Dbg_CopyString(const TCHAR *pszSrc)
{
    TCHAR *pszCpy;
    int c;

    c = lstrlen(pszSrc)+1;
    pszCpy = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, c*sizeof(TCHAR));

    if (pszCpy != NULL)
    {
        memcpy(pszCpy, pszSrc, c*sizeof(TCHAR));
    }

    return pszCpy;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemInit
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemInit(const TCHAR *pszName, DBG_MEM_COUNTER *rgCounters)
{
    if (!s_Dbg_cs.Init())
        return FALSE;

    s_Dbg_MemStats.pszName = Dbg_CopyString(pszName);
    s_rgCounters = rgCounters;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemUninit
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemUninit()
{
    DBG_MEMALLOC *pdma;
    DBG_MEMALLOC *pdmaTmp;
    TCHAR achID[64];
    BOOL bMemLeak = FALSE;

    // dump stats
    Dbg_MemDumpStats();

    // everything free?
    pdma = s_Dbg_MemStats.pMemAllocList;

    if (pdma != NULL ||
        s_Dbg_MemStats.uTotalAlloc != s_Dbg_MemStats.uTotalFree) // second test necessary to catch size 0 objects
    {
        TraceMsg(TF_MEMORY_LEAK, "%s: Memory leak detected! %x total bytes leaked!",
            s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc - s_Dbg_MemStats.uTotalFree);
        bMemLeak = TRUE;
    }

    while (pdma != NULL)
    {
        if (pdma->dwID == DWORD(-1))
        {
            achID[0] = '\0';
        }
        else
        {
            wsprintf(achID, " (ID = 0x%x)", pdma->dwID);
        }

        TraceMsg(TF_MEMORY_LEAK, "       Address: %8.8lx     Size: %8.8lx    TID: %8.8lx    %s%s%s line %i %s",
            pdma->pvAlloc, pdma->uCount, pdma->dwThreadID, pdma->pszName ? pdma->pszName : "", pdma->pszName ? " -- " : "", pdma->pszFile, pdma->iLine, achID);

        // free the DBG_MEMALLOC
        pdmaTmp = pdma->next;
        LocalFree(pdma->pszName);
        LocalFree(pdma);
        pdma = pdmaTmp;
    }

    // Assert after tracing.
    if (bMemLeak)
        AssertPrivate(0);

    s_Dbg_MemStats.pMemAllocList = NULL; // in case someone wants to call Dbg_MemInit again

    s_Dbg_cs.Delete();

    LocalFree(s_Dbg_MemStats.pszName);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemDumpStats
//
//----------------------------------------------------------------------------

extern "C" void Dbg_MemDumpStats()
{
    EnterCriticalSection(s_Dbg_cs);

    TraceMsg(TF_MEMORY_LEAK, "Memory: %s allocated %x bytes, freed %x bytes.",
        s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc, s_Dbg_MemStats.uTotalFree);

    if (s_Dbg_MemStats.uTotalAlloc != s_Dbg_MemStats.uTotalFree)
    {
        TraceMsg(TF_MEMORY_LEAK, "Memory: %s %x bytes currently allocated.",
            s_Dbg_MemStats.pszName, s_Dbg_MemStats.uTotalAlloc - s_Dbg_MemStats.uTotalFree);
    }

    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemAlloc", s_Dbg_MemStats.uTotalMemAllocCalls);
    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemAllocClear", s_Dbg_MemStats.uTotalMemAllocClearCalls);
    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemReAlloc", s_Dbg_MemStats.uTotalMemReAllocCalls);
    TraceMsg(TF_MEMORY_LEAK, "Memory:   %x MemFree", s_Dbg_MemStats.uTotalMemFreeCalls);

    LeaveCriticalSection(s_Dbg_cs);
}


//+---------------------------------------------------------------------------
//
// Dbg_MemAlloc
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemAlloc(UINT uCount, const TCHAR *pszFile, int iLine)
{
    void *pv;
    DBG_MEMALLOC *pdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemAllocCalls);

    if (uCount == 0)
    {
        // TraceMsg(TF_MEMORY_LEAK, "Zero size memory allocation! %s line %i", pszFile, iLine);
        //Assert(0);
    }
    if (uCount >= MEM_SUSPICIOUSLY_LARGE_ALLOC)
    {
        TraceMsg(TF_MEMORY_LEAK, "Suspiciously large memory allocation (0x%x bytes)! %s line %i", uCount, pszFile, iLine);
        Assert(0);
    }

    pv = LocalAlloc(LMEM_FIXED, uCount);

    if (pv == NULL)
        return NULL;

    //
    // record this allocation
    //

    if ((pdma = (DBG_MEMALLOC *)LocalAlloc(LPTR, sizeof(DBG_MEMALLOC))) == NULL)
    {
        // this is a transaction -- fail if we can't allocate the debug info
        LocalFree(pv);
        return NULL;
    }

    pdma->pvAlloc = pv;
    pdma->uCount = uCount;
    pdma->pszFile = pszFile;
    pdma->iLine = iLine;
    pdma->dwThreadID = GetCurrentThreadId();
    pdma->dwID = (DWORD)-1;

    EnterCriticalSection(s_Dbg_cs);

    pdma->next = s_Dbg_MemStats.pMemAllocList;
    s_Dbg_MemStats.pMemAllocList = pdma;

    //
    // update global stats
    //

    s_Dbg_MemStats.uTotalAlloc += uCount;

    LeaveCriticalSection(s_Dbg_cs);

    if (pv == s_Dbg_pvBreak)
        Assert(0);

    return pv;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemAllocClear
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemAllocClear(UINT uCount, const TCHAR *pszFile, int iLine)
{
    void *pv;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemAllocClearCalls);
    InterlockedDecrement(&s_Dbg_MemStats.uTotalMemAllocCalls); // compensate for wrapping

    pv = Dbg_MemAlloc(uCount, pszFile, iLine);

    if (pv != NULL)
    {
        // clear out the mem
        memset(pv, 0, uCount);
    }
    
    return pv;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemFree
//
//----------------------------------------------------------------------------

extern "C" void Dbg_MemFree(void *pv)
{
    HLOCAL hLocal;
    DBG_MEMALLOC *pdma;
    DBG_MEMALLOC **ppdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemFreeCalls);

    if (pv != NULL) // MemFree(NULL) is legal
    {
        EnterCriticalSection(s_Dbg_cs);

        // was this guy allocated?
        ppdma = &s_Dbg_MemStats.pMemAllocList;

        if (ppdma)
        {
            while ((pdma = *ppdma) && pdma->pvAlloc != pv)
            {
                ppdma = &pdma->next;
            }

            if (pdma != NULL)
            {
                // found it, update and delete
                s_Dbg_MemStats.uTotalFree += pdma->uCount;
                *ppdma = pdma->next;
                LocalFree(pdma->pszName);
                LocalFree(pdma);
            }
            else
            {
                TraceMsg(TF_MEMORY_LEAK, "%s: MemFree'ing a bogus pointer %x!", s_Dbg_MemStats.pszName, pv);
                // Assert(0); // freeing bogus pointer
            }
        }
        else
        {
            Assert(0); // freeing bogus pointer
        }

        LeaveCriticalSection(s_Dbg_cs);

        hLocal = LocalFree(pv); // to match retail behavior, we don't call LocalFree for pv == NULL
        Assert(hLocal == NULL);
    }
}

//+---------------------------------------------------------------------------
//
// Dbg_MemReAlloc
//
//----------------------------------------------------------------------------

extern "C" void *Dbg_MemReAlloc(void *pv, UINT uCount, const TCHAR *pszFile, int iLine)
{
    DBG_MEMALLOC *pdma;

    InterlockedIncrement(&s_Dbg_MemStats.uTotalMemReAllocCalls);

    EnterCriticalSection(s_Dbg_cs);

    // was this guy allocated?
    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma == NULL)
    {
        // can't find this guy!
        TraceMsg(TF_MEMORY_LEAK, "%s: MemReAlloc'ing a bogus pointer %x!", s_Dbg_MemStats.pszName, pv);
        Assert(0); // bogus pointer

        pv = NULL;
    }
    else
    {
        // we blow away the original pv here, but we're not free'ing it so that's ok
#pragma prefast(suppress:308)
        pv = LocalReAlloc((HLOCAL)pv, uCount, LMEM_MOVEABLE | LMEM_ZEROINIT);
    }

    if (pv != NULL)
    {
        // update the stats
        pdma->pvAlloc = pv;
        s_Dbg_MemStats.uTotalAlloc += (uCount - pdma->uCount);
        pdma->uCount = uCount;
        pdma->pszFile = pszFile;
        pdma->iLine = iLine;
    }

    LeaveCriticalSection(s_Dbg_cs);

    if (pv == s_Dbg_pvBreak)
        Assert(0);

    return pv;
}


//+---------------------------------------------------------------------------
//
// Dbg_MemSize
//
//----------------------------------------------------------------------------

extern "C" UINT Dbg_MemSize(void *pv)
{
    UINT uiSize;

    EnterCriticalSection(s_Dbg_cs);

    uiSize = (UINT)LocalSize((HLOCAL)pv);

    LeaveCriticalSection(s_Dbg_cs);

    return uiSize;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetName
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetName(void *pv, const TCHAR *pszName)
{
    return Dbg_MemSetNameIDCounter(pv, pszName, (DWORD)-1, (ULONG)-1);
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetNameID
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetNameID(void *pv, const TCHAR *pszName, DWORD dwID)
{
    return Dbg_MemSetNameIDCounter(pv, pszName, dwID, (ULONG)-1);
}

//+---------------------------------------------------------------------------
//
// Dbg_MemSetNameID
//
//----------------------------------------------------------------------------

extern "C" BOOL Dbg_MemSetNameIDCounter(void *pv, const TCHAR *pszName, DWORD dwID, ULONG iCounter)
{
    DBG_MEMALLOC *pdma;
    BOOL f = FALSE;

    EnterCriticalSection(s_Dbg_cs);

    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma != NULL)
    {
        if (s_rgCounters != NULL && iCounter != (ULONG)-1)
        {
            s_rgCounters[iCounter].uCount++;
        }
        LocalFree(pdma->pszName);
        pdma->pszName = Dbg_CopyString(pszName);
        pdma->dwID = dwID;
        f = TRUE;
    }

    LeaveCriticalSection(s_Dbg_cs);

    return f;
}

//+---------------------------------------------------------------------------
//
// Dbg_MemGetName
//
// Pass in ccBuffer == 0 to get size of string only.
//
//----------------------------------------------------------------------------

extern "C" int Dbg_MemGetName(void *pv, TCHAR *pch, int ccBuffer)
{
    DBG_MEMALLOC *pdma;
    int cc;

    if (ccBuffer <= 0)
        return 0;

    EnterCriticalSection(s_Dbg_cs);

    for (pdma = s_Dbg_MemStats.pMemAllocList; pdma != NULL && pdma->pvAlloc != pv; pdma = pdma->next)
        ;

    if (pdma != NULL)
    {
        cc = lstrlen(pdma->pszName);
        cc = min(cc, ccBuffer-1);
        memcpy(pch, pdma->pszName, cc*sizeof(TCHAR));
    }
    else
    {
        cc = 0;
    }
    pch[cc] = '\0';

    LeaveCriticalSection(s_Dbg_cs);

    return cc;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicload\regwatch.cpp ===
//
// regwatch.cpp
//

#include "private.h"
#include "regwatch.h"
#include "indicml.h"
#include "tfpriv.h"
#include "ctffunc.h"
#include "tlapi.h"
#include "immxutil.h"

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCache();
extern "C" HRESULT WINAPI TF_PostAllThreadMsg(WPARAM wParam, DWORD dwFlags);

static const char c_szKbdLayout[]  = "keyboard layout";
static const char c_szKbdToggleKey[]  = "Keyboard Layout\\Toggle";
static const char c_szKbdPreload[]  = "keyboard layout\\Preload";
static const char c_szRun[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Run";
static const char c_szSpeechKey[] = "Software\\Microsoft\\Speech";
static const char c_szCPLAppearance[] = "Control Panel\\Appearance";
static const char c_szCPLColors[] = "Control Panel\\Colors";
static const char c_szCPLMetrics[] = "Control Panel\\Desktop\\WindowMetrics";
static const TCHAR c_szCTFTIPKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
static const TCHAR c_szCTFAssemblies[] = TEXT("SOFTWARE\\Microsoft\\CTF\\Assemblies\\");

REGWATCH CRegWatcher::_rgRegWatch[NUM_REG_WATCH] =
{
    { HKEY_CURRENT_USER,   c_szKbdToggleKey,    0 },
    { HKEY_LOCAL_MACHINE,  c_szCTFTIPKey,       0 },
    { HKEY_CURRENT_USER,   c_szKbdPreload,      0 },
    { HKEY_CURRENT_USER,   c_szRun,             0 },
    { HKEY_CURRENT_USER,   c_szCTFTIPKey,       0 },
    { HKEY_CURRENT_USER,   c_szSpeechKey,       0 },
    { HKEY_CURRENT_USER,   c_szCPLAppearance,   0 },
    { HKEY_CURRENT_USER,   c_szCPLColors,       0 },
    { HKEY_CURRENT_USER,   c_szCPLMetrics,      0 },
    { HKEY_LOCAL_MACHINE,  c_szSpeechKey,       0 },
    { HKEY_CURRENT_USER,   c_szKbdLayout,       0 },
    { HKEY_CURRENT_USER,   c_szCTFAssemblies,   0 },
};

HANDLE CRegWatcher::_rgEvent[NUM_REG_WATCH] = { 0 };

typedef LONG (STDAPICALLTYPE* PFNREGNOTIFYCHANGEKEYVALUE) ( HKEY,
                                                             BOOL,
                                                             DWORD,
                                                             HANDLE,
                                                             BOOL);

typedef HRESULT (STDAPICALLTYPE* PFNCREATELANGPROFILEUTIL) (ITfFnLangProfileUtil **);

PFNREGNOTIFYCHANGEKEYVALUE g_pfnRegNotifyChangeKeyValue = NULL;


//////////////////////////////////////////////////////////////////////////////
//
// CRegWatcher
//
//////////////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------------
//
//  Init
//
//--------------------------------------------------------------------------

BOOL CRegWatcher::Init()
{
    int i;
    BOOL bRet = FALSE;

    if (!IsOnNT())
    {
        _rgRegWatch[REG_WATCH_RUN].hKeyRoot = HKEY_LOCAL_MACHINE;
    }

    HMODULE hMod = LoadSystemLibrary("advapi32.dll"); // Issue: why no release?
    g_pfnRegNotifyChangeKeyValue = (PFNREGNOTIFYCHANGEKEYVALUE)GetProcAddress(hMod, "RegNotifyChangeKeyValue");

    if (!g_pfnRegNotifyChangeKeyValue)
    {
        Assert(0);
        goto Exit;
    }

    for (i = 0; i < NUM_REG_WATCH; i++)
    {
        if ((_rgEvent[i] = CreateEvent(NULL, TRUE, FALSE, NULL)) != 0)
        {
            InitEvent(i);
        }
    }

    KillInternat();

    UpdateSpTip();

    bRet = TRUE;

Exit:
    return bRet;
}

//--------------------------------------------------------------------------
//
//  Uninit
//
//--------------------------------------------------------------------------

void CRegWatcher::Uninit()
{
    int i;

    for (i = 0; i < NUM_REG_WATCH; i++)
    {
        RegCloseKey(_rgRegWatch[i].hKey);
        if (_rgEvent[i])
        {
            CloseHandle(_rgEvent[i]);
        }
    }
}

//--------------------------------------------------------------------------
//
//  RegImxTimerProc
//
//--------------------------------------------------------------------------
UINT_PTR CRegWatcher::nRegImxTimerId = 0;

void CRegWatcher::RegImxTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
     KillTimer(NULL, nRegImxTimerId);
     nRegImxTimerId = 0;

     TF_InvalidAssemblyListCache();
     TF_PostAllThreadMsg(TFPRIV_UPDATE_REG_IMX, TLF_LBIMGR);
}

//--------------------------------------------------------------------------
//
//  SysColorTimerProc
//
//--------------------------------------------------------------------------
UINT_PTR CRegWatcher::nSysColorTimerId = 0;

void CRegWatcher::SysColorTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
     KillTimer(NULL, nSysColorTimerId);
     nSysColorTimerId = 0;

     TF_PostAllThreadMsg(TFPRIV_SYSCOLORCHANGED, TLF_LBIMGR);
}

//--------------------------------------------------------------------------
//
//  KbdToggleTimerProc
//
//--------------------------------------------------------------------------
UINT_PTR CRegWatcher::nKbdToggleTimerId = 0;

void CRegWatcher::KbdToggleTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
     KillTimer(NULL, nKbdToggleTimerId);
     nKbdToggleTimerId = 0;

     TF_PostAllThreadMsg(TFPRIV_UPDATE_REG_KBDTOGGLE, TLF_LBIMGR);
}

//--------------------------------------------------------------------------
//
//  OnEvent
//
//--------------------------------------------------------------------------

void CRegWatcher::OnEvent(DWORD dwEventId)
{
    Assert(dwEventId < NUM_REG_WATCH); // bogus event?

    InitEvent(dwEventId, TRUE);

    switch (dwEventId)
    {
          case REG_WATCH_KBDTOGGLE:
              if (nKbdToggleTimerId)
              {
                  KillTimer(NULL, nKbdToggleTimerId);
                  nKbdToggleTimerId = 0;
              }

              nKbdToggleTimerId = SetTimer(NULL, 0, 500, KbdToggleTimerProc);
              break;

          case REG_WATCH_KBDLAYOUT:
          case REG_WATCH_KBDPRELOAD:
          case REG_WATCH_HKLM_IMX:
          case REG_WATCH_HKCU_IMX:
          case REG_WATCH_HKCU_ASSEMBLIES:
              if (nRegImxTimerId)
              {
                  KillTimer(NULL, nRegImxTimerId);
                  nRegImxTimerId = 0;
              }

              nRegImxTimerId = SetTimer(NULL, 0, 200, RegImxTimerProc);
              break;

          case REG_WATCH_RUN:
              KillInternat();
              break;

          case REG_WATCH_HKCU_SPEECH:
          case REG_WATCH_HKLM_SPEECH:
              UpdateSpTip();

              // Forcelly update assembly list
              // fix bug 4871
              if (nRegImxTimerId)
              {
                  KillTimer(NULL, nRegImxTimerId);
                  nRegImxTimerId = 0;
              }

              nRegImxTimerId = SetTimer(NULL, 0, 200, RegImxTimerProc);

              break;

          case REG_WATCH_HKCU_CPL_APPEARANCE:
          case REG_WATCH_HKCU_CPL_COLORS:
          case REG_WATCH_HKCU_CPL_METRICS:
              StartSysColorChangeTimer();
              break;

     }
}

//--------------------------------------------------------------------------
//
//  StartSysColorChangeTimer
//
//--------------------------------------------------------------------------

void CRegWatcher::StartSysColorChangeTimer()
{
    if (nSysColorTimerId)
    {
        KillTimer(NULL, nSysColorTimerId);
        nSysColorTimerId = 0;
    }

    nSysColorTimerId = SetTimer(NULL, 0, 500, SysColorTimerProc);
}


//--------------------------------------------------------------------------
//
//  InitEvent
//
//--------------------------------------------------------------------------

BOOL CRegWatcher::InitEvent(int nId, BOOL fReset)
{
    LONG lErrorCode;

    if (fReset)
        ::ResetEvent(_rgEvent[nId]);

    RegCloseKey(_rgRegWatch[nId].hKey);

    if (RegOpenKeyEx(_rgRegWatch[nId].hKeyRoot, _rgRegWatch[nId].pszKey, 0, KEY_READ, &_rgRegWatch[nId].hKey) == S_OK ||
        RegCreateKeyEx(_rgRegWatch[nId].hKeyRoot, _rgRegWatch[nId].pszKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &_rgRegWatch[nId].hKey, NULL) == S_OK)
    {
        Assert(g_pfnRegNotifyChangeKeyValue);
        lErrorCode = g_pfnRegNotifyChangeKeyValue(_rgRegWatch[nId].hKey,
                                             TRUE,
                                             REG_NOTIFY_CHANGE_NAME |
                                                REG_NOTIFY_CHANGE_LAST_SET,
                                             _rgEvent[nId],
                                             TRUE);

        if (lErrorCode != ERROR_SUCCESS)
        {
            Assert(0);
            return FALSE; 
        }

        return TRUE;
    }

    return FALSE;
}

//--------------------------------------------------------------------------
//
//  KillInternat
//
//--------------------------------------------------------------------------

void CRegWatcher::KillInternat()
{
    HKEY hKey;

    if (RegOpenKeyEx(_rgRegWatch[REG_WATCH_RUN].hKeyRoot, _rgRegWatch[REG_WATCH_RUN].pszKey, 0, KEY_ALL_ACCESS, &hKey) == S_OK)
    {
        RegDeleteValue(hKey, "internat.exe");
        RegCloseKey(hKey);
    }

    HWND hwndIndic = FindWindow(INDICATOR_CLASS, NULL);
    if (hwndIndic)
    {
        PostMessage(hwndIndic, WM_CLOSE, 0, 0);
    }
}


//--------------------------------------------------------------------------
//
//  UpdateSpTip
//
//--------------------------------------------------------------------------

#define WM_PRIV_SPEECHOPTION    WM_APP+2
const char c_szWorkerWndClass[] = "SapiTipWorkerClass";
const TCHAR c_szSapilayrKey[] = TEXT("SOFTWARE\\Microsoft\\CTF\\Sapilayr\\");
const TCHAR c_szProfileInit[] = TEXT("ProfileInitialized");
const TCHAR c_szSpTipFile[]   = TEXT("\\IME\\sptip.dll");
const TCHAR c_szTFCreateLangPropUtil[] = TEXT("TF_CreateLangProfileUtil");

extern "C" HRESULT WINAPI TF_InvalidAssemblyListCacheIfExist();

void CRegWatcher::UpdateSpTip()
{
    EnumWindows( EnumWndProc, NULL);

    // clear the key that states "we've init'ed profiles"
    //
    // 03/27/01 - for bug#4818, we re-enabled this piece of code for HKCU value
    //            instead of HKLM
    //
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szSapilayrKey, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
    {
        DWORD dw = 0;
        RegSetValueEx(hKey, c_szProfileInit, NULL, REG_DWORD, (const BYTE *)&dw, sizeof(dw));
        RegCloseKey(hKey);
    }

    //
    // ..then call into sptip's ITfFnLangProfileUtil to update sptip's profile
    // we probably don't need to do this at the moment app starts
    // if we don't need to register profiles at app boot, we also don't need
    // the code above to reset 'ProfileInit' - actually we need to remove this
    // code to fix bug 2801 or 3479 (not to access HKLM)
    //
    PFNCREATELANGPROFILEUTIL   pfnCreateLangProfUtil = NULL;
    ITfFnLangProfileUtil *pFnLangUtil = NULL;
    TCHAR szPathSpTip[MAX_PATH];
    HMODULE hSpTip = NULL;

    UINT uLength = GetSystemWindowsDirectory(szPathSpTip, ARRAYSIZE(szPathSpTip));
    if (uLength && 
        (ARRAYSIZE(szPathSpTip) > (uLength + ARRAYSIZE(c_szSpTipFile))))
    {
        _tcscat(szPathSpTip, c_szSpTipFile);
        hSpTip = LoadLibrary(szPathSpTip); // Issue: why no release?
    }
    if (hSpTip != NULL)
    {
        pfnCreateLangProfUtil = (PFNCREATELANGPROFILEUTIL)GetProcAddress(hSpTip, c_szTFCreateLangPropUtil);
    }

    HRESULT hr = E_FAIL;
    if (pfnCreateLangProfUtil != NULL)
    {
        hr = pfnCreateLangProfUtil(&pFnLangUtil);
    }

    if (S_OK == hr)
    { 
        if (S_OK == pFnLangUtil->RegisterActiveProfiles())
            TF_InvalidAssemblyListCacheIfExist();
    }

    if (pFnLangUtil)
        pFnLangUtil->Release();

    if (hSpTip != NULL)
    {
        FreeLibrary(hSpTip);
    }
}

BOOL CALLBACK CRegWatcher::EnumWndProc(HWND hwnd, LPARAM lparam)
{
    char szCls[MAX_PATH];
    if (GetClassNameA(hwnd, szCls, ARRAYSIZE(szCls)) > 0)
    {
        if ( 0 == lstrcmpiA(szCls, c_szWorkerWndClass) )
        {
            PostMessage(hwnd, WM_PRIV_SPEECHOPTION, 0, 0);
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\ctf.64\sptip\server.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       server.cpp
//
//  Contents:   COM server functionality.
//
//----------------------------------------------------------------------------
#include "windows.h"

//  DLL part of the Object
//
STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    return TRUE;
}

STDAPI DllRegisterServer(void)
{
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cicsthkl\lib\substhkl.cpp ===
#include "private.h"
#include "cicsthkl.h"

#define LANGIDFROMHKL(x) LANGID(LOWORD(HandleToLong(x)))

const CHAR c_szCTFTIPKey[] = "SOFTWARE\\Microsoft\\CTF\\TIP\\";
const CHAR c_szLanguageProfileKey[] = "LanguageProfile\\";
const CHAR c_szSubstitutehKL[] =      "SubstituteLayout";

//+------------------------------------------------------------------------
//
//  Function:   cicsthkl_CLSIDToString
//
//  Synopsis:   Converts a CLSID to an mbcs string.
//
//-------------------------------------------------------------------------

static const BYTE GuidMap[] = {3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
    8, 9, '-', 10, 11, 12, 13, 14, 15};

static const char szDigits[] = "0123456789ABCDEF";


BOOL cicsthkl_CLSIDToStringA(REFGUID refGUID, char *pchA)
{
    int i;
    char *p = pchA;

    const BYTE * pBytes = (const BYTE *) &refGUID;

    *p++ = '{';
    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = '-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *p++ = '}';
    *p   = '\0';

    return TRUE;
}

//+---------------------------------------------------------------------------
//
// cicsthkl_AsciiToNum
//
//----------------------------------------------------------------------------

DWORD cicsthkl_AsciiToNum( char *pszAscii)
{
   DWORD dwNum = 0;

   for (; *pszAscii; pszAscii++) {
       if (*pszAscii >= '0' && *pszAscii <= '9') {
           dwNum = (dwNum << 4) | (*pszAscii - '0');
       } else if (*pszAscii >= 'A' && *pszAscii <= 'F') {
           dwNum = (dwNum << 4) | (*pszAscii - 'A' + 0x000A);
       } else if (*pszAscii >= 'a' && *pszAscii <= 'f') {
           dwNum = (dwNum << 4) | (*pszAscii - 'a' + 0x000A);
       } else {
           return (0);
       }
   }

   return (dwNum);
}

//+---------------------------------------------------------------------------
//
// cicsthkl_NumToA
//
//----------------------------------------------------------------------------

void cicsthkl_NumToAscii(DWORD dw, char *psz)
{
    int n = 7;
    while (n >= 0)
    {
        BYTE b = (BYTE)(dw >> (n * 4)) & 0x0F;
        if (b < 0x0A)
           *psz = (char)('0' + b);
        else
           *psz = (char)('A' + b - 0x0A);
        psz++;
        n--;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// GetSubstituteHKLFromReg
//
//----------------------------------------------------------------------------

HKL GetSubstituteHKLFromReg(REFCLSID rclsid, LANGID langid, REFGUID rguid)
{
    HKL hKL = NULL;
    CHAR szKey[MAX_PATH];
    CHAR szTempStr[64];

    StringCchCopyA(szKey, ARRAYSIZE(szKey), c_szCTFTIPKey);
    cicsthkl_CLSIDToStringA(rclsid, szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), "\\");
    StringCchCatA(szKey, ARRAYSIZE(szKey), c_szLanguageProfileKey);
    StringCchPrintfA(szTempStr, ARRAYSIZE(szTempStr), "0x%08x", langid);
    StringCchCatA(szKey, ARRAYSIZE(szKey), szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), "\\");
    cicsthkl_CLSIDToStringA(rguid, szTempStr);
    StringCchCatA(szKey, ARRAYSIZE(szKey), szTempStr);

    HKEY hKey = NULL;
    LONG lRes = RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey);
    if (lRes == ERROR_SUCCESS)
    {
        DWORD dwType = NULL;
        char szValue[32];
        DWORD dwCount = sizeof(szValue);
        lRes = RegQueryValueExA(hKey, 
                               (LPTSTR)c_szSubstitutehKL,
                               NULL, 
                               &dwType,
                               (LPBYTE)szValue,
                               &dwCount);

        if (lRes == ERROR_SUCCESS)
        {
            if ((szValue[0] == '0') && 
                ((szValue[1] == 'X') || (szValue[1] == 'x')))
                hKL = (HKL)IntToPtr(cicsthkl_AsciiToNum(&szValue[2]));
        }

        RegCloseKey(hKey);
    }
    return hKL;

}

//----------------------------------------------------------------------------
// 
// [in] langid
//     langid may be LOWORD of the return value of GetKeyboardLayout(0).
//
// The return value
//     It returns NULL hKL 
//         - if Cicero does not have a focus
//         - it there is no keyboard TIP running now
//         - it the current keyboard TIP does not have a substitute layout.
//
//----------------------------------------------------------------------------
HRESULT CicGetSubstitueHKL(LANGID langid, HKL *phkl, BOOL fCheckFocus)
{
    HRESULT hr;
    ITfThreadMgr *ptim;

    *phkl = NULL;

    if (fCheckFocus)
    {
        BOOL fFocusInCicero = FALSE;
        if (SUCCEEDED(CoCreateInstance( CLSID_TF_ThreadMgr,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_ITfThreadMgr,
                                        (void **)&ptim))) {
 
            ITfDocumentMgr *pdim;
            if (SUCCEEDED(ptim->GetFocus(&pdim)) && pdim)
            {
                 fFocusInCicero = TRUE;
                 pdim->Release();
            }
            ptim->Release();
        }
 
        if (!fFocusInCicero)
        {
            //
            // Cicero does not have a focus. Try GetKeyboardLayout(0).
            //
            return S_FALSE;
        }
    }
 
    HKL hKL = NULL;
    ITfInputProcessorProfiles *pPro;

    if (SUCCEEDED(hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_ITfInputProcessorProfiles,
                                        (void **)&pPro ))) {
        CLSID clsid;
        GUID guid;
 
        ITfInputProcessorProfileSubstituteLayout *pProSubLayout;

        if (SUCCEEDED(hr = pPro->GetDefaultLanguageProfile(langid, 
                                                           GUID_TFCAT_TIP_KEYBOARD, 
                                                           &clsid, 
                                                           &guid)))
        {
            if (!IsEqualGUID(clsid, CLSID_NULL))
            {
                if (SUCCEEDED(hr = pPro->QueryInterface(IID_ITfInputProcessorProfileSubstituteLayout,
                                                        (void **)&pProSubLayout)))
                {
                    hr = pProSubLayout->GetSubstituteKeyboardLayout(clsid, 
                                                                    langid, 
                                                                    guid, 
                                                                    &hKL);
                    pProSubLayout->Release();
                }
                else
                {
                    hKL = GetSubstituteHKLFromReg(clsid, langid, guid);
                    hr = S_OK;
                }
            }
        }
        pPro->Release();
    }
 
    //
    // if hKL is NULL, please get hKL from GetKeybaordLayout(0).
    //
    *phkl = hKL;
    return hr;
}


//----------------------------------------------------------------------------
//
// CicSubstGetKeyboardLayout
//
//----------------------------------------------------------------------------

extern "C" HKL WINAPI CicSubstGetKeyboardLayout(char *pszKLID)
{
    HKL hkl = NULL;
    HKL hklReal = GetKeyboardLayout(0);

    if (SUCCEEDED(CicGetSubstitueHKL(LANGIDFROMHKL(hklReal), &hkl, TRUE)))
    {
        if (!hkl)
        {
            hkl = hklReal;
            if (pszKLID)
                GetKeyboardLayoutName(pszKLID);
        }
        else
        {
            if (pszKLID)
                cicsthkl_NumToAscii((DWORD)HandleToLong(hkl), pszKLID);
        }
    }
    return hkl;
}

//----------------------------------------------------------------------------
//
// CicSubstGetDefaultKeyboardLayout
//
//----------------------------------------------------------------------------

extern "C" HKL WINAPI CicSubstGetDefaultKeyboardLayout(LANGID langid)
{
    HKL hkl = NULL;

    CicGetSubstitueHKL(langid, &hkl, FALSE);

    return hkl;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuiarray.cpp ===
//
// cuiarray.cpp
//  = array object in CUILib =
//

#include "private.h"
#include "cuiarray.h"

/*=============================================================================*/
/*                                                                             */
/*   C  U I F  O B J E C T  A R R A Y                                          */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  O B J E C T  A R R A Y   */
/*------------------------------------------------------------------------------

    constructor of CUIFObjectArrayBase

------------------------------------------------------------------------------*/
CUIFObjectArrayBase::CUIFObjectArrayBase( void )
{
    m_pBuffer = NULL;
    m_nBuffer = 0;
    m_nObject = 0;
}


/*   ~  C  U I F  O B J E C T  A R R A Y   */
/*------------------------------------------------------------------------------

    destructor of CUIFObjectArrayBase

------------------------------------------------------------------------------*/
CUIFObjectArrayBase::~CUIFObjectArrayBase( void )
{
    if (m_pBuffer) {
        MemFree( m_pBuffer );
    }
}


/*   A D D   */
/*------------------------------------------------------------------------------

    Add object to the list

------------------------------------------------------------------------------*/
BOOL CUIFObjectArrayBase::Add( void *pv )
{
    // sanity check

    if (pv == NULL) {
        Assert( FALSE );
        return FALSE;
    }

    // check if the object is alrady in the list

    if (0 <= Find( pv )) {
        return FALSE;
    }

    // ensure buffer size

    if (!EnsureBuffer( m_nObject + 1 )) {
        return FALSE;
    }

    // add to list

    Assert( m_nObject < m_nBuffer );
    m_pBuffer[ m_nObject ] = pv;

    m_nObject++;
    return TRUE;
}


/*   R E M O V E   */
/*------------------------------------------------------------------------------

    Remove object from the list

------------------------------------------------------------------------------*/
BOOL CUIFObjectArrayBase::Remove( void *pv )
{
    int i;

    // sanity check

    if (pv == NULL) {
        Assert( FALSE );
        return FALSE;
    }

    // check if the object is in the list

    i = Find( pv );
    if (i < 0) {
        return FALSE;
    }

    // remove from the list

    if (i < m_nObject - 1) {
        MemMove( &m_pBuffer[ i ], &m_pBuffer[ i+1 ], (m_nObject-i-1) * sizeof(void*) );
    }

    m_nObject--;
    return TRUE;
}


/*   G E T  C O U N T   */
/*------------------------------------------------------------------------------

    Get count of objects in the list

------------------------------------------------------------------------------*/
int CUIFObjectArrayBase::GetCount( void )
{
    return m_nObject;
}


/*   G E T   */
/*------------------------------------------------------------------------------

    Get object in the list

------------------------------------------------------------------------------*/
void *CUIFObjectArrayBase::Get( int i )
{
    if (i < 0 || m_nObject <= i) {
        return NULL;
    }

    return m_pBuffer[ i ];
}


/*   G E T  F I R S T   */
/*------------------------------------------------------------------------------

    Get fist object in the list

------------------------------------------------------------------------------*/
void *CUIFObjectArrayBase::GetFirst( void )
{
    return Get( 0 );
}


/*   G E T  L A S T   */
/*------------------------------------------------------------------------------

    Get last object in the list

------------------------------------------------------------------------------*/
void *CUIFObjectArrayBase::GetLast( void )
{
    return Get( m_nObject - 1 );
}


/*   F I N D   */
/*------------------------------------------------------------------------------

    Find object 
    Returns index of object in list when found, -1 when not found.

------------------------------------------------------------------------------*/
int CUIFObjectArrayBase::Find( void *pv )
{
    int i;

    for (i = 0; i < m_nObject; i++) {
        if (m_pBuffer[i] == pv) {
            return i;
        }
    }

    return -1;
}


/*   E N S U R E  B U F F E R   */
/*------------------------------------------------------------------------------

    Ensure buffer size (create/enlarge buffer when no more room)
    Returns TRUE when buffer size is enough, FALSE when error occured

------------------------------------------------------------------------------*/
BOOL CUIFObjectArrayBase::EnsureBuffer( int iSize )
{
    void **pBufferNew;
    int        nBufferNew;

    Assert( 0 < iSize );

    // check if there is room

    if (iSize <= m_nBuffer) {
        Assert( m_pBuffer != NULL );
        return TRUE;
    }

    // calc new buffer size

    nBufferNew = ((iSize - 1) / 16 + 1) * 16;

    // create new buffer

    if (m_pBuffer == NULL) {
        Assert( m_nBuffer == 0 );
        pBufferNew = (void**)MemAlloc( nBufferNew * sizeof(void*) );
    }
    else {
        Assert( 0 < m_nBuffer );
        pBufferNew = (void**)MemReAlloc( m_pBuffer, nBufferNew * sizeof(void*) );
    }

    // check if buffer has been created

    if (pBufferNew == NULL) {
        Assert( FALSE );
        return FALSE;
    }

    // update buffer info

    m_pBuffer = pBufferNew;
    m_nBuffer = nBufferNew;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuidebug.h ===
//
// cuidebug.h
//  = debug functions in CUILIB =
//

#ifndef CUIDEBUG_H
#define CUIDEBUG_H

#if defined(_DEBUG) || defined(DEBUG)

//
// debug version 
//

void CUIAssertProc( LPCTSTR szFile, int iLine, LPCSTR szEval );

#define Assert( f ) { if (!(BOOL)(f)) { CUIAssertProc( __FILE__, __LINE__, #f ); } }

#else /* !DEBUG */

//
// release version
//

#define Assert( f ) 

#endif /* !DEBUG */

#endif /* CUIDEBUG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuibln.cpp ===
//
// cuibln.cpp - ui frame object for balloon message window
//

#include "private.h"
#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuibln.h"
#include "cuiutil.h"
#include "cresstr.h"
#include "cuires.h"


//
// constants
//

#define cxyTailWidth        10
#define cxyTailHeight       16
#define cxRoundSize         16
#define cyRoundSize         16

#define WM_HOOKEDKEY        (WM_USER + 0x0001)


//

/*   C  U I F  B A L L O O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFBalloonButton::CUIFBalloonButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton( pParent, dwID, prc, dwStyle )
{
    m_iButtonID = 0;
}


/*   ~  C  U I F  B A L L O O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFBalloonButton::~CUIFBalloonButton( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonButton::OnPaint( HDC hDC )
{
    HDC      hDCMem = NULL;
    HBITMAP  hBmMem = NULL;
    HBITMAP  hBmMemOld = NULL;
    BOOL     fDownFace = FALSE;
    COLORREF colLTFrame;
    COLORREF colRBFrame;
    HBRUSH   hBrush;
    HBRUSH   hBrushOld;
    HPEN     hPen;
    HPEN     hPenOld;
    RECT     rcItem;

    rcItem = GetRectRef();
    OffsetRect( &rcItem, -rcItem.left, -rcItem.top );

    // create memory DC

    hDCMem = CreateCompatibleDC( hDC );
    hBmMem = CreateCompatibleBitmap( hDC, rcItem.right, rcItem.bottom );
    hBmMemOld = (HBITMAP)SelectObject( hDCMem, hBmMem );

    // determine button image

    switch (m_dwStatus) {
        default: {
            colLTFrame = GetSysColor( COLOR_INFOBK );
            colRBFrame = GetSysColor( COLOR_INFOBK );
            fDownFace = FALSE;
            break;
        }

        case UIBUTTON_DOWN: {
            colLTFrame = GetSysColor( COLOR_3DSHADOW );
            colRBFrame = GetSysColor( COLOR_3DHILIGHT );
            fDownFace = TRUE;
            break;
        }

        case UIBUTTON_HOVER: {
            colLTFrame = GetSysColor( COLOR_3DHILIGHT );
            colRBFrame = GetSysColor( COLOR_3DSHADOW );
            fDownFace = FALSE;
            break;
        }

        case UIBUTTON_DOWNOUT: {
            colLTFrame = GetSysColor( COLOR_3DHILIGHT );
            colRBFrame = GetSysColor( COLOR_3DSHADOW );
            fDownFace = FALSE;
            break;
        }
    }

    // paint button face

    hBrush = CreateSolidBrush( GetSysColor( COLOR_INFOBK ) );
    FillRect( hDCMem, &rcItem, hBrush );
    DeleteObject( hBrush );

    // paint image on button

    DrawTextProc( hDCMem, &rcItem, fDownFace );

    // paint button frame (hilight/shadow)

    hBrushOld = (HBRUSH)SelectObject( hDCMem, GetStockObject( NULL_BRUSH ) );
    hPen = CreatePen( PS_SOLID, 0, colLTFrame );
    hPenOld = (HPEN)SelectObject( hDCMem, hPen );
    RoundRect( hDCMem, rcItem.left, rcItem.top, rcItem.right - 1, rcItem.bottom - 1, 6, 6 );
    SelectObject( hDCMem, hPenOld );
    DeleteObject( hPen );

    hPen = CreatePen( PS_SOLID, 0, colRBFrame );
    hPenOld = (HPEN)SelectObject( hDCMem, hPen );
    RoundRect( hDCMem, rcItem.left + 1, rcItem.top + 1, rcItem.right, rcItem.bottom, 6, 6 );
    SelectObject( hDCMem, hPenOld );
    DeleteObject( hPen );

    // paint button frame (fixed)

    hPen = CreatePen( PS_SOLID, 0, GetSysColor( COLOR_3DFACE ) );
    hPenOld = (HPEN)SelectObject( hDCMem, hPen );
    RoundRect( hDCMem, rcItem.left + 1, rcItem.top + 1, rcItem.right - 1, rcItem.bottom - 1, 6, 6 );
    SelectObject( hDCMem, hPenOld );
    DeleteObject( hPen );

    SelectObject( hDCMem, hBrushOld );

    //

    BitBlt( hDC, 
            GetRectRef().left, 
            GetRectRef().top, 
            GetRectRef().right - GetRectRef().left, 
            GetRectRef().bottom - GetRectRef().top, 
            hDCMem, 
            rcItem.left, 
            rcItem.top, 
            SRCCOPY );

    //

    SelectObject( hDCMem, hBmMemOld );
    DeleteObject( hBmMem );
    DeleteDC( hDCMem );
}


/*   G E T  B U T T O N  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFBalloonButton::GetButtonID( void )
{
    return m_iButtonID;
}


/*   S E T  B U T T O N  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonButton::SetButtonID( int iButtonID )
{
    m_iButtonID = iButtonID;
}


/*   D R A W  T E X T  P R O C   */
/*------------------------------------------------------------------------------

    Draw text on button face

------------------------------------------------------------------------------*/
void CUIFBalloonButton::DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    HFONT       hFontOld;
    COLORREF    colTextOld;
    int         iBkModeOld;
    DWORD       dwAlign = 0;
    RECT        rc;

    //

    if (m_pwchText == NULL) {
        return;
    }

    //

    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    // calc text width

    switch (m_dwStyle & UIBUTTON_HALIGNMASK) {
        case UIBUTTON_LEFT:
        default: {
            dwAlign |= DT_LEFT;
            break;
        }

        case UIBUTTON_CENTER: {
            dwAlign |= DT_CENTER;
            break;
        }

        case UIBUTTON_RIGHT: {
            dwAlign |= DT_RIGHT;
            break;
        }
    }

    switch (m_dwStyle & UIBUTTON_VALIGNMASK) {
        case UIBUTTON_TOP:
        default: {
            dwAlign |= DT_TOP;
            break;
        }

        case UIBUTTON_VCENTER: {
            dwAlign |= DT_VCENTER;
            break;
        }

        case UIBUTTON_BOTTOM: {
            dwAlign |= DT_BOTTOM;
            break;
        }
    }

    //

    colTextOld = SetTextColor( hDC, GetSysColor( COLOR_BTNTEXT ) );
    iBkModeOld = SetBkMode( hDC, TRANSPARENT );

    rc = *prc;
    if (fDown) {
        OffsetRect( &rc, +1, +1 );
    }
    CUIDrawText( hDC, m_pwchText, -1, &rc, dwAlign | DT_SINGLELINE );

    SetBkMode( hDC, iBkModeOld );
    SetTextColor( hDC, colTextOld );
    SelectObject( hDC, hFontOld );
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B A L L O O N  W I N D O W                                      */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B A L L O O N  W I N D O W   */
/*------------------------------------------------------------------------------

    Constructor of CUIFBalloonWindow

------------------------------------------------------------------------------*/
CUIFBalloonWindow::CUIFBalloonWindow( HINSTANCE hInst, DWORD dwStyle ) : CUIFWindow( hInst, dwStyle )
{
    m_hWindowRgn        = NULL;
    m_pwszText          = NULL;
    m_rcMargin.left     = 8;
    m_rcMargin.top      = 8;
    m_rcMargin.right    = 8;
    m_rcMargin.bottom   = 8;
    m_iMaxTxtWidth      = -1;
    m_fColBack          = FALSE;
    m_fColText          = FALSE;
    m_colBack           = RGB( 0, 0, 0 );
    m_colText           = RGB( 0, 0, 0 );
    m_ptTarget.x        = 0;
    m_ptTarget.y        = 0;
    m_rcExclude.left    = 0;
    m_rcExclude.right   = 0;
    m_rcExclude.top     = 0;
    m_rcExclude.bottom  = 0;
    m_posDef            = BALLOONPOS_ABOVE;
    m_pos               = BALLOONPOS_ABOVE;
    m_dir               = BALLOONDIR_LEFT;
    m_align             = BALLOONALIGN_CENTER;
    m_ptTail.x          = 0;
    m_ptTail.y          = 0;
    m_nButton           = 0;
    m_iCmd              = -1;
    m_hWndNotify        = 0;
    m_uiMsgNotify       = WM_NULL;
}


/*   ~  C  U I F  B A L L O O N  W I N D O W   */
/*------------------------------------------------------------------------------

    Destructor of CUIFBalloonWindow

------------------------------------------------------------------------------*/
CUIFBalloonWindow::~CUIFBalloonWindow( void )
{
    if (m_pwszText != NULL) {
        delete m_pwszText;
    }
}


/*   G E T  C L A S S  N A M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCTSTR CUIFBalloonWindow::GetClassName( void )
{
    return TEXT(WNDCLASS_BALLOONWND);
}


/*   G E T  W N D  T I T L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCTSTR CUIFBalloonWindow::GetWndTitle( void )
{
    return TEXT(WNDTITLE_BALLOONWND);
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize UI window object
    (UIFObject method)

------------------------------------------------------------------------------*/
CUIFObject *CUIFBalloonWindow::Initialize( void )
{
    CUIFObject *pUIObj = CUIFWindow::Initialize();

    // create buttons

    switch (GetStyleBits( UIBALLOON_BUTTONS )) {
        case UIBALLOON_OK: {
            AddButton( IDOK );
            break;
        }

        case UIBALLOON_YESNO: {
            AddButton( IDYES );
            AddButton( IDNO );
            break;
        }
    }

    return pUIObj;
}


/*   O N  C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnCreate( HWND hWnd )
{
    UNREFERENCED_PARAMETER( hWnd );

    m_iCmd = -1;
    AdjustPos();
}


/*   O N  D E S T R O Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnDestroy( HWND hWnd )
{
    UNREFERENCED_PARAMETER( hWnd );

    SendNotification( m_iCmd );
    DoneWindowRegion();
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint window object
    (UIFObject method)

------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnPaint( HDC hDC )
{
    RECT rcClient;
    RECT rcMargin;

    // paint balloon frame

    GetRect( &rcClient );
    PaintFrameProc( hDC, &rcClient );

    // paint message

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            rcClient.bottom -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_BELLOW: {
            rcClient.top += cxyTailHeight;
            break;
        }

        case BALLOONPOS_LEFT: {
            rcClient.right -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_RIGHT: {
            rcClient.left += cxyTailHeight;
            break;
        }
    }

    GetMargin( &rcMargin );
    rcClient.left   = rcClient.left   + rcMargin.left;
    rcClient.top    = rcClient.top    + rcMargin.top;
    rcClient.right  = rcClient.right  - rcMargin.right;
    rcClient.bottom = rcClient.bottom - rcMargin.bottom;

    PaintMessageProc( hDC, &rcClient, m_pwszText );
}


/*   O N  K E Y  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::OnKeyDown( HWND hWnd, WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( hWnd );
    UNREFERENCED_PARAMETER( lParam );

    BOOL fEnd = FALSE;

    switch (wParam) {
        case VK_RETURN: {
            CUIFBalloonButton *pUIBtn = (CUIFBalloonButton *)FindUIObject( 0 ); /* first button */

            if (pUIBtn != NULL) {
                m_iCmd = pUIBtn->GetButtonID();
                fEnd = TRUE;
            }
            break;
        }

        case VK_ESCAPE: {
            m_iCmd = -1;
            fEnd = TRUE;
            break;
        }

        case 'Y': {
            CUIFBalloonButton *pUIBtn = FindButton( IDYES );

            if (pUIBtn != NULL) {
                m_iCmd = pUIBtn->GetButtonID();
                fEnd = TRUE;
            }
            break;
        }

        case 'N': {
            CUIFBalloonButton *pUIBtn = FindButton( IDNO );

            if (pUIBtn != NULL) {
                m_iCmd = pUIBtn->GetButtonID();
                fEnd = TRUE;
            }
            break;
        }
    }

    if (fEnd) {
        DestroyWindow( GetWnd() );
    }
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
    UNREFERENCED_PARAMETER( dwCommand );
    UNREFERENCED_PARAMETER( lParam );

    m_iCmd = ((CUIFBalloonButton*)pUIObj)->GetButtonID();
    DestroyWindow( GetWnd() );

    return 0;
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetText( LPCWSTR pwchMessage )
{
    if (m_pwszText != NULL) {
        delete m_pwszText;
        m_pwszText = NULL;
    }

    if (pwchMessage != NULL) {
        int l = lstrlenW( pwchMessage );

        m_pwszText = new WCHAR[ l+1 ];
        if (m_pwszText)
            StrCpyW( m_pwszText, pwchMessage );
    }
    else {
        m_pwszText = new WCHAR[1];
        if (m_pwszText)
            *m_pwszText = L'\0';
    }

    AdjustPos();
    return 0;
}


/*   S E T  N O T I F Y  W I N D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetNotifyWindow( HWND hWndNotify, UINT uiMsgNotify )
{
    m_hWndNotify = hWndNotify;
    m_uiMsgNotify = uiMsgNotify;

    return 0;
}


/*   S E T  B A L L O O N  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonPos( BALLOONWNDPOS pos )
{
    m_posDef = pos;
    AdjustPos();

    return 0;
}


/*   S E T  B A L L O O N  A L I G N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonAlign( BALLOONWNDALIGN align )
{
    m_align = align;
    AdjustPos();

    return 0;
}


/*   G E T  B K  C O L O R   */
/*------------------------------------------------------------------------------

    Retrieves the background color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetBalloonBkColor( void )
{ 
    if (m_fColBack) {
        return (LRESULT)m_colBack;
    }
    else {
        return (LRESULT)GetSysColor( COLOR_INFOBK );
    }
}


/*   G E T  T E X T  C O L O R   */
/*------------------------------------------------------------------------------

    Retrieves the text color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetBalloonTextColor( void )
{ 
    if (m_fColText) {
        return (LRESULT)m_colText;
    }
    else {
        return (LRESULT)GetSysColor( COLOR_INFOTEXT );
    }
}


/*   G E T  M A R G I N   */
/*------------------------------------------------------------------------------

    Retrieves the top, left, bottom, and right margins set for a tooltip window. 
    A margin is the distance, in pixels, between the tooltip window border and 
    the text contained within the tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetMargin( RECT *prc )
{
    if (prc == NULL) {
        return 0;
    }

    *prc = m_rcMargin;
    return 0;
}


/*   G E T  M A X  T I P  W I D T H   */
/*------------------------------------------------------------------------------

    Retrieves the maximum width for a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::GetMaxBalloonWidth( void )
{
    return m_iMaxTxtWidth;
}


/*   S E T  B K  C O L O R   */
/*------------------------------------------------------------------------------

    Sets the background color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonBkColor( COLORREF col )
{ 
    m_fColBack = TRUE;
    m_colBack = col;

    return 0;
}


/*   S E T  T E X T  C O L O R   */
/*------------------------------------------------------------------------------

    Sets the text color in a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetBalloonTextColor( COLORREF col )
{ 
    m_fColText = TRUE;
    m_colText = col;

    return 0;
}


/*   S E T  M A R G I N   */
/*------------------------------------------------------------------------------

    Sets the top, left, bottom, and right margins for a tooltip window. A margin 
    is the distance, in pixels, between the tooltip window border and the text 
    contained within the tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetMargin( RECT *prc )
{
    if (prc == NULL) {
        return 0;
    }

    m_rcMargin = *prc;
    return 0;
}


/*   S E T  M A X  T I P  W I D T H   */
/*------------------------------------------------------------------------------

     Sets the maximum width for a tooltip window. 

------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetMaxBalloonWidth( INT iWidth )
{
    m_iMaxTxtWidth = iWidth;
    return 0;
}


/*   S E T  B U T T O N  T E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetButtonText( int idCmd, LPCWSTR pwszText )
{
    CUIFBalloonButton *pUIBtn = FindButton( idCmd );

    if (pUIBtn != NULL) {
        pUIBtn->SetText( pwszText );
    }

    return 0;
}


/*   S E T  T A R G E T  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetTargetPos( POINT pt )
{
    m_ptTarget = pt;
    AdjustPos();

    return 0;
}


/*   S E T  E X C L U D E  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFBalloonWindow::SetExcludeRect( const RECT *prcExclude )
{
    m_rcExclude = *prcExclude;
    AdjustPos();

    return 0;
}


/*   C R E A T E  R E G I O N   */
/*------------------------------------------------------------------------------


    
------------------------------------------------------------------------------*/
HRGN CUIFBalloonWindow::CreateRegion( RECT *prc )
{
    POINT   rgPt[4];
    HRGN    hRgn;
    HRGN    hRgnTail;

    // create message body window

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right, 
                        prc->bottom - cxyTailHeight, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right, 
                        prc->bottom - cxyTailHeight );
#endif // UNDER_CE

            rgPt[0].x = m_ptTail.x;
            rgPt[0].y = prc->bottom - 1 - cxyTailHeight;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = m_ptTail.x + cxyTailWidth * (m_dir == BALLOONDIR_LEFT ? +1 : -1 );
            rgPt[2].y = prc->bottom - 1 - cxyTailHeight;
            rgPt[3] = rgPt[0];
            break;
        }

        case BALLOONPOS_BELLOW: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left, 
                        prc->top + cxyTailHeight, 
                        prc->right, 
                        prc->bottom, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left, 
                        prc->top + cxyTailHeight, 
                        prc->right, 
                        prc->bottom );
#endif // UNDER_CE

            rgPt[0].x = m_ptTail.x;
            rgPt[0].y = prc->top + cxyTailHeight;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = m_ptTail.x + cxyTailWidth * (m_dir == BALLOONDIR_LEFT ? +1 : -1 );
            rgPt[2].y = prc->top + cxyTailHeight;
            rgPt[3] = rgPt[0];
            break;
        }

        case BALLOONPOS_LEFT: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right - cxyTailHeight, 
                        prc->bottom, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left, 
                        prc->top, 
                        prc->right - cxyTailHeight, 
                        prc->bottom );
#endif // UNDER_CE

            rgPt[0].x = prc->right - 1 - cxyTailHeight;
            rgPt[0].y = m_ptTail.y;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = prc->right - 1 - cxyTailHeight;
            rgPt[2].y = m_ptTail.y + cxyTailWidth * (m_dir == BALLOONDIR_UP ? +1 : -1 );
            rgPt[3] = rgPt[0];
            break;
        }

        case BALLOONPOS_RIGHT: {
#ifndef UNDER_CE // CE does not support RoundRectRgn
            hRgn = CreateRoundRectRgn( 
                        prc->left + cxyTailHeight, 
                        prc->top, 
                        prc->right, 
                        prc->bottom, 
                        cxRoundSize, 
                        cyRoundSize );
#else // UNDER_CE
            hRgn = CreateRectRgn( 
                        prc->left + cxyTailHeight, 
                        prc->top, 
                        prc->right, 
                        prc->bottom );
#endif // UNDER_CE

            rgPt[0].x = prc->left + cxyTailHeight;
            rgPt[0].y = m_ptTail.y;

            rgPt[1].x = m_ptTail.x;
            rgPt[1].y = m_ptTail.y;

            rgPt[2].x = prc->left + cxyTailHeight;
            rgPt[2].y = m_ptTail.y + cxyTailWidth * (m_dir == BALLOONDIR_UP ? +1 : -1 );
            rgPt[3] = rgPt[0];
            break;
        }
    }

    // add balloon tail region

#ifndef UNDER_CE // tmptmp CE does not support. check later !!
    hRgnTail = CreatePolygonRgn( rgPt, 4, WINDING );
#endif // UNDER_CE
    CombineRgn( hRgn, hRgn, hRgnTail, RGN_OR );
    DeleteRgn( hRgnTail );

    return hRgn;
}


/*   P A I N T  F R A M E  P R O C   */
/*------------------------------------------------------------------------------


    
------------------------------------------------------------------------------*/
void CUIFBalloonWindow::PaintFrameProc( HDC hDC, RECT *prc )
{
    HRGN        hRgn;
    HBRUSH      hBrushFrm;
    HBRUSH      hBrushWnd;

    Assert( hDC != NULL );

    hRgn = CreateRegion( prc );
    hBrushWnd = CreateSolidBrush( (COLORREF)GetBalloonBkColor() );
    hBrushFrm = CreateSolidBrush( GetSysColor( COLOR_WINDOWFRAME ) );

    FillRgn( hDC, hRgn, hBrushWnd );
#ifndef UNDER_CE // tmptmp CE does not support. check later !!
    FrameRgn( hDC, hRgn, hBrushFrm, 1, 1 );
#endif // UNDER_CE

    DeleteObject( hBrushWnd );
    DeleteObject( hBrushFrm );

    DeleteObject( hRgn );
}


/*   P A I N T  M E S S A G E  P R O C   */
/*------------------------------------------------------------------------------


    
------------------------------------------------------------------------------*/
void CUIFBalloonWindow::PaintMessageProc( HDC hDC, RECT *prc, WCHAR *pwszText )
{
    HFONT       hFontOld;
    COLORREF    colTextOld;
    int         iBkModeOld;

    Assert( hDC != NULL );

    hFontOld = (HFONT)SelectObject( hDC, m_hFont );
    colTextOld = SetTextColor( hDC, (COLORREF)GetBalloonTextColor() );
    iBkModeOld = SetBkMode( hDC, TRANSPARENT );

    CUIDrawText( hDC, pwszText, -1, prc, DT_LEFT | DT_WORDBREAK );

    SelectObject( hDC, hFontOld );
    SetTextColor( hDC, colTextOld );
    SetBkMode( hDC, iBkModeOld );
}


/*   I N I T  W I N D O W  R E G I O N   */
/*------------------------------------------------------------------------------

    Set window region

------------------------------------------------------------------------------*/
void CUIFBalloonWindow::InitWindowRegion( void )
{
    RECT rcClient;

    GetRect( &rcClient );
    m_hWindowRgn = CreateRegion( &rcClient );

    if (m_hWindowRgn != NULL) {
        SetWindowRgn( GetWnd(), m_hWindowRgn, TRUE );
    }
}


/*   D O N E  W I N D O W  R E G I O N   */
/*------------------------------------------------------------------------------

    Reset window region

------------------------------------------------------------------------------*/
void CUIFBalloonWindow::DoneWindowRegion( void )
{
    if (m_hWindowRgn != NULL) {
        SetWindowRgn( GetWnd(), NULL, TRUE );

        DeleteObject( m_hWindowRgn );
        m_hWindowRgn = NULL;
    }
}


/*   G E T  B U T T O N  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::GetButtonSize( SIZE *pSize )
{
    HDC         hDC;
    HFONT       hFontOld;
    TEXTMETRIC  TM;

    // get text metrics

#ifndef UNDER_CE // DCA => DCW
    hDC = CreateDC( "DISPLAY", NULL, NULL, NULL );
#else // UNDER_CE
    hDC = CreateDCW( L"DISPLAY", NULL, NULL, NULL );
#endif // UNDER_CE
    hFontOld = (HFONT)SelectObject( hDC, GetFont() );
    GetTextMetrics( hDC, &TM );
    SelectObject( hDC, hFontOld );
    DeleteDC( hDC );

    // calc button size

    pSize->cx = TM.tmAveCharWidth * 16;
    pSize->cy = TM.tmHeight + 10;
}


/*   A D J U S T  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::AdjustPos( void )
{
    HDC        hDC;
    HFONT      hFontOld;
    TEXTMETRIC TM;
    RECT       rcWork;
    RECT       rcWindow = {0};
    SIZE       WndSize;
    RECT       rcText;
    SIZE       BtnSize;

    if (!IsWindow( GetWnd() )) {
        return;
    }
    if (m_pwszText == NULL) {
        return;
    }

    //

    GetButtonSize( &BtnSize );

    // get text size

#ifndef UNDER_CE // DCA => DCW
    hDC = GetDC( GetWnd() );    //CreateDC( "DISPLAY", NULL, NULL, NULL );
#else // UNDER_CE
    hDC = GetDCW( GetWnd() );   //CreateDCW( L"DISPLAY", NULL, NULL, NULL );
#endif // UNDER_CE
    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    GetTextMetrics( hDC, &TM );
    rcText.left   = 0;
    rcText.right  = TM.tmAveCharWidth * 40;
    rcText.top    = 0;
    rcText.bottom = 0;

    if (0 < m_nButton) {
        rcText.right  = max( rcText.right, BtnSize.cx*m_nButton + BtnSize.cx/2*(m_nButton-1) );
    }
    
    CUIDrawText( hDC, m_pwszText, -1, &rcText, DT_LEFT | DT_WORDBREAK | DT_CALCRECT );

    SelectObject( hDC, hFontOld );
    ReleaseDC( GetWnd(), hDC );

    //
    // determine window size
    //

    // max width

    if (0 < m_nButton) {
        rcText.right  = max( rcText.right, BtnSize.cx*m_nButton + BtnSize.cx/2*(m_nButton-1) );
    }

    // client width

    WndSize.cx = (rcText.right - rcText.left)
                + m_rcMargin.left
                + m_rcMargin.right;
    WndSize.cy = (rcText.bottom - rcText.top)
                + m_rcMargin.top
                + m_rcMargin.bottom;

    // tail width

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE:
        case BALLOONPOS_BELLOW: {
            WndSize.cy += cxyTailHeight;     /* balloon tail height */
            break;
        }

        case BALLOONPOS_LEFT:
        case BALLOONPOS_RIGHT: {
            WndSize.cx += cxyTailHeight;     /* balloon tail height */
            break;
        }
    }

    // buton height

    if (0 < m_nButton) {
        WndSize.cy += m_rcMargin.bottom + BtnSize.cy;        /* margin and button height */ 
    }

    //
    // determine tip window place
    //

    SystemParametersInfo( SPI_GETWORKAREA, 0, &rcWork, 0 );
    if (CUIIsMonitorAPIAvail()) {
        HMONITOR    hMonitor;
        MONITORINFO MonitorInfo;

        hMonitor = CUIMonitorFromPoint( m_ptTarget, MONITOR_DEFAULTTONEAREST );
        if (hMonitor != NULL) {
            MonitorInfo.cbSize = sizeof(MonitorInfo);
            if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
                rcWork = MonitorInfo.rcMonitor;
            }
        }
    }

    m_pos = m_posDef;
    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            if (m_rcExclude.top - WndSize.cy < rcWork.top) {
                // cannot locate the tip window at above. can put it at bellow?

                if (m_rcExclude.bottom + WndSize.cy < rcWork.bottom) { 
                    m_pos = BALLOONPOS_BELLOW;
                }
            }
            break;
        }

        case BALLOONPOS_BELLOW: {
            if (rcWork.bottom <= m_rcExclude.bottom + WndSize.cy) {
                // cannot locate the tip window at bellow. can put it at above?

                if (rcWork.top < m_rcExclude.top - WndSize.cy) { 
                    m_pos = BALLOONPOS_ABOVE;
                }
            }
            break;
        }

        case BALLOONPOS_LEFT: {
            if (m_rcExclude.left - WndSize.cx < rcWork.left) {
                // cannot locate the tip window at left. can put it at right?

                if (m_rcExclude.right + WndSize.cx < rcWork.right) { 
                    m_pos = BALLOONPOS_RIGHT;
                }
            }
            break;
        }

        case BALLOONPOS_RIGHT: {
            if (rcWork.right <= m_rcExclude.right + WndSize.cx) {
                // cannot locate the tip window at right. can put it at left?

                if (rcWork.left < m_rcExclude.left - WndSize.cx) { 
                    m_pos = BALLOONPOS_LEFT;
                }
            }
            break;
        }
    }

    //
    // calc window position
    //

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.left = m_ptTarget.x - WndSize.cx / 2;
                    break;
                }

                case BALLOONALIGN_LEFT: {
                    rcWindow.left = m_rcExclude.left;
                    break;
                }

                case BALLOONALIGN_RIGHT: {
                    rcWindow.left = m_rcExclude.right - WndSize.cx;
                    break;
                }
            }

            rcWindow.top  = m_rcExclude.top - WndSize.cy;
            break;
        }

        case BALLOONPOS_BELLOW: {
            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.left = m_ptTarget.x - WndSize.cx / 2;
                    break;
                }

                case BALLOONALIGN_LEFT: {
                    rcWindow.left = m_rcExclude.left;
                    break;
                }

                case BALLOONALIGN_RIGHT: {
                    rcWindow.left = m_rcExclude.right - WndSize.cx;
                    break;
                }
            }

            rcWindow.top  = m_rcExclude.bottom;
            break;
        }

        case BALLOONPOS_LEFT: {
            rcWindow.left = m_rcExclude.left - WndSize.cx;

            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.top  = m_ptTarget.y - WndSize.cy / 2;
                    break;
                }

                case BALLOONALIGN_TOP: {
                    rcWindow.top  = m_rcExclude.top;
                    break;
                }

                case BALLOONALIGN_BOTTOM: {
                    rcWindow.top = m_rcExclude.bottom - WndSize.cy;
                    break;
                }
            }
            break;
        }

        case BALLOONPOS_RIGHT: {
            rcWindow.left = m_rcExclude.right;

            switch (m_align) {
                default:
                case BALLOONALIGN_CENTER: {
                    rcWindow.top  = m_ptTarget.y - WndSize.cy / 2;
                    break;
                }

                case BALLOONALIGN_TOP: {
                    rcWindow.top  = m_rcExclude.top;
                    break;
                }

                case BALLOONALIGN_BOTTOM: {
                    rcWindow.top = m_rcExclude.bottom - WndSize.cy;
                    break;
                }
            }
            break;
        }
    }

    rcWindow.right  = rcWindow.left + WndSize.cx;
    rcWindow.bottom = rcWindow.top  + WndSize.cy;

    if (rcWindow.left < rcWork.left) {
        OffsetRect( &rcWindow, rcWork.left - rcWindow.left, 0 );
    }
    else if (rcWork.right < rcWindow.right) {
        OffsetRect( &rcWindow, rcWork.right - rcWindow.right, 0 );
    }

    if (rcWindow.top < rcWork.top) {
        OffsetRect( &rcWindow, 0, rcWork.top - rcWindow.top );
    }
    else if (rcWork.bottom < rcWindow.bottom) {
        OffsetRect( &rcWindow, 0, rcWork.bottom - rcWindow.bottom );
    }

    //
    // calc target (end of balloon tail) point and direction
    //

    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            m_ptTail.x = m_ptTarget.x;
            m_ptTail.x = max( m_ptTail.x, rcWindow.left + cxRoundSize/2 );
            m_ptTail.x = min( m_ptTail.x, rcWindow.right - cxRoundSize/2 - 1 );
            m_ptTail.y = rcWindow.bottom - 1;

            m_dir = ((m_ptTail.x < (rcWindow.left + rcWindow.right)/2) ? BALLOONDIR_LEFT : BALLOONDIR_RIGHT);
            break;
        }

        case BALLOONPOS_BELLOW: {
            m_ptTail.x = m_ptTarget.x;
            m_ptTail.x = max( m_ptTail.x, rcWindow.left + cxRoundSize/2 );
            m_ptTail.x = min( m_ptTail.x, rcWindow.right - cxRoundSize/2 - 1 );
            m_ptTail.y = rcWindow.top;

            m_dir = ((m_ptTail.x < (rcWindow.left + rcWindow.right)/2) ? BALLOONDIR_LEFT : BALLOONDIR_RIGHT);
            break;
        }

        case BALLOONPOS_LEFT: {
            m_ptTail.x = rcWindow.right - 1;
            m_ptTail.y = m_ptTarget.y;
            m_ptTail.y = max( m_ptTail.y, rcWindow.top + cyRoundSize/2 );
            m_ptTail.y = min( m_ptTail.y, rcWindow.bottom - cyRoundSize/2 - 1 );

            m_dir = ((m_ptTail.y < (rcWindow.top + rcWindow.bottom)/2) ? BALLOONDIR_UP : BALLOONDIR_DOWN);
            break;
        }

        case BALLOONPOS_RIGHT: {
            m_ptTail.x = rcWindow.left;
            m_ptTail.y = m_ptTarget.y;
            m_ptTail.y = max( m_ptTail.y, rcWindow.top + cyRoundSize/2 );
            m_ptTail.y = min( m_ptTail.y, rcWindow.bottom - cyRoundSize/2 - 1 );

            m_dir = ((m_ptTail.y < (rcWindow.top + rcWindow.bottom)/2) ? BALLOONDIR_UP : BALLOONDIR_DOWN);
            break;
        }
    }

    m_ptTail.x -= rcWindow.left;        // client pos
    m_ptTail.y -= rcWindow.top;         // client pos

    //

    Show( FALSE );
    DoneWindowRegion();

    Move( rcWindow.left, rcWindow.top, rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top );
    LayoutObject();

    InitWindowRegion();
    Show( TRUE );
}


/*   L A Y O U T  O B J E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::LayoutObject( void )
{
    RECT rcClient;
    RECT rcMargin;
    SIZE BtnSize;
    int  i;

    //

    GetButtonSize( &BtnSize );

    // layout buttons

    GetRect( &rcClient );
    switch (m_pos) {
        default:
        case BALLOONPOS_ABOVE: {
            rcClient.bottom -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_BELLOW: {
            rcClient.top += cxyTailHeight;
            break;
        }

        case BALLOONPOS_LEFT: {
            rcClient.right -= cxyTailHeight;
            break;
        }

        case BALLOONPOS_RIGHT: {
            rcClient.left += cxyTailHeight;
            break;
        }
    }

    GetMargin( &rcMargin );
    rcClient.left   = rcClient.left   + rcMargin.left;
    rcClient.top    = rcClient.top    + rcMargin.top;
    rcClient.right  = rcClient.right  - rcMargin.right;
    rcClient.bottom = rcClient.bottom - rcMargin.bottom;

    //

    for (i = 0; i < m_nButton; i++) {
        CUIFObject *pUIBtn = FindUIObject( i );

        if (pUIBtn != NULL) {
            RECT rcButton;

            rcButton.left   = ((rcClient.left + rcClient.right) - (BtnSize.cx*m_nButton + BtnSize.cx/2*(m_nButton-1))) / 2 + BtnSize.cx*i + BtnSize.cx/2*i;
            rcButton.top    = rcClient.bottom - BtnSize.cy;
            rcButton.right  = rcButton.left + BtnSize.cx;
            rcButton.bottom = rcButton.top  + BtnSize.cy;

            pUIBtn->SetRect( &rcButton );
            pUIBtn->Show( TRUE );
        }
    }
}


/*   A D D  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::AddButton( int idCmd )
{
    CUIFBalloonButton *pUIBtn = NULL;
    RECT rcNull = { 0, 0, 0, 0 };

    switch (idCmd) {
        case IDOK:
        case IDCANCEL:
        case IDABORT:
        case IDRETRY:
        case IDIGNORE:
        case IDYES:
        case IDNO: {
            pUIBtn = new CUIFBalloonButton( this, (DWORD)m_nButton, &rcNull, UIBUTTON_PUSH | UIBUTTON_CENTER | UIBUTTON_VCENTER );
            break;
        }
    }

    if (pUIBtn != NULL) {
        // 

        WCHAR *pwsz;
        pUIBtn->Initialize();
        pUIBtn->SetButtonID( idCmd );

        switch (idCmd) {
            case IDOK: {
                pwsz = CRStr(CUI_IDS_OK);
                pUIBtn->SetText( *pwsz ? pwsz : L"OK" );
                break;
            }

            case IDCANCEL: {
                pwsz = CRStr(CUI_IDS_CANCEL);
                pUIBtn->SetText( *pwsz ? pwsz : L"Cancel" );
                break;
            }

            case IDABORT: {
                pwsz = CRStr(CUI_IDS_ABORT);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Abort" );
                break;
            }

            case IDRETRY: {
                pwsz = CRStr(CUI_IDS_RETRY);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Retry" );
                break;
            }

            case IDIGNORE: {
                pwsz = CRStr(CUI_IDS_IGNORE);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Ignore" );
                break;
            }

            case IDYES: {
                pwsz = CRStr(CUI_IDS_YES);
                pUIBtn->SetText( *pwsz ? pwsz : L"&Yes" );
                break;
            }

            case IDNO: {
                pwsz = CRStr(CUI_IDS_NO);
                pUIBtn->SetText( *pwsz ? pwsz : L"&No" );
                break;
            }
        }

        AddUIObj( pUIBtn );
        m_nButton++;
    }
}


/*   F I N D  U I  O B J E C T   */
/*------------------------------------------------------------------------------

    Find UI object which has an ID
    When no UI object found, returns NULL.

------------------------------------------------------------------------------*/
CUIFObject *CUIFBalloonWindow::FindUIObject( DWORD dwID )
{
    int nChild;
    int i;

    nChild = m_ChildList.GetCount();
    for (i = 0; i < nChild; i++) {
        CUIFObject *pUIObj = m_ChildList.Get( i );

        Assert(PtrToInt( pUIObj ));
        if (pUIObj->GetID() == dwID) {
            return pUIObj;
        }
    }

    return NULL;
}


/*   F I N D  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFBalloonButton *CUIFBalloonWindow::FindButton( int idCmd )
{
    int i;

    for (i = 0; i < m_nButton; i++) {
        CUIFBalloonButton *pUIBtn = (CUIFBalloonButton*)FindUIObject( i );

        if ((pUIBtn != NULL) && (pUIBtn->GetButtonID() == idCmd)) {
            return pUIBtn;
        }
    }

    return NULL;
}


/*   S E N D  N O T I F I C A T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFBalloonWindow::SendNotification( int iCmd )
{
    if (m_hWndNotify != NULL) {
        PostMessage( m_hWndNotify, m_uiMsgNotify, (WPARAM)iCmd, 0 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuiicon.h ===
//
// cuiicon.h
//

#ifndef CUIICON_H
#define CUIICON_H

#include "cuiutil.h"
#include "delay.h"
#include "osver.h"


//////////////////////////////////////////////////////////////////////////////
//
// CUIFIcon
//
// Substitue hIcon to support single imagelist.
//
// todo:
//   We want to share the imagelist in future.
//
//////////////////////////////////////////////////////////////////////////////

class CUIFIcon
{
public:
    CUIFIcon()
    {
        m_hIcon = NULL;
        m_himl = NULL;
        m_nimlId = 0;
    }

    ~CUIFIcon()
    {
        if (m_himl)
            ImageList_Destroy( m_himl );
    }

    const CUIFIcon& operator=(HICON hIcon)
    {
        m_hIcon = hIcon;
        if (m_himl)
        {
            ImageList_Destroy( m_himl );
            m_himl = NULL;
        }
 
        return *this;
    }

    operator HICON() {return m_hIcon;}

    HIMAGELIST GetImageList(BOOL fMirror) 
    {
        SIZE size;
        if (m_himl)
            return m_himl;

        if (!m_hIcon)
            return NULL;

        CUIGetIconSize( m_hIcon, &size );

        DWORD dwFlags = ILC_COLOR32 | ILC_MASK;
        if (fMirror && IsOnNT51())
            dwFlags |= ILC_MIRROR;

        m_himl = ImageList_Create(size.cx, size.cy, dwFlags, 1, 0);

        if (m_himl)
            ImageList_AddIcon( m_himl, m_hIcon );

        return m_himl;
    }
    int GetImageListId() {return m_nimlId;}

private:
    HICON m_hIcon;
    HIMAGELIST m_himl;
    int m_nimlId;
};

#endif CUIICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuiarray.h ===
//
// cuiarray.h
//  = array object in CUILib =
//

#ifndef CUIARRAY_H
#define CUIARRAY_H

//
// CUIFObjectArrayBase
//  = base class of object array = 
//

class CUIFObjectArrayBase
{
public:
    CUIFObjectArrayBase( void );
    virtual ~CUIFObjectArrayBase( void );

    BOOL Add( void *pv );
    BOOL Remove( void *pv );
    int  GetCount( void );
    int  Find( void *pv );
    void *Get( int i );
    void *GetFirst( void );
    void *GetLast( void );

private:
    void **m_pBuffer;
    int  m_nBuffer;
    int  m_nObject;

    BOOL EnsureBuffer( int iSize );
};


//
// CUIFObjectArray
//  = object array = 
//

template<class T>
class CUIFObjectArray : public CUIFObjectArrayBase
{
public:
    CUIFObjectArray( void ) : CUIFObjectArrayBase() 
    {
    }

    virtual ~CUIFObjectArray( void ) 
    {
    }

    T *Get( int i )
    {
        return (T*)CUIFObjectArrayBase::Get( i );
    }

    T *GetFirst( void )
    {
        return (T*)CUIFObjectArrayBase::GetFirst();
    }

    T *GetLast( void )
    {
        return (T*)CUIFObjectArrayBase::GetLast();
    }
};

#endif /* CUIARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuidebug.cpp ===
//
// cuidbg.cpp
//  = debug functions in CUILIB =
//

#include "private.h"
#include "cuidebug.h"

#if defined(_DEBUG) || defined(DEBUG)

/*   C U I  A S S E R T  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIAssertProc( LPCTSTR szFile, int iLine, LPCSTR szEval )
{
    TCHAR szMsg[ 2048 ];

    wsprintf( szMsg, TEXT("%s(%d) : %s\n\r"), szFile, iLine, szEval );

    OutputDebugString( TEXT("***** CUILIB ASSERTION FAILED ******\n\r") );
    OutputDebugString( szMsg );
    OutputDebugString( TEXT("\n\r") );
}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuilib.cpp ===
//
// cuilib.cpp
//

#include "private.h"
#include "cuilib.h"


/*=============================================================================*/
/*                                                                             */
/*   E X P O R T E D  F U N C T I O N S                                        */
/*                                                                             */
/*=============================================================================*/

/*   I N I T  U I F  L I B   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitUIFLib( void )
{
	InitUIFSys();
	InitUIFScheme();
	InitUIFUtil();
}


/*   D O N E  U I F  L I B   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneUIFLib( void )
{
	DoneUIFScheme();
	DoneUIFSys();
	DoneUIFUtil();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuibln.h ===
//
// cuibln.h
//


#ifndef CUIBLN_H
#define CUIBLN_H

#include "cuiobj.h"
#include "cuiwnd.h"

#define WNDCLASS_BALLOONWND     "MSIME_PopupMessage"
#define WNDTITLE_BALLOONWND     "MSIME_PopupMessage"


//
// CUIFBallloonButton
//

class CUIFBalloonButton : public CUIFButton
{
public:
    CUIFBalloonButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFBalloonButton( void );

    //
    // CUIFObject methods
    //
    virtual void OnPaint( HDC hDC );

    int  GetButtonID( void );
    void SetButtonID( int iButtonID );

protected:
    int m_iButtonID;

    void DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown );
};


//
// CUIFBalloonWindow
//  = Balloon window class =
//

#define UIBALLOON_OK        0x00010000
#define UIBALLOON_YESNO     0x00020000
#define UIBALLOON_BUTTONS   0x000F0000      /* mask bit */


typedef enum _BALLOONWNDPOS
{
    BALLOONPOS_ABOVE,
    BALLOONPOS_BELLOW,
    BALLOONPOS_LEFT,
    BALLOONPOS_RIGHT,
} BALLOONWNDPOS;


typedef enum _BALLONWNDDIR
{
    BALLOONDIR_LEFT,
    BALLOONDIR_RIGHT,
    BALLOONDIR_UP,
    BALLOONDIR_DOWN,
} BALLOONWNDDIR;


typedef enum _BALLONWNDALIGN
{
    BALLOONALIGN_CENTER,
    BALLOONALIGN_LEFT,
    BALLOONALIGN_TOP    = BALLOONALIGN_LEFT,
    BALLOONALIGN_RIGHT,
    BALLOONALIGN_BOTTOM = BALLOONALIGN_RIGHT,
} BALLOONWNDALIGN;


class CUIFBalloonWindow : public CUIFWindow
{
public:
    CUIFBalloonWindow( HINSTANCE hInst, DWORD dwStyle );
    virtual ~CUIFBalloonWindow( void );

    LPCTSTR GetClassName( void );
    LPCTSTR GetWndTitle( void );

    //
    // CUIFObject methods
    //
    virtual CUIFObject *Initialize( void );
    virtual void OnCreate( HWND hWnd );
    virtual void OnDestroy( HWND hWnd );
    virtual void OnPaint( HDC hDC );
    virtual void OnKeyDown( HWND hWnd, WPARAM wParam, LPARAM lParam );
    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

    //
    //
    //
    LRESULT SetText( LPCWSTR pwchMessage );
    LRESULT SetNotifyWindow( HWND hWndNotify, UINT uiMsgNotify );
    LRESULT SetBalloonPos( BALLOONWNDPOS pos );
    LRESULT SetBalloonAlign( BALLOONWNDALIGN align );
    LRESULT GetBalloonBkColor( void );
    LRESULT GetBalloonTextColor( void );
    LRESULT GetMargin( RECT *prc );
    LRESULT GetMaxBalloonWidth( void );
    LRESULT SetBalloonBkColor( COLORREF col );
    LRESULT SetBalloonTextColor( COLORREF col );
    LRESULT SetMargin( RECT *prc );
    LRESULT SetMaxBalloonWidth( INT iWidth );
    LRESULT SetButtonText( int idCmd, LPCWSTR pwszText );
    LRESULT SetTargetPos( POINT ptTarget );
    LRESULT SetExcludeRect( const RECT *prcExclude );

protected:
    WCHAR           *m_pwszText;
    HRGN            m_hWindowRgn;
    RECT            m_rcMargin;
    INT             m_iMaxTxtWidth;
    BOOL            m_fColBack;
    BOOL            m_fColText;
    COLORREF        m_colBack;
    COLORREF        m_colText;
    POINT           m_ptTarget;
    RECT            m_rcExclude;
    POINT           m_ptTail;
    BALLOONWNDPOS   m_posDef;
    BALLOONWNDPOS   m_pos;
    BALLOONWNDDIR   m_dir;
    BALLOONWNDALIGN m_align;
    int             m_nButton;

    int             m_iCmd;
    HWND            m_hWndNotify;
    UINT            m_uiMsgNotify;

    HRGN CreateRegion( RECT *prc );
    void InitWindowRegion( void );
    void DoneWindowRegion( void );
    void PaintFrameProc( HDC hDC, RECT *prc );
    void PaintMessageProc( HDC hDC, RECT *prc, WCHAR *pwszText );
    void GetButtonSize( SIZE *pSize );
    void AdjustPos( void );
    void LayoutObject( void );
    void AddButton( int idCmd );
    CUIFObject *FindUIObject( DWORD dwID );
    CUIFBalloonButton *FindButton( int idCmd );
    void SendNotification( int iCmd );
};

#endif /* CUIBLN_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuilib.h ===
//
// cuilib.h
//

#ifndef CUILIB_H
#define CUILIB_H

#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuitb.h"
#include "cuimenu.h"
#include "cuitip.h"
#include "cuibln.h"
#include "cuisys.h"
#include "cuischem.h"
#include "cuiutil.h"

extern void InitUIFLib( void );
extern void DoneUIFLib( void );

#endif /* CUILIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuimem.h ===
//
// cuimem.h
//  = memory management functions in CUILIB =
//

#ifndef CUIMEM_H
#define CUIMEM_H

// note: temporary, use Cicero memmgr as currently it does.

#include "mem.h"

#define MemAlloc( uCount )              cicMemAllocClear( (uCount) )
#define MemFree( pv )                   cicMemFree( (pv) )
#define MemReAlloc( pv, uCount )        cicMemReAlloc( (pv), (uCount) )

#define MemCopy( dst, src, uCount )     memcpy( (dst), (src), (uCount) )
#define MemMove( dst, src, uCount )     memmove( (dst), (src), (uCount) )
#define MemSet( dst, c, uCount )        memset( (dst), (c), (uCount) )


#endif /* CUIMEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuimenu.cpp ===
//
// cuimenu.cpp
//

#include "private.h"
#include "cuimenu.h"
#include "fontlink.h"


#if (_WIN32_WINNT < 0x0500)
#define SPI_GETMENUANIMATION                0x1002
#define SPI_GETMENUFADE                     0x1012

/*
 * AnimateWindow() Commands
 */
#define AW_HOR_POSITIVE             0x00000001
#define AW_HOR_NEGATIVE             0x00000002
#define AW_VER_POSITIVE             0x00000004
#define AW_VER_NEGATIVE             0x00000008
#define AW_CENTER                   0x00000010
#define AW_HIDE                     0x00010000
#define AW_ACTIVATE                 0x00020000
#define AW_SLIDE                    0x00040000
#define AW_BLEND                    0x00080000
#endif /* _WIN32_WINNT < 0x0500 */

#define MENU_ARROW_MARGIN 2
#define MENU_TEXT_MARGIN  8


/*============================================================================*/
//
//    CUIFMenuItem
//
/*============================================================================*/

/*------------------------------------------------------------------------------

   ctor

------------------------------------------------------------------------------*/
CUIFMenuItem::CUIFMenuItem(CUIFMenu *pMenu, DWORD dwFlags) : CUIFObject(pMenu, 0, NULL, 0)
{
    _uId = 0;
    _psz = NULL;
    _cch = 0;
    _pszTab = NULL;
    _cchTab = 0;
    _uShortcutkey = 0;
    _hbmp = NULL;
    _hbmpMask = NULL;
    _bChecked = FALSE;
    _bGrayed = FALSE;
    _pMenu = pMenu;
    _uUnderLine = -1;
    _bNonSelectedItem = (dwFlags & UIMENUITEM_NONSELECTEDITEM) ? TRUE : FALSE;
}

/*------------------------------------------------------------------------------

   dtor

------------------------------------------------------------------------------*/
CUIFMenuItem::~CUIFMenuItem(void)
{
    if (_psz)
        delete _psz;

    if (_pszTab)
        delete _pszTab;

    if (_pSubMenu)
        delete _pSubMenu;
}

/*------------------------------------------------------------------------------

   Init

------------------------------------------------------------------------------*/
BOOL CUIFMenuItem::Init(UINT uId, WCHAR *psz)
{
    _uId = uId;

    if (!psz)
    {
        _psz = NULL;
        _cch = 0;
        return TRUE;
    }

    UINT cch = StrLenW(psz);
    _psz = new WCHAR[cch + 1];
    if (!_psz)
        return FALSE;

    int i = 0;
    while (*psz && (*psz != L'\t'))
    {
        if (*psz == L'&')
        {
            psz++;
            if (*psz != L'&')
            {
                _uShortcutkey = LOBYTE(VkKeyScanW(*psz));
                if (!_uShortcutkey)
                {
                    Assert(!HIBYTE(*psz));
                    _uShortcutkey = LOBYTE(VkKeyScanA(LOBYTE(*psz)));
                }
                _uUnderLine = i;
            }
        }
        _psz[i] = *psz;
        i++;
        psz++;
    }
    _cch = StrLenW(_psz);

    if (*psz == L'\t')
    {
        _pszTab = new WCHAR[cch + 1];
        if (_pszTab)
        {
            i = 0;
            psz++;
            while (*psz)
            {
                _pszTab[i] = *psz;
                psz++;
                i++;
            }
            _cchTab = StrLenW(_pszTab);
        }
    }

    return TRUE;
}

/*------------------------------------------------------------------------------

   SetBitmap

------------------------------------------------------------------------------*/
void CUIFMenuItem::SetBitmap(HBITMAP hbmp)
{
    _hbmp = hbmp;
}

/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFMenuItem::SetBitmapMask( HBITMAP hBmp )
{
    _hbmpMask = hBmp;
#if 0
    BITMAP bmp;
    GetObject(_hbmp, sizeof(bmp), &bmp);
    RECT rc;
    ::SetRect(&rc, 0, 0, bmp.bmWidth, bmp.bmHeight);
    _hbmpMask = CreateMaskBmp(&rc, _hbmp, hBmp,
                              (HBRUSH)(COLOR_3DFACE + 1) );
#endif
    CallOnPaint();
}

/*------------------------------------------------------------------------------

   Check

------------------------------------------------------------------------------*/
void CUIFMenuItem::Check(BOOL bChecked)
{
    _bChecked = bChecked;
}

/*------------------------------------------------------------------------------

   RadioCheck

------------------------------------------------------------------------------*/
void CUIFMenuItem::RadioCheck(BOOL bRadioChecked)
{
    _bRadioChecked = bRadioChecked;
}

/*------------------------------------------------------------------------------

   Gray

------------------------------------------------------------------------------*/
void CUIFMenuItem::Gray(BOOL bGrayed)
{
    _bGrayed = bGrayed;
}

/*------------------------------------------------------------------------------

   SetSub

------------------------------------------------------------------------------*/
void CUIFMenuItem::SetSub(CUIFMenu *pSubMenu)
{
    _pSubMenu = pSubMenu;
}

/*------------------------------------------------------------------------------

   InitMenuExtent

------------------------------------------------------------------------------*/
void CUIFMenuItem::InitMenuExtent()
{
    HDC hdc = GetDC(m_pUIWnd->GetWnd());
    if (_psz)
    {
        HFONT hFontOld= (HFONT)SelectObject( hdc, GetFont() );
        CUIGetTextExtentPoint32( hdc, _psz, _cch, &_size);
        _size.cx += MENU_TEXT_MARGIN * 2;
        _size.cy += MENU_TEXT_MARGIN;

        if (_pszTab)
        {
            CUIGetTextExtentPoint32( hdc, _pszTab, _cchTab, &_sizeTab);
            _sizeTab.cy += MENU_TEXT_MARGIN;
        }

        SelectObject( hdc, hFontOld);

        if (GetSub())
        {
            _size.cx += (_size.cy + MENU_ARROW_MARGIN);
        }

        if (_pMenu->IsO10Menu())
            _size.cx += 24;
    }
    else if (_hbmp)
    {
        BITMAP bmp;
        GetObject(_hbmp, sizeof(bmp), &bmp);
        _size.cx = bmp.bmWidth + 2;
        _size.cy = bmp.bmHeight + 4;
    }
    else
    {
        _size.cy = 0;
        _size.cx = 0;
    }


    ReleaseDC(m_pUIWnd->GetWnd(), hdc);

}



/*------------------------------------------------------------------------------

   OnLButtonUp

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnLButtonUp(POINT pt)
{
    if (IsGrayed())
        return;

    if (IsNonSelectedItem())
        return;

    if (_pSubMenu)
        return;

    _pMenu->SetSelectedId(_uId);
    PostMessage(m_pUIWnd->GetWnd(), WM_NULL, 0, 0);
}

/*------------------------------------------------------------------------------

   OnMouseIn

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnMouseIn(POINT pt)
{
    _pMenu->CancelSubMenu();

    //
    // start timer to open submenu.
    //
    if (_pSubMenu)
    {
        UINT uElipse;
        if (!SystemParametersInfo(SPI_GETMENUSHOWDELAY, 
                                  0, 
                                  (void *)&uElipse, 
                                  FALSE))
        {
            uElipse = 300;
        }

        StartTimer(uElipse);
    }

    // 
    // darw this.
    // 
    _pMenu->SetSelectedItem(this);
}

/*------------------------------------------------------------------------------

   OnMouseOut

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnMouseOut(POINT pt)
{

}

/*------------------------------------------------------------------------------

   OnTimer

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnTimer()
{
    EndTimer();
    Assert(PtrToInt(_pSubMenu));

    if (!_pMenu->IsPointed(this))
        return;

    ShowSubPopup();

}
/*------------------------------------------------------------------------------

   ShowSubPopup

------------------------------------------------------------------------------*/
void CUIFMenuItem::ShowSubPopup()
{
    Assert(PtrToInt(_pSubMenu));

    RECT rc = GetRectRef();
    ClientToScreen(m_pUIWnd->GetWnd(), (POINT *)&rc.left);
    ClientToScreen(m_pUIWnd->GetWnd(), (POINT *)&rc.right);
    _pSubMenu->ShowSubPopup(_pMenu, &rc, FALSE);
}

/*------------------------------------------------------------------------------

   OnPaint

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnPaint(HDC hDC)
{
    if (_pMenu->IsO10Menu())
        OnPaintO10(hDC);
    else
        OnPaintDef(hDC);
}

/*------------------------------------------------------------------------------

   OnPaintDef

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnPaintDef(HDC hDC)
{
    HFONT hFontOld;
    int xAlign;
    int yAlign;
    int xText;
    int yText;
    int xCheck;
    int yCheck;
    int xBmp;
    int yBmp;
    int xArrow;
    int yArrow;
    SIZE size;

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );

    // calc alignment

    CUIGetTextExtentPoint32( hDC, _psz, _cch, &size );

    xAlign = 0;
    yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;

    xCheck = GetRectRef().left + xAlign;
    yCheck = GetRectRef().top + yAlign;

    xBmp   = xCheck + (_pMenu->IsBmpCheckItem() ? _pMenu->GetMenuCheckWidth() : 0);
    yBmp   = GetRectRef().top;

    xText  = xCheck + 2 + _pMenu->GetMenuCheckWidth() + (_pMenu->IsBmpCheckItem() ? _pMenu->GetMenuCheckWidth() : 0);
    yText  = GetRectRef().top + yAlign;
    xArrow = GetRectRef().left + GetRectRef().right - 10, 
    yArrow = GetRectRef().top + yAlign;

    // draw

    SetBkMode( hDC, TRANSPARENT );

    if (!_bGrayed)
    {
        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, GetSysColor(COLOR_MENUTEXT) );

            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                           xText,
                           yText,
                          (HBRUSH)(COLOR_MENUTEXT + 1));

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);

        }
        else
        {
            SetTextColor( hDC, GetSysColor(COLOR_HIGHLIGHTTEXT) );
            SetBkColor( hDC, GetSysColor(COLOR_HIGHLIGHT) );
            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED | ETO_OPAQUE,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                          xText,
                          yText,
                          (HBRUSH)(COLOR_HIGHLIGHTTEXT + 1));

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);
        }
    }
    else 
    {
        UINT ueto = ETO_CLIPPED;

        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
            CUIExtTextOut( hDC,
                        xText + 1,
                        yText + 1,
                        ueto,
                        &GetRectRef(),
                        _psz,
                        _cch,
                        NULL );

            DrawCheck(hDC, xCheck + 1, yCheck + 1);
    
            DrawBitmapProc(hDC, xBmp + 1, yBmp + 1);

            DrawArrow(hDC, xArrow + 1, yArrow + 1);
        }
        else
        {
            SetBkColor( hDC, GetSysColor(COLOR_HIGHLIGHT) );
            ueto |= ETO_OPAQUE;
        }

        SetTextColor(hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut(hDC,
                      xText,
                      yText,
                      ueto,
                      &GetRectRef(),
                      _psz,
                      _cch,
                      NULL );

        DrawUnderline(hDC,
                      xText,
                      yText,
                      (HBRUSH)(COLOR_3DSHADOW + 1));

        DrawCheck(hDC, xCheck, yCheck);

        DrawBitmapProc(hDC, xBmp, yBmp);

        DrawArrow(hDC, xArrow, yArrow);
    }

    // restore objects

    SelectObject( hDC, hFontOld);
}

/*------------------------------------------------------------------------------

   OnPaintO10

------------------------------------------------------------------------------*/
void CUIFMenuItem::OnPaintO10(HDC hDC)
{
    HFONT hFontOld;
    int xAlign;
    int yAlign;
    int xText;
    int yText;
    int xCheck;
    int yCheck;
    int xBmp;
    int yBmp;
    int xArrow;
    int yArrow;
    SIZE size;
    RECT rc;

    if (!m_pUIFScheme)
        return;

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );

    // calc alignment

    CUIGetTextExtentPoint32( hDC, _psz, _cch, &size );

    xAlign = 0;
    yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;

    xCheck = GetRectRef().left + xAlign;
    yCheck = GetRectRef().top + yAlign;

    xBmp   = xCheck + (_pMenu->IsBmpCheckItem() ? _pMenu->GetMenuCheckWidth() : 0);
    yBmp   = GetRectRef().top;

    xText  = xBmp + 8 + _pMenu->GetMenuCheckWidth();

    yText  = GetRectRef().top + yAlign;
    xArrow = GetRectRef().left + GetRectRef().right - size.cy - MENU_ARROW_MARGIN; //size.cy may be enough for size of arrow...
    yArrow = GetRectRef().top + yAlign;

    // draw
    GetRect(&rc);
    if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
    {
        rc.right = rc.left + _pMenu->GetMenuCheckWidth() + 2;
        if (_pMenu->IsBmpCheckItem())
            rc.right += _pMenu->GetMenuCheckWidth();

        ::FillRect(hDC, &rc, m_pUIFScheme->GetBrush(UIFCOLOR_CTRLBKGND));
    }
    else
    {
        m_pUIFScheme->DrawCtrlBkgd(hDC, &rc, 0, UIFDCS_SELECTED);
        m_pUIFScheme->DrawCtrlEdge(hDC, &rc, 0, UIFDCS_SELECTED);
    }

    SetBkMode( hDC, TRANSPARENT );

    if (!_bGrayed)
    {
        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, m_pUIFScheme->GetColor(UIFCOLOR_CTRLTEXT) );

            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                           xText,
                           yText,
                          (HBRUSH)m_pUIFScheme->GetBrush(UIFCOLOR_CTRLTEXT));

            if (_pszTab)
                CUIExtTextOut( hDC,
                               GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                               yText,
                               ETO_CLIPPED,
                               &GetRectRef(),
                               _pszTab,
                               _cchTab,
                               NULL );

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);

        }
        else
        {
            SetTextColor( hDC, m_pUIFScheme->GetColor(UIFCOLOR_MOUSEOVERTEXT) );

            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _psz,
                           _cch,
                           NULL );

            DrawUnderline(hDC,
                          xText,
                          yText,
                          (HBRUSH)m_pUIFScheme->GetBrush(UIFCOLOR_MOUSEOVERTEXT));

            if (_pszTab)
                CUIExtTextOut( hDC,
                               GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                               yText,
                               ETO_CLIPPED,
                               &GetRectRef(),
                               _pszTab,
                               _cchTab,
                               NULL );

            DrawCheck(hDC, xCheck, yCheck);

            DrawBitmapProc(hDC, xBmp, yBmp);

            DrawArrow(hDC, xArrow, yArrow);
        }
    }
    else 
    {
#if 1
        SetTextColor( hDC, m_pUIFScheme->GetColor(UIFCOLOR_CTRLTEXTDISABLED) );
        CUIExtTextOut(hDC,
                      xText,
                      yText,
                      ETO_CLIPPED,
                      &GetRectRef(),
                      _psz,
                      _cch,
                      NULL );

        DrawUnderline(hDC,
                      xText,
                      yText,
                      (HBRUSH)m_pUIFScheme->GetBrush(UIFCOLOR_CTRLTEXTDISABLED));

        if (_pszTab)
            CUIExtTextOut( hDC,
                           GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                           yText,
                           ETO_CLIPPED,
                           &GetRectRef(),
                           _pszTab,
                           _cchTab,
                           NULL );

        DrawCheck(hDC, xCheck, yCheck);

        DrawBitmapProc(hDC, xBmp, yBmp);

        DrawArrow(hDC, xArrow, yArrow);
#else
        UINT ueto = ETO_CLIPPED;

        if (!_pMenu->IsSelectedItem(this) || IsNonSelectedItem())
        {
            SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
            CUIExtTextOut( hDC,
                        xText + 1,
                        yText + 1,
                        ueto,
                        &GetRectRef(),
                        _psz,
                        _cch,
                        NULL );

            if (_pszTab)
                CUIExtTextOut( hDC,
                               GetRectRef().right - _pMenu->GetMaxTabTextLength() - 3,
                               yText + 1,
                               ETO_CLIPPED,
                               &GetRectRef(),
                               _pszTab,
                               _cchTab,
                               NULL );

            DrawCheck(hDC, xCheck + 1, yCheck + 1);
    
            DrawBitmapProc(hDC, xBmp + 1, yBmp + 1);

            DrawArrow(hDC, xArrow + 1, yArrow + 1);
        }
        else
        {
            SetBkColor( hDC, GetSysColor(COLOR_HIGHLIGHT) );
            ueto |= ETO_OPAQUE;
        }

        SetTextColor(hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut(hDC,
                      xText,
                      yText,
                      ueto,
                      &GetRectRef(),
                      _psz,
                      _cch,
                      NULL );

        DrawUnderline(hDC,
                      xText,
                      yText,
                      (HBRUSH)(COLOR_3DSHADOW + 1));

        CUIExtTextOut( hDC,
                       GetRectRef().right - _pMenu->GetMaxTabTextLength() - MENU_TEXT_MARGIN,
                       yText,
                       ETO_CLIPPED,
                       &GetRectRef(),
                       _pszTab,
                       _cchTab,
                       NULL );

        DrawCheck(hDC, xCheck, yCheck);

        DrawBitmapProc(hDC, xBmp, yBmp);

        DrawArrow(hDC, xArrow, yArrow);
#endif
    }

    // restore objects

    SelectObject( hDC, hFontOld);
}

/*------------------------------------------------------------------------------

   DrawUnderline

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawUnderline(HDC hDC, int x, int y, HBRUSH hbr)
{
    if (_uUnderLine > _cch)
        return;

    SIZE size0, size1;
    CUIGetTextExtentPoint32( hDC, _psz, _uUnderLine, &size0 );
    CUIGetTextExtentPoint32( hDC, _psz, _uUnderLine + 1, &size1 );

    RECT rc;
    rc.left   = x + size0.cx;
    if (_uUnderLine)
        rc.left++;

    rc.right  = x + size1.cx;
    rc.top    = y + size1.cy - 1;
    rc.bottom = y + size1.cy;
    FillRect(hDC, &rc, hbr);

}

/*------------------------------------------------------------------------------

   DrawCheck

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawCheck(HDC hDC, int x, int y)
{
    if (!IsCheck())
         return;

    HFONT hFontOld = (HFONT)SelectObject( hDC, _pMenu->GetMarlettFont());

    TextOut(hDC,  x,  y,  _bChecked ? "a" : "h",  1);

    SelectObject( hDC, hFontOld);
}

/*------------------------------------------------------------------------------

   DrawArrow

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawArrow(HDC hDC, int x, int y)
{
    if (!_pSubMenu)
        return;

    HFONT hFontOld = (HFONT)SelectObject( hDC, _pMenu->GetMarlettFont());
    TextOut( hDC, x, y, "4", 1);
    SelectObject( hDC, hFontOld);
}

/*   D R A W  B I T M A P  P R O C   */
/*------------------------------------------------------------------------------

    Draw bitmap on button face 

------------------------------------------------------------------------------*/
void CUIFMenuItem::DrawBitmapProc( HDC hDC, int x, int y)
{
    BITMAP bmp;
    DWORD dwState = 0;

    if (!m_pUIFScheme)
        return;

    if (!_hbmp)
        return;
    
    int cx;
    int cy;

    cx = _pMenu->GetMenuCheckWidth();

    cy = GetRectRef().bottom - GetRectRef().top;

    // we have to do this viewport trick to get around the fact that 
    // DrawState has a GDI bug in NT4, such that it handles offsets improperly.
    // so we do the offset by hand.
    // POINT ptOldOrg;
    // BOOL fRetVal = SetViewportOrgEx( hDC, 0, 0, &ptOldOrg );
    // Assert( fRetVal );

    GetObject(_hbmp, sizeof(bmp), &bmp);
    if (cx > bmp.bmWidth)
    {
        x += (cx - bmp.bmWidth) / 2;
        cx = bmp.bmWidth;
    }

    if (cy > bmp.bmHeight)
    {
        y += (cy - bmp.bmHeight) / 2;
        cy = bmp.bmHeight;
    }
   
    RECT rc;
    // ::SetRect(&rc, x + ptOldOrg.x, 
    //                y + ptOldOrg.y, 
    //                x + ptOldOrg.x + cx, 
    //                y + ptOldOrg.y + cy);
    ::SetRect(&rc, x,  y,  x + cx,  y + cy);

    if (IsRTL())
        m_pUIFScheme->SetLayout(LAYOUT_RTL);

    if (_pMenu->IsSelectedItem(this) && !IsNonSelectedItem())
    {
        dwState |=  UIFDCS_SELECTED;
        m_pUIFScheme->DrawMenuBitmap(hDC, &rc, _hbmp, _hbmpMask, dwState);
    }
#if 0
    else if (IsCheck())
    {
        dwState |=  UIFDCS_MOUSEOVER;
        m_pUIFScheme->DrawMenuBitmap(hDC, &rc, _hbmp, _hbmpMask, dwState);
        ::OffsetRect(&rc, -1, -1);
        ::InflateRect(&rc, 2, 2);
        m_pUIFScheme->DrawCtrlEdge(hDC, &rc, 0, UIFDCS_SELECTED);
    }
#endif
    else
    {
        m_pUIFScheme->DrawMenuBitmap(hDC, &rc, _hbmp, _hbmpMask, dwState);
    }

    if (IsRTL())
        m_pUIFScheme->SetLayout(0);


    // SetViewportOrgEx( hDC, ptOldOrg.x, ptOldOrg.y, NULL );
}

/*============================================================================*/
//
//    CUIFMenuItemSeparator
//
/*============================================================================*/


/*------------------------------------------------------------------------------

   OnPaint

------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::OnPaint(HDC hDC)
{
    if (_pMenu->IsO10Menu())
       OnPaintO10(hDC);
    else
       OnPaintDef(hDC);
}

/*------------------------------------------------------------------------------

   OnPaintDef

------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::OnPaintDef(HDC hDC)
{
    if (!m_pUIFScheme)
        return;

    int xAlign = 2;
    int yAlign = (GetRectRef().bottom - GetRectRef().top - 2) / 2;
    int cx = (GetRectRef().right - GetRectRef().left - 2 * xAlign);

    RECT rc;
    ::SetRect(&rc,
              GetRectRef().left + xAlign,
              GetRectRef().top + yAlign,
              GetRectRef().left + xAlign + cx, 
              GetRectRef().top + yAlign + 2);

    m_pUIFScheme->DrawMenuSeparator( hDC, &rc);
}


/*------------------------------------------------------------------------------

   OnPaintO10
    
------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::OnPaintO10(HDC hDC)
{
    if (!m_pUIFScheme)
        return;

    int xAlign = 2;
    int yAlign = (GetRectRef().bottom - GetRectRef().top - 2) / 2;
    int cx = (GetRectRef().right - GetRectRef().left - 2 * xAlign);
    int xStart = 0;
    RECT rc;

    GetRect(&rc);
    rc.right = rc.left + _pMenu->GetMenuCheckWidth() + 2;
    if (_pMenu->IsBmpCheckItem())
        rc.right += _pMenu->GetMenuCheckWidth();

    ::FillRect(hDC, &rc, m_pUIFScheme->GetBrush(UIFCOLOR_CTRLBKGND));
    xStart = _pMenu->GetMenuCheckWidth() + 2;

    ::SetRect(&rc,
              GetRectRef().left + xAlign + xStart, 
              GetRectRef().top + yAlign,
              GetRectRef().left + xAlign + cx, 
              GetRectRef().top + yAlign + 1);

    m_pUIFScheme->DrawMenuSeparator( hDC, &rc);
}

/*------------------------------------------------------------------------------

   InitMenuExtent

------------------------------------------------------------------------------*/
void CUIFMenuItemSeparator::InitMenuExtent()
{
    _size.cx = 0;
    _size.cy = 6;
}

/*============================================================================*/
//
//    CUIFMenu
//
/*============================================================================*/

/*------------------------------------------------------------------------------

   ctor

------------------------------------------------------------------------------*/
CUIFMenu::CUIFMenu(HINSTANCE hInst, DWORD dwWndStyle, DWORD dwMenuStyle) : CUIFWindow(hInst, dwWndStyle)
{
    _uIdSelect = CUI_MENU_UNSELECTED;
    _dwMenuStyle = dwMenuStyle;

    SetMenuFont();
}

/*------------------------------------------------------------------------------

   dtor

------------------------------------------------------------------------------*/
CUIFMenu::~CUIFMenu( void )
{
    int i;
    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        CUIFMenuItem *pItem = _rgItems.Get(i);
        delete pItem;
    }
    DeleteObject(_hfontMarlett);
    ClearMenuFont();
}

/*------------------------------------------------------------------------------

   InsertItem

------------------------------------------------------------------------------*/
BOOL CUIFMenu::InsertItem(CUIFMenuItem *pItem)
{
    if (!_rgItems.Add( pItem ))
        return FALSE;

    pItem->SetFont(GetFont());
    return TRUE;
}

/*------------------------------------------------------------------------------

   InsertSeparator

------------------------------------------------------------------------------*/
BOOL CUIFMenu::InsertSeparator()
{
    CUIFMenuItemSeparator *pSep;

    pSep = new CUIFMenuItemSeparator(this);
    if (!pSep)
        return FALSE;

    pSep->Initialize();

    if (!_rgItems.Add( pSep ))
    {
        delete pSep;
        return FALSE;
    }

    return TRUE;
}

/*------------------------------------------------------------------------------

   ShowModalPopup

------------------------------------------------------------------------------*/
UINT CUIFMenu::ShowModalPopup(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical)
{
    UINT uId;
    CUIFObject *puicap;

    if (pcuiWndParent)
    {
        puicap = pcuiWndParent->GetCaptureObject();
        pcuiWndParent->SetCaptureObject(NULL);
    }

    if (InitShow(pcuiWndParent, prc, fVertical, TRUE)) {
        _fInModal = TRUE;
        pcuiWndParent->SetBehindModal(this);

        ModalMessageLoop();

        uId = _uIdSelect;
        pcuiWndParent->SetBehindModal(NULL);
        _fInModal = FALSE;
    }
    else 
    {
        uId = CUI_MENU_UNSELECTED;
    }

    UninitShow();

    if (pcuiWndParent)
    {
        pcuiWndParent->SetCaptureObject(puicap);
    }

    return uId;
}


/*------------------------------------------------------------------------------

    ModalMessageLoop

------------------------------------------------------------------------------*/
void CUIFMenu::ModalMessageLoop( void )
{
    MSG msg;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.message == WM_NULL)
            break;

        if (msg.hwnd != GetWnd())
        {
            if ((msg.message > WM_MOUSEFIRST) &&
                (msg.message <= WM_MOUSELAST))
            {
                break;
            }
        }

        //
        // Dispatch key message to Sub menu.
        //
        if ((msg.message >= WM_KEYFIRST) &&
            (msg.message <= WM_KEYLAST))
        {
            if (!msg.hwnd)
            {
                CUIFMenu *pSubMenu = GetTopSubMenu();
                msg.hwnd = pSubMenu->GetWnd();
            }
        }


        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


/*------------------------------------------------------------------------------

   InitShow

------------------------------------------------------------------------------*/
BOOL CUIFMenu::InitShow(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical, BOOL fAnimate)
{
    int i;
    int cxMax = 0;
    SIZE size = {0, 0};
    RECT rc = {0, 0, 0, 0};
    RECT rcScreen;
    HMONITOR hMonitor;
    CUIFMenuItem *pItem;
    BOOL fMenuAnimation = FALSE;
    BOOL fAnimated      = FALSE;
    DWORD dwSlideFlag   = 0;
    int x;
    int y;


    CreateWnd((pcuiWndParent != NULL) ? pcuiWndParent->GetWnd() : NULL);

    _fIsBmpCheckItem = FALSE;

    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        pItem = _rgItems.Get(i);
        pItem->InitMenuExtent();
    }

    _cxMaxTab = 0;
    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        pItem = _rgItems.Get(i);

        pItem->GetMenuExtent(&size);

        size.cx += GetMenuCheckWidth();

        cxMax = (size.cx > cxMax) ? size.cx : cxMax;
        _cxMaxTab = (pItem->GetTabTextLength() > _cxMaxTab) ? 
                    pItem->GetTabTextLength() : 
                    _cxMaxTab;

        _fIsBmpCheckItem |= (pItem->IsBmp() && pItem->IsCheck()) ? TRUE : FALSE;
    }

    for (i = 0; i < _rgItems.GetCount(); i++)
    {
        pItem = _rgItems.Get(i);

        pItem->GetMenuExtent(&size);

        rc.right = rc.left + cxMax + _cxMaxTab;
        rc.bottom = rc.top + size.cy;
        pItem->SetRect(&rc);
        rc.top += size.cy;

        AddUIObj(pItem);
    }

    rc.top = 0;
    LONG_PTR dwStyle = GetWindowLongPtr(GetWnd(), GWL_STYLE);

    int nWidth = rc.right;
    int nHeight = rc.bottom;


    if (dwStyle & WS_DLGFRAME)
    {
        nWidth += GetSystemMetrics(SM_CXDLGFRAME) * 2;
        nHeight += GetSystemMetrics(SM_CYDLGFRAME) * 2;
    }
    else if (dwStyle & WS_BORDER)
    {
        nWidth += GetSystemMetrics(SM_CXBORDER) * 2;
        nHeight += GetSystemMetrics(SM_CYBORDER) * 2;
    }

    ::SetRect( &rcScreen, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN) );
    RECT rcT;
    rcT = *prc;
    hMonitor = CUIMonitorFromRect( &rcT, MONITOR_DEFAULTTONEAREST );
    if (hMonitor != NULL) {
        MONITORINFO MonitorInfo = {0};

        MonitorInfo.cbSize = sizeof(MONITORINFO);
        if (CUIGetMonitorInfo( hMonitor, &MonitorInfo )) {
            rcScreen = MonitorInfo.rcMonitor;
        }
    }

    if (FHasStyle( UIWINDOW_LAYOUTRTL ))
        rc.left -= nWidth;

    if (fVertical)
    {
        x = rc.left + prc->left;
        if (rc.top + prc->bottom + nHeight <= rcScreen.bottom)
        {
            y = rc.top + prc->bottom;
            dwSlideFlag  = AW_VER_POSITIVE;
        }
        else
        {
            y = rc.top + prc->top - nHeight;
            dwSlideFlag  = AW_VER_NEGATIVE;
        }

        if (rc.left + prc->right + nWidth > rcScreen.right)
            x = rcScreen.right - nWidth;
    }
    else
    {
        y = rc.top + prc->top;
        if (rc.left + prc->right + nWidth <= rcScreen.right)
        {
            x = rc.left + prc->right;
            dwSlideFlag  = AW_HOR_POSITIVE;
        }
        else
        {
            x = rc.left + prc->left - nWidth;
            dwSlideFlag  = AW_HOR_NEGATIVE;
        }

        if (rc.top + prc->bottom + nHeight > rcScreen.bottom)
            y = rcScreen.bottom - nHeight;
    }


    x = min( rcScreen.right - nWidth, x );
    x = max( rcScreen.left, x );
    y = min( rcScreen.bottom - nHeight, y );
    y = max( rcScreen.top, y );
    Move(x, y, nWidth, nHeight);

    SetRect(NULL);

    // animation support

    fAnimated = FALSE;
    if (fAnimate) {
        if (SystemParametersInfo( SPI_GETMENUANIMATION, 0, &fMenuAnimation, FALSE ) && fMenuAnimation) {
            BOOL  fFade = FALSE;
            DWORD dwFlags;

            if (!SystemParametersInfo( SPI_GETMENUFADE, 0, &fFade, FALSE )) {
                fFade = FALSE;
            }

            // determine animation flag

            if (fFade) {
                dwFlags = AW_BLEND;
            }
            else {
                dwFlags = AW_SLIDE | dwSlideFlag;
            }

            fAnimated = AnimateWnd( 200, dwFlags );
        }
    }
    if (!fAnimated) {
        Show(TRUE);
    }

    if (_pcuiParentMenu)
        _pcuiParentMenu->_pCurrentSubMenu = this;

    return TRUE;
}

/*------------------------------------------------------------------------------

   UninitShow

------------------------------------------------------------------------------*/
BOOL CUIFMenu::UninitShow()
{
    int i;

    if (_pCurrentSubMenu)
        _pCurrentSubMenu->UninitShow();

    Show(FALSE);

    if (_pcuiParentMenu)
        _pcuiParentMenu->_pCurrentSubMenu = NULL;


    for (i = 0; i < _rgItems.GetCount(); i++)
        RemoveUIObj(_rgItems.Get(i));

    DestroyWindow(GetWnd());


    return TRUE;
}

/*------------------------------------------------------------------------------

   ShowSubPopup

------------------------------------------------------------------------------*/
void CUIFMenu::ShowSubPopup(CUIFMenu *pcuiParentMenu, const RECT *prc, BOOL fVertical)
{
    _pcuiParentMenu = pcuiParentMenu;
    InitShow(pcuiParentMenu, prc, fVertical, TRUE);    // TODO: fAnimate = FALSE if submenu has already been shown, or going to be changed contibuously
}

/*------------------------------------------------------------------------------

   OnLButtonUp

------------------------------------------------------------------------------*/
void CUIFMenu::HandleMouseMsg( UINT uMsg, POINT pt )
{
    if (!PtInRect(&GetRectRef(), pt))
    {
        if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN) ||
            (uMsg == WM_LBUTTONUP) || (uMsg == WM_RBUTTONUP))
        {
            SetSelectedId(CUI_MENU_UNSELECTED);
            PostMessage(GetWnd(), WM_NULL, 0, 0);
        }
    }

    CUIFWindow::HandleMouseMsg( uMsg, pt );
}

/*------------------------------------------------------------------------------

   CancelMenu

------------------------------------------------------------------------------*/
void CUIFMenu::CancelMenu()
{
    if (_pcuiParentMenu)
    {
        UninitShow();
        return;
    }

    if (!_fInModal)
        return;

    SetSelectedId(CUI_MENU_UNSELECTED);
    PostMessage(GetWnd(), WM_NULL, 0, 0);
}

/*------------------------------------------------------------------------------

   CancelMenu

------------------------------------------------------------------------------*/
void CUIFMenu::SetSelectedId(UINT uId)
{
    if (_pcuiParentMenu)
    {
        _pcuiParentMenu->SetSelectedId(uId);
        return;
    }
    _uIdSelect = uId;
}

/*------------------------------------------------------------------------------

   GetTopSubMenu

------------------------------------------------------------------------------*/
CUIFMenu *CUIFMenu::GetTopSubMenu()
{
    if (_pCurrentSubMenu)
        return _pCurrentSubMenu->GetTopSubMenu();

    return this;
}

/*------------------------------------------------------------------------------

   PostKey

------------------------------------------------------------------------------*/
void CUIFMenu::PostKey(BOOL fUp, WPARAM wParam, LPARAM lParam)
{
    if (!_fInModal)
        return;

    if (fUp)
        PostMessage(0, WM_KEYUP, wParam, lParam);
    else
        PostMessage(0, WM_KEYDOWN, wParam, lParam);
}

/*------------------------------------------------------------------------------

   ModalMouseNotify

------------------------------------------------------------------------------*/
void CUIFMenu::ModalMouseNotify( UINT uMsg, POINT pt)
{
    if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN))
        CancelMenu();
}

/*------------------------------------------------------------------------------

   OnKeyDown

------------------------------------------------------------------------------*/
void CUIFMenu::OnKeyDown(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    UINT uVKey = (UINT)wParam & 0xff;
    CUIFMenuItem *pItem;

    switch (uVKey)
    {
         case VK_ESCAPE:
            CancelMenu();
            break;

         case VK_UP:
            pItem = GetPrevItem(_pSelectedItem);
            goto MoveToItem;

         case VK_DOWN:
            pItem = GetNextItem(_pSelectedItem);
MoveToItem:
            SetSelectedItem(pItem);
            break;

         case VK_RIGHT:
            if (_pSelectedItem && _pSelectedItem->GetSub())
            {
                _pSelectedItem->ShowSubPopup();
                CUIFMenu *pSubMenu = _pSelectedItem->GetSub();
                CUIFMenuItem *pSubMenuItem = pSubMenu->GetNextItem(NULL);
                pSubMenu->SetSelectedItem(pSubMenuItem);
            }
            break;

         case VK_LEFT:
            if (_pcuiParentMenu)
                CancelMenu();
            break;

         case VK_RETURN:
DoReturn:
            if (_pSelectedItem)
            {
                if (_pSelectedItem->IsGrayed())
                    break;

                if (_pSelectedItem->GetSub())
                {
                    _pSelectedItem->ShowSubPopup();
                    CUIFMenu *pSubMenu = _pSelectedItem->GetSub();
                    CUIFMenuItem *pSubMenuItem = pSubMenu->GetNextItem(NULL);
                    pSubMenu->SetSelectedItem(pSubMenuItem);
                }
                else
                {
                    SetSelectedId(_pSelectedItem->GetId());
                    PostMessage(GetWnd(), WM_NULL, 0, 0);
                }
            }
            else
            { 
                CancelMenu();
            }
            break;

         default:
            if ((uVKey >= 'A' && uVKey <= 'Z') ||
                (uVKey >= '0' && uVKey <= '9'))
            {
                int nCnt = _rgItems.GetCount();
                int i;
                for (i = 0; i < nCnt; i++)
                {
                    pItem = _rgItems.Get(i);
                    Assert(PtrToInt(pItem));
                    if (pItem->GetVKey() == uVKey)
                    {
                        SetSelectedItem(pItem);
                        goto DoReturn;
                    }
                }
            }
            break;

    }
}

/*------------------------------------------------------------------------------

   OnKeyUp

------------------------------------------------------------------------------*/
void CUIFMenu::OnKeyUp(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
}

/*------------------------------------------------------------------------------

   GetNextItem

------------------------------------------------------------------------------*/
CUIFMenuItem *CUIFMenu::GetNextItem(CUIFMenuItem *pItem)
{
    int nCnt = _rgItems.GetCount();
    CUIFMenuItem *pItemTmp;
    int i;

    if (!nCnt)
        return NULL;

    if (!_pSelectedItem)
        return _rgItems.Get(0);

    for (i = 0; i < nCnt; i++)
    {
        pItemTmp = _rgItems.Get(i);
        Assert(PtrToInt(pItemTmp));

        if (pItem == pItemTmp)
        {
            i++;
            break;
        }
    }

    if (i == nCnt)
        i = 0;

    pItemTmp = _rgItems.Get(i);
    while (pItemTmp && pItemTmp->IsNonSelectedItem())
    {
        i++;
        if (i == nCnt)
            i = 0;
        pItemTmp = _rgItems.Get(i);
    }

    return pItemTmp;
}

/*------------------------------------------------------------------------------

   GetPrevItem

------------------------------------------------------------------------------*/
CUIFMenuItem *CUIFMenu::GetPrevItem(CUIFMenuItem *pItem)
{
    int nCnt = _rgItems.GetCount();
    CUIFMenuItem *pItemTmp = NULL;
    int i;

    if (!nCnt)
        return NULL;

    if (!_pSelectedItem)
        return _rgItems.Get(nCnt - 1);

    for (i = nCnt - 1; i >= 0; i--)
    {
        pItemTmp = _rgItems.Get(i);
        Assert(PtrToInt(pItemTmp));

        if (pItem == pItemTmp)
        {
            i--;
            break;
        }
    }

    if (i < 0)
        i = nCnt - 1;

    pItemTmp = _rgItems.Get(i);
    while (pItemTmp && pItemTmp->IsNonSelectedItem())
    {
        i--;
        if (i < 0)
            i = nCnt - 1;
        pItemTmp = _rgItems.Get(i);
    }

    return pItemTmp;
}

/*------------------------------------------------------------------------------

   SetMenuFont

------------------------------------------------------------------------------*/

void CUIFMenu::SetMenuFont()
{
    NONCLIENTMETRICS ncm;
    int nMarlettFontSize = 14;

    ncm.cbSize = sizeof(ncm);
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
    {
        HFONT hFont = CreateFontIndirect(&ncm.lfMenuFont);
        SetFont(hFont);
        nMarlettFontSize = (ncm.lfMenuFont.lfHeight > 0) ?
                            ncm.lfMenuFont.lfHeight :
                            -ncm.lfMenuFont.lfHeight;
        nMarlettFontSize = (ncm.iMenuHeight + nMarlettFontSize) / 2;
    }

    _hfontMarlett = CreateFont(nMarlettFontSize, 0, 0, 0, 400, FALSE, FALSE, FALSE, SYMBOL_CHARSET, 0, 0, 0, 0, "Marlett");

    _cxMenuCheck = nMarlettFontSize;

    int cxSmIcon = GetSystemMetrics( SM_CXSMICON );
    if (_cxMenuCheck < cxSmIcon)
        _cxMenuCheck = cxSmIcon;

    _cxMenuCheck += 2;
}

/*------------------------------------------------------------------------------

   ClearMenuFont

------------------------------------------------------------------------------*/

void CUIFMenu::ClearMenuFont()
{
    HFONT hFont = GetFont();
    SetFont(NULL);
    DeleteObject(hFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuimenu.h ===
//
// cuimenu.h
//


#ifndef CUIMENU_H
#define CUIMENU_H

#include "cuiwnd.h"

#define CUI_MENU_UNSELECTED (UINT)(-1)

class CUIFMenu;

#define UIMENUITEM_NONSELECTEDITEM  0x0001
#define UIMENUITEM_MULTICOLUMNITEM  0x0002

//-----------------------------------------------------------------------------
//
// CUIFMenuItem
//
//-----------------------------------------------------------------------------

class CUIFMenuItem : public CUIFObject
{
public:
    CUIFMenuItem(CUIFMenu *pMenu, DWORD dwFlags = 0);
    virtual ~CUIFMenuItem(void);

    BOOL Init(UINT uId, WCHAR *psz);
    void SetBitmap(HBITMAP hbmp);
    void SetBitmapMask( HBITMAP hBmp );
    void Check(BOOL bChecked);
    void RadioCheck(BOOL bChecked);
    void Gray(BOOL bGrayed);
    BOOL IsGrayed() {return _bGrayed;}
    virtual void InitMenuExtent();
    void SetSub(CUIFMenu *pMenu);
    CUIFMenu *GetSub() {return _pSubMenu;}
    CUIFMenu *GetMenu() {return _pMenu;}
    void ShowSubPopup();

    virtual void OnLButtonUp(POINT pt);
    virtual void OnMouseIn(POINT pt);
    virtual void OnMouseOut(POINT pt);

    virtual void OnPaint(HDC hdc);
    virtual void OnPaintDef(HDC hdc);
    virtual void OnPaintO10(HDC hdc);
    virtual void OnTimer();
    virtual BOOL IsSeparator() {return FALSE;}
    BOOL IsNonSelectedItem() {return _bNonSelectedItem;}

    UINT GetId() {return _uId;}

    UINT GetVKey() {return _uShortcutkey;}

    BOOL IsCheck() {return (_bChecked || _bRadioChecked) ? TRUE : FALSE;}
    BOOL IsBmp()   {return (_hbmp) ? TRUE : FALSE;}
    BOOL IsStr()   {return (_psz) ? TRUE : FALSE;}

    BOOL GetMenuExtent(SIZE *psize)
    {
        *psize = _size;
        return TRUE;
    }

    int GetTabTextLength() {return _sizeTab.cx;}

protected:
    void DrawUnderline(HDC hDC, int x, int y, HBRUSH hbr);
    void DrawCheck(HDC hDC, int x, int y);
    void DrawArrow(HDC hDC, int x, int y);
    void DrawBitmapProc( HDC hDC, int x, int y);

    UINT _uId;
    WCHAR *_psz;
    UINT  _cch;
    WCHAR *_pszTab;
    UINT  _cchTab;
    UINT  _uShortcutkey;
    UINT  _uUnderLine;
    HBITMAP _hbmp;
    HBITMAP _hbmpMask;
    BOOL _bChecked;
    BOOL _bRadioChecked;
    BOOL _bGrayed;
    BOOL _bNonSelectedItem;
    CUIFMenu *_pMenu;
    CUIFMenu *_pSubMenu;

    SIZE _size;
    SIZE _sizeTab;
};

//-----------------------------------------------------------------------------
//
// CUIFMenuItemSeparator
//
//-----------------------------------------------------------------------------

class CUIFMenuItemSeparator : public CUIFMenuItem
{
public:
    CUIFMenuItemSeparator(CUIFMenu *pMenu) : CUIFMenuItem(pMenu, UIMENUITEM_NONSELECTEDITEM) 
    {
        _uId = (UINT)-1;
    }

    virtual ~CUIFMenuItemSeparator(void) {}

    virtual void InitMenuExtent();
    virtual void OnPaint(HDC hDC);
    virtual void OnPaintDef(HDC hdc);
    virtual void OnPaintO10(HDC hdc);
    virtual BOOL IsSeparator() {return TRUE;}
};

//-----------------------------------------------------------------------------
//
// CUIFMenu
//
//-----------------------------------------------------------------------------

#define UIMENU_MULTICOLUMN      0x00000001

class CUIFMenu : public CUIFWindow
{
public:
    CUIFMenu(HINSTANCE hInst, DWORD dwWndStyle, DWORD dwMenuStyle);
    virtual ~CUIFMenu(void);

    BOOL InsertItem(CUIFMenuItem *pItem);
    BOOL InsertSeparator();
    UINT ShowModalPopup(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical);
    void ModalMouseNotify( UINT uMsg, POINT pt);
    void ShowSubPopup(CUIFMenu *pcuiParentMenu, const RECT *prc, BOOL fVertical);
    void HandleMouseMsg( UINT uMsg, POINT pt );

    HFONT GetMarlettFont() {return _hfontMarlett;}

    void CancelMenu();
    void PostKey(BOOL fUp, WPARAM wParam, LPARAM lParam);
    void SetSelectedId(UINT uId);
    void OnKeyDown(HWND hwnd, WPARAM wParam, LPARAM lParam);
    void OnKeyUp(HWND hwnd, WPARAM wParam, LPARAM lParam);

    void CancelSubMenu()
    {
        if (_pCurrentSubMenu)
            _pCurrentSubMenu->CancelMenu();
    }

    CUIFMenu *GetCurrentSubMenu()
    {
        return _pCurrentSubMenu;
    }

    void SetSelectedItem(CUIFMenuItem *pItem)
    {
        if (_pSelectedItem == pItem)
            return;

        CUIFMenuItem *pOldItem = _pSelectedItem;
        _pSelectedItem = pItem;

        if (pOldItem)
            pOldItem->CallOnPaint();
        if (_pSelectedItem)
            _pSelectedItem->CallOnPaint();
    }

    BOOL IsSelectedItem(CUIFMenuItem *pItem)
    {
        return (_pSelectedItem == pItem) ? TRUE : FALSE;
    }

    BOOL IsBmpCheckItem() {return _fIsBmpCheckItem;}
    BOOL IsO10Menu() {return  FHasStyle( UIWINDOW_OFC10MENU ) ? TRUE : FALSE;}
    int GetMenuCheckWidth() {return _cxMenuCheck;}
    int GetMaxTabTextLength() {return _cxMaxTab;}

protected:
    virtual void ModalMessageLoop( void );
    virtual BOOL InitShow(CUIFWindow *pcuiWndParent, const RECT *prc, BOOL fVertical, BOOL fAnimate);
    virtual BOOL UninitShow();
    CUIFMenu *GetTopSubMenu();
    CUIFMenuItem *GetNextItem(CUIFMenuItem *pItem);
    CUIFMenuItem *GetPrevItem(CUIFMenuItem *pItem);
    void SetMenuFont();
    void ClearMenuFont();

    CUIFMenu *_pcuiParentMenu;
    CUIFMenu *_pCurrentSubMenu;
    CUIFMenuItem *_pSelectedItem;

    UINT _uIdSelect;
    CUIFObjectArray<CUIFMenuItem> _rgItems;
    HFONT _hfontMarlett;
    BOOL _fInModal;
    BOOL _fIsBmpCheckItem;
    DWORD _dwMenuStyle;

    int _cxMenuCheck;
    int _cxMaxTab;
};


#endif // CUIMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuires.h ===
//
// cuires.h
//

#ifndef CUIRES_H
#define CUIRES_H

#define CUI_IDS_OK          100
#define CUI_IDS_CANCEL      101
#define CUI_IDS_ABORT       102
#define CUI_IDS_RETRY       103
#define CUI_IDS_IGNORE      104
#define CUI_IDS_YES         105
#define CUI_IDS_NO          106

#endif // CUIRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuischem.cpp ===
//
// cuischem.cpp
//  = UIF scheme implementation = 
//

#include "private.h"
#include "cuischem.h"
#include "cuisys.h"
#include "cmydc.h"
#include "cuiutil.h"
#include "math.h"


//
// gloval variables
//

static class CUIFColorTableSys   *v_pColTableSys   = NULL;
static class CUIFColorTableOff10 *v_pColTableOfc10 = NULL;



/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C O L O R  T A B L E                                            */
/*                                                                             */
/*=============================================================================*/

typedef enum _SYSCOLOR
{ 
    SYSCOLOR_3DFACE,
    SYSCOLOR_3DSHAODW,
    SYSCOLOR_ACTIVEBORDER,
    SYSCOLOR_ACTIVECAPTION,
    SYSCOLOR_BTNFACE,
    SYSCOLOR_BTNSHADOW,
    SYSCOLOR_BTNTEXT,
    SYSCOLOR_CAPTIONTEXT,
    SYSCOLOR_GRAYTEXT,
    SYSCOLOR_HIGHLIGHT,
    SYSCOLOR_HIGHLIGHTTEXT,
    SYSCOLOR_INACTIVECAPTION,
    SYSCOLOR_INACTIVECAPTIONTEXT,
    SYSCOLOR_MENUTEXT,
    SYSCOLOR_WINDOW,
    SYSCOLOR_WINDOWTEXT,
    
    SYSCOLOR_MAX                /* must be last */
} SYSCOLOR;


typedef enum _OFC10COLOR
{ 
    OFC10COLOR_BKGDTB,                  // msocbvcrCBBkgd
    OFC10COLOR_BKGDMENU,                // msocbvcrCBMenuBkgd
    OFC10COLOR_BKGDWP,                  // msocbvcrWPBkgd
    OFC10COLOR_MENUBARSHORT,            // msocbvcrCBMenuIconBkgd
    OFC10COLOR_MENUBARLONG,             // msocbvcrCBMenuIconBkgdDropped
    OFC10COLOR_MOUSEOVERBKGND,          // msocbvcrCBCtlBkgdMouseOver
    OFC10COLOR_MOUSEOVERBORDER,         // msocbvcrCBCtlBdrMouseOver
    OFC10COLOR_MOUSEOVERTEXT,           // msocbvcrCBCtlTextMouseOver
    OFC10COLOR_MOUSEDOWNBKGND,          // msocbvcrCBCtlBkgdMouseDown
    OFC10COLOR_MOUSEDOWNBORDER,         // msocbvcrCBCtlBdrMouseDown
    OFC10COLOR_MOUSEDOWNTEXT,           // msocbvcrCBCtlTextMouseDown
    OFC10COLOR_CTRLBKGD,                // msocbvcrCBCtlBkgd
    OFC10COLOR_CTRLTEXT,                // msocbvcrCBCtlText
    OFC10COLOR_CTRLTEXTDISABLED,        // msocbvcrCBCtlTextDisabled
    OFC10COLOR_CTRLIMAGESHADOW,         // REVIEW: KOJIW: office calcs shadow color from bkgnd (not constant color)
    OFC10COLOR_CTRLBKGDSELECTED,        // msocbvcrCBCtlBkgdSelected
    OFC10COLOR_CTRLBORDERSELECTED,      // msocbvcrCBCtlBdrSelected
//  OFC10COLOR_CTRLDBRDISABLED,         // 
    OFC10COLOR_BDROUTERMENU,            // msocbvcrCBMenuBdrOuter
    OFC10COLOR_BDRINNERMENU,            // msocbvcrCBMenuBdrInner
    OFC10COLOR_BDROUTERFLOATTB,         // msocbvcrCBBdrOuterFloating
    OFC10COLOR_BDRINNERFLOATTB,         // msocbvcrCBBdrInnerFloating
    OFC10COLOR_BDROUTERFLOATWP,         // msocbvcrWPBdrOuterFloating
    OFC10COLOR_BDRINNERFLOATWP,         // msocbvcrWPBdrInnerFloating
    OFC10COLOR_CAPTIONBKGDTB,           // msocbvcrCBTitleBkgd
    OFC10COLOR_CAPTIONTEXTTB,           // msocbvcrCBTitleText
    OFC10COLOR_ACTIVECAPTIONBKGDWP,     // msocbvcrWPTitleBkgdActive
    OFC10COLOR_ACTIVECAPTIONTEXTWP,     // msocbvcrWPTitleTextActive
    OFC10COLOR_INACTIVECAPTIONBKGDWP,   // msocbvcrWPTitleBkgdInactive
    OFC10COLOR_INACTIVECAPTIONTEXTWP,   // msocbvcrWPTitleTextInactive
    OFC10COLOR_SPLITTERLINE,            // msocbvcrCBSplitterLine
    OFC10COLOR_DRAGHANDLE,              // msocbvcrCBDragHandle
    OFC10COLOR_MENUCTRLTEXT,            // msocbvcrCBMenuCtlText

    OFC10COLOR_MAX              /* must be last */
} OFC10COLOR;

/*============================================================================*/
/*
	Contrast Increasing Code
*/
/*============================================================================*/

typedef double CIC_NUM;
// Sizes of color channels in weighted RGB space.

#define MAX_RED   195
#define MAX_GREEN 390
#define MAX_BLUE   65

/*
A note on "dMinContrast":
0 contrast means the two colors are the same.
Black and White have a contrast of roughly 442, which is the maximum contrast
two colors can have.
The most you can request to have between two colors is 221, since if
one color is 50% grey, the furthest you can be from it is 221 away
(at white or black).
*/

#define MIN_TEXT_CONTRAST 180
#define MIN_ICON_CONTRAST 90
struct COLORCONTRAST
{
	OFC10COLOR colLocked; // will not be changed by CIC
	OFC10COLOR colMoveable; // might be changed by CIC
	CIC_NUM    cMinContrast; // minimum contrast required between locked and moveable
	BOOL       fConsiderDarkness; // take into consideration the effects of dark colors
};
    
static const COLORCONTRAST vrgContrast[] =
{
    // Locked                           Moveable                            Contrast    Darkness
    OFC10COLOR_BKGDTB,            OFC10COLOR_CTRLTEXT,               MIN_TEXT_CONTRAST, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_CTRLTEXTDISABLED,       80, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEOVERBKGND,         50, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEOVERBORDER,        100, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_CTRLBKGDSELECTED,      5, TRUE, // TODO DMORTON - need larger value
//  OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEOVERSELECTED,      30, TRUE,
//  OFC10COLOR_MOUSEOVERSELECTED, OFC10COLOR_MOUSEOVERSELECTEDBORDER,100, TRUE,
    OFC10COLOR_MOUSEOVERBKGND,    OFC10COLOR_MOUSEOVERTEXT,          MIN_TEXT_CONTRAST, TRUE,
    OFC10COLOR_BKGDTB,            OFC10COLOR_MOUSEDOWNBKGND,         30, TRUE,
    OFC10COLOR_MOUSEDOWNBKGND,    OFC10COLOR_MOUSEDOWNTEXT,          MIN_TEXT_CONTRAST, TRUE,
    OFC10COLOR_BKGDMENU,          OFC10COLOR_MENUCTRLTEXT,           MIN_TEXT_CONTRAST, TRUE,
//  OFC10COLOR_BKGDMENU,          OFC10COLOR_MENUCTRLTEXTDISABLED,   80, TRUE,
//  OFC10COLOR_BKGDMENU,          OFC10COLOR_MENUCTRLBORDER,         100, TRUE,
    OFC10COLOR_CAPTIONBKGDTB ,    OFC10COLOR_CAPTIONTEXTTB,          MIN_TEXT_CONTRAST, TRUE,
	OFC10COLOR_BKGDMENU,          OFC10COLOR_DRAGHANDLE,             85, TRUE,
};


//
// CUIFColorTableBase
//

class CUIFColorTable
{
public:
    CUIFColorTable( void )
    {
    }

    virtual ~CUIFColorTable( void )
    {
        DoneColor();
        DoneBrush();
    }

    void Initialize( void )
    {
        InitColor();
        InitBrush();
    }

    void Update( void )
    {
        DoneColor();
        DoneBrush();
        InitColor();
        InitBrush();
    }

protected:
    virtual void InitColor( void ) {}
    virtual void DoneColor( void ) {}
    virtual void InitBrush( void ) {}
    virtual void DoneBrush( void ) {}
};


//
// CUIFColorTableSys
//

class CUIFColorTableSys : public CUIFColorTable
{
public:
    CUIFColorTableSys( void ) : CUIFColorTable()
    {
    }

    virtual ~CUIFColorTableSys( void )
    {
        DoneColor();
        DoneBrush();
    }

    __inline COLORREF GetColor( SYSCOLOR iColor )
    {
        return m_rgColor[ iColor ];
    }

    __inline HBRUSH GetBrush( SYSCOLOR iColor )
    {
        if (!m_rgBrush[iColor])
            m_rgBrush[iColor] = CreateSolidBrush( m_rgColor[iColor] );

        return m_rgBrush[ iColor ];
    }

protected:
    COLORREF m_rgColor[ SYSCOLOR_MAX ];
    HBRUSH   m_rgBrush[ SYSCOLOR_MAX ];

    virtual void InitColor( void )
    {
        m_rgColor[ SYSCOLOR_3DFACE              ] = GetSysColor( COLOR_3DFACE              );
        m_rgColor[ SYSCOLOR_3DSHAODW            ] = GetSysColor( COLOR_3DSHADOW            );
        m_rgColor[ SYSCOLOR_ACTIVEBORDER        ] = GetSysColor( COLOR_ACTIVEBORDER        );
        m_rgColor[ SYSCOLOR_ACTIVECAPTION       ] = GetSysColor( COLOR_ACTIVECAPTION       );
        m_rgColor[ SYSCOLOR_BTNFACE             ] = GetSysColor( COLOR_BTNFACE             );
        m_rgColor[ SYSCOLOR_BTNSHADOW           ] = GetSysColor( COLOR_BTNSHADOW           );
        m_rgColor[ SYSCOLOR_BTNTEXT             ] = GetSysColor( COLOR_BTNTEXT             );
        m_rgColor[ SYSCOLOR_CAPTIONTEXT         ] = GetSysColor( COLOR_CAPTIONTEXT         );
        m_rgColor[ SYSCOLOR_GRAYTEXT            ] = GetSysColor( COLOR_GRAYTEXT            );
        m_rgColor[ SYSCOLOR_HIGHLIGHT           ] = GetSysColor( COLOR_HIGHLIGHT           );
        m_rgColor[ SYSCOLOR_HIGHLIGHTTEXT       ] = GetSysColor( COLOR_HIGHLIGHTTEXT       );
        m_rgColor[ SYSCOLOR_INACTIVECAPTION     ] = GetSysColor( COLOR_INACTIVECAPTION     );
        m_rgColor[ SYSCOLOR_INACTIVECAPTIONTEXT ] = GetSysColor( COLOR_INACTIVECAPTIONTEXT );
        m_rgColor[ SYSCOLOR_MENUTEXT            ] = GetSysColor( COLOR_MENUTEXT            );
        m_rgColor[ SYSCOLOR_WINDOW              ] = GetSysColor( COLOR_WINDOW              );
        m_rgColor[ SYSCOLOR_WINDOWTEXT          ] = GetSysColor( COLOR_WINDOWTEXT          );
        m_rgColor[ SYSCOLOR_3DSHAODW            ] = GetSysColor( COLOR_3DSHADOW            );
    }

    virtual void DoneColor( void )
    {
    }

    virtual void InitBrush( void )
    {
        for (int i = 0; i < SYSCOLOR_MAX; i++) {
            m_rgBrush[i] = NULL;
        }
    }

    virtual void DoneBrush( void )
    {
        for (int i = 0; i < SYSCOLOR_MAX; i++) {
            if (m_rgBrush[i]) {
                DeleteObject( m_rgBrush[i] );
                m_rgBrush[i] = NULL;
            }
        }
    }
};


//
// CUIFColorTableOff10
//

class CUIFColorTableOff10 : public CUIFColorTable
{
public:
    CUIFColorTableOff10( void ) : CUIFColorTable()
    {
    }

    virtual ~CUIFColorTableOff10( void )
    {
        DoneColor();
        DoneBrush();
    }

    __inline COLORREF GetColor( OFC10COLOR iColor )
    {
        return m_rgColor[ iColor ];
    }

    __inline HBRUSH GetBrush( OFC10COLOR iColor )
    {
        if (!m_rgBrush[iColor])
            m_rgBrush[iColor] = CreateSolidBrush( m_rgColor[iColor] );

        return m_rgBrush[ iColor ];
    }

protected:
    COLORREF m_rgColor[ OFC10COLOR_MAX ];
    HBRUSH   m_rgBrush[ OFC10COLOR_MAX ];

    virtual void InitColor( void )
    {
        if (UIFIsLowColor() || UIFIsHighContrast()) {
            if (UIFIsHighContrast()) {
                // high contrast setting
                m_rgColor[ OFC10COLOR_MENUBARLONG           ] = col( COLOR_BTNFACE );
                m_rgColor[ OFC10COLOR_MOUSEOVERBKGND        ] = col( COLOR_HIGHLIGHT );
                m_rgColor[ OFC10COLOR_MOUSEOVERBORDER       ] = col( COLOR_MENUTEXT );
                m_rgColor[ OFC10COLOR_MOUSEOVERTEXT         ] = col( COLOR_HIGHLIGHTTEXT);
                m_rgColor[ OFC10COLOR_CTRLBKGDSELECTED      ] = col( COLOR_HIGHLIGHT );
                m_rgColor[ OFC10COLOR_CTRLBORDERSELECTED    ] = col( COLOR_MENUTEXT );
            }
            else {
                // low color setting
                m_rgColor[ OFC10COLOR_MENUBARLONG           ] = col( COLOR_BTNSHADOW );
                m_rgColor[ OFC10COLOR_MOUSEOVERBKGND        ] = col( COLOR_WINDOW );
                m_rgColor[ OFC10COLOR_MOUSEOVERBORDER       ] = col( COLOR_HIGHLIGHT );
                m_rgColor[ OFC10COLOR_MOUSEOVERTEXT         ] = col( COLOR_WINDOWTEXT );
                m_rgColor[ OFC10COLOR_CTRLBKGDSELECTED      ] = col( COLOR_WINDOW );
                m_rgColor[ OFC10COLOR_CTRLBORDERSELECTED    ] = col( COLOR_HIGHLIGHT );
            }

            // common setting
            m_rgColor[ OFC10COLOR_BKGDTB                ] = col( COLOR_BTNFACE ); 
            m_rgColor[ OFC10COLOR_BKGDMENU              ] = col( COLOR_WINDOW );
            m_rgColor[ OFC10COLOR_BKGDWP                ] = col( COLOR_WINDOW );
            m_rgColor[ OFC10COLOR_MENUBARSHORT          ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_MOUSEDOWNBKGND        ] = col( COLOR_HIGHLIGHT);
            m_rgColor[ OFC10COLOR_MOUSEDOWNBORDER       ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_MOUSEDOWNTEXT         ] = col( COLOR_HIGHLIGHTTEXT);
            m_rgColor[ OFC10COLOR_CTRLBKGD              ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_CTRLTEXT              ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_CTRLTEXTDISABLED      ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_CTRLIMAGESHADOW       ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_BDROUTERMENU          ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_BDRINNERMENU          ] = col( COLOR_WINDOW );
            m_rgColor[ OFC10COLOR_BDROUTERFLOATTB       ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATTB       ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_BDROUTERFLOATWP       ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATWP       ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_CAPTIONBKGDTB         ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_CAPTIONTEXTTB         ] = col( COLOR_CAPTIONTEXT );
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONBKGDWP   ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONTEXTWP   ] = col( COLOR_HIGHLIGHTTEXT );
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONBKGDWP ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONTEXTWP ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_SPLITTERLINE          ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_DRAGHANDLE            ] = col( COLOR_BTNTEXT );

            m_rgColor[ OFC10COLOR_SPLITTERLINE          ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_MENUCTRLTEXT          ] = col( COLOR_WINDOWTEXT );
        }
        else {
            m_rgColor[ OFC10COLOR_BKGDTB                ] = col( 835, col( COLOR_BTNFACE ), 165, col( COLOR_WINDOW ) ); 
            m_rgColor[ OFC10COLOR_BKGDMENU              ] = col( 15, col( COLOR_BTNFACE ),   85, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_BKGDWP                ] = col( 15, col( COLOR_BTNFACE ),   85, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MENUBARSHORT          ] = col(835, col( COLOR_BTNFACE ),  165, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MENUBARLONG           ] = col( 90, col( COLOR_BTNFACE ),   10, col( COLOR_BTNSHADOW ) );
            m_rgColor[ OFC10COLOR_MOUSEOVERBKGND        ] = col( 30, col( COLOR_HIGHLIGHT ), 70, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MOUSEOVERBORDER       ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_MOUSEOVERTEXT         ] = col( COLOR_MENUTEXT );
            m_rgColor[ OFC10COLOR_MOUSEDOWNBKGND        ] = col( 50, col( COLOR_HIGHLIGHT ), 50, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MOUSEDOWNBORDER       ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_MOUSEDOWNTEXT         ] = col( COLOR_HIGHLIGHTTEXT );
            m_rgColor[ OFC10COLOR_CTRLBKGD              ] = m_rgColor[ OFC10COLOR_BKGDTB              ];
            m_rgColor[ OFC10COLOR_CTRLTEXT              ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_CTRLTEXTDISABLED      ] = col( 90, col( COLOR_BTNSHADOW ), 10, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_CTRLBKGDSELECTED      ] = col( 10, col( COLOR_HIGHLIGHT ), 50,  m_rgColor[ OFC10COLOR_CTRLBKGD], 40, col( COLOR_WINDOW));
            m_rgColor[ OFC10COLOR_CTRLIMAGESHADOW       ] = col( 75, m_rgColor[ OFC10COLOR_MOUSEOVERBKGND ], 25, RGB( 0x00, 0x00, 0x00 ) );    // REVIEW: KOJIW: bkgnd s always OFC10COLOR_MOUSEOVERBKGND???
            m_rgColor[ OFC10COLOR_CTRLBORDERSELECTED    ] = col( COLOR_HIGHLIGHT );
            m_rgColor[ OFC10COLOR_BDROUTERMENU          ] = col( 20, col( COLOR_BTNTEXT ), 80, col( COLOR_BTNSHADOW ) );
            m_rgColor[ OFC10COLOR_BDRINNERMENU          ] = m_rgColor[ OFC10COLOR_BKGDMENU            ];
            m_rgColor[ OFC10COLOR_BDROUTERFLOATTB       ] = col( 15, col( COLOR_BTNTEXT ), 85, col( COLOR_BTNSHADOW ) );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATTB       ] = m_rgColor[ OFC10COLOR_BKGDTB              ];
            m_rgColor[ OFC10COLOR_BDROUTERFLOATWP       ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_BDRINNERFLOATWP       ] = m_rgColor[ OFC10COLOR_BKGDWP              ];
            m_rgColor[ OFC10COLOR_CAPTIONBKGDTB         ] = col( COLOR_BTNSHADOW );
            m_rgColor[ OFC10COLOR_CAPTIONTEXTTB         ] = col( COLOR_CAPTIONTEXT );
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONBKGDWP   ] = m_rgColor[ OFC10COLOR_MOUSEOVERBKGND      ];
            m_rgColor[ OFC10COLOR_ACTIVECAPTIONTEXTWP   ] = m_rgColor[ OFC10COLOR_MOUSEOVERTEXT       ];
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONBKGDWP ] = col( COLOR_BTNFACE );
            m_rgColor[ OFC10COLOR_INACTIVECAPTIONTEXTWP ] = col( COLOR_BTNTEXT );
            m_rgColor[ OFC10COLOR_SPLITTERLINE          ] = col( 70, col( COLOR_BTNSHADOW ), 30, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_DRAGHANDLE            ] = col( 75, col( COLOR_BTNSHADOW ), 25, col( COLOR_WINDOW ) );
            m_rgColor[ OFC10COLOR_MENUCTRLTEXT          ] = col( COLOR_WINDOWTEXT );

            CbvFixContrastProblems();
        }
    }

    virtual void DoneColor( void )
    {
    }

    virtual void InitBrush( void )
    {
        for (int i = 0; i < OFC10COLOR_MAX; i++) {
            m_rgBrush[i] = NULL;
        }
    }

    virtual void DoneBrush( void )
    {
        for (int i = 0; i < OFC10COLOR_MAX; i++) {
            if (m_rgBrush[i]) {
                DeleteObject( m_rgBrush[i] );
                m_rgBrush[i] = NULL;
            }
        }
    }

    __inline COLORREF col( int iColor )
    {
        return GetSysColor( iColor );
    }

    COLORREF col( int r1, COLORREF col1, int r2, COLORREF col2 )
    {
        int sum = r1 + r2;

        Assert( sum == 10 || sum == 100 || sum == 1000 );
        int r = (r1 * GetRValue(col1) + r2 * GetRValue(col2) + sum/2) / sum;
        int g = (r1 * GetGValue(col1) + r2 * GetGValue(col2) + sum/2) / sum;
        int b = (r1 * GetBValue(col1) + r2 * GetBValue(col2) + sum/2) / sum;
        return RGB( r, g, b );

    }

    COLORREF col( int r1, COLORREF col1, int r2, COLORREF col2 , int r3, COLORREF col3)
    {
        int sum = r1 + r2 + r3;

        Assert( sum == 10 || sum == 100 || sum == 1000 );
        int r = (r1 * GetRValue(col1) + r2 * GetRValue(col2) + r3 * GetRValue(col3) + sum/3) / sum;
        int g = (r1 * GetGValue(col1) + r2 * GetGValue(col2) + r3 * GetGValue(col3) + sum/3) / sum;
        int b = (r1 * GetBValue(col1) + r2 * GetBValue(col2) + r3 * GetBValue(col3) + sum/3) / sum;
        return RGB( r, g, b );

    }

    
   /*---------------------------------------------------------------------------
       CCbvScaleContrastForDarkness

       As colors become darker, their contrast descreases, even if their
       distance apart stays fixed.

       ie. in the grayscale, 0 and 50 are the same distance apart as 205 and 255,
       but monitors/eyes see less difference between 0 and 50, than 205 and 255.

       This function increases the dContrast value, based on a dDarkness.

       This operation assumes the parameters are in the weighted RGB color space
       (the color space that the CIC uses), ie. 220 is middle of the road.

   ----------------------------------------------------------------- DMORTON -*/
   CIC_NUM CCbvScaleContrastForDarkness(CIC_NUM dContrast, CIC_NUM dDarkness)
   {
       return (2 - (min(dDarkness, 220)) / 220) * dContrast;
   }

   /*---------------------------------------------------------------------------
       CCbvGetContrastSquared
    
        As a speed improvement, whenever you don't need the real contrast, but
        instead can make due with the contrast squared, call this function
        and avoid the expensive sqrt call thats in CCbvGetContrast.
    
    ----------------------------------------------------------------- DMORTON -*/
    CIC_NUM CCbvGetContrastSquared(COLORREF cr1, COLORREF cr2)
    {
        // Transform the delta vector into weighted RGB color space
        CIC_NUM dRedD = (CIC_NUM)(GetRValue(cr1) - GetRValue(cr2)) * MAX_RED / 255;
        CIC_NUM dGreenD = (CIC_NUM)(GetGValue(cr1) - GetGValue(cr2)) * MAX_GREEN / 255;
        CIC_NUM dBlueD = (CIC_NUM)(GetBValue(cr1) - GetBValue(cr2)) * MAX_BLUE / 255;
    
        // Calculate its magnitude squared
        return(dRedD * dRedD + dGreenD * dGreenD + dBlueD * dBlueD);
    }
    
    /*---------------------------------------------------------------------------
        CCbvGetContrast
    
        Determines the contrast between cr1 and cr2.
    
        As the incoming parameters are COLORREFs, they must be in the
        normal RGB space.
    
        However, the result is given in the more usefull weighted RGB space.
    
    ----------------------------------------------------------------- DMORTON -*/
    CIC_NUM CCbvGetContrast(COLORREF cr1, COLORREF cr2)
    {
        // Calculate its magnitude - watch out for negative values
        return((CIC_NUM)sqrt((double)CCbvGetContrastSquared(cr1, cr2)));
    }
    
    
    /*---------------------------------------------------------------------------
        FCbvEnoughContrast
    
        Determines if crLocked and crMoveable meet the minimum contrast requirement,
        which is specified by dMinContrast.
    
        fDarkness will invoke consideration of how dark colors have less contrast,
        if its TRUE.  crLocked will be used to determine how dark the colors are.
    
    ----------------------------------------------------------------- DMORTON -*/
    BOOL FCbvEnoughContrast(COLORREF crLocked, COLORREF crMoveable,
                            CIC_NUM dMinContrast, BOOL fDarkness)
    {
        if (fDarkness)
        {
            // TODO DMORTON - how expensive is this CCbvGetContrast call?
            // Isn't it doing a square root?
            dMinContrast = CCbvScaleContrastForDarkness(dMinContrast,
                            CCbvGetContrast(crLocked, RGB(0, 0, 0)));
        }
    
        // Its much faster to square dMinContrast, then it is to square root
        // the calculated contrast.
        return(CCbvGetContrastSquared(crLocked, crMoveable) >
                 dMinContrast * dMinContrast);
    }
    
    /*---------------------------------------------------------------------------
        CbvIncreaseContrast
    
        Attempts to seperate crMoveable, from crLocked, so that their resulting
        contrast is at least cMinContrast.
    
        Its stupid to call this function if the colors already have this minimum
        contrast, so that case is asserted.
    
    ----------------------------------------------------------------- DMORTON -*/
    void CbvIncreaseContrast(COLORREF crLocked, COLORREF *pcrMoveable,
                             CIC_NUM cMinContrast)
    {
        CIC_NUM cLockedI = CCbvGetContrast(crLocked, RGB(0, 0, 0));
        CIC_NUM cMoveableI = CCbvGetContrast(*pcrMoveable, RGB(0, 0, 0));
    
        // Scale up dMinContrast if cLockedI is close to black, since we have
        // a hard time seeing differences in dark shades
        CIC_NUM cContrast = CCbvScaleContrastForDarkness(cMinContrast, cLockedI);
    
        BOOL fTowardsWhite;
    
        if (cMoveableI > cLockedI) // we want to move towards white
        {
            if (cLockedI < 442 - cContrast) // TODO DMORTON: is this a valid way of checking available distance to white?
            {
                fTowardsWhite = TRUE; // There is room towards white
            }
            else
            {
                fTowardsWhite = FALSE; // There is no room towards white, try black
            }
        }
        else // we want to move towards black
        {
            if (cLockedI > cContrast)
            {
                fTowardsWhite = FALSE; // There is room towards black
            }
            else
            {
                fTowardsWhite = TRUE; // There is no room towards black, try white
            }
        }

        // Convert to weighted color space
        CIC_NUM cRedL = GetRValue(crLocked) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenL = GetGValue(crLocked) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueL = GetBValue(crLocked) * (CIC_NUM) MAX_BLUE / 255;
    
        CIC_NUM cRedM = GetRValue(*pcrMoveable) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenM = GetGValue(*pcrMoveable) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueM = GetBValue(*pcrMoveable) * (CIC_NUM) MAX_BLUE / 255;
    
        if (fTowardsWhite)
        {
            // Convert everything so white is the origin
            cRedM = MAX_RED - cRedM;
            cGreenM = MAX_GREEN - cGreenM;
            cBlueM = MAX_BLUE - cBlueM;
    
            cRedL = MAX_RED - cRedL;
            cGreenL = MAX_GREEN - cGreenL;
            cBlueL = MAX_BLUE - cBlueL;
        }
    
        // Calculate the magnitude of the moveable color
        CIC_NUM cMagMove = (CIC_NUM)sqrt(cRedM * cRedM + cGreenM * cGreenM + cBlueM * cBlueM);
    
        // we don't want some floating point snafu to cause us
        // to go negative, or be zero
        cMagMove = max(0.001f, cMagMove);
    
        // Dot product the locked color and the moveable color
        CIC_NUM cLockDotMove = cRedL * cRedM + cGreenL * cGreenM + cBlueL * cBlueM;
        // Take the projection of the locked color onto the moveable color
        CIC_NUM cLockProjected = (cLockDotMove) / cMagMove;
        CIC_NUM cScale = cLockProjected / cMagMove;
    
        CIC_NUM cRedTemp = cScale * cRedM - cRedL;
        CIC_NUM cGreenTemp = cScale * cGreenM - cGreenL;
        CIC_NUM cBlueTemp = cScale * cBlueM - cBlueL;
    
        // Calculate the last side of the triangle,
        // this is simply r^2 = a^2 + b^2, solving for b.
        CIC_NUM cN = (CIC_NUM)sqrt(cContrast * cContrast -
                       (cRedTemp * cRedTemp + cGreenTemp * cGreenTemp +
                            cBlueTemp * cBlueTemp));
    
        CIC_NUM cNewMagMove = cLockProjected - cN;
    
        // Scale the unit moveable vector
        cRedM = cRedM * cNewMagMove / cMagMove;
        cGreenM = cGreenM * cNewMagMove / cMagMove;
        cBlueM = cBlueM * cNewMagMove / cMagMove;
    
        if (fTowardsWhite)
        {
            // Convert everything back again
            cRedM = MAX_RED - cRedM;
            cGreenM = MAX_GREEN - cGreenM;
            cBlueM = MAX_BLUE - cBlueM;
        }
    
        cRedM = min(MAX_RED, max(0, cRedM));
        cGreenM = min(MAX_GREEN, max(0, cGreenM));
        cBlueM = min(MAX_BLUE, max(0, cBlueM));
    
        // Convert back to normal RGB color space
        int cR = (int)(cRedM * 255 / MAX_RED + 0.5);
        int cG = (int)(cGreenM * 255 / MAX_GREEN + 0.5);
        int cB = (int)(cBlueM * 255 / MAX_BLUE + 0.5);
    
        cR = max(0, min(255, cR));
        cG = max(0, min(255, cG));
        cB = max(0, min(255, cB));
    
        *pcrMoveable = RGB(cR, cG, cB);
    }
    
    /*---------------------------------------------------------------------------
        CbvDecreaseContrast
    
        Attempts to pull crMoveable towards crLocked, so that their resulting
        contrast is at most cMaxContrast.
    
        Its stupid to call this function if the colors already have this maximum
        contrast, so that case is asserted.
    
    ----------------------------------------------------------------- DMORTON -*/
    void CbvDecreaseContrast(COLORREF crLocked, COLORREF *pcrMoveable, CIC_NUM cMaxContrast)
    {
        CIC_NUM cLockedI = CCbvGetContrast(crLocked, RGB(0, 0, 0));
    
        // Scale up dMaxContrast if cLockedI is close to black, since we have
        // a hard time seeing differences in dark shades
        CIC_NUM dContrast = CCbvScaleContrastForDarkness(cMaxContrast, cLockedI);
    
        CIC_NUM cRedL = GetRValue(crLocked) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenL = GetGValue(crLocked) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueL = GetBValue(crLocked) * (CIC_NUM) MAX_BLUE / 255;
    
        CIC_NUM cRedM = GetRValue(*pcrMoveable) * (CIC_NUM) MAX_RED / 255;
        CIC_NUM cGreenM = GetGValue(*pcrMoveable) * (CIC_NUM) MAX_GREEN / 255;
        CIC_NUM cBlueM = GetBValue(*pcrMoveable) * (CIC_NUM) MAX_BLUE / 255;
    
        CIC_NUM cRedDelta = cRedL - cRedM;
        CIC_NUM cGreenDelta = cGreenL - cGreenM;
        CIC_NUM cBlueDelta = cBlueL - cBlueM;
    
        // Add to moveable a fraction of delta, to get it closer to locked.
        CIC_NUM dMagDelta = (CIC_NUM)sqrt(cRedDelta * cRedDelta + cGreenDelta * cGreenDelta
                                    + cBlueDelta * cBlueDelta);
        CIC_NUM dScale = (dMagDelta - dContrast) / dMagDelta;
    
        cRedM += cRedDelta * dScale;
        cGreenM += cGreenDelta * dScale;
        cBlueM += cBlueDelta * dScale;
    
        cRedM = min(MAX_RED, max(0, cRedM));
        cGreenM = min(MAX_GREEN, max(0, cGreenM));
        cBlueM = min(MAX_BLUE, max(0, cBlueM));
    
        // Transform back into normal RGB space...
        int cR = (int)(cRedM * 255 / MAX_RED + 0.5);
        int cG = (int)(cGreenM * 255 / MAX_GREEN + 0.5);
        int cB = (int)(cBlueM * 255 / MAX_BLUE + 0.5);
    
        cR = max(0, min(255, cR));
        cG = max(0, min(255, cG));
        cB = max(0, min(255, cB));
    
        *pcrMoveable = RGB(cR, cG, cB);
    
    }
    
    
    /*---------------------------------------------------------------------------
        CbvFixContrastProblems
    
        Goes through all crucial combinations of colors, ensuring that minimum
        and maximum contrasts are in place.
    
    ----------------------------------------------------------------- DMORTON -*/
    void CbvFixContrastProblems()
    {
#if 0
        if (FCbvEnoughContrast(m_rgColor[OFC10COLOR_MAINMENUBKGD],
                               m_rgColor[OFC10COLOR_BKGDTB], 35, TRUE))
        {
            CbvDecreaseContrast(m_rgColor[OFC10COLOR_MAINMENUBKGD],
                                &(m_rgColor[OFC10COLOR_BKGDTB]), 35);
        }
#else

        if (FCbvEnoughContrast(col(COLOR_BTNFACE),
                               m_rgColor[OFC10COLOR_BKGDTB], 35, TRUE))
        {
            CbvDecreaseContrast(col(COLOR_BTNFACE),
                                &(m_rgColor[OFC10COLOR_BKGDTB]), 35);
        }
#endif

        int i;
        for(i = 0; i < sizeof(vrgContrast) / sizeof(vrgContrast[0]); i++)
        {
            if (!FCbvEnoughContrast(m_rgColor[vrgContrast[i].colLocked],
                                    m_rgColor[vrgContrast[i].colMoveable],
                                    vrgContrast[i].cMinContrast,
                                    vrgContrast[i].fConsiderDarkness))
            {
                CbvIncreaseContrast(m_rgColor[vrgContrast[i].colLocked],
                                    &(m_rgColor[vrgContrast[i].colMoveable]),
                                    vrgContrast[i].cMinContrast);
            }
        }
    }
};


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S C H E M E  D E F                                              */
/*                                                                             */
/*=============================================================================*/

static SYSCOLOR v_rgSysCol[ UIFCOLOR_MAX ] =
{
    SYSCOLOR_3DFACE,                /* UIFCOLOR_MENUBKGND            */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_MENUBARSHORT         */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_MENUBARLONG          */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEOVERBKGND       */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEOVERBORDER      */
    SYSCOLOR_HIGHLIGHTTEXT,         /* UIFCOLOR_MOUSEOVERTEXT        */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEDOWNBKGND       */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_MOUSEDOWNBORDER      */
    SYSCOLOR_HIGHLIGHTTEXT,         /* UIFCOLOR_MOUSEDOWNTEXT        */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_CTRLBKGND            */
    SYSCOLOR_BTNTEXT,               /* UIFCOLOR_CTRLTEXT             */
    SYSCOLOR_GRAYTEXT,              /* UIFCOLOR_CTRLTEXTDISABLED     */
    SYSCOLOR_3DSHAODW,              /* UIFCOLOR_CTRLIMAGESHADOW      */
    SYSCOLOR_HIGHLIGHT,             /* UIFCOLOR_CTRLBKGNDSELECTED    */
    SYSCOLOR_ACTIVEBORDER,          /* UIFCOLOR_BORDEROUTER          */
    SYSCOLOR_3DFACE,                /* UIFCOLOR_BORDERINNER          */
    SYSCOLOR_ACTIVECAPTION,         /* UIFCOLOR_ACTIVECAPTIONBKGND   */
    SYSCOLOR_CAPTIONTEXT,           /* UIFCOLOR_ACTIVECAPTIONTEXT    */
    SYSCOLOR_INACTIVECAPTION,       /* UIFCOLOR_INACTIVECAPTIONBKGND */
    SYSCOLOR_INACTIVECAPTIONTEXT,   /* UIFCOLOR_INACTIVECAPTIONTEXT  */
    SYSCOLOR_BTNSHADOW,             /* UIFCOLOR_SPLITTERLINE         */
    SYSCOLOR_BTNTEXT,               /* UIFCOLOR_DRAGHANDLE           */


    SYSCOLOR_3DFACE,                /* UIFCOLOR_WINDOW               */
};


//
// CUIFSchemeDef
//  = UI object default scheme =
//

class CUIFSchemeDef : public CUIFScheme
{
public:
    CUIFSchemeDef( UIFSCHEME scheme )
    {
        m_scheme = scheme;
    }

    virtual ~CUIFSchemeDef( void )
    {
    }

    //
    // CUIFScheme methods
    //

    /*   G E T  T Y P E   */
    /*------------------------------------------------------------------------------
    
        Get scheme type
    
    ------------------------------------------------------------------------------*/
    virtual UIFSCHEME GetType( void )
    {
        return m_scheme;
    }

    /*   G E T  C O L O R   */
    /*------------------------------------------------------------------------------
    
        Get scheme color
    
    ------------------------------------------------------------------------------*/
    virtual COLORREF GetColor( UIFCOLOR iCol )
    {
        return v_pColTableSys->GetColor( v_rgSysCol[ iCol ] );
    }

    /*   G E T  B R U S H   */
    /*------------------------------------------------------------------------------
    
        Get scheme brush
    
    ------------------------------------------------------------------------------*/
    virtual HBRUSH GetBrush( UIFCOLOR iCol )
    {
        return v_pColTableSys->GetBrush( v_rgSysCol[ iCol ] );
    }

    /*   C Y  M E N U  I T E M   */
    /*------------------------------------------------------------------------------
    
        Get menu item height
    
    ------------------------------------------------------------------------------*/
    virtual int CyMenuItem( int cyMenuText )
    {
        return cyMenuText + 2;
    }

    /*   C X  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame width

    ------------------------------------------------------------------------------*/
    virtual int CxSizeFrame( void )
    {
        return GetSystemMetrics( SM_CXSIZEFRAME );
    }

    /*   C Y  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame height

    ------------------------------------------------------------------------------*/
    virtual int CySizeFrame( void )
    {
        return GetSystemMetrics( SM_CYSIZEFRAME );
    }

    /*   C X  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border width

    ------------------------------------------------------------------------------*/
    virtual int CxWndBorder( void )
    {
        return 1;
    }

    /*   C Y  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border height

    ------------------------------------------------------------------------------*/
    virtual int CyWndBorder( void )
    {
        return 1;
    }

    /*   F I L L  R E C T   */
    /*------------------------------------------------------------------------------
    
        Fill rect by shceme color
    
    ------------------------------------------------------------------------------*/
    virtual void FillRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FillRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   F R A M E  R E C T   */
    /*------------------------------------------------------------------------------
    
        Frame rect by scheme color
    
    ------------------------------------------------------------------------------*/
    virtual void FrameRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FrameRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   D R A W  S E L E C T I O N  R E C T   */
    /*------------------------------------------------------------------------------
    
        Draw selection rect
    
    ------------------------------------------------------------------------------*/
    virtual void DrawSelectionRect( HDC hDC, const RECT *prc, BOOL fMouseDown )
    {
        Assert( prc != NULL );
        ::FillRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEDOWNBKGND ) );
    }

    /*   G E T  C T R L  F A C E  O F F S E T   */
    /*------------------------------------------------------------------------------
    
        Get offcet of control face from status
    
    ------------------------------------------------------------------------------*/
    virtual void GetCtrlFaceOffset( DWORD dwFlag, DWORD dwState, SIZE *poffset )
    {
        int cxyOffset = 0;

        Assert( PtrToInt(poffset) );
        if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONSELECT) ? -1 : 
                        (dwFlag & UIFDCF_SUNKENONSELECT) ? +1 : 0;
        }
        else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONMOUSEDOWN) ? -1 : 
                        (dwFlag & UIFDCF_SUNKENONMOUSEDOWN) ? +1 : 0;
        } 
        else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONMOUSEOVER) ? -1 : 
                        (dwFlag & UIFDCF_SUNKENONMOUSEOVER) ? +1 : 0;
        }
        else {
            cxyOffset = (dwFlag & UIFDCF_RAISEDONNORMAL) ? -1 : 
                        (dwFlag & UIFDCF_RAISEDONNORMAL) ? +1 : 0;
        }

        poffset->cx = cxyOffset;
        poffset->cy = cxyOffset;
    }

    /*   D R A W  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        Assert( prc != NULL );
        ::FillRect( hDC, prc, GetBrush( UIFCOLOR_CTRLBKGND ) );

#ifndef UNDER_CE
        if (((dwState & UIFDCS_SELECTED) != 0) && ((dwState & UIFDCS_MOUSEDOWN) == 0)) {
            RECT rc = *prc;
            HBRUSH hBrush;
            COLORREF colTextOld;
            COLORREF colBackOld;
            hBrush = CreateDitherBrush();
            if (hBrush)
            {
                colTextOld = SetTextColor( hDC, GetSysColor(COLOR_3DFACE) );
                colBackOld = SetBkColor( hDC, GetSysColor(COLOR_3DHILIGHT) );

                InflateRect( &rc, -2, -2 );
                ::FillRect( hDC, &rc, hBrush );

                SetTextColor( hDC, colTextOld );
                SetBkColor( hDC, colBackOld );
                DeleteObject( hBrush );
            }
        }
#endif /* !UNDER_CE */
    }

    /*   D R A W  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        UINT uiEdge = 0;

        if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
            uiEdge = (dwFlag & UIFDCF_RAISEDONSELECT) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_SUNKENONSELECT) ? BDR_SUNKENOUTER : 0;
        }
        else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
            uiEdge = (dwFlag & UIFDCF_RAISEDONMOUSEDOWN) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_SUNKENONMOUSEDOWN) ? BDR_SUNKENOUTER : 0;
        } 
        else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
            uiEdge = (dwFlag & UIFDCF_RAISEDONMOUSEOVER) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_SUNKENONMOUSEOVER) ? BDR_SUNKENOUTER : 0;
        }
        else {
            uiEdge = (dwFlag & UIFDCF_RAISEDONNORMAL) ? BDR_RAISEDINNER : 
                     (dwFlag & UIFDCF_RAISEDONNORMAL) ? BDR_SUNKENOUTER : 0;
        }

        if (uiEdge != 0) {
            RECT rcT = *prc;
            DrawEdge( hDC, &rcT, uiEdge, BF_RECT );
        }
    }

    /*   D R A W  C T R L  T E X T   */
    /*------------------------------------------------------------------------------
    
        Paint control text
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlText( HDC hDC, const RECT *prc, LPCWSTR pwch, int cwch, DWORD dwState , BOOL fVertical)
    {
        RECT     rc;
        COLORREF colTextOld = GetTextColor( hDC );
        int      iBkModeOld = SetBkMode( hDC, TRANSPARENT );

        Assert( prc != NULL );
        Assert( pwch != NULL );

        rc = *prc;
        if (cwch == -1) {
            cwch = StrLenW(pwch);
        }
        if (dwState & UIFDCS_DISABLED) {
            OffsetRect( &rc, +1, +1 );
    
            SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );    // TODO: KojiW
            CUIExtTextOut( hDC,
                            fVertical ? rc.right : rc.left,
                            rc.top,
                            ETO_CLIPPED,
                            &rc,
                            pwch,
                            cwch,
                            NULL );
    
            OffsetRect( &rc, -1, -1 );
        }
    
        SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );   // TODO: KojiW
        CUIExtTextOut( hDC,
                        fVertical ? rc.right : rc.left,
                        rc.top,
                        ETO_CLIPPED,
                        &rc,
                        pwch,
                        cwch,
                        NULL );

        SetTextColor( hDC, colTextOld );
        SetBkMode( hDC, iBkModeOld );
    }

    /*   D R A W  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
        Assert( prc != NULL );
        if (IsRTLLayout())
        {
            HBITMAP hbmp;
            HBITMAP hbmpMask;
            if (CUIGetIconBitmaps(hIcon, &hbmp, &hbmpMask, psizeIcon))
            {
                DrawCtrlBitmap( hDC, prc, hbmp, hbmpMask, dwState );
                DeleteObject(hbmp);
                DeleteObject(hbmpMask);
            }
        }
        else
        {
            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hIcon,
                0,
                prc->left,
                prc->top,
                0,
                0,
                DST_ICON | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );
        }
    }

    /*   D R A W  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        Assert( prc != NULL );

        if (IsRTLLayout())
        {
            hBmp = CUIMirrorBitmap(hBmp, GetBrush(UIFCOLOR_CTRLBKGND));
            hBmpMask = CUIMirrorBitmap(hBmpMask, (HBRUSH)GetStockObject(BLACK_BRUSH));
        }

        if (!hBmpMask)
        {
            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hBmp,
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );
        }
        else
        {
            HBITMAP hBmpTmp;
            HBRUSH hbr;
            BOOL fDeleteHBR = FALSE;

            if (dwState & UIFDCS_DISABLED) {
                hBmpTmp = CreateDisabledBitmap(prc, 
                                               hBmpMask, 
                                               GetBrush(UIFCOLOR_CTRLBKGND),
                                               GetBrush(UIFCOLOR_CTRLTEXTDISABLED ), TRUE);
            }
            else
            {

                if (((dwState & UIFDCS_SELECTED) != 0) && ((dwState & UIFDCS_MOUSEDOWN) == 0)) 
                {
                    hbr = CreateDitherBrush();
                    fDeleteHBR = TRUE;
                }
                // else if (dwState & UIFDCS_SELECTED)
                //     hbr = (HBRUSH)(COLOR_3DHIGHLIGHT + 1);
                else
                    hbr = (HBRUSH)(COLOR_3DFACE + 1);

                hBmpTmp = CreateMaskBmp(prc, hBmp, hBmpMask, hbr,
                                        GetSysColor(COLOR_3DFACE),
                                        GetSysColor(COLOR_3DHILIGHT));
#if 0
    CBitmapDC hdcTmp;
    CBitmapDC hdcSrc((HDC)hdcTmp);
    CBitmapDC hdcMask((HDC)hdcTmp);
    CBitmapDC hdcDst((HDC)hdcTmp);
    hdcSrc.SetBitmap(hBmp);
    hdcMask.SetBitmap(hBmpMask);
    hdcDst.SetBitmap(hBmpTmp);
    BitBlt(hdcTmp,  0, 30, 30, 30, hdcSrc, 0, 0, SRCCOPY);
    BitBlt(hdcTmp, 30, 30, 30, 30, hdcMask, 0, 0, SRCCOPY);
    BitBlt(hdcTmp, 60, 30, 30, 30, hdcDst, 0, 0, SRCCOPY);
    hdcSrc.GetBitmapAndKeep();
    hdcMask.GetBitmapAndKeep();
    hdcDst.GetBitmapAndKeep();
#endif
            }

            if (hBmpTmp)
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmpTmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP);

                DeleteObject(hBmpTmp);
            }
            if (fDeleteHBR)
                DeleteObject(hbr );
        }

        if (IsRTLLayout())
        {
            DeleteObject(hBmp);
            DeleteObject(hBmpMask);
        }
    }

    /*   D R A W  M E N U  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint menu bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        DrawCtrlBitmap( hDC, prc, hBmp, hBmpMask, dwState );
    }

    /*   D R A W  M E N U  S E P A R A T O R
    /*------------------------------------------------------------------------------
    
        Paint menu separator
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuSeparator( HDC hDC, const RECT *prc)
    {
        RECT rc;
        rc = *prc;
        rc.bottom = rc.top + (rc.bottom - rc.top) / 2;
        ::FillRect(hDC, &rc, (HBRUSH)(COLOR_3DSHADOW + 1));
        rc = *prc;
        rc.top = rc.top + (rc.bottom - rc.top) / 2;
        ::FillRect(hDC, &rc, (HBRUSH)(COLOR_3DHIGHLIGHT + 1));
    }

    /*   D R A W  F R A M E  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint frame control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        DrawCtrlBkgd( hDC, prc, dwFlag, dwState );
    }

    /*   D R A W  F R A M E  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint frame control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        DrawCtrlEdge( hDC, prc, dwFlag, dwState );
    }

    /*   D R A W  F R A M E  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint frame control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
        DrawCtrlIcon( hDC, prc, hIcon, dwState , psizeIcon);
    }

    /*   D R A W  F R A M E  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint frame control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        DrawCtrlBitmap( hDC, prc, hBmp, hBmpMask, dwState );
    }

    /*   D R A W  W N D  F R A M E   */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawWndFrame( HDC hDC, const RECT *prc, DWORD dwFlag, int cxFrame, int cyFrame )
    {
        RECT rc = *prc;

        switch (dwFlag) {
            default:
            case UIFDWF_THIN: {
                FrameRect( hDC, &rc, UIFCOLOR_BORDEROUTER );
                break;
            }

            case UIFDWF_THICK:
            case UIFDWF_ROUNDTHICK: {
                DrawEdge( hDC, &rc, EDGE_RAISED, BF_RECT );
                break;
            }
        }
    }

    /*   D R A W  D R A G  H A N D L E */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawDragHandle( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        RECT rc;
        if (!fVertical)
        {
            ::SetRect(&rc, 
                      prc->left + 1, 
                      prc->top, 
                      prc->left + 4, 
                      prc->bottom);
        }
        else
        {
            ::SetRect(&rc, 
                      prc->left, 
                      prc->top + 1, 
                      prc->right, 
                      prc->top + 4);
        }

        DrawEdge(hDC, &rc, BDR_RAISEDINNER, BF_RECT);
    }

    /*   D R A W  S E P A R A T O R */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawSeparator( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        CSolidPen hpenL;
        CSolidPen hpenS;
        HPEN hpenOld = NULL;
    
        if (!hpenL.Init(GetSysColor(COLOR_3DHILIGHT)))
            return;
    
        if (!hpenS.Init(GetSysColor(COLOR_3DSHADOW)))
            return;
    
        if (!fVertical)
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenS);
            MoveToEx(hDC, prc->left + 1, prc->top, NULL);
            LineTo(hDC,   prc->left + 1, prc->bottom);
    
            SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left + 2, prc->top, NULL);
            LineTo(hDC,   prc->left + 2, prc->bottom);
        }
        else
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenS);
            MoveToEx(hDC, prc->left , prc->top + 1, NULL);
            LineTo(hDC,   prc->right, prc->top + 1);

            SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left , prc->top + 2, NULL);
            LineTo(hDC,   prc->right, prc->top + 2);
    }
    
        SelectObject(hDC, hpenOld);
    }

protected:
    UIFSCHEME m_scheme;
};


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S C H E M E  O F F 1 0  L O O K                                 */
/*                                                                             */
/*=============================================================================*/

static OFC10COLOR v_rgO10ColMenu[ UIFCOLOR_MAX ] = 
{
    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_MENUBKGND            */
    OFC10COLOR_MENUBARSHORT,            /* UIFCOLOR_MENUBARSHORT         */
    OFC10COLOR_MENUBARLONG,             /* UIFCOLOR_MENUBARLONG          */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_MOUSEOVERBKGND       */
    OFC10COLOR_MOUSEOVERBORDER,         /* UIFCOLOR_MOUSEOVERBORDER      */
    OFC10COLOR_MOUSEOVERTEXT,           /* UIFCOLOR_MOUSEOVERTEXT        */
    OFC10COLOR_MOUSEDOWNBKGND,          /* UIFCOLOR_MOUSEDOWNBKGND       */
    OFC10COLOR_MOUSEDOWNBORDER,         /* UIFCOLOR_MOUSEDOWNBORDER      */
    OFC10COLOR_MOUSEDOWNTEXT,           /* UIFCOLOR_MOUSEDOWNTEXT        */
    OFC10COLOR_CTRLBKGD,                /* UIFCOLOR_CTRLBKGND            */
    OFC10COLOR_MENUCTRLTEXT,            /* UIFCOLOR_CTRLTEXT             */
    OFC10COLOR_CTRLTEXTDISABLED,        /* UIFCOLOR_CTRLTEXTDISABLED     */
    OFC10COLOR_CTRLIMAGESHADOW,         /* UIFCOLOR_CTRLIMAGESHADOW      */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_CTRLBKGNDSELECTED    */
    OFC10COLOR_BDROUTERMENU,            /* UIFCOLOR_BORDEROUTER          */
    OFC10COLOR_BDRINNERMENU,            /* UIFCOLOR_BORDERINNER          */
    OFC10COLOR_ACTIVECAPTIONBKGDWP,     /* UIFCOLOR_ACTIVECAPTIONBKGND   */  // TEMP assign
    OFC10COLOR_ACTIVECAPTIONTEXTWP,     /* UIFCOLOR_ACTIVECAPTIONTEXT    */  // TEMP assign
    OFC10COLOR_INACTIVECAPTIONBKGDWP,   /* UIFCOLOR_INACTIVECAPTIONBKGND */  // TEMP assign
    OFC10COLOR_INACTIVECAPTIONTEXTWP,   /* UIFCOLOR_INACTIVECAPTIONTEXT  */  // TEMP assign
    OFC10COLOR_SPLITTERLINE,            /* UIFCOLOR_SPLITTERLINE         */
    OFC10COLOR_DRAGHANDLE,              /* UIFCOLOR_DRAGHANDLE           */

    // virtual colors

    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_WINDOW               */
};


static OFC10COLOR v_rgO10ColToolbar[ UIFCOLOR_MAX ] = 
{
    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_MENUBKGND            */
    OFC10COLOR_MENUBARSHORT,            /* UIFCOLOR_MENUBARSHORT         */
    OFC10COLOR_MENUBARLONG,             /* UIFCOLOR_MENUBARLONG          */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_MOUSEOVERBKGND       */
    OFC10COLOR_MOUSEOVERBORDER,         /* UIFCOLOR_MOUSEOVERBORDER      */
    OFC10COLOR_MOUSEOVERTEXT,           /* UIFCOLOR_MOUSEOVERTEXT        */
    OFC10COLOR_MOUSEDOWNBKGND,          /* UIFCOLOR_MOUSEDOWNBKGND       */
    OFC10COLOR_MOUSEDOWNBORDER,         /* UIFCOLOR_MOUSEDOWNBORDER      */
    OFC10COLOR_MOUSEDOWNTEXT,           /* UIFCOLOR_MOUSEDOWNTEXT        */
    OFC10COLOR_CTRLBKGD,                /* UIFCOLOR_CTRLBKGND            */
    OFC10COLOR_CTRLTEXT,                /* UIFCOLOR_CTRLTEXT             */
    OFC10COLOR_CTRLTEXTDISABLED,        /* UIFCOLOR_CTRLTEXTDISABLED     */
    OFC10COLOR_CTRLIMAGESHADOW,         /* UIFCOLOR_CTRLIMAGESHADOW      */
    OFC10COLOR_CTRLBKGDSELECTED,        /* UIFCOLOR_CTRLBKGNDSELECTED    */
    OFC10COLOR_BDROUTERFLOATTB,         /* UIFCOLOR_BORDEROUTER          */
    OFC10COLOR_BDRINNERFLOATTB,         /* UIFCOLOR_BORDERINNER          */
    OFC10COLOR_CAPTIONBKGDTB,           /* UIFCOLOR_ACTIVECAPTIONBKGND   */
    OFC10COLOR_CAPTIONTEXTTB,           /* UIFCOLOR_ACTIVECAPTIONTEXT    */
    OFC10COLOR_CAPTIONBKGDTB,           /* UIFCOLOR_INACTIVECAPTIONBKGND */
    OFC10COLOR_CAPTIONTEXTTB,           /* UIFCOLOR_INACTIVECAPTIONTEXT  */
    OFC10COLOR_SPLITTERLINE,            /* UIFCOLOR_SPLITTERLINE         */
    OFC10COLOR_DRAGHANDLE,              /* UIFCOLOR_DRAGHANDLE           */


    // virtual colors

    OFC10COLOR_BKGDTB,                  /* UIFCOLOR_WINDOW               */
};


static OFC10COLOR v_rgO10ColWorkPane[ UIFCOLOR_MAX ] = 
{
    OFC10COLOR_BKGDMENU,                /* UIFCOLOR_MENUBKGND            */
    OFC10COLOR_MENUBARSHORT,            /* UIFCOLOR_MENUBARSHORT         */
    OFC10COLOR_MENUBARLONG,             /* UIFCOLOR_MENUBARLONG          */
    OFC10COLOR_MOUSEOVERBKGND,          /* UIFCOLOR_MOUSEOVERBKGND       */
    OFC10COLOR_MOUSEOVERBORDER,         /* UIFCOLOR_MOUSEOVERBORDER      */
    OFC10COLOR_MOUSEOVERTEXT,           /* UIFCOLOR_MOUSEOVERTEXT        */
    OFC10COLOR_MOUSEDOWNBKGND,          /* UIFCOLOR_MOUSEDOWNBKGND       */
    OFC10COLOR_MOUSEDOWNBORDER,         /* UIFCOLOR_MOUSEDOWNBORDER      */
    OFC10COLOR_MOUSEDOWNTEXT,           /* UIFCOLOR_MOUSEDOWNTEXT        */
    OFC10COLOR_CTRLBKGD,                /* UIFCOLOR_CTRLBKGND            */
    OFC10COLOR_CTRLTEXT,                /* UIFCOLOR_CTRLTEXT             */
    OFC10COLOR_CTRLTEXTDISABLED,        /* UIFCOLOR_CTRLTEXTDISABLED     */
    OFC10COLOR_CTRLIMAGESHADOW,         /* UIFCOLOR_CTRLIMAGESHADOW      */
    OFC10COLOR_CTRLBKGDSELECTED,        /* UIFCOLOR_CTRLBKGNDSELECTED    */
    OFC10COLOR_BDROUTERFLOATWP,         /* UIFCOLOR_BORDEROUTER          */
    OFC10COLOR_BDRINNERFLOATWP,         /* UIFCOLOR_BORDERINNER          */
    OFC10COLOR_ACTIVECAPTIONBKGDWP,     /* UIFCOLOR_ACTIVECAPTIONBKGND   */
    OFC10COLOR_ACTIVECAPTIONTEXTWP,     /* UIFCOLOR_ACTIVECAPTIONTEXT    */
    OFC10COLOR_INACTIVECAPTIONBKGDWP,   /* UIFCOLOR_INACTIVECAPTIONBKGND */
    OFC10COLOR_INACTIVECAPTIONTEXTWP,   /* UIFCOLOR_INACTIVECAPTIONTEXT  */
    OFC10COLOR_SPLITTERLINE,            /* UIFCOLOR_SPLITTERLINE         */
    OFC10COLOR_DRAGHANDLE,              /* UIFCOLOR_DRAGHANDLE           */

    // virtual colors

    OFC10COLOR_BKGDWP,                  /* UIFCOLOR_WINDOW              */
};


//
// CUIFSchemeOff10
//

class CUIFSchemeOff10 : public CUIFScheme
{
public:
    CUIFSchemeOff10( UIFSCHEME scheme )
    {
        m_scheme = scheme;

        // find color map table

        switch (m_scheme) {
            default:
            case UIFSCHEME_OFC10MENU: {
                m_pcoldef = v_rgO10ColMenu;
                break;
            }

            case UIFSCHEME_OFC10TOOLBAR: {
                m_pcoldef = v_rgO10ColToolbar;
                break;
            }

            case UIFSCHEME_OFC10WORKPANE: {
                m_pcoldef = v_rgO10ColWorkPane;
                break;
            }
        }
    }

    virtual ~CUIFSchemeOff10( void )
    {
    }

    //
    // CUIFScheme method
    //

    /*   G E T  T Y P E   */
    /*------------------------------------------------------------------------------
    
        Get scheme type
    
    ------------------------------------------------------------------------------*/
    virtual UIFSCHEME GetType( void )
    {
        return m_scheme;
    }

    /*   G E T  C O L O R   */
    /*------------------------------------------------------------------------------
    
        Get scheme color
    
    ------------------------------------------------------------------------------*/
    virtual COLORREF GetColor( UIFCOLOR iCol )
    {
        return v_pColTableOfc10->GetColor( m_pcoldef[ iCol ] );
    }

    /*   G E T  B R U S H   */
    /*------------------------------------------------------------------------------
    
        Get scheme brush
    
    ------------------------------------------------------------------------------*/
    virtual HBRUSH GetBrush( UIFCOLOR iCol )
    {
        return v_pColTableOfc10->GetBrush( m_pcoldef[ iCol ] );
    }

    /*   C Y  M E N U  I T E M   */
    /*------------------------------------------------------------------------------
    
        Get menu item height
    
    ------------------------------------------------------------------------------*/
    virtual int CyMenuItem( int cyMenuText )
    {
        return cyMenuText + 4;
    }

    /*   C X  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame width

    ------------------------------------------------------------------------------*/
    virtual int CxSizeFrame( void )
    {
        return max( 3, GetSystemMetrics( SM_CXSIZEFRAME ) - 2 );
    }

    /*   C Y  S I Z E  F R A M E   */
    /*------------------------------------------------------------------------------

        Get size frame height

    ------------------------------------------------------------------------------*/
    virtual int CySizeFrame( void )
    {
        return max( 3, GetSystemMetrics( SM_CYSIZEFRAME ) - 2 );
    }

    /*   C X  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border width

    ------------------------------------------------------------------------------*/
    virtual int CxWndBorder( void )
    {
        return 1;
    }

    /*   C Y  W N D  B O R D E R   */
    /*------------------------------------------------------------------------------

        Get window border height

    ------------------------------------------------------------------------------*/
    virtual int CyWndBorder( void )
    {
        return 1;
    }

    /*   F I L L  R E C T   */
    /*------------------------------------------------------------------------------
    
        Fill rect by scheme color
    
    ------------------------------------------------------------------------------*/
    virtual void FillRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FillRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   F R A M E  R E C T   */
    /*------------------------------------------------------------------------------
    
        Frame rect by scheme color
    
    ------------------------------------------------------------------------------*/
    virtual void FrameRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )
    {
        ::FrameRect( hDC, prc, GetBrush( iCol ) );
    }

    /*   D R A W  S E L E C T I O N  R E C T   */
    /*------------------------------------------------------------------------------
    
        Draw selection rect
    
    ------------------------------------------------------------------------------*/
    virtual void DrawSelectionRect( HDC hDC, const RECT *prc, BOOL fMouseDown )
    {
        Assert( prc != NULL );

        if (fMouseDown) {
            ::FillRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEDOWNBKGND ) );
            ::FrameRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEDOWNBORDER ) );
        }
        else {
            ::FillRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEOVERBKGND ) );
            ::FrameRect( hDC, prc, GetBrush( UIFCOLOR_MOUSEOVERBORDER ) );
        }
    }

    /*   G E T  C T R L  F A C E  O F F S E T   */
    /*------------------------------------------------------------------------------
    
        Get offcet of control face from status
    
    ------------------------------------------------------------------------------*/
    virtual void GetCtrlFaceOffset( DWORD dwFlag, DWORD dwState, SIZE *poffset )
    {
        Assert( poffset != NULL );
        poffset->cx = 0;
        poffset->cy = 0;
    }

    /*   D R A W  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        get background color
    
    ------------------------------------------------------------------------------*/
    virtual UIFCOLOR GetBkgdCol( DWORD dwState )
    {
        UIFCOLOR col = UIFCOLOR_MAX; /* invalid */

        if ((dwState & UIFDCS_DISABLED) == 0) { /* enabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEOVERBKGND;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_CTRLBKGNDSELECTED;    /* frame: 65% */
            }
            else {
                col = UIFCOLOR_WINDOW;
            }
        }
        else { /* disabled */
            col = UIFCOLOR_WINDOW;
        }

        return col;
    }

    /*   D R A W  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        Assert( prc != NULL );
        UIFCOLOR col = GetBkgdCol(dwState);

        if (col != UIFCOLOR_MAX) {
            FillRect( hDC, prc, col );
        }
    }

    /*   D R A W  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        UIFCOLOR col = UIFCOLOR_MAX; /* invalid color */

        if ((dwState & UIFDCS_DISABLED) == 0) { /* enabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEOVERBORDER;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_MOUSEOVERBORDER;    /* frame: 65% */
            }
        }
        else { /* disabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */      // REVIEW: KOJIW: correct?
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_CTRLTEXTDISABLED;
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEDOWNBORDER;    /* frame: 100% */      // REVIEW: KOJIW: correct?
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_CTRLTEXTDISABLED;   // ????
            }
        }

        if (col != UIFCOLOR_MAX) {
            FrameRect( hDC, prc, col );
        }
    }

    /*   D R A W  C T R L  T E X T   */
    /*------------------------------------------------------------------------------
    
        Paint control text
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlText( HDC hDC, const RECT *prc, LPCWSTR pwch, int cwch, DWORD dwState , BOOL fVertical)
    {
        COLORREF colTextOld = GetTextColor( hDC );
        int      iBkModeOld = SetBkMode( hDC, TRANSPARENT );

        Assert( prc != NULL );
        Assert( pwch != NULL );

        if (cwch == -1) {
            cwch = StrLenW(pwch);
        }

        if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
            SetTextColor( hDC, GetColor(UIFCOLOR_MOUSEDOWNTEXT) );
        } else if (dwState & UIFDCS_DISABLED) {
            SetTextColor( hDC, GetColor(UIFCOLOR_CTRLTEXTDISABLED) );
        } else if (dwState & UIFDCS_MOUSEOVER) {
            SetTextColor( hDC, GetColor(UIFCOLOR_MOUSEOVERTEXT) );
        } else if (dwState & UIFDCS_MOUSEDOWN) {
            SetTextColor( hDC, GetColor(UIFCOLOR_MOUSEDOWNTEXT) );
        } else {
            SetTextColor( hDC, GetColor(UIFCOLOR_CTRLTEXT) );
        }
        CUIExtTextOut( hDC,
                        fVertical ? prc->right : prc->left,
                        prc->top,
                        ETO_CLIPPED,
                        prc,
                        pwch,
                        cwch,
                        NULL );

        SetTextColor( hDC, colTextOld );
        SetBkMode( hDC, iBkModeOld );
    }

    /*   D R A W  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
#if 1
        HBITMAP hbmp;
        HBITMAP hbmpMask;
        if (CUIGetIconBitmaps(hIcon, &hbmp, &hbmpMask, psizeIcon))
        {
            DrawCtrlBitmap( hDC, prc, hbmp, hbmpMask, dwState );
            DeleteObject(hbmp);
            DeleteObject(hbmpMask);
        }
#else
        Assert( prc != NULL );
        if (((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) && 
            ((dwState & UIFDCS_SELECTED) == 0) &&
            ((dwState & UIFDCS_DISABLED) == 0)) {
            // draw shadow

            CUIDrawState( hDC,
                GetBrush( UIFCOLOR_CTRLIMAGESHADOW ),
                NULL,
                (LPARAM)hIcon,
                0,
                prc->left + 1,
                prc->top + 1,
                0,
                0,
                DST_ICON | DSS_MONO );

            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hIcon,
                0,
                prc->left - 1,
                prc->top - 1,
                0,
                0,
                DST_ICON );
        }
        else {
            if (dwState & UIFDCS_DISABLED)
            {
                HICON hIconSm = NULL;

                if (hIcon)
                   hIconSm = (HICON)CopyImage(hIcon, IMAGE_ICON, 16, 16, 0);

                if (hIconSm)
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hIconSm,
                        0,
                        prc->left,
                        prc->top,
                        prc->right - prc->left,
                        prc->bottom - prc->top,
                        DST_ICON | (DSS_DISABLED | DSS_MONO));
                }
                else
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hIcon,
                        0,
                        prc->left,
                        prc->top,
                        0,
                        0,
                        DST_ICON | (DSS_DISABLED | DSS_MONO));
                }

                if (hIconSm)
                    DestroyIcon(hIconSm);
            }
            else
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hIcon,
                    0,
                    prc->left,
                    prc->top,
                    0,
                    0,
                    DST_ICON);
            }
        }
#endif
    }

    /*   D R A W  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        Assert( prc != NULL );
        
        if (IsRTLLayout())
        {
            hBmp = CUIMirrorBitmap(hBmp, GetBrush(GetBkgdCol(dwState)));
            hBmpMask = CUIMirrorBitmap(hBmpMask, (HBRUSH)GetStockObject(BLACK_BRUSH));
        }

        if (((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) && 
                 ((dwState & UIFDCS_SELECTED) == 0) &&
                 ((dwState & UIFDCS_DISABLED) == 0)) {
            if (!hBmpMask)
            {
                // draw shadow

                CUIDrawState( hDC,
                    GetBrush( UIFCOLOR_CTRLIMAGESHADOW ),
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left + 1,
                    prc->top + 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP | DSS_MONO );

                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left - 1,
                    prc->top - 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );

            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col = GetBkgdCol(dwState);
                RECT rcNew = *prc;

                //
                // adjust rect of shadow for RTL layout.
                //
                if (IsRTLLayout())
                {
                    rcNew.left++;
                    rcNew.top++;
                }

                hBmpTmp = CreateShadowMaskBmp(&rcNew, 
                                        hBmp,  
                                        hBmpMask, 
                                        (HBRUSH)GetBrush(col),
                                        GetBrush( UIFCOLOR_CTRLIMAGESHADOW));




                if (hBmpTmp)
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hBmpTmp,
                        0,
                        rcNew.left,
                        rcNew.top,
                        rcNew.right - rcNew.left,
                        rcNew.bottom - rcNew.top,
                        DST_BITMAP );


                    DeleteObject(hBmpTmp);
                }
            }
        }
        else {

            if (!hBmpMask)
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );

            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col = GetBkgdCol(dwState);
                if (dwState & UIFDCS_DISABLED) 
                    hBmpTmp = CreateDisabledBitmap(prc, 
                                           hBmpMask, 
                                           GetBrush(col),
                                           GetBrush(UIFCOLOR_CTRLTEXTDISABLED),
                                           FALSE);
                else
                    hBmpTmp = CreateMaskBmp(prc, 
                                            hBmp,  
                                            hBmpMask, 
                                            (HBRUSH)GetBrush(col), 0, 0);
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmpTmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP);
                    // DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );

                DeleteObject(hBmpTmp);
            }
        }

        if (IsRTLLayout())
        {
            DeleteObject(hBmp);
            DeleteObject(hBmpMask);
        }

    }

    /*   D R A W  M E N U  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint menu bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        Assert( prc != NULL );

        if (IsRTLLayout())
        {
            // hBmp = CUIMirrorBitmap(hBmp, GetBrush(UIFCOLOR_CTRLBKGND));
            UIFCOLOR col;

            if (dwState & UIFDCS_SELECTED)
                // col = UIFCOLOR_CTRLIMAGESHADOW;
                col = UIFCOLOR_MOUSEOVERBKGND;  
            else
                col = UIFCOLOR_CTRLBKGND;

            hBmp = CUIMirrorBitmap(hBmp, GetBrush(col));
            hBmpMask = CUIMirrorBitmap(hBmpMask, (HBRUSH)GetStockObject(BLACK_BRUSH));
        }

        if (((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) && ((dwState & UIFDCS_SELECTED) == 0)) {
            if (!hBmpMask)
            {
                // draw shadow
    
                CUIDrawState( hDC,
                    GetBrush( UIFCOLOR_CTRLIMAGESHADOW ),
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left + 1,
                    prc->top + 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP | DSS_MONO );

                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left - 1,
                    prc->top - 1,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );
            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col = GetBkgdCol(dwState);
                RECT rcNew = *prc;
                hBmpTmp = CreateShadowMaskBmp(&rcNew, 
                                        hBmp,  
                                        hBmpMask, 
                                        (HBRUSH)GetBrush(col),
                                        GetBrush( UIFCOLOR_CTRLIMAGESHADOW));




                if (hBmpTmp)
                {
                    CUIDrawState( hDC,
                        NULL,
                        NULL,
                        (LPARAM)hBmpTmp,
                        0,
                        rcNew.left,
                        rcNew.top,
                        rcNew.right - rcNew.left,
                        rcNew.bottom - rcNew.top,
                        DST_BITMAP );

                    DeleteObject(hBmpTmp);
                }
            }
        }
        else {
            if (!hBmpMask)
            {
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );
            }
            else
            {
                HBITMAP hBmpTmp;
                UIFCOLOR col;

                if (dwState & UIFDCS_SELECTED)
                    // col = UIFCOLOR_CTRLIMAGESHADOW;
                    col = UIFCOLOR_MOUSEOVERBKGND;  
                else
                    col = UIFCOLOR_CTRLBKGND;

                hBmpTmp = CreateMaskBmp(prc, 
                                        hBmp,  
                                        hBmpMask, 
                                        (HBRUSH)GetBrush(col), 0, 0);
                CUIDrawState( hDC,
                    NULL,
                    NULL,
                    (LPARAM)hBmpTmp,
                    0,
                    prc->left,
                    prc->top,
                    prc->right - prc->left,
                    prc->bottom - prc->top,
                    DST_BITMAP );

                DeleteObject(hBmpTmp);
            }
        }

        if (IsRTLLayout())
        {
            DeleteObject(hBmp);
            DeleteObject(hBmpMask);
        }

    }

    /*   D R A W  M E N U  S E P A R A T O R
    /*------------------------------------------------------------------------------
    
        Paint menu separator
    
    ------------------------------------------------------------------------------*/
    virtual void DrawMenuSeparator( HDC hDC, const RECT *prc)
    {
        ::FillRect(hDC, prc, GetBrush(UIFCOLOR_CTRLBKGND));
    }

    /*   G E T  F R A M E  B K G D  C O L  */
    /*------------------------------------------------------------------------------
    
        get background color of frame control
    
    ------------------------------------------------------------------------------*/
    virtual UIFCOLOR GetFrameBkgdCol( DWORD dwState )
    {
        UIFCOLOR col = UIFCOLOR_MAX; /* invalid */

        if ((dwState & UIFDCS_DISABLED) == 0) { /* enabled */
            if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                col = UIFCOLOR_MOUSEDOWNBKGND;    /* frame: 100% */
            }
            else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                col = UIFCOLOR_MOUSEOVERBKGND;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                col = UIFCOLOR_MOUSEOVERBKGND;    /* frame: 65% */
            }
            else if ((dwState & UIFDCS_ACTIVE) == UIFDCS_ACTIVE) {
                col = UIFCOLOR_ACTIVECAPTIONBKGND;
            }
            else {
                col = UIFCOLOR_INACTIVECAPTIONBKGND;
            }
        }
        else { /* disabled */
            if ((dwState & UIFDCS_ACTIVE) == UIFDCS_ACTIVE) {
                col = UIFCOLOR_ACTIVECAPTIONBKGND;
            }
            else {
                col = UIFCOLOR_INACTIVECAPTIONBKGND;
            }
        }

        return col;
    }

    /*   D R A W  F R A M E  C T R L  B K G D   */
    /*------------------------------------------------------------------------------
    
        Paint frame control background
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        Assert( prc != NULL );
        UIFCOLOR col = GetFrameBkgdCol(dwState);

        if (col != UIFCOLOR_MAX)  {
            FillRect( hDC, prc, col );
        }
    }

    /*   D R A W  F R A M E  C T R L  E D G E   */
    /*------------------------------------------------------------------------------
    
        Paint frame control edge
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )
    {
        DrawCtrlEdge( hDC, prc, dwFlag, dwState );
    }

    /*   D R A W  F R A M E  C T R L  I C O N   */
    /*------------------------------------------------------------------------------
    
        Paint frame control icon
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)
    {
        HBITMAP hbmp;
        HBITMAP hbmpMask;
        if (CUIGetIconBitmaps(hIcon, &hbmp, &hbmpMask, psizeIcon))
        {
            DrawCtrlBitmap( hDC, prc, hbmp, hbmpMask, dwState );
            DeleteObject(hbmp);
            DeleteObject(hbmpMask);
        }
    }

    /*   D R A W  F R A M E  C T R L  B I T M A P   */
    /*------------------------------------------------------------------------------
    
        Paint frame control bitmap
    
    ------------------------------------------------------------------------------*/
    virtual void DrawFrameCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )
    {
        if (!hBmpMask) {
            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hBmp,
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                DST_BITMAP | ((dwState & UIFDCS_DISABLED) ? (DSS_DISABLED | DSS_MONO) : 0) );
        }
        else {
            HBITMAP hBmpTmp;
            UIFCOLOR col = GetFrameBkgdCol(dwState);

            if (dwState & UIFDCS_DISABLED) {
                hBmpTmp = CreateDisabledBitmap(prc, 
                                               hBmpMask, 
                                               (HBRUSH)GetBrush(col),
                                               GetBrush( UIFCOLOR_CTRLIMAGESHADOW ), FALSE);
            }
            else {
                HDC hDCMem;
                HDC hDCTmp;
                HDC hDCMono;
                HBITMAP hBmpMono;
                HBITMAP hBmpMemOld;
                HBITMAP hBmpTmpOld;
                HBITMAP hBmpMonoOld;
                LONG width  = prc->right - prc->left;
                LONG height = prc->bottom - prc->top;
                RECT rc;
                UIFCOLOR colText;

                SetRect( &rc, 0, 0, width, height );
                if ((dwState & UIFDCS_MOUSEOVERSELECTED) == UIFDCS_MOUSEOVERSELECTED) {
                    colText = UIFCOLOR_MOUSEDOWNTEXT;    /* frame: 100% */
                }
                else if ((dwState & UIFDCS_MOUSEDOWN) == UIFDCS_MOUSEDOWN) {
                    colText = UIFCOLOR_MOUSEDOWNTEXT;    /* frame: 100% */
                }
                else if ((dwState & UIFDCS_MOUSEOVER) == UIFDCS_MOUSEOVER) {
                    colText = UIFCOLOR_MOUSEOVERTEXT;    /* frame: 65% */
                }
                else if ((dwState & UIFDCS_SELECTED) == UIFDCS_SELECTED) {
                    colText = UIFCOLOR_MOUSEOVERTEXT;    /* frame: 65% */
                }
                else {
                    colText = UIFCOLOR_CTRLTEXT;
                }

                // create destination bitmap

                hDCTmp = CreateCompatibleDC( hDC );
                hBmpTmp = CreateCompatibleBitmap( hDC, width, height );
                hBmpTmpOld = (HBITMAP)SelectObject( hDCTmp, hBmpTmp );

                // create work DC
                
                hDCMem = CreateCompatibleDC( hDC );

                // paint background

                FillRect( hDCTmp, &rc, col );

                // step1. apply mask

                hBmpMemOld = (HBITMAP)SelectObject( hDCMem, hBmpMask );
                BitBlt( hDCTmp, 0, 0, width, height, hDCMem, 0, 0, SRCAND );

                // step2. fill color on mask

                HBRUSH hBrushOld = (HBRUSH)SelectObject( hDCTmp, GetBrush( colText ) );
                BitBlt( hDCTmp, 0, 0, width, height, hDCMem, 0, 0, 0x00BA0B09 /* DPSnao */ );
                SelectObject( hDCTmp, hBrushOld );

                // step3. create image mask

                SelectObject( hDCMem, hBmp );

                hDCMono = CreateCompatibleDC( hDC );
                hBmpMono = CreateBitmap( width, height, 1, 1, NULL );
                hBmpMonoOld = (HBITMAP)SelectObject( hDCMono, hBmpMono );

                SetBkColor( hDCMem, RGB( 0, 0, 0 ) );
                BitBlt( hDCMono, 0, 0, width, height, hDCMem, 0, 0, SRCCOPY );

                // step4. apply image mask

                SetBkColor( hDCTmp, RGB( 255, 255, 255 ) );
                SetTextColor( hDCTmp, RGB( 0, 0, 0 ) );
                BitBlt( hDCTmp, 0, 0, width, height, hDCMono, 0, 0, SRCAND );

                SelectObject( hDCMono, hBmpMonoOld );
                DeleteObject( hBmpMono );
                DeleteDC( hDCMono );

                // step5. apply image

                BitBlt( hDCTmp, 0, 0, width, height, hDCMem, 0, 0, SRCINVERT );

                // dispose work DC

                DeleteDC( hDCMem );

                // 

                SelectObject( hDCTmp, hBmpTmpOld );
                DeleteDC( hDCTmp );
            }

            CUIDrawState( hDC,
                NULL,
                NULL,
                (LPARAM)hBmpTmp,
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                DST_BITMAP);

            DeleteObject(hBmpTmp);
        }
    }

    /*   D R A W  W N D  F R A M E   */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawWndFrame( HDC hDC, const RECT *prc, DWORD dwFlag, int cxFrame, int cyFrame )
    {
        RECT rc;
        int cxFrameOuter;
        int cyFrameOuter;
        int cxFrameInner;
        int cyFrameInner;

        switch (dwFlag) {
            default:
            case UIFDWF_THIN: {
                cxFrameOuter = cxFrame;
                cyFrameOuter = cyFrame;
                cxFrameInner = 0;
                cyFrameInner = 0;
                break;
            }

            case UIFDWF_THICK:
            case UIFDWF_ROUNDTHICK: {
                cxFrameOuter = cxFrame - 1;
                cyFrameOuter = cyFrame - 1;
                cxFrameInner = 1;
                cyFrameInner = 1;
                break;
            }
        }

        // left

        rc = *prc;
        rc.right  = rc.left + cxFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cxFrameInner != 0) {
            rc.left   = rc.left + cxFrameOuter;
            rc.right  = rc.left + cxFrameInner;
            rc.top    = rc.top    + cyFrameOuter;
            rc.bottom = rc.bottom - cyFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // right

        rc = *prc;
        rc.left = rc.right - cxFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cxFrameInner != 0) {
            rc.left   = rc.right - cxFrame;
            rc.right  = rc.left + cxFrameInner;
            rc.top    = rc.top    + cyFrameOuter;
            rc.bottom = rc.bottom - cyFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // top

        rc = *prc;
        rc.bottom = rc.top + cyFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cyFrameInner != 0) {
            rc.top    = rc.top + cyFrameOuter;
            rc.bottom = rc.top + cyFrameInner;
            rc.left   = rc.left  + cxFrameOuter;
            rc.right  = rc.right - cxFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // bottom

        rc = *prc;
        rc.top = rc.bottom - cyFrameOuter;
        FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

        if (cyFrameInner != 0) {
            rc.top    = rc.bottom - cyFrame;
            rc.bottom = rc.top + cyFrameInner;
            rc.left   = rc.left  + cxFrameOuter;
            rc.right  = rc.right - cxFrameOuter;
            FillRect( hDC, &rc, UIFCOLOR_BORDERINNER );
        }

        // rounded corner

        if (dwFlag & UIFDWF_ROUNDTHICK) {
            rc = *prc;
            rc.left   = rc.left + cxFrameOuter;
            rc.top    = rc.top + cyFrameOuter;
            rc.right  = rc.left + 1;
            rc.bottom = rc.top + 1;
            FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );

            rc = *prc;
            rc.left   = rc.right - (cxFrameOuter + 1);
            rc.top    = rc.top + cyFrameOuter;
            rc.right  = rc.left + 1;
            rc.bottom = rc.top + 1;
            FillRect( hDC, &rc, UIFCOLOR_BORDEROUTER );
        }
    }

    /*   D R A W  D R A G  H A N D L E */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawDragHandle( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        CSolidPen hpen;
        hpen.Init(GetColor(UIFCOLOR_DRAGHANDLE));

        HPEN hpenOld = (HPEN)SelectObject(hDC, hpen);

        if (!fVertical)
        {
            int x0, x1, y;
            y = prc->top + 2;
            x0 = prc->left + 2;
            x1 = prc->right;
            for (;y < prc->bottom - 1; y+=2)
            {
                MoveToEx(hDC, x0, y, NULL);
                LineTo(hDC, x1, y);
            }
        }
        else
        {
            int y0, y1, x;
            x = prc->left + 2;
            y0 = prc->top + 2;
            y1 = prc->bottom;
            for (;x < prc->right - 1; x+=2)
            {
                MoveToEx(hDC, x, y0, NULL);
                LineTo(hDC, x, y1);
            }
        }
        SelectObject(hDC, hpenOld);
    }

    /*   D R A W  S E P A R A T O R */
    /*------------------------------------------------------------------------------



    ------------------------------------------------------------------------------*/
    virtual void DrawSeparator( HDC hDC, const RECT *prc, BOOL fVertical)
    {
        CSolidPen hpenL;
        HPEN hpenOld = NULL;
    
        if (!hpenL.Init(GetColor(UIFCOLOR_CTRLIMAGESHADOW)))
            return;
    
        if (!fVertical)
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left + 1, prc->top + 1, NULL);
            LineTo(hDC,   prc->left + 1, prc->bottom - 1);
        }
        else
        {
            hpenOld = (HPEN)SelectObject(hDC, (HPEN)hpenL);
            MoveToEx(hDC, prc->left + 1, prc->top + 1, NULL);
            LineTo(hDC,   prc->right - 1, prc->top + 1);
        }
    
        SelectObject(hDC, hpenOld);
    }

protected:
    UIFSCHEME  m_scheme;
    OFC10COLOR *m_pcoldef;
};


/*=============================================================================*/
/*                                                                             */
/*   E X P O R T E D  F U N C T I O N S                                        */
/*                                                                             */
/*=============================================================================*/

/*   I N I T  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitUIFScheme( void )
{
    // create color tables

    v_pColTableSys = new CUIFColorTableSys();
    if (v_pColTableSys)
        v_pColTableSys->Initialize();

    v_pColTableOfc10 = new CUIFColorTableOff10();
    if (v_pColTableOfc10)
        v_pColTableOfc10->Initialize();
}


/*   D O N E  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneUIFScheme( void )
{
    if (v_pColTableSys != NULL) {
        delete v_pColTableSys;
        v_pColTableSys = NULL;
    }

    if (v_pColTableOfc10 != NULL) {
        delete v_pColTableOfc10;
        v_pColTableOfc10 = NULL;
    }
}


/*   U P D A T E  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void UpdateUIFScheme( void )
{
    if (v_pColTableSys != NULL) {
        v_pColTableSys->Update();
    }

    if (v_pColTableOfc10 != NULL) {
        v_pColTableOfc10->Update();
    }
}


/*   C R E A T E  U I F  S C H E M E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFScheme *CreateUIFScheme( UIFSCHEME scheme )
{
    CUIFScheme *pScheme = NULL;

    switch (scheme) {
        default:
        case UIFSCHEME_DEFAULT: {
            pScheme = new CUIFSchemeDef( scheme );
            break;
        }

        case UIFSCHEME_OFC10MENU: {
            pScheme = new CUIFSchemeOff10( scheme );
            break;
        }

        case UIFSCHEME_OFC10TOOLBAR: {
            pScheme = new CUIFSchemeOff10( scheme );
            break;
        }

        case UIFSCHEME_OFC10WORKPANE: {
            pScheme = new CUIFSchemeOff10( scheme );
            break;
        }
    }

    Assert( pScheme != NULL );
    return pScheme;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuiobj.h ===
//
// cuiobj.h
//  = UI object library - define UI objects =
//

//
//      CUIFObject
//        +- CUIFBorder                 border object
//        +- CUIFStatic                 static object
//        +- CUIFButton                 button object
//        |    +- CUIFScrollButton      scrollbar button object (used in CUIFScroll)
//        +- CUIFScrollButton               scrollbar thumb object (used in CUIFScroll)
//        +- CUIFScroll                 scrollbar object
//        +- CUIFList                   listbox object
//        +- CUIFGripper                gripper object
//        +- CUIFWindow                 window frame object (need to be at top of parent)
//


#ifndef CUIOBJ_H
#define CUIOBJ_H

#include "cuischem.h"
#include "cuiarray.h"
#include "cuitheme.h"
#include "cuiicon.h"


class CUIFWindow;

//
// CUIFObject
//-----------------------------------------------------------------------------

//
// CUIFObject
//  = base class of UI object =
//

class CUIFObject: public CUIFTheme
{
public:
    CUIFObject( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFObject( void );

    virtual CUIFObject *Initialize( void );
    virtual void OnPaint( HDC hDC );
    virtual void OnTimer( void )                        { return; }
    virtual void OnLButtonDown( POINT pt )              { return; }
    virtual void OnMButtonDown( POINT pt )              { return; }
    virtual void OnRButtonDown( POINT pt )              { return; }
    virtual void OnLButtonUp( POINT pt )                { return; }
    virtual void OnMButtonUp( POINT pt )                { return; }
    virtual void OnRButtonUp( POINT pt )                { return; }
    virtual void OnMouseMove( POINT pt )                { return; }
    virtual void OnMouseIn( POINT pt )                  { return; }
    virtual void OnMouseOut( POINT pt )                 { return; }
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt )     { return FALSE; }

    virtual void GetRect( RECT *prc );
    virtual void SetRect( const RECT *prc );
    virtual BOOL PtInObject( POINT pt );

    virtual void PaintObject( HDC hDC, const RECT *prcUpdate );
    virtual void CallOnPaint(void);

    virtual void Enable( BOOL fEnable );
    __inline BOOL IsEnabled( void )
    {
        return m_fEnabled;
    }

    virtual void Show( BOOL fShow );
    __inline BOOL IsVisible( void )
    {
        return m_fVisible;
    }

    virtual void SetFontToThis( HFONT hFont );
    virtual void SetFont( HFONT hFont );
    __inline HFONT GetFont( void )
    {
        return m_hFont;
    }

    virtual void SetStyle( DWORD dwStyle );
    __inline DWORD GetStyle( void )
    {
        return m_dwStyle;
    }

    __inline DWORD GetID( void )
    {
        return m_dwID;
    }

    virtual void AddUIObj( CUIFObject *pUIObj );
    virtual void RemoveUIObj( CUIFObject *pUIObj );
    CUIFObject *ObjectFromPoint( POINT pt );

    __inline CUIFWindow *GetUIWnd( void )
    { 
        return m_pUIWnd; 
    }


    void SetScheme(CUIFScheme *pCUIFScheme);
    __inline CUIFScheme *GetUIFScheme( void )
    {
        return m_pUIFScheme; 
    }

    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCode, LPARAM lParam );

    virtual void SetToolTip( LPCWSTR pwchToolTip );
    virtual LPCWSTR GetToolTip( void );

    //
    // Start ToolTip notification. If this return TRUE, the default tooltip
    // won't be shown.
    //
    virtual BOOL OnShowToolTip( void ) {return FALSE;}
    virtual void OnHideToolTip( void ) {return;}
    virtual void DetachWndObj( void );
    virtual void ClearWndObj( void );

#if defined(_DEBUG) || defined(DEBUG)
    __inline BOOL FInitialized( void )
    {
        return m_fInitialized;
    }
#endif /* DEBUG */

protected:
    CUIFObject      *m_pParent;
    CUIFWindow      *m_pUIWnd;
    CUIFScheme      *m_pUIFScheme;
    CUIFObjectArray<CUIFObject> m_ChildList;
    DWORD           m_dwID;
    DWORD           m_dwStyle;
    RECT            m_rc;
    BOOL            m_fEnabled;
    BOOL            m_fVisible;
    HFONT           m_hFont;
    BOOL            m_fUseCustomFont;
    LPWSTR          m_pwchToolTip;

    //
    // Theme support 
    //
    virtual BOOL OnPaintTheme( HDC hDC ) {return FALSE;}
    virtual void OnPaintNoTheme( HDC hDC )   {return;}
    virtual void ClearTheme();

    void StartCapture( void );
    void EndCapture( void );
    void StartTimer( UINT uElapse );
    void EndTimer( void );
    BOOL IsCapture( void );
    BOOL IsTimer( void );
    LRESULT NotifyCommand( DWORD dwCode, LPARAM lParam );
    int GetFontHeight( void );

    //
    // uischeme functions
    //
    COLORREF GetUIFColor( UIFCOLOR iCol );
    HBRUSH GetUIFBrush( UIFCOLOR iCol );

    //
    //
    //
    __inline const RECT &GetRectRef( void ) const 
    { 
        return this->m_rc; 
    }

    __inline DWORD GetStyleBits( DWORD dwMaskBits )
    {
        return (m_dwStyle & dwMaskBits);
    }

    __inline BOOL FHasStyle( DWORD dwStyleBit )
    {
        return ((m_dwStyle & dwStyleBit ) != 0);
    }

    BOOL IsRTL();


public:
    POINT       m_pointPreferredSize;

private:
#if defined(_DEBUG) || defined(DEBUG)
    BOOL        m_fInitialized;
#endif /* DEBUG */
};


//
// CUIFBorder
//-----------------------------------------------------------------------------

// UIFBorder style

#define UIBORDER_HORZ       0x00000000  // horizontal border
#define UIBORDER_VERT       0x00000001  // vertial border

#define UIBORDER_DIRMASK    0x00000001  // (mask bits) border direction


//
// CUIFBorder
//  = border UI object =
//

class CUIFBorder : public CUIFObject
{
public:
    CUIFBorder( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    ~CUIFBorder( void );

    void OnPaint( HDC hDC );
};


//
// CUIFStatic
//-----------------------------------------------------------------------------

// UIStatic style

#define UISTATIC_LEFT       0x00000000  // left alignment
#define UISTATIC_CENTER     0x00000001  // center alignment (horizontal)
#define UISTATIC_RIGHT      0x00000002  // right alignment
#define UISTATIC_TOP        0x00000000  // top alignment
#define UISTATIC_VCENTER    0x00000010  // center alignment (vertical)
#define UISTATIC_BOTTOM     0x00000020  // bottom alignment

#define UISTATIC_HALIGNMASK 0x00000003  // (mask bits) horizontal alignment mask bits
#define UISTATIC_VALIGNMASK 0x00000030  // (mask bits) vertiacal alignment mask bits

//
// CUIFStatic
//  = static UI object =
//

class CUIFStatic : public CUIFObject
{
public:
    CUIFStatic( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFStatic( void );

    virtual void OnPaint( HDC hDC );
    virtual void SetText( LPCWSTR pwchText);
    virtual int GetText( LPWSTR pwchBuf, int cwchBuf );

protected:
    LPWSTR m_pwchText;
};


//
// CUIFButton
//-----------------------------------------------------------------------------


// UIFButton style

#define UIBUTTON_LEFT       0x00000000  // horizontal alignment - left align
#define UIBUTTON_CENTER     0x00000001  // horizontal alignment - center align
#define UIBUTTON_RIGHT      0x00000002  // horizontal alignment - right align
#define UIBUTTON_TOP        0x00000000  // vertical alignment - top align
#define UIBUTTON_VCENTER    0x00000004  // vertical alignment - center
#define UIBUTTON_BOTTOM     0x00000008  // vertical alignment - bottom
#define UIBUTTON_PUSH       0x00000000  // button type - push button
#define UIBUTTON_TOGGLE     0x00000010  // button type - toggle button
#define UIBUTTON_PUSHDOWN   0x00000020  // button type - pushdown button
#define UIBUTTON_FITIMAGE   0x00000100  // button style - fit image to the client area
#define UIBUTTON_SUNKENONMOUSEDOWN   0x00000200  // button style - sunken on mouse down
#define UIBUTTON_VERTICAL   0x00000400  // button style - vertical text drawing

#define UIBUTTON_HALIGNMASK 0x00000003  // (mask bits) horizontal alignment
#define UIBUTTON_VALIGNMASK 0x0000000c  // (mask bits) vertiacal alignment
#define UIBUTTON_TYPEMASK   0x00000030  // (mask bits) button type (push/toggle/pushdown)


// UIFButton notification code

#define UIBUTTON_PRESSED    0x00000001


// UIFButton status

#define UIBUTTON_NORMAL     0x00000000
#define UIBUTTON_DOWN       0x00000001
#define UIBUTTON_HOVER      0x00000002
#define UIBUTTON_DOWNOUT    0x00000003


//
// CUIFButton
//  = button UI object =
//

class CUIFButton : public CUIFObject
{
public:
    CUIFButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFButton( void );

    virtual void OnPaintNoTheme( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseIn( POINT pt );
    virtual void OnMouseOut( POINT pt );
    virtual void Enable( BOOL fEnable );

    void SetText( LPCWSTR pwch );
    void SetIcon( HICON hIcon );
    void SetIcon( LPCTSTR lpszResName );
    void SetBitmap( HBITMAP hBmp );
    void SetBitmap( LPCTSTR lpszResName );
    void SetBitmapMask( HBITMAP hBmp );
    void SetBitmapMask( LPCTSTR lpszResName );

    __inline LPCWSTR GetText( void )        { return m_pwchText; }
    __inline HICON GetIcon( void )          { return m_hIcon; }
    __inline HBITMAP GetBitmap( void )      { return m_hBmp; }
    __inline HBITMAP GetBitmapMask( void )  { return m_hBmpMask; }

    BOOL GetToggleState( void );
    void SetToggleState( BOOL fToggle );

    DWORD GetDCF()
    {
        return (GetStyle() & UIBUTTON_SUNKENONMOUSEDOWN) ? UIFDCF_BUTTONSUNKEN : UIFDCF_BUTTON;
    }

    BOOL IsVertical()
    {
        return (GetStyle() & UIBUTTON_VERTICAL) ? TRUE : FALSE;
    }

protected:
    DWORD   m_dwStatus;
    LPWSTR  m_pwchText;
    CUIFIcon   m_hIcon;
    HBITMAP m_hBmp;
    HBITMAP m_hBmpMask;
    BOOL    m_fToggled;
    SIZE    m_sizeIcon;
    SIZE    m_sizeText;
    SIZE    m_sizeBmp;

    virtual void SetStatus( DWORD dwStatus );
    void DrawEdgeProc( HDC hDC, const RECT *prc, BOOL fDown );
    void DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown );
    void DrawIconProc( HDC hDC, const RECT *prc, BOOL fDown );
    void DrawBitmapProc( HDC hDC, const RECT *prc, BOOL fDown );
    void GetTextSize( LPCWSTR pwch, SIZE *psize );
    void GetIconSize( HICON hIcon, SIZE *psize );
    void GetBitmapSize( HBITMAP hBmp, SIZE *psize );
};


//
// CUIFButton2
//  = button UI object =
//

class CUIFButton2 : public CUIFButton
{
public:
    CUIFButton2( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFButton2( void );

protected:
    virtual BOOL OnPaintTheme( HDC hDC );
    virtual void OnPaintNoTheme( HDC hDC );

private:
    DWORD MakeDrawFlag();

};


//
// CUIFScroll
//-----------------------------------------------------------------------------

class CUIFScroll;

//
// CUIFScrollButton
//  = scrollbar button UI object =
//

// UIFScrollButton style

#define UISCROLLBUTTON_LEFT     0x00000000
#define UISCROLLBUTTON_UP       0x00010000
#define UISCROLLBUTTON_RIGHT    0x00020000
#define UISCROLLBUTTON_DOWN     0x00030000

#define UISCROLLBUTTON_DIRMASK  0x00030000  /* mask bits */

// UIFScrollButton notification code

#define UISCROLLBUTTON_PRESSED  0x00010000

//

class CUIFScrollButton : public CUIFButton
{
public:
    CUIFScrollButton( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle );
    ~CUIFScrollButton( void );

    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseIn( POINT pt );
    virtual void OnMouseOut( POINT pt );
    virtual void OnPaint( HDC hDC );
    virtual void OnTimer( void );
};


//
// CUIFScrollThumb
//  = scrollbar thumb UI object =
//

// UIFScrollThumb notifucation code

#define UISCROLLTHUMB_MOVING    0x00000001
#define UISCROLLTHUMB_MOVED     0x00000002

//

class CUIFScrollThumb : public CUIFObject
{
public:
    CUIFScrollThumb( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFScrollThumb( void );

    virtual void OnPaint(HDC hDC);
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    void SetScrollArea( RECT *prc );

protected:
    void DragProc( POINT pt, BOOL fEndDrag );

    RECT  m_rcScrollArea;
    POINT m_ptDrag;
    POINT m_ptDragOrg;
};


//
// CUIFScroll
//  = scrollbar UI object =
//

// UIFScroll style

#define UISCROLL_VERTTB         0x00000000
#define UISCROLL_VERTBT         0x00000001
#define UISCROLL_HORZLR         0x00000002
#define UISCROLL_HORZRL         0x00000003

#define UISCROLL_DIRMASK        0x00000003  /* mask bits */

// UIFScroll scroll page direction

#define UISCROLL_NONE           0x00000000
#define UISCROLL_PAGEDOWN       0x00000001  // page left
#define UISCROLL_PAGEUP         0x00000002  // page right

// UIFScroll notify codes

#define UISCROLLNOTIFY_SCROLLED 0x00000001  // scrollbar has been moved
#define UISCROLLNOTIFY_SCROLLLN 0x00000002  // scroll up/down line

// UIFScroll info

typedef struct _UIFSCROLLINFO
{
    int nMax;
    int nPage;
    int nPos;
} UIFSCROLLINFO;


//

class CUIFScroll : public CUIFObject
{
public:
    CUIFScroll( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFScroll( void );

    virtual CUIFObject *Initialize( void );
    virtual void OnPaint(HDC hDC);
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseIn( POINT pt );
    virtual void OnMouseOut( POINT pt );
    virtual void SetRect( const RECT *prc );
    virtual void SetStyle( DWORD dwStyle );
    virtual void Show( BOOL fShow );
    virtual void OnTimer( void );
    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

    void SetScrollInfo( UIFSCROLLINFO *pScrollInfo );
    void GetScrollInfo( UIFSCROLLINFO *pScrollInfo );

protected:
    virtual void GetMetrics( void );
    void SetCurPos( int nPos, BOOL fAdjustThumb = TRUE );
    BOOL GetThumbRect( RECT *prc );
    BOOL GetBtnUpRect( RECT *prc );
    BOOL GetBtnDnRect( RECT *prc );
    DWORD GetScrollThumbStyle( void );
    DWORD GetScrollUpBtnStyle( void );
    DWORD GetScrollDnBtnStyle( void );
    void GetScrollArea( RECT *prc );
    void GetPageUpArea( RECT *prc );
    void GetPageDnArea( RECT *prc );

    __inline void ShiftLine( int nLine )
    {
        SetCurPos( m_ScrollInfo.nPos + nLine );
    }

    __inline void ShiftPage( int nPage )
    {
        SetCurPos( m_ScrollInfo.nPos + m_ScrollInfo.nPage * nPage );
    }

    __inline BOOL PtInPageUpArea( POINT pt )
    {
        RECT rc;
        GetPageUpArea( &rc );
        return PtInRect( &rc, pt );
    }

    __inline BOOL PtInPageDnArea( POINT pt )
    {
        RECT rc;
        GetPageDnArea( &rc );
        return PtInRect( &rc, pt );
    }

    CUIFScrollButton *m_pBtnUp;
    CUIFScrollButton *m_pBtnDn;
    CUIFScrollThumb  *m_pThumb;

    UIFSCROLLINFO m_ScrollInfo;
    SIZE  m_sizeScrollBtn;
    BOOL  m_fScrollPage;
    DWORD m_dwScrollDir;
};


//
// CUIFListBase
//-----------------------------------------------------------------------------

// UIFList style

#define UILIST_HORZTB           0x00000000
#define UILIST_HORZBT           0x00000001
#define UILIST_VERTLR           0x00000002
#define UILIST_VERTRL           0x00000003
#define UILIST_DISABLENOSCROLL  0x00000010
#define UILIST_HORZ             UILIST_HORZTB /* for compatibility */
#define UILIST_VERT             UILIST_VERTRL /* for compatibility */
#define UILIST_FIXEDHEIGHT      0x00000000
#define UILIST_VARIABLEHEIGHT   0x00000020
#define UILIST_ICONSNOTNUMBERS  0x00000040

#define UILIST_DIRMASK          0x00000003 /* mask bits */

// UIFList notification code

#define UILIST_SELECTED         0x00000001
#define UILIST_SELCHANGED       0x00000002


//
// CListItemBase
//  = list item data object base class =
//

class CListItemBase
{
public:
    CListItemBase( void )
    {
    }

    virtual ~CListItemBase( void )
    {
    }
};


//
// CUIFListBase
//  = list UI object base class =
//

class CUIFListBase : public CUIFObject
{
public:
    CUIFListBase( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFListBase( void );

    //
    // CUIFObject method
    //
    virtual CUIFObject *Initialize( void );
    virtual void OnPaint( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual void OnTimer( void );
    virtual void SetRect( const RECT *prc );
    virtual void SetStyle( DWORD dwStyle );
    virtual LRESULT OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam );

    int AddItem( CListItemBase *pItem );
    int GetCount( void );
    CListItemBase *GetItem( int iItem );
    void DelItem( int iItem );
    void DelAllItem( void );

    void SetSelection( int iSelection, BOOL fRedraw );
    void ClearSelection( BOOL fRedraw );
    void SetLineHeight( int nLineHeight );
    void SetTop( int nStart, BOOL fSetScrollPos );
    int GetSelection( void );
    int GetLineHeight( void );
    int GetTop( void );
    int GetBottom( void );
    int GetVisibleCount( void );

protected:
    CUIFObjectArray<CListItemBase> m_listItem;
    int        m_nItem;
    int        m_nItemVisible;
    int        m_iItemTop;
    int        m_iItemSelect;
    int        m_nLineHeight;
    CUIFScroll *m_pUIScroll;

    virtual int GetItemHeight( int iItem );
    virtual int GetListHeight( void );
    virtual void GetLineRect( int iLine, RECT *prc );
    virtual void GetScrollBarRect( RECT *prc );
    virtual DWORD GetScrollBarStyle( void );
    virtual CUIFScroll *CreateScrollBarObj( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle );
    virtual void PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected );

    int ListItemFromPoint( POINT pt );
    void CalcVisibleCount( void );
    void UpdateScrollBar( void );
};


//
// CUIFList
//-----------------------------------------------------------------------------

//
// CUIFList
//  = list UI object =
//

class CUIFList : public CUIFListBase
{
public:
    CUIFList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFList( void );

    int AddString( WCHAR *psz );
    LPCWSTR GetString( int iID );
    void DeleteString( int iID );
    void DeleteAllString( void );
    void SetPrivateData( int iID, DWORD dw );
    DWORD GetPrivateData( int iID );

protected:
    virtual void PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected );
    int ItemFromID( int iID );
};


//
// CUIFGripper
//-----------------------------------------------------------------------------

//
// CUIFGripper
//  = gripper UI object =
//

#define UIGRIPPER_VERTICAL  0x00000001

//
// Gripper Theme Margin
//
#define CUI_GRIPPER_THEME_MARGIN 2

class CUIFGripper : public CUIFObject
{
public:
    CUIFGripper( CUIFObject *pParent, const RECT *prc, DWORD dwStyle = 0);
    virtual ~CUIFGripper( void );

    virtual void SetStyle( DWORD dwStyle );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

protected:
    virtual BOOL OnPaintTheme( HDC hDC );
    virtual void OnPaintNoTheme( HDC hDC );

private:
    BOOL IsVertical()
    {
        return (GetStyle() & UIGRIPPER_VERTICAL) ? TRUE : FALSE;
    }
    POINT _ptCur;
};


//
// CUIFWndFrame
//-----------------------------------------------------------------------------

//
// CUIFWndFrame
//  = window frame obeject =
//

// CUIFWndFrame styles

#define UIWNDFRAME_THIN             0x00000000  // frame style: thin
#define UIWNDFRAME_THICK            0x00000001  // frame style: thick
#define UIWNDFRAME_ROUNDTHICK       0x00000002  // frame style: thick with rounded top corners
#define UIWNDFRAME_RESIZELEFT       0x00000010  // resize flag: resizable at left   border
#define UIWNDFRAME_RESIZETOP        0x00000020  // resize flag: resizable at top    border
#define UIWNDFRAME_RESIZERIGHT      0x00000040  // resize flag: resizable at right  border
#define UIWNDFRAME_RESIZEBOTTOM     0x00000080  // resize flag: resizable at bottom border
#define UIWNDFRAME_NORESIZE         0x00000000  // resize flag: no resizable
#define UIWNDFRAME_RESIZEALL        (UIWNDFRAME_RESIZELEFT | UIWNDFRAME_RESIZETOP | UIWNDFRAME_RESIZERIGHT | UIWNDFRAME_RESIZEBOTTOM)

#define UIWNDFRAME_STYLEMASK        0x0000000f  // (mask bit)

class CUIFWndFrame : public CUIFObject
{
public:
    CUIFWndFrame( CUIFObject *pParent, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFWndFrame( void );

    virtual BOOL OnPaintTheme( HDC hDC );
    virtual void OnPaintNoTheme( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

    void GetInternalRect( RECT *prc );
    void GetFrameSize( SIZE *psize );
    void SetFrameSize( SIZE *psize );
    void GetMinimumSize( SIZE *psize );
    void SetMinimumSize( SIZE *psize );

protected:
    DWORD m_dwHTResizing;
    POINT m_ptDrag;
    RECT  m_rcOrg;
    int   m_cxFrame;
    int   m_cyFrame;
    int   m_cxMin;
    int   m_cyMin;

    DWORD HitTest( POINT pt );
};


//
// CUIFWndCaption
//-----------------------------------------------------------------------------

//
// CUIFWndCaption
//  = window caption object =
//

#define UIWNDCAPTION_INACTIVE       0x00000000
#define UIWNDCAPTION_ACTIVE         0x00000001
#define UIWNDCAPTION_MOVABLE        0x00000002


class CUIFWndCaption : public CUIFStatic
{
public:
    CUIFWndCaption( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFWndCaption( void );

    virtual void OnPaint( HDC hDC );
    virtual void OnLButtonDown( POINT pt );
    virtual void OnLButtonUp( POINT pt );
    virtual void OnMouseMove( POINT pt );
    virtual BOOL OnSetCursor( UINT uMsg, POINT pt );

private:
    POINT m_ptDrag;
};


//
// CUIFCaptionButton
//-----------------------------------------------------------------------------

//
// CUIFCaptionButton
//  = caption control object =
//

#define UICAPTIONBUTTON_INACTIVE    0x00000000
#define UICAPTIONBUTTON_ACTIVE      0x00010000


class CUIFCaptionButton : public CUIFButton2
{
public:
    CUIFCaptionButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle );
    virtual ~CUIFCaptionButton( void );

    virtual void OnPaint( HDC hDC );
};

#endif /* CUIOBJ_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuiobj.cpp ===
//
// cuiobj.cpp
//  = ui object library =
//

#include "private.h"
#include "delay.h"
#include "cuiobj.h"
#include "cuiwnd.h"
#include "cuitip.h"
#include "cmydc.h"
#include "cuiutil.h"
#include "cuitheme.h"


#define SCROLLTHUMBHEIGHT_MIN   6


/*   G E T  S C R O L L  D E L A Y   */
/*------------------------------------------------------------------------------

    Get delay time to start auto scroll (while the scroll button down)
    The time is in milli-second

------------------------------------------------------------------------------*/
__inline UINT GetScrollDelay( void )
{
    return (GetDoubleClickTime() * 4 / 5);
}


/*   G E T  S C R O L L  S P E E D   */
/*------------------------------------------------------------------------------

    Get repeat time in auto scroll (while the scroll button down)
    The time is in milli-second

------------------------------------------------------------------------------*/
__inline UINT GetScrollSpeed( void )
{
    return (GetScrollDelay() / 8);
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  O B J E C T                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  O B J E C T   */
/*------------------------------------------------------------------------------

    Constructor of CUIFObject

------------------------------------------------------------------------------*/
CUIFObject::CUIFObject( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle )
{
    m_pParent = pParent;
    m_dwID    = dwID;
    m_dwStyle = dwStyle;

    ::SetRect( &m_rc, 0, 0, 0, 0 );
    if (prc != NULL) {
        m_rc = *prc;
    }

    m_pUIWnd = NULL;
    if (m_pParent != NULL) {
        m_pUIWnd = pParent->GetUIWnd();
    }

    m_pUIFScheme = NULL;
    if (m_pParent != NULL) {
        m_pUIFScheme = pParent->GetUIFScheme();
    }

    m_fEnabled = TRUE;
    m_fVisible = TRUE;
    m_hFont    = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
    m_fUseCustomFont = FALSE;
    m_pwchToolTip = NULL;

    m_pointPreferredSize.x=m_pointPreferredSize.y=-1;

#if defined(_DEBUG) || defined(DEBUG)
    m_fInitialized = FALSE;
#endif /* DEBUG */
}


/*   ~  C  U I F  O B J E C T   */
/*------------------------------------------------------------------------------

    Destructor of CUIFObject

------------------------------------------------------------------------------*/
CUIFObject::~CUIFObject( void )
{
    CUIFObject *pUIObj;

#if defined(_DEBUG) || defined(DEBUG)
    Assert( m_fInitialized );
#endif /* DEBUG */

    // dispose buffer
    if (m_pUIWnd != NULL) {
        CUIFToolTip *pTipWnd = m_pUIWnd->GetToolTipWnd();
        if (pTipWnd && (this == pTipWnd->GetCurrentObj()))
            pTipWnd->ClearCurrentObj();
    }

    if (m_pwchToolTip != NULL) {
        delete m_pwchToolTip;
    }

    // delete children

    while (pUIObj = m_ChildList.GetLast()) {
        m_ChildList.Remove( pUIObj );
        delete pUIObj;
    }

    // to clear capture/timer/pointed status call RemoveUIObj of UIFrameWindow

    if (m_pUIWnd != NULL) {
        m_pUIWnd->RemoveUIObj( this );
    }
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Inititalize the object
    Returns TRUE when succeed to initialize, FALSE when failed.
    This function MUST be called when create a object.

------------------------------------------------------------------------------*/
CUIFObject *CUIFObject::Initialize( void )
{
#if defined(_DEBUG) || defined(DEBUG)
    Assert( !m_fInitialized );
    m_fInitialized = TRUE;
#endif /* DEBUG */

    return this;
}


/*   C A L L  O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::CallOnPaint( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->UpdateUI(&GetRectRef());
    }
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
void CUIFObject::OnPaint( HDC hDC )
{
    BOOL fDefault = TRUE;

    if ((GetUIWnd()->GetStyle() & UIWINDOW_WHISTLERLOOK) != 0) {
        fDefault = !OnPaintTheme( hDC );
    }

    if (fDefault) {
        OnPaintNoTheme( hDC );
    }
}


/*   S T A R T  C A P T U R E   */
/*------------------------------------------------------------------------------

    Start capturing mouse

------------------------------------------------------------------------------*/
void CUIFObject::StartCapture( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetCaptureObject( this );
    }
}


/*   E N D  C A P T U R E   */
/*------------------------------------------------------------------------------

    End capturing mouse

------------------------------------------------------------------------------*/
void CUIFObject::EndCapture( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetCaptureObject( NULL );
    }
}


/*   S T A R T  T I M E R   */
/*------------------------------------------------------------------------------

    Make timer

------------------------------------------------------------------------------*/
void CUIFObject::StartTimer( UINT uElapse )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetTimerObject( this, uElapse );
    }
}


/*   E N D  T I M E R   */
/*------------------------------------------------------------------------------

    Kill timer

------------------------------------------------------------------------------*/
void CUIFObject::EndTimer( void )
{
    if (m_pUIWnd != NULL) {
        m_pUIWnd->SetTimerObject( NULL );
    }
}


/*   I S  C A P T U R E   */
/*------------------------------------------------------------------------------

    Check if the object is capturing mouse

------------------------------------------------------------------------------*/
BOOL CUIFObject::IsCapture( void )
{
    if (m_pUIWnd != NULL) {
        return (m_pUIWnd->GetCaptureObject() == this);
    }

    return FALSE;
}


/*   I S  T I M E R   */
/*------------------------------------------------------------------------------

    Check if the object has timer

------------------------------------------------------------------------------*/
BOOL CUIFObject::IsTimer( void )
{
    if (m_pUIWnd != NULL) {
        return (m_pUIWnd->GetTimerObject() == this);
    }

    return FALSE;
}


/*   G E T  R E C T   */
/*------------------------------------------------------------------------------

    Get rectangle of object

------------------------------------------------------------------------------*/
void CUIFObject::GetRect( RECT *prc )
{
    *prc = GetRectRef();
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------

    Set rectangle of object

------------------------------------------------------------------------------*/
void CUIFObject::SetRect( const RECT *prc )
{
    Assert(PtrToInt(prc));
    m_rc = *prc;

    if (m_pUIWnd != NULL) {
        m_pUIWnd->OnObjectMoved( this );
    }

    CallOnPaint();
}


/*   P T  I N  O B J E C T   */
/*------------------------------------------------------------------------------

    Check if point is in the object

------------------------------------------------------------------------------*/
BOOL CUIFObject::PtInObject( POINT pt )
{
    return m_fVisible && PtInRect( &GetRectRef(), pt );
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------

    Enable/disable object

------------------------------------------------------------------------------*/
void CUIFObject::Enable( BOOL fEnable )
{
    if (m_fEnabled != fEnable) {
        int nChild;
        int i;

        m_fEnabled = fEnable;
        
        // enable/disable all children

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );

            Assert( pUIObj != NULL );
            pUIObj->Enable( fEnable );
        }

        CallOnPaint();
    }
}


/*   S H O W   */
/*------------------------------------------------------------------------------

    Show/hide object

------------------------------------------------------------------------------*/
void CUIFObject::Show( BOOL fShow )
{
    if (m_fVisible != fShow) {
        int nChild;
        int i;

        m_fVisible = fShow;

        // show/hide all children

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );

            Assert( pUIObj != NULL );
            pUIObj->Show( fShow );
        }

        // let parent paint the object when it's hidden

        if (!m_fVisible) {
            if (m_pParent != NULL) {
               m_pParent->CallOnPaint();
            }
        }
        else {
            CallOnPaint();
        }
    }
}


/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

    Set font

------------------------------------------------------------------------------*/
void CUIFObject::SetFontToThis( HFONT hFont )
{
    if (hFont == NULL) {
        hFont = (HFONT)GetStockObject( DEFAULT_GUI_FONT );
        m_fUseCustomFont = FALSE;
    } else {
        m_fUseCustomFont = TRUE;
    }
    m_hFont = hFont;
}

/*   S E T  F O N T   */
/*------------------------------------------------------------------------------

    Set font

------------------------------------------------------------------------------*/
void CUIFObject::SetFont( HFONT hFont )
{
    int nChild;
    int i;

    SetFontToThis(hFont);

    // set font to all children

    nChild = m_ChildList.GetCount();
    for (i = 0; i < nChild; i++) {
        CUIFObject *pUIObj = m_ChildList.Get( i );

        Assert( pUIObj != NULL );
        pUIObj->SetFont( hFont );
    }

    CallOnPaint();
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------

    Set the style of object

------------------------------------------------------------------------------*/
void CUIFObject::SetStyle( DWORD dwStyle )
{
    m_dwStyle = dwStyle;
}


/*   P A I N T  O B J E C T   */
/*------------------------------------------------------------------------------

    Paint object
    NOTE: Paint itself at first (actual paint is done in OnPaint()), and then
    paint all children if exist.

------------------------------------------------------------------------------*/
void CUIFObject::PaintObject( HDC hDC, const RECT *prcUpdate )
{
    int nChild;
    int i;

    if (prcUpdate == NULL) {
        prcUpdate = &GetRectRef();
    }

    if (m_fVisible) {
        // paint itself at first

        OnPaint( hDC );

        // paint all children

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );
            RECT rcDest;

            Assert( pUIObj != NULL );
            if (IntersectRect( &rcDest, prcUpdate, &pUIObj->GetRectRef() )) {
                pUIObj->PaintObject( hDC, &rcDest );
            }
        }
    }
}


/*   A D D  U I  O B J   */
/*------------------------------------------------------------------------------

    Add child UI object

------------------------------------------------------------------------------*/
void CUIFObject::AddUIObj( CUIFObject *pUIObj )
{
    Assert( pUIObj != NULL );
    Assert( pUIObj->FInitialized() );

    if (m_ChildList.Add( pUIObj )) {
        CallOnPaint();
    }
}


/*   R E M O V E  U I  O B J   */
/*------------------------------------------------------------------------------

    Remove child UI object

------------------------------------------------------------------------------*/
void CUIFObject::RemoveUIObj( CUIFObject *pUIObj )
{
    Assert( pUIObj != NULL );

    if (m_ChildList.Remove( pUIObj )) {
        CallOnPaint();
    }
}


/*   O B J E C T  F R O M  P O I N T   */
/*------------------------------------------------------------------------------

    Get UI object from point
    Returns UI object which is under of the point.  If no UI object found,
    returns NULL.

------------------------------------------------------------------------------*/
CUIFObject *CUIFObject::ObjectFromPoint( POINT pt )
{
    CUIFObject *pUIObjFromPoint = NULL;

    if (PtInObject( pt )) {
        int nChild;
        int i;

        pUIObjFromPoint = this;

        nChild = m_ChildList.GetCount();
        for (i = 0; i < nChild; i++) {
            CUIFObject *pUIObj = m_ChildList.Get( i );
            CUIFObject *pUIObjFromPointChild = NULL;

            Assert( pUIObj != NULL );
            pUIObjFromPointChild = pUIObj->ObjectFromPoint( pt );
            if (pUIObjFromPointChild != NULL) {
                pUIObjFromPoint = pUIObjFromPointChild;
            }
        }
    }

    return pUIObjFromPoint;
}


/*   O N  O B J E C T  N O T I F Y     */
/*------------------------------------------------------------------------------

    Default handler: Send notification to the parent object
    This allows for heirarchies of objects administrated from the top.

------------------------------------------------------------------------------*/
LRESULT CUIFObject::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCode, LPARAM lParam )
{
    LRESULT lResult = 0;

    if (m_pParent != NULL) {
        lResult = m_pParent->OnObjectNotify( pUIObj, dwCode, lParam );
    }

    return lResult;
}


/*   S E T  T O O L  T I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::SetToolTip( LPCWSTR pwchToolTip )
{
    if (m_pwchToolTip != NULL) {
        delete m_pwchToolTip;
        m_pwchToolTip = NULL;
    }

    if (pwchToolTip != NULL) {
        m_pwchToolTip = new WCHAR[ StrLenW( pwchToolTip ) + 1 ];
        if (m_pwchToolTip)
            StrCpyW( m_pwchToolTip, pwchToolTip );
    }
}


/*   G E T  T O O L  T I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CUIFObject::GetToolTip( void )
{
    return m_pwchToolTip;
}


/*   N O T I F Y  C O M M A N D   */
/*------------------------------------------------------------------------------

    Send notification to the parent object

------------------------------------------------------------------------------*/
LRESULT CUIFObject::NotifyCommand( DWORD dwCode, LPARAM lParam )
{
    LRESULT lResult = 0;

    if (m_pParent != NULL) {
        lResult = m_pParent->OnObjectNotify( this, dwCode, lParam );
    }

    return lResult;
}


/*   G E T  F O N T  H E I G H T   */
/*------------------------------------------------------------------------------

    Get the height of font set to the object

------------------------------------------------------------------------------*/
int CUIFObject::GetFontHeight( void )
{
    HDC hDC;
    HFONT hFontOld;
    TEXTMETRIC tm;

    hDC = GetDC( m_pUIWnd->GetWnd() );
    hFontOld = (HFONT)SelectObject( hDC, m_hFont );

    GetTextMetrics( hDC, &tm );

    SelectObject( hDC, hFontOld );
    ReleaseDC( m_pUIWnd->GetWnd(), hDC );

    return tm.tmHeight + tm.tmExternalLeading;
}


/*   G E T  U I F  C O L O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
COLORREF CUIFObject::GetUIFColor( UIFCOLOR iCol )
{ 
    return (m_pUIFScheme != NULL) ? m_pUIFScheme->GetColor( iCol ) : RGB( 0, 0, 0 );
}


/*   G E T  U I F  B R U S H   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HBRUSH CUIFObject::GetUIFBrush( UIFCOLOR iCol )
{ 
    return (m_pUIFScheme != NULL) ? m_pUIFScheme->GetBrush( iCol ) : NULL; 
}

/*   D E T A C H W N D O B J   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::DetachWndObj( void )
{
    if (m_pUIWnd != NULL) {
        CUIFToolTip *pTipWnd = m_pUIWnd->GetToolTipWnd();
        if (pTipWnd && (this == pTipWnd->GetCurrentObj()))
            pTipWnd->ClearCurrentObj();
        m_pUIWnd->RemoveUIObj( this );
    }
    m_pUIWnd = NULL;
}

/*   C L E A R W N D O B J */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::ClearWndObj( void )
{
    int i;

    m_pUIWnd = NULL;

    for (i = 0; i < m_ChildList.GetCount(); i ++)
    {
        CUIFObject *pObj;
        pObj = m_ChildList.Get(i);
        if (pObj)
            pObj->ClearWndObj();
    }
}

/*   O N T H E M E C H A N G E D
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::ClearTheme( void )
{
    int i;
    CloseThemeData();

    for (i = 0; i < m_ChildList.GetCount(); i ++)
    {
        CUIFObject *pObj;
        pObj = m_ChildList.Get(i);
        if (pObj)
            pObj->ClearTheme();
    }
}

/*   O N T H E M E C H A N G E D
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFObject::SetScheme(CUIFScheme *pUIFScheme)
{
    int i;
    m_pUIFScheme = pUIFScheme;; 

    for (i = 0; i < m_ChildList.GetCount(); i ++)
    {
        CUIFObject *pObj;
        pObj = m_ChildList.Get(i);
        if (pObj)
            pObj->SetScheme(pUIFScheme);
    }
}

/*   I S R T L  */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFObject::IsRTL()
{
    if (!m_pUIWnd)
        return FALSE;

    if (!m_pUIWnd->FHasStyle( UIWINDOW_LAYOUTRTL ))
        return FALSE;

    return TRUE;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B O R D E R                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B O R D E R   */
/*------------------------------------------------------------------------------

    Constructor of  CUIFBorder

------------------------------------------------------------------------------*/
CUIFBorder::CUIFBorder( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  B O R D E R   */
/*------------------------------------------------------------------------------

    Destructor of CUIFBorder

------------------------------------------------------------------------------*/
CUIFBorder::~CUIFBorder( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of border object

------------------------------------------------------------------------------*/
void CUIFBorder::OnPaint( HDC hDC )
{
    RECT rc = GetRectRef();

    switch (m_dwStyle & UIBORDER_DIRMASK) {
        default:
        case UIBORDER_HORZ: {
            DrawEdge( hDC, &rc, EDGE_ETCHED, BF_TOP );
            break;
        }

        case UIBORDER_VERT: {
            DrawEdge( hDC, &rc, EDGE_ETCHED, BF_LEFT );
            break;
        }
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S T A T I C                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  S T A T I C   */
/*------------------------------------------------------------------------------

    Constructor of CUIFStatic

------------------------------------------------------------------------------*/
CUIFStatic::CUIFStatic( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_pwchText = NULL;
}


/*   ~  C  U I F  S T A T I C   */
/*------------------------------------------------------------------------------

    Destructor of CUIFStatic

------------------------------------------------------------------------------*/
CUIFStatic::~CUIFStatic( void )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
    }
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

    Set text to display

------------------------------------------------------------------------------*/
void CUIFStatic::SetText( LPCWSTR pwchText )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
        m_pwchText = NULL;
    }

    if (pwchText != NULL) {
        int cwch = StrLenW( pwchText ) + 1;

        m_pwchText = new WCHAR[ cwch ];
        if (m_pwchText)
            MemCopy( m_pwchText, pwchText, cwch * sizeof(WCHAR) );
    }

    // update window

    CallOnPaint();
}


/*   G E T  T E X T   */
/*------------------------------------------------------------------------------

    Get text

------------------------------------------------------------------------------*/
int CUIFStatic::GetText( LPWSTR pwchBuf, int cwchBuf )
{
    int cwchText = (m_pwchText == NULL) ? 0 : StrLenW(m_pwchText);

    if (cwchBuf <= 0) {
        // return text length in cwch (not including null-terminater)

        return cwchText;
    }
    else if (pwchBuf == NULL) {
        // return error code

        return (-1);
    }

    if (0 < cwchText) {
        cwchText = min( cwchText, cwchBuf-1 );
        MemCopy( pwchBuf, m_pwchText, cwchText * sizeof(WCHAR) );
        *(pwchBuf + cwchText) = L'\0';      // always null terminate
    }

    return cwchText;
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of static object

------------------------------------------------------------------------------*/
void CUIFStatic::OnPaint( HDC hDC )
{
    HFONT hFontOld;
    int xAlign;
    int yAlign;
    SIZE size;
    int cwch;

    if (m_pwchText == NULL) {
        return;
    }

    cwch = StrLenW(m_pwchText);

    // prepare objects

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );

    // calc alignment

    GetTextExtentPointW( hDC, m_pwchText, cwch, &size );
    switch (m_dwStyle & UISTATIC_HALIGNMASK) {
        case UISTATIC_LEFT:
        default: {
            xAlign = 0;
            break;
        }

        case UISTATIC_CENTER: {
            xAlign = (GetRectRef().right - GetRectRef().left - size.cx) / 2;
            break;
        }

        case UISTATIC_RIGHT: {
            xAlign = GetRectRef().right - GetRectRef().left - size.cx;
            break;
        }
    }

    switch (m_dwStyle & UISTATIC_VALIGNMASK) {
        case UISTATIC_TOP:
        default: {
            yAlign = 0;
            break;
        }

        case UISTATIC_VCENTER: {
            yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;
            break;
        }

        case UISTATIC_BOTTOM: {
            yAlign = GetRectRef().bottom - GetRectRef().top - size.cy;
            break;
        }
    }

    // draw

    SetBkMode( hDC, TRANSPARENT );
    if (IsEnabled()) {
        SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
        CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign,
                    GetRectRef().top + yAlign,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );
    }
    else {
        SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
        CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign + 1,
                    GetRectRef().top + yAlign + 1,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );

        SetTextColor( hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign,
                    GetRectRef().top + yAlign,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );
    }

    // restore objects

    SelectObject( hDC, hFontOld);
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B U T T O N                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B U T T O N   */
/*------------------------------------------------------------------------------

    Constructor of CUIFButton

------------------------------------------------------------------------------*/
CUIFButton::CUIFButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_dwStatus = UIBUTTON_NORMAL;
    m_fToggled = FALSE;

    m_hIcon    = NULL;
    m_hBmp     = NULL;
    m_hBmpMask = NULL;
    m_pwchText = NULL;
}


/*   ~  C  U I F  B U T T O N   */
/*------------------------------------------------------------------------------

    Destructor of CUIFButton

------------------------------------------------------------------------------*/
CUIFButton::~CUIFButton( void )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
    }
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
void CUIFButton::OnPaintNoTheme( HDC hDC )
{
    BOOL fDownFace;

    // erase face at first

    FillRect( hDC, &GetRectRef(), (HBRUSH)(COLOR_3DFACE + 1) );
#ifndef UNDER_CE
    if (m_fToggled && (m_dwStatus == UIBUTTON_NORMAL || m_dwStatus == UIBUTTON_DOWNOUT)) {
        RECT rc;
        HBRUSH hBrush;
        COLORREF colTextOld;
        COLORREF colBackOld;

        hBrush = CreateDitherBrush();
        if (hBrush)
        {
            colTextOld = SetTextColor( hDC, GetSysColor(COLOR_3DFACE) );
            colBackOld = SetBkColor( hDC, GetSysColor(COLOR_3DHILIGHT) );

            rc = GetRectRef();
            InflateRect( &rc, -2, -2 );
            FillRect( hDC, &rc, hBrush );

            SetTextColor( hDC, colTextOld );
            SetBkColor( hDC, colBackOld );
            DeleteObject( hBrush );
        }
    }
#endif /* !UNDER_CE */

    // draw face

    fDownFace = m_fToggled || (m_dwStatus == UIBUTTON_DOWN);

    if (m_hBmp != NULL) {
        DrawBitmapProc( hDC, &GetRectRef(), fDownFace );
    }
    else if (m_hIcon != NULL) {
        DrawIconProc( hDC, &GetRectRef(), fDownFace );
    }
    else {
        DrawTextProc( hDC, &GetRectRef(), fDownFace );
    }

    // draw button edge

    if (m_fToggled) {
      DrawEdgeProc( hDC, &GetRectRef(), TRUE );
    }
    else {
        switch (m_dwStatus) {
            case UIBUTTON_DOWN: {
                DrawEdgeProc( hDC, &GetRectRef(), TRUE );
                break;
            }

            case UIBUTTON_HOVER:
            case UIBUTTON_DOWNOUT: {
                DrawEdgeProc( hDC, &GetRectRef(), FALSE );
                break;
            }
        }
    }
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnLButtonDown( POINT pt )
{
    SetStatus( UIBUTTON_DOWN );
    StartCapture();

    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            break;
        }

        case UIBUTTON_TOGGLE: {
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            NotifyCommand( UIBUTTON_PRESSED, 0 );
            break;
        }
    }
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnLButtonUp( POINT pt )
{
    BOOL fCaptured = IsCapture();

    if (fCaptured) {
        EndCapture();
    }

    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            if (PtInObject( pt )) {
                SetStatus( UIBUTTON_HOVER );
                NotifyCommand( UIBUTTON_PRESSED, 0 );
            }
            else {
                SetStatus( UIBUTTON_NORMAL );
            }
            break;
        }

        case UIBUTTON_TOGGLE: {
            if (PtInObject( pt )) {
                SetStatus( UIBUTTON_HOVER );

                if (fCaptured) {
                    m_fToggled = !m_fToggled;
                    NotifyCommand( UIBUTTON_PRESSED, 0 );
                }
            }
            else {
                SetStatus( UIBUTTON_NORMAL );
            }
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            SetStatus( UIBUTTON_NORMAL );
            break;
        }
    }
}


/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnMouseIn( POINT pt )
{
    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            SetStatus( IsCapture() ? UIBUTTON_DOWN : UIBUTTON_HOVER );
            break;
        }

        case UIBUTTON_TOGGLE: {
            SetStatus( IsCapture() ? UIBUTTON_DOWN : UIBUTTON_HOVER );
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            SetStatus( IsCapture() ? UIBUTTON_NORMAL : UIBUTTON_HOVER );
            break;
        }
    }
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::OnMouseOut( POINT pt )
{
    switch (m_dwStyle & UIBUTTON_TYPEMASK) {
        default:
        case UIBUTTON_PUSH: {
            SetStatus( IsCapture() ? UIBUTTON_DOWNOUT : UIBUTTON_NORMAL );
            break;
        }

        case UIBUTTON_TOGGLE: {
            SetStatus( IsCapture() ? UIBUTTON_DOWNOUT : UIBUTTON_NORMAL );
            break;
        }

        case UIBUTTON_PUSHDOWN: {
            SetStatus( UIBUTTON_NORMAL );
            break;
        }
    }
}


/*   E N A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFButton::Enable( BOOL fEnable )
{
    CUIFObject::Enable( fEnable );
    if (!IsEnabled()) {
        SetStatus( UIBUTTON_NORMAL );

        if (IsCapture()) {
            EndCapture();
        }
    }
}


/*   D R A W  E D G E  P R O C   */
/*------------------------------------------------------------------------------

    Draw button edge

------------------------------------------------------------------------------*/
void CUIFButton::DrawEdgeProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    RECT rc = *prc;
    DrawEdge( hDC, &rc, fDown ? BDR_SUNKENOUTER : BDR_RAISEDINNER, BF_RECT );
}


/*   S E T  T E X T   */
/*------------------------------------------------------------------------------

    Set text of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetText( LPCWSTR psz )
{
    if (m_pwchText != NULL) {
        delete m_pwchText;
        m_pwchText = NULL;
    }

    // 
    //  init size;
    // 
    MemSet(&m_sizeText, 0, sizeof(SIZE));

    if (psz != NULL) 
    {
        int cwch = StrLenW( psz ) + 1;

        m_pwchText = new WCHAR[ cwch ];
        if (!m_pwchText)
            return;

        MemCopy( m_pwchText, psz, cwch * sizeof(WCHAR) );
        GetTextSize( m_pwchText, &m_sizeText );
    }

    // update window

    CallOnPaint();
}


/*   S E T  I C O N   */
/*------------------------------------------------------------------------------

    Set icon of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetIcon( HICON hIcon )
{
    m_hIcon = hIcon;
    if (m_hIcon)
        GetIconSize(m_hIcon, &m_sizeIcon);
    else
        MemSet(&m_sizeIcon, 0, sizeof(SIZE));
    CallOnPaint();
}


/*   S E T  I C O N   */
/*------------------------------------------------------------------------------

    Set icon of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetIcon( LPCTSTR lpszResName )
{
    SetIcon( LoadIcon( m_pUIWnd->GetInstance(), lpszResName ) );
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmap( HBITMAP hBmp )
{
    m_hBmp = hBmp;
    if (m_hBmp)
        GetBitmapSize(m_hBmp, &m_sizeBmp);
    else
        MemSet(&m_sizeBmp, 0, sizeof(SIZE));
    CallOnPaint();
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmap( LPCTSTR lpszResName )
{
    SetBitmap( LoadBitmap( m_pUIWnd->GetInstance(), lpszResName ) );
}

/*   S E T  B I T M A P M A S K  */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmapMask( HBITMAP hBmp )
{
    m_hBmpMask = hBmp;

    CallOnPaint();
}


/*   S E T  B I T M A P   */
/*------------------------------------------------------------------------------

    Set bitmap of button face

------------------------------------------------------------------------------*/
void CUIFButton::SetBitmapMask( LPCTSTR lpszResName )
{
    SetBitmapMask( LoadBitmap( m_pUIWnd->GetInstance(), lpszResName ) );
}


/*   D R A W  T E X T  P R O C   */
/*------------------------------------------------------------------------------

    Draw text on button face

------------------------------------------------------------------------------*/
void CUIFButton::DrawTextProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    int nDownPad = fDown ? 1 : 0;
    int xAlign;
    int yAlign;
    SIZE size;
    HFONT hFontOld;

    //

    if (m_pwchText == NULL) {
        return;
    }

    //

    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    // calc text width

    CUIGetTextExtentPoint32( hDC, m_pwchText, StrLenW(m_pwchText), &size );
    switch (m_dwStyle & UIBUTTON_HALIGNMASK) {
        case UIBUTTON_LEFT:
        default: {
            xAlign = 0;
            break;
        }

        case UIBUTTON_CENTER: {
            xAlign = (GetRectRef().right - GetRectRef().left - size.cx) / 2;
            break;
        }

        case UIBUTTON_RIGHT: {
            xAlign = GetRectRef().right - GetRectRef().left - size.cx;
            break;
        }
    }

    switch (m_dwStyle & UIBUTTON_VALIGNMASK) {
        case UIBUTTON_TOP:
        default: {
            yAlign = 0;
            break;
        }

        case UIBUTTON_VCENTER: {
            yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;
            break;
        }

        case UIBUTTON_BOTTOM: {
            yAlign = GetRectRef().bottom - GetRectRef().top - size.cy;
            break;
        }
    }

    //

    SetBkMode( hDC, TRANSPARENT );
    if (IsEnabled()) {
        SetTextColor( hDC, GetSysColor(COLOR_BTNTEXT) );
        CUIExtTextOut( hDC,
                    prc->left + xAlign + nDownPad,
                    prc->top + yAlign + nDownPad,
                    ETO_CLIPPED,
                    prc,
                    m_pwchText,
                    StrLenW(m_pwchText),
                    NULL );
    }
    else {
        SetTextColor( hDC, GetSysColor(COLOR_3DHIGHLIGHT) );
        CUIExtTextOut( hDC,
                    prc->left + xAlign + nDownPad + 1,
                    prc->top + yAlign + nDownPad + 1,
                    ETO_CLIPPED,
                    prc,
                    m_pwchText,
                    StrLenW(m_pwchText),
                    NULL );

        SetTextColor( hDC, GetSysColor(COLOR_3DSHADOW) );
        CUIExtTextOut( hDC,
                    prc->left + xAlign + nDownPad,
                    prc->top + yAlign + nDownPad,
                    ETO_CLIPPED,
                    prc,
                    m_pwchText,
                    StrLenW(m_pwchText),
                    NULL );
    }

    SelectObject( hDC, hFontOld );
}


/*   D R A W  I C O N  P R O C   */
/*------------------------------------------------------------------------------

    Draw icon on button face

------------------------------------------------------------------------------*/
void CUIFButton::DrawIconProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    Assert(hDC && prc && m_hIcon);
    const int nDownPad = fDown ? 1 : 0;
    const int nWidth = prc->right - prc->left;
    const int nHeight= prc->bottom - prc->top;
    const RECT rc = {0, 0, nWidth, nHeight};
    HDC hDCMem = NULL;
    HBITMAP hBmpOld;
    HBITMAP hBmp = NULL;

    // prepare memory dc

    hDCMem = CreateCompatibleDC( hDC );
    if (!hDCMem)
        goto Exit;
       
    hBmp = CreateCompatibleBitmap( hDC, nWidth, nHeight );
    if (!hBmp)
        goto Exit;
       
    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmp );


    // clear background

    if (IsEnabled()) {
        BitBlt( hDCMem, rc.left, rc.top, nWidth, nHeight, hDC, prc->left, prc->top, SRCCOPY );
    }
    else {
        FillRect( hDCMem, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH) );
    }

    // paint icon into memory dc

    if (m_dwStyle & UIBUTTON_FITIMAGE) {
        DrawIconEx( hDCMem,
            2 + nDownPad,
            2 + nDownPad,
            m_hIcon,
            nWidth  - 4,
            nHeight - 4,
            0,
            NULL,
            DI_NORMAL );
    }
    else {
        DrawIconEx( hDCMem,
            (nWidth - 16) / 2 + nDownPad,
            (nHeight - 16) / 2 + nDownPad,
            m_hIcon,
            16,
            16,
            0,
            NULL,
            DI_NORMAL );
    }

    SelectObject( hDCMem, hBmpOld);

    CUIDrawState( hDC,
        NULL,
        NULL,
        (LPARAM)hBmp,
        0, // we don't pass a WPARAM in this case.
        prc->left,
        prc->top,
        nWidth,
        nHeight,
        DST_BITMAP | (IsEnabled() ? 0 : (DSS_DISABLED | DSS_MONO)) );

Exit:
    if (hBmp)
        DeleteObject( hBmp );
    if (hDCMem)
        DeleteDC( hDCMem );
}


/*   D R A W  B I T M A P  P R O C   */
/*------------------------------------------------------------------------------

    Draw bitmap on button face 

------------------------------------------------------------------------------*/
void CUIFButton::DrawBitmapProc( HDC hDC, const RECT *prc, BOOL fDown )
{
    const int nDownPad = fDown ? 1 : 0;
    const int nWidth = GetRectRef().right - GetRectRef().left;
    const int nHeight= GetRectRef().bottom - GetRectRef().top;

    if (!m_hBmpMask)
    {
        CUIDrawState( hDC,
            NULL,
            NULL,
            (LPARAM)m_hBmp,
            0,
            prc->left + nDownPad,
            prc->top  + nDownPad,
            nWidth  - nDownPad,
            nHeight - nDownPad,
            DST_BITMAP | (IsEnabled() ? 0 : DSS_DISABLED | DSS_MONO) );
    }
    else
    {
        HBITMAP hBmp = CreateMaskBmp(&GetRectRef(), 
                                     m_hBmp, 
                                     m_hBmpMask, 
                                     (HBRUSH)(COLOR_3DFACE + 1) , 0, 0);
        CUIDrawState( hDC,
            NULL,
            NULL,
            (LPARAM)hBmp,
            0,
            prc->left + nDownPad,
            prc->top  + nDownPad,
            nWidth  - nDownPad,
            nHeight - nDownPad,
            DST_BITMAP | (IsEnabled() ? 0 : DSS_DISABLED | DSS_MONO) );

        DeleteObject(hBmp);
    }
}


/*   S E T  S T A T U S   */
/*------------------------------------------------------------------------------

    Set button status

------------------------------------------------------------------------------*/
void CUIFButton::SetStatus( DWORD dwStatus )
{
    if (dwStatus != m_dwStatus) {
        m_dwStatus = dwStatus;
        CallOnPaint();
    }
}


/*   G E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------

    Get toggle status
    Returns TRUE when the button has been toggled.

------------------------------------------------------------------------------*/
BOOL CUIFButton::GetToggleState( void )
{
    return m_fToggled;
}


/*   S E T  T O G G L E  S T A T E   */
/*------------------------------------------------------------------------------

    Set toggle status

------------------------------------------------------------------------------*/
void CUIFButton::SetToggleState( BOOL fToggle )
{
    if ((m_dwStyle & UIBUTTON_TYPEMASK) == UIBUTTON_TOGGLE && m_fToggled != fToggle) {
        m_fToggled = fToggle;
        CallOnPaint();
    }
}


/*   G E T  T E X T  S I Z E   */
/*------------------------------------------------------------------------------

    calc text width

------------------------------------------------------------------------------*/
void CUIFButton::GetTextSize( LPCWSTR pwch, SIZE *psize )
{
    HDC hDC = GetDC( NULL );
    HFONT hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    Assert( pwch != NULL );
    if (!m_fUseCustomFont && SUCCEEDED(EnsureThemeData(m_pUIWnd->GetWnd())))
    {
        RECT rcText;
        GetThemeTextExtent( hDC,0 , pwch, StrLenW(pwch),0, NULL, &rcText);
        psize->cx = rcText.right;
        psize->cy = rcText.bottom;

    }
    else
    {
        CUIGetTextExtentPoint32( hDC, pwch, StrLenW(pwch), psize );
    }

    //
    // swap width and height
    //
    if (IsVertical())
    {
        int nTemp = psize->cx;
        psize->cx = psize->cy;
        psize->cy = nTemp;
    }

    SelectObject( hDC, hFontOld );
    ReleaseDC( NULL, hDC );
}


/*   G E T  I C O N  S I Z E   */
/*------------------------------------------------------------------------------

    get icon size

------------------------------------------------------------------------------*/
void CUIFButton::GetIconSize( HICON hIcon, SIZE *psize )
{
    ICONINFO IconInfo;
    BITMAP   bmp;
    
    Assert( hIcon != NULL );

    if (GetIconInfo( hIcon, &IconInfo ))
    {
        GetObject( IconInfo.hbmColor, sizeof(bmp), &bmp );
        DeleteObject( IconInfo.hbmColor );
        DeleteObject( IconInfo.hbmMask );
        psize->cx = bmp.bmWidth;
        psize->cy = bmp.bmHeight;
    }
    else
    {
        psize->cx = GetSystemMetrics(SM_CXSMICON);
        psize->cy = GetSystemMetrics(SM_CYSMICON);
    }
}


/*   G E T  B I T M A P  S I Z E   */
/*------------------------------------------------------------------------------

    get bitmap size

------------------------------------------------------------------------------*/
void CUIFButton::GetBitmapSize( HBITMAP hBmp, SIZE *psize )
{
    BITMAP bmp;
    
    Assert( hBmp != NULL );

    GetObject( hBmp, sizeof(bmp), &bmp );
    psize->cx = bmp.bmWidth;
    psize->cy = bmp.bmHeight;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  B U T T O N  2                                                  */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  B U T T O N  2   */
/*------------------------------------------------------------------------------

    Constructor of CUIFButton2

------------------------------------------------------------------------------*/
CUIFButton2::CUIFButton2( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton( pParent, dwID, prc, dwStyle )
{
    SetActiveTheme(L"TOOLBAR", TP_BUTTON, 0);
}


/*   ~  C  U I F  B U T T O N  2   */
/*------------------------------------------------------------------------------

    Destructor of CUIFButton2

------------------------------------------------------------------------------*/
CUIFButton2::~CUIFButton2( void )
{
    CloseThemeData();
}




/*------------------------------------------------------------------------------

    MakeDrawFlag

------------------------------------------------------------------------------*/
DWORD CUIFButton2::MakeDrawFlag()
{
    DWORD   dwState = 0;
    // make draw flag

    dwState |= (m_fToggled) ? UIFDCS_SELECTED : 0;
    switch (m_dwStatus) {
        case UIBUTTON_DOWN: {
            dwState |= UIFDCS_MOUSEDOWN;
            break;
        }

        case UIBUTTON_HOVER:
        case UIBUTTON_DOWNOUT: {
            dwState |= UIFDCS_MOUSEOVER;
            break;
        }
    }
    dwState |= IsEnabled() ? 0 : UIFDCS_DISABLED;

    return dwState;
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
BOOL CUIFButton2::OnPaintTheme( HDC hDC )
{
    DWORD   dwState = 0;
    BOOL    fRet = FALSE;
    SIZE    sizeText  = {0};
    SIZE    sizeImage = {0};
    SIZE    sizeFace  = {0};
    SIZE    offset    = {0};
    RECT    rcText    = {0};
    RECT    rcImage   = {0};
    RECT    rcFace    = {0};
    RECT    rcContent = {0};
    HFONT   hFontOld = NULL;
    DWORD   dwTextFlag = 0;

    // make draw flag

    dwState = MakeDrawFlag();

    if (!CUIIsThemeActive()) {
        goto Exit;
    }

    if (FAILED(EnsureThemeData( GetUIWnd()->GetWnd())))
        goto Exit;

    hFontOld = (HFONT)SelectObject( hDC, GetFont() );

    int    iStateID;


    if (!IsEnabled()) {
        iStateID = TS_DISABLED;
    }
    else if (GetToggleState()) {
        iStateID = TS_CHECKED;
    }
    else if (m_dwStatus == UIBUTTON_DOWN) {
        iStateID = TS_PRESSED;
    }
    else if (m_dwStatus == UIBUTTON_HOVER) {
        iStateID = TS_HOT;
    }
    else {
        iStateID = TS_NORMAL;
    }

    // if (FAILED(GetThemeBackgroundContentRect(hDC, iStateID, &GetRectRef(), &rcContent )))
    //     goto Exit;
    rcContent = GetRectRef();

    // calc face size

    if (m_pwchText != NULL) {
        sizeText  = m_sizeText;
    }
    if (m_hIcon != NULL) { 
        sizeImage  = m_sizeIcon;
    }
    else if (m_hBmp != NULL ) {
        sizeImage  = m_sizeBmp;
    }

    // alignment

    if (!IsVertical())
    {
        sizeFace.cx = sizeText.cx + sizeImage.cx + ((sizeText.cx != 0 && sizeImage.cx != 0) ? 2 : 0);
        sizeFace.cy = max( sizeText.cy, sizeImage.cy );
    }
    else
    {
        sizeFace.cy = sizeText.cy + sizeImage.cy + ((sizeText.cy != 0 && sizeImage.cy != 0) ? 2 : 0);
        sizeFace.cx = max( sizeText.cx, sizeImage.cx );
    }

    switch (GetStyleBits( UIBUTTON_HALIGNMASK )) {
        case UIBUTTON_LEFT:
        default: {
            rcFace.left   = rcContent.left + 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            dwTextFlag = DT_LEFT;
            break;
        }

        case UIBUTTON_CENTER: {
            rcFace.left   = (rcContent.right + rcContent.left - sizeFace.cx) / 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            dwTextFlag = DT_CENTER;
            break;
        }

        case UIBUTTON_RIGHT: {
            rcFace.left   = rcContent.right - 2 - sizeText.cx;
            rcFace.right  = rcFace.left + sizeFace.cx;
            dwTextFlag = DT_RIGHT;
            break;
        }
    }

    switch (GetStyleBits( UIBUTTON_VALIGNMASK )) {
        case UIBUTTON_TOP:
        default: {
            rcFace.top    = rcContent.top + 2;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            dwTextFlag = DT_TOP;
            break;
        }

        case UIBUTTON_VCENTER: {
            rcFace.top     = (rcContent.bottom + rcContent.top - sizeFace.cy) / 2;
            rcFace.bottom  = rcFace.top + sizeFace.cy;
            dwTextFlag = DT_VCENTER;
            break;
        }

        case UIBUTTON_BOTTOM: {
            rcFace.top    = rcContent.bottom - 2 - sizeFace.cy;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            dwTextFlag = DT_BOTTOM;
            break;
        }
    }

    if (!IsVertical())
    {
        rcImage.left   = rcFace.left;
        rcImage.top    = (rcFace.bottom + rcFace.top - sizeImage.cy) / 2;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = rcFace.right - sizeText.cx;
        rcText.top     = (rcFace.bottom + rcFace.top - sizeText.cy) / 2;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }
    else
    {
        rcImage.left   = (rcFace.right + rcFace.left - sizeImage.cx) / 2;
        rcImage.top    = rcFace.top;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = (rcFace.right + rcFace.left - sizeText.cx) / 2;
        rcText.top     = rcFace.bottom - sizeText.cy;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }

    if (FAILED(DrawThemeBackground(hDC, iStateID, &GetRectRef(), 0 )))
        goto Exit;

    if (m_pwchText != NULL) 
    {
        int cwch = StrLenW(m_pwchText);
       
        //
        // DrawtThemeText() uses the font from theme so 
        // marlett font won't be used....
        // We need to draw the text when a font is set.
        //
        if (m_fUseCustomFont)
        {
            COLORREF col;
            int xText;
            int yText;

            if (FAILED(GetThemeColor(iStateID, TMT_TEXTCOLOR, &col)))
            {
                col = GetSysColor(COLOR_WINDOWTEXT);
            }

            COLORREF colTextOld = GetTextColor( hDC );
            int      iBkModeOld = SetBkMode( hDC, TRANSPARENT );

            xText = IsVertical() ? rcText.right : rcText.left;
            yText = rcText.top;

 
            //
            // we want to calc the marging correctly for theme. 
            // but somehow MSUTB's langbar is corrupted.
            //
            if (IsRTL())
                xText -= 2;

#if 0
            MARGINS marginsItem = {0};
            GetThemeMargins(NULL, iStateID, TMT_CONTENTMARGINS, 
                            NULL, &marginsItem);
            xText += marginsItem.cxLeftWidth;
            yText += marginsItem.cxRightWidth;
#endif

            SetTextColor( hDC, col);
            CUIExtTextOut( hDC,
                           xText,
                           yText,
                           ETO_CLIPPED,
                           &rcText,
                           m_pwchText,
                           cwch,
                           NULL );

            SetTextColor( hDC, colTextOld );
            SetBkMode( hDC, iBkModeOld );
        } 
        else 
        {
            if (FAILED(DrawThemeText(hDC, 
                                 iStateID, 
                                 m_pwchText, 
                                 cwch,
                                 dwTextFlag, 
                                 0, 
                                 &rcText)))
             goto Exit;
        } 
    }

    if (m_hIcon != NULL) 
    {
        if (FAILED(DrawThemeIcon(hDC, 
                                 iStateID, 
                                 &rcImage, 
                                 m_hIcon.GetImageList(IsRTL()), 
                                 m_hIcon.GetImageListId() )))
            goto Exit;

    }
    else if (m_hBmp != NULL) 
    {
        //
        // Draw Bitmap by ourselves.
        //
        DrawMaskBmpOnDC(hDC, &rcImage, m_hBmp, m_hBmpMask);

    }

    if (hFontOld)
        SelectObject( hDC, hFontOld );

    fRet = TRUE;

Exit:
    return fRet;
}

/*   O N  P A I N T D E F  */
/*------------------------------------------------------------------------------

    Paint procedure of button object

------------------------------------------------------------------------------*/
void CUIFButton2::OnPaintNoTheme( HDC hDC )
{
    DWORD   dwState = 0;
    HDC     hDCMem = NULL;
    HBITMAP hBmpMem = NULL;
    HBITMAP hBmpOld;
    SIZE    size;
    RECT    rc;
    SIZE    sizeText  = {0};
    SIZE    sizeImage = {0};
    SIZE    sizeFace  = {0};
    SIZE    offset    = {0};
    RECT    rcText    = {0};
    RECT    rcImage   = {0};
    RECT    rcFace    = {0};
    HFONT   hFontOld;

    if (!m_pUIFScheme)
        return;

    // make draw flag

    dwState = MakeDrawFlag();

    // prepare memory dc

    size.cx = GetRectRef().right - GetRectRef().left;
    size.cy = GetRectRef().bottom - GetRectRef().top;

    hDCMem = CreateCompatibleDC( hDC );
    if (!hDCMem)
        goto Exit;

    hBmpMem = CreateCompatibleBitmap( hDC, size.cx, size.cy );
    if (!hBmpMem)
        goto Exit;

    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

    ::SetRect( &rc, 0, 0, size.cx, size.cy );
    hFontOld = (HFONT)SelectObject( hDCMem, GetFont() );

    // calc face size

    if (m_pwchText != NULL) {
        sizeText  = m_sizeText;
    }
    if (m_hIcon != NULL) { 
        sizeImage  = m_sizeIcon;
    }
    else if (m_hBmp != NULL ) {
        sizeImage  = m_sizeBmp;
    }

    // alignment

    if (!IsVertical())
    {
        sizeFace.cx = sizeText.cx + sizeImage.cx + ((sizeText.cx != 0 && sizeImage.cx != 0) ? 2 : 0);
        sizeFace.cy = max( sizeText.cy, sizeImage.cy );
    }
    else
    {
        sizeFace.cy = sizeText.cy + sizeImage.cy + ((sizeText.cy != 0 && sizeImage.cy != 0) ? 2 : 0);
        sizeFace.cx = max( sizeText.cx, sizeImage.cx );
    }

    switch (GetStyleBits( UIBUTTON_HALIGNMASK )) {
        case UIBUTTON_LEFT:
        default: {
            rcFace.left   = rc.left + 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_CENTER: {
            rcFace.left   = (rc.right + rc.left - sizeFace.cx) / 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_RIGHT: {
            rcFace.left   = rc.right - 2 - sizeText.cx;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }
    }

    switch (GetStyleBits( UIBUTTON_VALIGNMASK )) {
        case UIBUTTON_TOP:
        default: {
            rcFace.top    = rc.top + 2;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_VCENTER: {
            rcFace.top     = (rc.bottom + rc.top - sizeFace.cy) / 2;
            rcFace.bottom  = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_BOTTOM: {
            rcFace.top    = rc.bottom - 2 - sizeFace.cy;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }
    }

    m_pUIFScheme->GetCtrlFaceOffset( GetDCF(), dwState, &offset );
    OffsetRect( &rcFace, offset.cx, offset.cy );

    if (!IsVertical())
    {
        rcImage.left   = rcFace.left;
        rcImage.top    = (rcFace.bottom + rcFace.top - sizeImage.cy) / 2;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = rcFace.right - sizeText.cx;
        rcText.top     = (rcFace.bottom + rcFace.top - sizeText.cy) / 2;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }
    else
    {
        rcImage.left   = (rcFace.right + rcFace.left - sizeImage.cx) / 2;
        rcImage.top    = rcFace.top;
        rcImage.right  = rcImage.left + sizeImage.cx;
        rcImage.bottom = rcImage.top  + sizeImage.cy;

        rcText.left    = (rcFace.right + rcFace.left - sizeText.cx) / 2;
        rcText.top     = rcFace.bottom - sizeText.cy;
        rcText.right   = rcText.left + sizeText.cx;
        rcText.bottom  = rcText.top  + sizeText.cy;
    }

    if (IsRTL())
        m_pUIFScheme->SetLayout(LAYOUT_RTL);

    // paint background

    m_pUIFScheme->DrawCtrlBkgd( hDCMem, &rc, GetDCF(), dwState );

    // paint face

    if (m_pwchText != NULL) {
        m_pUIFScheme->DrawCtrlText( hDCMem, &rcText, m_pwchText, -1, dwState , IsVertical());
    }

    if (m_hIcon!= NULL) {
        m_pUIFScheme->DrawCtrlIcon( hDCMem, &rcImage, m_hIcon, dwState, &m_sizeIcon );
    }
    else if (m_hBmp != NULL) {
        m_pUIFScheme->DrawCtrlBitmap( hDCMem, &rcImage, m_hBmp, m_hBmpMask, dwState );
    }

    if (IsRTL())
        m_pUIFScheme->SetLayout(0);

    // draw button edge

    m_pUIFScheme->DrawCtrlEdge( hDCMem, &rc, GetDCF(), dwState );

    //

    BitBlt( hDC, GetRectRef().left, GetRectRef().top, size.cx, size.cy, hDCMem, 0, 0, SRCCOPY );

    SelectObject( hDCMem, hFontOld );
    SelectObject( hDCMem, hBmpOld );

Exit:
    if (hBmpMem)
       DeleteObject( hBmpMem );
    if (hDCMem)
       DeleteDC( hDCMem );

}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S C R O L L                                                     */
/*                                                                             */
/*=============================================================================*/

//
// CUIFScrollButton
//

/*   C  U I F  S C R O L L  B U T T O N   */
/*------------------------------------------------------------------------------

    Constructor of CUIFScrollButton

------------------------------------------------------------------------------*/
CUIFScrollButton::CUIFScrollButton( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle ) : CUIFButton( pUIScroll, 0, prc, dwStyle )
{
}


/*   ~  C  U I F  S C R O L L  B U T T O N   */
/*------------------------------------------------------------------------------

    Destructor of CUIFScrollButton

------------------------------------------------------------------------------*/
CUIFScrollButton::~CUIFScrollButton( void )
{
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnLButtonDown( POINT pt )
{
    CUIFButton::OnLButtonDown( pt );

    // scroll one item

    NotifyCommand( UISCROLLBUTTON_PRESSED, 0 );

    // create time to auto-repeat

    StartTimer( GetScrollDelay() );
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnLButtonUp( POINT pt )
{
    CUIFButton::OnLButtonUp( pt );

    // stop auto-repeat

    if (IsTimer()) {
        EndTimer();
    }
}

/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnMouseIn( POINT pt )
{
    CUIFButton::OnMouseIn( pt );

    if (IsCapture()) {
        // scroll one item when mouse is in

        NotifyCommand( UISCROLLBUTTON_PRESSED, 0 );

        // create timer to auto-repeat again

        StartTimer( GetScrollSpeed() );
    }
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnMouseOut( POINT pt )
{
    CUIFButton::OnMouseOut( pt );

    // kill timer to prevent from auto-repeat

    if (IsTimer()) {
        EndTimer();
    }
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll button object

------------------------------------------------------------------------------*/
void CUIFScrollButton::OnPaint( HDC hDC )
{
    RECT rc = GetRectRef();
    UINT uState = 0;

    switch (m_dwStyle & UISCROLLBUTTON_DIRMASK) {
        case UISCROLLBUTTON_LEFT: {
            uState = DFCS_SCROLLLEFT;
            break;
        }

        case UISCROLLBUTTON_UP: {
            uState = DFCS_SCROLLUP;
            break;
        }

        case UISCROLLBUTTON_RIGHT: {
            uState = DFCS_SCROLLRIGHT;
            break;
        }

        case UISCROLLBUTTON_DOWN: {
            uState = DFCS_SCROLLDOWN;
            break;
        }
    }

    uState |= ((m_dwStatus == UIBUTTON_DOWN) ? DFCS_PUSHED | DFCS_FLAT : 0);
    uState |= ((!IsEnabled()) ? DFCS_INACTIVE : 0);

    DrawFrameControl( hDC, &rc, DFC_SCROLL, uState );
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollButton::OnTimer( void )
{
    POINT pt;

    StartTimer( GetScrollSpeed() );

    GetCursorPos( &pt );
    ScreenToClient( m_pUIWnd->GetWnd(), &pt );

    if (PtInObject( pt )) {
        NotifyCommand( UISCROLLBUTTON_PRESSED, 0 );
    }
}


//
// CUIFScrollThumb
//

/*   C  U I F  S C R O L L  T H U M B   */
/*------------------------------------------------------------------------------

    Constructor of CUIFScrollThumb 

------------------------------------------------------------------------------*/
CUIFScrollThumb::CUIFScrollThumb( CUIFScroll *pUIScroll, const RECT *prc, DWORD dwStyle ) : CUIFObject( pUIScroll, 0 /* no id */, prc, dwStyle )
{
}


/*   ~  C  U I F  S C R O L L  T H U M B   */
/*------------------------------------------------------------------------------

    Destructor of CUIFScrollThumb 

------------------------------------------------------------------------------*/
CUIFScrollThumb::~CUIFScrollThumb( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll thumb object

------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnPaint(HDC hDC)
{
    RECT rc = GetRectRef();

    if (!IsEnabled()) {
        return;
    }

    FillRect( hDC, &rc, (HBRUSH)(COLOR_3DFACE + 1) );
    DrawEdge( hDC, &rc, EDGE_RAISED, BF_RECT );
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnLButtonDown( POINT pt )
{
    if (IsEnabled()) {
        StartCapture();

        m_ptDragOrg = pt;
        m_ptDrag.x = pt.x - GetRectRef().left;
        m_ptDrag.y = pt.y - GetRectRef().top;
    }
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
        DragProc( pt, TRUE /* end of dragging */ );
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScrollThumb::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        DragProc( pt, FALSE /* still dragging */ );
    }
}


/*   S E T  S C R O L L  A R E A   */
/*------------------------------------------------------------------------------

    Set scroll area

------------------------------------------------------------------------------*/
void CUIFScrollThumb::SetScrollArea( RECT *prc )
{
    m_rcScrollArea = *prc;
}


/*   D R A G  P R O C   */
/*------------------------------------------------------------------------------

    Handle mouse message while dragging
    Move the thumb and notify to the parent object (Scroll).

------------------------------------------------------------------------------*/
void CUIFScrollThumb::DragProc( POINT pt, BOOL fEndDrag )
{
    RECT rcValid;

    // get valid drag area (TEMP code)

    m_pParent->GetRect( &rcValid );
    InflateRect( &rcValid, 64, 64 );

    // check if drag point is valid

    if (!PtInRect( &rcValid, pt )) {
        RECT rc;

        // back to original position
    
        rc.left   = m_ptDragOrg.x - m_ptDrag.x;
        rc.top    = m_ptDragOrg.y - m_ptDrag.y;
        rc.right  = rc.left + (GetRectRef().right - GetRectRef().left);
        rc.bottom = rc.top  + (GetRectRef().bottom - GetRectRef().top);

        // move myself and notify to parent
    
        SetRect( &rc );
        NotifyCommand( UISCROLLTHUMB_MOVED, 0 );
    }
    else {
        RECT rc;

        // calc new thumb position
    
        rc.left   = pt.x - m_ptDrag.x;
        rc.top    = pt.y - m_ptDrag.y;
        rc.right  = rc.left + (GetRectRef().right - GetRectRef().left);
        rc.bottom = rc.top  + (GetRectRef().bottom - GetRectRef().top);
    
        // adjust thumb position
    
        if (rc.top < m_rcScrollArea.top) {
            rc.bottom += (m_rcScrollArea.top - rc.top);
            rc.top    += (m_rcScrollArea.top - rc.top);
        }
        else if (m_rcScrollArea.bottom < rc.bottom) {
            rc.top    += (m_rcScrollArea.bottom - rc.bottom);
            rc.bottom += (m_rcScrollArea.bottom - rc.bottom);
        }
    
        if (rc.left < m_rcScrollArea.left) {
            rc.right  += (m_rcScrollArea.left - rc.left);
            rc.left   += (m_rcScrollArea.left - rc.left);
        }
        else if (m_rcScrollArea.right < rc.right) {
            rc.left   += (m_rcScrollArea.right - rc.right);
            rc.right  += (m_rcScrollArea.right - rc.right);
        }
    
        // move myself and notify to parent
    
        SetRect( &rc );
        NotifyCommand( fEndDrag ? UISCROLLTHUMB_MOVED : UISCROLLTHUMB_MOVING, 0 );
    }
}


//
// CUIFScroll
//

/*   C  U I F  S C R O L L   */
/*------------------------------------------------------------------------------

    Constructor of CUIFScroll

------------------------------------------------------------------------------*/
CUIFScroll::CUIFScroll( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_ScrollInfo.nMax  = 0;
    m_ScrollInfo.nPage = 0;
    m_ScrollInfo.nPos  = 0;
    m_fScrollPage = FALSE;
    m_dwScrollDir = UISCROLL_NONE;

    // get metrics

    GetMetrics();
}


/*   ~  C  U I F  S C R O L L   */
/*------------------------------------------------------------------------------

    Destructor of CUIFScroll

------------------------------------------------------------------------------*/
CUIFScroll::~CUIFScroll( void )
{
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Intialize scroll object

------------------------------------------------------------------------------*/
CUIFObject *CUIFScroll::Initialize( void )
{
    RECT rc;

    // create child objects

    GetBtnUpRect( &rc );
    m_pBtnUp = new CUIFScrollButton( this, &rc, GetScrollUpBtnStyle() );
    if (m_pBtnUp)
    {
        m_pBtnUp->Initialize();
        AddUIObj( m_pBtnUp );
    }

    GetBtnDnRect( &rc );
    m_pBtnDn = new CUIFScrollButton( this, &rc, GetScrollDnBtnStyle() );
    if (m_pBtnDn)
    {
        m_pBtnDn->Initialize();
        AddUIObj( m_pBtnDn );
    }

    GetThumbRect( &rc );
    m_pThumb = new CUIFScrollThumb( this, &rc, GetScrollThumbStyle() );
    if (m_pThumb)
    {
       m_pThumb->Initialize();
       AddUIObj( m_pThumb );
       //

       GetScrollArea( &rc );
       m_pThumb->SetScrollArea( &rc );
    }


    //
    
    return CUIFObject::Initialize();
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of scroll object

------------------------------------------------------------------------------*/
void CUIFScroll::OnPaint( HDC hDC )
{
    HBRUSH hBrush;

    // paint scroll bar back

    hBrush = (HBRUSH)DefWindowProc( m_pUIWnd->GetWnd(), WM_CTLCOLORSCROLLBAR, (WPARAM)hDC, (LPARAM)m_pUIWnd->GetWnd() );
    if (hBrush == NULL) {
        // never happen?  just in case...
        hBrush = GetSysColorBrush(COLOR_SCROLLBAR);
    }

    FillRect( hDC, &GetRectRef(), hBrush );
    DeleteObject( hBrush );

    // paint scroll area

    if (m_fScrollPage) {
        RECT rc;

        switch (m_dwScrollDir) {
            case UISCROLL_PAGEUP: {
                GetPageUpArea( &rc );
                break;
            }

            case UISCROLL_PAGEDOWN: {
                GetPageDnArea( &rc );
                break;
            }
        }
        InvertRect( hDC, &rc );
    }
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnLButtonDown( POINT pt )
{
    if (!m_pThumb->IsVisible()) {
        return;
    }

    StartCapture();
    if (PtInPageUpArea( pt )) {
        StartTimer( GetScrollDelay() );
        m_fScrollPage = TRUE;
        m_dwScrollDir = UISCROLL_PAGEUP;

        ShiftPage( -1 );
    }
    else if (PtInPageDnArea( pt )) {
        StartTimer( GetScrollDelay() );
        m_fScrollPage = TRUE;
        m_dwScrollDir = UISCROLL_PAGEDOWN;

        ShiftPage( +1 );
    }
    else {
        Assert( FALSE );
    }

    CallOnPaint();
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
    }

    if (IsTimer()) {
        EndTimer();
    }

    m_fScrollPage = FALSE;
    m_dwScrollDir = UISCROLL_NONE;
    CallOnPaint();
}


/*   O N  M O U S E  I N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnMouseIn( POINT pt )
{
    if (IsCapture()) {
        switch (m_dwScrollDir) {
            case UISCROLL_PAGEUP: {
                if (PtInPageUpArea( pt )) {
                    StartTimer( GetScrollSpeed() );
                    m_fScrollPage = TRUE;

                    ShiftPage( -1 );
                    CallOnPaint();
                }
                break;
            }

            case UISCROLL_PAGEDOWN: {
                if (PtInPageDnArea( pt )) {
                    StartTimer( GetScrollSpeed() );
                    m_fScrollPage = TRUE;

                    ShiftPage( +1 );
                    CallOnPaint();
                }
                break;
            }
        }
    }
}


/*   O N  M O U S E  O U T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnMouseOut( POINT pt )
{
    m_fScrollPage = FALSE;
    if (IsTimer()) {
        EndTimer();
    }

    CallOnPaint();
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::SetRect( const RECT *prc )
{
    RECT rc;
    BOOL fThumbVisible;

    CUIFObject::SetRect( prc );

    // adjist child object poisition

    GetBtnUpRect( &rc );
    m_pBtnUp->SetRect( &rc );

    GetBtnDnRect( &rc );
    m_pBtnDn->SetRect( &rc );

    GetScrollArea( &rc );
    m_pThumb->SetScrollArea( &rc );

    fThumbVisible = GetThumbRect( &rc );
    m_pThumb->SetRect( &rc );
    m_pThumb->Show( IsVisible() && fThumbVisible );
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::SetStyle( DWORD dwStyle )
{
    RECT rc;
    BOOL fThumbVisible;

    CUIFObject::SetStyle( dwStyle );

    //

    GetMetrics();

    // update child object style

    m_pBtnUp->SetStyle( GetScrollUpBtnStyle() );
    m_pBtnDn->SetStyle( GetScrollDnBtnStyle() );
    m_pThumb->SetStyle( GetScrollThumbStyle() );

    // update child object poisition

    GetBtnUpRect( &rc );
    m_pBtnUp->SetRect( &rc );

    GetBtnDnRect( &rc );
    m_pBtnDn->SetRect( &rc );

    GetScrollArea( &rc );
    m_pThumb->SetScrollArea( &rc );

    fThumbVisible = GetThumbRect( &rc );
    m_pThumb->SetRect( &rc );
    m_pThumb->Show( IsVisible() && fThumbVisible );
}


/*   S H O W   */
/*------------------------------------------------------------------------------

    show/hide scroll bar

------------------------------------------------------------------------------*/
void CUIFScroll::Show( BOOL fShow )
{
    if (m_fVisible != fShow) {
        RECT rcThumb;
        BOOL fThumbVisible;

        m_fVisible = fShow;
        fThumbVisible = GetThumbRect( &rcThumb );

        m_pBtnUp->Show( fShow );
        m_pBtnDn->Show( fShow );
        m_pThumb->Show( fShow && fThumbVisible );

        // let parent paint the object when it's hidden

        if (!m_fVisible) {
            if (m_pParent != NULL) {
               m_pParent->CallOnPaint();
            }
        }
        else {
            CallOnPaint();
        }
    }
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::OnTimer( void )
{
    POINT pt;

    StartTimer( GetScrollSpeed() );

    GetCursorPos( &pt );
    ScreenToClient( m_pUIWnd->GetWnd(), &pt );

    switch (m_dwScrollDir) {
        case UISCROLL_PAGEUP: {
            if (PtInPageUpArea( pt )) {
                ShiftPage( -1 );
            }
            break;
        }

        case UISCROLL_PAGEDOWN: {
            if (PtInPageDnArea( pt )) {
                ShiftPage( +1 );
            }
            break;
        }
    }
}


/*   S E T  S C R O L L  I N F O   */
/*------------------------------------------------------------------------------

    Set scrollbar info

------------------------------------------------------------------------------*/
void CUIFScroll::SetScrollInfo( UIFSCROLLINFO *pScrollInfo )
{
    BOOL fEnable;

    Assert( pScrollInfo != NULL );

    m_ScrollInfo.nMax  = pScrollInfo->nMax;
    m_ScrollInfo.nPage = pScrollInfo->nPage;

    // disable when cannot scroll

    fEnable = (m_ScrollInfo.nMax > m_ScrollInfo.nPage);

    Enable( fEnable );
    m_pBtnUp->Enable( fEnable );
    m_pBtnDn->Enable( fEnable );
    m_pThumb->Enable( fEnable );

    // clear scrolling page info

    m_fScrollPage = FALSE;
    m_dwScrollDir = UISCROLL_NONE;

    //

    SetCurPos( pScrollInfo->nPos, TRUE /* adjust thumb position */ );
}


/*   G E T  S C R O L L  I N F O   */
/*------------------------------------------------------------------------------

    Get scrollbar info

------------------------------------------------------------------------------*/
void CUIFScroll::GetScrollInfo( UIFSCROLLINFO *pScrollInfo )
{
    Assert( pScrollInfo != NULL );

    *pScrollInfo = m_ScrollInfo;
}


/*   G E T  T H U M B  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFScroll::GetThumbRect( RECT *prc )
{
    RECT rcScroll;
    BOOL fVisible;

    // return FALSE when thumb is invisible

    if (m_ScrollInfo.nMax <= 0 || 
        m_ScrollInfo.nPage <= 0 || 
        m_ScrollInfo.nMax <= m_ScrollInfo.nPage) {
        ::SetRect( prc, 0, 0, 0, 0 );
        return FALSE;
    }

    // calc thumb rect from current position

    GetScrollArea( &rcScroll );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            int nThumbHeight = (rcScroll.bottom - rcScroll.top) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbHeight = max( SCROLLTHUMBHEIGHT_MIN, nThumbHeight );

            fVisible = (nThumbHeight <= (rcScroll.bottom - rcScroll.top));

            prc->left   = GetRectRef().left;
            prc->top    = rcScroll.top + (rcScroll.bottom - rcScroll.top - nThumbHeight) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage);
            prc->right  = GetRectRef().right;
            prc->bottom = prc->top + nThumbHeight;
            break;
        }

        case UISCROLL_VERTBT: {
            int nThumbHeight = (rcScroll.bottom - rcScroll.top) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbHeight = max( SCROLLTHUMBHEIGHT_MIN, nThumbHeight );

            fVisible = (nThumbHeight <= (rcScroll.bottom - rcScroll.top));

            prc->left   = GetRectRef().left;
            prc->top    = rcScroll.bottom - (rcScroll.bottom - rcScroll.top - nThumbHeight) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage) - nThumbHeight;
            prc->right  = GetRectRef().right;
            prc->bottom = prc->top + nThumbHeight;
            break;
        }

        case UISCROLL_HORZLR: {
            int nThumbWidth = (rcScroll.right - rcScroll.left) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbWidth = max( SCROLLTHUMBHEIGHT_MIN, nThumbWidth );

            fVisible = (nThumbWidth <= (rcScroll.right - rcScroll.left));

            prc->left   = rcScroll.left + (rcScroll.right - rcScroll.left - nThumbWidth) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage);
            prc->top    = GetRectRef().top;
            prc->right  = prc->left + nThumbWidth;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            int nThumbWidth = (rcScroll.right - rcScroll.left) * m_ScrollInfo.nPage / m_ScrollInfo.nMax;
            nThumbWidth = max( SCROLLTHUMBHEIGHT_MIN, nThumbWidth );

            fVisible = (nThumbWidth <= (rcScroll.right - rcScroll.left));

            prc->left   = rcScroll.right - (rcScroll.right - rcScroll.left - nThumbWidth) * m_ScrollInfo.nPos / (m_ScrollInfo.nMax - m_ScrollInfo.nPage) - nThumbWidth;
            prc->top    = GetRectRef().top;
            prc->right  = prc->left + nThumbWidth;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    return fVisible;
}


/*   G E T  B T N  U P  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFScroll::GetBtnUpRect( RECT *prc )
{
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().top + min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().left + min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().right - min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    return TRUE;
}


/*   G E T  B T N  D N  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFScroll::GetBtnDnRect( RECT *prc )
{
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().top + min( m_sizeScrollBtn.cy, (GetRectRef().bottom - GetRectRef().top)/2 );
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().right - min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().left + min( m_sizeScrollBtn.cx, (GetRectRef().right - GetRectRef().left)/2 );
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    return TRUE;
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFScroll::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
    if (pUIObj == m_pBtnUp) {
        switch (dwCommand) {
            case UISCROLLBUTTON_PRESSED: {
                if (NotifyCommand( UISCROLLNOTIFY_SCROLLLN, -1 ) == 0) {
                    ShiftLine( -1 );
                }
                break;
            }
        }
    }
    else if (pUIObj == m_pBtnDn) {
        switch (dwCommand) {
            case UISCROLLBUTTON_PRESSED: {
                if (NotifyCommand( UISCROLLNOTIFY_SCROLLLN, +1 ) == 0) {
                    ShiftLine( +1 );
                }
                break;
            }
        }
    }
    else if (pUIObj == m_pThumb) {
        switch (dwCommand) {
            case UISCROLLTHUMB_MOVING: 
            case UISCROLLTHUMB_MOVED: {
                RECT rcThumb;
                RECT rcScroll;
                int nPos;
                int nPosMax;
                int ptThumb;
                int ptMax;

                m_pThumb->GetRect( &rcThumb );
                GetScrollArea( &rcScroll );

                nPosMax = m_ScrollInfo.nMax - m_ScrollInfo.nPage;
            
                switch (m_dwStyle & UISCROLL_DIRMASK) {
                    default:
                    case UISCROLL_VERTTB: {
                        ptThumb = rcThumb.top - rcScroll.top;
                        ptMax   = (rcScroll.bottom - rcScroll.top) - (rcThumb.bottom - rcThumb.top);
                        break;
                    }
            
                    case UISCROLL_VERTBT: {
                        ptThumb = rcScroll.bottom - rcThumb.bottom;
                        ptMax   = (rcScroll.bottom - rcScroll.top) - (rcThumb.bottom - rcThumb.top);
                        break;
                    }
            
                    case UISCROLL_HORZLR: {
                        ptThumb = rcThumb.left - rcScroll.left;
                        ptMax   = (rcScroll.right - rcScroll.left) - (rcThumb.right - rcThumb.left);
                        break;
                    }
            
                    case UISCROLL_HORZRL: {
                        ptThumb = rcScroll.right - rcThumb.right;
                        ptMax   = (rcScroll.right - rcScroll.left) - (rcThumb.right - rcThumb.left);
                        break;
                    }
                }

                Assert( (0 <= ptThumb) && (ptThumb <= ptMax) );
                if (ptMax == 0) {
                    nPos = 0;
                }
                else {
                    nPos = (ptThumb * nPosMax + ptMax/2) / ptMax;
                    nPos = max( nPos, 0 );
                    nPos = min( nPos, nPosMax );
                }

                SetCurPos( nPos, (dwCommand == UISCROLLTHUMB_MOVED) /* adjust thumb position */ );
                break;
            }
        } /* of switch */
    }

    return 0;
}


/*   S E T  C U R  P O S   */
/*------------------------------------------------------------------------------

    Set current page position

------------------------------------------------------------------------------*/
void CUIFScroll::SetCurPos( int nPos, BOOL fAdjustThumbPos )
{
    int nPosMax = (m_ScrollInfo.nMax <= m_ScrollInfo.nPage) ? 0 : m_ScrollInfo.nMax - m_ScrollInfo.nPage;

    // set position

    nPosMax = m_ScrollInfo.nMax - m_ScrollInfo.nPage;
    nPos = min( nPos, nPosMax );
    nPos = max( nPos, 0 );

    m_ScrollInfo.nPos = nPos;

    // set thumb position

    if (fAdjustThumbPos) {
        RECT rcThumb;
        BOOL fThumbVisible;

        fThumbVisible = GetThumbRect( &rcThumb );
        m_pThumb->SetRect( &rcThumb );
        m_pThumb->Show( IsVisible() && fThumbVisible );
    }

    if (IsVisible()) {
        CallOnPaint();
    }

    // notify scroll to parent

    NotifyCommand( UISCROLLNOTIFY_SCROLLED, m_ScrollInfo.nPos );
}


/*   G E T  S C R O L L  A R E A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetScrollArea( RECT *prc )
{
    RECT rcBtnUp;
    RECT rcBtnDn;

    Assert( prc != NULL );

    GetBtnUpRect( &rcBtnUp );
    GetBtnDnRect( &rcBtnDn );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top    + (rcBtnUp.bottom - rcBtnUp.top);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnDn.bottom - rcBtnDn.top);
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top    + (rcBtnDn.bottom - rcBtnDn.top);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnUp.bottom - rcBtnUp.top);
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().left   + (rcBtnUp.bottom - rcBtnUp.top);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right  - (rcBtnDn.bottom - rcBtnDn.top);
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().left   + (rcBtnDn.bottom - rcBtnDn.top);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right  - (rcBtnUp.bottom - rcBtnUp.top);
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }
}


/*   G E T  P A G E  U P  A R E A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetPageUpArea( RECT *prc )
{
    RECT rcThumb;
    RECT rcBtnUp;

    Assert( prc != NULL );

    m_pThumb->GetRect( &rcThumb );
    GetBtnUpRect( &rcBtnUp );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top    + (rcBtnUp.bottom - rcBtnUp.top);
            prc->right  = GetRectRef().right;
            prc->bottom = rcThumb.top;
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = rcThumb.bottom;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnUp.bottom - rcBtnUp.top);
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = GetRectRef().left   + (rcBtnUp.bottom - rcBtnUp.top);
            prc->top    = GetRectRef().top;;
            prc->right  = rcThumb.left;
            prc->bottom = GetRectRef().bottom;;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = rcThumb.right;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right  - (rcBtnUp.bottom - rcBtnUp.top);
            prc->bottom = GetRectRef().bottom;;
            break;
        }
    }
}


/*   G E T  P A G E  D N  A R E A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetPageDnArea( RECT *prc )
{
    RECT rcThumb;
    RECT rcBtnDn;

    Assert( prc != NULL );

    m_pThumb->GetRect( &rcThumb );
    GetBtnDnRect( &rcBtnDn );
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            prc->left   = GetRectRef().left;
            prc->top    = rcThumb.bottom;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - (rcBtnDn.bottom - rcBtnDn.top);
            break;
        }

        case UISCROLL_VERTBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top + (rcBtnDn.bottom - rcBtnDn.top);
            prc->right  = GetRectRef().right;
            prc->bottom = rcThumb.top;
            break;
        }

        case UISCROLL_HORZLR: {
            prc->left   = rcThumb.right;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right - (rcBtnDn.bottom - rcBtnDn.top);
            prc->bottom = GetRectRef().bottom;;
            break;
        }

        case UISCROLL_HORZRL: {
            prc->left   = GetRectRef().left + (rcBtnDn.bottom - rcBtnDn.top) ;
            prc->top    = GetRectRef().top;
            prc->right  = rcThumb.left;
            prc->bottom = GetRectRef().bottom;;
            break;
        }
    }
}


/*   G E T  S C R O L L  T H U M B  S T Y L E   */
/*------------------------------------------------------------------------------

    Get style of scroll thumb

------------------------------------------------------------------------------*/
DWORD CUIFScroll::GetScrollThumbStyle( void )
{
    return 0;
}


/*   G E T  S C R O L L  U P  B T N  S T Y L E   */
/*------------------------------------------------------------------------------

    Get style of scroll up button 

------------------------------------------------------------------------------*/
DWORD CUIFScroll::GetScrollUpBtnStyle( void )
{
    DWORD dwStyle = 0;

    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            dwStyle = UISCROLLBUTTON_UP;
            break;
        }

        case UISCROLL_VERTBT: {
            dwStyle = UISCROLLBUTTON_DOWN;
            break;
        }

        case UISCROLL_HORZLR: {
            dwStyle = UISCROLLBUTTON_LEFT;
            break;
        }

        case UISCROLL_HORZRL: {
            dwStyle = UISCROLLBUTTON_RIGHT;
            break;
        }
    }

    return dwStyle;
}


/*   G E T  S C R O L L  D N  B T N  S T Y L E   */
/*------------------------------------------------------------------------------

    Get style of scroll down button

------------------------------------------------------------------------------*/
DWORD CUIFScroll::GetScrollDnBtnStyle( void )
{
    DWORD dwStyle = 0;

    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB: {
            dwStyle = UISCROLLBUTTON_DOWN;
            break;
        }

        case UISCROLL_VERTBT: {
            dwStyle = UISCROLLBUTTON_UP;
            break;
        }

        case UISCROLL_HORZLR: {
            dwStyle = UISCROLLBUTTON_RIGHT;
            break;
        }

        case UISCROLL_HORZRL: {
            dwStyle = UISCROLLBUTTON_LEFT;
            break;
        }
    }

    return dwStyle;
}


/*   G E T  M E T R I C S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFScroll::GetMetrics( void )
{
    switch (m_dwStyle & UISCROLL_DIRMASK) {
        default:
        case UISCROLL_VERTTB:
        case UISCROLL_VERTBT: {
            m_sizeScrollBtn.cx = GetSystemMetrics( SM_CXVSCROLL );
            m_sizeScrollBtn.cy = GetSystemMetrics( SM_CYVSCROLL );
            break;
        }

        case UISCROLL_HORZLR:
        case UISCROLL_HORZRL: {
            m_sizeScrollBtn.cx = GetSystemMetrics( SM_CXHSCROLL );
            m_sizeScrollBtn.cy = GetSystemMetrics( SM_CYHSCROLL );
            break;
        }
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  L I S T  B A S E                                                */
/*                                                                             */
/*=============================================================================*/

//
// CUIFListBase
//

/*   C  U I F  L I S T  B A S E   */
/*------------------------------------------------------------------------------

    Constructor of CUIFListBase

------------------------------------------------------------------------------*/
CUIFListBase::CUIFListBase( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, dwID, prc, dwStyle )
{
    m_nItem        = 0;
    m_nLineHeight  = GetFontHeight();
    m_nItemVisible = 0;
    m_iItemTop     = 0;
    m_iItemSelect  = 0;
}


/*   ~  C  U I F  L I S T  B A S E   */
/*------------------------------------------------------------------------------

    Destructor of CUIFListBase

------------------------------------------------------------------------------*/
CUIFListBase::~CUIFListBase( void )
{
    CListItemBase *pItem;

    while ((pItem = m_listItem.GetFirst()) != NULL) {
        m_listItem.Remove(pItem);
        delete pItem;
        m_nItem--;
    }

    Assert( m_nItem == 0 );
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize list object

------------------------------------------------------------------------------*/
CUIFObject *CUIFListBase::Initialize( void )
{
    RECT rcScroll;

    // create scrollbar

    GetScrollBarRect( &rcScroll );
    m_pUIScroll = CreateScrollBarObj( this, 0, &rcScroll, GetScrollBarStyle() );
    m_pUIScroll->Initialize();
    AddUIObj( m_pUIScroll );

    // calc visible item count

    CalcVisibleCount();

    // initialize scrollbar

    UpdateScrollBar();

    //

    return CUIFObject::Initialize();
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of list object

------------------------------------------------------------------------------*/
void CUIFListBase::OnPaint( HDC hDC )
{
    int iLine;
    HFONT hFontOld = (HFONT)SelectObject( hDC, m_hFont );

    for (iLine = 0; iLine < m_nItemVisible + 1; iLine++) {
        CListItemBase *pItem;
        int iItem = m_iItemTop + iLine;
        RECT rc;

        pItem = GetItem( iItem );
        if (pItem != NULL) {
            GetLineRect( iLine, &rc );
            if (!IsRectEmpty( &rc )) {
                PaintItemProc( hDC, &rc, pItem, (iItem == m_iItemSelect) );
            }
        }
    }

    SelectObject( hDC, hFontOld );
}


/*   O N  L B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnLButtonDown( POINT pt )
{
    int iItemSelNew = ListItemFromPoint( pt );

    if (iItemSelNew != -1) {
        SetSelection( iItemSelNew, TRUE );
    }

    StartCapture();
    StartTimer( 100 );      // TEMP
}


/*   O N  L B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnLButtonUp( POINT pt )
{
    BOOL fSelected = FALSE;

    if (IsCapture()) {
        int iItemSelNew = ListItemFromPoint( pt );

        if (iItemSelNew != -1) {
            SetSelection( iItemSelNew, TRUE );
        }
        EndCapture();

        fSelected = (PtInObject( pt ) && iItemSelNew != -1);
    }

    if (IsTimer()) {
        EndTimer();
    }

    // notify

    if (fSelected) {
        NotifyCommand( UILIST_SELECTED, m_iItemSelect );
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        int iItemSelNew = ListItemFromPoint( pt );

        if (iItemSelNew != -1) {
            SetSelection( iItemSelNew, TRUE );
        }
    }
}


/*   O N  T I M E R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::OnTimer( void )
{
    POINT pt;

    if (!IsCapture()) {
        return;
    }

    GetCursorPos( &pt );
    ScreenToClient( m_pUIWnd->GetWnd(), &pt );

    if (!PtInObject( pt )) {
        switch (m_dwStyle & UILIST_DIRMASK) {
            default:
            case UILIST_HORZTB: {
                if (pt.y < GetRectRef().top) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                else if (GetRectRef().bottom <= pt.y) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                break;
            }

            case UILIST_HORZBT: {
                if (pt.y < GetRectRef().top) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                else if (GetRectRef().bottom <= pt.y) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                break;
            }

            case UILIST_VERTLR: {
                if (GetRectRef().right <= pt.x) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                else if (pt.x < GetRectRef().left) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                break;
            }

            case UILIST_VERTRL: {
                if (GetRectRef().right <= pt.x) {
                    // scroll up

                    SetSelection( m_iItemSelect - 1, TRUE );
                }
                else if (pt.x < GetRectRef().left) {
                    // scroll down

                    SetSelection( m_iItemSelect + 1, TRUE );
                }
                break;
            }
        }
    }
}


/*   S E T  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetRect( const RECT *prc )
{
    RECT rcScroll;

    CUIFObject::SetRect( prc );

    // set scrollbar position

    GetScrollBarRect( &rcScroll );
    m_pUIScroll->SetRect( &rcScroll );

    // calc visible item count

    CalcVisibleCount();

    // update scrollbar

    UpdateScrollBar();
}


/*   S E T  S T Y L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetStyle( DWORD dwStyle )
{
    RECT rcScroll;

    CUIFObject::SetStyle( dwStyle );

    // change scroll bar style either

    m_pUIScroll->SetStyle( GetScrollBarStyle() );

    // set scrollbar position

    GetScrollBarRect( &rcScroll );
    m_pUIScroll->SetRect( &rcScroll );

    // calc visible item count

    CalcVisibleCount();

    // update scrollbar

    UpdateScrollBar();
}


/*   O N  O B J E C T  N O T I F Y   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFListBase::OnObjectNotify( CUIFObject *pUIObj, DWORD dwCommand, LPARAM lParam )
{
    LRESULT lResult = 0;
    
    if (pUIObj == m_pUIScroll) {
        switch (dwCommand) {
            case UISCROLLNOTIFY_SCROLLED: {
                int nCur = (int)lParam;
                int iItemTop;

                if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
                    // fixed height

                    iItemTop = nCur;
                }
                else {
                    int nItemPos = 0;
                    int nItemHeight;

                    // variable height

                    for (iItemTop = 0; iItemTop < m_nItem; iItemTop++) {
                        nItemHeight = GetItemHeight( iItemTop );

                        if (nCur < nItemPos + nItemHeight/2) {
                            break;
                        }
                        nItemPos += nItemHeight;
                    }

                }

                SetTop( iItemTop, FALSE );
                break;
            }

            case UISCROLLNOTIFY_SCROLLLN: {
                SetTop((int)(GetTop() + lParam), TRUE );

                lResult = 1; /* processed */
                break;
            }
        }
    }

    return lResult;
}


/*   A D D  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::AddItem( CListItemBase *pItem )
{
    int iItem = m_nItem;

    // add to list

    //
    // -1 is error code for CUIFList::AddString()
    //
    if (!m_listItem.Add( pItem ))
        return -1;

    m_nItem++;

    // calc visible item count

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
        CalcVisibleCount();
    }

    // update scrollbar

    UpdateScrollBar();

    // update window

    CallOnPaint();

    return iItem;
}


/*   G E T  C O U N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetCount( void )
{
    return m_nItem;
}


/*   G E T  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CListItemBase *CUIFListBase::GetItem( int iItem )
{
    if (0 <= iItem && iItem < m_nItem) {
        return m_listItem.Get( iItem );
    }

    return NULL;
}


/*   D E L  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::DelItem( int iItem )
{
    CListItemBase *pItem;

    pItem = GetItem( iItem );
    if (pItem != NULL) {
        // delete item

        m_listItem.Remove(pItem);
        delete pItem;
        m_nItem--;

        // calc visible item count

        if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
            CalcVisibleCount();
        }

        // update scrollbar

        UpdateScrollBar();

        // update window

        CallOnPaint();
    }
}


/*   D E L  A L L  I T E M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::DelAllItem( void )
{
    CListItemBase *pItem;

    while ((pItem = m_listItem.GetFirst()) != NULL) {
        m_listItem.Remove(pItem);
        delete pItem;
        m_nItem--;
    }
    Assert( m_nItem == 0 );

    m_iItemTop = 0;
    m_iItemSelect = 0;

    // calc visible item count

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
        CalcVisibleCount();
    }

    // update scrollbar

    UpdateScrollBar();

    // update window

    CallOnPaint();
}


/*   S E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetSelection( int iSelection, BOOL fRedraw )
{
    BOOL fNotify;

    if (iSelection < -1 || m_nItem <= iSelection) {
        return;
    }

    fNotify = (iSelection != m_iItemSelect) && iSelection != -1 && m_iItemSelect != -1;
    m_iItemSelect = iSelection;

    // make the selection visible always

    int iItemTop = GetTop();
    int iItemBottom = GetBottom();

    if (m_iItemSelect < iItemTop) {
        SetTop( m_iItemSelect, TRUE );
    }
    else if (iItemBottom < m_iItemSelect) {
        if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
            // fixed height

            SetTop( m_iItemSelect - m_nItemVisible + 1, TRUE );
        }
        else {
            int nHeight = GetListHeight();
            int nItemShift;
            int ptBottom;
            int i;

            // variable height

            ptBottom = 0;
            for (i = iItemTop; i <= m_iItemSelect; i++) {
                ptBottom += GetItemHeight( i );
            }

            // find number of items to shift

            nItemShift = 0;
            while (nHeight < ptBottom && (iItemTop + nItemShift) < m_iItemSelect) {
                ptBottom -= GetItemHeight( iItemTop + nItemShift );
                nItemShift++;
            }

            // set new top

            SetTop( iItemTop + nItemShift, TRUE );
        }
    }

    if (fRedraw) {
        CallOnPaint();
    }

    if (fNotify) {
        NotifyCommand( UILIST_SELCHANGED, m_iItemSelect );
    }
}


/*   C L E A R  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::ClearSelection( BOOL fRedraw )
{
    if (m_iItemSelect != -1) {
        m_iItemSelect = -1;

        if (fRedraw) {
            CallOnPaint();
        }

        NotifyCommand( UILIST_SELCHANGED, m_iItemSelect );
    }
}


/*   S E T  L I N E  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetLineHeight( int nLineHeight )
{
    m_nLineHeight = nLineHeight;

    // calc visible item count

    CalcVisibleCount();

    // update scrollbar

    UpdateScrollBar();

    // update window

    CallOnPaint();
}


/*   S E T  T O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::SetTop( int nTop, BOOL fSetScrollPos )
{
    nTop = min( nTop, m_nItem );
    nTop = max( nTop, 0 );

    if (m_iItemTop != nTop) {
        m_iItemTop = nTop;

        // calc visible count
                
        if ((m_dwStyle & UILIST_VARIABLEHEIGHT) != 0) {
            CalcVisibleCount();
        }

        CallOnPaint();

        if (fSetScrollPos) {
            // update scrollbar

            UpdateScrollBar();
        }
    }
}


/*   G E T  S E L E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetSelection( void )
{
    return m_iItemSelect;
}


/*   G E T  L I N E  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetLineHeight( void )
{
    return m_nLineHeight;
}


/*   G E T  T O P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetTop( void )
{
    return m_iItemTop;
}


/*   G E T  B O T T O M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetBottom( void )
{
    return m_iItemTop + m_nItemVisible - 1; 
}


/*   G E T  V I S I B L E  C O U N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetVisibleCount( void )
{
    return m_nItemVisible; 
}


/*   G E T  I T E M  H E I G H T   */
/*------------------------------------------------------------------------------

    (only called in UILIST_VARIABLEHEIGHT)

------------------------------------------------------------------------------*/
int CUIFListBase::GetItemHeight( int iItem )
{
    return m_nLineHeight;
}


/*   G E T  L I S T  H E I G H T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::GetListHeight( void )
{
    int nHeight;

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            nHeight = GetRectRef().bottom - GetRectRef().top;
            break;
        }

        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            nHeight = GetRectRef().right - GetRectRef().left;
            break;
        }
    }

    return nHeight;
}


/*   G E T  L I N E  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::GetLineRect( int iLine, RECT *prc )
{
    int pxyItem = 0;
    int cxyItem = 0;

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
        // fixed height

        cxyItem = GetLineHeight();
        pxyItem = iLine * cxyItem;
    }
    else {
        int i;

        // variable height

        for (i = 0; i <= iLine; i++) {
            pxyItem += cxyItem;
            cxyItem = GetItemHeight( m_iItemTop + i );
        }
    }

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().top + pxyItem;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().top + (pxyItem + cxyItem);
            break;
        }

        case UILIST_HORZBT: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - (pxyItem + cxyItem);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom - pxyItem;
            break;
        }

        case UILIST_VERTLR: {
            prc->left   = GetRectRef().left + pxyItem;
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().left + (pxyItem + cxyItem);
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UILIST_VERTRL: {
            prc->left   = GetRectRef().right - (pxyItem + cxyItem);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right - pxyItem;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }

    // exclude scrollbar 

    if (m_pUIScroll != NULL && m_pUIScroll->IsVisible()) {
        RECT rcScroll;

        m_pUIScroll->GetRect( &rcScroll );

        switch (m_dwStyle & UILIST_DIRMASK) {
            default:
            case UILIST_HORZTB:
            case UILIST_HORZBT: {
                prc->right = min( prc->right, rcScroll.left );
                break;
            }

            case UILIST_VERTLR:
            case UILIST_VERTRL: {
                prc->bottom = max( prc->bottom, rcScroll.top );
                break;
            }
        }
    }

    // clip

    IntersectRect( prc, prc, &GetRectRef() );
}


/*   G E T  S C R O L L  B A R  R E C T   */
/*------------------------------------------------------------------------------

    Get scrollbar position

------------------------------------------------------------------------------*/
void CUIFListBase::GetScrollBarRect( RECT *prc )
{
    Assert( prc != NULL );

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB:
        case UILIST_HORZBT: {
            prc->left   = GetRectRef().right - GetSystemMetrics(SM_CXVSCROLL);
            prc->top    = GetRectRef().top;
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }

        case UILIST_VERTLR:
        case UILIST_VERTRL: {
            prc->left   = GetRectRef().left;
            prc->top    = GetRectRef().bottom - GetSystemMetrics(SM_CYHSCROLL);
            prc->right  = GetRectRef().right;
            prc->bottom = GetRectRef().bottom;
            break;
        }
    }
}


/*   G E T  S C R O L L  B A R  S T Y L E   */
/*------------------------------------------------------------------------------

    Get scrollbar style

------------------------------------------------------------------------------*/
DWORD CUIFListBase::GetScrollBarStyle( void )
{
    DWORD dwScrollStyle;

    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB: {
            dwScrollStyle = UISCROLL_VERTTB;
            break;
        }

        case UILIST_HORZBT: {
            dwScrollStyle = UISCROLL_VERTBT;
            break;
        }

        case UILIST_VERTLR: {
            dwScrollStyle = UISCROLL_HORZLR;
            break;
        }

        case UILIST_VERTRL: {
            dwScrollStyle = UISCROLL_HORZRL;
            break;
        }
    }
    return dwScrollStyle;
}


/*   C R E A T E  S C R O L L  B A R  O B J   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFScroll *CUIFListBase::CreateScrollBarObj( CUIFObject *pParent, DWORD dwID, RECT *prc, DWORD dwStyle )
{
    return new CUIFScroll( pParent, dwID, prc, dwStyle );
}


/*   P A I N T  I T E M  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFListBase::PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected )
{
    COLORREF colText;
    COLORREF colBack;

    Assert( pItem != NULL );

    // set color

    if (fSelected) {
        colText = GetSysColor(COLOR_HIGHLIGHTTEXT);
        colBack = GetSysColor(COLOR_HIGHLIGHT);
    }
    else {
        colText = GetSysColor(COLOR_WINDOWTEXT);
        colBack = GetSysColor(COLOR_3DFACE);
    }

    SetTextColor( hDC, colText );
    SetBkColor( hDC, colBack );

    // 

    CUIExtTextOut( hDC, prc->left, prc->top, ETO_OPAQUE | ETO_CLIPPED, prc, L"", 0, NULL );
}


/*   L I S T  I T E M  F R O M  P O I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFListBase::ListItemFromPoint( POINT pt )
{
    if (PtInObject( pt )) {
        int iLine;
        RECT rc;

        for (iLine = 0; iLine < m_nItemVisible + 1; iLine++) {
            if (m_nItem <= m_iItemTop + iLine) {
                break;
            }

            GetLineRect( iLine, &rc );
            if (PtInRect( &rc, pt )) {
                return iLine + m_iItemTop;
            }
        }
    }

    return (-1);
}


/*   C A L C  V I S I B L E  C O U N T   */
/*------------------------------------------------------------------------------

    Calculate number of visible item

------------------------------------------------------------------------------*/
void CUIFListBase::CalcVisibleCount( void )
{
    int nHeight = GetListHeight();

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
        // fixed height

	if (m_nLineHeight <= 0) {
		m_nItemVisible = 0;
	}
	else {
	        m_nItemVisible = nHeight / m_nLineHeight;
	}
    }
    else {
        // variable height

        if (0 < m_nItem) {
            int i = m_iItemTop;

            // count visible item

            m_nItemVisible = 0;
            while (0 < nHeight && i < m_nItem) {
                nHeight -= GetItemHeight( i );
                m_nItemVisible++;
                i++;
            }

            // adjustment

            if (0 < nHeight && m_nItemVisible == 0) {
                // at least, one item is visible

                m_nItemVisible = 1;
            }
            else if (nHeight < 0 && 1 < m_nItemVisible) {
                // exclude last item if clipped

                m_nItemVisible--;
            }
        }
        else {
            m_nItemVisible = 0;
        }
    }
}


/*   U P D A T E  S C R O L L  B A R   */
/*------------------------------------------------------------------------------

    Update scrollbar range and visible status

------------------------------------------------------------------------------*/
void CUIFListBase::UpdateScrollBar( void )
{
    UIFSCROLLINFO ScrollInfo;

    Assert( m_pUIScroll != NULL );

    // set scroll range/current pos

    if ((m_dwStyle & UILIST_VARIABLEHEIGHT) == 0) {
        // fixed height

        ScrollInfo.nMax  = m_nItem;
        ScrollInfo.nPage = m_nItemVisible;
        ScrollInfo.nPos  = m_iItemTop;
    }
    else {
        int nTotal    = 0;
        int nTop      = 0;
        int nVisible  = 0;
        int i;

        // variable height

        nVisible = GetListHeight();
        for (i = 0; i < m_nItem; i++) {
            int nItemHeight = GetItemHeight( i );

            if (i < m_iItemTop) {
              nTop += nItemHeight;
            }

            nTotal += nItemHeight;
        }

        // adjust gap at the end of list

        if (nVisible < nTotal) {
            int nLastPage = 0;

            for (i = m_nItem-1; 0 <= i; i--) {
                int nItemHeight = GetItemHeight( i );

                if (nVisible < nLastPage + nItemHeight) {
                    break;
                }
                nLastPage += nItemHeight;
            }

            if (0 < nLastPage && nLastPage < nVisible) {
                nTotal += (nVisible - nLastPage);
            }
        }

        ScrollInfo.nMax  = nTotal;
        ScrollInfo.nPage = nVisible;
        ScrollInfo.nPos  = nTop;
    }
    m_pUIScroll->SetScrollInfo( &ScrollInfo );

    // show/hide scroll bar

    if ((m_dwStyle & UILIST_DISABLENOSCROLL) == 0) {
        m_pUIScroll->Show( ScrollInfo.nPage < ScrollInfo.nMax );
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  L I S T                                                         */
/*                                                                             */
/*=============================================================================*/

//
// CListItem
//

class CListItem : public CListItemBase
{
public:
    CListItem( WCHAR *psz, int nId )
    {
        m_pwch = NULL;
        m_nId = nId;
        m_dwData = 0;

        if (psz != NULL) {
            m_pwch = new WCHAR[ StrLenW(psz) + 1 ];
            if (m_pwch != NULL) {
                StrCpyW( m_pwch, psz );
            }
        }
    }

    virtual ~CListItem( void )
    {
        if (m_pwch != NULL) {
            delete m_pwch;
        }
    }

    __inline LPCWSTR GetString( void )
    {
        return m_pwch;
    }

    __inline int GetID( void )
    {
        return m_nId;
    }

    __inline void SetData( DWORD dwData )
    {
        m_dwData = dwData;
    }

    __inline DWORD GetData( void )
    {
        return m_dwData;
    }

protected:
    WCHAR *m_pwch;
    int   m_nId;
    DWORD m_dwData;
};


//
// CUIFList
//

/*   C  U I F  L I S T   */
/*------------------------------------------------------------------------------

    Constructor of CUIFList

------------------------------------------------------------------------------*/
CUIFList::CUIFList( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFListBase( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  L I S T   */
/*------------------------------------------------------------------------------

    Destructor of CUIFList

------------------------------------------------------------------------------*/
CUIFList::~CUIFList( void )
{
}


/*   A D D  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFList::AddString( WCHAR *psz )
{
    CListItem *pItem = new CListItem( psz, GetCount() );
    if (!pItem)
    {
        //
        // is it ok to return -1?
        //
        return -1;
    }

    return AddItem( pItem );
}


/*   G E T  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LPCWSTR CUIFList::GetString( int nID )
{
    int iItem = ItemFromID( nID );
    CListItem *pItem;

    pItem = (CListItem *)GetItem( iItem );
    if (pItem != NULL) {
        return pItem->GetString();
    }

    return NULL;
}


/*   D E L E T E  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::DeleteString( int nID )
{
    int iItem = ItemFromID( nID );

    if (iItem != -1) {
        DelItem( iItem );
    }
}


/*   D E L E T E  A L L  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::DeleteAllString( void )
{
    DelAllItem();
}


/*   S E T  P R I V A T E  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::SetPrivateData( int nID, DWORD dw )
{
    int iItem = ItemFromID( nID );
    CListItem *pItem;

    pItem = (CListItem *)GetItem( iItem );
    if (pItem != NULL) {
        pItem->SetData( dw );
    }
}


/*   G E T  P R I V A T E  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFList::GetPrivateData( int nID )
{
    int iItem = ItemFromID( nID );
    CListItem *pItem;

    pItem = (CListItem *)GetItem( iItem );
    if (pItem != NULL) {
        return pItem->GetData();
    }

    return 0;
}


/*   I T E M  F R O M  I D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIFList::ItemFromID( int iID )
{
    int nItem;
    int i;

    nItem = GetCount();
    for (i = 0; i < nItem; i++) {
        CListItem *pItem = (CListItem *)GetItem( i );

        if (iID == pItem->GetID()) {
            return i;
        }
    }

    return -1;
}


/*   P A I N T  I T E M  P R O C   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFList::PaintItemProc( HDC hDC, RECT *prc, CListItemBase *pItem, BOOL fSelected )
{
    CListItem *pListItem = (CListItem *)pItem;
    COLORREF colText;
    COLORREF colBack;
    LPCWSTR pwch;
    SIZE  size;
    POINT ptOrg;

    Assert( pListItem != NULL );
    pwch = pListItem->GetString();
    if (pwch == NULL) {
        return;
    }

    // set color

    if (fSelected) {
        colText = GetSysColor(COLOR_HIGHLIGHTTEXT);
        colBack = GetSysColor(COLOR_HIGHLIGHT);
    }
    else {
        colText = GetSysColor(COLOR_WINDOWTEXT);
        colBack = GetSysColor(COLOR_3DFACE);
    }

    SetTextColor( hDC, colText );
    SetBkColor( hDC, colBack );

    // calc origin

    GetTextExtentPointW( hDC, pwch, StrLenW(pwch), &size );
    switch (m_dwStyle & UILIST_DIRMASK) {
        default:
        case UILIST_HORZTB: {
            ptOrg.x = prc->left;
            ptOrg.y = (prc->bottom + prc->top - size.cy) / 2;
            break;
        }

        case UILIST_HORZBT: {
            ptOrg.x = prc->right;
            ptOrg.y = (prc->bottom + prc->top + size.cy) / 2;
            break;
        }

        case UILIST_VERTLR: {
            ptOrg.x = (prc->right + prc->left - size.cy) / 2;
            ptOrg.y = prc->bottom;
            break;
        }

        case UILIST_VERTRL: {
            ptOrg.x = (prc->right + prc->left + size.cy) / 2;
            ptOrg.y = prc->top;
            break;
        }
    }

    CUIExtTextOut( hDC, ptOrg.x, ptOrg.y, ETO_OPAQUE | ETO_CLIPPED, prc, pwch, StrLenW(pwch), NULL );
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  G R I P P E R                                                   */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  G R I P P E R   */
/*------------------------------------------------------------------------------

    Constructor of CUIFGripper

------------------------------------------------------------------------------*/
CUIFGripper::CUIFGripper( CUIFObject *pParent, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, 0, prc, dwStyle )
{
    if (IsVertical())
        SetActiveTheme(L"REBAR", RP_GRIPPERVERT);
    else
        SetActiveTheme(L"REBAR", RP_GRIPPER);
}


/*   ~  C  U I F  G R I P P E R   */
/*------------------------------------------------------------------------------

    Destructor of CUIFGripper

------------------------------------------------------------------------------*/
CUIFGripper::~CUIFGripper( void )
{
}

/*   O N  P A I N T  T H E M E */
/*------------------------------------------------------------------------------

    Paint procedure of gripper object

------------------------------------------------------------------------------*/
void CUIFGripper::SetStyle( DWORD dwStyle )
{
    CUIFObject::SetStyle(dwStyle);
    if (IsVertical())
        SetActiveTheme(L"REBAR", RP_GRIPPERVERT);
    else
        SetActiveTheme(L"REBAR", RP_GRIPPER);
}

/*   O N  P A I N T  T H E M E */
/*------------------------------------------------------------------------------

    Paint procedure of gripper object

------------------------------------------------------------------------------*/
BOOL CUIFGripper::OnPaintTheme( HDC hDC )
{
    BOOL fRet = FALSE;
    int    iStateID;
    RECT rc;

    iStateID = TS_NORMAL;

    if (FAILED(EnsureThemeData( GetUIWnd()->GetWnd())))
        goto Exit;

    rc = GetRectRef();
    if (!IsVertical())
    {
       rc.left  += CUI_GRIPPER_THEME_MARGIN;
       rc.right -= CUI_GRIPPER_THEME_MARGIN;
    }
    else
    {
       rc.top    += CUI_GRIPPER_THEME_MARGIN;
       rc.bottom -= CUI_GRIPPER_THEME_MARGIN;
    }

    if (FAILED(DrawThemeBackground(hDC, iStateID, &rc, 0 )))
        goto Exit;

    fRet = TRUE;
Exit:
    return fRet;
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of gripper object

------------------------------------------------------------------------------*/
void CUIFGripper::OnPaintNoTheme( HDC hDC )
{
    CUIFWindow *pWnd = GetUIWnd();
    CUIFScheme *pUIFScheme = pWnd->GetUIFScheme();
    if (pUIFScheme)
    {
        pUIFScheme->DrawDragHandle(hDC, &GetRectRef(), IsVertical());
    }
    else
    {
        RECT rc;
        if (!IsVertical())
        {
            ::SetRect(&rc, 
                      GetRectRef().left + 1, 
                      GetRectRef().top, 
                      GetRectRef().left + 4, 
                      GetRectRef().bottom);
        }
        else
        {
            ::SetRect(&rc, 
                      GetRectRef().left, 
                      GetRectRef().top + 1, 
                      GetRectRef().right, 
                      GetRectRef().top + 4);
        }

        DrawEdge(hDC, &rc, BDR_RAISEDINNER, BF_RECT);
    }

}


/*   O N  S E T  C U R S O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFGripper::OnSetCursor( UINT uMsg, POINT pt )
{
    SetCursor(LoadCursor(NULL, IDC_SIZEALL));
    return TRUE;
}


/*   O N  L  B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFGripper::OnLButtonDown( POINT pt )
{
    RECT rc;
    StartCapture();
    _ptCur  = pt;
    ClientToScreen(m_pUIWnd->GetWnd(), &_ptCur);
    GetWindowRect(m_pUIWnd->GetWnd(), &rc);
    _ptCur.x -= rc.left;
    _ptCur.y -= rc.top;
}


/*   O N  L  B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFGripper::OnLButtonUp( POINT pt )
{
    if (IsCapture())
    {
        EndCapture();
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFGripper::OnMouseMove( POINT pt )
{
    if (IsCapture())
    {
        POINT ptCursor;
        GetCursorPos(&ptCursor);
        m_pUIWnd->Move(ptCursor.x - _ptCur.x, ptCursor.y - _ptCur.y, -1, -1);
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  W N D  F R A M E                                                */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  W N D  F R A M E   */
/*------------------------------------------------------------------------------

    Constructor of CUIFWndFrame

------------------------------------------------------------------------------*/
CUIFWndFrame::CUIFWndFrame( CUIFObject *pParent, const RECT *prc, DWORD dwStyle ) : CUIFObject( pParent, 0, prc, dwStyle )
{
    SetActiveTheme(L"WINDOW", WP_FRAMELEFT);

    m_dwHTResizing = 0;

    m_cxFrame = 0;
    m_cyFrame = 0;
    if (GetUIFScheme())
    {
        switch (GetStyle() & UIWNDFRAME_STYLEMASK) {
            default:
            case UIWNDFRAME_THIN: {
                m_cxFrame = GetUIFScheme()->CxWndBorder();
                m_cyFrame = GetUIFScheme()->CxWndBorder();
                break;
            }

            case UIWNDFRAME_THICK:
            case UIWNDFRAME_ROUNDTHICK: {
                m_cxFrame = GetUIFScheme()->CxSizeFrame();
                m_cyFrame = GetUIFScheme()->CySizeFrame();
                break;
            }
        }
    }

    m_cxMin = GetSystemMetrics( SM_CXMIN );
    m_cyMin = GetSystemMetrics( SM_CYMIN );
}


/*   ~  C  U I F  W N D  F R A M E   */
/*------------------------------------------------------------------------------

    Destructor of CUIFWndFrame

------------------------------------------------------------------------------*/
CUIFWndFrame::~CUIFWndFrame( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of wnd frame object

------------------------------------------------------------------------------*/
BOOL CUIFWndFrame::OnPaintTheme( HDC hDC )
{
    BOOL fRet = FALSE;

    if (FAILED(EnsureThemeData(m_pUIWnd->GetWnd())))
        goto Exit;

    //
    // DrawThemebackground() does not draw caption.
    // so we draw the frame with 4 lines by DrawThemeLine().
    //

    // if (FAILED(DrawThemeBackground(hDC, FS_ACTIVE, &GetRectRef(), 0 )))
    //     goto Exit;

    RECT rc;

    //
    // draw left side
    //
    rc = GetRectRef();
    rc.right = m_cxFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_RAISED, BF_LEFT )))
        goto Exit;

    //
    // draw right side
    //
    rc = GetRectRef();
    rc.left = rc.right - m_cxFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_SUNKEN, BF_RIGHT )))
        goto Exit;

    //
    // draw top side
    //
    rc = GetRectRef();
    rc.bottom = m_cyFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_RAISED, BF_TOP )))
        goto Exit;

    //
    // draw bottom side
    //
    rc = GetRectRef();
    rc.top = rc.bottom - m_cyFrame;
    if (FAILED(DrawThemeEdge(hDC, 0, &rc, EDGE_SUNKEN, BF_BOTTOM )))
        goto Exit;

    fRet = TRUE;
Exit:
    return fRet;
}

/*   O N  P A I N T   */
/*------------------------------------------------------------------------------

    Paint procedure of wnd frame object

------------------------------------------------------------------------------*/
void CUIFWndFrame::OnPaintNoTheme( HDC hDC )
{
    if (!GetUIFScheme())
        return;

    DWORD dwFlag = 0;

    switch (GetStyle() & UIWNDFRAME_STYLEMASK) {
        default:
        case UIWNDFRAME_THIN: {
            dwFlag = UIFDWF_THIN;
            break;
        }

        case UIWNDFRAME_THICK: {
            dwFlag = UIFDWF_THICK;
            break;
        }

        case UIWNDFRAME_ROUNDTHICK: {
            dwFlag = UIFDWF_ROUNDTHICK;
            break;
        }
    }

    GetUIFScheme()->DrawWndFrame( hDC, &GetRectRef(), dwFlag, m_cxFrame, m_cyFrame );
}


/*   O N  S E T  C U R S O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFWndFrame::OnSetCursor( UINT uMsg, POINT pt )
{
    DWORD   dw;
    LPCTSTR idc = NULL;

    if (IsCapture()) {
        dw = m_dwHTResizing;
    }
    else {
        dw = HitTest( pt ) & GetStyle();
    }

    if (dw == (UIWNDFRAME_RESIZELEFT | UIWNDFRAME_RESIZETOP)) {
        idc = IDC_SIZENWSE;
    }
    else if (dw == (UIWNDFRAME_RESIZELEFT | UIWNDFRAME_RESIZEBOTTOM)) {
        idc = IDC_SIZENESW;
    }
    else if (dw == (UIWNDFRAME_RESIZERIGHT | UIWNDFRAME_RESIZETOP)) {
        idc = IDC_SIZENESW;
    }
    else if (dw == (UIWNDFRAME_RESIZERIGHT | UIWNDFRAME_RESIZEBOTTOM)) {
        idc = IDC_SIZENWSE;
    }
    else if (dw == UIWNDFRAME_RESIZELEFT) {
        idc = IDC_SIZEWE;
    }
    else if (dw == UIWNDFRAME_RESIZETOP) {
        idc = IDC_SIZENS;
    }
    else if (dw == UIWNDFRAME_RESIZERIGHT) {
        idc = IDC_SIZEWE;
    }
    else if (dw == UIWNDFRAME_RESIZEBOTTOM) {
        idc = IDC_SIZENS;
    }

    if (idc != NULL) {
        SetCursor( LoadCursor( NULL, idc ) );
        return TRUE;
    }

    return FALSE;
}


/*   O N  L  B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::OnLButtonDown( POINT pt )
{
    DWORD   dwHT;

    dwHT = HitTest( pt ) & GetStyle();

    if (dwHT != 0) {
        ClientToScreen( m_pUIWnd->GetWnd(), &pt );

        m_ptDrag = pt;
        m_dwHTResizing = dwHT;
        GetWindowRect( m_pUIWnd->GetWnd(), &m_rcOrg );

        StartCapture();
    }
}


/*   O N  L  B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        RECT rc = m_rcOrg;

        ClientToScreen( m_pUIWnd->GetWnd(), &pt );

        if (m_dwHTResizing & UIWNDFRAME_RESIZELEFT) {
            rc.left = m_rcOrg.left + (pt.x - m_ptDrag.x);
        }
        if (m_dwHTResizing & UIWNDFRAME_RESIZETOP) {
            rc.top = m_rcOrg.top + (pt.y - m_ptDrag.y);
        }
        if (m_dwHTResizing & UIWNDFRAME_RESIZERIGHT) {
            rc.right = m_rcOrg.right + (pt.x - m_ptDrag.x);
            rc.right = max( rc.right, rc.left + m_cxMin );
        }
        if (m_dwHTResizing & UIWNDFRAME_RESIZEBOTTOM) {
            rc.bottom = m_rcOrg.bottom + (pt.y - m_ptDrag.y);
            rc.bottom = max( rc.bottom, rc.top + m_cyMin );
        }

        m_pUIWnd->Move( rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top );
    }
}


/*   G E T  I N T E R N A L  R E C T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::GetInternalRect( RECT *prc )
{
    Assert( prc != NULL );

    *prc = GetRectRef();
    prc->left   = prc->left   + m_cxFrame;
    prc->top    = prc->top    + m_cyFrame;
    prc->right  = prc->right  - m_cxFrame;
    prc->bottom = prc->bottom - m_cyFrame;
}


/*   H I T  T E S T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFWndFrame::HitTest( POINT pt )
{
    DWORD dwHT = 0;

    dwHT |= (GetRectRef().left <= pt.x && pt.x < GetRectRef().left + m_cxFrame) ? UIWNDFRAME_RESIZELEFT : 0;
    dwHT |= (GetRectRef().top  <= pt.y && pt.y < GetRectRef().top  + m_cyFrame) ? UIWNDFRAME_RESIZETOP  : 0;
    dwHT |= (GetRectRef().right  - m_cxFrame <= pt.x && pt.x < GetRectRef().right ) ? UIWNDFRAME_RESIZERIGHT  : 0;
    dwHT |= (GetRectRef().bottom - m_cyFrame <= pt.y && pt.y < GetRectRef().bottom) ? UIWNDFRAME_RESIZEBOTTOM : 0;

    return dwHT;
}


/*   G E T  F R A M E  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::GetFrameSize( SIZE *psize )
{
    Assert( psize != NULL );

    psize->cx = m_cxFrame;
    psize->cy = m_cyFrame;
}


/*   S E T  F R A M E  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::SetFrameSize( SIZE *psize )
{
    Assert( psize != NULL );

    m_cxFrame = psize->cx;
    m_cyFrame = psize->cy;

    CallOnPaint();
}


/*   G E T  M I N I M U M  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::GetMinimumSize( SIZE *psize )
{
    Assert( psize != NULL );

    psize->cx = m_cxMin;
    psize->cy = m_cyMin;
}


/*   S E T  M I N I M U M  S I Z E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndFrame::SetMinimumSize( SIZE *psize )
{
    Assert( psize != NULL );

    if (psize->cx != -1) {
        m_cxMin = psize->cx;
    }
    if (psize->cy != -1) {
        m_cyMin = psize->cy;
    }
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  W N D  C A P T I O N                                            */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  W N D  C A P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFWndCaption::CUIFWndCaption( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFStatic( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  W N D  C A P T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFWndCaption::~CUIFWndCaption( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnPaint( HDC hDC )
{
    HFONT    hFontOld;
    COLORREF colTextOld;
    int      iBkModeOld;
    int      xAlign;
    int      yAlign;
    SIZE     size;
    int      cwch;
    UIFCOLOR colBkgnd;
    UIFCOLOR colText;

    // 

    if (FHasStyle( UIWNDCAPTION_ACTIVE )) {
        colBkgnd = UIFCOLOR_ACTIVECAPTIONBKGND;
        colText  = UIFCOLOR_ACTIVECAPTIONTEXT;
    }
    else {
        colBkgnd = UIFCOLOR_INACTIVECAPTIONBKGND;
        colText  = UIFCOLOR_INACTIVECAPTIONTEXT;
    }

    // background

    FillRect( hDC, &GetRectRef(), GetUIFBrush( colBkgnd ) );

    // caption text

    if (m_pwchText == NULL) {
        return;
    }

    // prepare objects

    hFontOld= (HFONT)SelectObject( hDC, GetFont() );
    colTextOld = SetTextColor( hDC, GetUIFColor( colText ) );
    iBkModeOld = SetBkMode( hDC, TRANSPARENT );

    // calc alignment

    cwch = StrLenW(m_pwchText);
    GetTextExtentPointW( hDC, m_pwchText, cwch, &size );

    xAlign = 8;
    yAlign = (GetRectRef().bottom - GetRectRef().top - size.cy) / 2;

    // draw

    CUIExtTextOut( hDC,
                    GetRectRef().left + xAlign,
                    GetRectRef().top + yAlign,
                    ETO_CLIPPED,
                    &GetRectRef(),
                    m_pwchText,
                    cwch,
                    NULL );

    // restore objects

    SelectObject( hDC, hFontOld );
    SetTextColor( hDC, colTextOld );
    SetBkMode( hDC, iBkModeOld );
}


/*   O N  L  B U T T O N  D O W N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnLButtonDown( POINT pt )
{
    RECT rc;

    if (!FHasStyle( UIWNDCAPTION_MOVABLE )) {
        return;
    }

    StartCapture();
    SetCursor( LoadCursor( NULL, IDC_SIZEALL ) );

    m_ptDrag = pt;
    ClientToScreen( m_pUIWnd->GetWnd(), &m_ptDrag );
    GetWindowRect( m_pUIWnd->GetWnd(), &rc );
    m_ptDrag.x -= rc.left;
    m_ptDrag.y -= rc.top;
}


/*   O N  L  B U T T O N  U P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnLButtonUp( POINT pt )
{
    if (IsCapture()) {
        EndCapture();
        SetCursor( LoadCursor( NULL, IDC_ARROW ) );
    }
}


/*   O N  M O U S E  M O V E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFWndCaption::OnMouseMove( POINT pt )
{
    if (IsCapture()) {
        POINT ptCursor;

        GetCursorPos( &ptCursor );
        m_pUIWnd->Move( ptCursor.x - m_ptDrag.x, ptCursor.y - m_ptDrag.y, -1, -1 );
    }
}


/*   O N  S E T  C U R S O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL CUIFWndCaption::OnSetCursor( UINT uMsg, POINT pt )
{
    if (IsCapture()) {
        SetCursor( LoadCursor( NULL, IDC_SIZEALL ) );
    }
    else {
        SetCursor( LoadCursor( NULL, IDC_ARROW ) );
    }
    return TRUE;
}


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  C A P T I O N  B U T T O N                                      */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  C A P T I O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCaptionButton::CUIFCaptionButton( CUIFObject *pParent, DWORD dwID, const RECT *prc, DWORD dwStyle ) : CUIFButton2( pParent, dwID, prc, dwStyle )
{
}


/*   ~  C  U I F  C A P T I O N  B U T T O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CUIFCaptionButton::~CUIFCaptionButton( void )
{
}


/*   O N  P A I N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFCaptionButton::OnPaint( HDC hDC )
{
    DWORD   dwState = 0;
    HDC     hDCMem;
    HBITMAP hBmpMem;
    HBITMAP hBmpOld;
    SIZE    size;
    RECT    rc;
    SIZE    sizeText  = {0};
    SIZE    sizeImage = {0};
    SIZE    sizeFace  = {0};
    SIZE    offset    = {0};
    RECT    rcText    = {0};
    RECT    rcImage   = {0};
    RECT    rcFace    = {0};
    HFONT   hFontOld;

    if (!m_pUIFScheme)
        return;

    // make draw flag

    dwState |= (m_fToggled) ? UIFDCS_SELECTED : 0;
    switch (m_dwStatus) {
        case UIBUTTON_DOWN: {
            dwState |= UIFDCS_MOUSEDOWN;
            break;
        }

        case UIBUTTON_HOVER:
        case UIBUTTON_DOWNOUT: {
            dwState |= UIFDCS_MOUSEOVER;
            break;
        }
    }
    dwState |= IsEnabled() ? 0 : UIFDCS_DISABLED;
    dwState |= (FHasStyle( UICAPTIONBUTTON_ACTIVE ) ? UIFDCS_ACTIVE : UIFDCS_INACTIVE);

    // prepare memory dc

    size.cx = GetRectRef().right - GetRectRef().left;
    size.cy = GetRectRef().bottom - GetRectRef().top;

    hDCMem = CreateCompatibleDC( hDC );
    hBmpMem = CreateCompatibleBitmap( hDC, size.cx, size.cy );
    hBmpOld = (HBITMAP)SelectObject( hDCMem, hBmpMem );

    BitBlt( hDCMem, 0, 0, size.cx, size.cy, hDC, GetRectRef().left, GetRectRef().top, SRCCOPY );

    ::SetRect( &rc, 0, 0, size.cx, size.cy );
    hFontOld = (HFONT)SelectObject( hDCMem, GetFont() );


    // calc face size

    if (m_pwchText != NULL) {
        sizeText  = m_sizeText;
    }
    if (m_hIcon != NULL) { 
        sizeImage  = m_sizeIcon;
    }
    else if (m_hBmp != NULL ) {
        sizeImage  = m_sizeBmp;
    }

    // alignment

    sizeFace.cx = sizeText.cx + sizeImage.cx + ((sizeText.cx != 0 && sizeImage.cx != 0) ? 2 : 0);
    sizeFace.cy = max( sizeText.cy, sizeImage.cy );

    switch (GetStyleBits( UIBUTTON_HALIGNMASK )) {
        case UIBUTTON_LEFT:
        default: {
            rcFace.left   = rc.left + 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_CENTER: {
            rcFace.left   = (rc.right + rc.left - sizeFace.cx) / 2;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }

        case UIBUTTON_RIGHT: {
            rcFace.left   = rc.right - 2 - sizeText.cx;
            rcFace.right  = rcFace.left + sizeFace.cx;
            break;
        }
    }

    switch (GetStyleBits( UIBUTTON_VALIGNMASK )) {
        case UIBUTTON_TOP:
        default: {
            rcFace.top    = rc.top + 2;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_VCENTER: {
            rcFace.top     = (rc.bottom + rc.top - sizeFace.cy) / 2;
            rcFace.bottom  = rcFace.top + sizeFace.cy;
            break;
        }

        case UIBUTTON_BOTTOM: {
            rcFace.top    = rc.bottom - 2 - sizeFace.cy;
            rcFace.bottom = rcFace.top + sizeFace.cy;
            break;
        }
    }

    m_pUIFScheme->GetCtrlFaceOffset( UIFDCF_CAPTIONBUTTON, dwState, &offset );
    OffsetRect( &rcFace, offset.cx, offset.cy );

    rcImage.left   = rcFace.left;
    rcImage.top    = (rcFace.bottom + rcFace.top - sizeImage.cy) / 2;
    rcImage.right  = rcImage.left + sizeImage.cx;
    rcImage.bottom = rcImage.top  + sizeImage.cy;

    rcText.left    = rcFace.right - sizeText.cx;
    rcText.top     = (rcFace.bottom + rcFace.top - sizeText.cy) / 2;
    rcText.right   = rcText.left + sizeText.cx;
    rcText.bottom  = rcText.top  + sizeText.cy;

    // paint background

    m_pUIFScheme->DrawFrameCtrlBkgd( hDCMem, &rc, UIFDCF_CAPTIONBUTTON, dwState );

    // paint face

    if (m_hIcon!= NULL) {
        m_pUIFScheme->DrawFrameCtrlIcon( hDCMem, &rcImage, m_hIcon, dwState, &m_sizeIcon);
    }
    else if (m_hBmp != NULL) {
        m_pUIFScheme->DrawFrameCtrlBitmap( hDCMem, &rcImage, m_hBmp, m_hBmpMask, dwState );
    }

    // draw button edge

    m_pUIFScheme->DrawFrameCtrlEdge( hDCMem, &rc, UIFDCF_CAPTIONBUTTON, dwState );

    //

    BitBlt( hDC, GetRectRef().left, GetRectRef().top, size.cx, size.cy, hDCMem, 0, 0, SRCCOPY );

    SelectObject( hDCMem, hFontOld );
    SelectObject( hDCMem, hBmpOld );
    DeleteObject( hBmpMem );
    DeleteDC( hDCMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuishadw.cpp ===
//
// cuishadw.cpp
//

#include "private.h"
#include "cuishadw.h"
#include "cuisys.h"
#include "cuiutil.h"


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S H A D O W                                                     */
/*                                                                             */
/*=============================================================================*/

/*   C  U I F  S H A D O W   */
/*------------------------------------------------------------------------------

    Constructor of CUIFShadow

------------------------------------------------------------------------------*/
CUIFShadow::CUIFShadow( HINSTANCE hInst, DWORD dwStyle, CUIFWindow *pWndOwner ) : CUIFWindow( hInst, dwStyle | UIWINDOW_TOOLWINDOW )
{
    m_pWndOwner    = pWndOwner;
    m_color        = RGB( 0, 0, 0 );
    m_iGradWidth   = 0;
    m_iAlpha       = 0;
    m_sizeShift.cx = 0;
    m_sizeShift.cy = 0;
    m_fGradient    = FALSE;
}


/*   ~  C  U I F  S H A D O W   */
/*------------------------------------------------------------------------------

    Destructor of CUIFShadow

------------------------------------------------------------------------------*/
CUIFShadow::~CUIFShadow( void )
{
    if (m_pWndOwner) {
        m_pWndOwner->ClearShadowWnd();
    }
}


/*   I N I T I A L I Z E   */
/*------------------------------------------------------------------------------

    Initialize UI window object
    (UIFObject method)

------------------------------------------------------------------------------*/
CUIFObject *CUIFShadow::Initialize( void )
{
    InitSettings();

    return CUIFWindow::Initialize();
}


/*   G E T  W N D  S T Y L E  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
DWORD CUIFShadow::GetWndStyleEx( void )
{
    DWORD dwWndStyleEx = CUIFWindow::GetWndStyleEx();

    if (m_fGradient) {
        dwWndStyleEx |= WS_EX_LAYERED;
    }

    return dwWndStyleEx;
}


/*   O N  C R E A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::OnCreate( HWND hWnd )
{
    CUIFWindow::OnCreate( hWnd );
}


/*   P A I N T  O B J E C T   */
/*------------------------------------------------------------------------------

    Paint window object
    (UIFObject method)

------------------------------------------------------------------------------*/
void CUIFShadow::OnPaint( HDC hDC )
{
    HBRUSH hBrush;
    RECT   rc = GetRectRef();

    // 

    hBrush = CreateSolidBrush( m_color );
    FillRect( hDC, &rc, hBrush );
    DeleteObject( hBrush );
}


/*   O N  S E T T I N G  C H A N G E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFShadow::OnSettingChange( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    InitSettings();

    if (m_fGradient) {
        DWORD dwWndStyleEx = GetWindowLong( GetWnd(), GWL_EXSTYLE );
        SetWindowLong( GetWnd(), GWL_EXSTYLE, (dwWndStyleEx | WS_EX_LAYERED) );
    }
    else {
        DWORD dwWndStyleEx = GetWindowLong( GetWnd(), GWL_EXSTYLE );
        SetWindowLong( GetWnd(), GWL_EXSTYLE, (dwWndStyleEx & ~WS_EX_LAYERED) );
    }

    AdjustWindowPos();
    InitShadow();

    return CUIFWindow::OnSettingChange( hWnd, uMsg, wParam, lParam );
}


/*   S H O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::Show( BOOL fShow )
{
    if (fShow) {
        if (IsWindow( m_hWnd ) && !IsWindowVisible( m_hWnd )) {
            AdjustWindowPos();
            InitShadow();
        }
    }

    if (IsWindow( m_hWnd )) {
        m_fVisible = fShow;
        ShowWindow( m_hWnd, fShow ? SW_SHOWNOACTIVATE : SW_HIDE );
    }
}


/*   O N  O W N E R  W N D  M O V E D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::OnOwnerWndMoved( BOOL fResized )
{
    if (IsWindow( m_hWnd ) && IsWindowVisible( m_hWnd )) {
        AdjustWindowPos();
        if (fResized) {
            InitShadow();
        }
    }
}


/*   G E T  S H I F T   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
void CUIFShadow::GetShift( SIZE *psize )
{
    *psize = m_sizeShift;
}


/*   O N  W I N D O W P O S C H A N G I N G
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
LRESULT CUIFShadow::OnWindowPosChanging(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  
{ 
    WINDOWPOS *pwp = (WINDOWPOS *)lParam;

    pwp->hwndInsertAfter = m_pWndOwner->GetWnd();
    return DefWindowProc(hWnd, uMsg, wParam, lParam); 
}


/*   I N I T  S E T T I N G S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::InitSettings( void )
{
    m_fGradient = !UIFIsLowColor() && CUIIsUpdateLayeredWindowAvail();

    if (m_fGradient) {
        m_color        = RGB( 0, 0, 0 );
        m_iGradWidth   = 4;
        m_iAlpha       = 25;
        m_sizeShift.cx = 4;
        m_sizeShift.cy = 4;
    }
    else {
        m_color        = RGB( 128, 128, 128 );
        m_iGradWidth   = 0;
        m_iAlpha       = 0;
        m_sizeShift.cx = 2;
        m_sizeShift.cy = 2;
    }
}


/*   A D J U S T  W I N D O W  P O S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::AdjustWindowPos( void )
{
    HWND hWndOwner = m_pWndOwner->GetWnd();
    RECT rc;

    if (!IsWindow( GetWnd() )) {
        return;
    }

    GetWindowRect( hWndOwner, &rc );
    SetWindowPos( GetWnd(), 
                    hWndOwner, 
                    rc.left + m_sizeShift.cx, 
                    rc.top  + m_sizeShift.cy,
                    rc.right - rc.left,
                    rc.bottom - rc.top,
                    SWP_NOOWNERZORDER | SWP_NOACTIVATE );
}


/*   I N I T  S H A D O W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void CUIFShadow::InitShadow( void )
{
    typedef struct _RGBAPLHA {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbAlpha;
    } RGBALPHA;

    HDC         hdcScreen = NULL;
    HDC         hdcLayered = NULL;
    RECT        rcWindow;
    SIZE        size;
    BITMAPINFO  BitmapInfo;
    HBITMAP     hBitmapMem = NULL;
    HBITMAP     hBitmapOld = NULL;
    void        *pDIBits;
    int         i;
    int         j;
    int         iAlphaStep;
    POINT       ptSrc;
    POINT       ptDst;
    BLENDFUNCTION Blend;


    //

    if (!m_fGradient) {
        return;
    }

    // The extended window style, WS_EX_LAYERED, that has been set in CreateWindowEx 
    // will be cleared on Access (why?).  reset it again

    SetWindowLong( GetWnd(), GWL_EXSTYLE, (GetWindowLong( GetWnd(), GWL_EXSTYLE ) | WS_EX_LAYERED) );

    //

    Assert( CUIIsUpdateLayeredWindowAvail() );
    Assert( m_iGradWidth != 0 );
    iAlphaStep = ((255 * m_iAlpha / 100) / m_iGradWidth);

    //

    GetWindowRect( GetWnd(), &rcWindow );
    size.cx = rcWindow.right - rcWindow.left;
    size.cy = rcWindow.bottom - rcWindow.top;

    hdcScreen = GetDC( NULL );
    if (hdcScreen == NULL) {
        return;
    }

    hdcLayered = CreateCompatibleDC( hdcScreen );
    if (hdcLayered == NULL) {
        ReleaseDC( NULL, hdcScreen );
        return;
    }

    // create bitmap

    BitmapInfo.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    BitmapInfo.bmiHeader.biWidth         = size.cx;
    BitmapInfo.bmiHeader.biHeight        = size.cy;
    BitmapInfo.bmiHeader.biPlanes        = 1;
    BitmapInfo.bmiHeader.biBitCount      = 32;
    BitmapInfo.bmiHeader.biCompression   = BI_RGB;
    BitmapInfo.bmiHeader.biSizeImage     = 0;
    BitmapInfo.bmiHeader.biXPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biYPelsPerMeter = 100;
    BitmapInfo.bmiHeader.biClrUsed       = 0;
    BitmapInfo.bmiHeader.biClrImportant  = 0;

    hBitmapMem = CreateDIBSection( hdcScreen, &BitmapInfo, DIB_RGB_COLORS, &pDIBits, NULL, 0 );
    if (pDIBits == NULL) {
        ReleaseDC( NULL, hdcScreen );
        DeleteDC( hdcLayered );
        return;
    }

    MemSet( pDIBits, 0, ((((32 * size.cx) + 31) & ~31) / 8) * size.cy );

    // face 

    for (i = 0; i < size.cy; i++) {
        RGBALPHA *ppxl = (RGBALPHA *)pDIBits + i * size.cx;
        BYTE bAlpha = iAlphaStep * m_iGradWidth;

        for (j = 0; j < size.cx; j++) {
            ppxl->rgbAlpha = bAlpha;
            ppxl++;
        }
    }

    // edges

    for (i = 0; i < m_iGradWidth; i++) {
        RGBALPHA *ppxl;
        BYTE bAlpha = iAlphaStep * (i + 1);

        // top

        if (i <= (size.cy + 1)/2) {
            for (j = m_iGradWidth; j < size.cx - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + (size.cy - 1 - i) * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }
        }

        // bottom

        if (i <= (size.cy + 1)/2) {
            for (j = m_iGradWidth; j < size.cx - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + i * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }
        }

        // left

        if (i <= (size.cx + 1)/2) {
            for (j = m_iGradWidth; j < size.cy - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + j * size.cx + i;
                ppxl->rgbAlpha = bAlpha;
            }
        }

        // right

        if (i <= (size.cx + 1)/2) {
            for (j = m_iGradWidth; j < size.cy - m_iGradWidth; j++) {
                ppxl = (RGBALPHA *)pDIBits + j * size.cx + (size.cx - 1 - i);
                ppxl->rgbAlpha = bAlpha;
            }
        }
    }

    // corners

    for (i = 0; i < m_iGradWidth; i++) {
        RGBALPHA *ppxl;
        BYTE bAlpha;

        for (j = 0; j < m_iGradWidth; j++) {
            bAlpha = iAlphaStep * (i + 1) * (j + 1) / (m_iGradWidth + 1);

            // top-left

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + (size.cy - 1 - i) * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }

            // top-right

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + (size.cy - 1 - i) * size.cx + (size.cx - 1 - j);
                ppxl->rgbAlpha = bAlpha;
            }

            // bottom-left

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + i * size.cx + j;
                ppxl->rgbAlpha = bAlpha;
            }

            // bottom-right

            if ((i <= (size.cy + 1)/2) && (j <= (size.cx + 1)/2)) {
                ppxl = (RGBALPHA *)pDIBits + i * size.cx + (size.cx - 1 - j);
                ppxl->rgbAlpha = bAlpha;
            }
        }
    }

    //

    ptSrc.x = 0;
    ptSrc.y = 0;
    ptDst.x = rcWindow.left;
    ptDst.y = rcWindow.top;
    Blend.BlendOp             = AC_SRC_OVER;
    Blend.BlendFlags          = 0;
    Blend.SourceConstantAlpha = 255;
    Blend.AlphaFormat         = AC_SRC_ALPHA;

    hBitmapOld = (HBITMAP)SelectObject( hdcLayered, hBitmapMem );

    CUIUpdateLayeredWindow( GetWnd(), hdcScreen, NULL, &size, hdcLayered, &ptSrc, 0, &Blend, ULW_ALPHA );

    SelectObject( hdcLayered, hBitmapOld );

    // done

    ReleaseDC( NULL, hdcScreen );
    DeleteDC( hdcLayered );
    DeleteObject( hBitmapMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuischem.h ===
//
// cuischem.h
//

#ifndef CUISCHEM_H
#define CUISCHEM_H

#ifndef LAYOUT_RTL
#define LAYOUT_RTL                         0x00000001 // Right to left
#endif // LAYOUT_RTL

//
// UIFrame scheme
//

typedef enum _UIFSCHEME
{
    UIFSCHEME_DEFAULT,
    UIFSCHEME_OFC10MENU,
    UIFSCHEME_OFC10TOOLBAR,
    UIFSCHEME_OFC10WORKPANE,
} UIFSCHEME;


//
// UIFrame color
//

typedef enum _UIFCOLOR
{
    // base color

    UIFCOLOR_MENUBKGND,
    UIFCOLOR_MENUBARSHORT,
    UIFCOLOR_MENUBARLONG,
    UIFCOLOR_MOUSEOVERBKGND,
    UIFCOLOR_MOUSEOVERBORDER,
    UIFCOLOR_MOUSEOVERTEXT,
    UIFCOLOR_MOUSEDOWNBKGND,
    UIFCOLOR_MOUSEDOWNBORDER,
    UIFCOLOR_MOUSEDOWNTEXT,
    UIFCOLOR_CTRLBKGND,
    UIFCOLOR_CTRLTEXT,
    UIFCOLOR_CTRLTEXTDISABLED,
    UIFCOLOR_CTRLIMAGESHADOW,
    UIFCOLOR_CTRLBKGNDSELECTED,
    UIFCOLOR_BORDEROUTER,
    UIFCOLOR_BORDERINNER,
    UIFCOLOR_ACTIVECAPTIONBKGND,
    UIFCOLOR_ACTIVECAPTIONTEXT,
    UIFCOLOR_INACTIVECAPTIONBKGND,
    UIFCOLOR_INACTIVECAPTIONTEXT,
    UIFCOLOR_SPLITTERLINE,
    UIFCOLOR_DRAGHANDLE,

    // virtual color

    UIFCOLOR_WINDOW,

    UIFCOLOR_MAX,                   /* must be last */
} UIFCOLOR;


//
// DrawControl flags
//

#define UIFDCF_FLATONNORMAL                 0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONNORMAL               0x00000001 /* used in default scheme */
#define UIFDCF_SUNKENONNORMAL               0x00000002 /* used in default scheme */
#define UIFDCF_FLATONMOUSEOVER              0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONMOUSEOVER            0x00000004 /* used in default scheme */
#define UIFDCF_SUNKENONMOUSEOVER            0x00000008 /* used in default scheme */
#define UIFDCF_FLATONMOUSEDOWN              0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONMOUSEDOWN            0x00000010 /* used in default scheme */
#define UIFDCF_SUNKENONMOUSEDOWN            0x00000020 /* used in default scheme */
#define UIFDCF_FLATONSELECT                 0x00000000 /* used in default scheme */
#define UIFDCF_RAISEDONSELECT               0x00000040 /* used in default scheme */
#define UIFDCF_SUNKENONSELECT               0x00000080 /* used in default scheme */

#define UIFDCF_BUTTON                       (UIFDCF_FLATONNORMAL | UIFDCF_RAISEDONMOUSEOVER | UIFDCF_RAISEDONMOUSEDOWN | UIFDCF_RAISEDONSELECT)
#define UIFDCF_BUTTONSUNKEN                 (UIFDCF_RAISEDONNORMAL | UIFDCF_RAISEDONMOUSEOVER | UIFDCF_SUNKENONMOUSEDOWN | UIFDCF_SUNKENONSELECT)
#define UIFDCF_CAPTIONBUTTON                (UIFDCF_RAISEDONNORMAL | UIFDCF_RAISEDONMOUSEOVER | UIFDCF_SUNKENONMOUSEDOWN | UIFDCF_SUNKENONSELECT)


//
// DrawControl states
//

#define UIFDCS_NORMAL                       0x00000000
#define UIFDCS_MOUSEOVER                    0x00000001
#define UIFDCS_MOUSEDOWN                    0x00000002
#define UIFDCS_SELECTED                     0x00000010
#define UIFDCS_DISABLED                     0x00000020
#define UIFDCS_MOUSEOVERSELECTED            (UIFDCS_MOUSEOVER | UIFDCS_SELECTED)
#define UIFDCS_MOUSEDOWNSELECTED            (UIFDCS_MOUSEDOWN | UIFDCS_SELECTED)
#define UIFDCS_DISABLEDSELECTED             (UIFDCS_DISABLED  | UIFDCS_SELECTED)
#define UIFDCS_MOUSEOVERDISABLED            (UIFDCS_MOUSEOVER | UIFDCS_DISABLED)
#define UIFDCS_MOUSEOVERDISABLEDSELECTED    (UIFDCS_MOUSEOVER | UIFDCS_DISABLED | UIFDCS_SELECTED)
#define UIFDCS_ACTIVE                       0x00000040 /* used in DrawFrameCtrlXXX */
#define UIFDCS_INACTIVE                     0x00000000 /* used in DrawFrameCtrlXXX */


//
// DrawWndFrame flags
//

#define UIFDWF_THIN                         0x00000000
#define UIFDWF_THICK                        0x00000001
#define UIFDWF_ROUNDTHICK                   0x00000002


//
// CUIFScheme
//

class CUIFScheme
{
public:
    CUIFScheme() {
        m_dwLayout = 0;
    }

    //
    //
    //
    virtual UIFSCHEME GetType( void )                                                                           = 0;    /* PURE */

    // 
    // scheme color
    //
    virtual COLORREF GetColor( UIFCOLOR iCol )                                                                  = 0;    /* PURE */
    virtual HBRUSH GetBrush( UIFCOLOR iCol )                                                                    = 0;    /* PURE */

    //
    // metrics 
    //
    virtual int CyMenuItem( int cyMenuText )                                                                    = 0;    /* PURE */
    virtual int CxSizeFrame( void )                                                                             = 0;    /* PURE */
    virtual int CySizeFrame( void )                                                                             = 0;    /* PURE */
    virtual int CxWndBorder( void )                                                                             = 0;    /* PURE */
    virtual int CyWndBorder( void )                                                                             = 0;    /* PURE */

    //
    // drawing helper
    //
    virtual void FillRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )                                            = 0;    /* PURE */
    virtual void FrameRect( HDC hDC, const RECT *prc, UIFCOLOR iCol )                                           = 0;    /* PURE */
    virtual void DrawSelectionRect( HDC hDC, const RECT *prc, BOOL fMouseDown )                                 = 0;    /* PURE */

    virtual void GetCtrlFaceOffset( DWORD dwFlag, DWORD dwState, SIZE *poffset )                                = 0;    /* PURE */
    virtual void DrawCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                          = 0;    /* PURE */
    virtual void DrawCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                          = 0;    /* PURE */
    virtual void DrawCtrlText( HDC hDC, const RECT *prc, LPCWSTR pwch, int cwch, DWORD dwState, BOOL fVertical )                = 0;    /* PURE */
    virtual void DrawCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState , SIZE *psizeIcon)          = 0;    /* PURE */
    virtual void DrawCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )      = 0;    /* PURE */
    virtual void DrawMenuBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState )      = 0;    /* PURE */
    virtual void DrawMenuSeparator( HDC hDC, const RECT *prc)                                                   = 0;    /* PURE */
    virtual void DrawFrameCtrlBkgd( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                     = 0;    /* PURE */
    virtual void DrawFrameCtrlEdge( HDC hDC, const RECT *prc, DWORD dwFlag, DWORD dwState )                     = 0;    /* PURE */
    virtual void DrawFrameCtrlIcon( HDC hDC, const RECT *prc, HICON hIcon, DWORD dwState,  SIZE *psizeIcon)      = 0;    /* PURE */
    virtual void DrawFrameCtrlBitmap( HDC hDC, const RECT *prc, HBITMAP hBmp, HBITMAP hBmpMask, DWORD dwState ) = 0;    /* PURE */
    virtual void DrawWndFrame( HDC hDC, const RECT *prc, DWORD dwFlag, int cxFrame, int cyFrame )               = 0;    /* PURE */
    virtual void DrawDragHandle( HDC hDC, const RECT *prc, BOOL fVertical)                                      = 0;    /* PURE */
    virtual void DrawSeparator( HDC hDC, const RECT *prc, BOOL fVertical)                                       = 0;    /* PURE */

    void SetLayout(DWORD dwLayout) {
        m_dwLayout = dwLayout;
    }

    BOOL IsRTLLayout() {
        return (m_dwLayout & LAYOUT_RTL) ? TRUE : FALSE;
    }

protected:
    DWORD m_dwLayout;
};


//
// exported functions
//

extern void InitUIFScheme( void );
extern void DoneUIFScheme( void );
extern void UpdateUIFScheme( void );

extern CUIFScheme *CreateUIFScheme( UIFSCHEME scheme );

#endif /* CUISCHEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuishadw.h ===
//
// cuishadw.h
//  = UI object library - define UIShadow class =
//

#ifndef CUISHADW_H
#define CUISHADW_H

#include "cuiobj.h"
#include "cuiwnd.h"

//
// CUIFShadow
//  = shadow window class =
//

class CUIFShadow : public CUIFWindow
{
public:
    CUIFShadow( HINSTANCE hInst, DWORD dwStyle, CUIFWindow *pWndOwner );
    virtual ~CUIFShadow( void );

    //
    // CUIFObject methods
    //
    virtual CUIFObject *Initialize( void );
    virtual DWORD GetWndStyleEx( void );
    virtual void OnCreate( HWND hWnd );
    virtual void OnPaint( HDC hDC );
    virtual void Show( BOOL fShow );
    virtual LRESULT OnSettingChange( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    virtual LRESULT OnWindowPosChanging(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    //
    //
    //
    void OnOwnerWndMoved( BOOL fResized );
    void GetShift( SIZE *psize );

protected:
    CUIFWindow          *m_pWndOwner;
    COLORREF            m_color;
    int                 m_iGradWidth;
    int                 m_iAlpha;
    SIZE                m_sizeShift;
    BOOL                m_fGradient;

    void InitSettings( void );
    void AdjustWindowPos( void );
    void InitShadow( void );
};

#endif /* CUISHADW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuistr.h ===
//
// cuistr.h
//  = handling string functions in CUILIB =
//

#ifndef CUISTR_H
#define CUISTR_H

extern int CUIStrCmpW( const WCHAR *pwch1, const WCHAR *pwch2 );
extern WCHAR *CUIStrCpyW( WCHAR *pwchDst, const WCHAR *pwchSrc );
extern int CUIStrLenW( const WCHAR *pwch );


#define StrCmpW( pwch1, pwch2 )         CUIStrCmpW( (pwch1), (pwch2) )
#define StrCpyW( pwchDst, pwchSrc )     CUIStrCpyW( (pwchDst), (pwchSrc) )
#define StrLenW( pwch )                 CUIStrLenW( (pwch) )

#endif /* CUISTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuistr.cpp ===
//
// cuistr.cpp
//  = handling string functions in CUILIB =
//

#include "private.h"
#include "cuistr.h"


/*   C U I  S T R  C M P  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIStrCmpW( const WCHAR* pwch1, const WCHAR* pwch2 )
{
    while (*pwch1 && *pwch2 && (*pwch1 == *pwch2)) {
        pwch1++;
        pwch2++;
    }

    return (*pwch1 - *pwch2);
}


/*   C U I  S T R  C P Y  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
WCHAR* CUIStrCpyW( WCHAR *pwchDst, const WCHAR *pwchSrc )
{
    WCHAR *pwch = pwchDst;

    while (*pwch++ = *pwchSrc++);

    return pwchDst;
}


/*   C U I  S T R  L E N  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
int CUIStrLenW( const WCHAR *pwch )
{
    const WCHAR *pwchFirst = pwch;

    while (*pwch++);

    return (int)(UINT_PTR)(pwch - pwchFirst - (UINT_PTR)1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuisys.h ===
//
// cuisys.h
//

#ifndef CUISYS_H
#define CUISYS_H

//
// exported functions
//

extern void InitUIFSys( void );
extern void DoneUIFSys( void );
extern void UpdateUIFSys( void );

extern BOOL UIFIsWindowsNT( void );
extern BOOL UIFIsLowColor( void );
extern BOOL UIFIsHighContrast( void );

#endif /* CUISYS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuisys.cpp ===
//
// cuischem.cpp
//  = UIF scheme implementation = 
//

#include "private.h"
#include "cuisys.h"


//
// gloval variables
//

static class CUIFSystemInfo *vpSysInfo = NULL;


//
// misc def
//

#define COLOR_WHITE RGB( 0xFF, 0xFF, 0xFF )
#define COLOR_BLACK RGB( 0x00, 0x00, 0x00 )


/*=============================================================================*/
/*                                                                             */
/*   C  U I F  S Y S T E M  M E T R I C                                        */
/*                                                                             */
/*=============================================================================*/

//
// CUIFSystemInfo
//  = system info =
//

class CUIFSystemInfo
{
public:
    CUIFSystemInfo( void )
    {
        m_OSVerInfo.dwMajorVersion = 4;
        m_OSVerInfo.dwMinorVersion = 0;
        m_OSVerInfo.dwBuildNumber  = 0;
        m_OSVerInfo.dwPlatformId   = VER_PLATFORM_WIN32_WINDOWS;
        
        m_cBitsPixelScreen   = 8;
        m_fHighContrast      = FALSE;
        m_fHighContrastMenus = FALSE;
    }

    ~CUIFSystemInfo( void )
    {
    }

    void Initialize( void )
    {
        GetOSVersion();
        GetSystemMetrics();
    }

    void Update( void )
    {
        GetSystemMetrics();
    }

    __inline DWORD GetOSPlatformId( void )
    {
        return m_OSVerInfo.dwPlatformId;
    }

    __inline DWORD GetOSMajorVersion( void )
    {
        return m_OSVerInfo.dwMajorVersion;
    }

    __inline DWORD GetOSMinorVersion( void )
    {
        return m_OSVerInfo.dwMinorVersion;
    }
    
    __inline int GetBitsPixelScreen( void )
    {
        return m_cBitsPixelScreen;
    }

    __inline BOOL FHighContrast( void )
    {
        return m_fHighContrast;
    }

    __inline BOOL FHighContrastMenus( void )
    {
        return m_fHighContrastMenus;
    }

protected:
    OSVERSIONINFO m_OSVerInfo;
    int  m_cBitsPixelScreen;
    BOOL m_fHighContrast;
    BOOL m_fHighContrastMenus;

    void GetOSVersion( void )
    {
        m_OSVerInfo.dwOSVersionInfoSize = sizeof(m_OSVerInfo);
        GetVersionEx( &m_OSVerInfo );
    }

    void GetSystemMetrics( void )
    {
        HDC hDC = GetDC( NULL );
        COLORREF crBtnText;
        COLORREF crBtnFace;
        HIGHCONTRAST hicntr;
    
        // device caps
    
        m_cBitsPixelScreen = GetDeviceCaps( hDC, BITSPIXEL );
    
        // system paramater info
    
        MemSet( &hicntr, 0, sizeof(HIGHCONTRAST) );
        hicntr.cbSize = sizeof(HIGHCONTRAST);
        SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hicntr, 0 );
    
        m_fHighContrast = ((hicntr.dwFlags & HCF_HIGHCONTRASTON) != 0);
    
        // misc
    
        crBtnText = GetSysColor( COLOR_BTNTEXT );
        crBtnFace = GetSysColor( COLOR_BTNFACE );
    
        m_fHighContrastMenus = (m_fHighContrast ||
                                    ((crBtnText == COLOR_BLACK) && (crBtnFace == COLOR_WHITE)) ||
                                    ((crBtnText == COLOR_WHITE) && (crBtnFace == COLOR_BLACK)));
    
        // finished
    
        ReleaseDC( NULL, hDC );
    }
};


/*=============================================================================*/
/*                                                                             */
/*   E X P O R T E D  F U N C T I O N S                                        */
/*                                                                             */
/*=============================================================================*/

/*   I N I T  U I F  S Y S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void InitUIFSys( void )
{
    if (vpSysInfo = new CUIFSystemInfo())
        vpSysInfo->Initialize();
}


/*   D O N E  U I F  S Y S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void DoneUIFSys( void )
{
    if (vpSysInfo != NULL) {
        delete vpSysInfo;
        vpSysInfo = NULL;
    }
}


/*   U P D A T E  U I F  S Y S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
void UpdateUIFSys( void )
{
    if (vpSysInfo != NULL) {
        vpSysInfo->Update();
    }
}


/*   U I F  I S  W I N D O W S  N  T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL UIFIsWindowsNT( void )
{
    if (vpSysInfo != NULL) {
        return (vpSysInfo->GetOSPlatformId() == VER_PLATFORM_WIN32_NT);
    }
    else {
        return FALSE;
    }
}


/*   U I F  I S  L O W  C O L O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL UIFIsLowColor( void )
{
    if (vpSysInfo != NULL) {
        return (vpSysInfo->GetBitsPixelScreen() <= 8);
    }
    else {
        return TRUE;
    }
}


/*   U I F  I S  H I G H  C O N T R A S T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
BOOL UIFIsHighContrast( void )
{
    if (vpSysInfo != NULL) {
        return vpSysInfo->FHighContrastMenus();  // use FHighContrastMenus, not FHighContrast
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\ctf\cuilib\cuitb.cpp ===
//
// cuitb.cpp
//

#include "private.h"
#include "cuitb.h"
#include "cuiwnd.h"
#include "cuischem.h"
#include "cmydc.h"

HBRUSH CreateDitherBrush( void );

#if 0
void DrawDownTri(HDC hDC, RECT *prc)
{
    static HBITMAP hbmpTri = NULL;
    HBITMAP hbmpOld;
    HDC hdcMem = CreateCompatibleDC(hDC);

    if (!hdcMem)
        return;

    if (!hbmpTri)
    {
        HPEN hpen;
        HPEN hpenOld;
        const static RECT rcBmp = {0, 0, 6, 3};

        hpen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNTEXT));
        hbmpTri = CreateCompatibleBitmap(hDC, 5, 3);
        hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmpTri);

        FillRect( hdcMem, &rcBmp, (HBRUSH)(COLOR_3DFACE + 1) );
 
        hpenOld = (HPEN)SelectObject(hdcMem, hpen);

        MoveToEx(hdcMem, 0, 0, NULL);
        LineTo(hdcMem,   5, 0);
        MoveToEx(hdcMem, 1, 1, NULL);
        LineTo(hdcMem,   4, 1);
        MoveToEx(hdcMem, 2, 2, NULL);
        LineTo(hdcMem,   3, 2);
   
        SelectObject(hdcMem, hpenOld);

        DeleteObject(hpen);
    }
    else
        hbmpOld = (HBITMAP)SelectObject(hdcMem, hbmpTri);


    BitBlt(hDC, 
           prc->left + ((prc->right - prc->left) / 2) - 3,
           prc->top + ((prc->bottom - prc->top) / 2) - 1,
           5, 3,
           hdcMem,
           0, 0, SRCCOPY);

    SelectObject(hdcMem, hbmpOld);
    DeleteDC(hdcMem);
}
#endif

/*=============================================================================*/
/*                                                                             */
/*   C  U I  B U T T O N                                 