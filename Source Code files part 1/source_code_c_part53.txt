W);

           RECT rect;
           GetClientRect(hwnd,&rect);
           FillRect(
                        (HDC)wParam,
                        &rect,
                        static_cast<HBRUSH>
                        (
                           LongToHandle
                           (
                              ListView_GetBkColor(listHWnd)+1
                           )
                        )
                    );
           lResult=1;
           break;
           // NTRAID#NTBUG9-421812-2001/06/22-lucios - Begin
        case WM_PAINT:
        {
            HWND listHwnd;
            listHwnd=GetDlgItem(GetParent(hwnd),IDC_QUERY_LISTVIEW);

            HFONT hFont, hOldFont;
            RECT rcClient;
            PAINTSTRUCT paint;
            COLORREF oldFgColor, oldBkColor;

            BeginPaint(hwnd, &paint);

            hFont = (HFONT)SendMessage(listHwnd, WM_GETFONT, 0, 0L);
            hOldFont = (HFONT)SelectObject(paint.hdc, hFont);

            if ( hOldFont )
            {
                oldFgColor = SetTextColor(paint.hdc, GetSysColor(COLOR_WINDOWTEXT));
                oldBkColor = SetBkColor(paint.hdc, ListView_GetBkColor(listHwnd));

                int cch = GetWindowTextLength(hwnd);
                String strText;

                if (cch > 0)
                {
                    PWSTR pwz = new WCHAR [cch + 1];
                    // REVIEWED-2002-02-19-lucios. pwz has the correct size (cch+1)
                    int iRet = GetWindowText(hwnd, pwz, cch + 1);
                    if (iRet)
                    {
                        strText = pwz;
                    }
                    else
                    {
                        DBG_OUT_LASTERROR;
                    }
                    delete [] pwz;
                }

                if (!strText.empty())
                {
                    GetClientRect(hwnd, &rcClient);
                    int iRet;

                    // NTRAID#NTBUG9-421812-2001/06/22-lucios - Begin
                    // Now we center unconditionally since the previous calculation
                    // does not work for error messages with \n's
                    // REVIEWED-2002-02-19-lucios.
                    iRet = DrawTextEx(paint.hdc,
                                      const_cast<PWSTR>(strText.c_str()),
                                      cch,
                                      &rcClient,
                                      DT_WORDBREAK | DT_TOP |DT_CENTER,
                                      NULL);
                    // NTRAID#NTBUG9-421812-2001/06/22-lucios - End
                    if (!iRet)
                    {
                        DBG_OUT_LASTERROR;
                    }
                }

                SetTextColor(paint.hdc, oldFgColor);
                SetBkColor(paint.hdc, oldBkColor);
                SelectObject(paint.hdc, hOldFont);
            }

            EndPaint(hwnd, &paint);
            break;
        }

        case WM_SETTEXT:
        {
            InvalidateRect(hwnd, NULL, TRUE);
            //break;                                // deliberate drop through..
        }

        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return lResult;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_ShowBanner
//
//  Synopsis:   Show or hide the banner window.
//
//  Arguments:  [ulFlags]   - 0 to leave visibility unchanged
//                             SW_SHOW to make banner window visible
//                             SW_HIDE to hide banner window
//              [idsPrompt] - 0 or the ID of a resource string to load and
//                             display in the window.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_ShowBanner(
    ULONG ulFlags,
    ULONG idsPrompt)
{
    String strMsg;

    if (idsPrompt)
    {
        strMsg = String::load(static_cast<int>(idsPrompt));
    }

    _ShowBanner(ulFlags, strMsg);
}




/*-----------------------------------------------------------------------------
/ CAdvancedDlg::_ShowBanner
/ --------------------
/   Show the views banner, including sizing it to obscure only the top section
/   of the window.
/
/ In:
/   uFlags = flags to combine when calling SetWindowPos
/   idPrompt = resource ID of prompt text ot be displayed
/
/----------------------------------------------------------------------------*/
void
CAdvancedDlg::_ShowBanner(
    ULONG ulFlags,
    const String &strMsg)
{
    TRACE_METHOD(CAdvancedDlg, _ShowBanner);

    do
    {
        // NTRAID#NTBUG9-500661-2002/04/08-lucios
        // NTRAID#NTBUG9-513313-2002/04/08-lucios
        // NTRAID#NTBUG9-515793-2002/04/08-lucios
        // The code bellow is responsible for showing only the list view
        // header and redmensioning the banner when it is displayed. When
        // the banner should be hidden it restores the listbox.
        // It also toggles the TAB_STOP property of the banner and list box.
        if (!m_hwndBanner)
        {
            break;
        }

        RECT rcDlg;
        GetClientRect(m_hwnd, &rcDlg);
        HWND hwndList = _hCtrl(IDC_QUERY_LISTVIEW);
        
        if(!hwndList) return;

        RECT rcLv;
        _GetChildWindowRect(hwndList, &rcLv);
        RECT rcHeader;
        _GetChildWindowRect(ListView_GetHeader(hwndList),&rcHeader);
        int listYBorder=GetSystemMetrics(SM_CYEDGE) + GetSystemMetrics(SM_CYBORDER);

        if(ulFlags & SWP_SHOWWINDOW ||( (ulFlags==0) && IsWindowVisible(m_hwndBanner)) )
        {
            SetWindowPos(hwndList,
                HWND_TOP,
                0, 
                0,
                rcDlg.right - m_cxLvSeparation,
                rcHeader.bottom - rcHeader.top + listYBorder,
                SWP_SHOWWINDOW | 
                SWP_NOMOVE);
            

            SetWindowPos(m_hwndBanner,
                HWND_TOP,
                rcLv.left+m_cxLvSeparation, 
                rcHeader.bottom + listYBorder,
                rcDlg.right - m_cxLvSeparation, 
                rcDlg.bottom - rcLv.top - m_cyLvSeparation*2-(rcHeader.bottom-rcHeader.top),
                ulFlags);
            
            if (!strMsg.empty())
            {
                SetWindowText(m_hwndBanner, strMsg.c_str());
            }
            InvalidateRect(m_hwndBanner,NULL,true);

            DWORD dwStyle = GetWindowLong(hwndList, GWL_STYLE) & ~(WS_TABSTOP);
            SetWindowLong(hwndList, GWL_STYLE, dwStyle);
    
            dwStyle = GetWindowLong(m_hwndBanner, GWL_STYLE) | WS_TABSTOP;
            SetWindowLong(m_hwndBanner, GWL_STYLE, dwStyle);
        }
        else
        {
            SetWindowPos(hwndList,
                    NULL,
                    0,
                    0,
                    rcDlg.right - m_cxLvSeparation,
                    rcDlg.bottom - rcLv.top - m_cyLvSeparation,
                    SWP_NOMOVE
                    | SWP_NOOWNERZORDER
                    | SWP_NOCOPYBITS
                    | SWP_NOZORDER);
            ShowWindow(m_hwndBanner,SW_HIDE);
            
            DWORD dwStyle = GetWindowLong(hwndList, GWL_STYLE) | WS_TABSTOP;
            SetWindowLong(hwndList, GWL_STYLE, dwStyle);
    
            dwStyle = GetWindowLong(m_hwndBanner, GWL_STYLE) & ~(WS_TABSTOP);
            SetWindowLong(m_hwndBanner, GWL_STYLE, dwStyle);
        }

    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_UpdateColumns
//
//  Synopsis:   For all classes checked in the Look For since last visit,
//              add their default columns, remove columns that now refer
//              to classes which are no longer selected.
//
//  History:    06-15-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAdvancedDlg::_UpdateColumns()
{
    TRACE_METHOD(CAdvancedDlg, _UpdateColumns);

    HRESULT hr = S_OK;
    size_t i = 0;
    HWND hwndLV = _hCtrl(IDC_QUERY_LISTVIEW);

    //
    // If we're in downlevel mode, only two columns are allowed: name and
    // display path
    //

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
    {
        while (i < m_vakListviewColumns.size())
        {
            if (m_vakListviewColumns[i] != AK_NAME &&
                m_vakListviewColumns[i] != AK_DISPLAY_PATH)
            {
                ListView_DeleteColumn(hwndLV, i);
                m_vakListviewColumns.erase(m_vakListviewColumns.begin() + i);
            }
            else
            {
                i++;
            }
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_DISPLAY_PATH);
        m_ulPrevFilterFlags = 0;
        return hr;
    }

    //
    // For each of the selected classes that have been added since the
    // last time we were here, add the default set of attributes for that
    // class to the listview.
    //

    const CFilterManager &rfm = m_rop.GetFilterManager();
    ULONG ulCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();
    const CAttributeManager &ram = m_rop.GetAttributeManager();

    if ((ulCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS) &&
        !(m_ulPrevFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
    {
        _AddColIfNotPresent(AK_NAME);
    }

    if ((ulCurFilterFlags & DSOP_FILTER_USERS) &&
        !(m_ulPrevFilterFlags & DSOP_FILTER_USERS))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzUserObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_EMAIL_ADDRESSES);
    }

    if ((ulCurFilterFlags & DSOP_FILTER_COMPUTERS) &&
        !(m_ulPrevFilterFlags & DSOP_FILTER_COMPUTERS))
    {
        _AddColIfNotPresent(AK_NAME);
    }

    //NTRAID#NTBUG9-481117-2001/11/05-lucios
    if ((ulCurFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER) &&
    !(m_ulPrevFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzComputerObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_DESCRIPTION);
    }



    if ((ulCurFilterFlags & ALL_UPLEVEL_GROUP_FILTERS) &&
        !(m_ulPrevFilterFlags & ALL_UPLEVEL_GROUP_FILTERS))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzGroupObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_DESCRIPTION);
    }

    if ((ulCurFilterFlags & DSOP_FILTER_CONTACTS) &&
        !(m_ulPrevFilterFlags & DSOP_FILTER_CONTACTS))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzContactObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_SAMACCOUNTNAME);
        _AddColIfNotPresent(AK_EMAIL_ADDRESSES);
        _AddColIfNotPresent(AK_COMPANY);
    }

    _AddColIfNotPresent(AK_DISPLAY_PATH);

    m_ulPrevFilterFlags = ulCurFilterFlags;

    //
    // For each of the columns, if there are no selected classes in that
    // column's attribute's owning class list, remove that column.
    //

    vector<String> vstrSelectedClasses;
    String::EqualIgnoreCase comp;
    i = 0;

    ram.GetSelectedClasses(&vstrSelectedClasses);

    while (i < m_vakListviewColumns.size())
    {
        const vector<String> &vstrOwning =
            ram.GetOwningClasses(m_vakListviewColumns[i]);

        if (!vstrOwning.empty() && !vstrOwning[0].icompare(L"*"))
        {
            i++;
            continue;
        }

        vector<String>::const_iterator itFound;

        itFound = find_first_of(vstrOwning.begin(),
                                vstrOwning.end(),
                                vstrSelectedClasses.begin(),
                                vstrSelectedClasses.end(),
                                comp);

        if (itFound == vstrOwning.end())
        {
            ListView_DeleteColumn(hwndLV, i);
            m_vakListviewColumns.erase(m_vakListviewColumns.begin() + i);
        }
        else
        {
            i++;
        }
    }



    //
    // Insert new set of columns
    //
    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
        const String &strAttrDisplayName = ram.GetAttrDisplayName(m_vakListviewColumns[i]);
        LVCOLUMN col;
        // REVIEWED-2002-02-19-lucios.
        ZeroMemory(&col, sizeof col);
        col.mask = LVCF_TEXT;
        col.pszText = const_cast<PWSTR>(strAttrDisplayName.c_str());
        ListView_SetColumn(hwndLV,
            i,
            &col);
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_AddColIfNotPresent
//
//  Synopsis:   If the column with key [ak] isn't already in the vector of
//              attributes m_vakListViewColumns and to the listview itself.
//
//  Arguments:  [ak]   - ATTR_KEY of attribute to add
//              [iPos] - 0 based position to insert column into listview
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_AddColIfNotPresent(
    ATTR_KEY ak,
    int iPos)
{
    BOOL fAdded = AddIfNotPresent(&m_vakListviewColumns, ak);

    if (!fAdded)
    {
        return;
    }

    _AddColToListview(ak, iPos);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_AddColToListview
//
//  Synopsis:   Add column with key [ak] to listview at position [iPos].
//
//  Arguments:  [ak]   - ATTR_KEY representing attribute
//              [iPos] - 0 based position to insert column into listview
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_AddColToListview(
    ATTR_KEY ak,
    int iPos)
{
    LV_COLUMN   lvc;
    // REVIEWED-2002-02-19-lucios.
    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;
    lvc.cx = 100;

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    const String &strAttrDisplayName = ram.GetAttrDisplayName(ak);

    lvc.pszText = const_cast<PWSTR>(strAttrDisplayName.c_str());
    int iResult = ListView_InsertColumn(_hCtrl(IDC_QUERY_LISTVIEW),
                                        iPos,
                                        &lvc);
    if (iResult == -1)
    {
        DBG_OUT_LASTERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <shlwapi.h>
#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>

#if DBG==1


    #include "malloc.h" // alloca

//
//  Globals
//

ULONG g_AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL  g_fInitializedTickCount = FALSE;
ULONG g_ulTickCountAtStart;
BOOL  g_fCritSecInit = FALSE;
CRITICAL_SECTION g_csMessageBuf;
static TCHAR g_szMessageBuf[2048];        // this is the message buffer

DECLARE_HEAPCHECKING;

//
//  Forward declration of local functions
//

LPCSTR AnsiPathFindFileName(LPCSTR pPath);
void  InitializeDebugging(void);
void  smprintf(ULONG ulCompMask, ULONG cchIndent, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
static int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

static int __cdecl w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4smprintf(LPTSTR  format, va_list arglist)
{
    int ret;

    EnterCriticalSection(&g_csMessageBuf);
    //NTRAID#NTBUG9-548039-2002/02/19-lucios. Pending fix.
    ret = wvsprintf(g_szMessageBuf,
                    format,
                    arglist);
    OutputDebugString(g_szMessageBuf);
    LeaveCriticalSection(&g_csMessageBuf);
    return ret;
}




//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

CRITICAL_SECTION g_csDebugPrint;

void smprintf(
             ULONG ulCompMask,
             ULONG cchIndent,
             LPTSTR  pszComp,
             LPTSTR  ppszfmt,
             va_list pargs)
{
    if (ulCompMask & DEB_FORCE)
    {
        EnterCriticalSection(&g_csDebugPrint);

        if (ulCompMask & DEB_ELAPSEDTIME)
        {
            ULONG ulTicksNow = GetTickCount();

            if (!g_fInitializedTickCount)
            {
                g_fInitializedTickCount = TRUE;
                g_ulTickCountAtStart = ulTicksNow;
            }

            ULONG ulDelta;

            if (g_ulTickCountAtStart > ulTicksNow)
            {
                ulDelta = ulTicksNow + ((ULONG)-1) - g_ulTickCountAtStart;
            }
            else
            {
                ulDelta = ulTicksNow - g_ulTickCountAtStart;
            }
            w4dprintf(_T("%04u.%03u "), ulDelta / 1000, ulDelta % 1000);
        }

        if (!(ulCompMask & DEB_NOCOMPNAME))
        {
            DWORD pid = GetCurrentProcessId();
            DWORD tid = GetCurrentThreadId();

            w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
        }

        if (cchIndent)
        {
            TCHAR tzFmt[] = _T("%999s");
            //NTRAID#NTBUG9-548039-2002/02/19-lucios. Pending fix.
            wsprintf(tzFmt, _T("%%%us"), cchIndent);
            w4dprintf(tzFmt, _T(""));
        }
        w4smprintf(ppszfmt, pargs);

        LeaveCriticalSection(&g_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

    #define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
    #define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
    #define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    if (!g_fCritSecInit) InitializeDebugging();

    *pulInfoLevel = DEF_INFOLEVEL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        ADMINDEBUGKEY,
                        0,
                        KEY_READ,
                        &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                            KEY_ALL_ACCESS, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                                  REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        //REVIEWED-2002-02-19-lucios.
        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                               (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            //REVIEWED-2002-02-19-lucios.
            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                                 (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}

void InitializeDebugging(void)
{
    if (g_fCritSecInit) return;
    //NTRAID#NTBUG9-548146-2002/02/19-lucios. Pending fix.
    InitializeCriticalSection(&g_csMessageBuf);
    InitializeCriticalSection(&g_csDebugPrint);
    g_fCritSecInit = TRUE;
}



// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPCSTR AnsiPathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath))
    {
        if ((pPath[0] == '\\' || pPath[0] == ':')
            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return(LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];

    //
    // get process
    //

    static String wszModuleName;
    LPCSTR pszModuleName="Unknown";
    AnsiString szModuleName;
    
        // NTRAID#NTBUG9-550604-2002/02/20-lucios. Pending fix.
    if ( SUCCEEDED(MyGetModuleFileName(NULL, wszModuleName)) )
    {
        if( wszModuleName.convert(szModuleName)==String::CONVERT_SUCCESSFUL )
        {
            pszModuleName = szModuleName.c_str();
        }
    }

    LPCSTR pProcess = AnsiPathFindFileName(pszModuleName);

    //NTRAID#NTBUG9-548039-2002/02/19-lucios. Pending fix.
    wsprintf(szAssertCaption, _T("%hs: Assertion Failed"), pProcess);


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    //NTRAID#NTBUG9-548039-2002/02/19-lucios. Pending fix.
    wsprintf(szDetails, _T(" Assertion:\t %s\n\n")       \
             _T(" File:   \t\t %hs\n")        \
             _T(" Line:   \t\t %d\n\n")       \
             _T(" Module:   \t %hs\n")        \
             _T(" Thread ID:\t %d.%d\n"),
             szMsg, szFile, iLine, pszModuleName, pid, tid);


    int id = MessageBox(NULL,
                        szDetails,
                        szAssertCaption,
                        MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                            | MB_TASKMODAL
                            | MB_ICONEXCLAMATION
                            | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void __cdecl _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, 0, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (g_AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPCSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
                   szMessage, pszFileName, iLine, tid);
    }

    if (g_AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (g_AdminAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________



CDbg::CDbg(LPTSTR  str)
    :
m_InfoLevelString(str),
    m_flInfoLevel(DEF_INFOLEVEL),
    m_flOutputOptions(0)
{
    ULONG flRegistry = 0;

    CheckInit(m_InfoLevelString, &flRegistry);

    m_flInfoLevel = flRegistry & DEB_FORCE;
    m_flOutputOptions = flRegistry & ~DEB_FORCE;
}

CDbg::~CDbg()
{
}


void __cdecl CDbg::Trace(LPSTR pszfmt, ...)
{
#ifdef UNICODE
    ULONG convert = static_cast<ULONG>(strlen(pszfmt)) + 1;
    LPTSTR ptcfmt=NULL;
    __try 
    {
        ptcfmt = (PWSTR)alloca(convert * sizeof(WCHAR));
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) 
    {
        ptcfmt = NULL;
    }
    ASSERT(ptcfmt!=NULL);
    ptcfmt[0] = '\0';
    // ASSERT is not enough!
    // NTRAID#NTBUG9-548193-2002/02/19-lucios. Pending fix.
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_flInfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pszfmt);
        ULONG cchIndent = _GetIndent();
        smprintf(DEB_TRACE, cchIndent, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void __cdecl CDbg::Trace(PWSTR pwzfmt, ...)
{
#ifndef UNICODE
    //REVIEWED-2002-02-19-lucios.
    int convert = wcslen(pwzfmt) + 1;
    LPTSTR ptcfmt = NULL;
    __try 
    {
        ptcfmt = (PWSTR)alloca(convert * sizeof(WCHAR));
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) 
    {
        ptcfmt = NULL;
    }
    // ASSERT is not enough!
    // NTRAID#NTBUG9-548193-2002/02/19-lucios. Pending fix.
    ASSERT(ptcfmt!=NULL);

    ptcfmt[0] = '\0';
    //REVIEWED-2002-02-19-lucios.
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    if (m_flInfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pwzfmt);
        ULONG cchIndent = _GetIndent();
        smprintf(DEB_TRACE, cchIndent, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void __cdecl CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    ULONG convert = static_cast<ULONG>(strlen(pszfmt)) + 1;
    LPTSTR ptcfmt = NULL;
    __try 
    {
        ptcfmt = (PWSTR)alloca(convert * sizeof(WCHAR));
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) 
    {
        ptcfmt = NULL;
    }
    // ASSERT is not enough!
    // NTRAID#NTBUG9-548193-2002/02/19-lucios. Pending fix.
    ASSERT(ptcfmt!=NULL);
    ptcfmt[0] = '\0';
    //REVIEWED-2002-02-19-lucios.
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    va_list va;
    va_start (va, pszfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
}

void __cdecl CDbg::DebugOut(ULONG fDebugMask, PWSTR pwzfmt, ...)
{
#ifndef UNICODE
    //REVIEWED-2002-02-19-lucios.
    int convert = wcslen(pwzfmt) + 1;
    // NTRAID#NTBUG9-548193-2002/02/19-lucios. Pending fix.
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    //REVIEWED-2002-02-19-lucios.
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    va_list va;
    va_start (va, pwzfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        LPCSTR fileName = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                       err, fileName, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        LPCSTR fileName = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, fileName, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    LPCSTR fileName = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", fileName, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, PWSTR  msg)
{
    LPCSTR fileName = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), fileName, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
#if 0
    LPTSTR ptcMsg = NULL;

#ifdef UNICODE
    int convert = strlen(pszMsg) + 1;
    // NTRAID#NTBUG9-548193-2002/02/19-lucios. Pending fix.
    ptcMsg = (PWSTR)alloca(convert * sizeof(WCHAR));
    ptcMsg[0] = '\0';
    //REVIEWED-2002-02-19-lucios.
    (void) MultiByteToWideChar(CP_ACP, 0, pszMsg, -1, ptcMsg, convert);
#else
    ptcMsg = pszMsg;
#endif

    AdminAssertEx(pszFile, iLine, ptcMsg);
#endif //0

    AdminAssertEx(pszFile, iLine, pszMsg);

}


ULONG
    CDbg::_GetIndent()
{
    ULONG cchIndent = 0;

    if (s_idxTls != 0xFFFFFFFF)
    {
        cchIndent = static_cast<ULONG>
                        (reinterpret_cast<ULONG_PTR>
                            (TlsGetValue(s_idxTls)));
    }
    return cchIndent;
}

void CDbg::IncIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent++;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}

void CDbg::DecIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent--;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}




#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#if DBG==1

class CDbg
{
public:
    CDbg(LPTSTR str);
   ~CDbg();

    void __cdecl Trace(PWSTR pszfmt, ...);
    void __cdecl Trace(LPSTR pszfmt, ...);
    void __cdecl DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void __cdecl DebugOut(unsigned long fDebugMask, PWSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, PWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);
    void IncIndent();
    void DecIndent();

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

    static ULONG s_idxTls;

private:

    ULONG
    _GetIndent();

    unsigned long   m_flInfoLevel; // must be the first data member
    unsigned long   m_flOutputOptions;
    LPTSTR          m_InfoLevelString;
};  // class CDbg

class CIndenter
{
public:

    CIndenter(CDbg *pdbg): m_pDbg(pdbg) { m_pDbg->IncIndent(); }
    ~CIndenter() { m_pDbg->DecIndent(); m_pDbg = NULL; }

private:

    CDbg *m_pDbg;
};

#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG==1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG==1





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined

#define DEB_FUNCTION        0x00800000
#define DEB_RESOURCE        0x01000000
#define DEB_METHOD          0x02000000
#define DEB_DSOBJECT        0x04000000
#define DEB_DATAOBJECT      0x08000000
#define DEB_RICHEDIT        0x10000000      // text processing
#define DEB_ELAPSEDTIME     0x20000000      // output elapsed time
#define DEB_NOCOMPNAME      0x40000000      // suppress component name

#define DEB_FORCE           0x1fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#ifndef DEF_INFOLEVEL
#define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\basedlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       BaseDlg.cxx
//
//  Contents:   Implementation of class to drive the base object picker
//              dialog.
//
//  Classes:    CBaseDlg
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

static ULONG
s_aulHelpIds[] =
{
    IDC_OBJECT_TYPE_LBL,    IDH_LOOK_FOR_EDIT,
    IDC_LOOK_FOR_PB,        IDH_LOOK_FOR_PB,
    IDC_LOOK_FOR_EDIT,      IDH_LOOK_FOR_EDIT,
    IDC_LOOK_IN_PB,         IDH_LOOK_IN_PB,
    IDC_LOCATION_LBL,       IDH_LOOK_IN_EDIT,
    IDC_LOOK_IN_EDIT,       IDH_LOOK_IN_EDIT,
    IDC_NAME_LBL,           IDH_NAME_LBL,
    IDC_RICHEDIT,           IDH_RICHEDIT,
    IDC_CHECK_NAMES_PB,     IDH_CHECK_NAMES_PB,
    IDC_ADVANCED_PB,        IDH_ADVANCED_PB,
    0,0
};


#define CY_SLE_IN_DLUS      6


#define LINKWINDOW_CLASSW       L"Link Window"



//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::CBaseDlg
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - reference to owning CObjectPicker instance
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CBaseDlg::CBaseDlg(
    const CObjectPicker &rop):
        m_rop(rop),
        m_AdvancedDlg(rop)
{
    TRACE_CONSTRUCTOR(CBaseDlg);

    Clear();
}



//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::Clear
//
//  Synopsis:   Reset all internal variables (used for both initialization
//              and shutdown).
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::Clear()
{
    TRACE_METHOD(CBaseDlg, Clear);

    m_hpenUnderline = NULL;
    m_ppdoSelections = NULL;
    m_cxMin = 0;
    m_cyMin = 0;
    m_cxSeparation = 0;
    m_cySeparation = 0;
    m_cxFrameLast = 0;
    m_cyFrameLast = 0;
    m_cxFour = 0;
    m_fMultiSelect = FALSE;
    m_rpRichEditOle = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::DoModal
//
//  Synopsis:   Create the modal base dialog.
//
//  Arguments:  [ppdoSelections] - filled with resulting selections if
//                                  return value is S_OK.
//
//  Returns:    S_OK    - user made selections and hit OK, *[ppdoSelections]
//                          is valid and caller must Release() it.
//              S_FALSE - user hit Cancel button, *[ppdoSelections] is NULL.
//              E_*     - error occurred, *[ppdoSelections] is NULL.
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBaseDlg::DoModal(
    IDataObject **ppdoSelections) const
{
    TRACE_METHOD(CBaseDlg, DoModal);

    m_ppdoSelections = ppdoSelections;
    INT_PTR pi = _DoModalDlg(m_rop.GetParentHwnd(), IDD_STANDALONE_TEXT);
    m_ppdoSelections = NULL;
    return static_cast<HRESULT>(pi);
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnInit
//
//  Synopsis:   Handle WM_INITDIALOG.
//
//  Arguments:  [pfSetFocus] - set to FALSE if focus changed.
//
//  Returns:    S_OK
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBaseDlg::_OnInit(
        BOOL *pfSetFocus)
{
    TRACE_METHOD(CBaseDlg, _OnInit);

    //
    // Make prefix shut up
    //

    if (!_hCtrl(IDC_RICHEDIT) ||
        !_hCtrl(IDC_CHECK_NAMES_PB) ||
        !_hCtrl(IDOK) ||
        !_hCtrl(IDC_SIZEGRIP))
    {
        return E_FAIL;
    }

    if (m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT)
    {
        m_fMultiSelect = TRUE;
    }
    else
    {
        m_fMultiSelect = FALSE;
    }

    //
    // Init data needed for sizing.
    //
    // First translate the separation distance between controls from
    // dialog units to pixels.
    //

    RECT rc;

    rc.left = rc.top = 1;
    rc.right = DIALOG_SEPARATION_X;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxSeparation = rc.right;
    m_cySeparation = rc.bottom;

    rc.left = rc.top = 1;
    rc.right = 4;
    rc.bottom = 4;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxFour = rc.right;

    //
    // Next shrink the dialog if we're in single select mode; the rich
    // edit should be the height of an SLE (14 DLUs).
    //

    if (!m_fMultiSelect)
    {
        //
        // Replace multiselect instruction text with single-select instruction
        // text.
        //

        String strText(String::load(IDS_SINGLE_SELECT_INSTRUCTIONS));

        if (!strText.empty())
        {
            Static_SetText(_hCtrl(IDC_NAME_LBL), strText.c_str());
        }
    }

    GetClientRect(m_hwnd, &rc);

    //
    // Now save the starting size; _OnMinMaxInfo will prevent the dialog
    // from being sized smaller than this.
    //

    m_cxFrameLast = rc.right;
    m_cyFrameLast = rc.bottom;

    GetWindowRect(m_hwnd, &rc);
    m_cxMin = rc.right - rc.left + 1;
    m_cyMin = rc.bottom - rc.top + 1;

    //
    // Get rich edit's ole interface, give it our callback
    //

    HWND hRichEdit = _hCtrl(IDC_RICHEDIT);
    if(!hRichEdit) return E_FAIL;

    ASSERT(!m_rpRichEditOle.get());
    LRESULT lResult = SendMessage(hRichEdit,
                                 EM_GETOLEINTERFACE,
                                 0,
                                 (LPARAM) &m_rpRichEditOle);

    if (!lResult)
    {
        DBG_OUT_LASTERROR;
        return HRESULT_FROM_LASTERROR;
    }
    ASSERT(m_rpRichEditOle.get());

    SendMessage( hRichEdit,EM_LIMITTEXT,0x7FFFFFFE,0);


    CRichEditOleCallback *pRichEditOleCallback =
        new CRichEditOleCallback(hRichEdit);

    SendMessage(hRichEdit,
                EM_SETOLECALLBACK,
                0,
                (LPARAM) pRichEditOleCallback);

    pRichEditOleCallback->Release();

    SendMessage(hRichEdit,
                EM_SETEVENTMASK,
                0,
                (LPARAM) ENM_CHANGE);

    //
    // Subclass the rich edit control for keystroke notification and
    // Enter key forwarding.
    //
    SetWindowLongPtr(hRichEdit, GWLP_USERDATA, (LONG_PTR) this);

    m_OriginalRichEditWndProc = (WNDPROC) SetWindowLongPtr(hRichEdit,
                                                   GWLP_WNDPROC,
                                                   (LONG_PTR)_EditWndProc);

    //
    // Init Look For readonly edit control, Look In readonly edit control,
    // and window caption.
    //

    UpdateLookForInText(m_hwnd, m_rop);

#if (DBG == 1)
    const CFilterManager &rfm = m_rop.GetFilterManager();
    Dbg(DEB_TRACE,
        "UA: initial Look For setting '%ws'\n",
        rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());

    const CScopeManager &rsm = m_rop.GetScopeManager();
    Dbg(DEB_TRACE,
        "UA: initial Look In setting '%ws'\n",
         rsm.GetCurScope().GetDisplayName().c_str());
#endif // (DBG == 1)

    m_hpenUnderline = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));

    // these are disabled till user types something
    SafeEnableWindow(_hCtrl(IDC_CHECK_NAMES_PB), FALSE);
    SafeEnableWindow(_hCtrl(IDOK), FALSE);

    //
    // Set the focus to the rich edit control
    //

#if (DBG == 1)
    HWND hwndPrev =
#endif
    SetFocus(hRichEdit);
#if (DBG == 1)
    if (!hwndPrev)
    {
        DBG_OUT_LASTERROR;
    }
#endif
    *pfSetFocus = FALSE;

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnSysColorChange
//
//  Synopsis:   Update the pen used for drawing objects in the rich edit
//              control.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::_OnSysColorChange()
{
    TRACE_METHOD(CBaseDlg, _OnSysColorChange);

    if (m_hpenUnderline)
    {
        VERIFY(DeleteObject(m_hpenUnderline));
    }
    m_hpenUnderline = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));
}



//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnDestroy
//
//  Synopsis:   Free resources on dialog destruction
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::_OnDestroy()
{
    TRACE_METHOD(CBaseDlg, _OnDestroy);

    if (m_hpenUnderline)
    {
        VERIFY(DeleteObject(m_hpenUnderline));
    }
    Clear();
}


//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBaseDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDC_LOOK_IN_PB:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Look In button\n");

        m_rop.GetScopeManager().DoLookInDialog(m_hwnd);
        m_rop.GetFilterManager().HandleScopeChange(m_hwnd);
        UpdateLookForInText(m_hwnd, m_rop);
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;

    case IDC_LOOK_FOR_PB:
    {
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Look For button\n");
        const CFilterManager &rfm = m_rop.GetFilterManager();

        rfm.DoLookForDialog(m_hwnd);

        Edit_SetText(_hCtrl(IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;
    }

    case IDC_CHECK_NAMES_PB:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Check Names button\n");
        m_rop.ProcessNames(_hCtrl(IDC_RICHEDIT), this);
        UpdateLookForInText(m_hwnd, m_rop);
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;

    case IDC_ADVANCED_PB:
    {
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Advanced button\n");
        vector<CDsObject>   vSelectedObjects;

        m_AdvancedDlg.DoModalDlg(m_hwnd, &vSelectedObjects);
        UpdateLookForInText(m_hwnd, m_rop);

        //
        // Add all selected objects to richedit
        //

        HWND hwndRichEdit = _hCtrl(IDC_RICHEDIT);
        IRichEditOle *pRichEditOle = NULL;
        LRESULT lResult = SendMessage(hwndRichEdit,
                                     EM_GETOLEINTERFACE,
                                     0,
                                     (LPARAM) &pRichEditOle);
        if (!lResult)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        CRichEditHelper re(m_rop, hwndRichEdit, this, pRichEditOle, FALSE);
        LONG cpEnd;
        CHARRANGE chrg;

        bool fNeedDelim = FALSE;
        
        if (m_fMultiSelect)
        {
            // append the new objects.
            
           LRESULT cchInEdit = SendMessage(hwndRichEdit,
                                           WM_GETTEXTLENGTH,
                                           0,
                                           0);

           SendMessage(hwndRichEdit, EM_SETSEL, cchInEdit, cchInEdit);

           fNeedDelim = (cchInEdit != 0);
        }
        else
        {
            // replace the old objects with the new ones
            // NTRAID#NTBUG9-191537-2000/11/13-sburns
            
            if (vSelectedObjects.size())
            {
               re.Erase(re.begin(), re.end());
            }
        }

        SendMessage(hwndRichEdit,
                    EM_EXGETSEL,
                    0,
                    reinterpret_cast<LPARAM>(&chrg));
        cpEnd = chrg.cpMax;

        for (size_t i = 0; i < vSelectedObjects.size(); i++)
        {
            if (!re.AlreadyInRichEdit(vSelectedObjects[i]))
            {
                if (fNeedDelim)
                {
                    re.Insert(cpEnd, L"; ");
                    cpEnd += 2;
                }
                re.InsertObject(cpEnd++, vSelectedObjects[i]);
                fNeedDelim = TRUE;
            }
        }

        SAFE_RELEASE(pRichEditOle);
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;
    }

    case IDC_RICHEDIT:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            BOOL fNonEmpty = Edit_GetTextLength(_hCtrl(IDC_RICHEDIT));
            SafeEnableWindow(_hCtrl(IDOK), fNonEmpty);

            // if the check names button has the focus, put it in
            // the richedit before disabling the button

            if (GetFocus() == _hCtrl(IDC_CHECK_NAMES_PB))
            {
                SetFocus(_hCtrl(IDC_RICHEDIT));
            }
            SafeEnableWindow(_hCtrl(IDC_CHECK_NAMES_PB), fNonEmpty);
        }
        break;

    case IDM_CUT:
        Dbg(DEB_TRACE, "UA: (BaseDlg) selected rich edit cmenu CUT\n");
        SendMessage(_hCtrl(IDC_RICHEDIT), WM_CUT, 0, 0);
        break;

    case IDM_COPY:
        Dbg(DEB_TRACE, "UA: (BaseDlg) selected rich edit cmenu COPY\n");
        SendMessage(_hCtrl(IDC_RICHEDIT), WM_COPY, 0, 0);
        break;

    case IDM_PASTE:
        Dbg(DEB_TRACE, "UA: (BaseDlg) selected rich edit cmenu PASTE\n");
        SendMessage(_hCtrl(IDC_RICHEDIT), WM_PASTE, 0, 0);
        break;

    case IDOK:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit OK\n");
        if (m_rop.ProcessNames(_hCtrl(IDC_RICHEDIT), this))
        {
            //
            //Only one object can be returned in case of single select
            //
            if(m_rpRichEditOle->GetObjectCount() > 1 && !m_fMultiSelect)
            {
                PopupMessage(m_hwnd,IDS_SINGLE_SEL_MSG);
            }
            else
            {
                HRESULT hr = _CreateDataObjectFromSelections();
                BREAK_ON_FAIL_HRESULT(hr);
                EndDialog(GetHwnd(), hr);
            }
        }
        else
        {
            UpdateLookForInText(m_hwnd, m_rop);
            SetFocus(_hCtrl(IDC_RICHEDIT));
        }
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Cancel\n");
        EndDialog(GetHwnd(), S_FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CBaseDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}

BOOL
CBaseDlg::_OnNotify(WPARAM wParam, LPARAM lParam)
{
    if(wParam == IDC_NAME_LBL)
    {
        switch (((NMHDR FAR*)lParam)->code)
        {
            //
            //Show the help popup for Examples
            //
        case NM_CLICK:
        case NM_RETURN:
            {
                WinHelp(_hCtrl((ULONG)wParam),
                    c_wzHelpFilename,
                    HELP_WM_HELP,
                    (DWORD_PTR) s_aulHelpIds);

                return TRUE;
            }
            break;
        }
    }
    return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_CreateDataObjectFromSelections
//
//  Synopsis:   Create a data object, which caller can use, containing
//              entries for all objects the user has selected.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBaseDlg::_CreateDataObjectFromSelections()
{
    TRACE_METHOD(CBaseDlg, _CreateDataObjectFromSelections);

    LONG cObjects = m_rpRichEditOle->GetObjectCount();
    CDsObjectList dsol;
    LONG i;

    ASSERT(cObjects > 0);

    *m_ppdoSelections = NULL;

    for (i = 0; i < cObjects; i++)
    {
        REOBJECT reobj;
        HRESULT hr;

        ZeroMemory(&reobj, sizeof reobj);
        reobj.cbStruct = sizeof(reobj);

        hr = m_rpRichEditOle->GetObject(i, &reobj, REO_GETOBJ_POLEOBJ);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            continue;
        }

        ASSERT(reobj.poleobj);

        CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;
        dsol.push_back(*pdso);
        reobj.poleobj->Release();
    }

    CDsObjectList okObjects;
    AddSidOkSelection
    (
        dsol,
        m_rop.GetTargetComputer().c_str(),
        okObjects,
        m_hwnd
    );
    if(okObjects.size()==0) return S_FALSE;

    CObjectPicker *pop = const_cast<CObjectPicker *>(&m_rop);
    *m_ppdoSelections = new CDataObject(pop, okObjects);

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnSize
//
//  Synopsis:   Handle window resizing
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBaseDlg::_OnSize(
    WPARAM wParam,
    LPARAM lParam)
{
    WORD nWidth = LOWORD(lParam);  // width of client area
    WORD nHeight = HIWORD(lParam); // height of client area

    //
    // Move the OK/Cancel buttons so they're always at lower right
    // corner of dialog.
    //

    RECT rcDlg;
    GetClientRect(m_hwnd, &rcDlg);

    if (!m_cxFrameLast || !m_cyFrameLast)
    {
        m_cxFrameLast = rcDlg.right;
        m_cyFrameLast = rcDlg.bottom;
        return TRUE;
    }

    RECT rcCancel;
    GetWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDCANCEL),
                 NULL,
                 rcDlg.right - WindowRectWidth(rcCancel) - m_cxSeparation,
                 rcDlg.bottom - WindowRectHeight(rcCancel) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcOKWR;
    GetWindowRect(_hCtrl(IDOK), &rcOKWR);
    _GetChildWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDOK),
                 NULL,
                 rcCancel.left - WindowRectWidth(rcOKWR) - m_cxFour,
                 rcDlg.bottom - WindowRectHeight(rcOKWR) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Advanced buttons so they its always at lower left
    // corner of dialog.
    //
    RECT rcAdvanced;

    _GetChildWindowRect(_hCtrl(IDC_ADVANCED_PB), &rcAdvanced);

    SetWindowPos(_hCtrl(IDC_ADVANCED_PB),
                 NULL,
                 rcAdvanced.left,
                 rcDlg.bottom - WindowRectHeight(rcOKWR) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Move the check names, object types and Locations 
    // buttons so their right edge stays aligned with right edge of Cancel
    // button.
    //

   
    //
    //check names button
    //
    RECT rcCheckNames;
    _GetChildWindowRect(_hCtrl(IDC_CHECK_NAMES_PB), &rcCheckNames);
    RECT rcCheckNamesWR;
    GetWindowRect(_hCtrl(IDC_CHECK_NAMES_PB), &rcCheckNamesWR);

    SetWindowPos(_hCtrl(IDC_CHECK_NAMES_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcCheckNamesWR),
                 rcCheckNames.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    //object types button
    //
    RECT rcObjectType;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_PB), &rcObjectType);
    RECT rcObjectTypeWR;
    GetWindowRect(_hCtrl(IDC_LOOK_FOR_PB), &rcObjectTypeWR);

    SetWindowPos(_hCtrl(IDC_LOOK_FOR_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcObjectTypeWR),
                 rcObjectType.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    //Locations button
    //
    RECT rcLocations;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_PB), &rcLocations);
    RECT rcLocationsWR;
    GetWindowRect(_hCtrl(IDC_LOOK_IN_PB), &rcLocationsWR);

    SetWindowPos(_hCtrl(IDC_LOOK_IN_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcLocationsWR),
                 rcLocations.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    

    //
    // resize look in and look for edit so its right edge is aligned with 
    // left edge of checkname - minimum x separation
    //

    _GetChildWindowRect(_hCtrl(IDC_CHECK_NAMES_PB), &rcCheckNames);

    RECT rcLookInEdit;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_EDIT), &rcLookInEdit);

    SetWindowPos(_hCtrl(IDC_LOOK_IN_EDIT),
                 NULL,
                 0,
                 0,
                 rcCheckNames.left - rcLookInEdit.left - m_cxFour,
                 rcLookInEdit.bottom - rcLookInEdit.top,
                 SWP_NOMOVE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    RECT rcLookForEdit;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_EDIT), &rcLookForEdit);

    SetWindowPos(_hCtrl(IDC_LOOK_FOR_EDIT),
                 NULL,
                 0,
                 0,
                 rcCheckNames.left - rcLookForEdit.left - m_cxFour,
                 rcLookForEdit.bottom - rcLookForEdit.top,
                 SWP_NOMOVE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // resize rich edit so its bottom edge is just above top of OK
    //

    RECT rcRichEdit;
    RECT rcOK;
    _GetChildWindowRect(_hCtrl(IDC_RICHEDIT), &rcRichEdit);
    _GetChildWindowRect(_hCtrl(IDOK), &rcOK);

    SetWindowPos(_hCtrl(IDC_RICHEDIT),
                    NULL,
                    0,
                    0,
                    rcCheckNames.left - rcRichEdit.left - m_cxFour,
                    rcOK.top - rcRichEdit.top - m_cySeparation,
                    SWP_NOMOVE
                    | SWP_NOCOPYBITS
                    | SWP_NOZORDER);

    //
    // Size gripper goes in bottom right corner
    //

    RECT rc;

    _GetChildWindowRect(_hCtrl(IDC_SIZEGRIP), &rc);

    SetWindowPos(_hCtrl(IDC_SIZEGRIP),
                 NULL,
                 nWidth - (rc.right - rc.left),
                 nHeight - (rc.bottom - rc.top),
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOZORDER);
    
    m_cxFrameLast = rcDlg.right;
    m_cyFrameLast = rcDlg.bottom;
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnMinMaxInfo
//
//  Synopsis:   Enforce minimum window size
//
//  Arguments:  [lpmmi] - from WM_SIZE message
//
//  Returns:    FALSE if dialog has valid size constraints to return.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBaseDlg::_OnMinMaxInfo(
    LPMINMAXINFO lpmmi)
{
    //
    // If we haven't gotten WM_INITDIALOG and set m_cxMin yet, we don't
    // know what the min size will be, so return nonzero to indicate we
    // didn't process this message.

    if (!m_cxMin) 
    {
        return TRUE;
    }

    lpmmi->ptMinTrackSize.x = m_cxMin;
    lpmmi->ptMinTrackSize.y = m_cyMin;
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_EditWndProc
//
//  Synopsis:   Subclassing window proc for rich edit control.
//
//  Arguments:  Standard Windows.
//
//  Returns:    Standard Windows.
//
//  History:    4-20-1999   DavidMun   Created
//
//  Notes:      If the user hits the Enter key and the OK button is enabled,
//              posts a press of that button to the main window.
//
//              Forwards everything except VK_RETURN keys to rich edit
//              window proc.
//
//---------------------------------------------------------------------------

LRESULT CALLBACK
CBaseDlg::_EditWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT         lResult = 0;
    BOOL            fCallWinProc = TRUE;
    CBaseDlg       *pThis =
        reinterpret_cast<CBaseDlg *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (msg)
    {
    case WM_KEYDOWN:
        if (wParam == VK_RETURN)
        {
            fCallWinProc = FALSE;
        }
        break;

    case WM_CHAR:
        if (wParam == VK_RETURN)
        {
            HWND hwndFrame = GetParent(hwnd);
            HWND hwndOK = GetDlgItem(hwndFrame, IDOK);

            if (IsWindowEnabled(hwndOK))
            {
                Dbg(DEB_TRACE, "CDsSelectDlg::_EditWndProc: Forwarding Return key\n");
                PostMessage(hwndFrame,
                            WM_COMMAND,
                            MAKEWPARAM(IDOK, BN_CLICKED),
                            (LPARAM) hwndOK);
            }
        }
        break;
    }

    if (fCallWinProc)
    {
        lResult = CallWindowProc(pThis->m_OriginalRichEditWndProc,
                                 hwnd,
                                 msg,
                                 wParam,
                                 lParam);

        //
        // Prevent dialog manager from telling the edit control to select
        // all of its contents when the focus has moved into it.  This is
        // necessary because otherwise tabbing into and out of the rich edit
        // makes it too easy to accidentally replace its contents with the
        // next addition.
        //

        if (msg == WM_GETDLGCODE)
        {
            lResult &= ~DLGC_HASSETSEL;
        }
    }
    return lResult;
}





//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CBaseDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\binder.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       binder.cxx
//
//  Contents:   Implementation of adsget/open object helper class
//
//  Classes:    CBinder
//
//  History:    02-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define BINDER_NAME_TRANSLATE_GC_INIT_FAILED            0x0001
#define BINDER_USER_CANCELLED_PWD_DLG                   0x0002



//+--------------------------------------------------------------------------
//
//  Member:     CBinder::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    02-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    // TRACE_METHOD(CBinder, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IBindHelper))
        {
            *ppvObj = (IUnknown *)(IBindHelper *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CBinder", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CBinder::BindToObject
//
//  Synopsis:   Call ADsOpenObject, prompting for credentials if necessary.
//
//  Arguments:  [tzPath] - ads path of desired object
//              [riid]   - interface requested on object
//              [ppv]    - out pointer for interface
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppv]
//
//  History:    02-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::BindToObject(
    HWND    hwnd,
    PCWSTR wzPath,
    REFIID riid,
    LPVOID *ppv,
    ULONG flags)
{
    Dbg(DEB_BIND, "BindToObject(%ws, flags=%#x)\n", wzPath, flags);
    DBG_INDENTER;

    HRESULT hr = S_OK;
    BSTR    bstrServer = NULL;
    PWSTR  pwzPathCopy = NULL;

    ASSERT(wzPath && *wzPath);

    if (!wzPath || !*wzPath)
    {
        hr = E_INVALIDARG;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    do
    {
        //
        // Get a copy of the server portion of the path
        //
        // Work around IADsPathname failure to handle WinNT paths containing
        // commas, e.g. "WinNT://foo,Domain".
        //

        //REVIEWED-2002-02-19-lucios.
        BOOL fWinntProvider = wcsstr(wzPath, c_wzWinNTPrefix) == wzPath;
        PWSTR pwzLastComma = wcsrchr(wzPath, L',');
        BOOL fWinntDomainObject = fWinntProvider &&
                                  pwzLastComma &&
                                  !cmpNoCase(pwzLastComma, L",Domain");
        BOOL fWinntComputerObject = fWinntProvider &&
                                  pwzLastComma &&
                                  !cmpNoCase(pwzLastComma, L",Computer");
        BOOL fWinntWorkgroupObject = fWinntProvider &&
                                    pwzLastComma &&
                                    !cmpNoCase(pwzLastComma, L",Workgroup");


        if (fWinntProvider)
        {
            if (pwzLastComma)
            {
                NewDupStr(&pwzPathCopy, wzPath);

                pwzPathCopy[pwzLastComma - wzPath] = L'\0';

                hr = g_pADsPath->GetMostSignificantElement(pwzPathCopy,
                                                           &bstrServer);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else
            {
                hr = g_pADsPath->GetWinntPathServerName(wzPath, &bstrServer);
                BREAK_ON_FAIL_HRESULT(hr);
            }
        }
        else
        {
            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         wzPath,
                                         ADS_FORMAT_SERVER,
                                         &bstrServer);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        ASSERT(bstrServer);

        //
        // Find or create a server info object for this server
        //

        CServerInfo *pServerInfo = NULL;
        USHORT usSrvInfoFlags = 0;

        if (fWinntDomainObject)
        {
            usSrvInfoFlags |= SRVINF_WINNT_DOMAIN_OBJECT;
        }

        if (fWinntComputerObject)
        {
            usSrvInfoFlags |= SRVINF_WINNT_COMPUTER_OBJECT;
        }

        if(fWinntWorkgroupObject)
        {
            usSrvInfoFlags |= SRVINF_WINNT_WORKGROUP_OBJECT;
        }

        if (flags & DSOP_BIND_FLAG_PATH_IS_DC)
        {
            usSrvInfoFlags |= SRVINF_SERVER_COMPONENT_IS_COMPUTER;
        }

        if (flags & DSOP_BIND_FLAG_SERVER_NEQ_DN)
        {
            usSrvInfoFlags |= SRVINF_SERVER_NEQ_DN;
        }

        hr = _GetServerInfo(hwnd,
                            bstrServer,
                            fWinntWorkgroupObject?pwzPathCopy:wzPath,
                            usSrvInfoFlags,
                            &pServerInfo,
                            riid,
                            ppv);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Either a serverinfo object already existed or one was just
        // created.  Use it to try to retrieve object.
        //

        if (!(flags & DSOP_BIND_FLAG_SERVER_NEQ_DN))
        {
            hr = pServerInfo->OpenObject(hwnd, 
                                        fWinntWorkgroupObject?pwzPathCopy:wzPath, 
                                        riid, 
                                        ppv);
        }
    } while (0);

    delete [] pwzPathCopy;
    SysFreeString(bstrServer);
    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CBinder::GetNameTranslate
//
//  Synopsis:   Return a name translate interface initialized to work with
//              domain [pwzDomain].
//
//  Arguments:  [hwndParent]      - frame or browser hwnd, for credential
//                                   prompt.
//              [ppNameTranslate] - filled with name translate interface
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppNameTranslate], caller must release
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::GetNameTranslate(
    HWND                hwndParent,
    PCWSTR              pwzADsPath,
    IADsNameTranslate **ppNameTranslate)
{
    TRACE_METHOD(CBinder, GetNameTranslate);

    HRESULT hr = S_OK;
    CServerInfo *pServerInfo = NULL;

    do
    {
        //
        // Init out var
        //

        *ppNameTranslate = NULL;

        //
        // Domain name is required for initialization.  Don't use
        // ADS_NAME_INITTYPE_GC because the domain might not be in the
        // local enterprise; but there's no way to tell the name translate
        // interface to use the GC in a different enterprise.
        //

        if (!pwzADsPath)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            ASSERT(!"CBinder::GetNameTranslate: pwzADsPath is NULL");
            break;
        }

        Bstr bstrServer;

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     pwzADsPath,
                                     ADS_FORMAT_SERVER,
                                     &bstrServer);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Get the name translate interface from the server info.
        //

        hr = _GetServerInfo(hwndParent,
                            bstrServer.c_str(),
                            pwzADsPath,
                            0,
                            &pServerInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pServerInfo->GetNameTranslate(ppNameTranslate);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::GetDomainRootDSE
//
//  Synopsis:   Retrieve an interface on the RootDSE object for domain
//              [pwzDomain].
//
//  Arguments:  [hwndParent]   - frame or browser, for credential prompt
//              [pwzDomain]    - domain for which to get rootdse
//              [ppADsRootDSE] - filled with interface on rootdse object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppADsRootDSE]
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::GetDomainRootDSE(
    HWND    hwndParent,
    PCWSTR pwzDomain,
    IADs **ppADsRootDSE)
{
    TRACE_METHOD(CBinder, GetDomainRootDSE);

    HRESULT hr = S_OK;
    CServerInfo *pServerInfo = NULL;

    do
    {
        WCHAR wzDomainADsPath[MAX_PATH];

        wsprintf(wzDomainADsPath, L"LDAP://%ws", pwzDomain);

        hr = _GetServerInfo(hwndParent,
                            pwzDomain,
                            wzDomainADsPath,
                            0,
                            &pServerInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pServerInfo->GetRootDSE(ppADsRootDSE);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBinder::BindToDcInDomain
//
//  Synopsis:  Does a dsbind to a dc in pwzDomainName and returns Handle to it
//
//  Arguments:  [IN hwnd]      - frame or browser hwnd, for credential
//                                   prompt.
//              [IN pwzDomainName]      - Domain for to do the bind
//              [IN dwFlag]             - Flags for DsGetDCName
//
//              [OUT phDs]           - Bind Handle is returned in it
//
//  Returns:    HRESULT
//
//  Modifies:   phDs, 
//
//  History:    07-20-1998   Hiteshr   Created
//
//---------------------------------------------------------------------------
STDMETHODIMP
CBinder::BindToDcInDomain(HWND hwnd,
                          PCWSTR pwzDomainName,
                          DWORD dwFlag,
                          PHANDLE phDs
                          )
{
    TRACE_METHOD(CBinder, BindToDcInDomain);

    ASSERT(pwzDomainName && phDs);

    CBindInfo *pCur = NULL;
    HRESULT hr = S_OK;

    if (!pwzDomainName || !phDs)
    {
        hr = E_INVALIDARG;
        DBG_OUT_HRESULT(hr);
        return hr;
    }


    *phDs = NULL;

    //
    //Check if we have it in the cache
    //
    for(pCur = m_pFirstBindInfo; pCur; pCur = pCur->Next())
    {
        if(pCur->IsForDomain(pwzDomainName))
        {
            break;
        }
    }

    if (pCur)
    {
        *phDs = pCur->GetDS();
        return hr;
    }

    //
    //Not found in the cache. Create a new entry
    //
    pCur = new CBindInfo(this, pwzDomainName, dwFlag);
    if(!pCur)
    {
        return E_OUTOFMEMORY;
    }        
    hr = pCur->Init(hwnd);
    if(FAILED(hr))
    {
        delete pCur;
        return hr;
    }

    //
    // Append to the link list
    //

    if (!m_pFirstBindInfo)
    {
        ASSERT(!m_pLastBindInfo);
        m_pFirstBindInfo = m_pLastBindInfo = pCur;
    }
    else
    {
        ASSERT(m_pLastBindInfo);
        pCur->LinkAfter(m_pLastBindInfo);
        m_pLastBindInfo = pCur;
    }

    //
    //Return the ds handle
    //
    *phDs = pCur->GetDS();

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_GetServerInfo
//
//  Synopsis:   Return a pointer to the server information object for the
//              server name [pwzServer], creating one if necessary.
//
//  Arguments:  [hwnd]         - parent for modal password dialog
//              [pwzServer]    - name of server for which to search
//              [pwzPath]      - full ADsPath for which to retrieve server
//                                info
//              [flags]        - SRVINF_* flags
//              [ppServerInfo] - filled with pointer to server info object
//                                for [pwzServer]
//              [riid]         - optional interface to get
//              [ppv]          - optional filled with retrieved interface
//
//  Returns:    HRESULT
//
//  History:    05-04-1998   DavidMun   Created
//
//  Notes:      Arguments [riid] and [ppv] are ignored unless [flags]
//              contains the flag SRVINF_SERVER_NEQ_DN, which indicates
//              that the server portion of pwzPath does not correspond to
//              the domain referenced in the DN of the path.  This can occur
//              when binding to the WKSP container.  If *[ppv] is filled in,
//              caller must Release the returned interface.
//
//---------------------------------------------------------------------------

HRESULT
CBinder::_GetServerInfo(
    HWND hwnd,
    PCWSTR pwzServer,
    PCWSTR pwzPath,
    USHORT flags,
    CServerInfo **ppServerInfo,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CBinder, _GetServerInfo);
    ASSERT(ppServerInfo);

    HRESULT hr = S_OK;
    CServerInfo *pCur;
    ULONG flProvider;

    if (!ppServerInfo)
    {
        hr = E_POINTER;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppServerInfo = NULL;

    hr = ProviderFlagFromPath(pwzPath, &flProvider);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    for (pCur = m_pFirstServerInfo; pCur; pCur = pCur->Next())
    {
        if (pCur->IsForServer(flProvider, pwzServer))
        {
            break;
        }
    }

    if (pCur)
    {
        *ppServerInfo = pCur;

        if (flags & SRVINF_SERVER_NEQ_DN)
        {
            ASSERT(ppv);

            hr = pCur->BindDirect(hwnd, pwzPath, riid, ppv);
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = _CreateServerInfo(hwnd,
                               pwzServer,
                               pwzPath,
                               flags,
                               ppServerInfo,
                               riid,
                               ppv);
        CHECK_HRESULT(hr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_CreateServerInfo
//
//  Synopsis:   Create a new server info object for server named [pwzServer]
//              and append it to the llist of server infos.
//
//  Arguments:  [pwzServer]    - server name associated with new server
//                                info object
//              [ppServerInfo] - filled with pointer to new object
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppServerInfo]
//
//  History:    05-04-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBinder::_CreateServerInfo(
    HWND hwnd,
    PCWSTR pwzServer,
    PCWSTR pwzPath,
    USHORT flags,
    CServerInfo **ppServerInfo,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CBinder, _CreateServerInfo);

    HRESULT         hr = S_OK;
    CSpServerInfo    spServerInfo(new CServerInfo(this,
                                                 pwzServer,
                                                 flags));

    ASSERT(!*ppServerInfo);

    do
    {
        hr = spServerInfo->Init(hwnd, pwzPath, riid, ppv);

        if (FAILED(hr) && !IsCredError(hr))
        {
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Append to the link list
        //

        if (!m_pFirstServerInfo)
        {
            ASSERT(!m_pLastServerInfo);

            m_pFirstServerInfo = m_pLastServerInfo = spServerInfo.get();
        }
        else
        {
            ASSERT(m_pLastServerInfo);

            spServerInfo->LinkAfter(m_pLastServerInfo);
            m_pLastServerInfo = spServerInfo.get();
        }

        //
        // transfer ownership from smart pointer to output argument
        //

        *ppServerInfo = spServerInfo.release();
    }
    while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::SetDefaultCreds
//
//  Synopsis:   Save the passed in credentials in member vars.
//
//  Arguments:  [userName] - user name
//              [password] - password
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBinder::SetDefaultCreds(
    const String &userName,
    const EncryptedString &password)
{
    CAutoCritSec Lock(&m_cs);
    m_userPassword=password;
    m_userName=userName;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::GetDefaultCreds
//
//  Synopsis:   Fill specified buffers with previously saved user name and
//              password.
//
//  Arguments:  [pwzUserName] - filled with user name
//              [pwzPassword] - filled with password
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBinder::GetDefaultCreds(
    ULONG flProvider,
    String &userName,
    EncryptedString &password
)
{
    CAutoCritSec Lock(&m_cs);

    if (m_userName.empty())
    {
        userName.erase();
        password.Encrypt(L"");
    }
    else
    {
        // NTRAID#NTBUG9-548215-2002/02/19-lucios. 
        userName = m_userName;
        //
        //if the provider is WINNT and userName is in UPN format
        //try to translate user name in NT4 format and winnt provider
        //won't accept user name in UPN format
        //
        if((flProvider == PROVIDER_WINNT) && _IsUserNameUpn())
        {
            if(!m_bCnvrtToWinntAttepmted)
            {
                _ConvertUserNameToWinnt();
                m_bCnvrtToWinntAttepmted = true;
            }

            if(!m_winntUserName.empty())
                userName = m_winntUserName;        
        }

        password = m_userPassword;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::ZeroCredentials
//
//  Synopsis:   Overwrite stored credentials with zeroes.
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBinder::ZeroCredentials()
{
    TRACE_METHOD(CBinder, ZeroCredentials);

    m_userName.erase();
    m_winntUserName.erase();
    m_userPassword.Encrypt(L"");

    CServerInfo *pCur;
    CServerInfo *pNext;

    for (pCur = m_pFirstServerInfo; pCur; pCur = pNext)
    {
        pNext = pCur->Next();
        delete pCur;
    }

    m_pFirstServerInfo = NULL;
    m_pLastServerInfo = NULL;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_IsUserNameUpn
//
//  Synopsis:   Checks if m_wzUserName is in UPN format
//
//  History:    04-02-2001 hiteshr Created
//
//---------------------------------------------------------------------------

bool
CBinder::_IsUserNameUpn()
{
    TRACE_METHOD(CBinder, _IsUserNameUpn);
    if(m_userName.empty())
        return FALSE;
    if(m_userName.find(L'@')!=String::npos)
        return true;
    else
        return false;

}

//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_ConvertUserNameToWinnt
//
//  Synopsis:   Gets NT4 format user name from UPN format name.
//
//  History:    04-02-2001 hiteshr Created
//
//---------------------------------------------------------------------------
bool 
CBinder::_ConvertUserNameToWinnt()
{
    TRACE_METHOD(CBinder, _ConvertUserNameToWinnt);
    WCHAR *pwzPassword=m_userPassword.GetClearTextCopy();
    //
    //Return Value
    //
    bool bReturn = false;

    HANDLE token = NULL;
    //
    //Logon to this machine using the credentials supplied by user
    //
    if(LogonUser(m_userName.c_str(),
        NULL,
        pwzPassword,
        LOGON32_LOGON_NEW_CREDENTIALS,
        LOGON32_PROVIDER_WINNT50,
        &token))
    {
        //
        //Let thread impersonate the security context of token. 
        //
        if(ImpersonateLoggedOnUser(token))
        {
            WCHAR wzWinntName[CREDUI_MAX_USERNAME_LENGTH  + 1];
            ULONG nSize = CREDUI_MAX_USERNAME_LENGTH;
            //
            //Translate the name from UPN to WINNT format
            //
            if(TranslateName(m_userName.c_str(),
                NameUserPrincipal,
                NameSamCompatible,
                wzWinntName,
                &nSize))
            {
                // NTRAID#NTBUG9-548215-2002/02/19-lucios. 
                m_winntUserName=wzWinntName;
                bReturn = true;
                Dbg(DEB_BIND, "%ws convert to Winnt name %ws", m_userName.c_str(), m_winntUserName.c_str());
            }
            //
            //Stop impersonation 
            //
            RevertToSelf();
        }
        //
        //Close the token
        //
        CloseHandle(token);
    }
    
    m_userPassword.DestroyClearTextCopy(pwzPassword);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\attributemanager.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       AttributeManager.cxx
//
//  Contents:   Implementation of class to cache class and attribute
//              strings and class icons used to display LDAP and WinNT
//              classes and attributes.
//
//  Classes:    CAttributeManager
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


const vector<ATTR_INFO> CAttributeManager::s_AttrEmpty;

//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::CAttributeManager
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of Object Picker
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAttributeManager::CAttributeManager(
    const CObjectPicker &rop):
        m_rop(rop),
        m_ulNextNewAttrIndex(AK_LAST)
{
    TRACE_CONSTRUCTOR(CAttributeManager);

    InitializeCriticalSection(&m_cs);
    m_himlClassIcons = ImageList_Create(

      // NTRAID#NTBUG9-193518-2000/11/21-sburns
      // NTRAID#NTBUG9-191961-2000/11/21-sburns
      
      GetSystemMetrics(SM_CXSMICON),
      GetSystemMetrics(SM_CYSMICON),
      ILC_COLOR16 | ILC_MASK,
      1,
      1);
      
    if (!m_himlClassIcons)
    {
        DBG_OUT_LASTERROR;
    }

    Clear();
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::~CAttributeManager
//
//  Synopsis:   dtor
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAttributeManager::~CAttributeManager()
{
    TRACE_DESTRUCTOR(CAttributeManager);

    if (m_himlClassIcons)
    {
        // bvt break fix: jdh  VERIFY(ImageList_Destroy(m_himlClassIcons));
        ImageList_Destroy(m_himlClassIcons);
        m_himlClassIcons = NULL;
    }
    DeleteCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::Clear
//
//  Synopsis:   Discard the cache
//
//  History:    05-25-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAttributeManager::Clear()
{
    TRACE_METHOD(CAttributeManager, Clear);

    if (m_himlClassIcons)
    {
        ImageList_RemoveAll(m_himlClassIcons);
    }
    m_vClasses.clear();
    m_AttrInfoMap.clear();
    m_rpDispSpec.Relinquish();
    m_rpDispSpecContainer.Relinquish();

    //
    // Restore the common attributes which have predefined ATTR_KEY values.
    // The display name is initialized on-demand at runtime, since it's
    // localized.
    //

    m_AttrInfoMap[AK_NAME].strAdsiName                  = L"name";
    m_AttrInfoMap[AK_NAME].Type                         = ADSTYPE_CASE_IGNORE_STRING;
    m_AttrInfoMap[AK_NAME].vstrDisplayName.push_back(String::load(IDS_LVCOLUMN_0));
    m_AttrInfoMap[AK_NAME].vstrOwningClassesAdsiNames.push_back(L"*");

    m_AttrInfoMap[AK_DISPLAY_PATH].vstrDisplayName.push_back(String::load(IDS_LVCOLUMN_1));
    m_AttrInfoMap[AK_DISPLAY_PATH].vstrOwningClassesAdsiNames.push_back(L"*");

    m_AttrInfoMap[AK_EMAIL_ADDRESSES].strAdsiName       = L"mail";
    m_AttrInfoMap[AK_EMAIL_ADDRESSES].Type              = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_ADSPATH].strAdsiName               = L"adsPath";
    m_AttrInfoMap[AK_ADSPATH].Type                      = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_OBJECT_CLASS].strAdsiName          = L"objectClass";
    m_AttrInfoMap[AK_OBJECT_CLASS].Type                 = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_USER_PRINCIPAL_NAME].strAdsiName   = L"userPrincipalName";
    m_AttrInfoMap[AK_USER_PRINCIPAL_NAME].Type          = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_COMPANY].strAdsiName               = L"company";
    m_AttrInfoMap[AK_COMPANY].Type                      = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_DESCRIPTION].strAdsiName           = L"description";
    m_AttrInfoMap[AK_DESCRIPTION].Type                  = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_SAMACCOUNTNAME].strAdsiName        = L"sAMAccountName";
    m_AttrInfoMap[AK_SAMACCOUNTNAME].Type               = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_OBJECT_SID].strAdsiName            = L"objectSid";
    m_AttrInfoMap[AK_OBJECT_SID].Type                   = ADSTYPE_OCTET_STRING;

    m_AttrInfoMap[AK_GROUP_TYPE].strAdsiName            = L"groupType";
    m_AttrInfoMap[AK_GROUP_TYPE].Type                   = ADSTYPE_INTEGER;

    m_AttrInfoMap[AK_USER_ACCT_CTRL].strAdsiName        = L"userAccountControl";
    m_AttrInfoMap[AK_USER_ACCT_CTRL].Type               = ADSTYPE_INTEGER;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetImageList
//
//  Synopsis:   Return the imagelist owned by this class
//
//  Arguments:  [phiml] - filled with pointer to this class's imagelist.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Caller (or common controls that caller associates the
//              imagelist with) must NOT free the imagelist.
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::GetImageList(
    HIMAGELIST *phiml) const
{
    HRESULT hr = S_OK;
    ASSERT(phiml);

    *phiml = m_himlClassIcons;

    if (!m_himlClassIcons)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Class:      CFindClass
//
//  Purpose:    Functor for looking up an element of m_vClasses by class
//              name.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CFindClass
{
public:

    CFindClass(
        const String &strClass,
        BOOL fDownlevel):
            m_strClass(strClass),
            m_fDownlevel(fDownlevel)
    {
    }

    BOOL
    operator()(const CLASS_INFO &ci)
    {
        return ((m_fDownlevel && (ci.ulFlags & CI_FLAG_IS_DOWNLEVEL)) ||
               (!m_fDownlevel && !(ci.ulFlags & CI_FLAG_IS_DOWNLEVEL))) &&
                !m_strClass.icompare(ci.strAdsiName);
    }

private:

    BOOL m_fDownlevel;
    const String &m_strClass;
};




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetIconIndexFromObject
//
//  Synopsis:   Wrapper for GetIconIndexFromClass--extracts necessary
//              arguments (flags and class) from [dso] and forwards call.
//
//  Arguments:  [hwnd]      - for binding
//              [dso]       - object
//              [pintIndex] - on success, filled with index to icon
//
//  Returns:
//
//  History:    08-02-2000   DavidMun   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::GetIconIndexFromObject(
    HWND hwnd,
    const CDsObject &dso,
    INT *pintIndex) const
{
    ULONG ulFlags = 0;

    if (dso.GetDisabled())
    {
        ulFlags |= DSOP_GETICON_FLAG_DISABLED;
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rScope = rsm.LookupScopeById(dso.GetOwningScopeID());

    if (IsDownlevel(rScope))
    {
        ulFlags |= DSOP_GETICON_FLAG_DOWNLEVEL;
    }

    ASSERT(dso.GetClass());

    if (!dso.GetClass())
    {
        DBG_OUT_HRESULT(E_FAIL);
        return E_FAIL;
    }
    return GetIconIndexFromClass(hwnd, dso.GetClass(), ulFlags, pintIndex);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetIconIndexFromClass
//
//  Synopsis:   Return an index into the imagelist owned by this
//              which contains an icon representing class named [strClass].
//
//  Arguments:  [hwnd]      - for binding
//              [strClass]  - class to look up
//              [ulFlags]   - DSOP_GETICON_FLAG_*
//              [pintIndex] - filled with index to icon, -1 if none could
//                              be found
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      May access DS or resource file to procure the icon.
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::GetIconIndexFromClass(
    HWND hwnd,
    const String &strClass,
    ULONG ulFlags,
    INT *pintIndex) const
{
    ASSERT(pintIndex);

    HRESULT hr = S_OK;

    do
    {
        // init out param for failure
        *pintIndex = -1;

        // find the entry in m_vClasses for class with ldap name strClass
        ClassInfoVector::iterator it;

        hr = _ReadClassInfo(hwnd,
                            strClass,
                            (ulFlags & DSOP_GETICON_FLAG_DOWNLEVEL),
                            &it);
        BREAK_ON_FAIL_HRESULT(hr);

        if (ulFlags & DSOP_GETICON_FLAG_DISABLED)
        {
            *pintIndex = it->iDisabledIcon;
        }
        else
        {
            *pintIndex = it->iIcon;
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::CopyIconToImageList
//
//  Synopsis:   Copy the icon representing class [strClass] from the
//              imagelist owned by this to the imagelist with handle
//              pointed to by [phimlDest].
//
//  Arguments:  [hwnd]      - for bind
//              [strClass]  - class for which to find icon
//              [ulFlags]   - DSOP_GETICON_FLAG_*
//              [phimlDest] - destination imagelist
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::CopyIconToImageList(
    HWND hwnd,
    const String &strClass,
    ULONG ulFlags,
    HIMAGELIST *phimlDest) const
{
    TRACE_METHOD(CAttributeManager, CopyIconToImageList);
    ASSERT(phimlDest);

    HRESULT hr = S_OK;

    do
    {
        // find the entry in m_vClasses for class with ldap name strClass
        ClassInfoVector::iterator it;

        hr = _ReadClassInfo(hwnd,
                            strClass,
                            (ulFlags & DSOP_GETICON_FLAG_DOWNLEVEL),
                            &it);
        BREAK_ON_FAIL_HRESULT(hr);

        HICON hIcon = NULL;

        if (ulFlags & DSOP_GETICON_FLAG_DISABLED)
        {
            // must Destroy this HICON
            
            hIcon = ImageList_GetIcon(m_himlClassIcons,
                                      it->iDisabledIcon,
                                      ILD_NORMAL);
        }
        else
        {
            // must Destroy this HICON

            hIcon = ImageList_GetIcon(m_himlClassIcons,
                                      it->iIcon,
                                      ILD_NORMAL);
        }

        if (hIcon)
        {
            ImageList_AddIcon(*phimlDest, hIcon);
            DestroyIcon(hIcon);  // NTRAID#NTBUG9-212260-2000/11/13-sburns
        }
        else
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_LASTERROR;
            break;
        }
    } while (0);
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrKeysForSelectedClasses
//
//  Synopsis:   Return a vector of ATTR_KEYs denoting all the attributes
//              available for the classes which are currently selected in
//              the 'look for' control.
//
//  Arguments:  [hwnd] - for bind
//
//  Returns:    Vector as described.
//
//  History:    06-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

AttrKeyVector
CAttributeManager::GetAttrKeysForSelectedClasses(
    HWND hwnd) const
{
    TRACE_METHOD(CAttributeManager, GetAttrKeysForSelectedClasses);

    vector<String> vstrClasses;
    GetSelectedClasses(&vstrClasses);
    BOOL fDownlevel = FALSE;

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
    {
        fDownlevel = TRUE;
    }
    return GetAttrKeysForClasses(hwnd, fDownlevel, vstrClasses);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetSelectedClasses
//
//  Synopsis:   Fill [pvstrClasses] with the LDAP class name strings for
//              all the classes currently selected in Look For.
//
//  Arguments:  [pvstrClasses] - filled with class strings as described
//
//  History:    06-15-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAttributeManager::GetSelectedClasses(
    vector<String> *pvstrClasses) const
{
    ULONG flSelectedClasses =
        m_rop.GetFilterManager().GetCurScopeSelectedFilterFlags();
    ASSERT(flSelectedClasses);
    ASSERT(!(flSelectedClasses & DOWNLEVEL_FILTER_BIT));

    if (flSelectedClasses & DSOP_FILTER_USERS)
    {
        pvstrClasses->push_back(c_wzUserObjectClass);
    }

    if (flSelectedClasses & ALL_UPLEVEL_GROUP_FILTERS)
    {
        pvstrClasses->push_back(c_wzGroupObjectClass);
    }

    if (flSelectedClasses & DSOP_FILTER_COMPUTERS)
    {
        pvstrClasses->push_back(c_wzComputerObjectClass);
    }

    if (flSelectedClasses & DSOP_FILTER_CONTACTS)
    {
        pvstrClasses->push_back(c_wzContactObjectClass);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrKeysForClasses
//
//  Synopsis:   Return attribute keys for only the classes [vstrClasses].
//
//  Arguments:  [hwnd]        - for bind
//              [fDownlevel]  - TRUE  => all classes downlevel,
//                              FALSE => all classes uplevel
//              [vstrClasses] - classes that should be represented by
//                               entries in returned vector
//
//  Returns:    AttrKeyVector containing ATTR_KEYs for only the
//              classes in [vstrClasses].
//
//  History:    06-12-2000   DavidMun   Created
//
//  Notes:      The attribute infos in the returned vector may list classes
//              in addition to those in [vstrClasses].
//
//---------------------------------------------------------------------------

AttrKeyVector
CAttributeManager::GetAttrKeysForClasses(
    HWND hwnd,
    BOOL fDownlevel,
    const vector<String> &vstrClasses) const
{
    TRACE_METHOD(CAttributeManager, GetAttrKeysForClasses);

    AttrKeyVector vakResult;

    //
    // First ensure that we've read display specifier info on all the
    // classes in vstrClasses, as well as all their attributes.
    //

    vector<String>::const_iterator itvstr;

    for (itvstr = vstrClasses.begin(); itvstr != vstrClasses.end(); itvstr++)
    {
        _ReadAttrInfo(hwnd, fDownlevel, *itvstr); // calls _ReadClassInfo first
    }

    //
    // Now populate a new AttrKeyVector with the keys of all the attributes
    // that apply to any class in vstrClasses.
    //

    AttrInfoMap::const_iterator itAttrInfoMap;

    for (itAttrInfoMap = m_AttrInfoMap.begin();
         itAttrInfoMap != m_AttrInfoMap.end();
         itAttrInfoMap++)
    {
        vector<String>::const_iterator itOwning;

        //
        // Iterate over the owning classes of the current attribute.  If
        // any of those classes matches one in [vstrClasses], then the
        // key of the current ATTR_INFO should be copied into the output vector.
        //

        BOOL fMatch = FALSE;

        for (itOwning = itAttrInfoMap->second.vstrOwningClassesAdsiNames.begin();
             itOwning != itAttrInfoMap->second.vstrOwningClassesAdsiNames.end();
             itOwning++)
        {
            for (itvstr = vstrClasses.begin();
                 itvstr != vstrClasses.end();
                 itvstr++)
            {
                if (!itvstr->icompare(*itOwning))
                {
                    fMatch = TRUE;
                    vakResult.push_back(itAttrInfoMap->first);
                    break;
                }
            }

            if (fMatch)
            {
                break;
            }
        }
    }
    return vakResult;
}

//
// A pointer to an ATTR_CALLBACK_INFO instance is passed to static
// function CAttributeManager::_AttrEnumCallback() as its lParam.
//

struct ATTR_CALLBACK_INFO
{
    ATTR_CALLBACK_INFO():
        pThis(NULL)
    {
    }

    ~ATTR_CALLBACK_INFO()
    {
        pThis = NULL;
    }

    const CAttributeManager *pThis;
    String strClass;
};




//+--------------------------------------------------------------------------
//
//  Class:      CFindAttrByAdsiName
//
//  Purpose:    Used as a functor to look up the attribute key of a given
//              class name.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CFindAttrByAdsiName
{
public:

    CFindAttrByAdsiName(
        const String &strAdsiName):
            m_strAdsiName(strAdsiName)
    {
    }

    BOOL
    operator()(const pair<ATTR_KEY, ATTR_INFO> &rKeyInfoPair)
    {
        return !m_strAdsiName.icompare(rKeyInfoPair.second.strAdsiName);
    }

private:

    const String &m_strAdsiName;
};



//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::DemandInit
//
//  Synopsis:   Bind to the display specifier container if we haven't already
//
//  Returns:    Result of attempting bind.
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::DemandInit(
    HWND hwnd) const
{
    HRESULT hr = S_OK;
    String   userName;
    EncryptedString  password;

    do
    {
        //
        // If DS is not available, there's nothing to do here
        //

        if (!ConfigSupportsDs(m_rop.GetTargetComputerConfig()))
        {
            break;
        }

        //
        // Create display specifier instance if we haven't already.
        //

        if (!m_rpDispSpec.get())
        {
            hr = m_rpDispSpec.AcquireViaCreateInstance(CLSID_DsDisplaySpecifier,
                                                     NULL,
                                                     CLSCTX_INPROC,
                                                     IID_IDsDisplaySpecifier);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        ASSERT(m_rpDispSpec.get());

        //
        // Bind to display specifier container if necessary
        // If we are already bound and the target hasn't changed
        // there is no need to bind again so break.
        //
        if (m_rpDispSpecContainer.get())
        {
            break;
        }

        VOID *pv = NULL;
        hr = m_rop.GetRootDSE().BindToDisplaySpecifiersContainer(hwnd,
                                                                 IID_IADsContainer,
                                                                 &pv);
        BREAK_ON_FAIL_HRESULT(hr);

        m_rpDispSpecContainer.Acquire(
            static_cast<IADsContainer *>(pv));

        ASSERT(m_rpDispSpecContainer.get());

        g_pBinder->GetDefaultCreds( PROVIDER_LDAP,
                                    userName, 
                                    password);

        if (!userName.empty())
        {
            String strDcName = m_rop.GetTargetDomainDc();
            if(strDcName.size() > 2 && strDcName[0] == L'\\' && strDcName[1] == L'\\')
                 strDcName.erase(0, 2);
            WCHAR *pwzPassword=password.GetClearTextCopy();
            hr = m_rpDispSpec->SetServer(strDcName.c_str(), 
                                         userName.c_str(), 
                                         pwzPassword, 
                                         DSSSF_DSAVAILABLE);
            password.DestroyClearTextCopy(pwzPassword);
            BREAK_ON_FAIL_HRESULT(hr);
        }
    } while (0);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::_ReadClassInfo
//
//  Synopsis:   Read and cache display specifier information for [strClass].
//
//  Arguments:  [hwnd]       - for binding
//              [strClass]   - name of class to read info for
//              [fDownlevel] - TRUE => [strClass] is name of downlevel class,
//                             FALSE => [strClass] is LDAP class name
//              [pit]        - filled with iterator at relevant CLASS_INFO
//
//  Returns:    HRESULT
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::_ReadClassInfo(
    HWND hwnd,
    const String &strClass,
    BOOL fDownlevel,
    ClassInfoVector::iterator *pit) const
{
    //TRACE_METHOD(CAttributeManager, _ReadClassInfo);
    ASSERT(pit);

    HRESULT hr = S_OK;
    CLASS_INFO ci;
    PWSTR pwzBuf = NULL;

    ci.strAdsiName = strClass;

    do
    {
        //
        // See if we've already got info on this class
        //

        CFindClass predicate(strClass, fDownlevel);

        *pit = find_if(m_vClasses.begin(), m_vClasses.end(), predicate);

        if (*pit != m_vClasses.end())
        {
            // success, return iterator pointing to cached info
            break;
        }

        Dbg(DEB_TRACE,
            "CAttributeManager::_ReadClassInfo<%#x> Reading class %ws\n",
            this,
            strClass.c_str());

        //
        // If DS is not available on target machine class info must be
        // hardcoded.
        //

        BOOL fDsAvailable = ConfigSupportsDs(m_rop.GetTargetComputerConfig());

        //
        // Don't have cached info for this class.
        // Read display info from the specifier for this class
        //
        // Special-case downlevel classes, as they won't appear in the
        // DS.
        //

        BOOL fIsLocalGroup = !strClass.icompare(c_wzLocalGroupClass);
        BOOL fIsGlobalGroup = !strClass.icompare(c_wzGlobalGroupClass);
        BOOL fIsGroup = !strClass.icompare(c_wzGroupObjectClass);
        BOOL fIsUser = !strClass.icompare(c_wzUserObjectClass);
        BOOL fIsComputer = !strClass.icompare(c_wzComputerObjectClass);

        if (fIsLocalGroup || fIsGlobalGroup)
        {
            HICON hIcon;
            ULONG idiGroup = fIsLocalGroup ? IDI_LOCAL_GROUP : IDI_GROUP;
            int   idsGroup = fIsLocalGroup ? IDS_LOCAL_GROUP : IDS_GLOBAL_GROUP;

            hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idiGroup));

            ci.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            ci.strDisplayName = String::load(idsGroup);
        }
        else if (fDownlevel || !fDsAvailable)
        {
            HICON hIcon;
            ULONG idi;
            ULONG idiDisabled = 0;
            int   ids;

            if (fIsUser)
            {
                idi = IDI_USER;
                idiDisabled = IDI_DISABLED_USER;
                ids = IDS_USER;
            }
            else if (fIsGroup)
            {
                idi = IDI_GROUP;
                ids = IDS_GROUP;
            }
            else if (fIsComputer)
            {
                idi = IDI_COMPUTER;
                idiDisabled = IDI_DISABLED_COMPUTER;
                ids = IDS_COMPUTER;
            }
            else
            {
                Dbg(DEB_ERROR,
                    "unexpected class %ws for non-DS machine config\n",
                    strClass.c_str());
                hr = E_INVALIDARG;
                break;
            }

            hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idi));
            ci.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);

            if (idiDisabled)
            {
                hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idiDisabled));
                ci.iDisabledIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            }
            ci.strDisplayName = String::load(ids);
            ci.ulFlags |= CI_FLAG_IS_DOWNLEVEL;
        }
        else
        {
            CWaitCursor Hourglass;

            hr = DemandInit(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);

            HICON hIcon;

            {
                TIMER("IDsDisplaySpecifier::GetIcon(%ws)", strClass.c_str());
                hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                              DSGIF_ISNORMAL
                                              | DSGIF_GETDEFAULTICON,
                                              16,
                                              16);
            }
            ci.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            DestroyIcon(hIcon);

            {
                TIMER("IDsDisplaySpecifier::GetIcon(%ws, DSGIF_ISDISABLED)",
                      strClass.c_str());
                hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                            DSGIF_ISDISABLED
                                            | DSGIF_GETDEFAULTICON,
                                            16,
                                            16);
            }
            ci.iDisabledIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            DestroyIcon(hIcon);

            pwzBuf = new WCHAR [MAX_PATH + 1];

            {
                TIMER("IDsDisplaySpecifier::GetFriendlyClassName(%ws)",
                      strClass.c_str());
                hr = m_rpDispSpec->GetFriendlyClassName(strClass.c_str(),
                                                      pwzBuf,
                                                      MAX_PATH);
            }

            if (SUCCEEDED(hr))
            {
                ci.strDisplayName = pwzBuf;
            }
            else
            {
                ci.strDisplayName = strClass;
            }
        }

        //
        // Add new info to class vector
        //

        m_vClasses.push_back(ci);
        *pit = m_vClasses.end() - 1;
    } while (0);

    delete [] pwzBuf;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::_ReadAttrInfo
//
//  Synopsis:   Read all class and attribute information for class with ADSI
//              name [strClass] from the display specifier interface.
//
//  Arguments:  [hwnd]     - for bind
//              [strClass] - class for which to read attributes
//
//  History:    06-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::_ReadAttrInfo(
    HWND hwnd,
    BOOL fDownlevel,
    const String &strClass) const
{
    //TRACE_METHOD(CAttributeManager, _ReadAttrInfo);

    ClassInfoVector::iterator itClass;
    HRESULT hr = S_OK;

    do
    {
        hr = _ReadClassInfo(hwnd, strClass, fDownlevel, &itClass); // calls DemandInit
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If we've been here before for this class and successfully read its
        // attributes, leave.
        //

        if (itClass->ulFlags & CI_FLAG_READ_ATTR_INFO)
        {
            break;
        }

        //
        // If the DS is not available, then leave, as there are no
        // attributes to be read.
        //

        BOOL fDsAvailable = ConfigSupportsDs(m_rop.GetTargetComputerConfig());

        if (!fDsAvailable)
        {
            break;
        }

        //
        // Remember the last attribute we know about before doing the enum.
        //

        AttrInfoMap::iterator itLastOld = m_AttrInfoMap.end();
        itLastOld--;

        //
        // Enumerate via callback all the display specifer attributes for class
        //

        Dbg(DEB_TRACE, "Reading attributes for class %ws\n", strClass.c_str());

        ATTR_CALLBACK_INFO aci;

        aci.pThis = this;
        aci.strClass = strClass;

        hr = m_rpDispSpec->EnumClassAttributes(strClass.c_str(),
                                               _AttrEnumCallback,
                                               reinterpret_cast<LPARAM>(&aci));

        //
        // Now for any attributes added, set their type
        //

        AttrInfoMap::iterator itMap = itLastOld;
        itMap++;

        for (; itMap != m_AttrInfoMap.end(); itMap++)
        {
            itMap->second.Type =
                m_rpDispSpec->GetAttributeADsType(itMap->second.strAdsiName.c_str());
//            Dbg(DEB_TRACE,
//                "%ws, %ws, %#x\n",
//                itMap->second.strAdsiName.c_str(),
//                itMap->second.strDisplayName.c_str(),
//                itMap->second.Type);
        }

        //
        // Remember that we read the attributes for this class
        //

        itClass->ulFlags |= CI_FLAG_READ_ATTR_INFO;
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::_AttrEnumCallback
//
//  Synopsis:   Receive the callback from the display specifier enumerator
//              for the attributes of a specific class.
//
//  Arguments:  [lParam]           - ATTR_CALLBACK_INFO *
//              [pszAttributeName] - ADSI (LDAP) name of attribute
//              [pszDisplayName]   - human-readable name of attribute
//              [dwFlags]          - unused
//
//  Returns:    S_OK (an error would only halt the enumeration)
//
//  History:    06-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT CALLBACK
CAttributeManager::_AttrEnumCallback(
    LPARAM lParam,
    LPCWSTR pszAttributeName,
    LPCWSTR pszDisplayName,
    DWORD dwFlags)
{
    ATTR_CALLBACK_INFO *paci = reinterpret_cast<ATTR_CALLBACK_INFO *>(lParam);
    const CAttributeManager *pThis = paci->pThis;
    ASSERT(pszAttributeName);
    ASSERT(pszDisplayName);
    CAutoCritSec Lock(const_cast<CRITICAL_SECTION*>(&pThis->m_cs));

    do
    {
        if (!pszAttributeName)
        {
            DBG_OUT_HRESULT(E_POINTER);
            break;
        }

        //
        // See if there's already an entry in m_AttrInfoMap for this
        // attribute.
        // This can happen because more than one class of object might have the
        // same attribute.
        //

        ATTR_KEY key = pThis->GetAttrKey(pszAttributeName);

        if(AddIfNotPresent( &pThis->m_AttrInfoMap[key].vstrOwningClassesAdsiNames,
                            paci->strClass))
        {
            if (pszDisplayName)
            {
                pThis->m_AttrInfoMap[key].vstrDisplayName.push_back(pszDisplayName);
            }
            else 
            {
                //
                // not localized, but better than nothing.  will be overwritten
                // with localized name should a later enumeration of some other
                // class' attributes have one for this attribute.
                //

                pThis->m_AttrInfoMap[key].vstrDisplayName.push_back(pszAttributeName);
            }
        }
        //
        // _ReadAttrInfo will go back and set the Type values for all
        // enumerated attributes
        //

    } while (0);

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrKey
//
//  Synopsis:   Return the key for attribute with ADSI name [strAdsiName],
//              creating one if necessary.
//
//  Arguments:  [strAdsiName] - name of attribute to find in
//                                  m_AttrInfoMap.
//
//  Returns:    New or existing key
//
//  History:    06-13-2000   DavidMun   Created
//
//  Note:       Only caller is dsobject which has a class and VARTYPE in
//              addition to attribute name.  It could supply those to make
//              the new ATTR_INFO structure contain more data, but right now
//              nothing needs to use that.
//
//---------------------------------------------------------------------------

ATTR_KEY
CAttributeManager::GetAttrKey(
    const String &strAdsiName) const
{
    //TRACE_METHOD(CAttributeManager, GetAttrKey);

    CFindAttrByAdsiName pred(strAdsiName);
    AttrInfoMap::iterator itAttr;

    itAttr = find_if(m_AttrInfoMap.begin(),
                     m_AttrInfoMap.end(),
                     pred);

    if (itAttr != m_AttrInfoMap.end())
    {
        return itAttr->first;
    }

    //
    // Master attribute list doesn't contain an entry for this attribute
    // (pszAttributeName) yet.  Create one.
    //

    ATTR_KEY key = static_cast<ATTR_KEY>(++m_ulNextNewAttrIndex);

    m_AttrInfoMap[key].strAdsiName = strAdsiName;
    return key;
}

BOOL
CAttributeManager::    
IsAttributeLoaded(
    ATTR_KEY ak) const
{

    CAutoCritSec Lock(const_cast<CRITICAL_SECTION *>(&m_cs));
    return !m_AttrInfoMap[ak].vstrDisplayName.empty();
}

//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrDisplayName
//
//  Synopsis:   Return the human-readable name for attribute with key [ak]
//
//  Arguments:  [ak] - represents attribute for which to return name
//
//  Returns:    Localized name of attribute
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const String &
CAttributeManager::GetAttrDisplayName(
    ATTR_KEY ak) const
{
    CAutoCritSec Lock(const_cast<CRITICAL_SECTION *>(&m_cs));
    String strClass = GetClassName(m_rop);

    vector<String>::const_iterator itClass;
    vector<String>::const_iterator itDisplayName;

    //
    // Iterate over the owning classes of the current attribute.  If
    // any of those classes matches one in [vstrClasses], then the
    // key of the current ATTR_INFO should be copied into the output vector.
    //

    BOOL fMatch = FALSE;

    for (itClass = m_AttrInfoMap[ak].vstrOwningClassesAdsiNames.begin(),
        itDisplayName = m_AttrInfoMap[ak].vstrDisplayName.begin();
        itClass != m_AttrInfoMap[ak].vstrOwningClassesAdsiNames.end() &&
        itDisplayName != m_AttrInfoMap[ak].vstrDisplayName.end();
        itClass++,
        itDisplayName++)
    {

        if (!itClass->icompare(strClass))
        {
            fMatch = TRUE;
            break;
        }
        if (fMatch)
        {
            break;
        }
    }
    if(!fMatch)
        itDisplayName = m_AttrInfoMap[ak].vstrDisplayName.begin();

    const String *pstrDisplayName = NULL;

    if(itDisplayName != m_AttrInfoMap[ak].vstrDisplayName.end())
        pstrDisplayName = &*itDisplayName;
    else
        pstrDisplayName = &m_AttrInfoMap[ak].strAdsiName;


    //
    // If we don't have a display name for the attribute yet, then we
    // haven't read the attr info from the DS yet. Caller is responsible
    // for telling us which classes to read before attempting to get
    // display info about them.
    //



    if (pstrDisplayName->empty())
    {
        Dbg(DEB_ERROR, "No display name for ATTR_KEY=%u\n", ak);
    }
    ASSERT(!pstrDisplayName->empty());

    return *pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\columnpickerdlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       ColumnPickerDlg.cxx
//
//  Contents:   Implementation of class that displays the column picker
//              dialog
//
//  Classes:    CColumnPickerDlg
//
//  History:    06-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


static ULONG
s_aulHelpIds[] =
{
    IDC_AVAILABLE_LIST,     IDH_AVAILABLE_LIST,
    IDC_ADD_COL_BTN,        IDH_ADD_COL_BTN,
    IDC_REMOVE_COL_BTN,     IDH_REMOVE_COL_BTN,
    IDC_SHOWN_LIST,         IDH_SHOWN_LIST,
    0,0
};


//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::DoModal
//
//  Synopsis:   Invoke the Column Picker as a modal dialog
//
//  Arguments:  [hwndParent] - handle to parent window
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CColumnPickerDlg::DoModal(
    HWND hwndParent)
{
    TRACE_METHOD(CColumnPickerDlg, DoModal);

    return (BOOL) _DoModalDlg(hwndParent, IDD_COLUMN_PICKER);
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_OnInit
//
//  Synopsis:   Initialize the contents of the 'available' and 'shown'
//              listviews.
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CColumnPickerDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CColumnPickerDlg, _OnInit);

    //
    // Add a full-width column to each of the listviews
    //

    HWND hwndLV = _hCtrl(IDC_AVAILABLE_LIST);
    if (!hwndLV)
    {
        DBG_OUT_LASTERROR;
        return HRESULT_FROM_LASTERROR;
    }
    RECT rcLV;
    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN col;
    //REVIEWED-2002-02-20-lucios.
    ZeroMemory(&col, sizeof col);

    col.mask = LVCF_WIDTH;
    col.cx = rcLV.right;

    int iCol = ListView_InsertColumn(hwndLV, 0, &col);
    if (iCol == -1)
    {
        DBG_OUT_LASTERROR;
    }
    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    hwndLV = _hCtrl(IDC_SHOWN_LIST);
    if (!hwndLV)
    {
        DBG_OUT_LASTERROR;
        return HRESULT_FROM_LASTERROR;
    }

    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    iCol = ListView_InsertColumn(hwndLV, 0, &col);
    if (iCol == -1)
    {
        DBG_OUT_LASTERROR;
    }

    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    const CAttributeManager &ram = m_rop.GetAttributeManager();

    m_vakAvailable = ram.GetAttrKeysForSelectedClasses(m_hwnd);

    if (m_vakAvailable.empty())
    {
        SafeEnableWindow(_hCtrl(IDC_ADD_COL_BTN), FALSE);
    }
    else
    {
        AttrKeyVector::iterator it;

        for (it = m_vakShown.begin(); it != m_vakShown.end(); it++)
        {
            AttrKeyVector::iterator itAvail;

            do
            {
                itAvail = find(m_vakAvailable.begin(), m_vakAvailable.end(), *it);
                if (itAvail != m_vakAvailable.end())
                {
                    m_vakAvailable.erase(itAvail);
                }
            } while (itAvail != m_vakAvailable.end());
        }
    }

    _EnsureAttributePresent(AK_NAME);
    _EnsureAttributePresent(AK_DISPLAY_PATH);

    _AddAttributesToListview(_hCtrl(IDC_AVAILABLE_LIST), m_vakAvailable);
    _AddAttributesToListview(_hCtrl(IDC_SHOWN_LIST), *m_pvakColumns);

    SetListViewSelection(_hCtrl(IDC_AVAILABLE_LIST), 0);
    SetListViewSelection(_hCtrl(IDC_SHOWN_LIST), 0);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_AddAttributesToListview
//
//  Synopsis:   Add the display names for all attributes in [vak] to the
//              listview with window handle [hwndLV].
//
//  Arguments:  [hwndLV] - handle to listview window
//              [vak]    - (possibly empty) vector of attribute keys
//
//  History:    06-14-2000   DavidMun   Created
//
//  Notes:      Adds ATTR_KEY values as lParam of listview items.
//
//---------------------------------------------------------------------------

void
CColumnPickerDlg::_AddAttributesToListview(
    HWND hwndLV,
    const AttrKeyVector &vak)
{
    LVITEM lvi;
    //REVIEWED-2002-02-20-lucios.
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    AttrKeyVector::const_iterator it;

    for (it = vak.begin(); it != vak.end(); it++)
    {
        lvi.pszText = const_cast<PWSTR>(ram.GetAttrDisplayName(*it).c_str());
        lvi.lParam = *it;
        lvi.iItem = INT_MAX;
        LONG lResult = ListView_InsertItem(hwndLV, &lvi);
        if (lResult == -1)
        {
            Dbg(DEB_ERROR,
                "Error %u inserting '%ws' in listview\n",
                GetLastError(),
                lvi.pszText);
            continue;
        }
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_EnsureAttributePresent
//
//  Synopsis:   If [ak] is present in neither the available nor the shown
//              lists, add it to the available list.
//
//  Arguments:  [ak] - attribute key to check for
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CColumnPickerDlg::_EnsureAttributePresent(
    ATTR_KEY ak)
{
    AttrKeyVector::iterator itAvail;
    AttrKeyVector::iterator itShown;

    itAvail = find(m_vakAvailable.begin(), m_vakAvailable.end(), ak);
    itShown = find(m_vakShown.begin(), m_vakShown.end(), ak);

    if (itAvail == m_vakAvailable.end() && itShown == m_vakShown.end())
    {
        m_vakAvailable.push_back(ak);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CColumnPickerDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDC_ADD_COL_BTN:
    {
        Dbg(DEB_TRACE, "UA: (CColumnPickerDlg) hit Add button\n");

        //
        // Move the selected item in the 'available' listview to the
        // 'shown' listview.
        //

        _MoveAttribute(IDC_AVAILABLE_LIST, IDC_SHOWN_LIST);

        //
        // Since the 'shown' listview must now contain at least one item,
        // ensure that the remove and OK buttons are enabled.
        //

        SafeEnableWindow(_hCtrl(IDC_REMOVE_COL_BTN), TRUE);
        SafeEnableWindow(_hCtrl(IDOK), TRUE);

        //
        // If the 'available' listview is now empty, disable the Add button.
        //

        if (!ListView_GetItemCount(_hCtrl(IDC_AVAILABLE_LIST)))
        {
            VERIFY(SetFocus(_hCtrl(IDC_REMOVE_COL_BTN)));
            SafeEnableWindow(_hCtrl(IDC_ADD_COL_BTN), FALSE);
        }
        break;
    }

    case IDC_REMOVE_COL_BTN:
    {
        Dbg(DEB_TRACE, "UA: (CColumnPickerDlg) hit Remove button\n");

        _MoveAttribute(IDC_SHOWN_LIST, IDC_AVAILABLE_LIST);
        SafeEnableWindow(_hCtrl(IDC_ADD_COL_BTN), TRUE);
        if (!ListView_GetItemCount(_hCtrl(IDC_SHOWN_LIST)))
        {
            SetFocus(_hCtrl(IDC_ADD_COL_BTN));
            SafeEnableWindow(_hCtrl(IDC_REMOVE_COL_BTN), FALSE);
            SafeEnableWindow(_hCtrl(IDOK), FALSE);
        }
        break;
    }

    case IDOK:
        ASSERT(!m_vakShown.empty());
        *m_pvakColumns = m_vakShown;
        EndDialog(m_hwnd, TRUE);
        break;

    case IDCANCEL:
        EndDialog(m_hwnd, FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CColumnPickerDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_MoveAttribute
//
//  Synopsis:   Move an entry from one listview (and its associated vector
//              of attribute keys) to the other.
//
//  Arguments:  [idFrom] - resource id of listview to take attribute from
//              [idTo]   - resource id of listview to move attribute to
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CColumnPickerDlg::_MoveAttribute(
    int idFrom,
    int idTo)
{
    TRACE_METHOD(CColumnPickerDlg, _MoveAttribute);
    HWND hwndLvFrom = _hCtrl(idFrom);
    HWND hwndLvTo = _hCtrl(idTo);

    do
    {
        //
        // Find out which item is selected in the 'from' listview
        //

        int iItem = ListView_GetNextItem(hwndLvFrom, -1, LVNI_SELECTED);
        const CAttributeManager &ram = m_rop.GetAttributeManager();

        ASSERT(iItem != -1);
        if (iItem == -1)
        {
            break;
        }

        //
        // Get the ATTR_KEY of that item
        //

        LVITEM lvi;
        //REVIEWED-2002-02-20-lucios.
        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;

        if (!ListView_GetItem(hwndLvFrom, &lvi))
        {
            DBG_OUT_LASTERROR;
            break;
        }

        ATTR_KEY ak = static_cast<ATTR_KEY>(lvi.lParam);

        //
        // Remove that item from the 'from' listview
        //

        ListView_DeleteItem(hwndLvFrom, iItem);

        // Set the selection on the next item in the 'from' listview.  The
        // next item is now at the same index as the one we just deleted.
        // NTRAID#NTBUG9-361131-2001/04/11-sburns

        int lastIndex = ListView_GetItemCount(hwndLvFrom) - 1;
               
        ListView_SetItemState(
                              hwndLvFrom,
                              min(iItem, lastIndex),
                              LVIS_SELECTED,
                              LVIS_SELECTED);
        
        //
        // Also remove it from the corresponding vector
        //

        if (idFrom == IDC_AVAILABLE_LIST)
        {
            m_vakAvailable.erase(find(m_vakAvailable.begin(), m_vakAvailable.end(), ak));
        }
        else
        {
            m_vakShown.erase(find(m_vakShown.begin(), m_vakShown.end(), ak));
        }

        //
        // Now add the item to the 'to' listview
        //

        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = ListView_GetNextItem(hwndLvTo, -1, LVNI_SELECTED);

        if (lvi.iItem == -1)
        {
            lvi.iItem = INT_MAX;
        }

        lvi.pszText = const_cast<PWSTR>(ram.GetAttrDisplayName(ak).c_str());

        iItem = ListView_InsertItem(hwndLvTo, &lvi);

        if (iItem == -1)
        {
            DBG_OUT_LASTERROR;
        }

        ListView_SetItemState(hwndLvTo,
                              iItem,
                              LVIS_SELECTED | LVIS_FOCUSED,
                              LVIS_SELECTED | LVIS_FOCUSED);
        ListView_EnsureVisible(hwndLvTo, iItem, FALSE);

        //
        // And add it to the corresponding vector
        //

        if (idTo == IDC_AVAILABLE_LIST)
        {
            m_vakAvailable.push_back(ak);
        }
        else
        {
            if (iItem == -1)
            {
                m_vakShown.push_back(ak);
            }
            else
            {
                m_vakShown.insert(m_vakShown.begin() + iItem, ak);
            }
        }

    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_OnNotify
//
//  Synopsis:   Handle WM_NOTIFY messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CColumnPickerDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);

    do
    {
        // don't care about notifications from stuff other than listviews

        if (pnmh->idFrom != IDC_AVAILABLE_LIST &&
            pnmh->idFrom != IDC_SHOWN_LIST)
        {
            break;
        }

        switch (pnmh->code)
        {
            // NTRAID#NTBUG9-503615-2002/01/15-lucios
            case NM_DBLCLK:
                int iItem;
                iItem = ListView_GetNextItem(pnmh->hwndFrom,
                                             -1,
                                             LVNI_SELECTED);

                if (iItem != -1)
                {
                    if(pnmh->idFrom==IDC_AVAILABLE_LIST) 
                    {
                        SendMessage(m_hwnd,WM_COMMAND,IDC_ADD_COL_BTN,0);
                    }
                    else
                    {
                        SendMessage(m_hwnd,WM_COMMAND,IDC_REMOVE_COL_BTN,0);
                    }
                }
            break;
            case LVN_ITEMCHANGED:
                HWND hwndBtn;
                HWND hwndFocusOnDisableBtn;

                if (pnmh->idFrom == IDC_AVAILABLE_LIST)
                {
                    hwndBtn = _hCtrl(IDC_ADD_COL_BTN);
                    hwndFocusOnDisableBtn = _hCtrl(IDC_SHOWN_LIST);
                }
                else
                {
                    hwndBtn = _hCtrl(IDC_REMOVE_COL_BTN);
                    hwndFocusOnDisableBtn = _hCtrl(IDC_AVAILABLE_LIST);
                }

                if (!hwndBtn)
                {
                    DBG_OUT_HRESULT(E_OUTOFMEMORY);
                    break;
                }
            break;
        }
    } while (0);

    return FALSE;
}



void
CColumnPickerDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CColumnPickerDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\bindinfo.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       bindinfo.cxx
//
//  Contents:   Class for keeping bind hanles in cache.
//
//  Classes:    CBindInfo
//
//  History:    20-oct-2000     hiteshr   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CBindInfo)


//===========================================================================
//
// CBindInfo
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::CBindInfo
//
//  Synopsis:   ctor
//
//  Arguments:  [pBinder]   - backpointer to parent
//              [pwzDomainDns] - Bind to a dc of this domain.
//---------------------------------------------------------------------------

CBindInfo::CBindInfo(
    CBinder *pBinder,
    PCWSTR pwzDomainDns,
    DWORD dwFlag):
        m_pBinder(pBinder),
        m_hrLastCredError(S_OK),
        m_pNext(NULL),
        m_hDs(0),
        m_dwFlag(dwFlag)
{
    //TRACE_CONSTRUCTOR(CBindInfo);
    Dbg(DEB_BIND, "CBindInfo::CBindInfo(%x) '%ws'\n", this, pwzDomainDns);
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBindInfo);

    m_strDomainPath = pwzDomainDns;

    //
    // Truncate at a trailing dot because sometimes we'll get it as
    // part of the server and sometimes we won't, and we don't want the
    // string comparison of server names to fail to match because of it.
    //
    m_strDomainPath.strip(String::TRAILING, L'.');
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::IsForDomain
//
//  Synopsis:   Return TRUE if this has a container interface for server
//              [pwzServer].
//
//  Arguments:  [flProvider] - PROVIDER_*
//              [pwzServer]  - server name
//
//  History:    08-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBindInfo::IsForDomain(
    PCWSTR pwzDomain)
{
    return !m_strDomainPath.icompare(pwzDomain);
}



//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::Init
//
//  Synopsis:   Perform the first part of the initialization of this which
//              can fail and is therefore done outside the ctor
//
//  Arguments:  [hwnd]    - for binding
//              [pwzPath] - NULL or path to bind to
//              [riid]    - identifies desired interface
//              [ppv]     - optional; on success filled with requested
//                           interface
//
//  Returns:    HRESULT
//
//  History:    07-14-1998   DavidMun   Created
//
//  Notes:      This method is only called once for each instance of this
//              class.  The _RepeatableInit() method may be called multiple
//              times.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::Init(
    HWND    hwnd)
{
    TRACE_METHOD(CBindInfo, Init);

    HRESULT hr = S_OK;
    BOOL    fUserIsLocal = IsCurrentUserLocalUser();
    BOOL    fUseDefaultCred = FALSE;
    BOOL    fPromptForCred = FALSE;
    String  userName;
    EncryptedString   password;
    BOOL    bDoneForceDiscovery = FALSE;
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    bHadDefaultCred = FALSE;
    String  strServer;
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity = 0;

    do
    {   
        if (!m_strDomainPath.length())
        {
            hr = E_POINTER;
            DBG_OUT_HRESULT(hr);
            break;
        }

       //
       //if User is logged in locally, don't attempt to bind
       //Use DefaultCred
       //
       if (fUserIsLocal)
       {
            fUseDefaultCred = TRUE;
            m_hrLastCredError = E_ACCESSDENIED;
       }
       
       while(true)
       {
            if (fUseDefaultCred || fPromptForCred)
            {
                if(fPromptForCred)
                {
                    Dbg(DEB_BIND, "Previous call tried default creds\n");
                    fPromptForCred = TRUE;

                    hr = _AskForCreds(hwnd, userName, password);
                    BREAK_ON_FAIL_HRESULT(hr);
                }
                else
                {
                    //
                    // Obtaining the container interface requires credentials.  If
                    // there are default credentials available from the binder, try
                    // using those first.  If they aren't available or result in a
                    // credential error, go into a loop prompting for and using
                    // credentials from user.
                    //

                    g_pBinder->GetDefaultCreds( PROVIDER_LDAP,
                                                userName, 
                                                password);

                    if (!userName.empty())
                    {
                        bHadDefaultCred = TRUE;
                        Dbg(DEB_BIND, "Using default credentials (%ws)\n", userName.c_str());
                    }
                    else
                    {
                        Dbg(DEB_BIND, "No default credentials, prompting\n", hr);
                        fPromptForCred = TRUE;
                        hr = _AskForCreds(hwnd, userName, password);
                        BREAK_ON_FAIL_HRESULT(hr);
                    }
                }
                //
                //UserName is in the format Domain\UserName
                //
                String sDomain;
                String sUser;
                // NTRAID#NTBUG9-548215-2002/02/20-lucios. 
                String::size_type posWhack = userName.find(L'\\');
                String::size_type posAt = userName.find(L'@');
                
                if(posWhack!=String::npos)
                {
                    sUser = userName.substr(posWhack + 1);
                    sDomain = userName.substr(0,posWhack);
                }
                else if(posAt!=String::npos)
                {
                    sDomain = userName.substr(posAt + 1);
                    sUser = userName.substr(0,posAt);
                }
                else
                {
                    ASSERT(FALSE);
                }

                if(!sUser.empty() && !sDomain.empty())
                {
                    WCHAR *pwzPassword=password.GetClearTextCopy();
                    dwErr = DsMakePasswordCredentials(sUser.c_str(),
                                                      sDomain.c_str(),
                                                      pwzPassword,
                                                      &AuthIdentity);
                    password.DestroyClearTextCopy(pwzPassword);
                    hr = HRESULT_FROM_WIN32(dwErr);
                    BREAK_ON_FAIL_HRESULT(hr);
                }

            }

            PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;

            ULONG GetDcFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED;
            if(m_dwFlag & OP_GC_SERVER_REQUIRED)
                GetDcFlags |= DS_GC_SERVER_REQUIRED;
            
            //If is DsGetDcName is not called already
            if(!strServer.length())
            {
                dwErr = DsGetDcNameW(NULL, 
                                     m_strDomainPath.c_str(), 
                                     NULL, 
                                     NULL, 
                                    GetDcFlags,
                                    &pDCInfo);
            
                hr = HRESULT_FROM_WIN32(dwErr);
                BREAK_ON_FAIL_HRESULT(hr);
                //Get the DCNAme
                strServer = pDCInfo->DomainControllerName;
                // NTRAID#NTBUG9-558892-2002/02/19-lucios.
                NetApiBufferFree(pDCInfo);
                pDCInfo = NULL;
            }

            Dbg(DEB_TRACE,"Binding to DC:'%ws'.",strServer.c_str());

            //Bind            
            if(!AuthIdentity)
            {
                dwErr = DsBind(strServer.c_str(), NULL, &m_hDs);
            }
            else
            {
                dwErr = DsBindWithCred(strServer.c_str(), 
                                       NULL, 
                                       AuthIdentity,
                                       &m_hDs);
                DsFreePasswordCredentials(AuthIdentity);
                AuthIdentity = 0;
            }

            hr = HRESULT_FROM_WIN32(dwErr);

            if (FAILED(hr))
            {
                if (IsCredError(hr))
                {
                    Dbg(DEB_BIND,
                    "NULL credentials returned credential hr %#x\n",
                    hr);

                    m_hrLastCredError = hr;
                    
                    if(!fUseDefaultCred)
                    {   
                        //
                        //Use Default Cred
                        //
                        fUseDefaultCred = TRUE;
                        continue;
                    }

                    if(!fPromptForCred)
                    {
                        //
                        //Prompt for Cred
                        //
                        fPromptForCred = TRUE;
                        continue;
                    }
                    //
                    //Keep Prompting until user presses cancel
                    //
                    continue;
                }                    
                else if(!bDoneForceDiscovery)
                {
                 
                    // Try again, the DC returned above was unavailable (i.e., the
                    // cache list was stale).
                    //
                    bDoneForceDiscovery = TRUE;
                    
                    GetDcFlags |= DS_FORCE_REDISCOVERY;
                    dwErr = DsGetDcNameW(NULL, 
                                         m_strDomainPath.c_str(), 
                                         NULL, 
                                         NULL, 
                                         GetDcFlags,
                                         &pDCInfo);

                    hr = HRESULT_FROM_WIN32(dwErr);
                    BREAK_ON_FAIL_HRESULT(hr);
                    
                    strServer = pDCInfo->DomainControllerName;                                            
                    // NTRAID#NTBUG9-558892-2002/02/19-lucios.
                    NetApiBufferFree(pDCInfo);
                    pDCInfo = NULL;            
                    
                     //Bind            
                    if(!AuthIdentity)
                    {
                        dwErr = DsBind(strServer.c_str(), NULL, &m_hDs);
                    }
                    else
                    {
                        dwErr = DsBindWithCred(strServer.c_str(), 
                                               NULL, 
                                               AuthIdentity,
                                               &m_hDs);
                        DsFreePasswordCredentials(AuthIdentity);
                        AuthIdentity = 0;
                    }
                    
                    hr = HRESULT_FROM_WIN32(dwErr);
                    if (FAILED(hr))
                    {
                        if (IsCredError(hr))
                        {
                            Dbg(DEB_BIND,
                            "NULL credentials returned credential hr %#x\n",
                            hr);
                            m_hrLastCredError = hr;
                            
                            if(!fUseDefaultCred)
                            {
                                fUseDefaultCred = TRUE;
                                continue;
                            }

                            if(!fPromptForCred)
                            {
                                fPromptForCred = TRUE;
                                continue;
                            }

                            continue;
                        }
                    }
                }
            }

            if(SUCCEEDED(hr) && fPromptForCred && !bHadDefaultCred)
            {
                g_pBinder->SetDefaultCreds( userName,
                                            password);
            }

            //If we fall through here, we don't need to reloop
            break;
        }
    } while (0);

    if (AuthIdentity) DsFreePasswordCredentials(AuthIdentity);

    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::~CBindInfo
//
//  Synopsis:   dtor
//
//  History:    04-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CBindInfo::~CBindInfo()
{
    TRACE_DESTRUCTOR(CBindInfo);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CBindInfo);
    if(m_hDs)
        DsUnBind(&m_hDs);

}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_AskForCreds
//
//  Synopsis:   Dispatch based on whether we're running in the thread that
//              created [hwndParent].
//
//  Arguments:  [hwndParent] - parent for modal password dialog
//              [wzUserName] - buffer to fill with name entered by user
//              [wzPassword] - buffer to fill with password entered by user
//
//  Returns:    S_OK if user enters credentials.
//              E_* if password dialog couldn't be opened.
//              Last credential error if user cancels password dialog.
//
//  Modifies:   *[wzUserName], *[wzPassword]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called by CBindInfo::OpenObject when it gets a credential
//              error.
//
//              This method blocks until password dialog is closed.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::_AskForCreds(
    HWND hwndParent,
    String &userName,
    EncryptedString &password)
{
    TRACE_METHOD(CBindInfo, _AskForCreds);

    HRESULT hr;

    //
    // This method is called via g_pBinder->BindToObject which itself may
    // be called from either thread.
    //
    // If we're running in the primary thread, use SendMessage to call
    // the routine that invokes the password dialog.
    //
    // If in non-primary thread post message to main thread to
    // pop up password dialog, then wait on event for it to complete.
    //

    ASSERT(!hwndParent || IsWindow(hwndParent));

    if (!hwndParent
        || GetWindowLongPtr(hwndParent, DWLP_DLGPROC) != (LONG_PTR) CDlg::_DlgProc)
    {
        Dbg(DEB_TRACE, "hwndParent = %#x, invoking password dialog directly\n", hwndParent);
        CPasswordDialog PasswordDlg(PROVIDER_LDAP,
                                    m_strDomainPath.c_str(),
                                    &userName,
                                    &password);

        hr = PasswordDlg.DoModalDialog(hwndParent);
    }
    else if (GetWindowThreadProcessId(hwndParent, NULL) == GetCurrentThreadId())
    {
        hr = _AskForCredsViaSendMessage(hwndParent, userName, password);
    }
    else
    {
        hr = _AskForCredsViaPostMessage(hwndParent, userName, password);
    }

    if (hr == S_FALSE)
    {
        hr = m_hrLastCredError;
    }
    else if (SUCCEEDED(hr))
    {
        //
        // If the username is neither in NT4 (domain\user) or UPN
        // (user@domain) format, then the bind will definitely fail.
        // If that's the case, change the name to domain\user, where
        // domain is the name of the thing we're trying to get access
        // to.
        //

        if ( (userName.find(L'\\')==String::npos) && (userName.find(L'@')==String::npos) )
        {
            String strNewName(m_strDomainPath);

            //
            // Strip port number, if any
            //

            if (strNewName.find(L':') != String::npos)
            {
                strNewName.erase(strNewName.find(L':'),
                                 String::npos);
            }

            //
            // If the server looks like a DNS name (contains at least one
            // '.' and one alpha character), use UPN format.
            // Otherwise assume it is a netbios or ip address and use NT4
            // format.
            //

            if (strNewName.find(L'.') != String::npos &&
                find_if(strNewName.begin(), strNewName.end(), IsCharAlpha) !=
                strNewName.end())
            {
                strNewName.insert(0, L"@");
                strNewName.insert(0, userName);

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    userName.c_str(),
                    strNewName.c_str());
                
                // NTRAID#NTBUG9-548991-2002/02/20-lucios.
                userName=strNewName;
            }
            else
            {
                strNewName += L"\\";
                strNewName += userName;

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    userName.c_str(),
                    strNewName.c_str());

                // NTRAID#NTBUG9-548991-2002/02/20-lucios. 
                userName=strNewName;
            }
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_AskForCredsViaSendMessage
//
//  Synopsis:   Use SendMessage to call the CDsBrowseMgr routine that invokes
//              the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from main thread.  Blocks until password dialog
//              closes.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::_AskForCredsViaSendMessage(
    HWND hwndParent,
    String &userName,
    EncryptedString &password)
{
    TRACE_METHOD(CBindInfo, _AskForCredsViaSendMessage);
    CRED_MSG_INFO cmi = {
                            PROVIDER_LDAP,
                            m_strDomainPath.c_str(),
                            &userName,
                            &password,
                            NULL,
                            S_OK
                        };

    SendMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_AskForCredsViaPostMessage
//
//  Synopsis:   Request that the main thread put up the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from worker thread.  Blocks until main thread
//              sets event after password dialog closes.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::_AskForCredsViaPostMessage(
    HWND hwndParent,
    String &userName,
    EncryptedString &password)
{
    TRACE_METHOD(CBindInfo, _AskForCredsViaPostMessage);
    ASSERT(hwndParent && IsWindow(hwndParent));

    CRED_MSG_INFO cmi = {
                            PROVIDER_LDAP,
                            m_strDomainPath.c_str(),
                            &userName,
                            &password,
                            NULL,
                            S_OK
                        };

    cmi.hPrompt = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!cmi.hPrompt)
    {
        DBG_OUT_LASTERROR;
        cmi.hr = HRESULT_FROM_LASTERROR;
        return cmi.hr;
    }

    PostMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);

    WaitForSingleObject(cmi.hPrompt, INFINITE);
    CloseHandle(cmi.hPrompt);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_PopupCredErr
//
//  Synopsis:   Pop up a dialog indicating a failure with the credentials
//              the user entered and block until the dialog is dismissed
//
//  Arguments:  [hwnd]        - parent wiindow
//              [ids]         - resource id of dialog message
//              [pwzUserName] - name used in creds
//              [pwzError]    - error received when using them
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      This method may safely be called from the worker thread
//
//---------------------------------------------------------------------------

// NTRAID#NTBUG9-533194-2002/06/27-artm  Removed unused function CBindInfo::_PopupCredErr().
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\classfac.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       cmpdtacf.cxx
//
//  Contents:   Implementation of class factory for ComponentData object.
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CDsObjectPickerCF)

//============================================================================
//
// IUnknown implementation
//
//============================================================================




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDsObjectPickerCF::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    TRACE_METHOD(CDsObjectPickerCF, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IClassFactory *)this;
        }
        else if (IsEqualIID(riid, IID_IClassFactory))
        {
            *ppvObj = (IUnknown *)(IClassFactory *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CDsObjectPickerCF", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDsObjectPickerCF::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDsObjectPickerCF::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IClassFactory implementation
//
//============================================================================




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::CreateInstance
//
//  Synopsis:   Create a new instance of a data source object.
//
//  Arguments:  [pUnkOuter] - must be NULL
//              [riid]      - must be interface supported by DSO
//              [ppvObj]    - filled with requested interface on success
//
//  Returns:    CLASS_E_NOAGGREGATION among others
//
//  Modifies:   *[ppvObj]
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDsObjectPickerCF::CreateInstance(
    IUnknown    *pUnkOuter,
    REFIID       riid,
    LPVOID      *ppvObj)
{
    TRACE_METHOD(CDsObjectPickerCF, CreateInstance);
    HRESULT hr = S_OK;
    CObjectPicker *pop = NULL;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        // Init for failure case

        *ppvObj = NULL;

        if (pUnkOuter != NULL)
        {
            hr = CLASS_E_NOAGGREGATION;
            DBG_OUT_HRESULT(hr);
            break;
        }

        pop = new CObjectPicker;

        //
        // Try to get the requested interface.  Since the CComponentData
        // object starts with a refcount of 1, release after the QI.  If
        // the QI succeeded, the ComponentData will end up with a refcount
        // of 1.  If it failed, the ComponentData will have self-destructed.
        //

        hr = pop->QueryInterface(riid, ppvObj);
        pop->Release();
        CHECK_HRESULT(hr);
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::LockServer
//
//  Synopsis:   Inc or dec the DLL lock count
//
//  Arguments:  [fLock] - TRUE increment, FALSE decrement
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDsObjectPickerCF::LockServer(
    BOOL fLock)
{
    TRACE_METHOD(CDsObjectPickerCF, LockServer);
    CDll::LockServer(fLock);

    return S_OK;
}



//============================================================================
//
// Non-interface member function implementation
//
//============================================================================



//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::CDsObjectPickerCF
//
//  Synopsis:   ctor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CDsObjectPickerCF::CDsObjectPickerCF():
    m_cRefs(1)
{
    TRACE_CONSTRUCTOR(CDsObjectPickerCF);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObjectPickerCF);
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::~CDsObjectPickerCF
//
//  Synopsis:   dtor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CDsObjectPickerCF::~CDsObjectPickerCF()
{
    TRACE_DESTRUCTOR(CDsObjectPickerCF);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CDsObjectPickerCF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\commonqueriestab.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       CommonQueriesDlg.cxx
//
//  Contents:   Implementation of dialog that produces an LDAP filter for
//              a number of common queries.
//
//  Classes:    CCommonQueriesTab
//
//  History:    04-03-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <ntdsadef.h> // MAX_RDN_SIZE
#define MAX_DESC_SIZE 1024

static ULONG
s_aulHelpIds[] =
{
    IDC_NAME_COMBO,             IDH_NAME_COMBO,
    IDC_NAME_EDIT,              IDH_NAME_EDIT,
    IDC_DESCRIPTION_COMBO,      IDH_DESCRIPTION_COMBO,
    IDC_DESCRIPTION_EDIT,       IDH_DESCRIPTION_EDIT,
    IDC_DISABLED_CKBOX,         IDH_DISABLED_CKBOX,
    IDC_NON_EXPIRING_CKBOX,     IDH_NON_EXPIRING_CKBOX,
    IDC_LASTLOGON_COMBO,        IDH_LASTLOGON_COMBO,
    IDC_LASTLOGON_LBL,          IDH_LASTLOGON_LBL,
    IDC_DESCRIPTION_LBL,        IDH_DESCRIPTION_LBL,
    IDC_NAME_LBL,               IDH_NAME_LBL1,                
    0,0
};

//
// Forward references
//

void
GetCurrentTimeStampMinusInterval(
    int iDays,
    ULARGE_INTEGER* pULI);


//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::CCommonQueriesTab
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CCommonQueriesTab::CCommonQueriesTab(
    const CObjectPicker &rop):
        CAdvancedDlgTab(rop),
        m_pfnFindValidCallback(NULL),
        m_CallbackLparam(0),
        m_flUser(0),
        m_fDescriptionIsPrefix(TRUE),
        m_fNameIsPrefix(TRUE),
        m_cDaysSinceLastLogon(0)
{
    TRACE_CONSTRUCTOR(CCommonQueriesTab);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::~CCommonQueriesTab
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CCommonQueriesTab::~CCommonQueriesTab()
{
    TRACE_DESTRUCTOR(CCommonQueriesTab);

    m_pfnFindValidCallback = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::DoModelessDlg
//
//  Synopsis:   Invoke the common queries subdialog as a child of the
//              tab control with window handle [hwndTab].
//
//  Arguments:  [hwndTab] - handle to parent tab control's window
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::DoModelessDlg(
    HWND hwndTab)
{
    TRACE_METHOD(CCommonQueriesTab, DoModelessDlg);

    HWND hwndDlg = _DoModelessDlg(hwndTab, IDD_COMMON_QUERIES);

    if (!hwndDlg)
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::Show
//
//  Synopsis:   Make the common queries child dialog visible and enable
//              its child controls as appropriate
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::Show() const
{
    TRACE_METHOD(CCommonQueriesTab, Show);

    ShowWindow(m_hwnd, SW_SHOW);
    SafeEnableWindow(m_hwnd, TRUE);
    Refresh();
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::Hide
//
//  Synopsis:   Hide the common queries child dialog and ensure its child
//              controls are disabled
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::Hide() const
{
    TRACE_METHOD(CCommonQueriesTab, Hide);

    ShowWindow(m_hwnd, SW_HIDE);
    _EnableChildControls(FALSE);
    SafeEnableWindow(m_hwnd, FALSE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_EnableChildControls
//
//  Synopsis:   Enable or disable child window controls.
//
//  Arguments:  [fEnable] - TRUE: enable the child window controls
//                          FALSE: disable all child controls.
//
//  History:    05-11-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::_EnableChildControls(
    BOOL fEnable) const
{
    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    //
    // If caller wants to disable, or the current scope is invalid or
    // downlevel, disable all child controls.
    //

    if (!fEnable ||
        rCurScope.Type() == ST_INVALID ||
        IsDownlevel(rCurScope))
    {
        SafeEnableWindow(_hCtrl(IDC_NAME_LBL), FALSE);
        SafeEnableWindow(_hCtrl(IDC_NAME_COMBO), FALSE);
        SafeEnableWindow(_hCtrl(IDC_NAME_EDIT), FALSE);
        SafeEnableWindow(_hCtrl(IDC_DESCRIPTION_LBL), FALSE);
        SafeEnableWindow(_hCtrl(IDC_DESCRIPTION_COMBO), FALSE);
        SafeEnableWindow(_hCtrl(IDC_DESCRIPTION_EDIT), FALSE);
        SafeEnableWindow(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        SafeEnableWindow(_hCtrl(IDC_NON_EXPIRING_CKBOX), FALSE);
        Button_SetCheck(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        Button_SetCheck(_hCtrl(IDC_NON_EXPIRING_CKBOX), FALSE);
        Edit_SetText(_hCtrl(IDC_NAME_EDIT), L"");
        Edit_SetText(_hCtrl(IDC_DESCRIPTION_EDIT), L"");
        SafeEnableWindow(_hCtrl(IDC_LASTLOGON_LBL), FALSE);
        SafeEnableWindow(_hCtrl(IDC_LASTLOGON_COMBO), FALSE);
        return;
    }

    //
    // Figure out which controls to enable given the look-for and look-in
    // selections.  Name is always enabled.
    //

    BOOL fEnableDescription = TRUE;
    BOOL fEnableObjectDisabled = TRUE;
    BOOL fEnableNonExpPwd = TRUE;
    BOOL fEnableLastLogon = TRUE;

    ULONG flCur = rfm.GetCurScopeSelectedFilterFlags();
    ASSERT(!(flCur & DOWNLEVEL_FILTER_BIT));
    ASSERT(flCur);

    if (flCur & (ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS |
                 DSOP_FILTER_EXTERNAL_CUSTOMIZER))
    {
        fEnableDescription = FALSE;
        fEnableObjectDisabled = FALSE;
        fEnableNonExpPwd = FALSE;
        fEnableLastLogon = FALSE;
    }

    if (flCur & (ALL_UPLEVEL_GROUP_FILTERS | DSOP_FILTER_CONTACTS))
    {
        fEnableObjectDisabled = FALSE;
        fEnableNonExpPwd = FALSE;
        fEnableLastLogon = FALSE;
    }

    if (flCur & DSOP_FILTER_COMPUTERS)
    {
        fEnableNonExpPwd = FALSE;
    }

    // the lastLogonTimestamp doesn't propagate to GC
    if (rCurScope.Type() == ST_GLOBAL_CATALOG)
    {
        fEnableLastLogon = FALSE;
    }

    //
    // Set enable/disable state of all controls
    //

    // name
    SafeEnableWindow(_hCtrl(IDC_NAME_LBL), TRUE);
    SafeEnableWindow(_hCtrl(IDC_NAME_COMBO), TRUE);
    SafeEnableWindow(_hCtrl(IDC_NAME_EDIT), TRUE);
    Edit_SetText(_hCtrl(IDC_NAME_EDIT), m_strName.c_str());

    // description
    SafeEnableWindow(_hCtrl(IDC_DESCRIPTION_LBL), fEnableDescription);
    SafeEnableWindow(_hCtrl(IDC_DESCRIPTION_COMBO), fEnableDescription);
    SafeEnableWindow(_hCtrl(IDC_DESCRIPTION_EDIT), fEnableDescription);

    if (fEnableDescription)
    {
        Edit_SetText(_hCtrl(IDC_DESCRIPTION_EDIT), m_strDescription.c_str());
    }
    else
    {
        Edit_SetText(_hCtrl(IDC_DESCRIPTION_EDIT), L"");
    }

    // non-expiring password
    SafeEnableWindow(_hCtrl(IDC_NON_EXPIRING_CKBOX), fEnableNonExpPwd);

    if (fEnableNonExpPwd && (m_flUser & UF_DONT_EXPIRE_PASSWD))
    {
        Button_SetCheck(_hCtrl(IDC_NON_EXPIRING_CKBOX), TRUE);
    }
    else
    {
        Button_SetCheck(_hCtrl(IDC_NON_EXPIRING_CKBOX), FALSE);
    }

    // object disabled
    if (!g_fExcludeDisabled)
    {
        SafeEnableWindow(_hCtrl(IDC_DISABLED_CKBOX), fEnableObjectDisabled);
        if (fEnableObjectDisabled && (m_flUser & UF_ACCOUNTDISABLE))
        {
            Button_SetCheck(_hCtrl(IDC_DISABLED_CKBOX), TRUE);
        }
        else
        {
            Button_SetCheck(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        }
    }

    // last logon
    SafeEnableWindow(_hCtrl(IDC_LASTLOGON_LBL), fEnableLastLogon);
    SafeEnableWindow(_hCtrl(IDC_LASTLOGON_COMBO), fEnableLastLogon);
}




void
CCommonQueriesTab::Save(
    IPersistStream *pstm) const
{
}




void
CCommonQueriesTab::Load(
    IPersistStream *pstm)
{
}



//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::GetLdapFilter
//
//  Synopsis:   Return the LDAP filter specified by the settings of the
//              child controls
//
//  Returns:    LDAP filter
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Filter returned contains the filter specified by current
//              Look For and Look In settings, concatenated with a more
//              specific filter based on child controls.
//
//---------------------------------------------------------------------------

String
CCommonQueriesTab::GetLdapFilter() const
{
    TRACE_METHOD(CCommonQueriesTab, GetLdapFilter);

    //
    // Get the LDAP filter associated with the current scope.  If it's
    // empty, return.
    //

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    const CFilterManager &rfm = m_rop.GetFilterManager();
    String strScopeFilter = rfm.GetLdapFilter(m_hwnd, rCurScope);

    if (strScopeFilter.empty())
    {
        return strScopeFilter;
    }

    //
    // Construct the filter based on the dialog control values and
    // concatenate it to the scope filter.
    //

    String strQuery;

    if (!m_strName.empty())
    {
        String strEscaped(m_strName);
        LdapEscape(&strEscaped);

        if (m_fNameIsPrefix)
        {
            if (m_strName.find(L'@') != String::npos)
            {
                strQuery += String::format(c_wzUpnQueryFormat, strEscaped.c_str());
            }
            else
            {
                strQuery += String::format(c_wzCnQueryFormat, strEscaped.c_str());
            }
        }
        else
        {
            if (m_strName.find(L'@') != String::npos)
            {
                strQuery += String::format(c_wzUpnQueryFormatExact, strEscaped.c_str());
            }
            else
            {
                strQuery += String::format(c_wzCnQueryFormatExact, strEscaped.c_str());
            }
        }
    }

    if (!m_strDescription.empty())
    {
        String strEscaped(m_strDescription);
        LdapEscape(&strEscaped);

        //
        // A leading space is not significant inside the ldap filter, so we
        // must escape it to get it noticed.  We do this only for
        // descriptions, not for names, as it seems unlikely that any RDNs
        // will have leading spaces.
        //

        if (strEscaped[0] == L' ')
        {
            strEscaped.erase(strEscaped.begin());
            strEscaped.insert(0, String(L"\\20"));
        }

        strQuery += L"(description=" + strEscaped;

        if (m_fDescriptionIsPrefix)
        {
            strQuery += L"*";
        }
        strQuery += L")";
    }

    if (m_flUser)
    {
        WCHAR wzUserFlag[20];

        strQuery += L"(userAccountControl:" LDAP_MATCHING_RULE_BIT_AND_W;
        // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
        wsprintf(wzUserFlag, L":=%u", m_flUser);
        strQuery += wzUserFlag;
        strQuery += L")";
    }

    if (m_cDaysSinceLastLogon)
    {
        ULARGE_INTEGER li;

        GetCurrentTimeStampMinusInterval(m_cDaysSinceLastLogon, &li);
        strQuery += L"(lastLogonTimestamp<=" + UliToStr(li) + L")";
    }

    if (strQuery.empty())
    {
        return strScopeFilter;
    }
    return L"(&" + strScopeFilter + strQuery + L")";
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::GetCustomizerInteraction
//
//  Synopsis:   Set the interaction the query engine should use
//              with the ICustomizeDsBrowser interface.
//
//
//  Arguments:  [pInteraction]      - filled with CUSTINT_* enum
//              [pstrCustomizerArg] - if *[pInteraction] is not set to
//                                     CUSTINT_IGNORE_CUSTOM_OBJECTS this
//                                     string is optionally filled with a
//                                     value to give the customizer.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------
// NTRAID#NTBUG9-529086-2002/06/24-lucios changed considerably this code
void
CCommonQueriesTab::GetCustomizerInteraction(
    CUSTOMIZER_INTERACTION  *pInteraction,
    BOOL *pPerformExternalCustomization,
    BOOL *pPerformDefaultCustomization,
    String *pstrCustomizerArg) const
{
    TRACE_METHOD(CCommonQueriesTab, GetCustomizerInteraction);

    *pPerformExternalCustomization=FALSE;
    *pPerformDefaultCustomization=FALSE;
    *pInteraction = CUSTINT_IGNORE_CUSTOM_OBJECTS;
    ULONG flags = m_rop.GetFilterManager().GetCurScopeSelectedFilterFlags();

    
    // Custom objects will only be included if the only search is on the
    // name attribute.
    if (m_flUser || !m_strDescription.empty()) return;

    if( flags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS )
    {
        *pPerformDefaultCustomization=TRUE;
    }
    
    if 
    ( 
        (flags & DSOP_FILTER_EXTERNAL_CUSTOMIZER) &&  
        m_rop.GetExternalCustomizer() 
    )
    {
        *pPerformExternalCustomization=TRUE;
    }

    *pstrCustomizerArg   = m_strName;

    // We set the interaction based on the
    // Starts With/Is Exactly field.
    if 
    (
        m_fNameIsPrefix && 
        (pPerformDefaultCustomization || pPerformExternalCustomization)
    )
    {
        *pInteraction = CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS;
    }
    else
    {
        *pInteraction = CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS;
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::Refresh
//
//  Synopsis:   Enable child windows as appropriate for current Look For
//              and Look In settings and update the state of the Find Now
//              button.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::Refresh() const
{
    TRACE_METHOD(CCommonQueriesTab, Refresh);

    //
    // Enable whichever of the child controls are applicable for the
    // current scope and look-in
    //

    _EnableChildControls(TRUE);

    //
    // Read all child controls and update the find now button enabled state
    //

    _ReadChildControls();
    _UpdateFindNow();
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_ReadChildControls
//
//  Synopsis:   Store the values in the child controls in member variables.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::_ReadChildControls() const
{
    m_fNameIsPrefix = !ComboBox_GetCurSel(_hCtrl(IDC_NAME_COMBO));
    m_fDescriptionIsPrefix = !ComboBox_GetCurSel(_hCtrl(IDC_DESCRIPTION_COMBO));

    _ReadEditCtrl(IDC_NAME_EDIT, &m_strName);
    m_strName.strip(String::BOTH);

    _ReadEditCtrl(IDC_DESCRIPTION_EDIT, &m_strDescription);

    m_flUser = 0;

    if (IsWindowEnabled(_hCtrl(IDC_DISABLED_CKBOX)) &&
        IsDlgButtonChecked(m_hwnd, IDC_DISABLED_CKBOX))
    {
        m_flUser |= UF_ACCOUNTDISABLE;
    }

    if (IsWindowEnabled(_hCtrl(IDC_NON_EXPIRING_CKBOX)) &&
        IsDlgButtonChecked(m_hwnd, IDC_NON_EXPIRING_CKBOX))
    {
        m_flUser |= UF_DONT_EXPIRE_PASSWD;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_UpdateFindNow
//
//  Synopsis:   Use the Advanced dialog's callback function to set the
//              state of the Find Now button.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::_UpdateFindNow() const
{
    if (!m_pfnFindValidCallback)
    {
        return;
    }

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
    {
        m_pfnFindValidCallback(TRUE, m_CallbackLparam);
        return;
    }

    const CFilterManager &rfm = m_rop.GetFilterManager();
    ULONG flCur = rfm.GetCurScopeSelectedFilterFlags();

    // NTRAID#NTBUG9-480121-2001/10/12-lucios
    // Added DSOP_FILTER_EXTERNAL_CUSTOMIZER
    flCur &= (ALL_UPLEVEL_GROUP_FILTERS
              | ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS
              | DSOP_FILTER_CONTACTS
              | DSOP_FILTER_USERS
              | DSOP_FILTER_COMPUTERS
              | DSOP_FILTER_EXTERNAL_CUSTOMIZER);

    m_pfnFindValidCallback(flCur != 0, m_CallbackLparam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::SetFindValidCallback
//
//  Synopsis:   Store the Advanced dialog's callback.
//
//  Arguments:  [pfnFindValidCallback] - pointer to callback function
//              [lParam]               - argument to give it
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::SetFindValidCallback(
    PFN_FIND_VALID pfnFindValidCallback,
    LPARAM lParam)
{
    m_pfnFindValidCallback = pfnFindValidCallback;
    m_CallbackLparam = lParam;
}




//
// LASTLOGON_DAYS - used to initialize the combobox and compute the value
// to query for.
//

struct LASTLOGON_DAYS
{
    PCWSTR  wzDays;
    ULONG   ulDays;
};

static LASTLOGON_DAYS s_aLastLogonDays[] =
{
    { L"",      0 },
    { L"30",   30 },
    { L"60",   60 },
    { L"90",   90 },
    { L"120", 120 },
    { L"180", 180 }
};




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_OnInit
//
//  Synopsis:   Initialize the dialog
//
//  Arguments:  [pfSetFocus] -
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CCommonQueriesTab::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CCommonQueriesTab, _OnInit);
    HRESULT hr = S_OK;

    hr = AddStringToCombo(_hCtrl(IDC_NAME_COMBO), IDS_STARTS_WITH);
    CHECK_HRESULT(hr);

    hr = AddStringToCombo(_hCtrl(IDC_NAME_COMBO), IDS_IS_EXACTLY);
    CHECK_HRESULT(hr);

    hr = AddStringToCombo(_hCtrl(IDC_DESCRIPTION_COMBO), IDS_STARTS_WITH);
    CHECK_HRESULT(hr);

    hr = AddStringToCombo(_hCtrl(IDC_DESCRIPTION_COMBO), IDS_IS_EXACTLY);
    CHECK_HRESULT(hr);

    ULONG i;

    for (i = 0; i < ARRAYLEN(s_aLastLogonDays); i++)
    {
        ComboBox_AddString(_hCtrl(IDC_LASTLOGON_COMBO),
                           s_aLastLogonDays[i].wzDays);
    }

    ComboBox_SetCurSel(_hCtrl(IDC_NAME_COMBO), 0);
    ComboBox_SetCurSel(_hCtrl(IDC_DESCRIPTION_COMBO), 0);
    ComboBox_SetCurSel(_hCtrl(IDC_LASTLOGON_COMBO), 0);

    if (g_fExcludeDisabled)
    {
        SafeEnableWindow(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        ShowWindow(_hCtrl(IDC_DISABLED_CKBOX), SW_HIDE);
    }


    // NTRAID#NTBUG9-439255-2001/08/23-lucios
    EnableThemeDialogTexture(m_hwnd,ETDT_ENABLETAB);

    // NTRAID#NTBUG9-638235-2002/06/11-lucios
    SendMessage( _hCtrl(IDC_NAME_EDIT),EM_LIMITTEXT,MAX_RDN_SIZE,0);
    SendMessage( _hCtrl(IDC_DESCRIPTION_EDIT),EM_LIMITTEXT,MAX_DESC_SIZE,0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CCommonQueriesTab::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDC_NAME_EDIT:
        if (HIWORD(wParam) == EN_UPDATE &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            _ReadEditCtrl(IDC_NAME_EDIT, &m_strName);
            // NTRAID#NTBUG9-486071-2002/01/15-lucios removed  m_strName.strip(String::BOTH);
            _UpdateFindNow();
        }
        break;

    case IDC_DESCRIPTION_EDIT:
        if (HIWORD(wParam) == EN_UPDATE &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            _ReadEditCtrl(IDC_DESCRIPTION_EDIT, &m_strDescription);
            _UpdateFindNow();
        }
        break;

    case IDC_DISABLED_CKBOX:
        if (IsDlgButtonChecked(m_hwnd, IDC_DISABLED_CKBOX) &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_flUser |= UF_ACCOUNTDISABLE;
        }
        else
        {
            m_flUser &= ~UF_ACCOUNTDISABLE;
        }
        _UpdateFindNow();
        break;

    case IDC_NON_EXPIRING_CKBOX:
        if (IsDlgButtonChecked(m_hwnd, IDC_NON_EXPIRING_CKBOX) &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_flUser |= UF_DONT_EXPIRE_PASSWD;
        }
        else
        {
            m_flUser &= ~UF_DONT_EXPIRE_PASSWD;
        }
        _UpdateFindNow();
        break;

    case IDC_NAME_COMBO:
        if (IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_fNameIsPrefix =
                !ComboBox_GetCurSel(reinterpret_cast<HWND>(lParam));
        }
        break;

    case IDC_DESCRIPTION_COMBO:
        if (IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_fDescriptionIsPrefix =
                !ComboBox_GetCurSel(reinterpret_cast<HWND>(lParam));
        }
        break;

    case IDC_LASTLOGON_COMBO:
        if (IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            int iCurSel = ComboBox_GetCurSel(reinterpret_cast<HWND>(lParam));

            if (iCurSel != CB_ERR)
            {
                m_cDaysSinceLastLogon = s_aLastLogonDays[iCurSel].ulDays;
            }
            else
            {
                m_cDaysSinceLastLogon = 0;
            }
        }
        break;

    default:
        fNotHandled = TRUE;
        break;
    }
    return fNotHandled;
}




BOOL
CCommonQueriesTab::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetCurrentTimeStampMinusInterval
//
//  Synopsis:   Calculate a value to be used in an LDAP filter for
//              querying against the lastLogonTimestamp attribute.
//
//  Arguments:  [iDays] - number of days in the past to calculate
//              [pULI]  - filled with current time minus [iDays] days.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
GetCurrentTimeStampMinusInterval(
    int iDays,
    ULARGE_INTEGER* pULI)
{
    ASSERT(pULI);

    FILETIME ftCurrent;
    GetSystemTimeAsFileTime(&ftCurrent);

    pULI->LowPart = ftCurrent.dwLowDateTime;
    pULI->HighPart = ftCurrent.dwHighDateTime;
    pULI->QuadPart -= ((((ULONGLONG)iDays * 24) * 60) * 60) * 10000000;
}


void
CCommonQueriesTab::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CCommonQueriesTab, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\dataobj.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       dataobj.cxx
//
//  Contents:   Implementation of data object class
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


UINT CDataObject::s_cfDsSelectionList =
    RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

UINT CDataObject::s_cfDsObjectList =
    RegisterClipboardFormat(CFSTR_DSOP_DS_OBJECT_LIST);

DEBUG_DECLARE_INSTANCE_COUNTER(CDataObject)


//+--------------------------------------------------------------------------
//
//  Class:      CDataObjectReleaser
//
//  Purpose:    Helper class to clean up the hglobal and associated
//              VARIANTs returned by the data object.
//
//  History:    3-08-1999   DavidMun   Created
//
//  Notes:      Inherits from IUnknown, but only Release is implemented.
//
//---------------------------------------------------------------------------

class CDataObjectReleaser: public IUnknown
{
public:

    //
    // IUnknown overrides
    //

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef) ();

    STDMETHOD_(ULONG, Release) ();


    CDataObjectReleaser(
        HGLOBAL hGlobal);

    ~CDataObjectReleaser();

private:

    HGLOBAL m_hGlobal;
};



//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::CDataObjectReleaser
//
//  Synopsis:   cdor
//
//  Arguments:  [hGlobal] - global to free on release
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObjectReleaser::CDataObjectReleaser(
    HGLOBAL hGlobal):
        m_hGlobal(hGlobal)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CDataObjectReleaser);
    ASSERT(hGlobal);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::~CDataObjectReleaser
//
//  Synopsis:   dtor
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObjectReleaser::~CDataObjectReleaser()
{
    TRACE_DESTRUCTOR_EX(DEB_DATAOBJECT, CDataObjectReleaser);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::AddRef
//
//  Synopsis:   Not implemented.
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObjectReleaser::AddRef()
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObjectReleaser, AddRef);
    ASSERT(0 && "CDataObjectReleaser::AddRef should never be called!");
    return 1;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::Release
//
//  Synopsis:   Free all memory held in or referenced by the global
//              memory block containing a DS_SELECTION_LIST.
//
//  Returns:    0
//
//  History:    3-05-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObjectReleaser::Release()
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObjectReleaser, Release);
    ASSERT(m_hGlobal);

    PDS_SELECTION_LIST pdssel = NULL;

    do
    {
        pdssel = (PDS_SELECTION_LIST)GlobalLock(m_hGlobal);

        if (!pdssel)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        //
        // If there aren't any attributes, there are no variants to
        // worry about.
        //

        if (!pdssel->cFetchedAttributes)
        {
            break;
        }

        //
        // Clear all the variants for each object.
        //

        ULONG i;

        for (i = 0; i < pdssel->cItems; i++)
        {
            pdssel->aDsSelection[i].pvarFetchedAttributes;

            ULONG j;

            for (j = 0; j < pdssel->cFetchedAttributes; j++)
            {
                VariantClear(&pdssel->aDsSelection[i].pvarFetchedAttributes[j]);
            }
        }
    } while (0);

    if (pdssel)
    {
        GlobalUnlock(m_hGlobal);
    }

    GlobalFree(m_hGlobal);
    m_hGlobal = NULL;
    delete this;

    return 0;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::QueryInterface
//
//  Synopsis:   Not implemented.
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObjectReleaser::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObjectReleaser, QueryInterface);
    ASSERT(0 && "CDataObjectReleaser::QueryInteface should never be called!");
    return E_NOTIMPL;
}



//============================================================================
//
// IUnknown implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    // TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CDataObject", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDataObject::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CDataObject::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObject::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IDataObject implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetData
//
//  Synopsis:   Return data in the requested format
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetData(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, GetData);

    HRESULT hr = S_OK;

    //
    // Init default output medium.  If any of the individual _getdata*
    // methods use something else, they can override.
    //

    pMedium->pUnkForRelease = NULL;
    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = NULL;

    if (m_dsol.empty() && m_strData.empty())
    {
        return S_FALSE;
    }

    try
    {
        if (pFormatEtc->cfFormat == s_cfDsObjectList)
        {
            hr = _GetDataDsol(pFormatEtc, pMedium);
        }
        else if (pFormatEtc->cfFormat == s_cfDsSelectionList)
        {
            hr = _GetDataDsSelList(pFormatEtc, pMedium);
        }
        else if (pFormatEtc->cfFormat == CF_UNICODETEXT ||
                 pFormatEtc->cfFormat == CF_TEXT)
        {
            hr = _GetDataText(pFormatEtc, pMedium, pFormatEtc->cfFormat);
        }
        else
        {
            hr = DV_E_FORMATETC;
    #if (DBG == 1)
            Dbg(DEB_WARN,
                "CDataObject::GetData: unrecognized cf %#x\n",
                pFormatEtc->cfFormat);
    #endif // (DBG == 1)
        }
    }
    catch (const exception &e)
    {
        Dbg(DEB_ERROR, "Caught exception %s\n", e.what());
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_GetDataDsol
//
//  Synopsis:   Return data in the internal format of a CDsObjectList.
//
//  History:    01-18-1999   DavidMun   Created
//
//  Notes:      WinNT group classes remain "LocalGroup" and "GlobalGroup".
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_GetDataDsol(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, _GetDataDsol);
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    CDsObjectList *pdsolCopy = new CDsObjectList(m_dsol);

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   sizeof(CDsObjectList **));

    if (!pMedium->hGlobal)
    {
        delete pdsolCopy;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return STG_E_MEDIUMFULL;
    }

    *(CDsObjectList **)GlobalLock(pMedium->hGlobal) = pdsolCopy;
    GlobalUnlock(pMedium->hGlobal);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_GetDataText
//
//  Synopsis:   Return data in text format
//
//  Arguments:  [pFormatEtc] -
//              [pMedium]    -
//              [cf]         - CF_TEXT or CF_UNICODETEXT
//
//  History:    5-21-1999   davidmun   Created
//
//  Notes:      Returns empty string unless this was constructed with
//              handle to rich edit control.
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_GetDataText(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium,
        ULONG      cf)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, _GetDataText);
    ASSERT(cf == CF_TEXT || cf == CF_UNICODETEXT);
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    HRESULT hr = S_OK;
    ULONG   cbChar = (ULONG)((cf == CF_UNICODETEXT) ? sizeof(WCHAR) : sizeof(CHAR));
    ULONG   cbMedium = cbChar * (static_cast<ULONG>(m_strData.length()) + 1);

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   cbMedium);

    if (!pMedium->hGlobal)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return STG_E_MEDIUMFULL;
    }

    PVOID pvMedium = GlobalLock(pMedium->hGlobal);

    if (cf == CF_UNICODETEXT)
    {
        // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
        // This method returns an HRESULT, it might be a good candidate for strsafe.
        lstrcpy((PWSTR)pvMedium, m_strData.c_str());
    }
    else
    {
        hr = UnicodeToAnsi((PSTR)pvMedium, m_strData.c_str(), cbMedium);
    }
    GlobalUnlock(pMedium->hGlobal);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_GetDataDsSelList
//
//  Synopsis:   Return data in the public format of a buffer containing a
//              DS_SELECTION_LIST variable length structure.
//
//  History:    01-18-1999   DavidMun   Created
//
//  Notes:      WinNT group classes are translated from the internal
//              representation of "LocalGroup" and "GlobalGroup" to
//              "Group".
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_GetDataDsSelList(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, _GetDataDsSelList);
    ASSERT(m_dsol.size());
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    //
    // Determine the amount of memory to allocate:
    // First the header structure, DS_SELECTION_LIST
    //

    BOOL  fLockedMem = FALSE;
    size_t cbRequired = sizeof(DS_SELECTION_LIST);

    //
    // DSSELECTIONLIST contains one DSSELECTION struct, include space
    // for the rest
    //

    cbRequired += (m_dsol.size() - 1) * sizeof(DS_SELECTION);

    //
    // Include the name and variable length data associated with each
    // selection.
    //

    CDsObjectList::const_iterator itSelectedObjects;

    for (itSelectedObjects = m_dsol.begin(); itSelectedObjects != m_dsol.end(); itSelectedObjects++)
    {
        cbRequired += itSelectedObjects->GetMarshalSize();
    }

#if (DBG == 1)
    size_t cbAllocatedBeforeVariants = cbRequired;
#endif // (DBG == 1)

    //
    // Each DS_SELECTION struct includes a pointer to an array of
    // VARIANTs, one for each attribute to fetch.
    //

    const vector<String> &rvAttrToFetch = m_rpop->GetAttrToFetchVector();
    ULONG cAttrToFetch = static_cast<ULONG>(rvAttrToFetch.size());

    if (cAttrToFetch)
    {
        cbRequired += m_dsol.size() *
                        sizeof(VARIANT) * cAttrToFetch;

        // add space for slack bytes so we can be sure to get pointer
        // alignment

        cbRequired += sizeof (void *);
    }

    //
    // Allocate a block
    //

    PDS_SELECTION_LIST pdssel;

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   cbRequired);

    if (!pMedium->hGlobal)
    {
        Dbg(DEB_ERROR,
            "GlobalAlloc for %uL bytes failed\n",
            cbRequired);
        return STG_E_MEDIUMFULL;
    }

    pdssel = reinterpret_cast<PDS_SELECTION_LIST>
        (GlobalLock(pMedium->hGlobal));

    fLockedMem = TRUE;
    //REVIEWED-2002-02-20-lucios. pdssel points to memory from 
    // pMedium->hGlobal that was allocated with cbRequired
    ZeroMemory(pdssel, cbRequired);

    //
    // Fill it in
    //

    pdssel->cItems = static_cast<ULONG>(m_dsol.size());
    pdssel->cFetchedAttributes = cAttrToFetch;

    //
    // Get a pointer to just past the end of the fixed length part of the
    // buffer: the last of the DS_SELECTION structs.
    //

    PWSTR pwzNextString = (PWSTR)(PBYTE)&pdssel->aDsSelection[m_dsol.size()];

    ULONG i;

    const CScopeManager &rsm = m_rpop->GetScopeManager();

    for (i = 0, itSelectedObjects = m_dsol.begin(); itSelectedObjects != m_dsol.end(); i++, itSelectedObjects++)
    {
        PDS_SELECTION pDsCur = &pdssel->aDsSelection[i];

        pDsCur->pwzName = pwzNextString;
        // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
        // strsafe seems to be indicated in this case as well
        lstrcpy(pwzNextString, itSelectedObjects->GetName());
        Dbg(DEB_TRACE, "*** Name '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        pDsCur->pwzClass = pwzNextString;

        //
        // Convert from internal localGroup/globalGroup class to
        // group class.
        //

        if (!lstrcmpi(itSelectedObjects->GetClass(), c_wzLocalGroupClass) ||
            !lstrcmpi(itSelectedObjects->GetClass(), c_wzGlobalGroupClass))
        {
            // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
            lstrcpy(pwzNextString, c_wzGroupObjectClass);
        }
        else
        {
            // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
            lstrcpy(pwzNextString, itSelectedObjects->GetClass());
        }

        Dbg(DEB_TRACE, "*** Class '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        pDsCur->pwzADsPath = pwzNextString;

        BSTR bstrADsPath = itSelectedObjects->GetAttr(AK_PROCESSED_ADSPATH).GetBstr();
        if (!*bstrADsPath)
        {
           bstrADsPath = itSelectedObjects->GetADsPath();
        }
        // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
        lstrcpy(pwzNextString, bstrADsPath);
        Dbg(DEB_TRACE, "*** Path '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        pDsCur->pwzUPN = pwzNextString;
        // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
        lstrcpy(pwzNextString, itSelectedObjects->GetUpn());
        Dbg(DEB_TRACE, "*** UPN '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        ULONG idOwningScope = itSelectedObjects->GetOwningScopeID();
        const CScope *pOwningScope = &rsm.LookupScopeById(idOwningScope);

        while (pOwningScope->Type() == ST_LDAP_CONTAINER)
        {
            pOwningScope = &rsm.GetParent(*pOwningScope);
        }
        ASSERT(!IsInvalid(*pOwningScope));

        // NTRAID#NTBUG9-574259-2002/04/11-lucios
        // ST_XFOREST is an internal kind of scope created 
        // for the XForest trusts the caller asked for when he
        // specified DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
        // We should return the flag type in his terms.
        if(pOwningScope->Type() == ST_XFOREST) 
        {
            pDsCur->flScopeType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
        }
        else 
        {
            pDsCur->flScopeType = static_cast<ULONG>(pOwningScope->Type());
        }
    }

#if (DBG == 1)
    size_t cbUsedBeforeVariants = (PBYTE)pwzNextString - (PBYTE)pdssel;

    Dbg(DEB_TRACE,
        "cbAllocatedBeforeVariants=%uL, cbUsedBeforeVariants=%uL\n",
        cbAllocatedBeforeVariants,
        cbUsedBeforeVariants);
    ASSERT(cbAllocatedBeforeVariants == cbUsedBeforeVariants);
#endif // (DBG == 1)

    //
    // If there are no other attributes to fetch for each item, we're
    // done, since the buffer is zero initialized, making the
    // pvarOtherAttributes member of each DS_SELECTION structure NULL.
    //

    if (cAttrToFetch)
    {
        //
        // The variants are stored after the last of the strings.  The strings
        // are WORD aligned, introduce slack bytes before the first of the
        // variants if necessary to make it aligned on a pointer-sized
        // boundary.
        //

        ULONG_PTR ulp = reinterpret_cast<ULONG_PTR>(pwzNextString);

        if (ulp % sizeof(void *))
        {
            ulp += sizeof(void *) - (ulp % sizeof(void *));
            pwzNextString = reinterpret_cast<PWSTR>(ulp);
        }
        ASSERT(!((ULONG_PTR) pwzNextString % sizeof(ULONG_PTR)));

        LPVARIANT pvarNext = (LPVARIANT) pwzNextString;

        for (i = 0, itSelectedObjects = m_dsol.begin();
             itSelectedObjects != m_dsol.end();
             i++, itSelectedObjects++)
        {
            pdssel->aDsSelection[i].pvarFetchedAttributes = pvarNext;

            vector<String>::const_iterator itAttrToFetch;

            for (itAttrToFetch = rvAttrToFetch.begin();
                 itAttrToFetch != rvAttrToFetch.end();
                 itAttrToFetch++)
            {
                ASSERT(pvarNext);

                const Variant &varFetched =
                    itSelectedObjects->GetAttr(*itAttrToFetch, *m_rpop.get());

                HRESULT hr2;
                Variant &varFetchedNonConst =
                    const_cast<Variant &>(varFetched);
                hr2 = VariantCopy(pvarNext, &varFetchedNonConst);
                CHECK_HRESULT(hr2);
                pvarNext++;
            }
        }

        //
        // Include a punkForRelease to clean up these variants.
        //

        pMedium->pUnkForRelease = (IUnknown *)
            new CDataObjectReleaser(pMedium->hGlobal);
    }

    if (fLockedMem)
    {
        GlobalUnlock(pMedium->hGlobal);
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetDataHere
//
//  Synopsis:   Fill the hGlobal in [pmedium] with the requested data
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetDataHere(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, GetDataHere);

    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::QueryGetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::QueryGetData(
        FORMATETC *pformatetc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, QueryGetData);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetCanonicalFormatEtc(
        FORMATETC *pformatectIn,
        FORMATETC *pformatetcOut)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, GetCanonicalFormatEtc);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::SetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::SetData(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, SetData);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, EnumFormatEtc);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::DAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, DAdvise);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::DUnadvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::DUnadvise(
    DWORD dwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, DUnadvise);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumDAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, EnumDAdvise);
    return E_NOTIMPL;
}




//============================================================================
//
// Non interface method implementation
//
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CDataObject
//
//  Synopsis:   ctor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObject::CDataObject(
        CObjectPicker *pop,
        const CDsObjectList &dsol):
            m_cRefs(1),
            m_rpop(pop)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CDataObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDataObject);

    m_dsol.assign(dsol.begin(), dsol.end());
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CDataObject
//
//  Synopsis:   ctor
//
//  Arguments:  [hwndRichEdit] - contains text and embedded objects
//              [pchrg]        - char position range to copy
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CDataObject::CDataObject(
    HWND hwndRichEdit,
    CHARRANGE *pchrg):
        m_cRefs(1)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CDataObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDataObject);
    HRESULT         hr = S_OK;
    IRichEditOle   *pRichEditOle = NULL;

    do
    {
        // If range is empty, do nothing

        if (pchrg->cpMin == pchrg->cpMax)
        {
            break;
        }

        ULONG cch = Edit_GetTextLength(hwndRichEdit);
        PWSTR pwzBuf = new WCHAR[cch + 1];

        pwzBuf[0] = L'\0'; // in case gettext fails
        Edit_GetText(hwndRichEdit, pwzBuf, cch + 1);
        m_strData = pwzBuf + pchrg->cpMin;

        if (pchrg->cpMax != -1)
        {
            if ((ULONG) pchrg->cpMax < cch)
            {
                m_strData.erase(pchrg->cpMax - pchrg->cpMin);
            }
        }

        delete [] pwzBuf;
        pwzBuf = NULL;

        LRESULT lResult = SendMessage(hwndRichEdit,
                                     EM_GETOLEINTERFACE,
                                     0,
                                     (LPARAM) &pRichEditOle);

        if (!lResult)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        LONG cObjects = pRichEditOle->GetObjectCount();
        LONG i;
        LONG cchOffset = 0;

        for (i = 0; i < cObjects; i++)
        {
            REOBJECT reobj;

            //REVIEWED-2002-02-20-lucios.
            ZeroMemory(&reobj, sizeof reobj);
            reobj.cbStruct = sizeof(reobj);

            hr = pRichEditOle->GetObject(i, &reobj, REO_GETOBJ_POLEOBJ);

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                continue;
            }

            ASSERT(reobj.poleobj);

            String strDisplayName;

            CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;
            pdso->GetDisplayName(&strDisplayName, TRUE);
            reobj.poleobj->Release();

            if (reobj.cp >= pchrg->cpMin &&
                (pchrg->cpMax == -1 || reobj.cp < pchrg->cpMax))
            {
                m_strData.erase(reobj.cp + cchOffset - pchrg->cpMin, 1);
                m_strData.insert(reobj.cp + cchOffset - pchrg->cpMin,
                                 strDisplayName);
                cchOffset += static_cast<ULONG>(strDisplayName.length()) - 1;
            }
        }

    } while (0);

    SAFE_RELEASE(pRichEditOle);
}





//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::~CDataObject
//
//  Synopsis:   dtor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObject::~CDataObject()
{
    TRACE_DESTRUCTOR_EX(DEB_DATAOBJECT, CDataObject);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\debug.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       debug.cxx
//
//  Contents:   Debugging routines
//
//  History:    09-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL(opd)


#if (DBG == 1)


void __cdecl
CTimer::Init(LPCSTR pszTitleFmt, ...)
{
    va_list va;
    va_start(va, pszTitleFmt);

    m_ulStart = GetTickCount();
    WCHAR wzTitleFmt[MAX_PATH];

    MultiByteToWideChar(CP_ACP,
                        0,
                        pszTitleFmt,
                        -1,
                        wzTitleFmt,
                        ARRAYLEN(wzTitleFmt));

    int iRet = _vsnwprintf(m_wzTitle, ARRAYLEN(m_wzTitle), wzTitleFmt, va);

    if (iRet == -1)
    {
        // resulting string too large and was truncated.  ensure null
        // termination.

        m_wzTitle[ARRAYLEN(m_wzTitle) - 1] = L'\0';
    }
    va_end(va);

}




CTimer::~CTimer()
{
    ULONG ulStop = GetTickCount();
    ULONG ulElapsedMS = ulStop - m_ulStart;

    ULONG ulSec = ulElapsedMS / 1000;
    ULONG ulMillisec = ulElapsedMS - (ulSec * 1000);

    Dbg(DEB_PERF, "Timer: %ws took %u.%03us\n", m_wzTitle, ulSec, ulMillisec);
}




PCWSTR
NextNonWs(
        PCWSTR pwzCur)
{
    while (wcschr(L" \t\n", *pwzCur))
    {
        pwzCur++;
    }
    return pwzCur;
}




void
DumpQuery(
    LPCSTR pzTitle,
    LPCTSTR ptszLdapQuery)
{
    Dbg(DEB_TRACE, "%hs\n", pzTitle);

    LPCTSTR pwzCur = ptszLdapQuery;

    if (!pwzCur)
    {
        Dbg(DEB_TRACE, "Query is NULL\n");
        return;
    }

    ULONG cchIndent = 0;
    ULONG i;
    PWSTR pwzCurLine;

    while (*pwzCur)
    {
        pwzCur = NextNonWs(pwzCur);

        if (*pwzCur == L'(' && wcschr(L"!&|", *NextNonWs(pwzCur + 1)))
        {
            pwzCurLine = new WCHAR[4 + cchIndent];

            for (i = 0; i < cchIndent; i++)
            {
                pwzCurLine[i] = L' ';
            }
            pwzCurLine[i + 0] = L'(';
            pwzCurLine[i + 1] = *NextNonWs(pwzCur + 1);
            pwzCurLine[i + 2] = L'\n';
            pwzCurLine[i + 3] = L'\0';

            cchIndent++;
            pwzCur = NextNonWs(pwzCur + 1) + 1;
        }
        else if (*NextNonWs(pwzCur) == L')')
        {
            cchIndent--;

            pwzCurLine = new WCHAR[3 + cchIndent];

            for (i = 0; i < cchIndent; i++)
            {
                pwzCurLine[i] = L' ';
            }
            pwzCurLine[i + 0] = L')';
            pwzCurLine[i + 1] = L'\n';
            pwzCurLine[i + 2] = L'\0';

            pwzCur = NextNonWs(pwzCur) + 1;
        }
        else
        {
            pwzCur = NextNonWs(pwzCur);

            ASSERT(*pwzCur == L'(');
            PCWSTR pwzCloseParen;
            ULONG cOpen = 0;

            for (pwzCloseParen = pwzCur + 1; *pwzCloseParen; pwzCloseParen++)
            {
                if (*pwzCloseParen == L'(')
                {
                    cOpen++;
                }
                else if (*pwzCloseParen == L')')
                {
                    if (!cOpen)
                    {
                        break;
                    }
                    cOpen--;
                }
            }

            if (!*pwzCloseParen)
            {
                Dbg(DEB_ERROR,
                    "DumpQuery: close paren not found in '%ws'\n",
                    pwzCur);
                return;
            }

            size_t cchClause = pwzCloseParen - pwzCur + 1;

            pwzCurLine = new WCHAR[cchClause + cchIndent + 2];

            for (i = 0; i < cchIndent; i++)
            {
                pwzCurLine[i] = L' ';
            }

            CopyMemory(&pwzCurLine[i], pwzCur, sizeof(WCHAR) * cchClause);
            lstrcpy(&pwzCurLine[i + cchClause], L"\n");
            pwzCur += cchClause;
        }

        Dbg(DEB_TRACE, pwzCurLine);
        delete [] pwzCurLine;
    }

    //
    // Well formed query should have balanced parentheses
    //

    ASSERT(!cchIndent);
}




//+--------------------------------------------------------------------------
//
//  Function:   IsSingleBitFlag
//
//  Synopsis:   Return TRUE if exactly one bit in [flags] is set, FALSE
//              otherwise.
//
//  History:    08-31-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsSingleBitFlag(
    ULONG flags)
{
    if (!flags)
    {
        return FALSE;
    }

    while (!(flags & 1))
    {
        flags >>= 1;
    }

    return !(flags & ~1UL);
}



#define DUMP_IF_SET(fl, bit)                    \
    if (((fl) & (bit)) == (bit))                \
    {                                           \
        Dbg(DEB_TRACE, "    %hs\n", #bit);      \
    }


//+--------------------------------------------------------------------------
//
//  Function:   DumpScopeType
//
//  Synopsis:
//
//  Arguments:  [flType] -
//
//  Returns:
//
//  Modifies:
//
//  History:    09-29-1998   DavidMun   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

void
DumpScopeType(
    ULONG flType)
{
    Dbg(DEB_TRACE, "  ScopeType:\n");

    if (!flType)
    {
        Dbg(DEB_TRACE, "    DSOP_SCOPE_TYPE_INVALID\n");
        return;
    }

    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_TARGET_COMPUTER);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_GLOBAL_CATALOG);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_WORKGROUP);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE);
}

void
DumpScopeFlags(
    ULONG flScope)
{
    if (flScope)
    {
        Dbg(DEB_TRACE, "  flScope:\n");

        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_STARTING_SCOPE);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_WANT_SID_PATH);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS);
    }
}

void
_DumpUplevelFilterFlags(ULONG flags)
{
    DUMP_IF_SET(flags, DSOP_FILTER_INCLUDE_ADVANCED_VIEW);
    DUMP_IF_SET(flags, DSOP_FILTER_USERS);
    DUMP_IF_SET(flags, DSOP_FILTER_BUILTIN_GROUPS);
    DUMP_IF_SET(flags, DSOP_FILTER_WELL_KNOWN_PRINCIPALS);
    DUMP_IF_SET(flags, DSOP_FILTER_UNIVERSAL_GROUPS_DL);
    DUMP_IF_SET(flags, DSOP_FILTER_UNIVERSAL_GROUPS_SE);
    DUMP_IF_SET(flags, DSOP_FILTER_GLOBAL_GROUPS_DL);
    DUMP_IF_SET(flags, DSOP_FILTER_GLOBAL_GROUPS_SE);
    DUMP_IF_SET(flags, DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL);
    DUMP_IF_SET(flags, DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE);
    DUMP_IF_SET(flags, DSOP_FILTER_CONTACTS);
    DUMP_IF_SET(flags, DSOP_FILTER_COMPUTERS);
}

void
_DumpDownlevelFilterFlags(ULONG flags)
{
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_USERS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_COMPUTERS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_WORLD);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_ANONYMOUS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_BATCH);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_DIALUP);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_INTERACTIVE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_NETWORK);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_SERVICE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_SYSTEM);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS);
}


void
DumpFilterFlags(
    const DSOP_FILTER_FLAGS &FilterFlags)
{
    if (FilterFlags.Uplevel.flBothModes)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.Uplevel.flBothModes (%#x)\n",
            FilterFlags.Uplevel.flBothModes);
        _DumpUplevelFilterFlags(FilterFlags.Uplevel.flBothModes);
    }

    if (FilterFlags.Uplevel.flMixedModeOnly)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.Uplevel.flMixedModeOnly (%#x)\n",
            FilterFlags.Uplevel.flMixedModeOnly);
        _DumpUplevelFilterFlags(FilterFlags.Uplevel.flMixedModeOnly);
    }

    if (FilterFlags.Uplevel.flNativeModeOnly)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.Uplevel.flNativeModeOnly (%#x)\n",
            FilterFlags.Uplevel.flNativeModeOnly);
        _DumpUplevelFilterFlags(FilterFlags.Uplevel.flNativeModeOnly);
    }

    if (FilterFlags.flDownlevel)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.flDownlevel (%#x)\n",
            FilterFlags.flDownlevel);
        _DumpDownlevelFilterFlags(FilterFlags.flDownlevel);
    }
}

void
DumpOptionFlags(
    ULONG flOptions)
{
    if (flOptions)
    {
        Dbg(DEB_TRACE, "  Options:\n");
        DUMP_IF_SET(flOptions, DSOP_FLAG_MULTISELECT);
        DUMP_IF_SET(flOptions, DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK);
    }
}


void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf)
{
    ULONG i;
    LPWSTR pwzNext = wzBuf;
    LPWSTR pwzEnd = wzBuf + cchBuf;

    for (i = 0; i < pvar->parray->rgsabound[0].cElements && pwzNext < pwzEnd + 6; i++)
    {
        wsprintf(pwzNext, L"x%02x ", ((LPBYTE)(pvar->parray->pvData))[i]);
        pwzNext += lstrlen(pwzNext);
    }
}




LPWSTR
VariantString(
    VARIANT *pvar)
{
    static WCHAR wzBuf[1024];

    wzBuf[0] = L'\0';

    switch (pvar->vt)
    {
    case VT_EMPTY:
        lstrcpy(wzBuf, L"VT_EMPTY");
        break;

    case VT_NULL:
        lstrcpy(wzBuf, L"VT_NULL");
        break;

    case VT_I2:
        wsprintf(wzBuf, L"%d", V_I2(pvar));
        break;

    case VT_I4:
        wsprintf(wzBuf, L"%d", V_I4(pvar));
        break;

    case VT_R4:
        wsprintf(wzBuf, L"%f", V_R4(pvar));
        break;

    case VT_R8:
        wsprintf(wzBuf, L"%f", V_R8(pvar));
        break;

    case VT_CY:
        wsprintf(wzBuf, L"LongLong Currency");
        break;

    case VT_DATE:
        wsprintf(wzBuf, L"date %f", V_DATE(pvar));
        break;

    case VT_BSTR:
        if (V_BSTR(pvar))
        {
            wsprintf(wzBuf, L"'%ws'", V_BSTR(pvar));
        }
        else
        {
            lstrcpy(wzBuf, L"VT_BSTR NULL");
        }
        break;

    case VT_DISPATCH:
        wsprintf(wzBuf, L"VT_DISPATCH 0x%p", V_DISPATCH(pvar));
        break;

    case VT_UNKNOWN:
        wsprintf(wzBuf, L"VT_UNKNOWN 0x%p", V_UNKNOWN(pvar));
        break;

    case VT_ERROR:
    case VT_HRESULT:
        wsprintf(wzBuf, L"hr 0x%x", V_ERROR(pvar));
        break;

    case VT_BOOL:
        wcscpy(wzBuf, V_BOOL(pvar) ? L"TRUE" : L"FALSE");
        break;

    case VT_VARIANT:
        wsprintf(wzBuf, L"variant 0x%p", V_VARIANTREF(pvar));
        break;

    case VT_DECIMAL:
        lstrcpy(wzBuf, L"VT_DECIMAL");
        break;

    case VT_I1:
        wsprintf(wzBuf, L"%d", V_I1(pvar));
        break;

    case VT_UI1:
        wsprintf(wzBuf, L"%u", V_UI1(pvar));
        break;

    case VT_UI2:
        wsprintf(wzBuf, L"%u", V_UI2(pvar));
        break;

    case VT_UI4:
        wsprintf(wzBuf, L"%u", V_UI4(pvar));
        break;

    case VT_I8:
        lstrcpy(wzBuf, L"VT_I8");
        break;

    case VT_UI8:
        lstrcpy(wzBuf, L"VT_UI8");
        break;

    case VT_INT:
        wsprintf(wzBuf, L"%d", V_INT(pvar));
        break;

    case VT_UINT:
        wsprintf(wzBuf, L"%u", V_UINT(pvar));
        break;

    case VT_VOID:
        lstrcpy(wzBuf, L"VT_VOID");
        break;

    case VT_UI1 | VT_ARRAY:
        VarArrayToStr(pvar, wzBuf, ARRAYLEN(wzBuf));
        break;

    case VT_PTR:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_RECORD:
    case VT_FILETIME:
    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_CLSID:
    case VT_BSTR_BLOB:
    default:
        wsprintf(wzBuf, L"VT 0x%x", V_VT(pvar));
        break;
    }
    return wzBuf;
}

void
IIDtoString(
    REFIID riid,
    String *pstr)
{
    HRESULT     hr = S_OK;
    ULONG       lResult;
    LPOLESTR    pwzIID = NULL;
    HKEY        hkInterface = NULL;
    HKEY        hkIID = NULL;

    do
    {
        hr = StringFromIID(riid, &pwzIID);
        if (FAILED(hr)) break;

        lResult = RegOpenKey(HKEY_CLASSES_ROOT, L"Interface", &hkInterface);
        if (lResult != NO_ERROR) break;

        lResult = RegOpenKey(hkInterface, pwzIID, &hkIID);
        if (lResult != NO_ERROR) break;

        WCHAR wzInterfaceName[MAX_PATH] = L"";
        ULONG cbData = sizeof(wzInterfaceName);

        lResult = RegQueryValueEx(hkIID,
                                  NULL,
                                  NULL,
                                  NULL,
                                  (PBYTE)wzInterfaceName,
                                  &cbData);

        if (*wzInterfaceName)
        {
            *pstr = wzInterfaceName;
        }
        else
        {
            *pstr = pwzIID;
        }
    } while (0);

    if (hkIID)
    {
        RegCloseKey(hkIID);
    }

    if (hkInterface)
    {
        RegCloseKey(hkInterface);
    }

    CoTaskMemFree(pwzIID);
}

void
SayNoItf(
    PCSTR szComponent,
    REFIID riid)
{
    String strIID;

    IIDtoString(riid, &strIID);
    Dbg(DEB_ERROR, "%hs::QI no interface %ws\n", szComponent, strIID.c_str());
}


String
DbgGetFilterDescr(
    const CObjectPicker &rop,
    ULONG flCurFilterFlags)
{
    String strFilter;
    String strPlural;

    if (rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT)
    {
        strPlural = L"s";
    }

    if (!(flCurFilterFlags & DSOP_DOWNLEVEL_FILTER_BIT))
    {
        if (flCurFilterFlags & DSOP_FILTER_USERS)
        {
            strFilter = L"User" + strPlural;
        }

        if (flCurFilterFlags & DSOP_FILTER_CONTACTS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Contact" + strPlural;
        }

        if (flCurFilterFlags & DSOP_FILTER_COMPUTERS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Computer" + strPlural;
        }

        if (flCurFilterFlags & ALL_UPLEVEL_GROUP_FILTERS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Group" + strPlural;
        }

        if (flCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Builtin Security Principal" + strPlural;
        }

        if (flCurFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Other object" + strPlural;
        }
    }
    else
    {
        if (IsDownlevelFlagSet(flCurFilterFlags, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            strFilter = L"User" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Computer" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Group" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags,
                               ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Builtin Security Principal" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags,
                               DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Other object" + strPlural;
        }
    }
    return strFilter;
}


String
DbgTvTextFromHandle(
    HWND hwndTv,
    HTREEITEM hItem)
{
    TVITEM tvi;
    WCHAR wzTextBuf[80];

    tvi.mask = TVIF_TEXT;
    tvi.hItem = hItem;
    tvi.cchTextMax = ARRAYLEN(wzTextBuf);
    tvi.pszText = wzTextBuf;

    VERIFY(TreeView_GetItem(hwndTv, &tvi));
    return tvi.pszText;
}

#endif // (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\dlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       dlg.cxx
//
//  Contents:   Implementation of modeless dialog base class
//
//  Classes:    CDlg
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop





//+--------------------------------------------------------------------------
//
//  Member:     CDlg::CDlg
//
//  Synopsis:   ctor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::CDlg():
    m_hwnd(NULL)
{
    TRACE_CONSTRUCTOR(CDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::~CDlg
//
//  Synopsis:   dtor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::~CDlg()
{
    TRACE_DESTRUCTOR(CDlg);
    m_hwnd = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModalDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog's return code
//
//  History:    04-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR
CDlg::_DoModalDlg(
    HWND hwndParent,
    INT idd) const
{
    TRACE_METHOD(CDlg, _DoModalDlg);

    ASSERT(!hwndParent || IsWindow(hwndParent));
    INT_PTR iResult = DialogBoxParam(g_hinst,
                                     MAKEINTRESOURCE(idd),
                                     hwndParent,
                                     CDlg::_DlgProc,
                                     (LPARAM) this);

    if (iResult == -1)
    {
        DBG_OUT_LASTERROR;
    }

    return iResult;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModelessDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog window handle, or NULL on failure
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HWND
CDlg::_DoModelessDlg(
    HWND hwndParent,
    INT idd)
{
    TRACE_METHOD(CDlg, _DoModelessDlg);

    HWND hwnd;

    hwnd = CreateDialogParam(g_hinst,
                             MAKEINTRESOURCE(idd),
                             hwndParent,
                             CDlg::_DlgProc,
                             (LPARAM) this);
    if (!hwnd)
    {
        DBG_OUT_LASTERROR;
    }
    return hwnd;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DlgProc
//
//  Synopsis:   Dispatch selected messages to derived class
//
//  Arguments:  standard windows dialog
//
//  Returns:    standard windows dialog
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK
CDlg::_DlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fReturn = TRUE;
    CDlg *pThis = (CDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    if (!pThis && message != WM_INITDIALOG)
    {
        Dbg(DEB_WARN,
            "CDlg::_DlgProc received message %#x before WM_INITDIALOG\n",
            message);
        return FALSE;
    }

    switch (message)
    {
    case WM_INITDIALOG:
    {
        HRESULT hr = S_OK;

        //
        // pThis isn't valid because we haven't set DWLP_USER yet.  Make
        // it valid.
        //

        pThis = (CDlg*) lParam;
        ASSERT(pThis);

        Dbg(DEB_ITRACE, "CDlg::_DlgProc setting DWLP_USER to %#x\n", pThis);
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pThis);
        pThis->m_hwnd = hwnd;
        BOOL fInitResult = TRUE;
        hr = pThis->_OnInit(&fInitResult);
        fReturn = fInitResult;

        //
        // If the initialization failed do not allow the dialog to start.
        //

        if (FAILED(hr))
        {
            DestroyWindow(hwnd);
        }
        break;
    }

    case WM_COMMAND:
        fReturn = pThis->_OnCommand(wParam, lParam);
        break;

    case WM_SIZE:
        fReturn = pThis->_OnSize(wParam, lParam);
        break;

    case WM_GETMINMAXINFO:
        fReturn = pThis->_OnMinMaxInfo((LPMINMAXINFO) lParam);
        break;

    case WM_NOTIFY:
        fReturn = pThis->_OnNotify(wParam, lParam);
        break;

    case WM_DRAWITEM:
        fReturn = pThis->_OnDrawItem(wParam, lParam);
        break;

    case WM_CTLCOLORSTATIC:
        fReturn = (BOOL)pThis->_OnStaticCtlColor((HDC) wParam, (HWND) lParam);
        break;

    case WM_SYSCOLORCHANGE:
        pThis->_OnSysColorChange();
        break;

    case OPM_PROMPT_FOR_CREDS:
        pThis->_OnCredentialPrompt(lParam);
        break;

    case OPM_NEW_QUERY_RESULTS:
        pThis->_OnNewBlock(wParam, lParam);
        break;

    case OPM_QUERY_COMPLETE:
        pThis->_OnQueryDone(wParam, lParam);
        break;

    case OPM_HIT_QUERY_LIMIT:
        pThis->_OnQueryLimit();
        break;

    case OPM_POPUP_CRED_ERROR:
        pThis->_OnPopupCredErr(lParam);
        break;

    case WM_DESTROY:
        //
        // It's possible to get a WM_DESTROY message without having gotten
        // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
        // comctl32.dll) fails, so guard pThis access here.
        //

        if (pThis)
        {
            pThis->_OnDestroy();
            pThis->m_hwnd = NULL;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        pThis->_OnHelp(message, wParam, lParam);
        break;

    case THREAD_SUCCEEDED:
        pThis->OnProgressMessage(message, wParam, lParam);


    default:
        fReturn = FALSE;
        break;
    }
    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_GetChildWindowRect
//
//  Synopsis:   Init *[prc] with the window rect, in client coordinates, of
//              child window [hwndChild].
//
//  Arguments:  [hwndChild] - child window for which to retrieve rect
//              [prc]       - pointer to rect struct to receive info
//
//  Modifies:   *[prc]
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDlg::_GetChildWindowRect(
    HWND hwndChild,
    RECT *prc) const
{
    ASSERT(hwndChild && IsWindow(hwndChild));

    VERIFY(GetWindowRect(hwndChild, prc));
    VERIFY(MapWindowPoints(NULL, m_hwnd, (LPPOINT) prc, 2));
}



//+--------------------------------------------------------------------------
//
//  Member:     CDlg::PerformCredentialPrompt
//
//  Synopsis:   Pop up a credential dialog.
//
//  Arguments:  [pcmi] -
//
//  Modifies:   *[pcmi->userName], *[pcmi->password]
//
//  History:    05-04-1998   DavidMun   Created
//
//  Notes:      Called by browse dialog in response to a
//              OPM_PROMPT_FOR_CREDS message.
//
//---------------------------------------------------------------------------

void
CDlg::_OnCredentialPrompt(
    LPARAM lParam) const
{
    TRACE_METHOD(CDlg, PerformCredentialPrompt);

    CRED_MSG_INFO *pcmi = reinterpret_cast<CRED_MSG_INFO *>(lParam);

    CPasswordDialog PasswordDlg(pcmi->flProvider,
                                pcmi->pwzServer,
                                pcmi->userName,
                                pcmi->password);

    pcmi->hr = PasswordDlg.DoModalDialog(m_hwnd);

    //
    // If this credential prompt is being performed on behalf of the
    // worker thread, release it to process the result.
    //

    if (pcmi->hPrompt)
    {
        SetEvent(pcmi->hPrompt);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_OnPopupCredErr
//
//  Synopsis:   Invoke a messagebox to display an error and set an event
//              when it closes.
//
//  Arguments:  [lParam] - POPUP_MSG_INFO pointer
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Used when worker thread needs to display an error.
//
//---------------------------------------------------------------------------

void
CDlg::_OnPopupCredErr(
    LPARAM lParam) const
{
    TRACE_METHOD(CDlg, _OnPopupMessage);

    POPUP_MSG_INFO *pmi = reinterpret_cast<POPUP_MSG_INFO *>(lParam);

    PopupMessage(pmi->hwnd, pmi->ids, pmi->wzError);

    ASSERT(pmi->hPrompt);
    if (pmi->hPrompt)
    {
        SetEvent(pmi->hPrompt);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_ReadEditCtrl
//
//  Synopsis:   Put the contents of the edit control with resource id [id]
//              into the string pointed to by [pstr].
//
//  Arguments:  [id]   - resource id of edit control
//              [pstr] - points to string to fill with edit control's
//                        contents
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDlg::_ReadEditCtrl(
    ULONG id,
    String *pstr) const
{
    pstr->erase();
    SetLastError(0);
    int cch = Edit_GetTextLength(_hCtrl(id));

    if (cch > 0)
    {
        PWSTR pwz = new WCHAR [cch + 1];
        int iRet = Edit_GetText(_hCtrl(id), pwz, cch + 1);
        if (iRet)
        {
            *pstr = pwz;
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
        delete [] pwz;
    }
    else
    {
#if (DBG == 1)
        if (GetLastError())
        {
            DBG_OUT_LASTERROR;
        }
#endif // (DBG == 1)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\dllmain.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       dllmain.cxx
//
//  Contents:   DLL entry point
//
//  History:    06-26-1997  MarkBl  Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

extern "C" BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if (DBG == 1)
            CDbg::s_idxTls = TlsAlloc();
#endif // (DBG == 1)


            Dbg(DEB_ITRACE, "DllMain: DLL_PROCESS_ATTACH\n");

            //
            // Get instance handle
            //

            g_hinst = hInstance;

            //
            // Disable thread notification from OS
            //

            DisableThreadLibraryCalls(hInstance);

            //
            // Initialize common and extended common controls
            //

            SHFusionInitialize(0);
            InitCommonControls();

            INITCOMMONCONTROLSEX icce;
            icce.dwSize = sizeof icce;
            icce.dwICC =
                ICC_USEREX_CLASSES
                | ICC_TAB_CLASSES
                | ICC_ANIMATE_CLASS
                | ICC_LISTVIEW_CLASSES
                | ICC_BAR_CLASSES;
            InitCommonControlsEx(&icce);

            //REVIEWED-2002-02-20-lucios. 
            InitializeCriticalSection(&g_csGlobalVarsCreation);

            //
            // Init other globals
            //

            InitGlobals();

        break;
    }

    case DLL_PROCESS_DETACH:
    {
        Dbg(DEB_ITRACE, "DllMain: DLL_PROCESS_DETACH\n");

        FreeGlobals();
        DeleteCriticalSection(&g_csGlobalVarsCreation);

        DEBUG_VERIFY_INSTANCE_COUNT(CDsObjectPickerCF);
        DEBUG_VERIFY_INSTANCE_COUNT(CDataObject);
        DEBUG_VERIFY_INSTANCE_COUNT(CDsObject);
        DEBUG_VERIFY_INSTANCE_COUNT(CObjectPicker);
        DEBUG_VERIFY_INSTANCE_COUNT(CADsPathWrapper);
        DEBUG_VERIFY_INSTANCE_COUNT(CRootDSE);
        DEBUG_VERIFY_INSTANCE_COUNT(CRow);
        DEBUG_VERIFY_INSTANCE_COUNT(RefCountPointer);
        DEBUG_VERIFY_INSTANCE_COUNT(CServerInfo);

        SHFusionUninitialize();
        
#if (DBG == 1)
        TlsFree(CDbg::s_idxTls);
        CDbg::s_idxTls = 0xFFFFFFFF;
        extern CRITICAL_SECTION g_csMessageBuf;
        extern CRITICAL_SECTION g_csDebugPrint;
        DeleteCriticalSection(&g_csMessageBuf);
        DeleteCriticalSection(&g_csDebugPrint);

#endif // (DBG == 1)
        break;
    }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\edso.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       edso.cxx
//
//  Contents:   Implementation of class to support interfaces required to
//              embed a CDsObject in a rich edit control.
//
//  Classes:    CEmbeddedDsObject
//
//  History:    5-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CEmbeddedDsObject)

//+--------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::CEmbeddedDsObject
//
//  Synopsis:   ctor
//
//  History:    5-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CEmbeddedDsObject::CEmbeddedDsObject(
    const CDsObject &rdso,
    const CEdsoGdiProvider *pGdiProvider):
        CDsObject(rdso),
        m_cRefs(1),
        m_pGdiProvider(pGdiProvider)
{
    TRACE_CONSTRUCTOR(CEmbeddedDsObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CEmbeddedDsObject);
    ASSERT(pGdiProvider);
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::~CEmbeddedDsObject
//
//  Synopsis:   dtor
//
//  History:    5-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CEmbeddedDsObject::~CEmbeddedDsObject()
{
    TRACE_DESTRUCTOR(CEmbeddedDsObject);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CEmbeddedDsObject);
}




//============================================================================
//
// IUnknown implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbeddedDsObject::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    //TRACE_METHOD(CEmbeddedDsObject, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IViewObject *)this;
        }
        else if (IsEqualIID(riid, IID_IOleObject))
        {
            *ppvObj = (IOleObject *)this;
        }
        else if (IsEqualIID(riid, IID_IViewObject))
        {
            *ppvObj = (IViewObject *)this;
        }
        else
        {
            hr = E_NOINTERFACE;
            DBG_OUT_NO_INTERFACE("CEmbeddedDsObject", riid);
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbeddedDsObject::AddRef()
{
    //TRACE_METHOD(CEmbeddedDsObject, AddRef);

    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbeddedDsObject::Release()
{
    //TRACE_METHOD(CEmbeddedDsObject, Release);

    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IOleObject implementation
//
//============================================================================




HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetClientSite(
     IOleClientSite *pClientSite)
{
    TRACE_METHOD(CEmbeddedDsObject, SetClientSite);

    m_rpOleClientSite = pClientSite;
    return S_OK;
}




HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetClientSite(
     IOleClientSite **ppClientSite)
{
    TRACE_METHOD(CEmbeddedDsObject, GetClientSite);

    *ppClientSite = m_rpOleClientSite.get();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetHostNames(
     LPCOLESTR szContainerApp,
     LPCOLESTR szContainerObj)
{
    TRACE_METHOD(CEmbeddedDsObject, SetHostNames);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Close(
     DWORD dwSaveOption)
{
    TRACE_METHOD(CEmbeddedDsObject, Close);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetMoniker(
     DWORD dwWhichMoniker,
     IMoniker *pmk)
{
    TRACE_METHOD(CEmbeddedDsObject, SetMoniker);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetMoniker(
     DWORD dwAssign,
     DWORD dwWhichMoniker,
     IMoniker **ppmk)
{
    TRACE_METHOD(CEmbeddedDsObject, GetMoniker);

    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::InitFromData(
     IDataObject *pDataObject,
     BOOL fCreation,
     DWORD dwReserved)
{
    TRACE_METHOD(CEmbeddedDsObject, InitFromData);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetClipboardData(
     DWORD dwReserved,
     IDataObject **ppDataObject)
{
    TRACE_METHOD(CEmbeddedDsObject, GetClipboardData);
    String strDisplayName;
    GetDisplayName(&strDisplayName, TRUE);

    *ppDataObject = new CEmbedDataObject(strDisplayName);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::DoVerb(
     LONG iVerb,
     LPMSG lpmsg,
     IOleClientSite *pActiveSite,
     LONG lindex,
     HWND hwndParent,
     LPCRECT lprcPosRect)
{
    TRACE_METHOD(CEmbeddedDsObject, DoVerb);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::EnumVerbs(
     IEnumOLEVERB **ppEnumOleVerb)
{
    TRACE_METHOD(CEmbeddedDsObject, EnumVerbs);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Update()
{
    TRACE_METHOD(CEmbeddedDsObject, Update);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::IsUpToDate()
{
    TRACE_METHOD(CEmbeddedDsObject, IsUpToDate);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetUserClassID(
     CLSID *pClsid)
{
    //TRACE_METHOD(CEmbeddedDsObject, GetUserClassID);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetUserType(
     DWORD dwFormOfType,
     LPOLESTR *pszUserType)
{
    //TRACE_METHOD(CEmbeddedDsObject, GetUserType);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetExtent(
     DWORD dwDrawAspect,
     SIZEL *psizel)
{
    TRACE_METHOD(CEmbeddedDsObject, SetExtent);

    //
    // E_FAIL indicates the object is not resizeable
    //

    return E_FAIL;
}

#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))

/*
 * XformSizeInPixelsToHimetric
 * XformSizeInHimetricToPixels
 *
 * Functions to convert a SIZEL structure (Size functions) or
 * an int (Width functions) between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.  This
 *                  contains pixels in XformSizeInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.  This contains pixels in
 *                  XformSizeInPixelsToHimetric and logical HiMetric
 *                  units in the complement function.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */

HRESULT
XformSizeInPixelsToHimetric(
    HDC hDC,
    LPSIZEL lpSizeInPix,
    LPSIZEL lpSizeInHiMetric)
{
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC ||
        GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE ||
        GetDeviceCaps(hDC, LOGPIXELSX) == 0)
    {
        hDC=GetDC(NULL);

        if (!hDC)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        fSystemDC=TRUE;
    }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got pixel units, convert them to logical HIMETRIC along the display
    lpSizeInHiMetric->cx = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cx, iXppli);
    lpSizeInHiMetric->cy = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cy, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetExtent(
     DWORD dwDrawAspect,
     SIZEL *psizel)
{
    TRACE_METHOD(CEmbeddedDsObject, GetExtent);

    HRESULT hr = S_OK;
    HWND    hwndRichEdit = NULL;
    HFONT   hEmbeddedDsObjectFont = NULL;

    do
    {
        hwndRichEdit = m_pGdiProvider->GetRichEditHwnd();
        hEmbeddedDsObjectFont = m_pGdiProvider->GetEdsoFont();

        HDC hdc = GetWindowDC(hwndRichEdit);

        if (!hdc)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        HGDIOBJ hOldFont = SelectObject(hdc, hEmbeddedDsObjectFont);

        String strDisplayName;

        GetDisplayName(&strDisplayName, TRUE);

        SIZE size;
        VERIFY(GetTextExtentPoint32(hdc,
                             strDisplayName.c_str(),
                             static_cast<int>(strDisplayName.length()),
                             &size));

        TEXTMETRIC      tm;
        VERIFY(GetTextMetrics(hdc, &tm));

        SIZEL           sizel;
        sizel.cx = size.cx + 1;
        // NTRAID#NTBUG9-346809-2001/05/22-hiteshr
        sizel.cy = size.cy; // - tm.tmDescent;
        hr = XformSizeInPixelsToHimetric(hdc, &sizel, psizel);
        BREAK_ON_FAIL_HRESULT(hr);

        SelectObject(hdc, hOldFont);
        ReleaseDC(hwndRichEdit, hdc);
    } while (0);

    return hr;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Advise(
     IAdviseSink *pAdvSink,
     DWORD *pdwConnection)
{
    TRACE_METHOD(CEmbeddedDsObject, Advise);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Unadvise(
     DWORD dwConnection)
{
    TRACE_METHOD(CEmbeddedDsObject, Unadvise);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::EnumAdvise(
     IEnumSTATDATA **ppenumAdvise)
{
    TRACE_METHOD(CEmbeddedDsObject, EnumAdvise);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetMiscStatus(
     DWORD dwAspect,
     DWORD *pdwStatus)
{
    TRACE_METHOD(CEmbeddedDsObject, GetMiscStatus);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetColorScheme(
     LOGPALETTE *pLogpal)
{
    TRACE_METHOD(CEmbeddedDsObject, SetColorScheme);

    return E_NOTIMPL;
}




//============================================================================
//
// IViewObject implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Function:   Draw
//
//  Synopsis:   Draw this object as a text string.
//
//  History:    3-18-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL (STDMETHODCALLTYPE *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    //TRACE_METHOD(CEmbeddedDsObject, Draw);

    HFONT hfontOld = (HFONT)SelectObject(hdcDraw, m_pGdiProvider->GetEdsoFont());
    SetTextAlign(hdcDraw, TA_BOTTOM);
    String strDisplayName;
    GetDisplayName(&strDisplayName, TRUE);
    LPCWSTR pwzName = strDisplayName.c_str();
    TextOut(hdcDraw, lprcBounds->left, lprcBounds->bottom, pwzName, lstrlen(pwzName));

    TEXTMETRIC      tm;

    GetTextMetrics(hdcDraw, &tm);

    HPEN hpenUnderline = m_pGdiProvider->GetEdsoPen();

    if (hpenUnderline)
    {
        HPEN hpenOld = SelectPen(hdcDraw, hpenUnderline);
        MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom - tm.tmDescent + 1, NULL);
        LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom - tm.tmDescent + 1);
        SelectPen(hdcDraw, hpenOld);
    }

    SelectObject(hdcDraw, hfontOld);
    return S_OK;
}




HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetColorSet(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    TRACE_METHOD(CEmbeddedDsObject, GetColorSet);

    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Freeze(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DWORD *pdwFreeze)
{
    TRACE_METHOD(CEmbeddedDsObject, Freeze);

    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Unfreeze(
    DWORD dwFreeze)
{
    TRACE_METHOD(CEmbeddedDsObject, Unfreeze);

    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetAdvise(
    DWORD aspects,
    DWORD advf,
    IAdviseSink *pAdvSink)
{
    TRACE_METHOD(CEmbeddedDsObject, SetAdvise);

    m_rpAdviseSink = pAdvSink;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetAdvise(
    DWORD *pAspects,
    DWORD *pAdvf,
    IAdviseSink **ppAdvSink)
{
    TRACE_METHOD(CEmbeddedDsObject, GetAdvise);

    return E_NOTIMPL;
}



DEBUG_DECLARE_INSTANCE_COUNTER(CEmbedDataObject)




//============================================================================
//
// IUnknown implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CEmbedDataObject", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbedDataObject::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbedDataObject::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IDataObject implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::GetData
//
//  Synopsis:   Return data in the requested format
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#pragma warning(disable:4702) // The catch inside this function is unreachable
STDMETHODIMP
CEmbedDataObject::GetData(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, GetData);

    HRESULT hr = S_OK;

    //
    // Init default output medium.  If any of the individual _getdata*
    // methods use something else, they can override.
    //

    pMedium->pUnkForRelease = NULL;
    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = NULL;

    if (m_strData.empty())
    {
        return S_FALSE;
    }

    try
    {
        if (pFormatEtc->cfFormat == CF_UNICODETEXT ||
            pFormatEtc->cfFormat == CF_TEXT)
        {
            hr = _GetDataText(pFormatEtc, pMedium, pFormatEtc->cfFormat);
        }
        else
        {
            hr = DV_E_FORMATETC;
    #if (DBG == 1)
            Dbg(DEB_WARN,
                "CEmbedDataObject::GetData: unrecognized cf %#x\n",
                pFormatEtc->cfFormat);
    #endif // (DBG == 1)
        }
    }
    catch (const exception &e)
    {
        Dbg(DEB_ERROR, "Caught exception %s\n", e.what());
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
#pragma warning(3:4702) // catch later unreachable code


//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::_GetDataText
//
//  Synopsis:   Return data in text format
//
//  Arguments:  [pFormatEtc] -
//              [pMedium]    -
//              [cf]         - CF_TEXT or CF_UNICODETEXT
//
//  History:    5-21-1999   davidmun   Created
//
//  Notes:      Returns empty string unless this was constructed with
//              handle to rich edit control.
//
//---------------------------------------------------------------------------

HRESULT
CEmbedDataObject::_GetDataText(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium,
        ULONG      cf)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, _GetDataText);
    ASSERT(cf == CF_TEXT || cf == CF_UNICODETEXT);
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    HRESULT hr = S_OK;
    ULONG   cbChar = (ULONG)((cf == CF_UNICODETEXT) ? sizeof(WCHAR) : sizeof(CHAR));
    ULONG   cbMedium = cbChar * (static_cast<ULONG>(m_strData.length()) + 1);

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   cbMedium);

    if (!pMedium->hGlobal)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return STG_E_MEDIUMFULL;
    }

    PVOID pvMedium = GlobalLock(pMedium->hGlobal);

    if (cf == CF_UNICODETEXT)
    {
        //REVIEWED-2002-02-21-lucios. pvMedium was recently allocated
        lstrcpy((PWSTR)pvMedium, m_strData.c_str());
    }
    else
    {
        hr = UnicodeToAnsi((PSTR)pvMedium, m_strData.c_str(), cbMedium);
    }
    GlobalUnlock(pMedium->hGlobal);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::GetDataHere
//
//  Synopsis:   Fill the hGlobal in [pmedium] with the requested data
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::GetDataHere(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, GetDataHere);

    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::QueryGetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::QueryGetData(
        FORMATETC *pformatetc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, QueryGetData);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::GetCanonicalFormatEtc(
        FORMATETC *pformatectIn,
        FORMATETC *pformatetcOut)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, GetCanonicalFormatEtc);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::SetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::SetData(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, SetData);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::EnumFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, EnumFormatEtc);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::DAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, DAdvise);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::DUnadvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::DUnadvise(
    DWORD dwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, DUnadvise);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::EnumDAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, EnumDAdvise);
    return E_NOTIMPL;
}




//============================================================================
//
// Non interface method implementation
//
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::CEmbedDataObject
//
//  Synopsis:   ctor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CEmbedDataObject::CEmbedDataObject(const String& strDisplayName):
            m_cRefs(1)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CEmbedDataObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CEmbedDataObject);

    m_strData = strDisplayName;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::~CEmbedDataObject
//
//  Synopsis:   dtor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CEmbedDataObject::~CEmbedDataObject()
{
    TRACE_DESTRUCTOR_EX(DEB_DATAOBJECT, CEmbedDataObject);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CEmbedDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\dsobject.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dsobject.cxx
//
//  Contents:   Class that represents a single object in the DS.
//
//  Classes:    CDsObject
//
//  History:    08-07-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop




HRESULT
CrackName(IN HWND hwnd, 
          IN LPWSTR pwzNameIn,           
          IN DS_NAME_FORMAT FormatOffered,
          IN LPWSTR pwzDomainName,
          IN BOOL bCrackInExtForest,
          OUT LPWSTR * ppwzResultName, 
          OUT PBOOL pbExtForest,
          OUT PBOOL pbAddDollar);

void AddDollarToNameToCrack(IN DS_NAME_FORMAT FormatOffered,
                            String &strNameToCrack);

DEBUG_DECLARE_INSTANCE_COUNTER(CDsObject)

#define MAX_SEARCH_HITS                     1000
#define MAX_SEARCH_HITS_STR                 L"1000"
#define NAME_QUERY_PAGE_TIME_LIMIT          45 // seconds

const Variant CDsObject::s_varEmpty;

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [pwzName]       - name typed by user
//
//  History:    08-13-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    PCWSTR pwzName):flNeedsSidFiltering(FALSE)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) user entry=%ws\n",
        this,
        pwzName);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    ASSERT(idOwningScope);
    ASSERT(pwzName);

    _SetFlag(DSO_FLAG_UNPROCESSED_USER_ENTRY);
    _SetOwningScopeId(idOwningScope);
    m_AttrValueMap[AK_USER_ENTERED_TEXT] = Variant(pwzName);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [strName]       - object RDN
//              [strClass]      - objectClass attribute value
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    const String &strName,
    const String &strClass):flNeedsSidFiltering(FALSE)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) Name=%ws, Class=%ws\n",
        this,
        strName.c_str(),
        strClass.c_str());
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    ASSERT(idOwningScope);

    m_AttrValueMap[AK_NAME] = Variant(strName.c_str());
    m_AttrValueMap[AK_OBJECT_CLASS] = Variant(strClass.c_str());
    _SetOwningScopeId(idOwningScope);
}





//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [Init] - contains various attribute values for this object
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    const SDsObjectInit &Init):flNeedsSidFiltering(FALSE)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) Name=%ws, Localized Name=%ws, Class=%ws\n",
        this,
        Init.pwzName,
        Init.pwzLocalizedName,
        Init.pwzClass);
    ASSERT(Init.idOwningScope);
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);

    _SetOwningScopeId(Init.idOwningScope);

    if (Init.pwzName && *Init.pwzName)
    {
        m_AttrValueMap[AK_NAME] = Variant(Init.pwzName);
    }

    if (Init.pwzLocalizedName && *Init.pwzLocalizedName)
    {
        m_AttrValueMap[AK_LOCALIZED_NAME] = Variant(Init.pwzLocalizedName);
    }

    if (Init.pwzClass && *Init.pwzClass)
    {
        m_AttrValueMap[AK_OBJECT_CLASS] = Variant(Init.pwzClass);
    }

    if (Init.pwzADsPath && *Init.pwzADsPath)
    {
        m_AttrValueMap[AK_ADSPATH] = Variant(Init.pwzADsPath);
    }

    if (Init.pwzUpn && *Init.pwzUpn)
    {
        m_AttrValueMap[AK_USER_PRINCIPAL_NAME] = Variant(Init.pwzUpn);
    }

    if (Init.fDisabled)
    {
        _SetFlag(DSO_FLAG_DISABLED);
    }
}

#define ADD_IF_SUCCEEDED(hr, idx)                           \
    if (SUCCEEDED(hr))                                      \
    {                                                       \
        ASSERT(!bstr.Empty());                              \
        m_AttrValueMap[idx] = Variant(bstr.c_str());    \
        bstr.Clear();                                       \
    }


//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [pADs]          - pointer to interface on object
//                                 represented by this
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Initializes this by querying [pADs] for attribute values.
//              Generally used to represent objects returned from downlevel
//              scopes.
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    IADs *pADs):flNeedsSidFiltering(FALSE)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) pADs=%#x\n",
        this,
        pADs);
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    ASSERT(idOwningScope);

    HRESULT hr;
    Bstr bstr;

    hr = pADs->get_Name(&bstr);
    ADD_IF_SUCCEEDED(hr, AK_NAME);

    if (SUCCEEDED(hr))
    {
        Dbg(DEB_TRACE, "name = %ws\n", GetName());
    }

    hr = pADs->get_Class(&bstr);
    ADD_IF_SUCCEEDED(hr, AK_OBJECT_CLASS);

    hr = pADs->get_ADsPath(&bstr);
    ADD_IF_SUCCEEDED(hr, AK_ADSPATH);

    if (IsDisabled(pADs))
    {
        _SetFlag(DSO_FLAG_DISABLED);
    }

    _SetOwningScopeId(idOwningScope);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   copy ctor
//
//  Arguments:  [dso] - object to copy
//
//  History:    03-06-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    const CDsObject &dso):flNeedsSidFiltering(FALSE)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) copying %#x name=%ws\n",
        this,
        &dso,
        dso.GetName());
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    this->operator=(dso);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [atvm]          - attributes to copy
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      [idOwningScope] value overrides any previous value in [atvm]
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    const AttrValueMap &atvm):
        m_AttrValueMap(atvm),
        flNeedsSidFiltering(FALSE)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) copying AttrValueMap, name=%ws\n",
        this,
        GetName());
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);

    _SetOwningScopeId(idOwningScope);

    if (GetAttr(AK_USER_ACCT_CTRL).GetUI4() & UF_ACCOUNTDISABLE)
    {
        _SetFlag(DSO_FLAG_DISABLED);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SetOwningScopeId
//
//  Synopsis:   Store the id of the scope which contains (owns) this
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_SetOwningScopeId(
    ULONG idOwningScope)
{
    ASSERT(idOwningScope);
    Variant &var = m_AttrValueMap[AK_FLAGS];

    if (var.Empty())
    {
        V_VT(&var) = VT_UI8;
        V_UI8(&var) = static_cast<ULONGLONG>(idOwningScope) << 32;
    }
    else
    {
        ASSERT(V_VT(&var) == VT_UI8);
        ULONGLONG ullNewFlagsVal = (V_UI8(&var) & ULONG_MAX);
        ullNewFlagsVal |= static_cast<ULONGLONG>(idOwningScope) << 32;
        V_UI8(&var) = ullNewFlagsVal;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetDisplayName
//
//  Synopsis:   Fill *[pstrDisplayName] with the string to display in the
//              listview's "Name" column.  May differ from object's RDN.
//
//  Arguments:  [pstrDisplayName]   - filled with name to display
//              [fForSelectionWell] - nonzero if name is being displayed in
//                                      the selection dialog (as opposed to
//                                      the browse dialog).
//
//  History:    11-24-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::GetDisplayName(
    String *pstrDisplayName,
    BOOL fForSelectionWell) const
{
    BSTR bstrNameForDisplay = GetLocalizedName();

    // If localized name available, use it in preference to RDN

    if (!*bstrNameForDisplay)
    {
        bstrNameForDisplay = GetName();
    }

    // use UPN if available

    if (*GetUpn())
    {
        *pstrDisplayName = String::format(g_wzColumn1Format,
                                          bstrNameForDisplay,
                                          GetUpn());
        return;
    }

    if (!fForSelectionWell)
    {
        *pstrDisplayName = bstrNameForDisplay;
        return;
    }

    do
    {
        //
        // for the selection well, and there's no upn.  if this
        // represents a downlevel object, display name is NT4 format,
        // i.e., DOMAIN\NAME, unless it's a downlevel object with
        // a path derived from its SID, e.g. we want ANONYMOUS to be
        // displayed as ANONYMOUS instead of NT AUTHORITY\ANONYMOUS.
        //

        if (_IsFlagSet(DSO_FLAG_HAS_DOWNLEVEL_SID_PATH))
        {
            break;
        }

        ULONG ulProvider = PROVIDER_UNKNOWN;

        if (!*GetADsPath())
        {
            break;
        }

        (void) ProviderFlagFromPath(GetADsPath(), &ulProvider);

        if (ulProvider != PROVIDER_WINNT)
        {
            break;
        }

        String strDisplayPath(GetADsPath());

        size_t idxSlash = strDisplayPath.rfind(L'/');

        if (!idxSlash || idxSlash == String::npos)
        {
            break;
        }

        *pstrDisplayName = strDisplayPath;

        pstrDisplayName->erase(idxSlash, 1);
        pstrDisplayName->insert(idxSlash, L"\\");

        idxSlash = pstrDisplayName->rfind(L'/', idxSlash - 1);

        if (idxSlash != String::npos)
        {
            pstrDisplayName->erase(0, idxSlash + 1);
        }
    } while (0);

    if (pstrDisplayName->empty())
    {
        *pstrDisplayName = bstrNameForDisplay;
    }
}





//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::operator ==
//
//  Synopsis:   Compare this against [dsoRhs], returning TRUE if the name,
//              class, provider, and DN of both match.
//
//  Arguments:  [sliRhs] - object to compare against this
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CDsObject::operator ==(
    const CDsObject &dsoRhs) const
{
    BOOL fEqual = FALSE;
    Bstr bstrMyDN;
    Bstr bstrRhsDn;

    do
    {
        if (lstrcmpi(GetName(), dsoRhs.GetName()))
        {
            break;
        }

        //
        // If exactly one of lhs or rhs is an unprocessed entry, treat
        // them as different since the unprocessed entry may resolve to
        // anything.
        //

        if (IsUnprocessedUserEntry() && !dsoRhs.IsUnprocessedUserEntry() ||
            !IsUnprocessedUserEntry() && dsoRhs.IsUnprocessedUserEntry())
        {
            break;
        }

        //
        // If both are unprocessed entries, compare their text
        //

        if (IsUnprocessedUserEntry() && dsoRhs.IsUnprocessedUserEntry())
        {
            fEqual = !lstrcmpi(GetAttr(AK_USER_ENTERED_TEXT).GetBstr(),
                               dsoRhs.GetAttr(AK_USER_ENTERED_TEXT).GetBstr());
            break;
        }

        if (lstrcmpi(GetClass(), dsoRhs.GetClass()))
        {
            break;
        }

        //
        // Objects have same relative name and class.
        //

        //
        // If neither has a path, they're the same.  If one has a path
        // and one does not, they're different.
        //

        if (!*GetADsPath())
        {
            if (!*dsoRhs.GetADsPath())
            {
                fEqual = TRUE;
            }
            break;
        }
        else if (!*dsoRhs.GetADsPath())
        {
            break;
        }

        //
        // If both use the WinNT provider, compare paths directly.
        // If exactly one uses the WinNT provider, consider them
        // different.
        //

        BSTR bstrADsPath = GetADsPath();
        BSTR bstrRhsADsPath = dsoRhs.GetADsPath();
        BOOL fWinNT = wcsstr(bstrADsPath, c_wzWinNTPrefix) != NULL;
        BOOL fRhsWinNT = wcsstr(bstrRhsADsPath, c_wzWinNTPrefix) != NULL;

        if (fWinNT && fRhsWinNT)
        {
            fEqual = !lstrcmpi(bstrADsPath, bstrRhsADsPath);
            break;
        }
        else if (fWinNT || fRhsWinNT)
        {
            break;
        }

        //
        // Neither uses the WinNT provider, and the RDNs are the same.
        // compare the distinguished names.  A string compare
        // of the paths is insufficient, since they may use different
        // providers or servers but actually have the same DN.
        //

        HRESULT hr;

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     bstrADsPath,
                                     ADS_FORMAT_X500_DN,
                                     &bstrMyDN);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     bstrRhsADsPath,
                                     ADS_FORMAT_X500_DN,
                                     &bstrRhsDn);
        BREAK_ON_FAIL_HRESULT(hr);

        if (lstrcmpi(bstrMyDN.c_str(), bstrRhsDn.c_str()))
        {
            break;
        }

        fEqual = TRUE;
    } while (0);

    return fEqual;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::Process
//
//  Synopsis:   Perform whatever work is required on this to make it ready
//              to return in a data object.
//
//  Arguments:  [hwnd]         - parent for error or multimatch
//                                dialogs
//              [rop]          - containing object picker instance
//              [pdsolExtras]  - llist to which to add items
//                                generated by processing user
//                                entries, NULL if single select
//              [fMultiselect] - may differ from what [rop] reports if
//                                this object resides in a single-select
//                                richedit not in the base dialog (i.e.,
//                                in CDnDlg).
//
//  Returns:    NAME_PROCESS_RESULT
//
//  Modifies:   *[pdsolExtras]
//
//  History:    08-10-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CDsObject::Process(
    HWND           hwnd,
    const CObjectPicker &rop,
    CDsObjectList *pdsolExtras)
{
    TRACE_METHOD(CDsObject, Process);
    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    BOOL fDisplayedError = FALSE;
    HRESULT hr = S_OK;

    do
    {
        //
        // If this has a string the user typed in, convert it to an
        // object.
        //

        if (IsUnprocessedUserEntry())
        {
            ASSERT(!_IsFlagSet(DSO_FLAG_FETCHED_ATTRIBUTES));
            ASSERT(!_IsFlagSet(DSO_FLAG_CONVERTED_PROVIDER));

            _ProcessUserEntry(hwnd, rop, pdsolExtras, &npr);

            if (NAME_PROCESSING_FAILED(npr))
            {
                fDisplayedError = TRUE;
                break;
            }
        }

        //
        // If attribute fetch is required, do it
        //

        (void) _FetchAttributes(hwnd, rop);

        //
        // If provider conversion is required, do it
        //

        hr = _ConvertProvider(hwnd, rop, &npr);
        BREAK_ON_FAIL_PROCESS_RESULT(npr);

    } while (0);

    if (npr == NPR_STOP_PROCESSING && !fDisplayedError)
    {
        String strError = GetErrorMessage(hr);

        PopupMessage(hwnd,
                     IDS_CANNOT_PROCESS,
                     GetName(),
                     strError.c_str());
    }

    if (!NAME_PROCESSING_FAILED(npr))
    {
        _ClearFlag(DSO_FLAG_UNPROCESSED_USER_ENTRY);
    }
    return npr;
}

/*

Flags used when processing user entered text:

DSO_FLAG_MULTISELECT
    indicates that the multiple match dialog should allow multiselect.

DSO_FLAG_IS_COMPUTER
    The value for the AK_USER_ENTERED_TEXT attribute should be considered the
    name of a computer.

DSO_FLAG_MIGHT_BE_UPN
    The value for the AK_USER_ENTERED_TEXT attribute could represent a
    userPrincipalName attribute value.

*/

#define DSO_NAME_PROCESSING_FLAG_MULTISELECT                0x00000001
#define DSO_NAME_PROCESSING_FLAG_IS_COMPUTER                0x00000002
#define DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN               0x00000004
#define DSO_NAME_PROCESSING_FLAG_EXACT_UPN                  0x00000008


//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_ProcessUserEntry
//
//  Synopsis:   Convert the user-entered string to an actual
//              object (if doing so generates more than one object, the
//              second through last are put in [pdsolExtras]).
//
//  Arguments:  [hwnd]   - object picker frame window
//              [pdsolExtras] - NULL if single select
//
//  Returns:    S_OK    - all items processed successfully
//              S_FALSE - user cancelled a dialog, quit processing
//              E_*
//
//  Modifies:   *[pdsolExtras]
//
//  History:    08-12-1998   DavidMun   Created
//
//  Notes:      The name in AK_USER_ENTERED_TEXT is a single name (i.e.  not
//              multiple semicolon delimited names) and has already had
//              leading and trailing spaces removed.
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_ProcessUserEntry(
    HWND hwnd,
    const CObjectPicker &rop,
    CDsObjectList *pdsolExtras,
    NAME_PROCESS_RESULT *pnpr)
{
    TRACE_METHOD(CDsObject, _ProcessUserEntry);

    HRESULT             hr = S_OK;
    CWaitCursor         Hourglass;
    CDsObjectList       dsolMatches;
    BOOL                fMultiselect = rop.GetInitInfoOptions() &
                                       DSOP_FLAG_MULTISELECT;
    ASSERT(fMultiselect && pdsolExtras || !fMultiselect && !pdsolExtras);
    const CScopeManager &rsm = rop.GetScopeManager();
    const CFilterManager &rfm = rop.GetFilterManager();

    //
    // Loop on this entry until it has been sucessfully processed, an
    // error occurs, or user selects 'remove this object' from a dialog
    // asking for info about this name.
    //

    String strName = GetAttr(AK_USER_ENTERED_TEXT).GetBstr();
    ASSERT(strName.length());

#if (DBG == 1)
    _DumpProcessUserEntry(rop, strName);
#endif

    while (TRUE)
    {
        size_t idxFirstWhack = strName.find(L'\\');
        //
        //Find the rightmost @
        //
        size_t idxLastAt= strName.rfind(L'@');
        ULONG flProcess = 0;

        if (fMultiselect)
        {
            flProcess |= DSO_NAME_PROCESSING_FLAG_MULTISELECT;
        }

        if (idxLastAt != String::npos)
        {
            //
            //This means name is either a UPN or Name in name@dnsDomainName 
            //format. In the comments UPN is used to mean both name formats.
            //
            flProcess |= DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN;
        }

        if (idxFirstWhack == 0 && strName[1] == L'\\')
        {
            flProcess |= DSO_NAME_PROCESSING_FLAG_IS_COMPUTER;
        }

        //
        // If the name has backslashes beyond the first two, it's an error.
        //

        if (flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER)
        {
            size_t idxExtraWhack = strName.find(L'\\', 2);

            if (idxExtraWhack != String::npos)
            {
                if (fMultiselect)
                {
                    CNameNotFoundDlg Dlg(rop, IDS_BAD_NAME, &strName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                    BREAK_ON_FAIL_HRESULT(hr);

                    if (NAME_PROCESSING_FAILED(*pnpr))
                    {
                        break;
                    }

                    ASSERT(dsolMatches.empty());
                    continue;
                }
                else
                {
                    PopupMessage(hwnd, IDS_BAD_NAME, strName.c_str());
                    *pnpr = NPR_STOP_PROCESSING;
                    break;
                }
            }

            //
            // Name starts with exactly two backslashes.  Strip them off.
            //

            strName.erase(0, 2);
        }

        //
        // If the name is of the form 'foo\bar' then treat 'foo' as a domain
        // or computer name and try to find 'bar' within it.  Note checking
        // for !(flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER) doesn't mean
        // object can't be a computer, it just means the name wasn't in the
        // form \\foo.
        //

        if (idxFirstWhack != String::npos &&
            !(flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER))
        {
            //
            // Note _SearchDomain has the ds customizer do a prefix
            // search in the domain 'foo' and includes those items in
            // dsolMatches.
            //
            // If the domain search fails and the user edits the string,
            // loop around and retry.  Can't just retry inside _SearchDomain
            // because the name may no longer be in form foo\bar.
            //

            _SearchDomain(&strName,
                          hwnd,
                          rop,
                          idxFirstWhack,
                          flProcess,
                          pnpr,
                          &dsolMatches);

            if (NAME_PROCESSING_FAILED(*pnpr))
            {
                break;
            }

            if (*pnpr == NPR_EDITED)
            {
                ASSERT(dsolMatches.empty());
                continue;
            }
        }
        else
        {
            //
            //For UPN format name, there is no prefix search. So once the
            //object is found we set bFoundObject to true and we don't do
            //any further search.
            //
            BOOL bFoundObject = FALSE;
            //
            //For UPN names, if UserEnteredUpLevelScope is present, we assume
            //that name after @ is domain name and do the search in it
            //this flag keeps track if we have already done the search in
            //domain name after @
            //
            BOOL bDoneUserSearch = FALSE;


            //
            //This is set to true by crackname if nameafter@ is in trusted Xforest
            //bExtForest can be true even if the object is not found in Xforest,
            //that means name before @ was entered incorrectly
            //
            BOOL bExtForest = FALSE;
            
            const CScope *pUpnDerivedScope = NULL;
            const CScope *pCrackNameScope = NULL;
            const CScope *pGCScope = NULL;

            //
            // strName does not contain slash or backslash.  It is
            // either a computer name, a UPN, or an RDN.
            //

            if (flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN)
            {
                //
                // If name might be upn, try to find domain scope
                // with dns name of portion after @.  
                   
                String strNameAfterAt(strName);
                strNameAfterAt.erase(0, idxLastAt + 1);

                //
                //Lookfor a scope with name of strNameAfterAt
                //
                pUpnDerivedScope = &rsm.LookupScopeByDisplayName(strNameAfterAt);

                if (IsUplevel(pUpnDerivedScope))
                {
                    bDoneUserSearch = TRUE;

                    //
                    //When a Search in cross forest in done, a new scope of 
                    //type DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN is added.
                    //Check if its Cross Forest.
                    //
                    BOOL bXForest = FALSE;
                    if(const_cast<CScope *>(pUpnDerivedScope)->GetType() == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
                    {
                       const CLdapDomainScope *pLdapScope = 
                            dynamic_cast<const CLdapDomainScope*>(pUpnDerivedScope);

                        bXForest = pLdapScope->IsXForest();
                    }

                    //
                    //Size before Query
                    //
                    size_t cItemsAtStart = dsolMatches.size();

                    _QueryForName(hwnd,
                                  rop,
                                  *pUpnDerivedScope,
                                  strName,
                                  strName,
                                  flProcess,
                                  &dsolMatches,
                                  bXForest); 

                    //
                    //we found a match in query. 
                    //                        
                    if(cItemsAtStart < dsolMatches.size())
                        bFoundObject = TRUE;
                }
                //
                //Now try dscrack. This may give a reference to another forest also.
                //We try dscrack name only for uplevel domain.
                //
                MACHINE_CONFIG mc = rop.GetTargetComputerConfig();
                const SScopeParameters *pspUserUplevel =
                    rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);
                const SScopeParameters *pspExtUplevel =
                    rsm.GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);


                //
                //Do DsCrackNames if following conditons are true
                //1) Object is not found yet
                //2) We do dscrack begining from GC in this forest. So machine must be
                //   joined to uplevel domain or mustbe uplevel DC
                //3) And one of the scopes which can contain UPN name, must be present
                //

                if (!bFoundObject &&                                    //1
                    (mc == MC_JOINED_NT5 || mc == MC_NT5_DC) &&         //2    
                    (rsm.GetScopeParams(ST_UPLEVEL_JOINED_DOMAIN) ||    //3
                    rsm.GetScopeParams(ST_ENTERPRISE_DOMAIN) ||
                    rsm.GetScopeParams(ST_GLOBAL_CATALOG) ||
                    pspExtUplevel ||
                    pspUserUplevel))                    
                {

                    //
                    //Try to crack in external forest only if ST_EXTERNAL_UPLEVEL_DOMAIN
                    //Scope is present.
                    //
                    BOOL bCrackInExtForest = FALSE;
                    if(pspExtUplevel) 
                        bCrackInExtForest = TRUE;

                    //
                    //Crack the name
                    //
                    LPWSTR pwzResultName = NULL;                
                    BOOL bAddDollar = FALSE;

                    hr = CrackName(hwnd,
                                   (LPWSTR)strName.c_str(),                                
                                   DS_USER_PRINCIPAL_NAME,
                                   (LPWSTR)rop.GetTargetForest().c_str(),
                                   bCrackInExtForest,
                                   &pwzResultName,
                                   &bExtForest,
                                   &bAddDollar);
                    if(SUCCEEDED(hr) && pwzResultName)
                    {   
                        bDoneUserSearch = TRUE;
                        size_t cItemsAtStart = dsolMatches.size();

                        String strDomainFromCrack= pwzResultName;
                        LocalFree(pwzResultName);
                        pwzResultName = NULL;
                    
                        //
                        //Object is in this forest only
                        //
                        if(!bExtForest)
                        {
                            pCrackNameScope = 
                                &rsm.LookupScopeByDisplayName(strDomainFromCrack);
                            pGCScope = 
                                &rsm.LookupScopeByType(ST_GLOBAL_CATALOG);

                            //
                            //1)if any of the enumerated domain match
                            //  strDomainFromCrack, Search there
                            //2)else if userEnteredUplevelScope is present
                            //  try to search in strDomainCrack
                            //3)else if wehave GC Scope
                            //  search there
                            //

                            if(pCrackNameScope &&                       //1
                               !IsInvalid(*pCrackNameScope) &&
                               (pCrackNameScope != pUpnDerivedScope))
                            {
                                _QueryForName(hwnd,
                                              rop,
                                              *pCrackNameScope,
                                              strName,
                                              strName,
                                              flProcess,
                                              &dsolMatches,
                                              FALSE);
                            }
                            else if(pspUserUplevel)                     //2
                            {                                                    
                                _SearchUplevelDomain(hwnd,
                                                     rop,
                                                     strDomainFromCrack,
                                                     pspUserUplevel,
                                                     strName,
                                                     strName,
                                                     flProcess,
                                                     FALSE,
                                                     FALSE,
                                                     &dsolMatches);
                            }
                            else if(pGCScope &&
                                    !IsInvalid(*pGCScope))
                            {
                                _QueryForName(hwnd,
                                              rop,
                                              *pGCScope,
                                              strName,
                                              strName,
                                              flProcess|DSO_NAME_PROCESSING_FLAG_EXACT_UPN,
                                              &dsolMatches,
                                              FALSE);
                            }                            
                        }
                        else
                        {
                            //
                            //Ok the Object in XForest. Check if this scope is in
                            //our list already. This needs to be done because
                            //strDomainFromCrack can be different from nameafter@
                            //
                            String strXForestName = strName;
                            if(bAddDollar)
                                AddDollarToNameToCrack(DS_USER_PRINCIPAL_NAME, strXForestName);

                            pCrackNameScope = 
                                &rsm.LookupScopeByDisplayName(strDomainFromCrack);

                            if(pCrackNameScope &&                       //1
                               !IsInvalid(*pCrackNameScope))
                            {
                                _QueryForName(hwnd,
                                              rop,
                                              *pCrackNameScope,
                                              strXForestName,
                                              strXForestName,
                                              flProcess,
                                              &dsolMatches,
                                              TRUE);
                            }
                            else
                            {
                                _SearchUplevelDomain(hwnd,
                                                     rop,
                                                     strDomainFromCrack,
                                                     pspExtUplevel,
                                                     strXForestName,
                                                     strXForestName,
                                                     flProcess,
                                                     FALSE,
                                                     TRUE,
                                                     &dsolMatches);
                            }
                        }

                        //
                        //we found a match in query. 
                        //                        
                        if(cItemsAtStart < dsolMatches.size())
                            bFoundObject = TRUE;

                    }
                    else // if(SUCCEEDED(hr) && pwzResultName)
                    {
                        // NTRAID#NTBUG9-462817-2001/09/06-lucios
                        // Cleaning the hr for future attempts
                        hr = S_OK;
                    }


                    //
                    // If CrackName tells that domain is in External Forest and 
                    // And EXTERNAL_UPLEVEL scope is present, no need to do UserSearch
                    //
                    if(bExtForest && pspExtUplevel)
                        bDoneUserSearch = TRUE;

                }
            }

            //
            // Search the current scope but only if we didn't just search it
            // as rUpnDerivedScope. 
            //
            if(!bFoundObject && !bExtForest)
            {
                //Size before Query
                size_t cItemsAtStart = dsolMatches.size();   

                if (IsUplevel(rsm.GetCurScope()))
                {
                    BOOL fSearchCurScope = TRUE;

                    //
                    // Search the current scope if:
                    //
                    // a. there is no UPN derived scope
                    // b. there is a UPN derived scope, but it is not the current
                    //    scope and, if the current scope is the GC, the UPN
                    //    derived scope is not an enterprise domain.
                    // c. the current scope is downlevel
                    //

                    if (!pUpnDerivedScope || ( pUpnDerivedScope && IsInvalid(*pUpnDerivedScope)) )
                    {
                        fSearchCurScope = TRUE;
                    }
                    else if (rsm.GetCurScope().Type() == ST_GLOBAL_CATALOG &&
                            (pUpnDerivedScope->Type() == ST_UPLEVEL_JOINED_DOMAIN ||
                             pUpnDerivedScope->Type() == ST_ENTERPRISE_DOMAIN))
                    {
                        fSearchCurScope = FALSE;
                    }
                    else if (&rsm.GetCurScope() == pUpnDerivedScope ||
                             &rsm.GetCurScope() == pCrackNameScope ||
                             &rsm.GetCurScope() == pGCScope)
                    {
                        fSearchCurScope = FALSE;
                    }
                    else
                    {
                        fSearchCurScope = TRUE;
                    }

                    if (fSearchCurScope)
                    {
                        _QueryForName(hwnd,
                                      rop,
                                      rsm.GetCurScope(),
                                      strName,
                                      strName,
                                      flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN ? 
                                      flProcess|DSO_NAME_PROCESSING_FLAG_EXACT_UPN:
                                      flProcess,
                                      &dsolMatches,
                                      FALSE);

                    }
                }
                else if (IsDownlevel(rsm.GetCurScope()))
                {
                    _BindForName(hwnd,
                                 rop,
                                 rsm.GetCurScope(),
                                 strName,
                                 &dsolMatches);
                }

                //
                //Did we find the object
                //        
                if(cItemsAtStart < dsolMatches.size())
                        bFoundObject = TRUE;
            }


            //
            //if nothing found, try to bind to the domain directly
            //
            if(!bFoundObject &&
               rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE) &&
               !bDoneUserSearch &&
               (flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN))
            {
                String strNameAfterAt(strName);
                strNameAfterAt.erase(0, idxLastAt + 1);
                String strNameBeforeAt(strName);
                strNameBeforeAt.erase(idxLastAt);

                const SScopeParameters *pspUserUplevel =
                    rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);


                _SearchUplevelDomain(hwnd,
                                     rop,
                                     strNameAfterAt,
                                     pspUserUplevel,
                                     strNameBeforeAt,
                                     strName,
                                     flProcess,
                                     FALSE,
                                     FALSE,
                                     &dsolMatches);
            }


            //
            // If the caller allows computer objects in user entered domains
            // and we have not already discovered a computer object with an
            // exact matching name then try binding to name as a computer
            // object.
            //

            _BindForComputer(hwnd, rop, strName, &dsolMatches);

            //
            // Ask the dsbrowse customizer to do a prefix search for the
            // objects it would add to the current scope.
            //

            _CustomizerPrefixSearch(hwnd,
                                    rop,
                                    rsm.GetCurScope(),
                                    strName,
                                    &dsolMatches);
        }

        //
        // If disabled objects are considered illegal, remove from the list
        // all which are disabled.  If this results in an empty list, make
        // a note of it so the appropriate error can be displayed in the
        // invalid name dialog.
        //

        BOOL fEmptyBecauseDisabledItemsRemoved = FALSE;

        if (g_fExcludeDisabled && !dsolMatches.empty())
        {
            CDsObjectList::iterator itCur;
            CDsObjectList::iterator itNext;

            for (itCur = dsolMatches.begin(); itCur != dsolMatches.end(); )
            {
                if (itCur->GetDisabled())
                {
                    Dbg(DEB_TRACE,
                        "Removing disabled match %ws\n",
                        itCur->GetName());
                    itNext = itCur;
                    itNext++;
                    dsolMatches.erase(itCur, itNext);
                    itCur = itNext;
                }
                else
                {
                    itCur++;
                }
            }

            if (dsolMatches.empty())
            {
                fEmptyBecauseDisabledItemsRemoved = TRUE;
            }
        }

        //
        // Ask the customizer to approve the matches, if any were found.
        // Note because this only REMOVES objects from matches, this is
        // called regardless of whether the DSOP_FILTER_EXTERNAL_CUSTOMIZER
        // or DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER flags are set.
        //
        // Those flags are only provided to prevent the ADDITION of objects
        // from customizers.
        //

        ICustomizeDsBrowser *pCustomize = rop.GetExternalCustomizer();

        if (pCustomize && !dsolMatches.empty())
        {
            RefCountPointer<CDataObject> rpdo;
            rpdo.Acquire(new CDataObject(const_cast<CObjectPicker*>(&rop),
                                         dsolMatches));
            BOOL *afApproved = new BOOL[dsolMatches.size()];

            //REVIEWED-2002-02-21-lucios.
            ZeroMemory(afApproved, sizeof(BOOL) * dsolMatches.size());

            IDsObjectPickerScope *pDsopScope =
                (IDsObjectPickerScope *)&rsm.GetCurScope();

            hr = pCustomize->ApproveObjects(pDsopScope,
                                            rpdo.get(),
                                            afApproved);

            if (FAILED(hr))
            {
                dsolMatches.clear();
            }
            else if (hr == S_FALSE)
            {
                ULONG i;
                CDsObjectList::iterator itCur;
                CDsObjectList::iterator itNext;

                for (i = 0, itCur = dsolMatches.begin();
                     itCur != dsolMatches.end();
                     i++)
                {
                    if (!afApproved[i])
                    {
                        Dbg(DEB_TRACE,
                            "Removing unapproved match %ws\n",
                            itCur->GetName());
                        itNext = itCur;
                        itNext++;
                        dsolMatches.erase(itCur, itNext);
                        itCur = itNext;
                    }
                    else
                    {
                        itCur++;
                    }
                }
            }
            delete [] afApproved;
            hr = S_OK;
        }

        //
        // If no matches were found anywhere, have the user edit the name
        // and try again.
        //

        if (dsolMatches.empty())
        {
            if (fMultiselect)
            {
                ULONG idsMsg;

                if (fEmptyBecauseDisabledItemsRemoved)
                {
                    idsMsg = IDS_DISABLED_WARNING_FMT;
                }
                else
                {
                    idsMsg = IDS_NAME_NOT_FOUND_FMT_MULTI;
                }

                CNameNotFoundDlg Dlg(rop, idsMsg, &strName);

                hr = Dlg.DoModalDialog(hwnd, pnpr);

                if (NAME_PROCESSING_FAILED(*pnpr))
                {
                    break;
                }

                //
                // strName has been updated.  Loop around and try again.
                //

                ASSERT(*pnpr == NPR_EDITED);
                continue;
            }
            else
            {
                ULONG idsMsg;

                if (fEmptyBecauseDisabledItemsRemoved)
                {
                    idsMsg = IDS_DISABLED_WARNING_FMT;
                }
                else
                {
                    idsMsg = IDS_NAME_NOT_FOUND_FMT_SINGLE;
                }

                //
                //Truncate the object name to MAX_OBJECTNAME_DISPLAY_LEN
                //
                String strObjectName = strName;
                if(!strObjectName.empty() && (strObjectName.size() > MAX_OBJECTNAME_DISPLAY_LEN))
                {
                    strObjectName.erase(MAX_OBJECTNAME_DISPLAY_LEN,strObjectName.size());
                    //
                    //Add three dots to indicate that name is truncated
                    //
                    strObjectName.append(L"...");
                }

                PopupMessage(hwnd,
                             idsMsg,
                             strObjectName.c_str(),
                             rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
                *pnpr = NPR_STOP_PROCESSING;
                break;
            }
        } 
        else if (dsolMatches.size() > 1)
        {
            //
            // More than one match was found.  Ask the user to pick which
            // is (are) valid.
            //

            hr = _MultiMatchDialog(hwnd,
                                   rop,
                                   fMultiselect,
                                   strName,
                                   pnpr,
                                   &dsolMatches,
                                   pdsolExtras);
            BREAK_ON_FAIL_HRESULT(hr);

            if (*pnpr == NPR_EDITED)
            {
                ASSERT(dsolMatches.empty());
                continue;
            }
        }

        break;
    }

    //
    // Out of the processing loop for this entry.  If it was successful,
    // dsolMatches has exactly one object.
    //

    if (!NAME_PROCESSING_FAILED(*pnpr) && SUCCEEDED(hr) && hr != S_FALSE)
    {
        ASSERT(dsolMatches.size() == 1);
        *this = dsolMatches.front();
    }

    if (FAILED(hr))
    {
        if (!NAME_PROCESSING_FAILED(*pnpr))
        {
            *pnpr = NPR_STOP_PROCESSING;
        }
    }

    // Preserve any edits user made

    m_AttrValueMap[AK_USER_ENTERED_TEXT] = Variant(strName);

    return hr;
}




#if (DBG == 1)
void
CDsObject::_DumpProcessUserEntry(
    const CObjectPicker &rop,
    const String &strName)
{
    const CFilterManager &rfm = rop.GetFilterManager();
    const CScopeManager &rsm = rop.GetScopeManager();
    ULONG flCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();
    String strFilter = DbgGetFilterDescr(rop, flCurFilterFlags);

    Dbg(DEB_TRACE, "UA: Processing entry:    '%ws'\n", strName.c_str());
    Dbg(DEB_TRACE, "UA: Current scope is:    %ws\n",
        rsm.GetCurScope().GetDisplayName().c_str());
    Dbg(DEB_TRACE, "UA: Current classes are: %ws\n", strFilter.c_str());
}
#endif // (DBG == 1)




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SearchDomain
//
//  Synopsis:   Search within the domain specified by the portion of the
//              user's string entry before the backslash at [idxFirstWhack].
//
//  Arguments:  [pstrName]      - name for which to search
//              [hwnd]          - for bind
//              [rop]           - containing object picker instance
//              [idxFirstWhack] - index of first '\' character in *[pstrName]
//              [flProcess]     - DSO_NAME_PROCESSING_FLAG_* bits
//              [pnpr]          - filled with result of processing
//              [pdsolMatches]  - any matching names are added to this list
//
//  History:    08-15-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_SearchDomain(
    String *pstrName,
    HWND hwnd,
    const CObjectPicker &rop,
    size_t idxFirstWhack,
    ULONG flProcess,
    NAME_PROCESS_RESULT *pnpr,
    CDsObjectList *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _SearchDomain);
    ASSERT(pdsolMatches->empty());

    *pnpr = NPR_SUCCESS;
    HRESULT hr = S_OK;
    String strScopeName(pstrName->substr(0, idxFirstWhack));
    String strRdn;
    const CFilterManager &rfm = rop.GetFilterManager();

    strRdn = pstrName->substr(idxFirstWhack + 1,
                              pstrName->length() - idxFirstWhack - 1);

    do
    {
        //
        // Complain if there's more than one backslash
        //

        if (pstrName->find(L'\\', idxFirstWhack + 1) != String::npos)
        {
            if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
            {
                CNameNotFoundDlg Dlg(rop, IDS_BAD_NAME_EXTRA_SLASH, pstrName);

                hr = Dlg.DoModalDialog(hwnd, pnpr);
            }
            else
            {
                PopupMessage(hwnd,
                             IDS_BAD_NAME_EXTRA_SLASH,
                             pstrName->c_str());
                *pnpr = NPR_STOP_PROCESSING;
            }
            break;
        }

        //
        // Complain if there's nothing after the backslash (this would
        // generate a query that matches everything)
        //

        if (!(*pstrName)[idxFirstWhack + 1])
        {
            if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
            {
                CNameNotFoundDlg Dlg(rop, IDS_BAD_NAME_SLASH_AT_END, pstrName);

                hr = Dlg.DoModalDialog(hwnd, pnpr);
            }
            else
            {
                PopupMessage(hwnd,
                             IDS_BAD_NAME_SLASH_AT_END,
                             pstrName->c_str());
                *pnpr = NPR_STOP_PROCESSING;
            }
            break;
        }


        // try the crack before any other scopes, to fix
        // NTRAID#NTBUG9-243391-2000/12/13-sburns
        // 
        // Well this is inefficient as it does crackname everytime
        // and also introduces the regression 
        // NTRAID#NTBUG9-282051-2001/01/17-hiteshr
        // i am moving it back to its original position.

        const CScopeManager &rsm = rop.GetScopeManager();

        //
        // Look for scope with display name matching portion of user's
        // string before the backslash.
        //

        Dbg(DEB_NAMEEDIT,
            "Looking for scope with flat name '%ws'\n",
            strScopeName.c_str());

        const CScope *pMatchingScope = &rsm.LookupScopeByFlatName(strScopeName);

        //
        // If a matching scope is found, query for or bind to the name
        // within that scope, and perform a prefix search of the custom
        // objects for that scope.
        //

        if (pMatchingScope && !IsInvalid(*pMatchingScope))
        {
            size_t cItemsAtStart = pdsolMatches->size();

            if (IsUplevel(*pMatchingScope))
            {

                BOOL bXForest = FALSE;
                if(const_cast<CScope*>(pMatchingScope)->GetType() == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
                {
                    const CLdapDomainScope *pLdapScope = 
                        dynamic_cast<const CLdapDomainScope*>(pMatchingScope);

                    bXForest = pLdapScope->IsXForest();
                }

                _QueryForName(hwnd,
                              rop,
                              *pMatchingScope,
                              strRdn,
                              *pstrName,
                              flProcess,
                              pdsolMatches,
                              bXForest);
            }
            else
            {
                _BindForName(hwnd,
                             rop,
                             *pMatchingScope,
                             strRdn,
                             pdsolMatches);
            }

            _CustomizerPrefixSearch(hwnd,
                                    rop,
                                    *pMatchingScope,
                                    strRdn,
                                    pdsolMatches);

            if (cItemsAtStart == pdsolMatches->size())
            {
                if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
                {
                    CNameNotFoundDlg Dlg(rop,
                                        IDS_NAME_NOT_FOUND_FMT_MULTI,
                                        pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
                else
                {
                    PopupMessage(hwnd,
                                 IDS_NAME_NOT_FOUND_FMT_SINGLE,
                                 pstrName->c_str(),
                                 rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
                    *pnpr = NPR_STOP_PROCESSING;
                }
            }
            break;
        }

         //
         //Now try dscrack. This may give a reference to another forest also.
         //We try dscrack name only for uplevel domain.
         //
         const SScopeParameters *pspExtUplevel =
                     rsm.GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);
 
         MACHINE_CONFIG mc = rop.GetTargetComputerConfig();
         if ((mc == MC_JOINED_NT5 || mc == MC_NT5_DC) &&         
             pspExtUplevel)
         {
 
 
             //
             //Crack the name
             //
             LPWSTR pwzResultName = NULL;                
             BOOL bExtForest = FALSE;
             BOOL bAddDollar = FALSE;

             hr = CrackName(hwnd,
                 (LPWSTR)pstrName->c_str(),                                
                 DS_NT4_ACCOUNT_NAME,
                 (LPWSTR)rop.GetTargetForest().c_str(),
                 TRUE,
                 &pwzResultName,
                 &bExtForest,
                 &bAddDollar);
             if(SUCCEEDED(hr) && bExtForest)
             {   
                 size_t cItemsAtStart = pdsolMatches->size();
                 if(pwzResultName )
                 {
                     String strXForestRdn = strRdn;
                     String strXForestUserEnteredString = *pstrName;
                     if(bAddDollar)
                     {
                         strXForestRdn += L"$";
                         AddDollarToNameToCrack(DS_NT4_ACCOUNT_NAME,strXForestUserEnteredString);
                     }

                     String strDomainFromCrack = pwzResultName;
                     LocalFree(pwzResultName);
                     pwzResultName = NULL;

                     pMatchingScope = &rsm.LookupScopeByFlatName(strDomainFromCrack);

                     //
                     // If a matching scope is found, query for or bind to the name
                     // within that scope, and perform a prefix search of the custom
                     // objects for that scope.
                     //

                     if (pMatchingScope && !IsInvalid(*pMatchingScope))
                     {

                         _QueryForName(hwnd,
                             rop,
                             *pMatchingScope,
                             strXForestRdn,
                             strXForestUserEnteredString,
                             flProcess,
                             pdsolMatches,
                             TRUE);
                         if(cItemsAtStart == pdsolMatches->size())
                         {
                             _CustomizerPrefixSearch(hwnd,
                                 rop,
                                 *pMatchingScope,
                                 strXForestRdn,
                                 pdsolMatches);
                         }
                     }
                     else
                     {
                         _SearchUplevelDomain(hwnd,
                             rop,
                             strDomainFromCrack,
                             pspExtUplevel,
                             strXForestRdn,
                             strXForestUserEnteredString,
                             flProcess,
                             TRUE,
                             TRUE,
                             pdsolMatches);

                     }
                     break;
                 } 
                 //else
                 //{
                 //We come here means in "a\b" "a" is in Xforest but 
                 //there is no object named "b" in "a". We should quit
                 //Here we need to show the NameNotFound message.
                 //Below if statement will show that.
                 //}

                 if(cItemsAtStart == pdsolMatches->size())
                 {
                     if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
                     {
                         CNameNotFoundDlg Dlg(rop,
                             IDS_NAME_NOT_FOUND_FMT_MULTI,
                             pstrName);

                         hr = Dlg.DoModalDialog(hwnd, pnpr);
                     }
                     else
                     {
                         PopupMessage(hwnd,
                             IDS_NAME_NOT_FOUND_FMT_SINGLE,
                             pstrName->c_str(),
                             rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
                         *pnpr = NPR_STOP_PROCESSING;
                     }
                     break;
                 }
             }
         }

         //
         // No matching scope. If the caller doesn't want us to search in
         // domains that didn't appear in the scope control, fail now.
         //
         // Note this code that requires the full list of domain scopes has
         // been populated before we get here, otherwise we could reject the
         // user's entry claiming that a scope which hasn't yet been added to
         // the scope list doesn't exist.
         //

         const SScopeParameters *pspUserUplevel =
             rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);

         const SScopeParameters *pspUserDownlevel =
             rsm.GetScopeParams(ST_USER_ENTERED_DOWNLEVEL_SCOPE);

         if (!pspUserUplevel && !pspUserDownlevel)
         {
             //
             // See if the user entered the bogus form:
             //      dns-name\object-name
             // If so, present a message explaining that they should
             // either use netbios-name\object-name or object-name@dns-name.
             //

             const CLdapDomainScope *pMatchingDisplayScope =
                 dynamic_cast<const CLdapDomainScope *>
                 (&rsm.LookupScopeByDisplayName(strScopeName));

             String strValidNB;
             String strValidUPN;

             if (pMatchingDisplayScope)
             {
                 strValidNB = pMatchingDisplayScope->GetFlatName();
                 strValidNB += L"\\";
                 strValidNB += strRdn;

                 strValidUPN = strRdn + L"@";
                 strValidUPN += strScopeName;
             }

             if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
             {
                 if (pMatchingDisplayScope)
                {
                    //
                    // yep.  build up an error message that explains
                    // what they did wrong and how to fix it.
                    //

                    String strError = String::format(IDS_DNS_SLASH_NAME,
                                                     pstrName->c_str(),
                                                     strValidNB.c_str(),
                                                     strValidUPN.c_str());

                    CNameNotFoundDlg Dlg(rop, strError, pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
                else
                {
                    //
                    // nope, they entered some random string which
                    // doesn't match the dns or the netbios name of
                    // anything in the lookin control.
                    //

                    CNameNotFoundDlg Dlg(rop, IDS_UNKNOWN_DOMAIN, pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
            }
            else
            {
                if (pMatchingDisplayScope)
                {
                    PopupMessage(hwnd,
                                 IDS_UNKNOWN_DOMAIN,
                                 pstrName->c_str(),
                                 strValidNB.c_str(),
                                 strValidUPN.c_str());
                }
                else
                {
                    PopupMessage(hwnd,
                                 IDS_UNKNOWN_DOMAIN,
                                 pstrName->c_str());
                }
                *pnpr = NPR_STOP_PROCESSING;
            }
            break;
        }

        //
        // Try to find an uplevel domain with name matching what the
        // user typed before the backslash, then query within it for
        // items starting with the characters after the backslash.
        //

        size_t cBeforeUplevelSearch = pdsolMatches->size();

        if (pspUserUplevel)
        {
            _SearchUplevelDomain(hwnd,
                                 rop,
                                 strScopeName,
                                 pspUserUplevel,
                                 strRdn,
                                 *pstrName,
                                 flProcess,
                                 TRUE,
                                 FALSE,
                                 pdsolMatches);
        }

        //
        // If no objects found that way, try searching for the object
        // strRdn in a downlevel domain with name strScopeName.
        //

        if (pspUserDownlevel &&
            pdsolMatches->size() == cBeforeUplevelSearch)
        {
            _SearchDownlevelDomain(hwnd,
                                   rop,
                                   strScopeName,
                                   strRdn,
                                   pdsolMatches);

            if (pdsolMatches->size() == cBeforeUplevelSearch)
            {
                if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
                {
                    CNameNotFoundDlg Dlg(rop,
                                        IDS_NAME_NOT_FOUND_FMT_MULTI,
                                        pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
                else
                {
                    PopupMessage(hwnd,
                                 IDS_NAME_NOT_FOUND_FMT_SINGLE,
                                 pstrName->c_str(),
                                 rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
                    *pnpr = NPR_STOP_PROCESSING;
                }
            }
        }
    }
    while (0);

    if (*pnpr == NPR_EDITED)
    {
        pdsolMatches->clear();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SearchUplevelDomain
//
//  Synopsis:   Attempt to bind to an uplevel domain with name [strScopeName]
//              and search for a name starting with [strRdn] there.
//
//  Arguments:  [hwnd]           - for bind
//              [rop]            - containing object picker instance
//              [strScopeName]   - name of scope to search in
//              [pspUserUplevel] - parameters for that scope
//              [strRdn]          [strNamePrefix] - Name to search for. 
//                                If user entered the name in domain\foo 
//                                format its foo
//                                If user entered the name in foo@domain 
//                                format its foo@domain
//                                If use entered the foo, its foo
//              [strUserEnteredString] The string user entered. Its used to 
//                                 get the sid in XForest case.
//              [bDoCustomizePrefix]    Call ExternalCustomizer. This is true
//                                  if user entered name in format
//                                  Domain\Foo and false if foo@domain
//              [bXForest]          Is name in XForest
//              [flProcess]      - DSO_NAME_PROCESSING_FLAG_* bits
//              [pdsolMatches]   - any matches are added to this list
//
//  History:    08-15-1998   DavidMun   Created
//
//  Notes:      If uplevel domain is found, creates a new scope object.
//
//---------------------------------------------------------------------------

void
CDsObject::_SearchUplevelDomain(
    HWND hwnd,
    const CObjectPicker &rop,
    const String &strScopeName,
    const SScopeParameters *pspUserUplevel,
    const String &strRdn,
    const String &strUserEnteredString,
    ULONG flProcess,
    BOOL bDoCustomizePrefix,
    BOOL bXForest,
    list<CDsObject> *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _SearchUplevelDomain);
    HRESULT hr = S_OK;
    String strDomainPath(c_wzLDAPPrefix);
    RpIDirectorySearch rpDirSearch;

    do
    {
        strDomainPath += strScopeName;

        hr = g_pBinder->BindToObject(hwnd,
                                     strDomainPath.c_str(),
                                     IID_IDirectorySearch,
                                     (void**)&rpDirSearch);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Create a scope for this domain.  It will not be made
        // visible (added to the dropdown scope list) but will be
        // included in the list of those searched if another name
        // in the form foo\bar is processed.
        //

        ADD_SCOPE_INFO  asi;
        if(!bXForest)
            asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
        else
            asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
        asi.FilterFlags = pspUserUplevel->FilterFlags;
        asi.Visibility = SCOPE_HIDDEN;
        asi.Domain.strScopeName = strScopeName;
        asi.Domain.strFlatName = strScopeName;
        asi.Domain.strADsPath = strDomainPath;

        const CScopeManager &rsm = rop.GetScopeManager();

        const CScope *pNewScope;
        if(!bXForest)
            pNewScope = &rsm.AddUserEnteredScope(asi);
        else
            pNewScope = &rsm.AddCrossForestDomainScope(asi);



        //
        // Query on the new scope for the rdn, also look for whatever
        // custom objects would be added to that domain scope.
        //

         size_t cItemsAtStart = pdsolMatches->size();

        _QueryForName(hwnd,
                      rop,
                      *pNewScope,
                      strRdn,
                      strUserEnteredString,
                      flProcess,
                      pdsolMatches,
                      bXForest);

        //
        //In cross forest we don't do prefix search, so if we have already found some objects
        //don't do further search
        //
        if(bDoCustomizePrefix && !(bXForest && (cItemsAtStart != pdsolMatches->size())))
            _CustomizerPrefixSearch(hwnd, rop, *pNewScope, strRdn, pdsolMatches);

        // NTRAID#NTBUG9-689629-2002/09/23-lucios
        // We are reverting pNewScope's addition if no matches have
        // been found, since that would cause the next search for foo
        // to call directly the uplevel search _QueryForName and 
        // not perform any downlevel search that could return matches.
        // See more details in the raid bug comments.
        if(pdsolMatches->size() == cItemsAtStart)
        {
            rsm.DeleteLastScope();
        }

    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SearchDownlevelDomain
//
//  Synopsis:   Attempt to bind to a downlevel domain with name
//              [strScopeName], then bind within that domain for a name
//              starting with [strRdn].
//
//  Arguments:  [hwnd]         - for bind
//              [rop]          - containing object picker instance
//              [strScopeName] - name of downlevel domain
//              [strRdn]       - name to search for
//              [pdsolMatches] - any matches are added to this list
//
//  History:    08-15-1998   DavidMun   Created
//
//  Notes:      If downlevel domain is found, creates a new scope object.
//
//---------------------------------------------------------------------------

void
CDsObject::_SearchDownlevelDomain(
    HWND hwnd,
    const CObjectPicker &rop,
    const String &strScopeName,
    const String &strRdn,
    CDsObjectList *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _SearchDownlevelDomain);
    HRESULT hr = S_OK;
    String  strScopePath;
    String  strScopePathWithHint;
    RpIADs  rpADs;

    do
    {
        strScopePath += c_wzWinNTPrefix + strScopeName;

        //
        // Try strScopeName as a computer first.
        //

        strScopePathWithHint = strScopePath + L",Computer";

        hr = g_pBinder->BindToObject(hwnd,
                                     strScopePathWithHint.c_str(),
                                     IID_IADs,
                                     (void**)&rpADs);

        if (FAILED(hr))
        {
            // Nope.  Try as domain.

            strScopePathWithHint = strScopePath + L",Domain";

            hr = g_pBinder->BindToObject(hwnd,
                                         strScopePathWithHint.c_str(),
                                         IID_IADs,
                                         (void**)&rpADs);
        }

        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Bind succeeded, therefore computer or domain exists.  Add a scope
        // for it and look for the RDN within it.
        //

        ADD_SCOPE_INFO  asi;

        const CScopeManager &rsm = rop.GetScopeManager();
        const SScopeParameters *pspUserDownlevel =
            rsm.GetScopeParams(ST_USER_ENTERED_DOWNLEVEL_SCOPE);

        asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
        asi.FilterFlags = pspUserDownlevel->FilterFlags;
        asi.Visibility = SCOPE_HIDDEN;
        asi.Domain.strScopeName = strScopeName;
        asi.Domain.strFlatName = strScopeName;
        asi.Domain.strADsPath = strScopePathWithHint;

        const CScope &rNewScope = rsm.AddUserEnteredScope(asi);

        //
        //Size of query before search
        //

        size_t cItemsAtStart = pdsolMatches->size();

        _BindForName(hwnd, rop, rNewScope, strRdn, pdsolMatches);
        _CustomizerPrefixSearch(hwnd, rop, rNewScope, strRdn, pdsolMatches);

        //
        //We don't keep this scope in list if nothing is found in this scope.
        //NTRAID#NTBUG9-243391-2001/01/17-hiteshr
        //
        if(cItemsAtStart == pdsolMatches->size())
            rsm.DeleteLastScope();

    } while (0);
}


HRESULT
_tThread_Proc(
    CProgressDialog& dialog)
{

    CRow * pRow = dialog.m_pRow;
    ULONG flProcess = dialog.m_flProcess;
    ULONG   cHits = 0;
    BOOL bXForest = dialog.m_bXForest;
    const CObjectPicker &rop = dialog.m_rop;
    const CScope &Scope = dialog.m_Scope;
    const String &strUserEnteredString = dialog.m_strUserEnteredString;
    CDsObjectList *pdsolMatches = dialog.m_pdsolMatches;

    ASSERT(pRow && pdsolMatches);

    String strFormat = String::load((int)IDS_PROGRESS_MESSAGE, g_hinst);
    HRESULT hr = S_OK;
    do // false loop
    {
        hr = CoInitialize(NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        while (SUCCEEDED(hr))
        {
            //
            //User pressed the stop button. Stop now.
            //
            if(dialog.HasUserCancelled())
                break;

            WCHAR buffer[34];
            _itow(cHits,buffer,10);
            String strMessage = String::format(strFormat, buffer);
            dialog.UpdateText(strMessage);

            hr = pRow->Next();

            if (hr == S_ADS_NOMORE_ROWS)
            {
                Dbg(DEB_TRACE,
                    "_QueryForName: S_ADS_NOMORE_ROWS, got %u\n",
                    cHits);

                ULONG ulADsLastError;
                WCHAR wzError[MAX_PATH];
                WCHAR wzProvider[MAX_PATH];

                HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                            wzError,
                                            ARRAYLEN(wzError),
                                            wzProvider,
                                            ARRAYLEN(wzProvider));

                if (SUCCEEDED(hr2) && ulADsLastError == ERROR_MORE_DATA)
                {
                    Dbg(DEB_TRACE, "Got ERROR_MORE_DATA, trying again\n");
                    continue;
                }

                break;
            }
            BREAK_ON_FAIL_HRESULT(hr);

            //
            // If we know that the user is looking for a computer, discard
            // objects not of class computer.
            //

            if (flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER)
            {
                PCWSTR pwzClass = pRow->GetColumnStr(AK_OBJECT_CLASS);

                if (!pwzClass)
                {
                    continue;
                }

                if (lstrcmpi(pwzClass, c_wzComputerObjectClass))
                {
                    continue;
                }
            }

            //
            // Create a new object and add it to the list
            //

            PCWSTR pwzName = pRow->GetColumnStr(AK_NAME);
            PCWSTR pwzClass = pRow->GetColumnStr(AK_OBJECT_CLASS);
            PCWSTR pwzPath = pRow->GetColumnStr(AK_ADSPATH);

            if (!pwzClass || !pwzName || !pwzPath)
            {
                Dbg(DEB_WARN,
                    "Skipping item missing class ('%ws'), name ('%ws'), or path ('%ws')\n",
                    pwzClass ? pwzClass : L"",
                    pwzName ? pwzName : L"",
                    pwzPath ? pwzPath : L"");
                continue;
            }


            //
            // Stop fetching items if we've exceeded the max for the multimatch
            // dialog.
            //

            // NTRAID#NTBUG9-490575-2002/04/08-lucios
            if (++cHits > MAX_SEARCH_HITS)
            {
                PopupMessageEx(IsWindow(dialog.GetHwnd())?
                                dialog.GetHwnd():dialog.GetParent(),
                            IDI_WARNING,
                            IDS_MAX_HITS,
                            MAX_SEARCH_HITS_STR);
                break;
            }

            //
            //If object is from Xforest, there is possibility of SID spoofing
            //we must verify that SID if fetched is good
            //first we check the upn typed cross forest names
            if(bXForest)
            {
                PSID pSid = pRow->GetObjectSid();

                BOOL bGoodSid = FALSE;
                hr = IsSidGood(rop.GetTargetComputer().c_str(),
                            strUserEnteredString.c_str(),
                            pSid,
                            &bGoodSid);

                if(FAILED(hr)) continue;
                
                if(!bGoodSid)
                {
                    Dbg(DEB_WARN,
                    "Skipping item Bad Sid('%ws'), name ('%ws'), or path ('%ws')\n",
                    pwzClass ? pwzClass : L"",
                    pwzName ? pwzName : L"",
                    pwzPath ? pwzPath : L"");

                    continue;
                }
           
            } 

            //
            // Add this new object if it isn't already in the list
            //

            CDsObject dsoNew(Scope.GetID(), pRow->GetAttributes());
            dsoNew.SetNeedsSidFiltering((Scope.Type()==ST_XFOREST)?TRUE:FALSE);

            if (find(pdsolMatches->begin(), pdsolMatches->end(), dsoNew) ==
                pdsolMatches->end())
            {
                pdsolMatches->push_back(dsoNew);
            }
        } // while (SUCCEEDED(hr))
        CoUninitialize();
    } while(0);
    
    dialog.ThreadDone();
    return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_QueryForName
//
//  Synopsis:   Perform a query in uplevel domain represented by [pDsScope]
//              for an object whose name starts with [strNamePrefix].
//
//  Arguments:  [hwnd]          - for bind
//              [rop]           - containing object picker instance
//              [Scope]         - scope in which to query
//              [strNamePrefix] - Name to search for. 
//                                If user entered the name in domain\foo 
//                                format its foo
//                                If user entered the name in foo@domain 
//                                format its foo@domain
//                                If use entered the foo, its foo
//              [strUserEnteredString] The string user entered. Its used to 
//                                get the sid from LSA in case of cross forest.                
//              [flProcess]     - DSO_NAME_PROCESSING_FLAG_* bits
//              [pdsolMatches]  - list to which to append matches
//              [bXForest]      - Is strNamePrefix in other forest. 
//                                If the name is another forest, we don't 
//                                support prefix search
//  History:    08-15-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_QueryForName(
    HWND hwnd,
    const CObjectPicker &rop,
    const CScope &Scope,
    const String &strNamePrefix,
    const String &strUserEnteredString,
    ULONG flProcess,
    CDsObjectList *pdsolMatches,
    BOOL bXForest)
{
    TRACE_METHOD(CDsObject, _QueryForName);
    ASSERT(IsUplevel(Scope));

    HRESULT hr = S_OK;
    const CLdapContainerScope *pLdapScope =
        dynamic_cast<const CLdapContainerScope *>(&Scope);

    if (!pLdapScope)
    {
        Dbg(DEB_TRACE,
            "Scope '%ws' type %u cast to CLdapContainerScope failed\n",
            Scope.GetDisplayName().c_str(),
            Scope.Type());
        ASSERT(0 && "expected to recieve ldap scope");
        return;
    }

    //
    // If the scope to query in is not the same as the current scope, then
    // it might not allow the types of objects selected for the current
    // scope.
    //

    const CFilterManager &rfm = rop.GetFilterManager();
    String strLdapContainerFilter = rfm.GetLdapFilter(hwnd, Scope);

    if (strLdapContainerFilter.empty())
    {
        Dbg(DEB_TRACE,
            "Scope '%ws' has no ldap query, returning\n",
            Scope.GetDisplayName().c_str());
        return;
    }

    String strADsPath;
    hr = pLdapScope->GetADsPath(hwnd, &strADsPath);

    if (FAILED(hr))
    {
        Dbg(DEB_TRACE,
            "Scope '%ws' has no ldap path, returning\n",
            Scope.GetDisplayName().c_str());
        return;
    }

    RpIDirectorySearch rpDirSearch;

    hr = g_pBinder->BindToObject(hwnd,
                                 strADsPath.c_str(),
                                 IID_IDirectorySearch,
                                 (void**)&rpDirSearch);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return;
    }

    //
    // Make a copy of the standard preferences and modify time limit
    // so it will be longer.  Want more generous limit for finding a
    // name the user typed in than just browsing.
    //

    ADS_SEARCHPREF_INFO aSearchPrefs[NUM_SEARCH_PREF];
    // REVIEWED-2002-02-20-lucios. aSearchPrefs has exactly 
    // the same size as g_aSearchPrefs
    CopyMemory(aSearchPrefs, g_aSearchPrefs, sizeof(aSearchPrefs));

    ULONG i;

    for (i = 0; i < NUM_SEARCH_PREF; i++)
    {
        if (aSearchPrefs[i].dwSearchPref == ADS_SEARCHPREF_PAGED_TIME_LIMIT)
        {
            aSearchPrefs[i].vValue.Integer = NAME_QUERY_PAGE_TIME_LIMIT;
            break;
        }
    }

    hr = rpDirSearch->SetSearchPreference(aSearchPrefs, NUM_SEARCH_PREF);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return;
    }

    //
    // Build the query clause, using an escaped version of the name.
    //

    String strEscaped(strNamePrefix);

    LdapEscape(&strEscaped);

    String strNameFilter;

    if(flProcess & DSO_NAME_PROCESSING_FLAG_EXACT_UPN)
    {
        strNameFilter = String::format(c_wzUpnQueryFormatExact,
            strEscaped.c_str());
    }
    else if (flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN)
    {
        String strNameBeforeAt(strNamePrefix);
        size_t idxLastAt = strNameBeforeAt.rfind(L'@');   
        if (idxLastAt != String::npos)
        {
            strNameBeforeAt.erase(idxLastAt);
        }
        LdapEscape(&strNameBeforeAt);        
        strNameFilter = String::format(c_wzUpnQueryFormatEx,
                                       strNameBeforeAt.c_str(),
                                       strEscaped.c_str());

    }
    else
    {
        if( bXForest )    
            strNameFilter = String::format(c_wzCnQueryFormatExact, strEscaped.c_str());
        else
            strNameFilter = String::format(c_wzCnQueryFormat, strEscaped.c_str());
    }

    // NTRAID#NTBUG9-431851-2001/08/23-lucios
    if (strNameFilter.size()==0)
    {
        Dbg(DEB_TRACE,"Could not format query string.");
        return;
    }
    // NTRAID#NTBUG9-431851-2001/08/23-lucios

#if (DBG == 1)
    Dbg(DEB_TRACE,
        "Querying for name %ws in scope %ws\n",
        strEscaped.c_str(),
        Scope.GetDisplayName().c_str());
#endif

    String strQuery;

    strQuery = L"(&";
    strQuery += strLdapContainerFilter;
    strQuery += strNameFilter;
    strQuery += L")";

    //
    // Perform the query
    //

    AttrKeyVector vakAttrToFetch;

    // NTRAID#NTBUG9-484598-2001/11/05-lucios
    // Added AK_DESCRIPTION
    vakAttrToFetch.push_back(AK_NAME);
    vakAttrToFetch.push_back(AK_OBJECT_CLASS);
    vakAttrToFetch.push_back(AK_ADSPATH);
    vakAttrToFetch.push_back(AK_USER_ACCT_CTRL);
    vakAttrToFetch.push_back(AK_USER_PRINCIPAL_NAME);
    vakAttrToFetch.push_back(AK_EMAIL_ADDRESSES);
    vakAttrToFetch.push_back(AK_SAMACCOUNTNAME);
    vakAttrToFetch.push_back(AK_DESCRIPTION);
    //
    //If object in cross forest, get the sid
    //
    if( bXForest || (Scope.Type() == ST_XFOREST) ) 
        vakAttrToFetch.push_back(AK_OBJECT_SID);

    CRow Row(hwnd, rop, rpDirSearch.get(), strQuery, vakAttrToFetch);


    CProgressDialog ProgressDialog( _tThread_Proc,
                                    IDA_SEARCH,
                                    1000*3,
                                    &Row,
                                    flProcess,
                                    bXForest,
                                    rop,
                                    Scope,
                                    strUserEnteredString,
                                    pdsolMatches);


    ProgressDialog.CreateProgressDialog(hwnd);

}




//+--------------------------------------------------------------------------
//
//  Class:      CStringCompare
//
//  Purpose:    Used as functor to search for string [rhs]
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CStringCompare
{
public:

    CStringCompare(
        const String &rhs):
            m_rhs(rhs)
    {
    }

    BOOL
    operator()(const String &lhs)
    {
        return !m_rhs.icompare(lhs);
    }

private:

    String m_rhs;
};

enum GROUP_TYPE
{
    GT_UNKNOWN,
    GT_LOCAL,
    GT_GLOBAL
};

#define NUM_SUB_AUTHORITES_FOR_BUILTIN_GROUPS   2


//+--------------------------------------------------------------------------
//
//  Function:   WantThisGroup
//
//  Synopsis:   Return TRUE if group object represented by [pADs] is valid in
//              scope [pDsScope].
//
//  Arguments:  [pDsScope]  - scope in which to check for acceptable groups
//              [pADs]      - points to group object to check
//              [ppwzClass] - filled with pointer to constant string
//
//  Returns:    TRUE if group object is acceptable in scope [pDsScope],
//              FALSE otherwise.
//
//  Modifies:   *[ppwzClass] points to "localGroup" or "globalGroup"
//
//  History:    7-01-1999   davidmun   Created
//
//---------------------------------------------------------------------------

BOOL
WantThisGroup(
    ULONG flDownlevel,
    IADs *pADs,
    PCWSTR *ppwzClass)
{
    ASSERT(flDownlevel & DOWNLEVEL_FILTER_BIT);
    ASSERT(pADs);

    HRESULT hr = S_OK;
    BOOL fWantGroup = FALSE;

    //
    // Get the downlevel filter flags for the current scope.  Also, before
    // entering the loop(s), determine whether it is necessary to check for the
    // group type of returned groups.
    //

    BOOL fWantLocal = (flDownlevel & DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS) ==
            DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

    BOOL fWantGlobal = (flDownlevel & DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS) ==
            DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

    BOOL fExcludeBuiltin = (flDownlevel &
                            DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS)
                    == DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;

    GROUP_TYPE  eGroupType = GT_UNKNOWN;

    Variant     varGroupType;

    do
    {
        // Get group type

        hr = pADs->Get(AutoBstr(c_wzGroupTypeAttr), &varGroupType);
        BREAK_ON_FAIL_HRESULT(hr);

        if (V_UI4(&varGroupType) & ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP)
        {
            eGroupType = GT_LOCAL;
        }
        else if (V_UI4(&varGroupType) & ADS_GROUP_TYPE_GLOBAL_GROUP)
        {
            eGroupType = GT_GLOBAL;
        }
        else
        {
            Dbg(DEB_ERROR,
                "Unknown group type value %#x\n",
                V_UI4(&varGroupType));
            break;
        }

        // if excluding builtin local groups, check for that

        if (fExcludeBuiltin && eGroupType == GT_LOCAL)
        {
            Variant varSid;

            hr = pADs->Get((BSTR)c_wzObjectSidAttr, &varSid);
            BREAK_ON_FAIL_HRESULT(hr);

            PSID psid = NULL;

            hr = varSid.SafeArrayAccessData((VOID**)&psid);
            BREAK_ON_FAIL_HRESULT(hr);

            ASSERT(IsValidSid(psid));

            PUCHAR  pcSubAuth = NULL;

            pcSubAuth = GetSidSubAuthorityCount(psid);

            ASSERT(pcSubAuth);

            if (*pcSubAuth == NUM_SUB_AUTHORITES_FOR_BUILTIN_GROUPS)
            {
                break;
            }
        }

        //
        // If we want one type of group but not another, check
        // that.
        //

        ASSERT(fWantLocal || fWantGlobal);

        if (!fWantLocal  && eGroupType == GT_LOCAL ||
            !fWantGlobal && eGroupType == GT_GLOBAL)
        {
            break;
        }

        //
        // Translate from the WinNT provider's group class/
        // type combo to an internal-use-only group class
        // of localgroup or globalgroup.
        //

        if (eGroupType == GT_LOCAL)
        {
            *ppwzClass = c_wzLocalGroupClass;
        }
        else
        {
            ASSERT(eGroupType == GT_GLOBAL);
            *ppwzClass = c_wzGlobalGroupClass;
        }

        fWantGroup = TRUE;
    } while (0);

    return fWantGroup;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_BindForName
//
//  Synopsis:   Attempt to bind to object [strName] in downlevel domain
//              represented by [pDsScope].
//
//  Arguments:  [hwnd]         - parent window, required for binding
//              [rop]          - containing object picker instance
//              [Scope]        - downlevel scope containing object
//              [strName]      - rdn of object
//              [pdsolMatches] - list to which to append new object
//
//  History:    08-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_BindForName(
    HWND                    hwnd,
    const CObjectPicker    &rop,
    const CScope           &Scope,
    const String           &strName,
    CDsObjectList         *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _BindForName);
    ASSERT(pdsolMatches);
    ASSERT(IsDownlevel(Scope));

    String  strObjectPath;
    Bstr    bstrName;
    Bstr    bstrClass;
    Bstr    bstrPath;
    RpIADsContainer  rpADsContainer;
    RpIDispatch     rpdisp;
    RpIADs  rpADs;
    HRESULT hr = S_OK;

    do
    {
        const CAdsiScope *pAdsiScope = dynamic_cast<const CAdsiScope *>(&Scope);

        if (!pAdsiScope)
        {
            Dbg(DEB_ERROR, "Expected scope to have CAdsiScope base\n");
            break;
        }

        hr = pAdsiScope->GetADsPath(hwnd, &strObjectPath);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "Scope '%ws' has no path, returning\n",
                pAdsiScope->GetDisplayName());
            break;
        }

        hr = g_pBinder->BindToObject(hwnd,
                                     strObjectPath.c_str(),
                                     IID_IADsContainer,
                                     (void**) &rpADsContainer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = rpADsContainer->GetObject(NULL,
                                       AutoBstr(strName),
                                       (IDispatch**)&rpdisp);

        if (FAILED(hr))
        {
            Dbg(DEB_ERROR,
                "GetObject(NULL,'%ws') error %#x\n",
                strName.c_str(),
                hr);
            break;
        }

        hr = rpADs.AcquireViaQueryInterface(*(IUnknown*)rpdisp.get(),
                                            IID_IADs);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Check the item's class against what the caller wants.
        //

        hr = rpADs->get_Class(&bstrClass);
        BREAK_ON_FAIL_HRESULT(hr);

        PCWSTR pwzClass = bstrClass.c_str();
        vector<String> vsWinNtFilter;

        const CFilterManager &rfm = rop.GetFilterManager();
        rfm.GetWinNtFilter(hwnd, Scope, &vsWinNtFilter);
        vector<String>::const_iterator itFilter;

        CStringCompare StringCompare(pwzClass);

        itFilter = find_if(vsWinNtFilter.begin(),
                           vsWinNtFilter.end(),
                           StringCompare);

        if (itFilter == vsWinNtFilter.end())
        {
            break;
        }

        ULONG flFilter;

        hr = rfm.GetSelectedFilterFlags(hwnd, Scope, &flFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        if (!lstrcmpi(bstrClass.c_str(), c_wzGroupObjectClass) &&
            !WantThisGroup(flFilter, rpADs.get(), &pwzClass))
        {
            break;
        }

        //
        // Found item and it has allowed class.  Ask it for the rest of
        // the attributes we need.
        //

        hr = rpADs->get_Name(&bstrName);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(bstrName.c_str());

        hr = rpADs->get_ADsPath(&bstrPath);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(bstrPath.c_str());

        SDsObjectInit Init;

        Init.idOwningScope = Scope.GetID();
        Init.pwzName = bstrName.c_str();
        Init.pwzClass = pwzClass;
        Init.pwzADsPath = bstrPath.c_str();
        Init.fDisabled = IsDisabled(rpADs.get());

        pdsolMatches->push_back(CDsObject(Init));
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CustomizerPrefixSearch
//
//  Synopsis:   Ask the customizer to do a prefix
//              search for [strNamePrefix].
//
//  Arguments:  [hwnd]          - for bind
//              [rop]           - containing object picker instance
//              [Scope]         - scope in which to search
//              [strNamePrefix] - start of name to search for
//              [pdsolMatches]  - list to which to append matches
//
//  History:    08-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_CustomizerPrefixSearch(
    HWND            hwnd,
    const CObjectPicker &rop,
    const CScope   &Scope,
    const String   &strNamePrefix,
    CDsObjectList  *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _CustomizerPrefixSearch);

    IDataObject *pdoToAdd = NULL;
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG flCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();
    ICustomizeDsBrowser *pExternalCustomizer = rop.GetExternalCustomizer();

    do
    {
        //
        // First check to see if the selected filter flags include the ones
        // for the internal or external customizer.  If none are set, bail.
        //

        if (!(flCurFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER) &&
            !(flCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS) &&
            !IsDownlevelFlagSet(flCurFilterFlags,
                                ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            break;
        }

        CDsObjectList dsol;

        //
        // If an external customizer is provided, use it
        //

        if (pExternalCustomizer &&
            (flCurFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
        {
            HRESULT hr;
            IDsObjectPickerScope *pDsopScope =
                static_cast<IDsObjectPickerScope *>(const_cast<CScope*>(&Scope));

            hr = pExternalCustomizer->PrefixSearch(pDsopScope,
                                                   strNamePrefix.c_str(),
                                                   &pdoToAdd);

            if (SUCCEEDED(hr) && pdoToAdd)
            {
                const CScopeManager &rsm = rop.GetScopeManager();
                const CScope &rCurScope = rsm.GetCurScope();

                AddFromDataObject(rCurScope.GetID(), pdoToAdd, NULL, 0, &dsol);
            }
        }

        //
        // Assume if the caller set flags that the internal customizer knows
        // about that it should also be used.
        //

        if ((flCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS) ||
                 IsDownlevelFlagSet(flCurFilterFlags,
                                    ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            const CAdminCustomizer &ac = rop.GetDefaultCustomizer();

            ac.PrefixSearch(hwnd, Scope, strNamePrefix, &dsol);
        }

        //
        // Move any objects from pdsol which aren't already in pdsolMatches
        // into the latter.
        //

        CDsObjectList::iterator it;

        for (it = dsol.begin(); it != dsol.end(); it++)
        {
            if (find(pdsolMatches->begin(),
                     pdsolMatches->end(),
                     *it) == pdsolMatches->end())
            {
                pdsolMatches->push_back(*it);
            }
        }
    } while (0);

    SAFE_RELEASE(pdoToAdd);
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_BindForComputer
//
//  Synopsis:   Attempt to bind to a computer with name [strName], if
//              successful, add an object representing it to [pdsolMatches]
//
//  Arguments:  [hwnd]         - for bind
//              [rop]          - containing object picker instance
//              [strName]      - name of computer
//              [pdsolMatches] - list to which to append matches
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_BindForComputer(
    HWND hwnd,
    const CObjectPicker &rop,
    const String &strName,
    CDsObjectList *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _BindForComputer);

    const CScopeManager &rsm = rop.GetScopeManager();
    const SScopeParameters *pspUserUplevel =
        rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);
    const SScopeParameters *pspUserDownlevel =
        rsm.GetScopeParams(ST_USER_ENTERED_DOWNLEVEL_SCOPE);
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG flCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();

    do
    {
        // don't try to find computer if user hasn't checked the Computers
        // box

        if (flCurFilterFlags & DOWNLEVEL_FILTER_BIT)
        {
            if (!IsDownlevelFlagSet(flCurFilterFlags,
                                    DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                Dbg(DEB_TRACE, "Cur scope selected filter flags don't contain computer, exiting\n");
                break;
            }
        }
        else if (!(flCurFilterFlags & DSOP_FILTER_COMPUTERS))
        {
            Dbg(DEB_TRACE, "Cur scope selected filter flags don't contain computer, exiting\n");
            break;
        }

        ULONG flUplevel = 0;

        if (pspUserUplevel)
        {
            flUplevel = pspUserUplevel->FilterFlags.Uplevel.flBothModes
                | pspUserUplevel->FilterFlags.Uplevel.flNativeModeOnly
                | pspUserUplevel->FilterFlags.Uplevel.flMixedModeOnly;
        }

        ULONG flDownlevel = 0;

        if (pspUserDownlevel)
        {
            flDownlevel = pspUserDownlevel->FilterFlags.flDownlevel;
        }

        if (!(flUplevel & DSOP_FILTER_COMPUTERS) &&
            !((flDownlevel & DSOP_DOWNLEVEL_FILTER_COMPUTERS) ==
             DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            break;
        }

        BOOL fFound = FALSE;

        if (!pdsolMatches->empty())
        {
            CDsObjectList::iterator it = pdsolMatches->begin();

            do
            {
                it = find(it, pdsolMatches->end(), strName);

                if (it != pdsolMatches->end())
                {
                    //
                    // name matches.  if class is computer, we've found
                    // it already, so don't continue with attempt to bind.
                    //

                    if (!lstrcmpi(it->GetClass(), c_wzComputerObjectClass))
                    {
                        fFound = TRUE;
                        break;
                    }
                    it++;
                }
            } while (!fFound && it != pdsolMatches->end());

            if (fFound)
            {
                Dbg(DEB_TRACE,
                    "Found computer %ws in matches, no need to bind for it\n",
                    strName.c_str());
                break;
            }
        }

        //
        // No computer object with matching name in pdsolMatches.  If the
        // computer name looks legal, try to bind.
        //

        if (strName.find_first_of(String(c_wzIllegalComputerNameChars)) !=
            String::npos)
        {
            Dbg(DEB_TRACE,
                "Name contains illegal character(s), not attempting to bind\n");
            break;
        }

        String strADsPath = c_wzWinNTPrefix;
        strADsPath += strName;
        strADsPath += L",Computer";

        RpIADs rpADs;

        Dbg(DEB_TRACE, "Attempting to bind to computer object\n");

        HRESULT hr = g_pBinder->BindToObject(hwnd,
                                             strADsPath.c_str(),
                                             IID_IADs,
                                             (void **)&rpADs);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // OK, we bound to the computer, so it exists.  We'll take the
        // easy way out here and instead of figuring out all the info
        // about the domain or workgroup to which the computer belongs,
        // just create a hidden scope with no name or address.
        //
        // Note this means you can enter a computer name which is
        // in a domain in the forest (but not yet propagated to GC, or
        // GC unavailable), or in some external trusted domain, which is
        // not represented by the current scope at the time the name was
        // entered, but is nevertheless represented by some other scope,
        // and the computer object will be returned with a scope type
        // of DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE or
        // DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE instead of the
        // scope type of its "real" owner.
        //

        ADD_SCOPE_INFO  asi;

        if (flUplevel & DSOP_FILTER_COMPUTERS)
        {
            asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
            asi.FilterFlags = pspUserUplevel->FilterFlags;
        }
        else
        {
            asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            asi.FilterFlags = pspUserDownlevel->FilterFlags;
        }

        asi.Visibility = SCOPE_HIDDEN;

        const CScope &rNewScope = rsm.AddUserEnteredScope(asi);

        CDsObject dsoComputer(rNewScope.GetID(), rpADs.get());
        pdsolMatches->push_back(dsoComputer);

    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_FetchAttributes
//
//  Synopsis:   Attempt to read for this object the attributes caller
//              requested be returned on all selected objects.
//
//  Arguments:  [hwnd] - for bind
//              [rop]  - containing object picker instance
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Object Picker does not guarantee to its callers that it
//              will successfully fetch any attributes.
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_FetchAttributes(
    HWND hwnd,
    const CObjectPicker &rop)
{
    TRACE_METHOD(CDsObject, _FetchAttributes);

    HRESULT hr = S_OK;
    const BSTR wzName = GetName();
    const BSTR wzClass = GetClass();
    const BSTR wzADsPath = GetADsPath();

    do
    {
        //
        // If we've already been here, bail.
        //

        if (_IsFlagSet(DSO_FLAG_FETCHED_ATTRIBUTES))
        {
            Dbg(DEB_TRACE,
                "object %ws has already fetched attributes\n",
                wzName);
            break;
        }

        //
        // See if there are any attributes to fetch.  If not, bail.
        //

        const vector<String> &rvAttrToFetch = rop.GetAttrToFetchVector();

        if (rvAttrToFetch.empty())
        {
            break;
        }

        //
        // If this object has a path, bind to it for IADs and use that
        // to read the attributes.
        //

        if (*wzADsPath)
        {
            RpIADs rpADs;

            // NTRAID#NTBUG9-550562-2002/06/19-artm
            RpIADs alternateADs;
            String ldapPath(wzADsPath);


            //
            // Iterate through the attribute names, fetching each.
            //

            Dbg(DEB_TRACE, "fetching attributes for object %ws\n", wzName);

            vector<String>::const_iterator itAttrName;

            for (itAttrName = rvAttrToFetch.begin(); itAttrName != rvAttrToFetch.end(); itAttrName++)
            {
                const CAttributeManager &ram = rop.GetAttributeManager();
                ATTR_KEY ak = ram.GetAttrKey(*itAttrName);

                if( 
                    (ak == AK_OBJECT_CLASS) || 
                    (ak == AK_NAME) || 
                    (ak == AK_ADSPATH) 
                  )
                {
                    // NTRAID#NTBUG9-502751-2002/01/09-lucios
                    // There is no reason to refetch this common attributes and
                    // the refetching of the class was causing bug 502751 since
                    // the ->get here retrieves it as a Variant List and the 
                    // search retrieves it as a String. After the variant list
                    // overwrites the string, CDsObject->GetClass, that expects
                    // a BSTR for the class, does not work.
                    continue;
                }
                HRESULT hr2;

                BOOL fIsGroupTypeAttr = !itAttrName->icompare(c_wzGroupTypeAttr);
                Variant varFetched;

                if (fIsGroupTypeAttr &&
                    !lstrcmpi(wzClass, c_wzLocalGroupClass))
                {
                    varFetched.SetUI4(ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP);
                }
                else if (fIsGroupTypeAttr &&
                         !lstrcmpi(wzClass, c_wzGlobalGroupClass))
                {
                    varFetched.SetUI4(ADS_GROUP_TYPE_GLOBAL_GROUP);
                }
                else
                {
                    //
                    // If we haven't bound to the object yet, do so.  If this
                    // fails, exit the loop since we won't be able to get
                    // any attributes from ADSI without the interface.
                    //

                    if (!rpADs.get())
                    {
                        hr = g_pBinder->BindToObject(hwnd,
                                                     wzADsPath,
                                                     IID_IADs,
                                                     (void**) &rpADs);
                        BREAK_ON_FAIL_HRESULT(hr);
                    }

                    hr2 = rpADs->Get(AutoBstr(*itAttrName),
                                     &varFetched);

                    if (FAILED(hr2))
                    {
                        // this is pretty noisy and not necessarily an error
                        Dbg(DEB_WARN,
                            "Err %#x fetching attribute '%ws' on '%ws'\n",
                            hr2,
                            itAttrName->c_str(),
                            wzName);

                        hr = hr2;
                        ASSERT(varFetched.Empty());

                        // NTRAID#NTBUG9-550562-2002/06/19-artm
                        // If we are targetting the GC, an attribute fetch can
                        // fail even if the attribute exists.  Try to retrieve the
                        // attribute a second time by targetting the domain.
                        hr2 = E_FAIL;

                        do // false loop
                        {
                            ULONG pathProvider = 0;
                            hr2 = ProviderFlagFromPath(wzADsPath, &pathProvider);

                            if ( FAILED(hr2) || !(pathProvider & PROVIDER_GC) )
                            {
                                break;
                            }

                            Dbg(DEB_DBGOUT, 
                                "Trying to fetch attribute '%ws' using LDAP://\n",
                                itAttrName->c_str());

                            // Initialize the alternate ADs target on demand.
                            if (!alternateADs.get())
                            {
                                hr2 = g_pADsPath->ConvertProvider(&ldapPath, L"LDAP");

                                BREAK_ON_FAIL_HRESULT(hr2);

                                hr2 = g_pBinder->BindToObject(hwnd,
                                    ldapPath.c_str(),
                                    IID_IADs,
                                    (void**) &alternateADs);
                                BREAK_ON_FAIL_HRESULT(hr2);
                            }

                            
                            hr2 = alternateADs->Get(AutoBstr(*itAttrName),
                                            &varFetched);

                            if (FAILED(hr2))
                            {
                                // this is pretty noisy and not necessarily an error
                                Dbg(DEB_DBGOUT,
                                    "Second attempt to fetch attribute '%ws' on '%ws' failed with %#x.\n",
                                    itAttrName->c_str(),
                                    ldapPath.c_str(),
                                    hr2);

                                // We do not want to update the hr value, use the failed hresult 
                                // from the first attempt.
                                //hr = hr2;

                                ASSERT(varFetched.Empty());
                            }

                        } while(false);
                    }
                }

                //
                // If we couldn't get this attribute, go on to the next one
                // to fetch.
                //

                if (varFetched.Empty())
                {
                    continue;
                }

                //
                // The attribute value is now in varFetched, put its value in
                // m_AttrValueMap.  To do this we have to get the ATTR_KEY that
                // corresponds to the attribute's ADSI name in itAttrName.
                //

                m_AttrValueMap[ak] = varFetched;
            }
            break;
        }

        //
        // This object doesn't have a path.  It probably doesn't really
        // exist in the DS and was added by CustomizeDsBrowser interface.
        // If caller wants objectSid or groupType attribute, fabricate
        // a variant with the property.
        //

        const CAdminCustomizer &rac = rop.GetDefaultCustomizer();
        PSID psid = rac.LookupDownlevelName(wzName);
        vector<String>::const_iterator it;

        for (it = rvAttrToFetch.begin(); it != rvAttrToFetch.end(); it++)
        {
            if (!it->icompare(c_wzObjectSidAttr))
            {
                Variant varSid;

                hr = _CreateSidVariant(psid, &varSid);
                BREAK_ON_FAIL_HRESULT(hr);

                m_AttrValueMap[AK_OBJECT_SID] = varSid;
            }
            else if (!it->icompare(c_wzGroupTypeAttr))
            {
                Variant varGroupType;

                if (!lstrcmpi(wzClass, c_wzLocalGroupClass))
                {
                    varGroupType.SetUI4(ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP);
                }
                else if (!lstrcmpi(wzClass, c_wzGlobalGroupClass))
                {
                    varGroupType.SetUI4(ADS_GROUP_TYPE_GLOBAL_GROUP);
                }
                m_AttrValueMap[AK_GROUP_TYPE] = varGroupType;
            }
        }
    } while (0);

    _SetFlag(DSO_FLAG_FETCHED_ATTRIBUTES);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CreateSidVariant
//
//  Synopsis:   Fill variant pointed to by [pvar] with the array of bytes
//              contained in the SID pointed to by [psid].
//
//  Arguments:  [psid] - points to SID to copy
//              [pvar] - points to variant to fill with copy
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_CreateSidVariant(
    PSID psid,
    VARIANT *pvar)
{
    HRESULT hr = S_OK;
    PUCHAR pcSubAuth = NULL;
    ULONG cbSid = 0;
    SAFEARRAYBOUND sabound;
    SAFEARRAY *psa = NULL;
    ULONG i;
    PVOID pvData = NULL;
    PULONG pulSubAuth = NULL;

    ASSERT(psid);

    if (!psid)
    {
        return E_POINTER;
    }

    ASSERT(IsValidSid(psid));
    ASSERT(V_VT(pvar) == VT_EMPTY);

    do
    {
        pcSubAuth = GetSidSubAuthorityCount(psid);

        ASSERT(pcSubAuth);

        cbSid = GetSidLengthRequired(*pcSubAuth);

        ASSERT(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

        sabound.cElements = cbSid;
        sabound.lLbound = 0;

        psa = SafeArrayCreate(VT_UI1, 1, &sabound);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = SafeArrayAccessData(psa, &pvData);
        BREAK_ON_FAIL_HRESULT(hr);

        pulSubAuth = (LPDWORD)pvData;

        SID sid;
    
        ZeroMemory(&sid, sizeof sid);

        sid.Revision = SID_REVISION;
        sid.SubAuthorityCount = *pcSubAuth;
        sid.IdentifierAuthority = *GetSidIdentifierAuthority(psid);

        // NTRAID#NTBUG9-550488-2002/02/20-lucios. Pending fix.
        // pvData apperently has a size of cbSid from the safearray
        // I don't know what garantees that this will be the same as
        // sizeof(SID)
        CopyMemory(pvData, &sid, sizeof(SID));

        pulSubAuth = (PULONG)((PBYTE)pvData + sizeof(SID) - sizeof(ULONG));

        for (i = 0; i < *pcSubAuth; i++)
        {
            *pulSubAuth++ = *GetSidSubAuthority(psid, i);
        }

        ASSERT(IsValidSid((PSID)pvData));

        SafeArrayUnaccessData(psa);

        pvar->vt = VT_ARRAY | VT_UI1;
        pvar->parray = psa;
    } while (0);

    return hr;
}


#define DSOP_ACCEPTABLE_PROVIDER_SCOPE_FLAGS    \
    (DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT        \
    | DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP)

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_ConvertProvider
//
//  Synopsis:   Convert the path of this object as necessary to make it
//              use one of the acceptable providers for its owning scope.
//
//  Arguments:  [hwnd] - for bind
//              [rop]  - containing object picker instance
//              [pnpr] - filled with result of processing
//
//  Returns:    HRESULT
//
//  History:    08-18-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_ConvertProvider(
    HWND hwnd,
    const CObjectPicker &rop,
    NAME_PROCESS_RESULT *pnpr)
{
    TRACE_METHOD(CDsObject, _ConvertProvider);

    HRESULT hr = S_OK;

    do
    {
        if (_IsFlagSet(DSO_FLAG_CONVERTED_PROVIDER))
        {
            break;
        }

        //
        // Some special objects don't have paths.  If the scope flag
        // DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_SID_PATH is set, create one based on
        // the object's sid, otherwise leave it empty.
        //

        const CScopeManager &sm = rop.GetScopeManager();
        const CScope &rOwningScope = sm.LookupScopeById(GetOwningScopeID());
        ASSERT(rOwningScope.Type() != ST_INVALID);

        if (!*GetADsPath())
        {
            //
            // see if the scope params for the scope in which this
            // object resides indicate we should generate a path
            //

            if (rOwningScope.GetScopeFlags() &
                DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH)
            {
                hr = _CreateDownlevelSidPath(rop);
            }
            break;
        }

        //
        // Force conversion of this object to LDAP://<SID=x> format if
        // objects in the owning scope are to be converted and this
        // object has an objectSid attribute.
        //

        if (rOwningScope.GetScopeFlags() & DSOP_SCOPE_FLAG_WANT_SID_PATH)
        {
            hr = _CreateUplevelSidPath(hwnd);
            break;
        }

        //
        // Compare the provider used by this object against the ones
        // allowed by its owning scope.  If it's already in an acceptable
        // form, no conversion is required.
        //

        ULONG flThisProvider;

        hr = ProviderFlagFromPath(GetADsPath(), &flThisProvider);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG flAcceptableProviders =
            rOwningScope.GetScopeFlags() & DSOP_ACCEPTABLE_PROVIDER_SCOPE_FLAGS;

        if (!flAcceptableProviders ||
            (flThisProvider & flAcceptableProviders))
        {
            break;
        }

        //
        // Path is using unacceptable provider.
        //

        //
        // If the acceptable provider list includes LDAP and the
        // path is based on GC, use IADsPathname to make the change.
        //

        if ((flAcceptableProviders & DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP) &&
            (flThisProvider & PROVIDER_GC))
        {
            String strPath = GetADsPath();
            hr = g_pADsPath->ConvertProvider(&strPath, L"LDAP");

            if (SUCCEEDED(hr))
            {
                Variant varPath;

                hr = varPath.SetBstr(strPath);
                BREAK_ON_FAIL_HRESULT(hr);

                m_AttrValueMap[AK_PROCESSED_ADSPATH] = varPath;
            }
            break;
        }

        //
        // If the acceptable provider list includes WinNT, use
        // IADsNameTranslate to convert.
        //

        if (flAcceptableProviders & PROVIDER_WINNT)
        {
            ASSERT((flThisProvider & PROVIDER_GC) ||
                   (flThisProvider & DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP));
            ASSERT(IsUplevel(rOwningScope));

            RpIADsNameTranslate rpADsNameTranslate;
            Bstr bstrMyDN;

            if (rOwningScope.Type() == ST_INVALID)
            {
                hr = E_UNEXPECTED;
                DBG_OUT_HRESULT(hr);
                break;
            }

            const CLdapContainerScope *pOwningLdapScope =
                dynamic_cast<const CLdapContainerScope *>(&rOwningScope);

            ASSERT(pOwningLdapScope);
            if (!pOwningLdapScope)
            {
                hr = E_UNEXPECTED;
                DBG_OUT_HRESULT(hr);
                break;
            }

            String strADsPath;

            hr = pOwningLdapScope->GetADsPath(hwnd, &strADsPath);
            BREAK_ON_FAIL_HRESULT(hr);

            {
                IADsNameTranslate *pNameTranslate = NULL;
                hr = g_pBinder->GetNameTranslate(hwnd,
                                                 strADsPath.c_str(),
                                                 &pNameTranslate);
                BREAK_ON_FAIL_HRESULT(hr);
                rpADsNameTranslate.Acquire(pNameTranslate);
            }

            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         GetADsPath(),
                                         ADS_FORMAT_X500_DN,
                                         &bstrMyDN);

            hr = rpADsNameTranslate->Set(ADS_NAME_TYPE_1779, bstrMyDN.c_str());
            BREAK_ON_FAIL_HRESULT(hr);

            Bstr bstrNT4;

            hr = rpADsNameTranslate->Get(ADS_NAME_TYPE_NT4, &bstrNT4);
            BREAK_ON_FAIL_HRESULT(hr);

            PWSTR pwzWhack = wcschr(bstrNT4.c_str(), L'\\');

            if (pwzWhack)
            {
                *pwzWhack = L'/';
            }
            else
            {
                Dbg(DEB_WARN, "Expected backslash in nt4 name '%s'\n", bstrNT4);
            }

            String strProcessedADsPath = c_wzWinNTPrefix;
            strProcessedADsPath += bstrNT4.c_str();
            Variant var;

            hr = var.SetBstr(strProcessedADsPath);
            BREAK_ON_FAIL_HRESULT(hr);

            m_AttrValueMap[AK_PROCESSED_ADSPATH] = var;
            m_AttrValueMap.erase(AK_DISPLAY_PATH);
            break;
        }

        //
        // If we're still here then the conversion hasn't happened yet.
        // There's one last permutation: the acceptable provider list
        // includes LDAP, but the current object is using WINNT.  The
        // only way to convert is if the object has an objectSid attribute.
        //

        if ((flAcceptableProviders & DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP) &&
            (flThisProvider & PROVIDER_WINNT))
        {
            hr = _CreateUplevelSidPath(hwnd);
        }
        else
        {
            Dbg(DEB_ERROR,
                "Unexpected combination: flPathProvider 0x%x, flAcceptableProviders 0x%x\n",
                flThisProvider,
                flAcceptableProviders);
            hr = E_FAIL;
        }
    } while (0);

    if (FAILED(hr))
    {
        *pnpr = NPR_STOP_PROCESSING;
    }
    else
    {
        _SetFlag(DSO_FLAG_CONVERTED_PROVIDER);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CreateUplevelSidPath
//
//  Synopsis:   Convert this object's path to the form LDAP://<sid=x> where
//              x is the string of hex digits (no spaces) that make up the
//              objectSid attribute value.
//
//  Arguments:  [hwnd] - for bind
//
//  Returns:    HRESULT
//
//  History:    08-18-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_CreateUplevelSidPath(
    HWND hwnd)
{
    HRESULT hr = S_OK;
    RpIADs  rpADs;
    Variant varSid;
    PSID    psid = NULL;
    BOOL    fAccessedData = FALSE;

    do
    {
        if (!*GetADsPath())
        {
            break;
        }

        hr = g_pBinder->BindToObject(hwnd,
                                     GetADsPath(),
                                     IID_IADs,
                                     (void**)&rpADs);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = rpADs->Get(AutoBstr(c_wzObjectSidAttr), &varSid);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(varSid.Type() == (VT_ARRAY | VT_UI1));

        hr = SafeArrayAccessData(V_ARRAY(&varSid), (VOID**)&psid);
        BREAK_ON_FAIL_HRESULT(hr);

        fAccessedData = TRUE;

        ASSERT(IsValidSid(psid));

        String strPath = c_wzLDAPPrefix;

        strPath += c_wzSidPathPrefix;

        //
        // Convert the bytes of the sid to hex chars.
        //

        PBYTE  pbSid = (PBYTE) psid;
        ULONG  i;
        PUCHAR  pcSubAuth = NULL;

        pcSubAuth = GetSidSubAuthorityCount(psid);

        ASSERT(pcSubAuth);

        ULONG   cbSid = GetSidLengthRequired(*pcSubAuth);

        ASSERT(cbSid);
        ASSERT(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

        for (i = 0; i < cbSid; i++)
        {
            WCHAR wzCur[3];
            
            // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
            wsprintf(wzCur, L"%02x", *pbSid);
            pbSid++;

            strPath += wzCur;
        }

        strPath += c_wzSidPathSuffix;
        Variant var;

        hr = var.SetBstr(strPath);
        BREAK_ON_FAIL_HRESULT(hr);

        m_AttrValueMap[AK_PROCESSED_ADSPATH] = var;
    } while (0);

    if (fAccessedData)
    {
        SafeArrayUnaccessData(V_ARRAY(&varSid));
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CreateDownlevelSidPath
//
//  Synopsis:   Create a path in the form WinNT://NT AUTHORITY/Interactive
//
//  Arguments:  [rop] - containing object picker instance
//
//  Returns:    HRESULT
//
//  History:    07-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_CreateDownlevelSidPath(
    const CObjectPicker &rop)
{
    TRACE_METHOD(CDsObject, _CreateDownlevelSidPath);

    HRESULT hr = S_OK;

    do
    {
        const CAdminCustomizer &rac = rop.GetDefaultCustomizer();

        PCWSTR pwzPath = rac.LookupDownlevelPath(GetName());

        if (!pwzPath)
        {
            hr = E_FAIL;
            Dbg(DEB_WARN,
                "AdminCustomizer gave no path for %ws\n",
                GetName());
            break;
        }

        Variant var;

        hr = var.SetBstr(pwzPath);
        BREAK_ON_FAIL_HRESULT(hr);

        m_AttrValueMap[AK_PROCESSED_ADSPATH] = var;
        _SetFlag(DSO_FLAG_HAS_DOWNLEVEL_SID_PATH);
    } while (0);

    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_MultiMatchDialog
//
//  Synopsis:   Invoke the multi-match dialog so the user can select which
//              of the multiple hits from the prefix search of the name
//              they entered they want to keep.
//
//  Arguments:  [hwnd]         - parent window
//              [rop]          - containing object picker instance
//              [fMultiselect] - if FALSE user forced to pick only one match
//              [strName] -      string for which multiple matches were found.        
//              [pnpr]         - filled with result of processing
//              [pdsolMatches] - on input, contains all matches.  on output
//                                with hr==S_OK, contains exactly one.
//              [pdsolExtras]  - on output, matches 2..n have been appended.
//
//  Returns:    S_OK
//              E_*
//
//  Modifies:   *[pdsolMatches], *[pdsolExtras]
//
//  History:    08-18-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_MultiMatchDialog(
    HWND hwnd,
    const CObjectPicker &rop,
    BOOL fMultiselect,
    const String & strName,
    NAME_PROCESS_RESULT *pnpr,
    CDsObjectList *pdsolMatches,
    CDsObjectList *pdsolExtras)
{
    TRACE_METHOD(CDsObject, _MultiMatchDialog);
    ASSERT(IsUnprocessedUserEntry());

    CMultiDlg   MultiMatchDlg(rop, strName);

    HRESULT hr;

    hr = MultiMatchDlg.DoModalDialog(hwnd,
                                     fMultiselect,
                                     pnpr,
                                     pdsolMatches);

    if (FAILED(hr) || *pnpr != NPR_SUCCESS)
    {
        return hr;
    }

    ASSERT(!pdsolMatches->empty());

    if (pdsolMatches->size() > 1)
    {
        CDsObjectList::iterator start = pdsolMatches->begin();
        start++;

        pdsolExtras->splice(pdsolExtras->end(),
                            *pdsolMatches,
                            start,
                            pdsolMatches->end());
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_InitDisplayPath
//
//  Synopsis:   Return the canonical path to the container of this object.
//
//  Returns:    Pointer to display path string, L"" on failure.
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_InitDisplayPath() const
{
    HRESULT hr = S_OK;

    do
    {
        //
        // Certain custom objects may not have paths. Skip those.
        //

        if (GetAttr(AK_ADSPATH).Empty())
        {
            break;
        }

        //
        // Well-known security principals' display paths are blank, even
        // though they are real objects with valid ADsPaths.
        //

        if (!lstrcmpi(GetAttr(AK_OBJECT_CLASS).GetBstr(),
                      c_wzForeignPrincipalsClass))
        {
            break;
        }

        //
        // Need to construct a display path, start with the ads path.  Note
        // we don't want AK_PROCESSED_ADSPATH because that may be something
        // ugly like a SID path.
        //

        String strDisplayPath = GetAttr(AK_ADSPATH).GetBstr();

        BOOL fWinNTPath = !_wcsnicmp(strDisplayPath.c_str(),
                                    c_wzWinNTPrefix,
                                    ARRAYLEN(c_wzWinNTPrefix) - 1);

        //
        // If the path uses the WinNT provider, it is of the form
        // WinNT://domain/object or WinNT://domain/machine/object
        // which is displayed as "domain" or "machine".
        //

        if (fWinNTPath)
        {
            strDisplayPath.erase(0, ARRAYLEN(c_wzWinNTPrefix) - 1);

            // domain/object or domain/machine/object

            size_t idxSlash1 = strDisplayPath.find(L'/');

            ASSERT(idxSlash1 != String::npos);

            size_t idxSlash2 = strDisplayPath.find(L'/', idxSlash1 + 1);

            if (idxSlash2 == String::npos)
            {
                // domain/object

                strDisplayPath.erase(idxSlash1);

                // domain
            }
            else
            {
                // domain/machine/object

                strDisplayPath.erase(idxSlash2);

                // domain/machine

                strDisplayPath.erase(0, idxSlash1 + 1);

                // machine
            }
            m_AttrValueMap[AK_DISPLAY_PATH].SetBstr(strDisplayPath.c_str());
            break;
        }

        //
        // It's not a WinNT provider based path.  Convert container path
        // from 1779 to canonical, or a close approximation.  This is for
        // display only, it will never be passed to name translate.
        //

        CPathWrapLock   lock(g_pADsPath);

        hr = g_pADsPath->Set(strDisplayPath.c_str(), ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = g_pADsPath->RemoveLeafElement();
        BREAK_ON_FAIL_HRESULT(hr);

        long cElem;

        hr = g_pADsPath->GetNumElements(&cElem);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElem > 0);

        long i;
        strDisplayPath = L"";

        for (i = cElem - 1; i >= 0; i--)
        {
            Bstr bstrElem;

            hr = g_pADsPath->GetElement(i, &bstrElem);
            BREAK_ON_FAIL_HRESULT(hr);

            String strElem(bstrElem.c_str());
            strElem.replace(L"\\\\", L"\\");  // undo escaping

            size_t idxEqual = strElem.find(L'=', 0);

            ASSERT(idxEqual != String::npos);

            if (!cmpNoCase(strElem.substr(0, idxEqual).c_str(), L"DC"))
            {
                if (strDisplayPath.empty())
                {
                    strDisplayPath = strElem.substr(idxEqual + 1,
                                                    String::npos);
                }
                else
                {
                    strDisplayPath.insert(0, L".");
                    strDisplayPath.insert(0, strElem.substr(idxEqual + 1,
                                                            String::npos));
                }
            }
            else
            {
                ASSERT(!strDisplayPath.empty());

                strDisplayPath += L"/";
                strDisplayPath += strElem.substr(idxEqual + 1, String::npos);
            }
        }
        BREAK_ON_FAIL_HRESULT(hr);

        m_AttrValueMap[AK_DISPLAY_PATH].SetBstr(strDisplayPath.c_str());
    } while (0);

    if (FAILED(hr))
    {
        m_AttrValueMap[AK_DISPLAY_PATH].SetBstr(L"");
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetAttr
//
//  Synopsis:   Return attribute with name [strAdsiName].
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const Variant &
CDsObject::GetAttr(
    const String &strAdsiName,
    const CObjectPicker &rop) const
{
    return GetAttr(rop.GetAttributeManager().GetAttrKey(strAdsiName));
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetAttr
//
//  Synopsis:   Return attribute having key [ak].
//
//  Arguments:  [ak] - ATTR_KEY value representing attribute
//
//  Returns:    Reference to variant containing attribute, or to empty
//              variant if this doesn't contain the requested attribute.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const Variant &
CDsObject::GetAttr(
    ATTR_KEY ak) const
{
    AttrValueMap::const_iterator it;

    if (ak == AK_DISPLAY_PATH)
    {
        _InitDisplayPath();
    }

    it = m_AttrValueMap.find(ak);

    if (it == m_AttrValueMap.end())
    {
        return s_varEmpty;
    }

    return it->second;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetMarshalSize
//
//  Synopsis:   Get the size required to put this into a block of data for
//              a data object which is to be returned to caller.
//
//  Returns:    Size in bytes needed to marshal this (not counting fetched
//              attributes, which are stored separately).
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CDsObject::GetMarshalSize() const
{
    ULONG cch;

    BSTR bstrName = GetName();
    BSTR bstrADsPath = GetAttr(AK_PROCESSED_ADSPATH).GetBstr();
    if (!*bstrADsPath)
    {
       bstrADsPath = GetADsPath();
    }
    BSTR bstrClass = GetClass();
    BSTR bstrUpn = GetUpn();

    if (!lstrcmpi(bstrClass, c_wzLocalGroupClass) ||
        !lstrcmpi(bstrClass, c_wzGlobalGroupClass))
    {
        cch = lstrlen(bstrName) + 1 +
              lstrlen(c_wzGroupObjectClass) + 1 +
              lstrlen(bstrADsPath) + 1 +
              lstrlen(bstrUpn) + 1;
    }
    else
    {
        cch = lstrlen(bstrName) + 1 +
              lstrlen(bstrClass) + 1 +
              lstrlen(bstrADsPath) + 1 +
              lstrlen(bstrUpn) + 1;
    }

    return cch * sizeof(WCHAR);
}

PSID
CDsObject::GetSid() const
{
    AttrValueMap::iterator it;

    it = m_AttrValueMap.find(AK_OBJECT_SID);

    if (it == m_AttrValueMap.end())
    {
        return NULL;
    }

    Variant &rvar = it->second;

    return(getSidFromVariant(rvar));
}



void AddDollarToNameToCrack(IN DS_NAME_FORMAT FormatOffered,
                            String &strNameToCrack)
{
    if(FormatOffered == DS_USER_PRINCIPAL_NAME)
    {
        //
        //Find the rightmost @
        //
        size_t idxLastAt = strNameToCrack.rfind(L'@');   
        if (idxLastAt != String::npos)
        {
            strNameToCrack.insert(idxLastAt,L"$");
        }
    }
    else if(FormatOffered == DS_NT4_ACCOUNT_NAME)
    {
        strNameToCrack.append(L"$");
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   CrackName
//
//  Synopsis:   Given an object name, returns the DnsDomainName of the Domain in
//              which it resides. If bCrackInExtForest is true, tries to chase to
//              the "DS_NAME_ERROR_TRUST_REFERRAL" referral.
//  ARGUMENTS
//              [IN hwnd]       Handle to owning window
//              [IN pwzNameIn]  Name to crack           
//              [IN FormatOffered] Format of pwzNameIn. It can be DS_USER_PRINCIPAL_NAME,
//                                 DS_NT4_ACCOUNT_NAME, or DS_UNKNOWN_NAME
//              [IN pwzDomainName]  Domain Name from where to start crack
//              [IN bCrackInExtForest] If to follow the DS_NAME_ERROR_TRUST_REFERRAL
//              [in ppwzResultName]     Output dnsDomainName. This value can be Null
//                                      even if function returns S_OK if 
//                                      bCrackInExtForest is FALSE and object existin
//                                      other forest.
//              [pbExtForest]           True if object exist trusted forest
// Return Value:    S_OK if succeeds. Else DSCrackError or E_FAIL 
//-----------------------------------------------------------------------------
HRESULT
CrackName(IN HWND hwnd, 
          IN LPWSTR pwzNameIn,           
          IN DS_NAME_FORMAT FormatOffered,
          IN LPWSTR pwzDomainName,
          IN BOOL bCrackInExtForest,
          OUT LPWSTR * ppwzResultName, 
          OUT PBOOL pbExtForest,
          OUT PBOOL pbAddDollar)
{
    TRACE_FUNCTION(Entering CrackName);

    if(!pwzNameIn || 
        !pwzDomainName || 
        !ppwzResultName || 
        !pbExtForest || 
        !pbAddDollar)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    Dbg(DEB_TRACE,
        "Name to crack'%ws' Starting Domain '%ws' \n",
        pwzNameIn,
        pwzDomainName);

    HRESULT hr = S_OK;    
    HANDLE hDS = (HANDLE)-1;
    DWORD dwErr = 0;
    PDS_NAME_RESULTW pDsNameResult = NULL;
    BOOL fLoopAgain = FALSE; 
    DS_NAME_FORMAT FormatRequested = DS_CANONICAL_NAME;

    //
    //First Crack Name is at GC 
    //
    DWORD BindToDcFlag = OP_GC_SERVER_REQUIRED;

    //
    //Init strDomain. strDomain contains the domain name at which to try 
    //the next DsCrackName.
    //
    String strDomain = pwzDomainName;
    *pbExtForest = FALSE;

    String strNameToCrack = pwzNameIn;

    //
    //If CrackName at GC returns TRUST_REFERRAL and CrackName at referral returns
    //NO_MAPPING error try by adding a $ to the objectname.
    // NTRAID#NTBUG9-401249-2001/05/21-hiteshr
    //
    BOOL bTriedWithDollar = FALSE;
    *pbAddDollar = FALSE;
    
    do
    {
        //
        // Get a DC name for the domain and bind to it.
        //
        Dbg(DEB_TRACE,
            "Trying to do dsbind to '%ws' \n",
            strDomain.c_str());
        hr = g_pBinder->BindToDcInDomain(hwnd,
                                         strDomain.c_str(),
                                         BindToDcFlag,
                                         &hDS
                                         );
        BREAK_ON_FAIL_HRESULT(hr);

        // NTRAID#NTBUG9-615853-2002/06/17-lucios
        // We are no longer removing OP_GC_SERVER_REQUIRED from 
        // BindToDcFlag because we have to follow the referrals 
        // (if any) through the GC's

        //
        // Convert the object name.
        //
        Dbg(DEB_TRACE,
            "Calling DsCrackNamesW \n");
        LPCWSTR pwzNameToCrack = strNameToCrack.c_str();
        dwErr = DsCrackNamesW(hDS, 
                              DS_NAME_FLAG_TRUST_REFERRAL, 
                              FormatOffered,
                              FormatRequested, 
                              1, 
                              &pwzNameToCrack, 
                              &pDsNameResult);

        if(dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        ASSERT(pDsNameResult);
        ASSERT(pDsNameResult->cItems == 1);

        switch (pDsNameResult->rItems->status)
        {
            //
            // The object info is in another FOREST
            // Try dscrackname again
            //           
            case DS_NAME_ERROR_TRUST_REFERRAL:
            {
                Dbg(DEB_TRACE,
                    "DsCrackNamesW Status is DS_NAME_ERROR_TRUST_REFERRAL.\n DnsDomainname returned is '%ws'",
                    pDsNameResult->rItems->pDomain);

                if(bCrackInExtForest)
                {                
                    strDomain = pDsNameResult->rItems->pDomain;
                    fLoopAgain = TRUE;
                }
                else
                {
                //
                //if bCrackInExtForest is false, we don't try to crack and
                //*ppwzResultName is NULL. Return is S_OK.
                //
                    fLoopAgain = FALSE;
                }

                DsFreeNameResultW(pDsNameResult);
                pDsNameResult = NULL;                
                *pbExtForest = TRUE;
            }
            break;
            
            case DS_NAME_NO_ERROR:
            {
                //
                // Success!
                //
                Dbg(DEB_TRACE,
                "DsCrackNamesW Status is DS_NAME_NO_ERROR.\n DnsDomainname returned is '%ws'",
                pDsNameResult->rItems->pDomain);

                // NTRAID#NTBUG9-553761-2002/02/19-lucios. 
                hr = LocalAllocString(ppwzResultName,pDsNameResult->rItems->pDomain);
                if(FAILED(hr)) 
                {
                    DBG_OUT_HRESULT(hr);
                    goto Cleanup;
                }
                DsFreeNameResultW(pDsNameResult);
                pDsNameResult = NULL;
                fLoopAgain = FALSE;
                if(bTriedWithDollar)
                    *pbAddDollar = TRUE;
            }
            break;


            // NTRAID#NTBUG9-615853-2002/06/17-lucios
            // We are no longer accepting DsCrackNamesW's guess
            // about the domain based on the name only. If we always
            // hit the GC, we should get a match or the name is invalid
            case DS_NAME_ERROR_DOMAIN_ONLY:
            case DS_NAME_ERROR_RESOLVING:
            case DS_NAME_ERROR_NOT_FOUND:
            case DS_NAME_ERROR_NO_MAPPING:
            {

                if(*pbExtForest && !bTriedWithDollar)
                {
                    bTriedWithDollar = TRUE;
                    AddDollarToNameToCrack(FormatOffered, strNameToCrack);
                    Dbg(DEB_TRACE,"DsCrackNamesW Status failed with error: %x"
                        " .\n Trying to crack with $ sign added\n",
                        pDsNameResult->rItems->status);
                    fLoopAgain = TRUE;
                }
                else
                {
                    Dbg(DEB_TRACE,
                        "DsCrackNamesW Status failed with error %x.\n",
                        pDsNameResult->rItems->status);
                    if(!fLoopAgain)
                        hr = E_FAIL;
                    fLoopAgain = FALSE;
                }
            }
            break;

            default:
            {
                fLoopAgain = FALSE;
                hr = E_FAIL;
            }
            break;
        }

    }while (fLoopAgain);

Cleanup:

    if (pDsNameResult)
    {
        DsFreeNameResultW(pDsNameResult);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\errordlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       password.cxx
//
//  Contents:   Implementation of class used to prompt user for credentials.
//
//  Classes:    CMessageDlg
//
//  History:    06-28-1998   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Function:   PopupMessage
//
//  Synopsis:   Invoke a modal dialog to display a formatted message string.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [idsMessage]  - resource id of printf style format string
//              [...]         - arguments required for string
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void __cdecl
PopupMessage(
    HWND  hwndParent,
    ULONG idsMessage,
    ...)
{
    va_list valArgs;
    va_start(valArgs, idsMessage);

    CMessageDlg MessageDlg;

    MessageDlg.DoModalDialog(hwndParent,
                          NULL,
                          IDI_ERROR,
                          NULL,
                          0,
                          0,
                          idsMessage,
                          valArgs);
    va_end(valArgs);
}




//+--------------------------------------------------------------------------
//
//  Function:   PopupMessageEx
//
//  Synopsis:   Invoke a modal dialog to display a formatted message string.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [idIcon]      - resource identifier of system icon
//              [idsMessage]  - resource id of printf style format string
//              [...]         - arguments required for string
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void __cdecl
PopupMessageEx(
    HWND    hwndParent,
    PCWSTR idIcon,
    ULONG   idsMessage,
    ...)
{
    va_list valArgs;
    va_start(valArgs, idsMessage);

    CMessageDlg MessageDlg;

    MessageDlg.DoModalDialog(hwndParent,
                          NULL,
                          idIcon,
                          NULL,
                          0,
                          0,
                          idsMessage,
                          valArgs);
    va_end(valArgs);
}




//+--------------------------------------------------------------------------
//
//  Function:   PopupMessageAndCode
//
//  Synopsis:   Invoke a modal dialog to display a formatted message string
//              and error code.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [pwzFileName] - error code's file name
//              [ulLineNo]    - error code's line number
//              [hr]          - error code's HRESULT
//              [idsMessage]  - resource id of printf style format string
//              [...]         - arguments required for string
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void __cdecl
PopupMessageAndCode(
    HWND    hwndParent,
    PCWSTR pwzFileName,
    ULONG   ulLineNo,
    HRESULT hr,
    ULONG   idsMessage,
    ...)
{
    va_list valArgs;
    va_start(valArgs, idsMessage);

    CMessageDlg MessageDlg;

    MessageDlg.DoModalDialog(hwndParent,
                          NULL,
                          IDI_ERROR,
                          pwzFileName,
                          ulLineNo,
                          hr,
                          idsMessage,
                          valArgs);
    va_end(valArgs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CMessageDlg::DoModalDialog
//
//  Synopsis:   Invoke a modal dialog to display a message.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [hinstIcon]   - NULL or module handle where icon lives
//              [idIcon]      - resource identifier of icon to display
//              [pwzFile]     - error code's file name
//              [ulLine]      - error code's line number
//              [ulErrorCode] - error code's error value
//              [idsMessage]  - resource id of printf style format string
//              [valArgs]     - arguments required for string
//
//  Returns:    HRESULT
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMessageDlg::DoModalDialog(
    HWND        hwndParent,
    HINSTANCE   hinstIcon,
    PCWSTR      idIcon,
    PCWSTR      pwzFile,
    ULONG       ulLine,
    ULONG       ulErrorCode,
    ULONG       idsMessage,
    va_list     valArgs)
{
    TRACE_METHOD(CMessageDlg, DoModalDialog);
    ASSERT(idsMessage);

    m_hinstIcon = hinstIcon;
    m_idIcon = idIcon;

    if (pwzFile)
    {
        // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
        wsprintf(m_wzErrorCode, L"%ws %u %x", pwzFile, ulLine, ulErrorCode);
    }

    String strMessageFmt(String::load(static_cast<unsigned>(idsMessage)));

    PWSTR pwzTemp = NULL;

    ULONG ulResult;

    ulResult = FormatMessageW(FORMAT_MESSAGE_FROM_STRING
                              | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                              strMessageFmt.c_str(),
                              0,
                              0,
                              (LPWSTR) &pwzTemp,
                              0,
                              &valArgs);

    if (ulResult && pwzTemp)
    {
        m_strMessage = pwzTemp;
        LocalFree(pwzTemp);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    _DoModalDlg(hwndParent, IDD_ERROR);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMessageDlg::_OnInit
//
//  Synopsis:   Initialize dialog controls
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    06-28-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMessageDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CMessageDlg, _OnInit);

    //
    // Make prefix shut up
    //

    if (!_hCtrl(IDC_ERRORMSG) ||
        !_hCtrl(IDC_ERROR_CODE_LBL) ||
        !_hCtrl(IDOK) ||
        !_hCtrl(IDC_ERROR_CODE_EDIT))
    {
        return E_FAIL;
    }

    //
    // The error dialog has these components:
    //
    // 1. caption
    // 2. icon
    // 3. error message
    // 4. error code
    //
    // The last is optional.
    //

    //
    // Set up the caption.  Take this from the parent window.
    //

    WCHAR   wzCaption[MAX_PATH];

    //REVIEWED-2002-02-21-lucios.
    GetWindowText(GetParent(m_hwnd), wzCaption, ARRAYLEN(wzCaption));
    SetWindowText(m_hwnd, wzCaption);

    //
    // Set the icon.
    //

    HICON hIcon = LoadIcon(m_hinstIcon, m_idIcon);

    if (hIcon)
    {
        SendDlgItemMessage(m_hwnd,
                           IDC_POPUP_MSG_ICON,
                           STM_SETICON,
                           (WPARAM)hIcon,
                           0L);
    }

    //
    // Set the error message static
    //

    Static_SetText(_hCtrl(IDC_ERRORMSG), m_strMessage.c_str());

    //
    // If there is an error code string, set it, otherwise hide
    // the edit control and its label and resize the dialog to
    // eliminate the empty space.
    //

    if (*m_wzErrorCode)
    {
        Static_SetText(_hCtrl(IDC_ERROR_CODE_EDIT), m_wzErrorCode);
    }
    else
    {
        SafeEnableWindow(_hCtrl(IDC_ERROR_CODE_LBL), FALSE);
        SafeEnableWindow(_hCtrl(IDC_ERROR_CODE_EDIT), FALSE);
        ShowWindow(_hCtrl(IDC_ERROR_CODE_LBL), SW_HIDE);
        ShowWindow(_hCtrl(IDC_ERROR_CODE_EDIT), SW_HIDE);

        RECT rcClose;
        RECT rcEdit;

        _GetChildWindowRect(_hCtrl(IDOK), &rcClose);
        _GetChildWindowRect(_hCtrl(IDC_ERROR_CODE_EDIT), &rcEdit);

        //
        // Move the Close button up on top of the hidden edit control
        //

        SetWindowPos(_hCtrl(IDOK),
                     NULL,
                     rcClose.left,
                     rcEdit.top,
                     0,
                     0,
                     SWP_NOSIZE | SWP_NOZORDER);

        //
        // Shrink the dialog vertically by the amount the button was
        // moved up
        //

        LONG cyDelta = rcClose.top - rcEdit.top;
        ASSERT(cyDelta > 0);
        RECT rcDialog;

        GetWindowRect(m_hwnd, &rcDialog);

        SetWindowPos(m_hwnd,
                     NULL,
                     0,
                     0,
                     WindowRectWidth(rcDialog),
                     WindowRectHeight(rcDialog) - cyDelta,
                     SWP_NOMOVE | SWP_NOZORDER);
    }

    return S_OK;
}





//+--------------------------------------------------------------------------
//
//  Member:     CMessageDlg::_OnCommand
//
//  Synopsis:   Handle user input.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    06-28-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CMessageDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        EndDialog(m_hwnd, 0);
        break;
    case IDCANCEL:
        EndDialog(GetHwnd(), 0);
        break;

    default:
        fNotHandled = TRUE;
        break;
    }

    return fNotHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\filtermanager.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       FilterManager.cxx
//
//  Contents:   Definition of class to manage LDAP and WinNT filters
//
//  Classes:    CFilterManager
//
//  History:    02-24-2000   davidmun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


#define MAX_CLAUSES                 6
#define MAX_INSERT_STR              256


//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::CFilterManager
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning instance of object picker
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilterManager::CFilterManager(
    const CObjectPicker &rop):
        m_rop(rop),
        m_flCurFilterFlags(0),
        m_bLookForDirty(false)
{
    TRACE_CONSTRUCTOR(CFilterManager);

    //
    // CAUTION: do not reference scope manager here, it is not
    // initialized yet.
    //
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::~CFilterManager
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilterManager::~CFilterManager()
{
    TRACE_DESTRUCTOR(CFilterManager);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::HandleScopeChange
//
//  Synopsis:   Update the current filter flags as necessary to match the
//              new scope the user has just selected.
//
//  Arguments:  [hwnd] - for binding
//
//  History:    06-08-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::HandleScopeChange(
    HWND hwnd) const
{
    TRACE_METHOD(CFilterManager, HandleScopeChange);

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    ASSERT(m_flCurFilterFlags);
    ULONG flNewFilterFlags = 0;
    HRESULT hr = S_OK;
    if(m_rop.GetFilterManager().IsLookForDirty())
    {

        //
        // If we are changing TO the global catalog, and there is a joined
        // domain scope, the set of filter flags is the bitwise OR of the two.
        //
        hr = _GetSelectedFilterFlags(hwnd, rCurScope, &flNewFilterFlags);
        ASSERT(SUCCEEDED(hr));

        if (rCurScope.Type() == ST_GLOBAL_CATALOG)
        {
            const CLdapDomainScope *pJoinedScope =
                dynamic_cast<const CLdapDomainScope *>
                (&rsm.LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN));

            ASSERT(!pJoinedScope || pJoinedScope->Type() == ST_UPLEVEL_JOINED_DOMAIN);

            if (pJoinedScope)
            {
                ULONG flJoined;

                hr = _GetSelectedFilterFlags(hwnd, *pJoinedScope, &flJoined);
                ASSERT(SUCCEEDED(hr));
                flNewFilterFlags |= flJoined;
            }
        }

        if (!(flNewFilterFlags & ~DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
        {
            PopupMessageEx(hwnd,
                IDI_INFORMATION,
                IDS_NEW_SCOPE_CLASSES_0_INTERSECTION);

            //
            // Since scope change should only come about via Look In dialog,
            // and that will not allow selection of a scope for which the
            // flags cannot be obtained, and once obtained flags are always
            // successfully returned from a scope, this should work.
            //

            hr = rCurScope.GetResultantDefaultFilterFlags(hwnd, &flNewFilterFlags);
            ASSERT(SUCCEEDED(hr));
        }
    }
    else
        hr = rCurScope.GetResultantDefaultFilterFlags(hwnd, &flNewFilterFlags);

    m_flCurFilterFlags = flNewFilterFlags;

    ASSERT(m_flCurFilterFlags);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetSelectedFilterFlags
//
//  Synopsis:   Wrapper which returns the flags the user has selected that
//              apply to [Scope], or if none apply, the default filter
//              flags for [Scope].
//
//  Arguments:  [hwnd]     - for bind
//              [Scope]    - scope for which to return flags that user has
//                            selected via Look For dialog
//              [pulFlags] - filled with selected flags
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFilterManager::GetSelectedFilterFlags(
    HWND hwnd,
    const CScope &Scope,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CFilterManager, GetSelectedFilterFlags);
    ASSERT(pulFlags);
    if (!pulFlags)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    hr = _GetSelectedFilterFlags(hwnd, Scope, pulFlags);



    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    if (!*pulFlags)
    {
        hr = Scope.GetResultantDefaultFilterFlags(hwnd, pulFlags);
        CHECK_HRESULT(hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GetSelectedFilterFlags
//
//  Synopsis:   Fill *[pulFlags] with the subset of the DSOP_* filter flags
//              that the caller indicated apply to scopes of the type of
//              [Scope] has which the user has selected in the Look For
//              dialog.
//
//  Arguments:  [hwnd]     - for bind
//              [Scope]    - scope for which to return flags that user has
//                            selected via Look For dialog
//              [pulFlags] - filled with selected flags
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      This routine is complex because [Scope] is not necessarily
//              the current scope, and therefore the selections the user
//              has made in the look for dialog must be mapped from the
//              current scope to [Scope].
//
//---------------------------------------------------------------------------

HRESULT
CFilterManager::_GetSelectedFilterFlags(
    HWND hwnd,
    const CScope &Scope,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CFilterManager, GetSelectedFilterFlags);
    ASSERT(pulFlags);

    if (!pulFlags)
    {
        return E_POINTER;
    }

    ULONG ulNewResultantFilter;

    HRESULT hr = Scope.GetResultantFilterFlags(hwnd, &ulNewResultantFilter);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    ULONG ulOldSelectedFilter = m_flCurFilterFlags;

    //
    // Are we switching between uplevel and downlevel?
    //

    if ((ulOldSelectedFilter & DOWNLEVEL_FILTER_BIT) &&
        !(ulNewResultantFilter & DOWNLEVEL_FILTER_BIT))
    {
        //
        // Yes, previous scope was downlevel, new scope is uplevel.  Compose
        // an uplevel filter flag set which corresponds to the downlevel
        // filters selected for previous scope.
        //

        ULONG flNewFilterFlags = 0;

        if (IsDownlevelFlagSet(ulOldSelectedFilter, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & DSOP_FILTER_USERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & ALL_UPLEVEL_GROUP_FILTERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & DSOP_FILTER_COMPUTERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
        {
            flNewFilterFlags |= (ulNewResultantFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER);
        }

        //
        // If that leaves us with some intersection, use it.  Otherwise notify
        // user that we're switching to default for new scope.
        //

        if (flNewFilterFlags)
        {
            ulOldSelectedFilter = flNewFilterFlags;

            if (ulNewResultantFilter & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
            {
                ulOldSelectedFilter |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;
            }
        }
        else
        {
            ulOldSelectedFilter = 0;
        }
    }
    else if (!(ulOldSelectedFilter & DOWNLEVEL_FILTER_BIT) &&
             (ulNewResultantFilter & DOWNLEVEL_FILTER_BIT))
    {
        //
        // Yes, previous scope was uplevel, new scope is downlevel
        //

        ULONG flNewFilterFlags = 0;

        if (ulOldSelectedFilter & DSOP_FILTER_USERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & DSOP_DOWNLEVEL_FILTER_USERS;
        }

        if (ulOldSelectedFilter & ALL_UPLEVEL_GROUP_FILTERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & ALL_DOWNLEVEL_GROUP_FILTERS;

            if (IsDownlevelFlagSet(ulNewResultantFilter,
                                   DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
            {
                flNewFilterFlags |=
                    DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
            }
        }

        if (ulOldSelectedFilter & DSOP_FILTER_COMPUTERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & DSOP_DOWNLEVEL_FILTER_COMPUTERS;
        }

        if (ulOldSelectedFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
        }

        if (ulOldSelectedFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER)
        {
            flNewFilterFlags |= ulNewResultantFilter & DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
        }

        //
        // If that leaves us with some intersection of flags that generate
        // objects, use it.  Otherwise notify user that we're switching to
        // default for new scope.
        //
        // We mask off DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS because
        // the exclusion of downlevel groups doesn't generate objects.  Note
        // also that doing this masks off the DOWNLEVEL_FILTER_BIT, which we
        // want.
        //

        if (flNewFilterFlags & ~DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS)
        {
            ulOldSelectedFilter = flNewFilterFlags;
        }
        else
        {
            ulOldSelectedFilter = 0;
        }
    }
    else if (ulOldSelectedFilter & DOWNLEVEL_FILTER_BIT)
    {
        //
        // Nope, both previous and new scopes are downlevel.  If
        // any of the classes the user selected for the previous scope
        // are not available in the current scope, remove the unavailable
        // ones from the selection in ulOldSelectedFilter.
        //

        if (!IsDownlevelFlagSet(ulNewResultantFilter, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            ulOldSelectedFilter &= ~DSOP_DOWNLEVEL_FILTER_USERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_DOWNLEVEL_GROUP_FILTERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            ulOldSelectedFilter &= ~DSOP_DOWNLEVEL_FILTER_COMPUTERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
        {
            ulOldSelectedFilter &= ~DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
        }

        //
        // At this point if the bitflags for any classes of objects were turned
        // off in ulOldSelectedFilter, the downlevel filter bit has also been
        // turned off.  So if ulOldSelectedFilter has any flags in it that
        // will generate objects (DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS
        // doesn't) then we need to turn the DOWNLEVEL_FILTER_BIT back on.
        //

        if (ulOldSelectedFilter & ~DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS)
        {
            ulOldSelectedFilter |= DOWNLEVEL_FILTER_BIT;
        }
        else
        {
            ulOldSelectedFilter = 0;
        }
    }
    else
    {
        //
        // Both previous and new scopes are uplevel.
        //

        if (!(ulNewResultantFilter & DSOP_FILTER_USERS))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_USERS;
        }
        //
        //If New doesn't have any of ALL_UPLEVEL_GROUP_FILTERS
        //remove them from old
        //If new has any of ALL_UPLEVEL_GROUP_FILTERS and 
        //if old also has any of ALL_UPLEVEL_GROUP_FILTERS then
        //old should only have those which are present in new
        //BUG 202699
        if (!(ulNewResultantFilter & ALL_UPLEVEL_GROUP_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_UPLEVEL_GROUP_FILTERS;
        }
        else
        {
            if(ulOldSelectedFilter & ALL_UPLEVEL_GROUP_FILTERS)
            {
                ulOldSelectedFilter &= ~ALL_UPLEVEL_GROUP_FILTERS;
                ulOldSelectedFilter |= ulNewResultantFilter & ALL_UPLEVEL_GROUP_FILTERS;
            }
        }

        if (!(ulNewResultantFilter & DSOP_FILTER_COMPUTERS))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_COMPUTERS;
        }

        if (!(ulNewResultantFilter & DSOP_FILTER_CONTACTS))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_CONTACTS;
        }

        if (!(ulNewResultantFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
        }

        if (!(ulNewResultantFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_EXTERNAL_CUSTOMIZER;
        }

        if (!(ulOldSelectedFilter & ~DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
        {
            ulOldSelectedFilter = 0;
        }
    }

#if (DBG == 1)
    if (Scope.Type() == ST_TARGET_COMPUTER)
    {
        ASSERT(!IsDownlevelFlagSet(ulOldSelectedFilter,
                                   DSOP_DOWNLEVEL_FILTER_COMPUTERS));
    }

    if (Scope.Type() == ST_WORKGROUP)
    {
        ASSERT(!ulOldSelectedFilter ||
               ulOldSelectedFilter == DSOP_DOWNLEVEL_FILTER_COMPUTERS);
    }
#endif // (DBG == 1)

    *pulFlags = ulOldSelectedFilter;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetFilterDescription
//
//  Synopsis:   Return a string describing the filter for the current scope
//
//  Arguments:  [hwnd]   - for BindToObject
//              [Target] - FOR_LOOK_FOR or FOR_CAPTION
//
//  Returns:    String describing the filter
//
//  History:    05-10-2000   DavidMun   Created
//
//  Notes:      The version for the caption starts with "Select ".  It lists
//              all valid object types for the current scope, regardless of
//              which ones are checked in the Look For dialog, except that
//              it will not include "other objects" or "builtin security
//              principals" unless those are the only things valid for the
//              scope.
//
//              The version for the look for readonly edit control always
//              lists exactly what is checked in the Look For dialog,
//              including "other objects" and "builtin security principals".
//
//---------------------------------------------------------------------------

String
CFilterManager::GetFilterDescription(
    HWND hwnd,
    DESCR_FOR Target) const
{
    TRACE_METHOD(CFilterManager, GetFilterDescription);

    HRESULT hr = S_OK;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    ULONG   cInserts = 0;
    WCHAR   atszInserts[MAX_CLAUSES][MAX_INSERT_STR];
    ULONG   ulPlural = 0;

    if (!m_flCurFilterFlags)
    {
        hr = rCurScope.GetResultantDefaultFilterFlags(hwnd, &m_flCurFilterFlags);
        CHECK_HRESULT(hr);
    }

    ICustomizeDsBrowser *pExtCustomizer = m_rop.GetExternalCustomizer();
    if( (Target == FOR_CAPTION) && (pExtCustomizer!=NULL) )
    {
       IDsObjectPickerScope *pDsScope =
           const_cast<IDsObjectPickerScope *>
                (static_cast<const IDsObjectPickerScope *>(&rCurScope));

        PDSQUERYINFO pdsqi = NULL;
        HRESULT hrAux = pExtCustomizer->GetQueryInfoByScope(pDsScope, &pdsqi);
 
        if ( SUCCEEDED(hrAux) && pdsqi != NULL )
        {
            if ( (pdsqi->pwzCaption != NULL) )
            {
               String tempRet(pdsqi->pwzCaption);
               FreeQueryInfo(pdsqi);
               return tempRet;
            }
            FreeQueryInfo(pdsqi);
        }
    }

    ULONG flFilter;

    if (Target == FOR_LOOK_FOR)
    {
        flFilter = m_flCurFilterFlags;
    }
    else
    {
        hr = rCurScope.GetResultantFilterFlags(hwnd, &flFilter);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr) && rCurScope.Type() == ST_GLOBAL_CATALOG)
        {
            const CScope &rJoinedDomainScope =
                m_rop.GetScopeManager().LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN);

            if (!IsInvalid(rJoinedDomainScope))
            {
                ULONG flJoined;
                hr = rJoinedDomainScope.GetResultantFilterFlags(hwnd, &flJoined);
                CHECK_HRESULT(hr);
                flFilter |= flJoined;
            }
        }
    }

    if (!flFilter)
    {
        return L"";
    }

    //REVIEWED-2002-02-20-lucios.
    ZeroMemory(atszInserts, sizeof(atszInserts));

    if (m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT)
    {
        ulPlural = 1;
    }

    if (IsUplevel(rCurScope))
    {
        if (flFilter & DSOP_FILTER_USERS)
        {
            LoadStr(IDS_USER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (flFilter & DSOP_FILTER_CONTACTS)
        {
            LoadStr(IDS_CONTACT + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (flFilter & DSOP_FILTER_COMPUTERS)
        {
            LoadStr(IDS_COMPUTER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (flFilter & ALL_UPLEVEL_GROUP_FILTERS)
        {
            LoadStr(IDS_GROUP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (Target == FOR_LOOK_FOR || !cInserts)
        {
            if (flFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)
            {
                LoadStr(IDS_BUILTIN_WKSP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }

            if (m_rop.GetExternalCustomizer() &&
                (flFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
            {
                LoadStr(IDS_OTHER_OBJECT + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }
        }
    }
    else
    {
        if (IsDownlevelFlagSet(flFilter, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            LoadStr(IDS_USER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (IsDownlevelFlagSet(flFilter, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            LoadStr(IDS_COMPUTER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (IsDownlevelFlagSet(flFilter, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            LoadStr(IDS_GROUP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (Target == FOR_LOOK_FOR || !cInserts)
        {
            if (IsDownlevelFlagSet(flFilter, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
            {
                LoadStr(IDS_BUILTIN_WKSP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }

            if (m_rop.GetExternalCustomizer() &&
                IsDownlevelFlagSet(flFilter, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
            {
                LoadStr(IDS_OTHER_OBJECT + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }
        }
    }

    ASSERT(cInserts <= MAX_CLAUSES);

    String strDescription;

    if (cInserts)
    {
        int iBase;

        if (Target == FOR_LOOK_FOR)
        {
            iBase = IDS_FILTER_ONE;
        }
        else
        {
            iBase = IDS_SELECT_ONE;
        }

        int idsCaptionFmt = iBase + (cInserts - 1);
        strDescription = String::format(idsCaptionFmt,
                                        atszInserts[0],
                                        atszInserts[1],
                                        atszInserts[2],
                                        atszInserts[3],
                                        atszInserts[4],
                                        atszInserts[5]);
    }

    return strDescription;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetLdapFilter
//
//  Synopsis:   Return the LDAP filter which should be used to find objects
//              in scope [Scope].
//
//  Arguments:  [hwnd]  - for bind
//              [Scope] - scope for which to retrieve filter
//
//  Returns:    LDAP filter, or empty string on failure
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::GetLdapFilter(
    HWND hwnd,
    const CScope &Scope) const
{
    TRACE_METHOD(CFilterManager, GetLdapFilter);
    ASSERT(IsUplevel(Scope));

    //
    // If external customizer supplies a filter, use that
    //

    ICustomizeDsBrowser *pExtCustomizer = m_rop.GetExternalCustomizer();

    if (pExtCustomizer)
    {
        IDsObjectPickerScope *pDsScope =
            const_cast<IDsObjectPickerScope *>
                (static_cast<const IDsObjectPickerScope *>(&Scope));
        PDSQUERYINFO pdsqi = NULL;
        HRESULT hr = pExtCustomizer->GetQueryInfoByScope(pDsScope, &pdsqi);

        String strFilter;

        if (SUCCEEDED(hr) && pdsqi)
        {
            if (pdsqi->pwzLdapQuery)
            {
                strFilter = pdsqi->pwzLdapQuery;
            }
            FreeQueryInfo(pdsqi);
        }

        if (!strFilter.empty())
        {
            return strFilter;
        }
    }

    //Check if XForest Scope
    CScope *pScope = (CScope *)&Scope;
    if(pScope->GetType() == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
    {
        const CLdapDomainScope *pLdapScope = 
            dynamic_cast<const CLdapDomainScope*>(&Scope);

        if(pLdapScope->IsXForest())
        {
            ULONG ulNewResultantFilter;

            HRESULT hr = pScope->GetResultantFilterFlags(hwnd, &ulNewResultantFilter);
            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                return L"";
            }


            return _GenerateUplevelFilter(ulNewResultantFilter);
        }
    }


    //
    // External customizer couldn't supply filter; possibly not implemented.
    // Try to generate one ourselves.
    //

    if (Scope.Type() == ST_GLOBAL_CATALOG)
    {
        const CGcScope *pGcScope = dynamic_cast<const CGcScope *>(&Scope);

        if (pGcScope)
        {
            return _GenerateGcFilter(hwnd, *pGcScope);
        }
        return L"";
    }

    ULONG ulFlags;

    HRESULT hr = GetSelectedFilterFlags(hwnd, Scope, &ulFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return L"";
    }

    return _GenerateUplevelFilter(ulFlags);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GenerateGcFilter
//
//  Synopsis:   Create the LDAP filter which should be used against the
//              Global Catalog.
//
//  Arguments:  [hwnd]    - for bind
//              [GcScope] - scope object representing the GC
//
//  Returns:    LDAP filter, empty string on error.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateGcFilter(
    HWND hwnd,
    const CGcScope &GcScope) const
{
    TRACE_METHOD(CFilterManager, _GenerateGcFilter);
    ASSERT(GcScope.Type() == ST_GLOBAL_CATALOG);

    const CScopeManager &sm = m_rop.GetScopeManager();
    const CLdapDomainScope *pJoinedScope = dynamic_cast<const CLdapDomainScope *>
        (&sm.LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN));

    ASSERT(!pJoinedScope || pJoinedScope->Type() == ST_UPLEVEL_JOINED_DOMAIN);

    ULONG flSelectedGcFlags = 0;

    // NTRAID#NTBUG9-703460-2002/10/15-lucios
    // There is a long story in the bug
    HRESULT hr = _GetSelectedFilterFlags(hwnd, GcScope, &flSelectedGcFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return L"";
    }

    flSelectedGcFlags |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;

    //
    // If caller did not ask for joined domain, or if caller did but it
    // isn't in the scope list for some reason, just treat GC as any other
    // uplevel scope.
    //

    if (!pJoinedScope)
    {
        return _GenerateUplevelFilter(flSelectedGcFlags);
    }

    //
    // If joined domain and GC query are identical, then again the
    // GC scope is no different from any other uplevel scope.
    //
    // N.B.: using private version _GetSelectedFilterFlags here.  The
    // private version fills flSelectedJoinedFlags with the intersection
    // of the classes of objects the user checked in the Look For dialog and
    // the allowed classes in the joined domain scope.
    //
    // This intersection may be 0.  The public version of the API would then
    // set flSelectedJoinedFlags to the default flags for the scope.
    //
    // We don't want the public api's behavior here.  Assume the GC scope
    // allows computers and groups, and the joined domain allows groups. If
    // the only selected class in Look For is computers, we don't want to
    // get back the default of groups for the joined domain, since that would
    // cause us to generate a combined filter for computers and groups.
    //
    // Instead we get back a 0 for the joined domain and ignore it, simply
    // generating a filter for computers.
    //

    ULONG flSelectedJoinedFlags;

    hr = _GetSelectedFilterFlags(hwnd, *pJoinedScope, &flSelectedJoinedFlags);

    // Either can be 0 but not both since the Object Types dialog's OK
    // is only enabled with some type selected and it shows a merge
    // of the joined domain types and GC types if GC is selected.
    ASSERT(flSelectedJoinedFlags || flSelectedGcFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return L"";
    }

    flSelectedJoinedFlags |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;

    //
    // The builtin group and well known principal flags don't have any
    // affect on the LDAP filters, since they represent objects which are
    // added in by AddObjects.  So strip those flags out before comparing
    // joined and GC flags.
    //

    ULONG flSelectedJoinedLessAddons = flSelectedJoinedFlags &
        ~(DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS);

    ULONG flSelectedGcLessAddons = flSelectedGcFlags &
        ~(DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS);

    //
    // If the joined domain now has nothing to contribute to the GC query,
    // ignore it.
    //

    if (!(flSelectedJoinedLessAddons & ~DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
    {
        return _GenerateUplevelFilter(flSelectedGcFlags);
    }

    //
    // If the flags remaining for the GC and joined domain are the same,
    // then we can generate just the GC filter.
    //

    if (flSelectedJoinedLessAddons == flSelectedGcLessAddons)
    {
        return _GenerateUplevelFilter(flSelectedGcFlags);
    }

    //
    // The GC and Joined Domain flags are different, but if the contacts
    // clause is filtered out, they still might amount to the same thing.
    //

    String strJoinedFilter;
    String strGcFilter;

    BOOL fFactorContact = FALSE;

    if (flSelectedJoinedFlags & DSOP_FILTER_CONTACTS)
    {
        ASSERT(flSelectedGcFlags & DSOP_FILTER_CONTACTS);
        fFactorContact = TRUE;
    }
    else
    {
        ASSERT(!(flSelectedGcFlags & DSOP_FILTER_CONTACTS));
    }

    if (fFactorContact)
    {
        ULONG flFactoredJoined;
        ULONG flFactoredGc;

        flFactoredJoined = flSelectedJoinedFlags & ~DSOP_FILTER_CONTACTS;
        flFactoredGc = flSelectedGcFlags & ~DSOP_FILTER_CONTACTS;

        strJoinedFilter = _GenerateUplevelFilter(flFactoredJoined);

        //
        // If, because of factoring, the joined domain filter is empty,
        // just use GC filter
        //

        if (strJoinedFilter.empty())
        {
            return _GenerateUplevelFilter(flSelectedGcFlags);
        }

        //
        // The factored joined filter is NOT empty.  Generated the
        // factored GC filter.  This may be empty; if it is the caller is
        // forcing us to do a search on the GC for joined domain only objects.
        //
        // If so, emit a warning, because it would be much more efficient for
        // the caller to simply not include the GC scope, and have the user
        // go to the joined domain to query the joined domain.
        //

        strGcFilter = _GenerateUplevelFilter(flFactoredGc);

        if (strGcFilter.empty())
        {
            Dbg(DEB_WARN,
                "Warning: caller forcing joined domain only query of GC, this is inefficient\n");
        }
    }
    else
    {
        //
        // Don't have to factor out contact clause, so just use the stock
        // queries.
        //

        strJoinedFilter = _GenerateUplevelFilter(flSelectedJoinedFlags);
        strGcFilter = _GenerateUplevelFilter(flSelectedGcFlags);
    }


    //
    // At this point strJoinedFilter and strGcFilter differ.  The joined
    // filter is nonempty and must be anded with a clause that restricts it
    // to objects in the GC that have a SID associated with the joined domain.
    //
    // The GC filter may or may not be empty.
    //

    String strCombinedFilter;

    do
    {
        //
        // Now combine the two to create a single ldap filter which returns
        // only the correct objects from the joined domain and the both+
        // native mode objects from all other domains in the enterprise.
        //
        // They're combined using the domain sid of the joined domain.
        //

        RpIADs rpADs;
        Variant varSid;
        String strADsPath;

        hr = pJoinedScope->GetADsPath(hwnd, &strADsPath);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "Scope '%ws' has no path, returning\n",
                pJoinedScope->GetDisplayName());
            break;
        }

        hr = g_pBinder->BindToObject(hwnd,
                                     strADsPath.c_str(),
                                     IID_IADs,
                                     (void**)&rpADs);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = rpADs->Get(AutoBstr(c_wzObjectSidAttr), &varSid);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // _GenerateCombinedGcFilter handles the case where strGcFilter is
        // empty.
        //

        strCombinedFilter = _GenerateCombinedGcFilter(&varSid,
                                                      strJoinedFilter,
                                                      strGcFilter);

        //
        // If there are no factored clauses to wrap the query with,
        // we're done.
        //

        if (!fFactorContact)
        {
            break;
        }

        String strFactoringPrefix;

        if (fFactorContact)
        {
            strFactoringPrefix += L"(|";
            strFactoringPrefix += c_wzContactQuery;
        }

        strCombinedFilter.insert(0, strFactoringPrefix);

        if (fFactorContact)
        {
            strCombinedFilter += L")";
        }
    } while (0);

    return strCombinedFilter;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GenerateCombinedGcFilter
//
//  Synopsis:   Generate an LDAP filter which combines the filters of the
//              Global Catalog and the joined domain scopes.
//
//  Arguments:  [pvarDomainSid]   - SID of joined domain
//              [strJoinedFilter] - LDAP filter of joined domain
//              [strGcFilter]     - LDAP filter of GC
//
//  Returns:    Combined LDAP filter
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateCombinedGcFilter(
    VARIANT *pvarDomainSid,
    const String &strJoinedFilter,
    const String &strGcFilter) const
{
    TRACE_METHOD(CFilterManager, _GenerateCombinedGcFilter);

    String strResultFilter;

    do
    {
        CSid    sidDomain(pvarDomainSid);

        const String strFirstRid(L"\\00\\00\\00\\00");
        const String strLastRid(L"\\ff\\ff\\ff\\ff");

        String strFirstDomainSid =
                    sidDomain.GetSidAndRidAsByteStr(strFirstRid);

        String strLastDomainSid =
                    sidDomain.GetSidAndRidAsByteStr(strLastRid);

        String strSidInRange =
                    L"(&"
                     L"(objectSid>=" + strFirstDomainSid + L")" +
                     L"(objectSid<=" + strLastDomainSid  + L")" +
                    L")";

        if (!strGcFilter.empty())
        {
            //
            // (|
            //  (&
            //   (joined domain query)
            //   (objectSid in joined domain sid range)
            //  )
            //  (&
            //   (GC query)
            //   (objectSid below joined domain sid range)
            //  )
            //  (&
            //   (GC query)
            //   (objectSid above joined domain sid range)
            //  )
            // )
            //

            CSid sidBelow = sidDomain;

            sidBelow.Decrement();

            String strLastDomainSidBelow =
                        sidBelow.GetSidAndRidAsByteStr(strLastRid);

            String strSidBelowRange =
                        L"(objectSid<=" + strLastDomainSidBelow + L")";

            CSid sidAbove = sidDomain;

            sidAbove.Increment();

            String strFirstDomainSidAbove =
                        sidAbove.GetSidAndRidAsByteStr(strFirstRid);

            String strSidAboveRange =
                        L"(objectSid>=" + strFirstDomainSidAbove + L")";

            strResultFilter = L"(|"
                               L"(&" +
                                  strJoinedFilter +
                                  strSidInRange +
                               L")"
                               L"(&" +
                                  strGcFilter +
                                  strSidBelowRange +
                               L")"
                               L"(&" +
                                  strGcFilter +
                                  strSidAboveRange +
                               L")"
                              L")";
        }
        else
        {
            //
            // (&
            //  (joined domain query)
            //  (objectSid in joined domain sid range)
            // )
            //


            strResultFilter = L"(&" +
                                 strJoinedFilter +
                                 strSidInRange +
                              L")";
        }
    }
    while (0);

    return strResultFilter;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GenerateUplevelFilter
//
//  Synopsis:   Return an LDAP filter for the DSOP_FILTER_* bits set in
//              [flFilter].
//
//  Arguments:  [flFilter] - DSOP_FILTER_* bits
//
//  Returns:    LDAP filter
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateUplevelFilter(
    ULONG flFilter) const
{
    TRACE_METHOD(CFilterManager, _GenerateUplevelFilter);

    String  strQuery;
    ULONG   cOuterTerms = 0;

    strQuery = _GenerateUplevelGroupFilter(flFilter);


    if (!strQuery.empty())
    {
        cOuterTerms++;
    }

    if (flFilter & DSOP_FILTER_USERS)
    {
        strQuery += c_wzUserQuery;
        cOuterTerms++;

        if (cOuterTerms > 1)
        {
            strQuery.insert(0, L"(|");
            strQuery += L")";
            cOuterTerms = 1;
        }
    }

    if (flFilter & DSOP_FILTER_CONTACTS)
    {
        strQuery += c_wzContactQuery;
        cOuterTerms++;

        if (cOuterTerms > 1)
        {
            strQuery.insert(0, L"(|");
            strQuery += L")";
            cOuterTerms = 1;
        }
    }

    if (flFilter & DSOP_FILTER_COMPUTERS)
    {
        strQuery += c_wzComputerQuery;
        cOuterTerms++;

        if (cOuterTerms > 1)
        {
            strQuery.insert(0, L"(|");
            strQuery += L")";
            cOuterTerms = 1;
        }
    }

    ASSERT(cOuterTerms == 0 || cOuterTerms == 1);

    if (cOuterTerms && !(flFilter & DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
    {
        strQuery.insert(0, c_wzNotShowInAdvancedViewOnly);
        strQuery.insert(0, L"(&");
        strQuery += L")";
    }

    return strQuery;
}




//+--------------------------------------------------------------------------
//
//  Function:   _GenerateUplevelGroupFilter
//
//  Synopsis:   Fill *[ppwzGroupQuery] with a new allocated string containing
//              a query representing the flags in [ulFlags].
//
//  Arguments:  [ulFlags]   - UGOP_*_GROUPS and UGOP_*_GROUPS_SE
//              [pstrQuery] - filled with group query
//
//  Modifies:   *[pstrQuery]
//
//  History:    05-29-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateUplevelGroupFilter(
    ULONG ulFlags) const
{
    TRACE_METHOD(CFilterManager, _GenerateUplevelGroupFilter);

    ULONG flSecurityGroups = ulFlags & DSOP_ALL_UPLEVEL_SECURITY_GROUPS;
    ULONG flDistributionGroups = ulFlags & DSOP_ALL_UPLEVEL_DISTRIBUTION_GROUPS;

    ULONG flGroupType1 = 0;
    ULONG flGroupType2 = 0;
    PCWSTR pwzClauseFmt1 = NULL;
    PCWSTR pwzClauseFmt2 = NULL;
    String strQuery;

    do
    {
        if (!flSecurityGroups && !flDistributionGroups)
        {
            break;
        }

        if (flDistributionGroups == flSecurityGroups >> 1)
        {
            flGroupType1 = _FlagsToGroupTypeBits(flDistributionGroups);
            pwzClauseFmt1 = c_wzGroupBoth;
        }
        else if (!flDistributionGroups)
        {
            flGroupType1 = _FlagsToGroupTypeBits(flSecurityGroups);
            pwzClauseFmt1 = c_wzGroupSE;
        }
        else if (!flSecurityGroups)
        {
            flGroupType1 = _FlagsToGroupTypeBits(flDistributionGroups);
            pwzClauseFmt1 = c_wzGroupNonSE;
        }
        else
        {
            flGroupType1 = _FlagsToGroupTypeBits(flDistributionGroups);
            pwzClauseFmt1 = c_wzGroupNonSE;

            flGroupType2 = _FlagsToGroupTypeBits(flSecurityGroups);
            pwzClauseFmt2 = c_wzGroupSE;
        }

        ASSERT(pwzClauseFmt1);

        WCHAR wzGroupType1Bits[20];
        // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
        wsprintf(wzGroupType1Bits, L"%u", flGroupType1);

        String strInsert1(String::format(pwzClauseFmt1, wzGroupType1Bits));

        if (pwzClauseFmt2)
        {
            WCHAR wzGroupType2Bits[20];
            // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
            wsprintf(wzGroupType2Bits, L"%u", flGroupType2);

            String strInsert2(String::format(pwzClauseFmt2, wzGroupType2Bits));

            strQuery = L"(|";
            strQuery += strInsert1;
            strQuery += strInsert2;
            strQuery += L")";
        }
        else
        {
            strQuery = strInsert1;
        }
    } while (0);

    return strQuery;
}




//+--------------------------------------------------------------------------
//
//  Function:   _FlagsToGroupTypeBits
//
//  Synopsis:   Convert object picker bitflags for the six flavors of uplevel
//              group to ntsam flags for the corresponding groups, thus
//              folding security enabled and non security enabled together.
//
//  Arguments:  [ulGroups] - UGOP_GROUPS*
//
//  Returns:    GROUP_TYPE_*_GROUP bitflags
//
//  History:    05-29-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CFilterManager::_FlagsToGroupTypeBits(
    ULONG ulGroups) const
{
    ULONG   flGroupBits = 0;

    if (ulGroups & (DSOP_FILTER_UNIVERSAL_GROUPS_DL | DSOP_FILTER_UNIVERSAL_GROUPS_SE))
    {
        flGroupBits |= GROUP_TYPE_UNIVERSAL_GROUP;
    }

    if (ulGroups & (DSOP_FILTER_GLOBAL_GROUPS_DL | DSOP_FILTER_GLOBAL_GROUPS_SE))
    {
        flGroupBits |= GROUP_TYPE_ACCOUNT_GROUP;
    }

    if (ulGroups & (DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE))
    {
        flGroupBits |= GROUP_TYPE_RESOURCE_GROUP;
    }

    ASSERT(flGroupBits);

    return flGroupBits;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetWinNtFilter
//
//  Synopsis:   Fill vector pointed to by [pvs] with the class strings to
//              pass to ADsBuildVarArrayStr (see CQueryEngine).
//
//  Arguments:  [hwnd]  - for bind
//              [Scope] - downlevel scope for which to return classes to
//                          enumerate
//              [pvs]   - points to vector which is cleared and filled
//                          with class names.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::GetWinNtFilter(
    HWND hwnd,
    const CScope &Scope,
    vector<String> *pvs) const
{
    TRACE_METHOD(CFilterManager, GetWinNtFilter);
    ASSERT(pvs);

    pvs->clear();

    if (!IsDownlevel(Scope))
    {
        return;
    }

    ULONG flFilter;
    HRESULT hr = GetSelectedFilterFlags(hwnd, Scope, &flFilter);
    CHECK_HRESULT(hr);

    if (FAILED(hr) || !flFilter)
    {
        return;
    }

    ASSERT(flFilter & DOWNLEVEL_FILTER_BIT);

    if ((flFilter & DSOP_DOWNLEVEL_FILTER_USERS) ==
        DSOP_DOWNLEVEL_FILTER_USERS)
    {
        pvs->push_back(c_wzUserObjectClass);
    }

    if ((flFilter & DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS) ==
        DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS ||
        (flFilter & DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS) ==
        DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS)
    {
        pvs->push_back(c_wzGroupObjectClass);
    }

    if ((flFilter & DSOP_DOWNLEVEL_FILTER_COMPUTERS) ==
        DSOP_DOWNLEVEL_FILTER_COMPUTERS)
    {
        pvs->push_back(c_wzComputerObjectClass);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::DoLookForDialog
//
//  Synopsis:   Invoke the modal Look For dialog
//
//  Arguments:  [hwndParent] - parent of modal dialog
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::DoLookForDialog(
    HWND hwndParent) const
{
    TRACE_METHOD(CFilterManager, DoLookForDialog);

    CLookForDlg  LookForDlg(m_rop);

    ASSERT(m_flCurFilterFlags);
    LookForDlg.DoModalDlg(hwndParent, m_flCurFilterFlags);

    m_flCurFilterFlags = LookForDlg.GetSelectedFlags();
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::Clear
//
//  Synopsis:   Reset internal state.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::Clear()
{
    TRACE_METHOD(CFilterManager, Clear);
    m_flCurFilterFlags = 0;
    m_bLookForDirty = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\downlvl.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       downlvl.cxx
//
//  Contents:   Functions which return information about domains when
//              uplevel (Windows 2000 or later) APIs are not available
//              (i.e. when joined to an NT4 domain or in a workgroup).
//
//  Functions:  GetLsaAccountDomainInfo
//              GetDomainSid
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Function:   GetLsaAccountDomainInfo
//
//  Synopsis:   Use LSA APIs to fill *[ppAccountDomainInfo].
//
//  Arguments:  [pwzServerName]       - target computer
//              [phlsaServer]         - filled with handle returned by
//                                       LsaOpenPolicy
//              [ppAccountDomainInfo] - filled with domain info returned
//                                       by LsaQueryInformationPolicy.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
GetLsaAccountDomainInfo(
    PCWSTR pwzServerName,
    PLSA_HANDLE  phlsaServer,
    PPOLICY_ACCOUNT_DOMAIN_INFO *ppAccountDomainInfo)

{
    TRACE_FUNCTION(GetLsaAccountDomainInfo);

    HRESULT                     hr = S_OK;
    NTSTATUS                    nts = ERROR_SUCCESS;
    LSA_OBJECT_ATTRIBUTES       oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    BOOL                        fOk;

    do
    {
        //
        // Open the lsa policy object on the target server
        //

        ZeroMemory(&sqos, sizeof sqos);
        sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        ZeroMemory(&oa, sizeof oa);
        oa.Length = sizeof oa;
        oa.SecurityQualityOfService = &sqos;

        UNICODE_STRING uszServerName;

        if (pwzServerName)
        {
            fOk = RtlCreateUnicodeString(&uszServerName, pwzServerName);

            if (!fOk)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }
        }

        nts = LsaOpenPolicy(pwzServerName ? &uszServerName : NULL,
                            &oa,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            phlsaServer);

        if (pwzServerName)
        {
            RtlFreeUnicodeString(&uszServerName);
        }
        BREAK_ON_FAIL_NTSTATUS(nts);

        //
        // Get the domain information for the passed-in server
        //

        nts = LsaQueryInformationPolicy(*phlsaServer,
                                        PolicyAccountDomainInformation,
                                        (LPVOID *)ppAccountDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);
    } while (0);

    if (NT_ERROR(nts))
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetDomainSid
//
//  Synopsis:   Get the SID of domain with name [pwzDomainName].
//
//  Arguments:  [pwzDomainName] - name of domain for which to retrieve SID
//              [ppSid]         - filled with pointer to domain's SID
//              [ppwzDC]        - if non-NULL, filled with name of DC for
//                                 domain [pwzDomainName].
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
GetDomainSid(
    PWSTR pwzDomainName,
    PSID *ppSid,
    PWSTR *ppwzDC)
{
    Dbg(DEB_TRACE, "GetDomainSid('%ws')\n", pwzDomainName);

    HRESULT hr;
    ULONG ulResult;
    PWSTR pwzPDC = NULL;
    NTSTATUS nts;
    LSA_HANDLE                  hlsaServer = NULL;
    POLICY_ACCOUNT_DOMAIN_INFO *pAccountDomainInfo = NULL;
    SECURITY_QUALITY_OF_SERVICE sqos;
    LSA_OBJECT_ATTRIBUTES       oa;
    BOOL                        fOk;

    do
    {
        //
        // First find a DC in the domain
        //

        ulResult = NetGetDCName(NULL, pwzDomainName, (LPBYTE *) &pwzPDC);

        if (ulResult != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            Dbg(DEB_ERROR, "GetDomainSid: NetGetDCName err=%uL\n", ulResult);
            break;
        }

        Dbg(DEB_TRACE,
            "GetDomainSid: DC of domain '%ws' is '%ws'\n",
            pwzDomainName,
            pwzPDC);

        PWSTR pwzDCname = pwzPDC + 2;

        if (ppwzDC)
        {
            *ppwzDC = new WCHAR[lstrlen(pwzDCname) + 1];

            if (!*ppwzDC)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }

            //REVIEWED-2002-02-20-lucios. *ppwzDC was recently allocated.
            lstrcpy(*ppwzDC, pwzDCname);
        }

        hr = GetLsaAccountDomainInfo(pwzDCname,
                                     &hlsaServer,
                                     &pAccountDomainInfo);

        //
        // Open the lsa policy object on the DC
        //
        
        //REVIEWED-2002-02-20-lucios.
        ZeroMemory(&sqos, sizeof sqos);
        sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        //REVIEWED-2002-02-20-lucios.
        ZeroMemory(&oa, sizeof oa);
        oa.Length = sizeof oa;
        oa.SecurityQualityOfService = &sqos;

        //
        // Get a handle to lsa policy for queries about domains
        //

        UNICODE_STRING uszServerName;

        fOk = RtlCreateUnicodeString(&uszServerName, pwzDCname);

        if (!fOk)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        nts = LsaOpenPolicy(&uszServerName,
                            &oa,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &hlsaServer);
        RtlFreeUnicodeString(&uszServerName);
        BREAK_ON_FAIL_NTSTATUS(nts);

        //
        // Get the SID for the domain
        //

        nts = LsaQueryInformationPolicy(hlsaServer,
                                        PolicyAccountDomainInformation,
                                        (LPVOID *)&pAccountDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);

        if (pAccountDomainInfo && pAccountDomainInfo->DomainSid)
        {
            ULONG cbSid = GetLengthSid(pAccountDomainInfo->DomainSid);
            ASSERT(cbSid);

            *ppSid = (PSID) new BYTE[cbSid];

            if (!*ppSid)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }
            //REVIEWED-2002-02-20-lucios.
            CopyMemory(*ppSid, pAccountDomainInfo->DomainSid, cbSid);
        }
        else
        {
            hr = E_FAIL;
            Dbg(DEB_ERROR,
                "GetDomainSid: couldn't obtain sid for domain '%ws'\n",
                pwzDomainName);
        }
    } while (0);

    //
    // Release resources
    //

    if (hlsaServer)
    {
        LsaClose(hlsaServer);
    }

    if (pwzPDC)
    {
        NetApiBufferFree(pwzPDC);
    }

    if (pAccountDomainInfo)
    {
        LsaFreeMemory(pAccountDomainInfo);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\globals.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       globals.cxx
//
//  Contents:   Globals used by multiple modules
//
//  History:    06-26-1997  MarkBl  Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

ULONG CDll::s_cObjs;
ULONG CDll::s_cLocks;

#if (DBG == 1)
ULONG CDbg::s_idxTls;
#endif // (DBG == 1)


HINSTANCE               g_hinst = 0;
CBinder                *g_pBinder = NULL;
CADsPathWrapper        *g_pADsPath = NULL;
CRITICAL_SECTION        g_csGlobalVarsCreation;
WCHAR                   g_wzColumn1Format[40];
ADS_SEARCHPREF_INFO     g_aSearchPrefs[NUM_SEARCH_PREF];
ULONG                   g_cQueryLimit;
BOOL                    g_fExcludeDisabled;
HINSTANCE               g_hinstRichEdit;

// Globals required by burnslib
HINSTANCE hResourceModuleHandle;
const wchar_t* RUNTIME_NAME = L"ObjectPicker";
DWORD DEFAULT_LOGGING_OPTIONS = OUTPUT_TYPICAL;

DEBUG_DECLARE_INSTANCE_COUNTER(RefCountPointer)

#include <initguid.h>
#include <cmnquery.h>
#include <dsquery.h>
#include <dsclient.h>

#include "objselp.h"
#include <objsel.h>





//+--------------------------------------------------------------------------
//
//  Function:   InitGlobals
//
//  Synopsis:   Initialize global variables during DLL initialization
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
InitGlobals()
{
    // DllMain already set g_hinst
    hResourceModuleHandle = g_hinst;

    LoadStr(IDS_COL1FORMAT,
            g_wzColumn1Format,
            ARRAYLEN(g_wzColumn1Format),
            L"%1 (%2)");

    GetPolicySettings(&g_cQueryLimit, &g_fExcludeDisabled);

    //
    // Set a page size so we'll get all objects even if there are
    // more than 1000.
    //

    g_aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    g_aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[0].vValue.Integer = DIR_SEARCH_PAGE_SIZE;

    //
    // Always follow aliases
    //

    g_aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
    g_aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[1].vValue.Integer = ADS_DEREF_ALWAYS;

    //
    // Search down the subtree
    //

    g_aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    g_aSearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[2].vValue.Integer = ADS_SCOPE_SUBTREE;

    //
    // Turn off client side caching of results, since we do that for the
    // virtual listview anyway.
    //

    g_aSearchPrefs[3].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    g_aSearchPrefs[3].vValue.dwType = ADSTYPE_BOOLEAN;
    g_aSearchPrefs[3].vValue.Integer = 0;

    //
    // Limit time spent on each page so that call (hopefully) doesn't
    // block for too long.
    //

    g_aSearchPrefs[4].dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
    g_aSearchPrefs[4].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[4].vValue.Integer = DIR_SEARCH_PAGE_TIME_LIMIT;

    ASSERT(!g_hinstRichEdit);
    // NTRAID#NTBUG9-550559-2002/02/20-lucios. Pending fix.
    g_hinstRichEdit = LoadLibrary(L"riched32.dll");
}



//+--------------------------------------------------------------------------
//
//  Function:   FreeGlobals
//
//  Synopsis:   Free resources held in global variables during DLL shutdown.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
FreeGlobals()
{
    TRACE_FUNCTION(FreeGlobals);

    if (g_hinstRichEdit)
    {
        VERIFY(FreeLibrary(g_hinstRichEdit));
        g_hinstRichEdit = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\helpids.h ===
//Object Selection dialog box

#define IDH_LOOK_FOR_LV                         322
#define IDH_LOOK_IN_TV                          323
#define IDH_ADD_BTN                             324
#define IDH_ADVANCED_PB                         325
#define IDH_CHECK_NAMES_PB                      326
#define IDH_CLAUSE_LIST                         327
#define IDH_COLUMNS_PB                          328
#define IDH_DESCRIPTION_COMBO                   329
#define IDH_DESCRIPTION_EDIT                    330
#define IDH_DISABLED_CKBOX                      331
#define IDH_EDIT_BTN                            332
#define IDH_FIND_NOW_PB                         333
#define IDH_INSTRUCTION_LBL                     334
#define IDH_LASTLOGON_COMBO                     335
#define IDH_LOOK_FOR_EDIT                       336
#define IDH_LOOK_FOR_PB                         337
#define IDH_LOOK_IN_EDIT                        338
#define IDH_LOOK_IN_PB                          339
#define IDH_NAME_COMBO                          340
#define IDH_NAME_EDIT                           341
#define IDH_NAME_LBL                            342
#define IDH_NON_EXPIRING_CKBOX                  343
#define IDH_QUERY_LISTVIEW                      344
#define IDH_REMOVE_BTN                          345
#define IDH_RICHEDIT                            346
#define IDH_STOP_PB                             347
#define IDH_AVAILABLE_LIST                      348
#define IDH_ADD_COL_BTN                         349
#define IDH_REMOVE_COL_BTN                      350
#define IDH_SHOWN_LIST                          351
#define IDH_LASTLOGON_LBL                       352
#define IDH_DESCRIPTION_LBL                     353    
#define IDH_NAME_LBL1                            354
#define IDH_MATCHING_LIST                       1180
#define IDH_CORRECT_RADIO                       1150
#define IDH_CORRECT_EDIT                        1160
#define IDH_REMOVE_RADIO                        1170
#define IDH_NETPASS_CONNECTAS                   1110  // edit control and connect as static
#define IDH_NETPASS_PASSWORD                    1120
#define IDH_NETPASS_OK                          1130
#define IDH_NETPASS_CANCEL                      1140
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\imperson.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       imperson.cxx
//
//  Contents:   Class to make current thread impersonate Anonymous.
//
//  Classes:    CImpersonateAnon
//
//  History:    09-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop




//+--------------------------------------------------------------------------
//
//  Member:     CImpersonateAnon::CImpersonateAnon
//
//  Synopsis:   Start impersonating Anonymous on the current thread.
//
//  History:    09-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CImpersonateAnon::CImpersonateAnon()
{
    TRACE_CONSTRUCTOR(CImpersonateAnon);

    m_fImpersonatingAnonymous = FALSE;
    m_hCurrentToken = NULL;
    NTSTATUS ntstatus;

    do
    {
        //
        // Check to see if we're already impersonating
        //

        ntstatus = NtOpenThreadToken(NtCurrentThread(),
                                    TOKEN_IMPERSONATE,
                                    TRUE,       // as self to ensure we never fail
                                    &m_hCurrentToken);

        if (ntstatus == STATUS_NO_TOKEN)
        {
            // We're not already impersonating

            m_hCurrentToken = NULL;
        }
        else if (!NT_SUCCESS(ntstatus))
        {
            DBG_OUT_LRESULT(ntstatus);
            break;
        }

        //
        // Impersonate the anonymous token
        //
        ntstatus = NtImpersonateAnonymousToken(NtCurrentThread());

        if (!NT_SUCCESS(ntstatus))
        {
            DBG_OUT_LRESULT(ntstatus);
            break;
        }

        m_fImpersonatingAnonymous = TRUE;
    } while (0);
}



//+--------------------------------------------------------------------------
//
//  Member:     CImpersonateAnon::~CImpersonateAnon
//
//  Synopsis:   Stop impersonating Anonymous on the current thread.
//
//  History:    09-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CImpersonateAnon::~CImpersonateAnon()
{
    TRACE_DESTRUCTOR(CImpersonateAnon);

    if (m_fImpersonatingAnonymous)
    {
        NTSTATUS ntstatus;

        ntstatus = NtSetInformationThread(NtCurrentThread(),
                                         ThreadImpersonationToken,
                                         &m_hCurrentToken,
                                         sizeof(HANDLE));

        if (!NT_SUCCESS(ntstatus))
        {
            DBG_OUT_LRESULT(ntstatus);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\ldapdisplaycache.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       LdapDisplayCache.cxx
//
//  Contents:   Implementation of class to cache class and attribute
//              strings and class icons used to display LDAP classes and
//              attributes.
//
//  Classes:    CDisplayCache
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


const vector<ATTRIBUTE_INFO> CDisplayCache::s_AttrEmpty;

//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::CDisplayCache
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of Object Picker
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDisplayCache::CDisplayCache(
    const CObjectPicker &rop):
        m_rop(rop)
{
    TRACE_CONSTRUCTOR(CDisplayCache);

    m_himlClassIcons = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);

    if (!m_himlClassIcons)
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::CDisplayCache
//
//  Synopsis:   copy ctor
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDisplayCache::CDisplayCache(
    const CDisplayCache &rdc):
        m_rop(rdc.m_rop)
{
    TRACE_CONSTRUCTOR(CDisplayCache);

    if (rdc.m_himlClassIcons)
    {
        m_himlClassIcons = ImageList_Duplicate(rdc.m_himlClassIcons);

        if (!m_himlClassIcons)
        {
            DBG_OUT_LASTERROR;
        }
    }

    m_vClasses = rdc.m_vClasses;
    m_rpDispSpec = rdc.m_rpDispSpec;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::~CDisplayCache
//
//  Synopsis:   dtor
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDisplayCache::~CDisplayCache()
{
    TRACE_DESTRUCTOR(CDisplayCache);

    if (m_himlClassIcons)
    {
        VERIFY(ImageList_Destroy(m_himlClassIcons));
        m_himlClassIcons = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::Clear
//
//  Synopsis:   Discard the cache
//
//  History:    05-25-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDisplayCache::Clear()
{
    TRACE_METHOD(CDisplayCache, Clear);

    if (m_himlClassIcons)
    {
        ImageList_RemoveAll(m_himlClassIcons);
    }
    m_vClasses.clear();
    m_rpDispSpec.Relinquish();
}




HRESULT
CDisplayCache::GetImageList(
    HIMAGELIST *phiml) const
{
    HRESULT hr = S_OK;
    ASSERT(phiml);

    *phiml = m_himlClassIcons;

    if (!m_himlClassIcons)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




class CFindClass
{
public:

    CFindClass(
        const String &strClass):
            m_strClass(strClass)
    {
    }

    BOOL
    operator()(const CLASS_INFO &rcd)
    {
        return !m_strClass.icompare(rcd.strAdsiName);
    }

private:

    const String &m_strClass;
};




HRESULT
CDisplayCache::GetIconIndexFromClass(
    HWND hwnd,
    const String &strClass,
    BOOL fDisabled,
    INT *pintIndex) const
{
    ASSERT(pintIndex);

    HRESULT hr = S_OK;

    do
    {
        // init out param for failure
        *pintIndex = -1;

        // find the entry in m_vClasses for class with ldap name strClass
        ClassInfoVector::iterator it;

        hr = _ReadClassInfo(hwnd, strClass, &it);
        BREAK_ON_FAIL_HRESULT(hr);

        if (fDisabled)
        {
            *pintIndex = it->iDisabledIcon;
        }
        else
        {
            *pintIndex = it->iIcon;
        }
    } while (0);

    return hr;
}




String
CDisplayCache::GetClassDisplayName(
    HWND hwnd,
    const String &strClass) const
{
    ClassInfoVector::iterator it;
    HRESULT hr = _ReadClassInfo(hwnd, strClass, &it);

    if (FAILED(hr))
    {
        return L"";
    }
    return it->strDisplayName;
}


const vector<ATTRIBUTE_INFO> &
CDisplayCache::GetClassAttributes(
    HWND hwnd,
    const String &strClass) const
{
    TRACE_METHOD(CDisplayCache, GetClassAttributes);
    Dbg(DEB_TRACE, "Class is %ws\n", strClass.c_str());

    ClassInfoVector::iterator itClass;
    HRESULT hr = _ReadClassInfo(hwnd, strClass, &itClass);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return s_AttrEmpty;
    }

    if (!itClass->vAttributes.empty())
    {
        return itClass->vAttributes;
    }

    m_rpDispSpec->EnumClassAttributes(strClass.c_str(),
                                      _AttrEnumCallback,
                                      reinterpret_cast<LPARAM>(&itClass->vAttributes));

    AttributeInfoVector::iterator itAttr;

    for (itAttr = itClass->vAttributes.begin();
         itAttr != itClass->vAttributes.end();
         itAttr++)
    {
        itAttr->Type = m_rpDispSpec->GetAttributeADsType(itAttr->strLdapName.c_str());
        Dbg(DEB_TRACE,
            "%ws, %ws, %#x\n",
            itAttr->strLdapName.c_str(),
            itAttr->strDisplayName.c_str(),
            itAttr->Type);
    }

    return itClass->vAttributes;
}




HRESULT CALLBACK
CDisplayCache::_AttrEnumCallback(
    LPARAM lParam,
    LPCWSTR pszAttributeName,
    LPCWSTR pszDisplayName,
    DWORD dwFlags)
{
    AttributeInfoVector *pvAttributes =
        reinterpret_cast<AttributeInfoVector *>(lParam);

    ATTRIBUTE_INFO ad;

    if (pszAttributeName)
    {
        ad.strLdapName = pszAttributeName;
    }

    if (pszDisplayName)
    {
        ad.strDisplayName = pszDisplayName;
    }

    ad.Type = ADSTYPE_INVALID;

    pvAttributes->push_back(ad);
    return S_OK;
}





//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::_ReadClassInfo
//
//  Synopsis:   Read and cache display specifier information for [strClass].
//
//  Arguments:  [hwnd]     - for binding
//              [strClass] - ldap name of class to read info for
//              [pit]      - filled with iterator at relevant CLASS_INFO
//
//  Returns:    HRESULT
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDisplayCache::_ReadClassInfo(
    HWND hwnd,
    const String &strClass,
    ClassInfoVector::iterator *pit) const
{
    TRACE_METHOD(CDisplayCache, _ReadClassInfo);
    Dbg(DEB_TRACE, "Class is %ws\n", strClass.c_str());

    HRESULT hr = S_OK;
    CLASS_INFO cd;
    PWSTR pwzBuf = NULL;

    cd.strAdsiName = strClass;

    do
    {
        hr = _DemandInit(hwnd);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // See if we've already got info on this class
        //

        CFindClass predicate(strClass);

        *pit = find_if(m_vClasses.begin(), m_vClasses.end(), predicate);

        if (*pit != m_vClasses.end())
        {
            // success, return iterator pointing to cached info
            break;
        }

        //
        //!!! handle no-net, joined nt4, etc.
        // Don't have cached info for this class.
        // Read display info from the specifier for this class
        //

        //
        // Special-case downlevel classes, as they won't appear in the
        // DS.
        //

        BOOL fIsLocalGroup = !strClass.icompare(c_wzLocalGroupClass);
        BOOL fIsGlobalGroup = !strClass.icompare(c_wzGlobalGroupClass);

        if (fIsLocalGroup || fIsGlobalGroup)
        {
            HICON hIcon;
            ULONG idiGroup = fIsLocalGroup ? IDI_LOCAL_GROUP : IDI_GROUP;
            int   idsGroup = fIsLocalGroup ? IDS_LOCAL_GROUP : IDS_GLOBAL_GROUP;

            hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idiGroup));

            cd.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            cd.strDisplayName = String::load(idsGroup);
        }
        else
        {
            HICON hIcon;

            hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                          DSGIF_ISNORMAL
                                          | DSGIF_GETDEFAULTICON,
                                          16,
                                          16);
            cd.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);

            hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                        DSGIF_ISDISABLED
                                        | DSGIF_GETDEFAULTICON,
                                        16,
                                        16);
            cd.iDisabledIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);

            pwzBuf = new WCHAR [MAX_PATH + 1];

            hr = m_rpDispSpec->GetFriendlyClassName(strClass.c_str(),
                                                  pwzBuf,
                                                  MAX_PATH);
            if (SUCCEEDED(hr))
            {
                cd.strDisplayName = pwzBuf;
            }
            else
            {
                cd.strDisplayName = strClass;
            }
        }

        //
        // Add new info to class vector
        //

        m_vClasses.push_back(cd);
        *pit = m_vClasses.end() - 1;
    } while (0);

    delete [] pwzBuf;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::_DemandInit
//
//  Synopsis:   Bind to the display specifier container if we haven't already
//
//  Returns:    Result of attempting bind.
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDisplayCache::_DemandInit(
    HWND hwnd) const
{
    HRESULT hr = S_OK;

    if (!m_rpDispSpec.get())
    {
        hr = m_rpDispSpec.AcquireViaCreateInstance(CLSID_DsDisplaySpecifier,
                                                 NULL,
                                                 CLSCTX_INPROC,
                                                 IID_IDsDisplaySpecifier);
    }

#if 0
    do
    {
        //
        // Bind to display specifier container if necessary
        //

        if (!m_rpDispSpecContainer.get())
        {
            VOID *pv = NULL;
            hr = m_rop.GetRootDSE().BindToDisplaySpecifiersContainer(hwnd,
                                                                     IID_IADsContainer,
                                                                     &pv);
            BREAK_ON_FAIL_HRESULT(hr);

            m_rpDispSpecContainer.Acquire(
                static_cast<IADsContainer *>(pv));
        }

        ASSERT(m_rpDispSpecContainer.get());

    } while (0);
#endif
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\lookfordlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LookForDlg.cxx
//
//  Contents:   CLookForDlg implementation
//
//  Classes:    CLookForDlg
//
//  History:    01-28-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_FOR_LV,            IDH_LOOK_FOR_LV,
    0,0
};


//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::CLookForDlg
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CLookForDlg::CLookForDlg(
    const CObjectPicker &rop):
        m_rop(rop),
        m_flSelected(0),
        m_rsm(rop.GetScopeManager())
{
    TRACE_CONSTRUCTOR(CLookForDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::~CLookForDlg
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CLookForDlg::~CLookForDlg()
{
    TRACE_DESTRUCTOR(CLookForDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnInit
//
//  Synopsis:   Initialize the dialog
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLookForDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CLookForDlg, _OnInit);

    //
    // put listview in checkbox style
    //

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_LOOK_FOR_LV),
                                        LVS_EX_CHECKBOXES,
                                        LVS_EX_CHECKBOXES);

    //
    // Get current scope and ask for the filter flags which apply to it.
    // Global catalog objects actually include the ones caller specified for
    // the GC plus the ones specified for the joined domain.
    //

    const CScope &rsCurScope = m_rsm.GetCurScope();
    ULONG flResultantFilterFlags;
    HRESULT hr = rsCurScope.GetResultantFilterFlags(m_hwnd,
                                                    &flResultantFilterFlags);
    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    if (rsCurScope.Type() == ST_GLOBAL_CATALOG)
    {
        const CScope &rJoinedDomainScope =
            m_rsm.LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN);

        if (!IsInvalid(rJoinedDomainScope))
        {
            ULONG flJoined;

            hr = rJoinedDomainScope.GetResultantFilterFlags(m_hwnd, &flJoined);

                if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                return hr;
            }
            flResultantFilterFlags |= flJoined;
        }
    }


    //
    // Create a copy of the Attribute Manager's image list and add the icon
    // for "other" (customizer supplied) objects to it.
    //

    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    HIMAGELIST hImageList = NULL;
    HIMAGELIST himlAttrMgr = NULL;

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    hr = ram.GetImageList(&himlAttrMgr);

    int iUser = -1;
    int iGroup = -1;
    int iComputer = -1;
    int iContact = -1;
    int iOther = -1;
    ULONG ulGetIconFlags = 0;

    if (IsDownlevel(rsCurScope))
    {
        ulGetIconFlags |= DSOP_GETICON_FLAG_DOWNLEVEL;
    }

    if (SUCCEEDED(hr))
    {
        hr = ram.GetIconIndexFromClass(m_hwnd,
                                       c_wzUserObjectClass,
                                       ulGetIconFlags,
                                       &iUser);
        if(SUCCEEDED(hr) || !IsCredError(hr))
        {
            hr = ram.GetIconIndexFromClass(m_hwnd,
                                           c_wzGroupObjectClass,
                                           ulGetIconFlags,
                                           &iGroup);
        }
        if(SUCCEEDED(hr) || !IsCredError(hr))
        {
            hr = ram.GetIconIndexFromClass(m_hwnd,
                                           c_wzComputerObjectClass,
                                           ulGetIconFlags,
                                           &iComputer);
        }

        if ((SUCCEEDED(hr) || !IsCredError(hr)) && 
            !IsDownlevel(rsCurScope) &&
            ConfigSupportsDs(m_rop.GetTargetComputerConfig()))
        {
            ram.GetIconIndexFromClass(m_hwnd, c_wzContactObjectClass, 0, &iContact);
        }

        hImageList = ImageList_Duplicate(himlAttrMgr);

        if (hImageList)
        {
            ListView_SetImageList(hwndLv, hImageList, LVSIL_SMALL);

            // Use the directory icon for "other" (customizer supplied) objects

            HICON hicoOther = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_DIRECTORY));

            if (hicoOther)
            {
                iOther = ImageList_AddIcon(hImageList, hicoOther);
            }
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        hr = S_OK;  // not having icons isn't a fatal error
    }

    //
    // Add a single column to the listview
    //

    LV_COLUMN   lvc;
    RECT        rcLv;

    VERIFY(GetClientRect(hwndLv, &rcLv));
    //REVIEWED-2002-02-21-lucios.
    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;
    lvc.cx = rcLv.right;
    ListView_InsertColumn(hwndLv, 0, &lvc);

    //
    // Add items to listview for each class represented by a nonzero filter bit
    //

    if (IsUplevel(rsCurScope))
    {
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_USERS,              IDS_USERS, iUser);
        _AddClassToLv(flResultantFilterFlags, ALL_UPLEVEL_GROUP_FILTERS,      IDS_GROUPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_COMPUTERS,          IDS_COMPUTERS, iComputer);
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_CONTACTS,           IDS_CONTACTS, iContact);
        _AddClassToLv(flResultantFilterFlags, ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS, IDS_BUILTIN_WKSPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_EXTERNAL_CUSTOMIZER, IDS_OTHER_OBJECTS, iOther);
    }
    else
    {
        _AddClassToLv(flResultantFilterFlags, DSOP_DOWNLEVEL_FILTER_USERS,     IDS_USERS, iUser);
        _AddClassToLv(flResultantFilterFlags, ALL_DOWNLEVEL_GROUP_FILTERS,     IDS_GROUPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_DOWNLEVEL_FILTER_COMPUTERS, IDS_COMPUTERS, iComputer);
        _AddClassToLv(flResultantFilterFlags, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS,IDS_BUILTIN_WKSPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER, IDS_OTHER_OBJECTS, iOther);
    }

    //
    // Make the first item in the listview have the focus
    //

    ListView_SetItemState(hwndLv,
                          0,
                          LVIS_FOCUSED | LVIS_SELECTED,
                          LVIS_FOCUSED | LVIS_SELECTED);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_AddClassToLv
//
//  Synopsis:
//
//  Arguments:  [flResultantFilterFlags] - all legal filter flags for the
//                                          current scope
//              [flMustBeSet]            - flag which must be set in
//                                          [flResultantFilterFlags] for
//                                          [ids] to be added to LV.
//              [ids]                    - id of class name
//
//  History:    02-28-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CLookForDlg::_AddClassToLv(
    ULONG flResultantFilterFlags,
    ULONG flMustBeSet,
    ULONG ids,
    int iImage)
{
    //
    // If working with downlevel filter flags then msb is set, so bitwise and
    // of flResultantFilterFlags and flMustBeSet will always be nonzero;
    // there must be some bit other than the DOWNLEVEL_FILTER_BIT set for
    // this item to qualify.
    //
    // If working with uplevel flags then DOWNLEVEL_FILTER_BIT is already 0
    // so masking it off doesn't affect anything.
    //

    if (!((flResultantFilterFlags & flMustBeSet) & ~DOWNLEVEL_FILTER_BIT))
    {
        return;
    }

    LVITEM  lvi;
    
    //REVIEWED-2002-02-21-lucios.
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    String str = String::load(static_cast<unsigned>(ids), g_hinst);
    lvi.pszText = const_cast<PWSTR>(str.c_str());
    lvi.lParam = (LPARAM) (flResultantFilterFlags & flMustBeSet);
    lvi.iImage = iImage;

    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    int iItem = ListView_InsertItem(hwndLv, &lvi);

    if (iItem == -1)
    {
        DBG_OUT_LASTERROR;
        return;
    }

    //
    // If this class is one that was selected on entry, turn on the check
    // mark next to it.
    //

    if (flMustBeSet & m_flSelected & ~DOWNLEVEL_FILTER_BIT)
    {
        ListView_SetCheckState(hwndLv, iItem, TRUE);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnNotify
//
//  Synopsis:   Handle listview item changed notifications
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookForDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    //TRACE_METHOD(CLookForDlg, _OnNotify);

    LPNMLISTVIEW pnmlv = reinterpret_cast<LPNMLISTVIEW> (lParam);
    BOOL         fReturn = FALSE;

    switch (pnmlv->hdr.code)
    {
    case LVN_ITEMCHANGED:
        SafeEnableWindow(_hCtrl(IDOK), _IsSomethingSelected());
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_IsSomethingSelected
//
//  Synopsis:   Return TRUE if the checkbox is checked for any of the
//              items in the listview.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookForDlg::_IsSomethingSelected() const
{
    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    int cItems = ListView_GetItemCount(hwndLv);
    ASSERT(cItems > 0);
    int i;

    for (i = 0; i < cItems; i++)
    {
        if (ListView_GetCheckState(hwndLv, static_cast<UINT>(i)))
        {
            return TRUE;
        }
    }
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookForDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        _UpdateSelectedFlags();
#if (DBG == 1)
        Dbg(DEB_TRACE,
            "UA: (LookForDlg) hit OK, selected classes are %ws\n",
             DbgGetFilterDescr(m_rop, m_flSelected).c_str());
#endif // (DBG == 1)
        m_rop.GetFilterManager().SetLookForDirty(true);
        EndDialog(GetHwnd(), FALSE);
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (LookForDlg) hit Cancel\n");
        EndDialog(GetHwnd(), FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CLookForDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_UpdateSelectedFlags
//
//  Synopsis:   Read the selected flags from the listview
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookForDlg::_UpdateSelectedFlags()
{
    TRACE_METHOD(CLookForDlg, _UpdateSelectedFlags);

    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    int cItems = ListView_GetItemCount(hwndLv);
    ASSERT(cItems > 0);
    int i;

    //
    // Reset the selected flags.  Some flags that apply to the current
    // scope's filters are not stored in the listview, namely
    // DSOP_FILTER_INCLUDE_ADVANCED_VIEW for uplevel and
    // DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS for downlevel.  If those
    // are set for the current scope, make sure to preserve them.
    //

    if (IsDownlevel(m_rsm.GetCurScope()))
    {
        if (IsDownlevelFlagSet(m_flSelected,
                               DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
        {
            m_flSelected = DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
        }
        else
        {
            m_flSelected = 0;
        }
    }
    else
    {
        m_flSelected &= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;
    }

    //
    // Now add in the flags stored with all the checked classes
    //

    for (i = 0; i < cItems; i++)
    {
        if (ListView_GetCheckState(hwndLv, static_cast<UINT>(i)))
        {
            LVITEM lvi;
            //REVIEWED-2002-02-21-lucios.
            ZeroMemory(&lvi, sizeof lvi);
            lvi.iItem = i;
            lvi.mask = LVIF_PARAM;
            VERIFY(ListView_GetItem(hwndLv, &lvi));
            m_flSelected |= lvi.lParam;
            Dbg(DEB_TRACE, "item %d selected, adding flag %#x\n", i, lvi.lParam);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookForDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CLookForDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\namenotfounddlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       NameNotFoundDlg.cxx
//
//  Contents:   Name not found dialog class
//
//  Classes:    CNameNotFoundDlg
//
//  History:    03-28-2000   DavidMun   Created from reenter.cxx
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_FOR_PB,            IDH_LOOK_FOR_PB,
    IDC_LOOK_FOR_EDIT,          IDH_LOOK_FOR_EDIT,
    IDC_LOOK_IN_PB,             IDH_LOOK_IN_PB,
    IDC_LOOK_IN_EDIT,           IDH_LOOK_IN_EDIT,
    IDC_CORRECT_RADIO,          IDH_CORRECT_RADIO,
    IDC_CORRECT_EDIT,           IDH_CORRECT_EDIT,
    IDC_REMOVE_RADIO,           IDH_REMOVE_RADIO,
    IDC_NOT_FOUND_MESSAGE,      ULONG_MAX,
    0,0
};




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::DoModalDialog
//
//  Synopsis:   Invoke the name not found dialog as a modal dialog.
//
//  Arguments:  [hwndParent] - dialog parent.
//
//  Returns:    S_OK    - user corrected name and hit OK
//              S_FALSE - user hit cancel
//
//  History:    08-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CNameNotFoundDlg::DoModalDialog(
    HWND hwndParent,
    NAME_PROCESS_RESULT *pnpr)
{
    TRACE_METHOD(CNameNotFoundDlg, DoModalDialog);

    m_pnpr = pnpr;
    _DoModalDlg(hwndParent, IDD_NAMENOTFOUND);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_OnInit
//
//  Synopsis:   Initialize dialog controls
//
//  Arguments:  [pfSetFocus] - set to FALSE
//
//  Returns:    S_OK
//
//  History:    08-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CNameNotFoundDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CNameNotFoundDlg, _OnInit);



    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    String strLookFor = rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR);

    //
    // Init the Look For and Look In r/o edit controls
    //

    Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_IN_EDIT),
                 rsm.GetCurScope().GetDisplayName().c_str());
    Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                 strLookFor.c_str());

    //
    //Truncate the object name to MAX_OBJECTNAME_DISPLAY_LEN
    //
    String strObjectName = *m_pstrName;
    if(!strObjectName.empty() && (strObjectName.size() > MAX_OBJECTNAME_DISPLAY_LEN))
    {
        strObjectName.erase(MAX_OBJECTNAME_DISPLAY_LEN,strObjectName.size());
        //
        //Add three dots to indicate that name is truncated
        //
        strObjectName.append(L"...");
    }

    //
    // Change the IDC_REMOVE_RADIO string to reflect object name
    //
    if(!strObjectName.empty())
    {
        String strRadio = String::format(IDS_REMOVE_FROM_SEL,
            strObjectName.c_str());

        SetWindowText(GetDlgItem(m_hwnd, IDC_REMOVE_RADIO), 
            strRadio.c_str());

    }
    //
    // Init the error message
    //
    if (!m_strError.empty())
    {
        Edit_SetText(_hCtrl(IDC_NOT_FOUND_MESSAGE), m_strError.c_str());
    }
    else
    {
        String strLabel = String::format(static_cast<unsigned>(m_idsError),
                                         strObjectName.c_str());

        Edit_SetText(_hCtrl(IDC_NOT_FOUND_MESSAGE), strLabel.c_str());
    }
    Button_SetCheck(_hCtrl(IDC_CORRECT_RADIO), BST_CHECKED);
    Edit_SetText(_hCtrl(IDC_CORRECT_EDIT), m_pstrName->c_str());
    SetFocus(_hCtrl(IDC_CORRECT_EDIT));
    *pfSetFocus = FALSE;
    DisableSystemMenuClose(m_hwnd);

    return S_OK;
}





//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_OnCommand
//
//  Synopsis:   Handle user input.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    08-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CNameNotFoundDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDC_LOOK_IN_PB:
    {
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Look In button\n");
        const CFilterManager &rfm = m_rop.GetFilterManager();
        const CScopeManager &rsm = m_rop.GetScopeManager();

        rsm.DoLookInDialog(m_hwnd);
        rfm.HandleScopeChange(m_hwnd);

        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_IN_EDIT),
                     rsm.GetCurScope().GetDisplayName().c_str());
        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        break;
    }

    case IDC_LOOK_FOR_PB:
    {
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Look For button\n");

        const CFilterManager &rfm = m_rop.GetFilterManager();
        rfm.DoLookForDialog(m_hwnd);
        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        break;
    }

    case IDOK:
    {
        if (BST_CHECKED == Button_GetCheck(_hCtrl(IDC_REMOVE_RADIO)))
        {
            Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit OK, remove radio is selected\n");
            *m_pnpr = NPR_DELETE;
        }
        else
        {
            *m_pnpr = NPR_EDITED;

            WCHAR wzName[MAX_PATH] = L"";

            Edit_GetText(_hCtrl(IDC_CORRECT_EDIT), wzName, ARRAYLEN(wzName));
            *m_pstrName = wzName;
            m_pstrName->strip(String::BOTH);
            Dbg(DEB_TRACE,
                "UA: (NameNotFoundDlg) hit OK, edited name is '%ws'\n",
                m_pstrName->c_str());
        }
        EndDialog(m_hwnd, S_OK);
    }
    break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Cancel\n");
        *m_pnpr = NPR_STOP_PROCESSING;
        EndDialog(m_hwnd, E_FAIL);
        break;

    case IDC_CORRECT_RADIO:
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Correct radio button\n");
        _EnableCorrectionCtrls(TRUE);
        wParam = MAKEWPARAM(0, EN_UPDATE);
        // FALL THROUGH

    case IDC_CORRECT_EDIT:
    if (HIWORD(wParam) == EN_UPDATE)
    {
        WCHAR wzName[MAX_PATH] = L"";

        Edit_GetText(_hCtrl(IDC_CORRECT_EDIT), wzName, ARRAYLEN(wzName));
        StripLeadTrailSpace(wzName);

        if (!*wzName)
        {
            SafeEnableWindow(_hCtrl(IDOK), FALSE);
        }
        else
        {
            SafeEnableWindow(_hCtrl(IDOK), TRUE);
        }
    }
    break;

    case IDC_REMOVE_RADIO:
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Remove radio button\n");
        _EnableCorrectionCtrls(FALSE);
        SafeEnableWindow(_hCtrl(IDOK), TRUE);
        break;

    default:
        fNotHandled = TRUE;
        break;
    }

    return fNotHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_EnableCorrectionCtrls
//
//  Synopsis:   Enable or disable child controls according to [fEnable]
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CNameNotFoundDlg::_EnableCorrectionCtrls(
    BOOL fEnable)
{
    SafeEnableWindow(_hCtrl(IDC_LOOK_FOR_EDIT), fEnable);
    SafeEnableWindow(_hCtrl(IDC_LOOK_FOR_PB), fEnable);
    SafeEnableWindow(_hCtrl(IDC_LOOK_IN_EDIT), fEnable);
    SafeEnableWindow(_hCtrl(IDC_LOOK_IN_PB), fEnable);
    SafeEnableWindow(_hCtrl(IDC_CORRECT_EDIT), fEnable);
    SafeEnableWindow(_hCtrl(IDC_LOOK_FOR_LBL), fEnable);
    SafeEnableWindow(_hCtrl(IDC_LOOK_IN_LBL), fEnable);
    SafeEnableWindow(_hCtrl(IDC_NAME_LBL), fEnable);
}




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CNameNotFoundDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CObjectSelect, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\multi.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       multi.cxx
//
//  Contents:   Implements a dialog allowing the user to choose between
//              multiple items which partially match the string in the name
//              edit control.
//
//  Classes:    CMultiDlg
//
//  History:    03-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CMultiDlg)

static ULONG
s_aulHelpIds[] =
{
    IDC_MATCHING_LIST,          IDH_MATCHING_LIST,
    IDC_SELECT_MATCHING_LBL,    static_cast<ULONG>(-1L),
    0,0
};

//
//This is a static variable used to pass column info to 
//callback sorting routine
//
static AttrKeyVector *g_vakListviewColumns = NULL;

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_MultiMatchDialog
//
//  Synopsis:   Present a dialog allowing user to choose between the multiple
//              items which matched the user's typed entry.
//
//  Arguments:  [hwndFrame]    - parent window
//              [fMultiSelect] - controls selection mode
//              [pnpr]         - filled with NPR_DELETE, NPR_EDIT, or
//                                NPR_SUCCESS
//              [pdsol]        - on input, contains more than one object.
//                                on successful return, objects which the
//                                user didn't select have been deleted.
//
//  Returns:    S_OK    - [pdsol] has selected items
//              S_FALSE - user hit Cancel
//              E_*     - any error
//
//  Modifies:   *[pdsol]
//
//  History:    08-17-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMultiDlg::DoModalDialog(
    HWND  hwndParent,
    BOOL  fMultiSelect,
    NAME_PROCESS_RESULT *pnpr,
    CDsObjectList *pdsol)
{
    TRACE_METHOD(CMultiDlg, DoModalDlg);

    m_fSingleSelect = !fMultiSelect;
    m_pdsol = pdsol;
    m_pnpr = pnpr;

    _DoModalDlg(hwndParent, IDD_MULTI);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnInit
//
//  Synopsis:   Handle dialog initialization.
//
//  Arguments:  [pfSetFocus] - set to TRUE on exit if focus changed
//
//  Returns:    S_OK
//
//  History:    03-30-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMultiDlg::_OnInit(
    BOOL *pfSetFocus)
{
    HRESULT hr = S_OK;
    HWND hwndLV = _hCtrl(IDC_MATCHING_LIST);
    const CAttributeManager &ram = m_rop.GetAttributeManager();

    g_vakListviewColumns = NULL;

    SetDefaultColumns(m_hwnd, m_rop, &m_vakListviewColumns);

    //
    // Set extended styles: full row select and labeltip
    //

    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);
    //
    // Put the columns in the listview
    //

    WCHAR       wszBuffer[MAX_PATH + 1];
    LV_COLUMN   lvc;
    RECT        rcLV;
    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    //REVIEWED-2002-02-21-lucios.
    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;
    lvc.cx = rcLV.right / static_cast<LONG>(m_vakListviewColumns.size());
    lvc.pszText = wszBuffer;
    lvc.cchTextMax = ARRAYLEN(wszBuffer);

    size_t i;
    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
        ATTR_KEY ak = m_vakListviewColumns[i];
        const String &strAttrDisplayName = ram.GetAttrDisplayName(ak);
        lvc.pszText = const_cast<PWSTR>(strAttrDisplayName.c_str());

        int iResult = ListView_InsertColumn(_hCtrl(IDC_MATCHING_LIST),
                                            i,
                                            &lvc);
        if (iResult == -1)
        {
            DBG_OUT_LASTERROR;
            hr = E_FAIL;
            break;
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // If we're not in single select mode, allow multiple selections in
    // listview.
    //

    String strLabelFmt;
    String strLabel;

    if (!m_fSingleSelect)
    {
        LONG lStyle = GetWindowLong(hwndLV, GWL_STYLE);
        lStyle &= ~LVS_SINGLESEL;
        SetWindowLong(hwndLV, GWL_STYLE, lStyle);
        strLabelFmt = String::load((int)IDS_MULTI_PICK_ONE_OR_MORE);
    }
    else
    {
        strLabelFmt = String::load((int)IDS_MULTI_PICK_ONE);
    }

    strLabel = String::format(strLabelFmt.c_str(), m_strUserEnteredText.c_str());
    Static_SetText(_hCtrl(IDC_SELECT_MATCHING_LBL), strLabel.c_str());

    //
    // Set the attribute/class display info manager's imagelist into the
    // listview
    //

    HIMAGELIST himl = NULL;
    hr = ram.GetImageList(&himl);

    if (SUCCEEDED(hr))
    {
        ListView_SetImageList(hwndLV, himl, LVSIL_SMALL);
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        hr = S_OK;  // nonfatal
    }

    //
    // Fill the listview
    //

    LVITEM lvi;
    
    //REVIEWED-2002-02-21-lucios.
    ZeroMemory(&lvi, sizeof lvi);

    CDsObjectList::iterator it;
    LPARAM InitialSelectionLParam = 0;

    for (i = 0, it = m_pdsol->begin(); it != m_pdsol->end(); i++, it++)
    {
        lvi.mask = LVIF_TEXT | LVIF_PARAM;

        //
        // Get an icon for this class
        //

        if (himl)
        {
            hr = ram.GetIconIndexFromObject(m_hwnd, *it, &lvi.iImage);
        }

        if (himl && SUCCEEDED(hr))
        {
            //
            // our class/icon cache has entry for this icon for this class.
            // the entry will be -1 if the icon couldn't be retrieved.
            //

            if (lvi.iImage != -1)
            {
                lvi.mask |= LVIF_IMAGE;
            }
        }


        lvi.pszText = it->GetAttr(m_vakListviewColumns[0]).GetBstr();
        lvi.lParam = reinterpret_cast<LPARAM>(&*it);

        //
        // Insert the item
        //

        LONG lResult = ListView_InsertItem(hwndLV, &lvi);

        if (lResult == -1)
        {
            Dbg(DEB_ERROR,
                "Error %u inserting '%ws' in multimatch listview\n",
                GetLastError(),
                lvi.pszText);
            continue;
        }

        //
        // If the user-entered text exactly matches the RDN, samAccountName,
        // or UPN attribute, remember this item as the one to select
        // initially.
        //

        const Variant &varSamAccountName = it->GetAttr(AK_SAMACCOUNTNAME);

        if (!InitialSelectionLParam &&
            (!m_strUserEnteredText.icompare(it->GetName()) ||
             !m_strUserEnteredText.icompare(it->GetLocalizedName()) ||
             !m_strUserEnteredText.icompare(it->GetUpn()) ||
             !m_strUserEnteredText.icompare(varSamAccountName.GetBstr())))
        {
            InitialSelectionLParam = lvi.lParam;
        }

        //
        // Column 0 added, now add the rest
        //

        size_t j;

        for (j = 1; j < m_vakListviewColumns.size(); j++)
        {
            ListView_SetItemText(hwndLV,
                                 lResult,
                                 static_cast<int>(j),
                                 const_cast<PWSTR>(it->GetAttr(m_vakListviewColumns[j]).GetBstr()));
        }
    }

    if (!InitialSelectionLParam)
    {
        ListView_SetItemState(hwndLV,
                              0,
                              LVIS_FOCUSED,
                              LVIS_FOCUSED);
    }
    else
    {
        LVFINDINFO lvfi;
        //REVIEWED-2002-02-21-lucios.
        ZeroMemory(&lvfi, sizeof lvfi);
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = InitialSelectionLParam;
        int iItem = ListView_FindItem(hwndLV, -1, &lvfi);

        // darn well better find it, we just added it!
        ASSERT(iItem != -1);

        if (iItem != -1)
        {
            SetListViewSelection(hwndLV, iItem);
        }
    }
    DisableSystemMenuClose(m_hwnd);
    SetFocus(hwndLV);
    *pfSetFocus = FALSE;

    if(SUCCEEDED(hr))
        g_vakListviewColumns = &m_vakListviewColumns;

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnCommand
//
//  Synopsis:   Handle user input.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    02-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CMultiDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        _OnOk();
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (MultiDlg) hit Cancel\n");
        *m_pnpr = NPR_STOP_PROCESSING;
        EndDialog(m_hwnd, E_FAIL);
        break;

    default:
        fNotHandled = TRUE;
        break;
    }
    return fNotHandled;
}



//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnOk
//
//  Synopsis:   Remember the user's selection(s) in the listview and close
//              the dialog
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CMultiDlg::_OnOk()
{
    HWND hwndLV = _hCtrl(IDC_MATCHING_LIST);

    //
    // Move each of the ds objects whose item in the listview is
    // selected from the passed-in list to a temporary list.
    //

    LVITEM lvi;
    int iItem = -1;
    //REVIEWED-2002-02-21-lucios.
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    CDsObjectList dsolTemp;

    while ((iItem = ListView_GetNextItem(hwndLV,
                                         iItem,
                                         LVNI_SELECTED)) != -1)
    {
        lvi.iItem = iItem;

        if (ListView_GetItem(hwndLV, &lvi))
        {
            CDsObjectList::iterator it;

            for (it = m_pdsol->begin(); it != m_pdsol->end(); it++)
            {
                if ((LPARAM)(&*it) == lvi.lParam)
                {
                    dsolTemp.splice(dsolTemp.end(), *m_pdsol, it);
                    break;
                }
            }
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
    }

    ASSERT(!dsolTemp.empty());

    //
    // Now dsolTemp contains all selected items.
    // Move the items in the temporary list back to the passed-in list
    //

    Dbg(DEB_TRACE,
        "UA: (MultiDlg) hit OK, %u items are selected, first is %ws\n",
        dsolTemp.size(),
        dsolTemp.front().GetName());

    m_pdsol->assign(dsolTemp.begin(), dsolTemp.end());
    *m_pnpr = NPR_SUCCESS;
    EndDialog(m_hwnd, S_OK);
}

//
//Callback function called by ListView for sorting the column
//Ported from ACLUI
//
int CALLBACK
ListCompareProc(LPARAM lParam1,
                LPARAM lParam2,
                LPARAM lParamSort)
{
    int iResult = 0;

    if(!g_vakListviewColumns)
        return 0;

    CDsObject * p1 = (CDsObject *)lParam1;
    CDsObject * p2 = (CDsObject *)lParam2;

    short iColumn = LOWORD(lParamSort);
    short iSortDirection = HIWORD(lParamSort);


    LPTSTR psz1 = NULL;
    LPTSTR psz2 = NULL;

    if (iSortDirection == 0)
        iSortDirection = 1;

    if (p1 && p2)
    {
        psz1 = p1->GetAttr((*g_vakListviewColumns)[iColumn]).GetBstr();
        psz2 = p2->GetAttr((*g_vakListviewColumns)[iColumn]).GetBstr();
    }

    if (iResult == 0 && psz1 && psz2)
    {
        iResult = CompareString(LOCALE_USER_DEFAULT, 0, psz1, -1, psz2, -1) - 2;
    }

    iResult *= iSortDirection;

    return iResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnNotify
//
//  Synopsis:   Handle WM_NOTIFY
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CMultiDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    //TRACE_METHOD(CDsSelectDlg, _OnNotify);
    LPNMHDR pnmh = (LPNMHDR) lParam;

    //
    // Ignore notifications from controls other than the listview
    //

    if (pnmh->idFrom != IDC_MATCHING_LIST)
    {
        return TRUE;
    }

    //
    // Since it's from listview, the notification header is
    // listview type.
    //

    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW) lParam;

    INT iItem = -1;

    switch (pnmlv->hdr.code)
    {
    case NM_DBLCLK:
        iItem = ListView_GetNextItem(pnmlv->hdr.hwndFrom,
                                     -1,
                                     LVNI_SELECTED);

        if (iItem != -1)
        {
            _OnOk();
        }
        break;

    case LVN_KEYDOWN:
        switch (((LPNMLVKEYDOWN)lParam)->wVKey)
        {
        case 'A':
            if (!m_fSingleSelect && GetKeyState(VK_CONTROL) < 0)
            {
                ListView_SetItemState(pnmh->hwndFrom,
                                      -1,
                                      LVIS_SELECTED,
                                      LVIS_SELECTED);
            }
            break;
        }
        break;

    case LVN_ITEMCHANGED:
        iItem = ListView_GetNextItem(pnmlv->hdr.hwndFrom,
                                     -1,
                                     LVNI_SELECTED);

        SafeEnableWindow(_hCtrl(IDOK), (iItem != -1));
        break;

    case LVN_COLUMNCLICK:
        if (m_iLastColumnClick == pnmlv->iSubItem)
            m_iSortDirection = -m_iSortDirection;
        else
            m_iSortDirection = 1;

        m_iLastColumnClick = pnmlv->iSubItem;

        ListView_SortItems(pnmh->hwndFrom,
            ListCompareProc,
            MAKELPARAM(m_iLastColumnClick, m_iSortDirection));


        break;
    default:
        break;
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnHelp
//
//  Synopsis:   Invoke context sensitive help
//
//  History:    04-21-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CMultiDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CDsSelectDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\lookindlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LookInDlg.cxx
//
//  Contents:   CLookInDlg implementation
//
//  Classes:    CLookInDlg
//
//  History:    01-28-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_IN_TV,            IDH_LOOK_IN_TV,
    0,0
};

#pragma warning(disable: 4701)  // local variable might not be init

//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnInit
//
//  Synopsis:   Handle WM_INITDIALOG
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    05-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLookInDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CLookInDlg, _OnInit);

    //
    // Init data needed for resizing.
    //
    // First translate the separation distance between controls from
    // dialog units to pixels.
    //

    RECT rc;

    rc.left = rc.top = 1;
    rc.right = DIALOG_SEPARATION_X;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxSeparation = rc.right;
    m_cySeparation = rc.bottom;

    GetClientRect(m_hwnd, &rc);

    m_cxFrameLast = rc.right;
    m_cyFrameLast = rc.bottom;

    GetWindowRect(m_hwnd, &rc);
    m_cxMin = rc.right - rc.left + 1;
    m_cyMin = rc.bottom - rc.top + 1;

    //
    // Create a copy of the Attribute Manager's image list and manually
    // add the icons for scopes which don't use the icon of some class.
    //

    HIMAGELIST himlAttrMgr = NULL;
    const CAttributeManager &ram = m_rop.GetAttributeManager();

    HRESULT hr = ram.GetImageList(&himlAttrMgr);

    if (SUCCEEDED(hr))
    {
        m_hImageList = ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 1, 1);

        if (m_hImageList)
        {
            //
            // copy icons from master list that came from DS--but use downlevel
            // flag for Computer, since that comes from a LoadIcon and
            // won't fail
            //

            ram.CopyIconToImageList(m_hwnd,
                                    c_wzComputerObjectClass,
                                    DSOP_GETICON_FLAG_DOWNLEVEL,
                                    &m_hImageList);

            HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_WORKGROUP));
            ImageList_AddIcon(m_hImageList, hIcon);
            hIcon = NULL;

            if (ConfigSupportsDs(m_rop.GetTargetComputerConfig()))
            {
                hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_DIRECTORY));
                ImageList_AddIcon(m_hImageList, hIcon);
                hIcon = NULL;
                HRESULT hr1 = S_OK;
                hr1 = ram.CopyIconToImageList(m_hwnd, c_wzDomainDnsClass, 0, &m_hImageList);
                //
                //If above failed with a cred error means, user pressed cancel for 
                //credential. No need to ask for the same credentials again.
                //Bug 188668
                // NTRAID#NTBUG9-597298-2002/04/01-lucios
                // Two changes here. First I'm moving the XForest icons load
                // inside this if since it only makes sense to load them when
                // we're able to access the other icons that reside in the 
                // display specifier.
                // The second change is removing "|| !IsCredError(hr1)", since
                // we don't want to try c_wzOuClass if c_wzDomainDnsClass
                //  failed (for any reason) or load the XForest icons.
                if(SUCCEEDED(hr1)) 
                {
                    ram.CopyIconToImageList(m_hwnd, c_wzOuClass, 0, &m_hImageList);
                
                    hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_FEDERATED));
                    ImageList_AddIcon(m_hImageList, hIcon);

                    hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_UNFEDERATED));
                    ImageList_AddIcon(m_hImageList, hIcon);
                }
            }
            else
            {
                    // NTRAID#NTBUG9-533296-2002/04/15-lucios
                    // Since the target is downlevel we need to load the icon
                    // for the domains from the resources
                    // At this point we have loaded the computer 
                    // (CopyIconToImageList pos 0) and workgroup(pos 1) icons.
                    // We need one Add's to fill in for ST_GLOBAL_CATALOG, that
                    // even though will not be shown for downlevel targets, has
                    // the index of 2 in CLookInDlg::_AddScopes.
                    // Only the icon for the second Add will actually be
                    // displayed for the index 3 in _AddScopes.
                    hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_DOMAIN));
                    ImageList_AddIcon(m_hImageList, hIcon);
                    ImageList_AddIcon(m_hImageList, hIcon);
            }

            //
            // associate the image list with the treeview.  note treeview does
            // not destroy the imagelist.
            //

            TreeView_SetImageList(_hCtrl(IDC_LOOK_IN_TV),
                                  m_hImageList,
                                  TVSIL_NORMAL);
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        hr = S_OK;  // not having icons isn't a fatal error
    }

    //
    // Populate the treeview with the root scopes and whatever child scopes
    // they already have.
    //

    vector<RpScope>::const_iterator it;
    vector<RpScope>::const_iterator itEnd;

    m_rop.GetScopeManager().GetRootScopeIterators(&it, &itEnd);
    _AddScopes(NULL, it, itEnd);

    //
    // If a starting scope has been specified, select it in the treeview.
    // This will automatically scroll/expand the treeview as necessary
    // to bring the selected item into view.
    //
    if (m_htiStartingScope)
    {
        TreeView_SelectItem(_hCtrl(IDC_LOOK_IN_TV), m_htiStartingScope);
    }
    return S_OK;
}
#pragma warning(default: 4701)




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_AddScopes
//
//  Synopsis:   Recursively add the scopes in the container specified by
//              [itBegin] and [itEnd] to the treeview as children of node
//              specified by [hRoot].
//
//  Arguments:  [hRoot]   - treeview node under which to add scopes, or
//                           NULL to add nodes as root items
//              [itBegin] - iterator at first item to add
//              [itEnd]   - iterator just past last item to add
//
//  History:    05-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------
void
CLookInDlg::_AddScopes(
    HTREEITEM hRoot,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd)
{
    TRACE_METHOD(CLookInDlg, _AddScopes);

    HWND hwndTv = GetDlgItem(m_hwnd, IDC_LOOK_IN_TV);
    ASSERT(IsWindow(hwndTv));
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        //
        // Scopes generated as the result of name resolution are never
        // displayed in the UI
        //

        if (it->get()->Type() == ST_USER_ENTERED_UPLEVEL_SCOPE ||
            it->get()->Type() == ST_USER_ENTERED_DOWNLEVEL_SCOPE)
        {
            continue;
        }

        //
        //Cross Forest Scopes are generated as a result of name resolution
        //and should never be shown in the UI
        //
        if(it->get()->Type() == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
        {
            const CLdapDomainScope *pLdapScope = 
                dynamic_cast<const CLdapDomainScope*>(it->get());
            if(pLdapScope->IsXForest())
                continue;
        }

        TVINSERTSTRUCT tvis;

        if (hRoot == NULL)
        {
            tvis.hParent = TVI_ROOT;
        }
        else
        {
            tvis.hParent = hRoot;
        }
        tvis.hInsertAfter = TVI_LAST;
        tvis.itemex.mask = TVIF_PARAM | TVIF_TEXT | TVIF_CHILDREN;
        tvis.itemex.lParam = reinterpret_cast<ULONG_PTR> (it->get());
        ASSERT(m_rop.GetScopeManager().IsValidScope(
            reinterpret_cast<CScope*>(tvis.itemex.lParam)));
        tvis.itemex.pszText = const_cast<PWSTR>
                                (it->get()->GetDisplayName().c_str());

        if (it->get()->MightHaveChildScopes())
        {
            tvis.itemex.cChildren = 1;
        }
        else
        {
            tvis.itemex.cChildren = 0;
        }

        if (m_hImageList)
        {
            ULONG idxScopeIcon = ULONG_MAX;

            switch (it->get()->Type())
            {
            case ST_TARGET_COMPUTER:
                idxScopeIcon = 0;
                break;

            case ST_WORKGROUP:
                idxScopeIcon = 1;
                break;

            case ST_GLOBAL_CATALOG:
                idxScopeIcon = 2;
                break;

            case ST_DOWNLEVEL_JOINED_DOMAIN:
            case ST_EXTERNAL_DOWNLEVEL_DOMAIN:
            case ST_UPLEVEL_JOINED_DOMAIN:
            case ST_ENTERPRISE_DOMAIN:
            case ST_EXTERNAL_UPLEVEL_DOMAIN:
                idxScopeIcon = 3;
                break;

            case ST_LDAP_CONTAINER:
                idxScopeIcon = 4;
                break;

            case ST_USER_ENTERED_DOWNLEVEL_SCOPE:
            case ST_USER_ENTERED_UPLEVEL_SCOPE:
                ASSERT(0 && "CLookInDlg::_AddScopes: not expecting user entered scope types to be displayed");
                break;

            case ST_XFOREST:
                idxScopeIcon = reinterpret_cast<CXForestScope *>
                                        (it->get())->IsFederated()?5:6;
                break;

            default:
                break;
            }

            if (idxScopeIcon < ULONG_MAX)
            {
                tvis.itemex.mask |= (TVIF_IMAGE | TVIF_SELECTEDIMAGE);
                tvis.itemex.iImage = idxScopeIcon;
                tvis.itemex.iSelectedImage = tvis.itemex.iImage;
            }
        }

        //
        // Insert current scope in treeview
        //

        HTREEITEM hti = TreeView_InsertItem(hwndTv, &tvis);

        //
        // If we haven't already, check to see if current scope is the
        // starting scope, and if so, have the treeview expand and scroll
        // so that it is visible and select it.
        //

        if (!m_htiStartingScope)
        {
            if (m_rpSelectedScope.get())
            {
                // Caller gave us a non-NULL starting scope, use that

                if (it->get() == m_rpSelectedScope.get())
                {
                    // cur scope matches caller's starting scope
                    m_htiStartingScope = hti;
                }
            }
            else if (it->get() == &m_rop.GetScopeManager().GetStartingScope())
            {
                // cur scope matches starting scope specified by initinfo
                m_htiStartingScope = hti;
            }
        }

        //
        // If current scope already has children, recurse to add them
        //

        vector<RpScope>::const_iterator itChildBegin;
        vector<RpScope>::const_iterator itChildEnd;

        it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

        _AddScopes(hti, itChildBegin, itChildEnd);
    }

    //
    // Ask treeview to sort the children of the parent node to which we
    // just added some children (but don't sort stuff under the root)
    //

    if (hRoot && itBegin != itEnd)
    {
        VERIFY(TreeView_SortChildren(hwndTv, hRoot, RESERVED_MUST_BE_ZERO));
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnCommand
//
//  Synopsis:   Handle OK and Cancel
//
//  Arguments:  [wParam] - from WM_COMMAND
//              [lParam] - from WM_COMMAND
//
//  Returns:    TRUE if command handled (i.e. if it was from OK or Cancel),
//              FALSE otherwise
//
//  History:    05-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDOK:
    {
        HWND hwndTv = _hCtrl(IDC_LOOK_IN_TV);
        HTREEITEM hItem = TreeView_GetSelection(hwndTv);

        if (hItem)
        {
            BOOL fAllowClose = TRUE;

            TVITEMEX tvi;
            tvi.mask = TVIF_PARAM;
            tvi.hItem = hItem;
            tvi.lParam = 0;

            if (TreeView_GetItem(hwndTv, &tvi))
            {
                ASSERT(tvi.lParam);
                CScope *pScope = reinterpret_cast<CScope *>((ULONG_PTR)tvi.lParam);

                ASSERT(m_rop.GetScopeManager().IsValidScope(pScope));
                Dbg(DEB_TRACE,
                    "UA: (LookInDlg) hit OK, selected scope is %ws\n",
                    pScope->GetDisplayName().c_str());

                //
                // Test access to the selected scope.  If it fails, notify
                // user and do not allow changing to it.
                //

                ULONG ulFlags;
                HRESULT hr = pScope->GetResultantFilterFlags(m_hwnd,
                                                             &ulFlags);

                if (SUCCEEDED(hr))
                {
                    m_rpSelectedScope = pScope;
                }
                else
                {
                    String strError = GetErrorMessage(hr);
                    PopupMessage(m_hwnd,
                                 IDS_SCOPE_ERROR,
                                 pScope->GetDisplayName().c_str(),
                                 strError.c_str());
                    fAllowClose = FALSE;
                }
            }

            if (fAllowClose)
            {
                EndDialog(GetHwnd(), TRUE);
            }
        }
        else
        {
            Dbg(DEB_TRACE, "UA: (LookInDlg) hit OK, no selected scope\n");
            DBG_OUT_LASTERROR;
            EndDialog(GetHwnd(), FALSE);
        }
        break;
    }

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (LookInDlg) hit Cancel\n");
        EndDialog(GetHwnd(), FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CLookInDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnNotify
//
//  Synopsis:   Handle notification of changes in the dialog
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    //TRACE_METHOD(CLookInDlg, _OnNotify);

    LPNMTREEVIEW pnmtv = reinterpret_cast<LPNMTREEVIEW> (lParam);
    BOOL         fReturn = FALSE;

#if (DBG == 1)
    switch (pnmtv->hdr.code)
    {
    case TVN_ITEMEXPANDING:
    {
        PWSTR pwzAction;

        switch (pnmtv->action)
        {
        case TVE_COLLAPSE:
            pwzAction = L"collapse";
            break;

        case TVE_EXPAND:
            pwzAction = L"expand";
            break;

        case TVE_TOGGLE:
            pwzAction = L"toggle";
            break;

        case TVE_EXPANDPARTIAL:
            pwzAction = L"expand partial";
            break;

        case TVE_COLLAPSERESET:
            pwzAction = L"collapse reset";
            break;

        default:
            pwzAction = L"<undefined action code>";
            break;
        }

        String strItemName = DbgTvTextFromHandle(pnmtv->hdr.hwndFrom,
                                                 pnmtv->itemNew.hItem);

        Dbg(DEB_TRACE,
            "UA: %ws node %ws\n",
            pwzAction,
            strItemName.c_str());
        break;
    }

    case TVN_SELCHANGED:
    {
        PWSTR pwzMethod;

        switch (pnmtv->action)
        {
        case TVC_BYKEYBOARD:
            pwzMethod = L"keyboard";
            break;

        case TVC_BYMOUSE:
            pwzMethod = L"mouse";
            break;

        case TVC_UNKNOWN:
            pwzMethod = L"unknown method";
            break;

        default:
            pwzMethod = L"<undefined action code>";
            break;
        }

        String strItemName = DbgTvTextFromHandle(pnmtv->hdr.hwndFrom,
                                                 pnmtv->itemNew.hItem);

        Dbg(DEB_TRACE,
            L"UA: selected item %ws by %ws\n",
            strItemName.c_str(),
            pwzMethod);
        break;
    }
    }
#endif // (DBG == 1)


    switch (pnmtv->hdr.code)
    {
    case TVN_ITEMEXPANDING:
        if (pnmtv->action == TVE_EXPAND)
        {
            CScope *pScope = reinterpret_cast<CScope*>(pnmtv->itemNew.lParam);

            ASSERT(m_rop.GetScopeManager().IsValidScope(pScope));
            CWaitCursor Hourglass;

            vector<RpScope>::const_iterator itCur;
            vector<RpScope>::const_iterator itEnd;

            // note this means cdlg itself should dispatch to password prompt
            pScope->Expand(m_hwnd, &itCur, &itEnd);

            // now add the scope's children to the tv underneath the scope.

            if (itCur != itEnd)
            {
                _AddScopes(pnmtv->itemNew.hItem, itCur, itEnd);

                // set the expanded once flag so we know not to expand again

                TVITEMEX tvi;

                tvi.mask = TVIF_HANDLE | TVIF_STATE;
                tvi.hItem = pnmtv->itemNew.hItem;
                tvi.state = tvi.stateMask = TVIS_EXPANDEDONCE;
                TreeView_SetItem(pnmtv->hdr.hwndFrom, &tvi);
            }
            else if (!pScope->MightHaveAdditionalChildScopes()
                     && !pScope->GetCurrentImmediateChildCount())
            {
                // no children, get rid of plus sign for this item

                TVITEMEX tvi;

                tvi.mask = TVIF_HANDLE | TVIF_CHILDREN;
                tvi.cChildren = 0;
                tvi.hItem = pnmtv->itemNew.hItem;
                TreeView_SetItem(pnmtv->hdr.hwndFrom, &tvi);
                RedrawWindow(pnmtv->hdr.hwndFrom, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnSysColorChange
//
//  Synopsis:   Forward the system color change notification message to the
//              treeview.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookInDlg::_OnSysColorChange()
{
    TRACE_METHOD(CLookInDlg, _OnSysColorChange);

    SendMessage(_hCtrl(IDC_LOOK_IN_TV), WM_SYSCOLORCHANGE, 0, 0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::DoModal
//
//  Synopsis:   Invoke the Loook In dialog as a modal dialog with respect
//              to [hwndParent] and block until it is closed.
//
//  Arguments:  [hwndParent] - parent window
//              [pCurScope]  - current scope
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookInDlg::DoModal(
    HWND hwndParent,
    CScope *pCurScope) const
{
    TRACE_METHOD(CLookInDlg, DoModal);

    m_rpSelectedScope = pCurScope;
    _DoModalDlg(hwndParent, IDD_LOOK_IN);
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnMinMaxInfo
//
//  Synopsis:   Fill [lpmmi] with the minimum allowed size of this dialog
//
//  Arguments:  [lpmmi] - from WM_GETMINMAXINFO
//
//  Returns:    FALSE (message processed)
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnMinMaxInfo(
    LPMINMAXINFO lpmmi)
{
    lpmmi->ptMinTrackSize.x = m_cxMin;
    lpmmi->ptMinTrackSize.y = m_cyMin;
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnSize
//
//  Synopsis:   Handle a WM_SIZE message by resizing this dialog
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnSize(
    WPARAM wParam,
    LPARAM lParam)
{
    WORD nWidth = LOWORD(lParam);  // width of client area
    WORD nHeight = HIWORD(lParam); // height of client area

    //
    // Move the OK/Cancel buttons so they're always at lower right
    // corner of dialog.
    //

    RECT rcDlg;
    GetClientRect(m_hwnd, &rcDlg);

    if (!m_cxFrameLast || !m_cyFrameLast)
    {
        Dbg(DEB_TRACE, "FrameLast not set yet, returning\n");
        m_cxFrameLast = rcDlg.right;
        m_cyFrameLast = rcDlg.bottom;
        return TRUE;
    }

    RECT rcCancel;
    GetWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDCANCEL),
                 NULL,
                 rcDlg.right - WindowRectWidth(rcCancel) - m_cxSeparation,
                 rcDlg.bottom - WindowRectHeight(rcCancel) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcOK;
    GetWindowRect(_hCtrl(IDOK), &rcOK);
    _GetChildWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDOK),
                 NULL,
                 rcCancel.left - WindowRectWidth(rcOK) - m_cxSeparation,
                 rcDlg.bottom - WindowRectHeight(rcOK) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    // Calculate the new width of the treeview
    // control by adding the delta (which may be negative) of this size
    // operation to the current width of the control.
    //

    HWND hwndTv = _hCtrl(IDC_LOOK_IN_TV);

    if (hwndTv)
    {
        RECT rcTv;

        VERIFY(GetWindowRect(hwndTv, &rcTv));

        LONG cxNew = WindowRectWidth(rcTv) + rcDlg.right - m_cxFrameLast;
        ASSERT(cxNew > 0);

        LONG cyDelta = rcDlg.bottom - m_cyFrameLast;

        SetWindowPos(hwndTv,
                     NULL,
                     0,
                     0,
                     cxNew,
                     WindowRectHeight(rcTv) + cyDelta,
                     SWP_NOMOVE
                     | SWP_NOOWNERZORDER
                     | SWP_NOZORDER);
    }
    else
    {
        DBG_OUT_HRESULT(E_FAIL);
    }

    //
    // Size gripper goes in bottom right corner
    //

    RECT rc;

    _GetChildWindowRect(_hCtrl(IDC_SIZEGRIP), &rc);

    SetWindowPos(_hCtrl(IDC_SIZEGRIP),
                 NULL,
                 nWidth - (rc.right - rc.left),
                 nHeight - (rc.bottom - rc.top),
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOZORDER);

    m_cxFrameLast = rcDlg.right;
    m_cyFrameLast = rcDlg.bottom;
    return FALSE;
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookInDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CLookInDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\oleglue.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       oleglue.cxx
//
//  Contents:   Miscellaneous functions required for implementing an ole
//              in-proc server
//
//  History:    12-04-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Create registry keys and values for the DS Object Picker.
//
//  Returns:    SELFREG_E_TYPELIB - couldn't register typelib
//              SELFREG_E_CLASS   - couldn't register class
//
//  History:    09-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllRegisterServer()
{
    TRACE_FUNCTION(DllRegisterServer);

    HRESULT     hr = SELFREG_E_CLASS;   // ASSUME FAILURE
    CSafeReg    shk;    // reused several times
    CSafeReg    shkCLSID;
    CSafeReg    shkNodeTypes;

    do
    {
        //
        // Create the CLSID entries
        //

        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        String wszModuleFilename;

        {
            CSafeReg    shkServer;

            hr = shkCLSID.Create(c_wzCLSID, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            (void) shk.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)c_wzClsidComment,
                                sizeof(c_wzClsidComment));

            hr = shk.Create(L"InprocServer32", &shkServer);
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();

            // NTRAID#NTBUG9-550604-2002/02/20-lucios. 
            hr = MyGetModuleFileName(g_hinst, wszModuleFilename);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shkServer.SetValue(NULL,
                                    REG_SZ,
                                    (CONST BYTE *) wszModuleFilename.c_str(),
                                    sizeof(WCHAR) * ((ULONG)wszModuleFilename.length() + 1));
            BREAK_ON_FAIL_HRESULT(hr);


            hr = shkServer.SetValue(L"ThreadingModel",
                                    REG_SZ,
                                    (CONST BYTE *) c_wzThreadingModel,
                                    sizeof(c_wzThreadingModel));
            BREAK_ON_FAIL_HRESULT(hr);
        }

    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Delete all registry entries made by DllRegisterServer.
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllUnregisterServer()
{
    TRACE_FUNCTION(DllUnregisterServer);

    HRESULT     hr = S_OK;
    CSafeReg    shkCLSID;

    //
    // Delete the CLSID entries
    //

    do
    {
        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        // clsid for event viewer snapin

        hr = shkCLSID.DeleteTree(c_wzCLSID);
        CHECK_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Return S_OK if refcount for dll is 0.
//
//  Returns:    S_OK or S_FALSE
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    TRACE_FUNCTION(DllCanUnloadNow);
    return CDll::CanUnloadNow();
}



//+--------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Return the requested class factory.
//
//  Arguments:  [rclsid] - class desired
//              [riid]   - interface on class factory desired
//              [ppv]    - filled with itf pointer to class factory
//
//  Returns:    S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//  Modifies:   *[ppv]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    TRACE_FUNCTION(DllGetClassObject);
    IUnknown *punk = NULL;
    HRESULT hr = S_OK;

    *ppv = NULL;

    if (IsEqualCLSID(rclsid, CLSID_DsObjectPicker))
    {
        punk = new CDsObjectPickerCF;

        if (punk)
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
        }
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        DBG_OUT_HRESULT(hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\op.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       op.cxx
//
//  Contents:   object picker entry point
//
//  Classes:    CObjectPicker
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CObjectPicker)
#define __THIS_FILE__   L"op"


ULONG
GetMachineNtVer(
    PCWSTR pwzMachine);

//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::CObjectPicker
//
//  Synopsis:   ctor
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CObjectPicker::CObjectPicker():
    m_cRefs(1),
    m_hwndParent(NULL),
    m_pExternalCustomizer(NULL),
    m_mcTargetComputer(MC_UNKNOWN),
    m_fTargetComputerIsLocal(FALSE),
    m_mcPreviousTargetComputer(MC_UNKNOWN),
    m_fPreviousTargetComputerIsLocal(FALSE),
    m_flInitInfoOptions(0),
    m_pScopeManager(NULL),
    m_pQueryEngine(NULL),
    m_pFilterManager(NULL),
    m_pAttributeManager(NULL),
    m_pAdminCustomizer(NULL),
    m_pBaseDlg(NULL)
{
    TRACE_CONSTRUCTOR(CObjectPicker);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CObjectPicker);

    // NTRAID#NTBUG9-548146-2002/02/20-lucios. Pending fix.
    InitializeCriticalSection(&m_csOleFreeThreading);

    //
    // Initialize globals in a thread-safe way.  Even though this DLL is
    // apartment model only, that only means one thread can access each
    // interface instance.  It doesn't preclude the creation of multiple
    // objects in different threads, each of which will try to init the
    // globals.
    //

    CAutoCritSec Lock(&g_csGlobalVarsCreation);

    if (g_pBinder)
    {
        ASSERT(g_pADsPath); // all globals created at once

        g_pBinder->AddRef();
        g_pADsPath->AddRef();
    }
    else
    {
        g_pBinder = new CBinder;
        g_pADsPath = new CADsPathWrapper;
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::~CObjectPicker
//
//  Synopsis:   dtor
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CObjectPicker::~CObjectPicker()
{
    TRACE_DESTRUCTOR(CObjectPicker);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CObjectPicker);
    ASSERT(!m_pExternalCustomizer);

    delete m_pScopeManager;
    m_pScopeManager = NULL;

    delete m_pQueryEngine;
    m_pQueryEngine = NULL;

    delete m_pFilterManager;
    m_pFilterManager = NULL;

    delete m_pAttributeManager;
    m_pAttributeManager = NULL;

    delete m_pAdminCustomizer;
    m_pAdminCustomizer = NULL;

    delete m_pBaseDlg;
    m_pBaseDlg = NULL;

    CAutoCritSec Lock(&g_csGlobalVarsCreation);

    if (g_pBinder)
    {
        ASSERT(g_pADsPath); // all globals created at once

        if (!g_pBinder->Release())
        {
            g_pBinder = NULL;
        }

        if (!g_pADsPath->Release())
        {
            g_pADsPath = NULL;
        }
    }

    DeleteCriticalSection(&m_csOleFreeThreading);
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::InitCopyFree
//
//  Synopsis:   Frees structure created by InitCopy
//
//  Arguments:  dest - pointer to structure to free
//
//  Returns:    void
//
//  History:    05-23-2002   Lucios   Created
//
//---------------------------------------------------------------------------
void CObjectPicker::InitCopyFree
(
    PDSOP_INIT_INFO *dest
)
{
    if(*dest==NULL) return;
    for(ULONG t=0;t<(*dest)->cDsScopeInfos;t++)
    {
        delete [] (*dest)->aDsScopeInfos[t].pwzADsPath;
        delete [] (*dest)->aDsScopeInfos[t].pwzDcName;
    }
    delete [] (*dest)->aDsScopeInfos;

    for(ULONG t=0;t<(*dest)->cAttributesToFetch;t++)
    {
        delete [] (*dest)->apwzAttributeNames[t];
    }

    delete [] (*dest)->apwzAttributeNames;

    delete [] (*dest)->pwzTargetComputer;

    delete *dest;
    *dest=0;

}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::InitCopy
//
//  Synopsis:   Copy dest into src to catch exceptions due to invalid args
//
//  Arguments:  dest - returned structure allocated with new that will
//                     receive a deep copy of src
//              src - pointer to the structure to be copied
//
//  Returns:    S_OK or E_INVALIDARG
//
//  History:    05-23-2002   Lucios   Created
//
//---------------------------------------------------------------------------
HRESULT CObjectPicker::InitCopy
(
    PDSOP_INIT_INFO *dest,
    PDSOP_INIT_INFO src
)
{
    if(!src) return E_INVALIDARG;

    __try
    {
        *dest=new DSOP_INIT_INFO;
        **dest=*src;
        
        // We will grow these as we succed in our alocations
        // , so that we only free what we allocate
        (*dest)->cDsScopeInfos=0;
        (*dest)->cAttributesToFetch=0;

        NewDupStr((PWSTR *)&(*dest)->pwzTargetComputer,src->pwzTargetComputer);
        
        (*dest)->apwzAttributeNames=new 
                PCWSTR[src->cAttributesToFetch];

        for(ULONG t=0;t<src->cAttributesToFetch;t++)
        {
            NewDupStr
            (
                (PWSTR *)&(*dest)->apwzAttributeNames[t],
                src->apwzAttributeNames[t]
            );
            (*dest)->cAttributesToFetch++;
        }

        (*dest)->aDsScopeInfos=new 
                DSOP_SCOPE_INIT_INFO[src->cDsScopeInfos];

        for(ULONG t=0;t<src->cDsScopeInfos;t++)
        {
            (*dest)->aDsScopeInfos[t]=src->aDsScopeInfos[t];
            NewDupStr
            (
                (PWSTR *)&(*dest)->aDsScopeInfos[t].pwzADsPath,
                src->aDsScopeInfos[t].pwzADsPath
            );
            NewDupStr
            (
                (PWSTR *)&(*dest)->aDsScopeInfos[t].pwzDcName,
                src->aDsScopeInfos[t].pwzDcName
            );
            (*dest)->cDsScopeInfos++;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return E_INVALIDARG;
    }
    return S_OK; 
}


//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::Initialize
//
//  Synopsis:   Validate and copy the passed-in structure.
//
//  Arguments:  [pInitInfo] - initialization information
//
//  Returns:    S_OK, E_INVALIDARG, or E_OUTOFMEMORY
//
//  History:    08-29-1998   DavidMun   Created
//
//---------------------------------------------------------------------------


STDMETHODIMP
CObjectPicker::Initialize(
    PDSOP_INIT_INFO pInitInfoArg)
{
    TRACE_METHOD(CObjectPicker, Initialize);
    PDSOP_INIT_INFO pInitInfo=NULL;

    HRESULT hr = S_OK;
    ULONG   i;

    CAutoCritSec Lock(&m_csOleFreeThreading);
 
    try
    {
        do
        {

            hr=InitCopy(&pInitInfo,pInitInfoArg);
            BREAK_ON_FAIL_HRESULT(hr);

            //
            // Create objects that manage various duties; if they already
            // exist clear them of data from any previous initialization
            // or use.
            //

            if (!m_pScopeManager)
            {
                m_pScopeManager = new CScopeManager(*this);
            }
            else
            {
                m_pScopeManager->Clear();
            }

            if (!m_pQueryEngine)
            {
                m_pQueryEngine = new CQueryEngine(*this);
                m_pQueryEngine->Initialize();
            }
            else
            {
                m_pQueryEngine->Clear();
            }

            if (!m_pFilterManager)
            {
                m_pFilterManager = new CFilterManager(*this);
            }
            else
            {
                m_pFilterManager->Clear();
            }

            // note attribute manager is only cleared if target machine changes
            if (!m_pAttributeManager)
            {
                m_pAttributeManager = new CAttributeManager(*this);
            }

            if (!m_pAdminCustomizer)
            {
                m_pAdminCustomizer = new CAdminCustomizer(*this);
            }
            else
            {
                m_pAdminCustomizer->Clear();
            }

            if (!m_pBaseDlg)
            {
                m_pBaseDlg = new CBaseDlg(*this);
            }
            else
            {
                m_pBaseDlg->Clear();
            }

            m_vstrAttributesToFetch.clear();

            _ClearFlag(CDSOP_INIT_SUCCEEDED);

#if (DBG == 1)
            _DumpInitInfo(pInitInfo);
#endif // (DBG == 1)

            for (i = 0; i < pInitInfo->cAttributesToFetch; i++)
            {
                PCWSTR pwzAttrName = pInitInfo->apwzAttributeNames[i];
                m_vstrAttributesToFetch.push_back(pwzAttrName);
            }

            m_flInitInfoOptions = pInitInfo->flOptions;

            //
            // If target machine is not the same as the previous call, or if
            // this is the first call, determine the configuration
            //


            BOOL fLastTargetIsLocalMachine = m_fTargetComputerIsLocal;
            m_fTargetComputerIsLocal =
                IsLocalComputername(pInitInfo->pwzTargetComputer);

            if ((m_mcTargetComputer == MC_UNKNOWN) ||
                (m_fTargetComputerIsLocal && !fLastTargetIsLocalMachine) ||
                (!m_fTargetComputerIsLocal && fLastTargetIsLocalMachine) ||
                (!m_fTargetComputerIsLocal &&
                 !fLastTargetIsLocalMachine &&
                 m_strTargetComputer.icompare(pInitInfo->pwzTargetComputer)))
            {
                if (pInitInfo->pwzTargetComputer && *pInitInfo->pwzTargetComputer)
                {
                    m_strPreviousTargetComputer = m_strTargetComputer;
                    m_strTargetComputer = pInitInfo->pwzTargetComputer;
                    m_strTargetComputer.strip(String::LEADING, L'\\');
                    Dbg(DEB_TRACE,
                        "Target computer is %s\n",
                        m_strTargetComputer.c_str());
                }
                else
                {
                    WCHAR wzLocalComputer[MAX_COMPUTERNAME_LENGTH + 1];
                    DWORD cchSize = ARRAYLEN(wzLocalComputer);

                    // NTRAID#NTBUG9-550683-2002/02/20-lucios. Pending fix.
                    VERIFY(GetComputerName(wzLocalComputer, &cchSize));
                    m_fPreviousTargetComputerIsLocal = m_fTargetComputerIsLocal;
                    m_fTargetComputerIsLocal = TRUE;
                    m_strPreviousTargetComputer = m_strTargetComputer;
                    m_strTargetComputer = wzLocalComputer;

                    Dbg(DEB_TRACE,
                        "Target computer NULL, using '%s'\n",
                        m_strTargetComputer.c_str());
                }

                m_pAttributeManager->Clear();

                hr = _InitializeMachineConfig();

                if (FAILED(hr))
                {
                    DBG_OUT_HRESULT(hr);

                    if (m_strTargetComputer.length())
                    {
                        PopupMessage(GetForegroundWindow(),
                                     IDS_INIT_FAILED_MACHINE_CONFIG,
                                     m_strTargetComputer.c_str());
                    }
                    else
                    {
                        PopupMessage(GetForegroundWindow(),
                                     IDS_INIT_FAILED_LOCAL_MACHINE_CONFIG);
                    }
                    break;
                }

                if (m_mcTargetComputer == MC_JOINED_NT5 ||
                    m_mcTargetComputer == MC_NT5_DC)
                {
                     m_RootDSE.Init(m_strTargetDomainDns.c_str(),
                                         m_strTargetForest.c_str());
                }
            }

            hr = m_pScopeManager->Initialize(pInitInfo);
            BREAK_ON_FAIL_HRESULT(hr);

            _SetFlag(CDSOP_INIT_SUCCEEDED);
        } while (0);
    }
    catch (const exception &e)
    {
        hr = E_OUTOFMEMORY;
        Dbg(DEB_ERROR, "Caught %s\n", e.what());
    }

    
    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
    }

    InitCopyFree(&pInitInfo);

    return hr;
}



#if (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Function:   _DumpInOptForm
//
//  Synopsis:   Dump to the debugger the scope flags in a form that can be
//              copied and pasted into a text file that the unit test can
//              read.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
_DumpInOptForm(
    PDSOP_SCOPE_INIT_INFO pCur,
    ULONG flScope)
{
    if (pCur->flType & flScope)
    {
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%#x\n", flScope);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%#x\n", pCur->flScope);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.Uplevel.flBothModes);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.Uplevel.flMixedModeOnly);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.Uplevel.flNativeModeOnly);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.flDownlevel);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "\"%ws\"\n", pCur->pwzDcName);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "\"%ws\"\n", pCur->pwzADsPath);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::_DumpInitInfo
//
//  Synopsis:   Dump initialization structure caller supplied to the debugger
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CObjectPicker::_DumpInitInfo(
    PCDSOP_INIT_INFO pInitInfo)
{
    Dbg(DEB_TRACE, "\n");

    String strDateTime;
    WCHAR  wzDateTime[12];

    int iRet = GetDateFormat(NULL,
                             0,
                             NULL,
                             L"MM'/'dd'/'yyyy",
                             wzDateTime,
                             ARRAYLEN(wzDateTime));

    if (iRet)
    {
        strDateTime = wzDateTime;
    }

    iRet = GetTimeFormat(NULL,
                         0,
                         NULL,
                         L"HH':'mm':'ss",
                         wzDateTime,
                         ARRAYLEN(wzDateTime));

    if (iRet)
    {
        if (!strDateTime.empty())
        {
            strDateTime += L" ";
        }
        strDateTime += wzDateTime;
    }

    Dbg(DEB_TRACE, "  %ws\n", strDateTime.c_str());

    WCHAR wzLocalComputerNB[LM20_CNLEN + 1] = L"";
    ULONG cchLocalComputerNB = ARRAYLEN(wzLocalComputerNB);
    //REVIEWED-2002-02-21-lucios.
    BOOL fOk = GetComputerName(wzLocalComputerNB, &cchLocalComputerNB);

    if (fOk)
    {
        Dbg(DEB_TRACE, "  Local Computer '%ws'\n", wzLocalComputerNB);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    OSVERSIONINFOEX VerInfo;
    //REVIEWED-2002-02-21-lucios.
    ZeroMemory(&VerInfo, sizeof VerInfo);
    VerInfo.dwOSVersionInfoSize = sizeof VerInfo;

    fOk = GetVersionEx(reinterpret_cast<OSVERSIONINFO *>(&VerInfo));

    if (fOk)
    {
        PCWSTR pwzProductType;

        switch (VerInfo.wProductType)
        {
        case VER_NT_WORKSTATION:
            pwzProductType = L"Workstation";
            break;

        case VER_NT_DOMAIN_CONTROLLER:
            pwzProductType = L"Domain Controller";
            break;

        case VER_NT_SERVER:
            pwzProductType = L"Server";
            break;

        default:
            pwzProductType = L"(unknown product type)";
            break;
        }

        if (VerInfo.szCSDVersion && *VerInfo.szCSDVersion)
        {
            Dbg(DEB_TRACE,
                "  Windows %ws %u.%u build %u %ws SP version %u.%u\n",
                pwzProductType,
                VerInfo.dwMajorVersion,
                VerInfo.dwMinorVersion,
                VerInfo.dwBuildNumber,
                VerInfo.szCSDVersion,
                VerInfo.wServicePackMajor,
                VerInfo.wServicePackMinor);
        }
        else
        {
            Dbg(DEB_TRACE, "  Windows %ws version %u.%u build %u\n",
                pwzProductType,
                VerInfo.dwMajorVersion,
                VerInfo.dwMinorVersion,
                VerInfo.dwBuildNumber);
        }
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    WCHAR wzUserName[LM20_DNLEN + 1 + LM20_UNLEN + 1] = L""; // +1 for \ +1 for NUL
    ULONG cchUserName = ARRAYLEN(wzUserName);
    //REVIEWED-2002-02-21-lucios.
    fOk = GetUserNameEx(NameSamCompatible, wzUserName, &cchUserName);

    if (fOk)
    {
        Dbg(DEB_TRACE, "  Logged on as '%ws'\n", wzUserName);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    Dbg(DEB_TRACE,
        "  Target Computer '%ws'\n",
        CHECK_NULL(pInitInfo->pwzTargetComputer));

    DumpOptionFlags(pInitInfo->flOptions);

    ULONG i;
    for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
    {
        PDSOP_SCOPE_INIT_INFO pCur = &pInitInfo->aDsScopeInfos[i];
        Dbg(DEB_TRACE, "\n");
        DumpScopeType(pCur->flType);
        DumpScopeFlags(pCur->flScope);
        DumpFilterFlags(pCur->FilterFlags);

        if (pCur->pwzDcName)
        {
            Dbg(DEB_TRACE, "  DC Name '%ws'\n", pCur->pwzDcName);
        }
        if (pCur->pwzADsPath)
        {
            Dbg(DEB_TRACE, "  ADsPath '%ws'\n", pCur->pwzADsPath);
        }
    }

    // dump in format opt.exe can read
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "\"%ws\"\n", pInitInfo->pwzTargetComputer);
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%#x\n", pInitInfo->flOptions);

    String strAttr(L"\"");

    for (i = 0; i < pInitInfo->cAttributesToFetch; i++)
    {
        strAttr += pInitInfo->apwzAttributeNames[i];

        if (i < pInitInfo->cAttributesToFetch - 1)
        {
            strAttr += L"; ";
        }
    }
    strAttr += L"\"";
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%ws\n", strAttr.c_str());
    ULONG cIndividualScopes = 0;

    for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
    {
        PDSOP_SCOPE_INIT_INFO pCur = &pInitInfo->aDsScopeInfos[i];

        if (pCur->flType & ST_TARGET_COMPUTER)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_UPLEVEL_JOINED_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_DOWNLEVEL_JOINED_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_ENTERPRISE_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_GLOBAL_CATALOG)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_EXTERNAL_UPLEVEL_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_EXTERNAL_DOWNLEVEL_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_WORKGROUP)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_USER_ENTERED_UPLEVEL_SCOPE)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_USER_ENTERED_DOWNLEVEL_SCOPE)
        {
            cIndividualScopes++;
        }
    }
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%u\n", cIndividualScopes);

    for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
    {
        PDSOP_SCOPE_INIT_INFO pCur = &pInitInfo->aDsScopeInfos[i];

        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_TARGET_COMPUTER             );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN       );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN     );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN           );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_GLOBAL_CATALOG              );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN     );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN   );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_WORKGROUP                   );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE  );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE);
    }
}
#endif // (DBG == 1)





//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::_InitializeMachineConfig
//
//  Synopsis:   Determine the configuration of the target computer.
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Configuration in this sense means whether the target
//              computer is joined to an NT4 domain, an NT5 domain, in a
//              workgroup, etc.
//
//---------------------------------------------------------------------------

HRESULT
CObjectPicker::_InitializeMachineConfig()
{
    TRACE_METHOD(CObjectPicker, _InitializeMachineConfig);

    HRESULT                             hr = S_OK;
    ULONG                               ulResult;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    PDOMAIN_CONTROLLER_INFO             pdci = NULL;
    RpIADs                              rpADs;

    do
    {
        m_mcPreviousTargetComputer = m_mcTargetComputer;
        m_mcTargetComputer = MC_UNKNOWN;
        PCWSTR pwzMachine;

        if (m_fTargetComputerIsLocal)
        {
            pwzMachine = NULL;
        }
        else
        {
            pwzMachine = m_strTargetComputer.c_str();
            ASSERT(*pwzMachine);
        }

        {
            TIMER("DsRoleGetPrimaryDomainInformation(%ws)",
                  CHECK_NULL(pwzMachine));

            ulResult = DsRoleGetPrimaryDomainInformation(pwzMachine,
                                                         DsRolePrimaryDomainInfoBasic,
                                                         (PBYTE *)&pDsRole);
        }
        if (pwzMachine && ulResult == ERROR_ACCESS_DENIED)
        {
            Dbg(DEB_TRACE,
                "DsRoleGetPrimaryDomainInformation returned ERROR_ACCESS_DENIED, establishing connection\n");

            //
            // Establish a connection with remote machine using WinNT provider,
            // and try again.
            //

            WCHAR wzComputerAdsPath[MAX_PATH];

            // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
            wsprintf(wzComputerAdsPath, L"WinNT://%ws,Computer", pwzMachine);

            hr = g_pBinder->BindToObject(GetForegroundWindow(),
                                         wzComputerAdsPath,
                                         IID_IADs,
                                         (void **) &rpADs);
            BREAK_ON_FAIL_HRESULT(hr);

            TIMER("DsRoleGetPrimaryDomainInformation2");

            ulResult =
                DsRoleGetPrimaryDomainInformation(pwzMachine,
                                                  DsRolePrimaryDomainInfoBasic,
                                                  (PBYTE *)&pDsRole);
        }

        if (ulResult != NO_ERROR)
        {
            DBG_OUT_LRESULT(ulResult);
            hr = HRESULT_FROM_WIN32(ulResult);
            break;
        }
        else if(NULL == pDsRole)
        {
            DBG_OUT_LRESULT(ERROR_UNEXP_NET_ERR);
            Dbg(DEB_TRACE,"Network issue found in WinSE Raid 21714, Whistler Raid 476297");
            hr = HRESULT_FROM_WIN32(ERROR_UNEXP_NET_ERR);
            break;
        }

        
        ASSERT(pDsRole);

        Dbg(DEB_TRACE, "DsRoleGetPrimaryDomainInformation returned:\n");
        Dbg(DEB_TRACE, "  DomainNameFlat: %ws\n", CHECK_NULL(pDsRole->DomainNameFlat));
        Dbg(DEB_TRACE, "  DomainNameDns: %ws\n", CHECK_NULL(pDsRole->DomainNameDns));
        Dbg(DEB_TRACE, "  DomainForestName: %ws\n", CHECK_NULL(pDsRole->DomainForestName));

        //
        // If machine is in a workgroup, we're done.
        //

        if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
            pDsRole->MachineRole == DsRole_RoleStandaloneServer)
        {
            Dbg(DEB_TRACE, "Target machine is not joined to a domain\n");

            m_mcTargetComputer = MC_IN_WORKGROUP;
            break;
        }

        if (pDsRole->DomainNameFlat)
        {
            m_strTargetDomainFlat = pDsRole->DomainNameFlat;
        }

        //
        // Target machine is joined to a domain.  Find out if it's joined
        // to an NT4 or an NT5 domain by getting the name of a DC, and
        // requesting that we get one which supports DS.
        //

        PWSTR pwzDomainNameForDsGetDc;
        ULONG flDsGetDc = DS_DIRECTORY_SERVICE_PREFERRED;

        if (pDsRole->DomainNameDns)
        {
            pwzDomainNameForDsGetDc = pDsRole->DomainNameDns;
            flDsGetDc |= DS_IS_DNS_NAME;
            Dbg(DEB_TRACE,
                "DsGetDcName(Domain=%ws, flags=DS_IS_DNS_NAME | DS_DIRECTORY_SERVICE_PREFERRED)\n",
                CHECK_NULL(pwzDomainNameForDsGetDc));
        }
        else
        {
            pwzDomainNameForDsGetDc = pDsRole->DomainNameFlat;
            flDsGetDc |= DS_IS_FLAT_NAME;
            Dbg(DEB_TRACE,
                "DsGetDcName(Domain=%ws, flags=DS_IS_FLAT_NAME | DS_DIRECTORY_SERVICE_PREFERRED)\n",
                CHECK_NULL(pwzDomainNameForDsGetDc));
        }

        ulResult = DsGetDcName(NULL,  // per CliffV this should ALWAYS be NULL
                               pwzDomainNameForDsGetDc,
                               NULL,
                               NULL,
                               flDsGetDc,
                               &pdci);

        if (ulResult != NO_ERROR)
        {
            m_mcTargetComputer = MC_NO_NETWORK;
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws returned %#x, treating target machine as no-net\n",
                pwzDomainNameForDsGetDc,
                ulResult);
            break;
        }

        if (pdci->Flags & DS_DS_FLAG)
        {
            Dbg(DEB_TRACE,
                "DsGetDcName returned DS DC for domain %ws, asking for DNS name\n",
                pwzDomainNameForDsGetDc);

            PDOMAIN_CONTROLLER_INFO pdci2 = NULL;

            ulResult = DsGetDcName(NULL,
                                   pwzDomainNameForDsGetDc,
                                   NULL,
                                   NULL,
                                   flDsGetDc | DS_RETURN_DNS_NAME,
                                   &pdci2);


            if (ulResult == NO_ERROR)
            {
                NetApiBufferFree(pdci);
                pdci = pdci2;
            }
            else
            {
                ASSERT(!pdci2);
            }
        }

        //
        // If TCP/IP is not installed on local machine then DsGetDcName for
        // DNS name will fail.  Also, no LDAP or GC scopes may be used.
        // Pretend we're joined to an NT4 domain so WinNT provider will be
        // used for domain scopes.
        //

        if (ulResult == ERROR_NO_SUCH_DOMAIN)
        {
            Dbg(DEB_TRACE,
                "Attempting to get DNS name for DS DC %ws failed, treating target machine as joined to NT4 domain\n",
                pwzDomainNameForDsGetDc);

            m_mcTargetComputer = MC_JOINED_NT4;
            break;
        }

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws (call for DNS name) returned %uL\n",
                pwzDomainNameForDsGetDc,
                ulResult);
            hr = HRESULT_FROM_WIN32(ulResult);
            break;
        }

        //
        // If the target machine is an NT4 BDC in an NT5 mixed-mode domain,
        // treat it as an NT4 DC.
        //

        if (pDsRole->MachineRole == DsRole_RoleBackupDomainController
            && GetMachineNtVer(pwzMachine) < 5)
        {
            Dbg(DEB_TRACE,
                "Target machine is an NT4 DC in NT5 mixed mode domain %ws\n",
                m_strTargetDomainDns.empty()
                    ? m_strTargetDomainFlat.c_str()
                    : m_strTargetDomainDns.c_str());

            m_mcTargetComputer = MC_NT4_DC;
            ASSERT(pwzMachine);  // we can't be running on NT4
            m_strTargetDomainDc = pwzMachine;
            break;
        }

        m_strTargetDomainDc = pdci->DomainControllerName;

        if (pDsRole->DomainNameDns)
        {
            m_strTargetDomainDns = pDsRole->DomainNameDns;
        }
        else if (pdci->DomainName)
        {
            m_strTargetDomainDns = pdci->DomainName;
        }

        m_strTargetDomainDns.strip(String::TRAILING, L'.');

        if (pdci->Flags & DS_DS_FLAG)
        {
            m_strTargetForest = pdci->DnsForestName;
            m_strTargetForest.strip(String::TRAILING, L'.');

            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                Dbg(DEB_TRACE,
                    "Target machine is an NT5 DC for NT5 domain %ws in forest %ws\n",
                    m_strTargetDomainDns.empty()
                        ? m_strTargetDomainFlat.c_str()
                        : m_strTargetDomainDns.c_str(),
                    m_strTargetForest.c_str());

                m_mcTargetComputer = MC_NT5_DC;
            }
            else
            {
                Dbg(DEB_TRACE,
                    "Target machine is joined to NT5 domain %ws (DC is %ws) in forest %ws\n",
                    m_strTargetDomainDns.empty()
                        ? m_strTargetDomainFlat.c_str()
                        : m_strTargetDomainDns.c_str(),
                    m_strTargetDomainDc.c_str(),
                    m_strTargetForest.c_str());

                m_mcTargetComputer = MC_JOINED_NT5;
            }
        }
        else
        {
            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                Dbg(DEB_TRACE,
                    "Target machine is an NT4 DC for domain %ws\n",
                    m_strTargetDomainFlat.c_str());
                m_mcTargetComputer = MC_NT4_DC;
            }
            else
            {
                Dbg(DEB_TRACE,
                    "Target machine is joined to NT4 domain %ws\n",
                    m_strTargetDomainFlat.c_str());

                m_mcTargetComputer = MC_JOINED_NT4;
            }
        }

    } while (0);

    if (pdci)
    {
        NetApiBufferFree(pdci);
    }

    if (pDsRole)
    {
        DsRoleFreeMemory(pDsRole);
    }
    return hr;
}




#define NT_VERSION_KEY      L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
#define NT_VERSION_VALUE    L"CurrentVersion"

//+--------------------------------------------------------------------------
//
//  Function:   GetMachineNtVer
//
//  Synopsis:   Return the major NT version number on machine [pwzMachine]
//              as an unsigned integer, or 0 on error.
//
//  Arguments:  [pwzMachine] - machine from which to read version; NULL
//                              for local machine
//
//  History:    09-01-1999   davidmun   Created
//
//---------------------------------------------------------------------------

ULONG
GetMachineNtVer(
    PCWSTR pwzMachine)
{
    TRACE_FUNCTION(GetMachineNtVer);

    ULONG           ulVer = 0;
    HRESULT         hr = S_OK;
    CSafeReg        reg;
    WCHAR           wzBuf[20] = L"";
    NET_API_STATUS  Status = NERR_Success;
    WKSTA_INFO_100  *pinfo100 = NULL;

    do
    {
        //
        // Try to get the nt version using NetWkstaGetInfo first
        //

        String strServer;

        if (pwzMachine)
        {
            ASSERT(*pwzMachine);
            strServer = String(L"\\\\") + pwzMachine;

            Status = NetWkstaGetInfo(const_cast<PWSTR>(strServer.c_str()),
                                     100,
                                     reinterpret_cast<LPBYTE *>(&pinfo100));
        }
        else
        {
            Status = NetWkstaGetInfo(NULL,
                                     100,
                                     reinterpret_cast<LPBYTE *>(&pinfo100));
        }

        if (Status == NERR_Success)
        {
            ulVer = pinfo100->wki100_ver_major;
            Dbg(DEB_TRACE,
                "NetWkstaGetInfo returns %u.%u\n",
                pinfo100->wki100_ver_major,
                pinfo100->wki100_ver_minor);
            break;
        }

        Dbg(DEB_ERROR, "NetWkstaGetInfo error %u\n", Status);

        //
        // NetWkstaGetInfo failed.  Try to get the version number from
        // the registry.
        //

        if (pwzMachine)
        {
            CSafeReg    regRemote;

            hr = regRemote.Connect(pwzMachine, HKEY_LOCAL_MACHINE);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = reg.Open(regRemote,
                          NT_VERSION_KEY,
                          STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);
            BREAK_ON_FAIL_HRESULT(hr);
        }
        else
        {
            hr = reg.Open(HKEY_LOCAL_MACHINE,
                          NT_VERSION_KEY,
                          STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        hr = reg.QueryStr(NT_VERSION_VALUE, wzBuf, ARRAYLEN(wzBuf));
        BREAK_ON_FAIL_HRESULT(hr);

        ulVer = wcstoul(wzBuf, NULL, 10);
    } while (0);

    if (pinfo100)
    {
        NetApiBufferFree(pinfo100);
    }

    Dbg(DEB_TRACE,
        "%ws NT version is %ws (%u)\n",
        pwzMachine ? pwzMachine : L"Local machine",
        wzBuf,
        ulVer);

    return ulVer;
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::InvokeDialog
//
//  Synopsis:   Once Initialize has been called successfully, this method
//              may be called to invoke the modal object picker dialog.
//
//  Arguments:  [hwndParent]     - parent window
//              [ppdoSelections] - filled with selected objects
//
//  Returns:    HRESULT
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CObjectPicker::InvokeDialog(
     HWND               hwndParent,
     IDataObject      **ppdoSelections)
{
    return InvokeDialogEx(hwndParent, NULL, ppdoSelections);
}



//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::InvokeDialogEx
//
//  Synopsis:   Invoke the modal object picker dialog.
//
//  Arguments:  [hwndParent]     - parent window of dialog
//              [pCustomizer]    - callback methods
//              [ppdoSelections] - filled with data object containing user's
//                                  selections on success
//
//  Returns:    S_FALSE - user cancelled dialog, *ppdoSelections == NULL
//              E_* - error occurred, *ppdoSelections == NULL
//              S_OK - *ppdoSelections is valid
//
//  Modifies:   *[ppdoSelections]
//
//  History:    10-07-1998   DavidMun   Created
//              01-20-2000   davidmun   rewritten
//
//---------------------------------------------------------------------------

STDMETHODIMP
CObjectPicker::InvokeDialogEx(
     HWND               hwndParent,
     ICustomizeDsBrowser *pCustomizer,
     IDataObject      **ppdoSelections)
{
    TRACE_METHOD(CObjectPicker, InvokeDialogEx);
    HRESULT hr = S_OK;
    
    CAutoCritSec Lock(&m_csOleFreeThreading);

    try
    {
        *ppdoSelections = NULL;

        do
        {
            if (!_IsFlagSet(CDSOP_INIT_SUCCEEDED))
            {
                PopupMessage(hwndParent, IDS_CANNOT_INVOKE);
                hr = E_UNEXPECTED;
                DBG_OUT_HRESULT(hr);
                break;
            }

            m_hwndParent = hwndParent;
            m_pExternalCustomizer = pCustomizer;

            //
            // If init succeeded we should know what the machine config is
            //

            ASSERT(m_mcTargetComputer != MC_UNKNOWN);

            //
            // Put up the dialog
            //
            LinkWindow_RegisterClass();
            hr = m_pBaseDlg->DoModal(ppdoSelections);
            LinkWindow_UnregisterClass(g_hinst);

            BREAK_ON_FAIL_HRESULT(hr);
        } while (0);

        m_hwndParent = NULL;
        m_pExternalCustomizer = NULL;
    }
    STANDARD_CATCH_BLOCK;

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::ProcessNames
//
//  Synopsis:   Process the user-entered text and any objects in the
//              rich edit control.
//
//  Arguments:  [hwndRichEdit]       - edit control containing text and
//                                      objects to process
//              [pEdsoGdiProvider]   - points to instance of object which
//                                      will provide GDI objects needed
//                                      to draw in the richedit.
//              [fForceSingleSelect] - if TRUE then the contents of the
//                                      rich edit are treated as a single
//                                      name, even if the
//                                      DSOP_FLAG_MULTISELECT flag was set
//                                      by the caller.
//
//  Returns:    TRUE if all text and every object processed successfully
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      When user-entered text is processed it is removed and
//              replaced with zero or more CEmbeddedDsObjects.  Each of these
//              objects is processed by requesting it to perform the
//              caller-specified name translation and attribute fetches, if
//              any.
//
//---------------------------------------------------------------------------

BOOL
CObjectPicker::ProcessNames(
    HWND hwndRichEdit,
    const CEdsoGdiProvider *pEdsoGdiProvider,
    BOOL fForceSingleSelect) const
{
    TRACE_METHOD(CObjectPicker, ProcessNames);

    enum PARSE_STATE
    {
        EAT_LEADING,
        EAT_TRAILING,
        EAT_DELIM
    };

    CWaitCursor                 Hourglass;
    PARSE_STATE                 ParseState = EAT_LEADING;
    NAME_PROCESS_RESULT         npr = NPR_SUCCESS;
    ULONG                       idxNextObjectToProcess = 0;
    IRichEditOle               *pRichEditOle = NULL;

    LRESULT lResult = SendMessage(hwndRichEdit,
                                 EM_GETOLEINTERFACE,
                                 0,
                                 (LPARAM) &pRichEditOle);
    if (!lResult)
    {
        DBG_OUT_LASTERROR;
        PopupMessage(hwndRichEdit,
                     IDS_CANNOT_READ_RICHEDIT,
                     lResult);
        return FALSE;
    }

    CRichEditHelper re(*this,
                       hwndRichEdit,
                       pEdsoGdiProvider,
                       pRichEditOle,
                       fForceSingleSelect);
    CRichEditHelper::iterator itCur = re.begin();

    while (!NAME_PROCESSING_FAILED(npr) && itCur != re.end())
    {
        switch (ParseState)
        {
        case EAT_LEADING:
            re.Consume(itCur, L" \r\t;");

            if (itCur == re.end())
            {
                break;
            }

            // if itCur is an object, advance past and eat trailing

            if (re.IsObject(itCur))
            {
                npr = re.ProcessObject(itCur, idxNextObjectToProcess);

                if (!NAME_PROCESSING_FAILED(npr))
                {
                    itCur++;
                    idxNextObjectToProcess++;
                    ParseState = EAT_TRAILING;
                }
                break;
            }

            //
            // itCur is at start of some text. convert it to object(s) or
            // delete it.
            //

            npr = re.MakeObject(itCur);
            break;

        case EAT_TRAILING:
            re.Consume(itCur, L" \t");

            // exit switch if nothing to the right of itCur

            if (itCur == re.end())
            {
                break;
            }

            if (re.ReadChar(itCur) == L'\r')
            {
                re.ReplaceChar(itCur, L';');
            }

            if (re.ReadChar(itCur) == L';')
            {
                itCur++;
                ParseState = EAT_DELIM;
                break;
            }

            //
            // itCur is at text or object. since we're eating trailing spaces
            // that means there's an object to the left of itCur.  insert
            // a delimiter, move past it, and switch to eating leading spaces.
            //

            re.Insert(itCur, L"; ");
            itCur += 2;
            ParseState = EAT_LEADING;
            break;

        case EAT_DELIM:
            re.Consume(itCur, L";\r");

            if (itCur == re.end())
            {
                break;
            }

            if (iswspace(re.ReadChar(itCur)))
            {
                itCur++;
                ParseState = EAT_LEADING;
                break;
            }

            //
            // itCur is at non-whitespace text or object which is folloinwg
            // directly after a semicolon.  add a space and move past it, then
            // switch to eating leading.
            //

            re.Insert(itCur, L" ");
            itCur++;
            ParseState = EAT_LEADING;
            break;
        }
    }

    SAFE_RELEASE(pRichEditOle);

    if (NAME_PROCESSING_FAILED(npr))
    {
        return FALSE;
    }

    re.TrimTrailing(L"; \t");
    return re.begin() != re.end();
}




//+---------------------------------------------------------------------------
//
//  Member:     CObjectPicker::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CObjectPicker::AddRef()
{
    ULONG ul = InterlockedIncrement((LONG *) &m_cRefs);
    //Dbg(DEB_TRACE, "AddRef new refcount is %d\n", ul);
    return ul;
}




//+---------------------------------------------------------------------------
//
//  Member:     CObjectPicker::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CObjectPicker::Release()
{
    ULONG cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    //Dbg(DEB_TRACE, "Release new refcount is %d\n", cRefsTemp);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CObjectPicker::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IDsObjectPicker))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IDsObjectPickerEx))
        {
            *ppvObj = (IUnknown *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CObjectPicker", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\pathwrap.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       pathwrap.cxx
//
//  Contents:   Utility class for thread safe set/retrieve operations on
//              an IADsPathname interface.
//
//  Classes:    CADsPathWrapper
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


DEBUG_DECLARE_INSTANCE_COUNTER(CADsPathWrapper)


//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::CADsPathWrapper
//
//  Synopsis:   ctor
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CADsPathWrapper::CADsPathWrapper():
        m_cRefs(1),
        m_cLocks(0)
{
    TRACE_CONSTRUCTOR(CADsPathWrapper);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CADsPathWrapper);

    HRESULT hr;
    
    // NTRAID#NTBUG9-548146-2002/02/20-lucios. Pending fix.
    InitializeCriticalSection(&m_cs);

    do
    {
        hr = m_rpADsPath.AcquireViaCreateInstance(
                              CLSID_Pathname,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IADsPathname);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = m_rpADsPath->put_EscapedMode(ADS_ESCAPEDMODE_OFF);
        ASSERT(SUCCEEDED(hr));
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::~CADsPathWrapper
//
//  Synopsis:   dtor
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CADsPathWrapper::~CADsPathWrapper()
{
    TRACE_DESTRUCTOR(CADsPathWrapper);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CADsPathWrapper);

    ASSERT(!m_cLocks);
    DeleteCriticalSection(&m_cs);
}



//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::SetRetrieve
//
//  Synopsis:   Perform an atomic set and retrieve
//
//  Arguments:  [ulFmtIn]  - ADS_SETTYPE_*
//              [pwzIn]    - ADs path to set
//              [ulFmtOut] - ADS_FORMAT_*
//              [pbstrOut] - filled with BSTR containing new format
//
//  Returns:    HRESULT
//
//  Modifies:   *[pbstrOut]
//
//  History:    08-08-1998   DavidMun   Created
//
//  Notes:      Caller must SysFreeString(*[pbstrOut])
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::SetRetrieve(
    ULONG   ulFmtIn,
    PCWSTR  pwzIn,
    ULONG   ulFmtOut,
    BSTR   *pbstrOut)
{
    ASSERT(pwzIn);
    ASSERT(pbstrOut);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set(AutoBstr(pwzIn), ulFmtIn);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "IADsPathName::Set(%ws,%#x) hr=%#x\n",
                pwzIn,
                ulFmtIn,
                hr);
            break;
        }

        hr = m_rpADsPath->Retrieve(ulFmtOut, pbstrOut);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "IADsPathName::Retrieve(%#x) hr=%#x\n",
                ulFmtOut,
                hr);
            break;
        }

    } while (0);

    return hr;
}




HRESULT
CADsPathWrapper::SetRetrieveContainer(
    ULONG   ulFmtIn,
    PCWSTR  pwzIn,
    ULONG   ulFmtOut,
    BSTR   *pbstrOut)
{
    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set(AutoBstr(pwzIn), ulFmtIn);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = m_rpADsPath->RemoveLeafElement();
        BREAK_ON_FAIL_HRESULT(hr);

        hr = m_rpADsPath->Retrieve(ulFmtOut, pbstrOut);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}


#define LDAP_GC_PORT_STR    L":3268"


//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::ConvertProvider
//
//  Synopsis:   Substitute provider string [pwzNewProvider] for the
//              provider in ADsPath [pstrPath].
//
//  Arguments:  [pstrPath]       - points to path to modify
//              [pwzNewProvider] - new provider
//
//  Returns:    S_OK or E_INVALIDARG (if [pstrPath] is ill-formed)
//
//  Modifies:   *[pstrPath]
//
//  History:    02-11-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::ConvertProvider(
    String *pstrPath,
    PCWSTR pwzNewProvider)
{
    size_t idxDelim = pstrPath->find(L"://");

    if (idxDelim == String::npos || idxDelim == 0)
    {
        DBG_OUT_HRESULT(E_INVALIDARG);
        return E_INVALIDARG;
    }

    pstrPath->StringBase::replace(0, idxDelim, pwzNewProvider);

    //
    // If there's a GC port number, remove it.
    //

    idxDelim = pstrPath->find(LDAP_GC_PORT_STR);

    if (idxDelim != String::npos)
    {
        pstrPath->erase(idxDelim, lstrlen(LDAP_GC_PORT_STR));
    }

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::GetMostSignificantElement
//
//  Synopsis:   Return the path element closest to the provider type.
//
//  Arguments:  [pwzIn]    - ADS path to set
//              [pbstrOut] - most significant element
//
//  Returns:    HRESULT
//
//  Modifies:   *[pbstrOut]
//
//  History:    01-22-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::GetMostSignificantElement(
    PCWSTR  pwzIn,
    BSTR   *pbstrOut)
{
    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set(AutoBstr(pwzIn), ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        long cElements;

        hr = m_rpADsPath->GetNumElements(&cElements);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElements > 0);

        hr = m_rpADsPath->GetElement(cElements - 1, pbstrOut);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}



HRESULT
CADsPathWrapper::GetWinntPathServerName(
    PCWSTR  pwzIn,
    BSTR   *pbstrOut)
{
    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set(AutoBstr(pwzIn), ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        long cElements;

        hr = m_rpADsPath->GetNumElements(&cElements);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElements > 0);

        // the server name is the most significant element in some
        // cases, like WinNT://server/user (form 1), but not always, as in
        // WinNT://workgroup/server/user or WinNT://domain/server/user (form 2)

        // Not astonishingly, given the all-around badness of
        // IADsPathname, the server format returns the domain name for form
        // (2) paths, and the server name for form (1) paths.  And the 1st
        // element of the path after the provider name is unreachable
        // except with Retrieve!  

        if (cElements >= 2)
        {
            // form 2 name, so get the next-to-last element

            hr = m_rpADsPath->GetElement(1, pbstrOut);
            BREAK_ON_FAIL_HRESULT(hr);
        }
        else
        {
            // form 1 name

            hr = m_rpADsPath->Retrieve(ADS_FORMAT_SERVER, pbstrOut);
            BREAK_ON_FAIL_HRESULT(hr);
        }

    } while (0);

    return hr;
}

HRESULT
CADsPathWrapper::GetWinntPathRDN(
                                 PCWSTR pwzIn,
                                 String *pstrRDN)
{
    if(!pwzIn || !pstrRDN)
        return E_POINTER;

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);
        pstrRDN->erase();

        hr = m_rpADsPath->Set(AutoBstr(pwzIn), ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        long cElements;

        hr = m_rpADsPath->GetNumElements(&cElements);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElements > 0);

        // path can have following format. (form1) WinNT://servername
        // (form2) WinNT://server/user,
        // (form3) WinNT://workgroup/server/user or WinNT://domain/server/user 
        // In form1 there is no rdn while in 2 and 3 least significant element is 
        // RDN


        if (cElements >= 2)
        {
            // form 2 or 3 name, so get the last element

            BSTR bstr;
            hr = m_rpADsPath->GetElement(0, &bstr);
            BREAK_ON_FAIL_HRESULT(hr);

            *pstrRDN = bstr;
            SysFreeString(bstr);
        }

    } while (0);

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::Set
//
//  Synopsis:   Wrap IADsPathname::Set.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::Set(
    PCWSTR pwzPath,
    long lSetType)
{
    //TRACE_METHOD(CADsPathWrapper, Set);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->Set(AutoBstr(pwzPath), lSetType);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::GetNumElements
//
//  Synopsis:   Wrap IADsPathname::GetNumElements.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::GetNumElements(
    long *pcElem)
{
    //TRACE_METHOD(CADsPathWrapper, GetNumElements);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->GetNumElements(pcElem);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::Escape
//
//  Synopsis:   Escape name element [pwzIn].
//
//  Arguments:  [pwzIn]    - element to escape
//              [pbstrOut] - filled with BSTR containing escaped element
//
//  Returns:    HRESULT
//
//  Modifies:   *[pbstrOut]
//
//  History:    5-04-1999   davidmun   Created
//
//  Notes:      Caller must call SysFreeString on returned BSTR.
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::Escape(
    PCWSTR pwzIn,
    BSTR *pbstrOut)
{
    HRESULT hr = S_OK;

    do
    {
        if (!m_rpADsPath.get())
        {
            hr = E_FAIL;
            DBG_OUT_HRESULT(hr);
            break;
        }

        CAutoCritSec Lock(&m_cs);

        hr = m_rpADsPath->Set(AutoBstr(L"LDAP"), ADS_SETTYPE_PROVIDER);
        BREAK_ON_FAIL_HRESULT(hr);
        hr = m_rpADsPath->GetEscapedElement(0, AutoBstr(pwzIn), pbstrOut);
        CHECK_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::GetElement
//
//  Synopsis:   Wrap IADsPathname::GetElement.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::GetElement(
    long idxElem,
    BSTR *pbstrElem)
{
    //TRACE_METHOD(CADsPathWrapper, GetElement);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->GetElement(idxElem, pbstrElem);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::RemoveLeafElement
//
//  Synopsis:   Wrap IADsPathname::RemoveLeafElement.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::RemoveLeafElement()
{
    //TRACE_METHOD(CADsPathWrapper, RemoveLeafElement);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->RemoveLeafElement();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\password.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       password.cxx
//
//  Contents:   Implementation of class used to prompt user for credentials.
//
//  Classes:    CPasswordDialog
//
//  History:    02-09-1998   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#include <wincred.h>
#include <wincrui.h>
#pragma hdrstop

//+--------------------------------------------------------------------------
//
//  Member:     CPasswordDialog::DoModalDialog
//
//  Synopsis:   Invoke the name and password dialog as a modal dialog.
//
//  Arguments:  [hwndParent] - dialog parent.
//
//  Returns:    S_OK    - user entered name & password and hit OK
//              S_FALSE - user hit cancel
//
//  History:    02-09-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CPasswordDialog::DoModalDialog(
HWND hwndParent)
{
    TRACE_METHOD(CPasswordDialog, DoModalDialog);
    HRESULT hr = S_OK;

    //
    // If the target is being accessed via WinNT provider, show the example
    // with just the nt4 style user name, otherwise show
    // the example with both UPN and NT4 style user names.
    //

    String strExample;

    if (m_flProvider != PROVIDER_WINNT)
    {
        strExample = String::load(IDS_EXAMPLE_UPN_NT4, g_hinst);
    }
    else
    {
        strExample = String::load(IDS_EXAMPLE_NT4, g_hinst);
    }

    //
    //Form the credui message
    //
    String strFormat = String::load((int)IDS_CREDUI_MESSAGE, g_hinst);
    String strMessage = String::format(strFormat, m_wzTarget.c_str(), strExample.c_str());

    String strTitle = String::load(IDS_CREDUI_TITLE, g_hinst);

    //
    //Init uiInfo
    // 
    CREDUI_INFO uiInfo;
    //REVIEWED-2002-02-21-lucios.
    ::ZeroMemory( &uiInfo, sizeof(CREDUI_INFO) );

    uiInfo.cbSize = sizeof(uiInfo);
    uiInfo.hwndParent = hwndParent;
    uiInfo.pszMessageText = strMessage.c_str();
    uiInfo.pszCaptionText = strTitle.c_str();

    TCHAR achUserName[CREDUI_MAX_USERNAME_LENGTH + 1];
    TCHAR achPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];
    //REVIEWED-2002-02-21-lucios.
    ::ZeroMemory(achUserName,sizeof(achUserName));
    ::SecureZeroMemory(achPassword,sizeof(achPassword));

    do
    {
        //
        //Show the password dialog box
        //
        DWORD dwErr = CredUIPromptForCredentials(&uiInfo,
            NULL,
            NULL,
            NO_ERROR,
            achUserName,
            CREDUI_MAX_USERNAME_LENGTH,
            achPassword,
            CREDUI_MAX_PASSWORD_LENGTH,
            NULL,
            CREDUI_FLAGS_DO_NOT_PERSIST | CREDUI_FLAGS_GENERIC_CREDENTIALS);
        if (NO_ERROR != dwErr) // e.g. S_FALSE
        {
            if(dwErr == ERROR_CANCELLED)
                hr = S_FALSE;
            else
            {
                hr = HRESULT_FROM_WIN32(dwErr);
                Dbg(DEB_ERROR,
                    "CredUIPromptForCredentials Failed\n");
                DBG_OUT_HRESULT(hr);
            }                    
            break;
        }

    }while(!_ValidateName(hwndParent, achUserName));

    if(hr == S_OK)
    {
        // NTRAID#NTBUG9-548215-2002/02/20-lucios. 
        *m_userName=achUserName;
        m_password->Encrypt(achPassword);
    }
    //REVIEWED-2002-02-21-lucios.
    ::ZeroMemory(achUserName,sizeof(achUserName));
    ::SecureZeroMemory(achPassword,sizeof(achPassword));

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordDialog::_ValidateName
//
//  Synopsis:   Ensure that the form of the name the user entered is valid
//              for the provider being used to access the resource.
//
//  Returns:    TRUE if name valid
//              FALSE if name not valid
//
//  History:    01-11-2000   davidmun   Created
//
//  Notes:      Displays error if name not valid
//
//---------------------------------------------------------------------------

BOOL
CPasswordDialog::_ValidateName(HWND hwnd, LPWSTR pwzUserName)
{
    if (pwzUserName && !*pwzUserName)
    {
        return FALSE; // bug if we get here
    }

    //
    // If provider is not WinNT, any nonempty name is valid
    //

    if (m_flProvider != PROVIDER_WINNT)
    {
        return TRUE;
    }

    // NTRAID#NTBUG9-506139-2002/02/04-lucios
    // Removed the checking for UPN format names 
    // for WinNT providers, since smartcards
    // can have '@'. Also, checking only for '@' 
    // doesn't garantee that the name is UPN.
    // We let the WinNT provider fail.
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\qclause.h ===
#undef QUERY_CLAUSE_ENTRY
#define QUERY_CLAUSE_ENTRY(QC, Class, Format)

#if defined(QUERY_CLAUSE_ENUM)
#undef QUERY_CLAUSE_ENTRY
#define QUERY_CLAUSE_ENTRY(QC, Class, Format)  QC
#elif defined(QUERY_CLAUSE_ARRAY)
#undef QUERY_CLAUSE_ENTRY
#define QUERY_CLAUSE_ENTRY(QC, Class, Format)  { Class, Format }
#endif


QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_USER,               QUERY_CLASS_USER,     c_tzUserQueryFmt),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_CONTACT,            QUERY_CLASS_CONTACT,  c_tzContactQueryFmt),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_COMPUTER,           QUERY_CLASS_COMPUTER, c_tzComputerQueryFmt),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_GROUP_NON_SE,       QUERY_CLASS_GROUP,    c_tzGroupNonSE),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_GROUP_SE,           QUERY_CLASS_GROUP,    c_tzGroupSE),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_GROUP_BOTH,         QUERY_CLASS_GROUP,    c_tzGroupBoth)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\progress.cpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// Dialog to display Query progress
//
// Author hiteshr, ported from sburns DCPromo implementation



#include "headers.hxx"


struct Wrapper_ThreadProcParams
{
   CProgressDialog*             dialog;
   CProgressDialog::ThreadProc  realProc;
};


DWORD WINAPI
wrapper_ThreadProc(void* p)
{
   ASSERT(p);

   Wrapper_ThreadProcParams* params =
      reinterpret_cast<Wrapper_ThreadProcParams*>(p);
   ASSERT(params->dialog);
   ASSERT(params->realProc);

   return params->realProc(*(params->dialog));

}
   


CProgressDialog::CProgressDialog
(
    ThreadProc ThreadProc,
    int iAnimationResId,
    DWORD dwWaitTime,
    CRow * pRow,
    ULONG flProcess,
    BOOL bXForest,
    const CObjectPicker &rop,
    const CScope &Scope,
    const String &strUserEnteredString,
    CDsObjectList *pdsolMatches
 ):
    m_hThread(NULL),
    m_ThreadProc(ThreadProc),
    m_pThreadParams(NULL),
    m_iAnimationResId(iAnimationResId),
    m_dwWaitTime(dwWaitTime),
    m_bStop(FALSE),
    m_hWorkerThreadEvent(NULL),
    m_hSemaphore(NULL),
    m_pRow(pRow), 
    m_flProcess(flProcess), 
    m_bXForest(bXForest),
    m_rop(rop),
    m_Scope(Scope),
    m_strUserEnteredString(strUserEnteredString),
    m_pdsolMatches(pdsolMatches)
{
    ASSERT(m_ThreadProc);
    ASSERT(m_iAnimationResId > 0);

    m_hWorkerThreadEvent = CreateEvent(NULL, FALSE,FALSE,NULL);
    ASSERT(m_hWorkerThreadEvent);
    m_hSemaphore = CreateSemaphore(NULL,1,1,NULL); 
    ASSERT(m_hSemaphore);
}



CProgressDialog::~CProgressDialog()
{
    if(m_pThreadParams)
        LocalFree(m_pThreadParams);
    if(m_hWorkerThreadEvent)
        CloseHandle(m_hWorkerThreadEvent);
    if(m_hSemaphore)
        CloseHandle(m_hSemaphore);
    if(m_hThread)
        CloseHandle(m_hThread);
}



HRESULT
CProgressDialog::CreateProgressDialog(HWND hwndParent)
{
    HRESULT hr = S_OK;
    m_hwndParent=hwndParent;
    hr = CreateThread();
    if(FAILED(hr))
    {
        return hr;
    }

    //
    //Wait for m_dwWaitTime milliseconds for Worker thread to finish.
    //Worker thread will signal m_hThreadDone event once it's done.
    //
    DWORD dwWaitResult = WaitForSingleObject(m_hWorkerThreadEvent, m_dwWaitTime);//Step1
    if(dwWaitResult == WAIT_TIMEOUT)
    {
        //
        //Wait for the Semaphore
        //
        dwWaitResult= WaitForSingleObject(m_hSemaphore,INFINITE);//Step2
        if(dwWaitResult == WAIT_OBJECT_0)
        {
            //
            //Check if the WorkerThread is done between Step1 and Step2
            //
            dwWaitResult = WaitForSingleObject(m_hWorkerThreadEvent,0);
            if(dwWaitResult == WAIT_TIMEOUT)
            {
                //
                //Worker thread is not done. Show the dialog box.
                //Now worker thread cannot finish until we release the 
                //semaphore in WM_INIT. 
                //
                DoModalDlg(hwndParent);
            }
            else
            {
                ULONG lUnused = 0;
                ReleaseSemaphore(m_hSemaphore, 1, (LPLONG)&lUnused);
                ASSERT(lUnused == 0);
            }
        }
    }

    //
    //Wait for worker thread to finish
    //
    WaitForSingleObject(m_hThread, INFINITE);

    return hr;
}

HRESULT
CProgressDialog::ThreadDone()
{
    DWORD dwWaitResult = 0;
    //
    //Wait for the semaphore
    //
    dwWaitResult = WaitForSingleObject(m_hSemaphore,INFINITE);
    if(dwWaitResult == WAIT_OBJECT_0)
    {
        //
        //If the dialog box is created, send a message to it.
        //
        if(GetHwnd())
        {
            PostMessage(GetHwnd(),THREAD_SUCCEEDED,0,0);
        }
        SetEvent(m_hWorkerThreadEvent);

        ULONG lUnused = 0;
        ReleaseSemaphore(m_hSemaphore, 1, (LPLONG)&lUnused);
        ASSERT(lUnused == 0);
    }
    return S_OK;
}

void
CProgressDialog::UpdateText(const String& message)
{
   SetDlgItemText(GetHwnd(), IDC_PRO_STATIC,message.c_str());
}




HRESULT
CProgressDialog::_OnInit(BOOL * /*pfSetFocus*/)
{
    Animate_Open(GetDlgItem(GetHwnd(), IDC_ANIMATION),
        MAKEINTRESOURCE(m_iAnimationResId));
    //
    //Release the semaphore. This semaphore is acquired
    //before creating the dialogbox window by calling 
    //DoModal
    //
    ULONG lUnused = 0;
    ReleaseSemaphore(m_hSemaphore, 1, (LPLONG)&lUnused);
    ASSERT(lUnused == 0);
    return S_OK;
}

HRESULT
CProgressDialog::CreateThread()
{

    m_pThreadParams = (Wrapper_ThreadProcParams*)
            LocalAlloc(LPTR,sizeof Wrapper_ThreadProcParams);

    if(!m_pThreadParams)
        return E_OUTOFMEMORY;

    m_pThreadParams->dialog   = this;      
    m_pThreadParams->realProc = m_ThreadProc;

    //
    //Start worker thread
    //
    ULONG idThread = 0;
    m_hThread = ::CreateThread( NULL,
                                0,
                                wrapper_ThreadProc,
                                m_pThreadParams,
                                0,
                                &idThread);
    if(!m_hThread)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}




BOOL
CProgressDialog::_OnCommand(WPARAM wParam, LPARAM /*lParam*/)
{

    BOOL fHandled = TRUE;
    switch (LOWORD(wParam))
    {
    case IDCANCEL:
        SafeEnableWindow(GetDlgItem(GetHwnd(),IDCANCEL),false);
        m_bStop = TRUE;
        break;

    default:
        fHandled = FALSE;
        break;
    }

    return fHandled;

}



BOOL
CProgressDialog::OnProgressMessage(
   UINT     message,
   WPARAM    /*wparam*/  ,
   LPARAM    /*lparam*/  )
{

   switch (message)
   {
      case THREAD_SUCCEEDED:
      {
         Animate_Stop(GetDlgItem(GetHwnd(), IDC_ANIMATION));
         BOOL result = EndDialog(GetHwnd(), THREAD_SUCCEEDED);
         ASSERT(result==TRUE);
         return true;
      }
      case THREAD_FAILED:
      {
         Animate_Stop(GetDlgItem(GetHwnd(), IDC_ANIMATION));         
         BOOL result = EndDialog(GetHwnd(), THREAD_FAILED);
         ASSERT(result==TRUE);
         return true;
      }
      default:
      {
         // do nothing
         break;
      }
   }
   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\qclass.h ===
#undef QUERY_CLASS_ENTRY
#define QUERY_CLASS_ENTRY(ClassEnum, ClassStr)

#if defined(QUERY_CLASS_ENUM)
#undef QUERY_CLASS_ENTRY
#define QUERY_CLASS_ENTRY(ClassEnum, ClassStr)  ClassEnum
#elif defined(QUERY_CLASS_ARRAY)
#undef QUERY_CLASS_ENTRY
#define QUERY_CLASS_ENTRY(ClassEnum, ClassStr)  ClassStr
#endif

QUERY_CLASS_ENTRY(QUERY_CLASS_USER,       L"CN=user"),
QUERY_CLASS_ENTRY(QUERY_CLASS_CONTACT,    L"CN=contact"),
QUERY_CLASS_ENTRY(QUERY_CLASS_COMPUTER,   L"CN=computer"),
QUERY_CLASS_ENTRY(QUERY_CLASS_GROUP,      L"CN=group")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\queryengine.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       QueryEngine.cxx
//
//  Contents:   Implementation of class used to perform queries and store
//              the results. It is used from the advanced dialog.
//
//  Classes:    CQueryEngine
//
//  History:    04-13-2000   DavidMun   Created
//
//  Notes:      Methods whose names begin with a lowercase 't' (e.g.
//              _tAddCustomObjects) run in the worker thread.
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


#define NOTIFY_BLOCK_SIZE   64
#define BREAK_IF_NEW_WORK_ITEM if (m_usnNextWorkItem > m_usnCurWorkItem) break

//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::CQueryEngine
//
//  Synopsis:   ctor
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CQueryEngine::CQueryEngine(
    const CObjectPicker &rop):
        m_rop(rop),
        m_hThread(NULL),
        m_CurrentThreadState(WTS_WAIT),
        m_DesiredThreadState(WTS_WAIT),
        m_hThreadEvent(NULL),
        m_usnCurWorkItem(0),
        m_usnNextWorkItem(0),
        m_hrLastQueryResult(S_OK)
{
    TRACE_CONSTRUCTOR(CQueryEngine);
    // NTRAID#NTBUG9-548146-2002/02/20-lucios. Pending fix.
    InitializeCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::~CQueryEngine
//
//  Synopsis:   dtor
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CQueryEngine::~CQueryEngine()
{
    TRACE_DESTRUCTOR(CQueryEngine);

    if (m_hThread)
    {
        ASSERT(m_hThreadEvent);

        {
            CAutoCritSec Lock(&m_cs);

            m_DesiredThreadState = WTS_EXIT;
            m_usnNextWorkItem++;
            VERIFY(SetEvent(m_hThreadEvent));
        }

        MessageWait(1, &m_hThread, INFINITE);
        CloseHandle(m_hThread);
        CloseHandle(m_hThreadEvent);
    }
    else
    {
        ASSERT(!m_hThreadEvent);
    }
    DeleteCriticalSection(&m_cs);
    m_hThread = 0;
    m_hThreadEvent = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::Initialize
//
//  Synopsis:   Second phase of initialization; if this fails queries
//              cannot be performed.
//
//  Returns:    HRESULT
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CQueryEngine::Initialize()
{
    TRACE_METHOD(CQueryEngine, Initialize);

    HRESULT hr = S_OK;

    do
    {
        m_hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!m_hThreadEvent)
        {
            DBG_OUT_LASTERROR;
            hr = HRESULT_FROM_LASTERROR;
            break;
        }

        ULONG idThread;

        m_hThread = CreateThread(NULL,
                                 0,
                                 CQueryEngine::_tThread_Proc,
                                 (PVOID) this,
                                 0,
                                 &idThread);

        if (!m_hThread)
        {
            DBG_OUT_LASTERROR;
            hr = HRESULT_FROM_LASTERROR;
            break;
        }

        Dbg(DEB_TRACE, "Created thread, id=0x%x\n", idThread);
    } while (0);

    if (FAILED(hr) && m_hThreadEvent)
    {
        VERIFY(CloseHandle(m_hThreadEvent));
        m_hThreadEvent = NULL;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::AsyncDirSearch
//
//  Synopsis:   Tell the worker thread to start a query.
//
//  Arguments:  [qp] - particulars of the query to perform
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CQueryEngine::AsyncDirSearch(
    const SQueryParams &qp,
    ULONG *pusnThisWorkItem) const
{
    TRACE_METHOD(CQueryEngine, AsyncDirSearch);

    if (!m_hThread)
    {
        return E_OUTOFMEMORY;
    }
    ASSERT(m_hThreadEvent);

    {
        CAutoCritSec Lock(&m_cs);

        ++m_usnNextWorkItem;
        if (pusnThisWorkItem)
        {
            *pusnThisWorkItem = m_usnNextWorkItem;
        }
        m_NextQueryParams = qp;
        m_DesiredThreadState = WTS_QUERY;
        m_hrLastQueryResult = S_OK;
    }
    VERIFY(SetEvent(m_hThreadEvent));
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::StopWorkItem
//
//  Synopsis:   Abort whatever work is in progress.
//
//  History:    04-27-2000   DavidMun   Created
//
//  Notes:      Safe to call if no work is in progress.
//
//---------------------------------------------------------------------------

void
CQueryEngine::StopWorkItem() const
{
    TRACE_METHOD(CQueryEngine, StopWorkItem);

    CAutoCritSec Lock(&m_cs);
    ++m_usnNextWorkItem;
    m_DesiredThreadState = WTS_WAIT;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::SyncDirSearch
//
//  Synopsis:   Perform the search specified by [qp] and block until it
//              is complete.
//
//  Arguments:  [qp] - indicates what to search for and where.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CQueryEngine::SyncDirSearch(
    const SQueryParams &qp) const
{
    TRACE_METHOD(CQueryEngine, SyncDirSearch);

    HRESULT hr = AsyncDirSearch(qp);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    if (qp.hQueryCompleteEvent == INVALID_HANDLE_VALUE)
    {
        Dbg(DEB_ERROR,
            "error: Caller did not supply hQueryCompleteEvent value\n");
        return E_INVALIDARG;
    }

    MessageWait(1, &qp.hQueryCompleteEvent, INFINITE);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tThread_Proc, static
//
//  Synopsis:   Entry point and main loop for the query thread.
//
//  Arguments:  [pvThis] - pointer to CWorkerThread instance
//
//  Returns:    0
//
//  History:    10-14-1997   DavidMun   Created
//              02-02-2000   davidmun   taken from CWorkerThread, modified
//
//---------------------------------------------------------------------------

DWORD WINAPI
CQueryEngine::_tThread_Proc(
    LPVOID pvThis)
{
    TRACE_FUNCTION(CWorkerThread::_tThread_Proc);
    HRESULT hr;

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return 0;
    }

    CQueryEngine *pThis = reinterpret_cast<CQueryEngine *> (pvThis);


    while (pThis->m_CurrentThreadState != WTS_EXIT)
    {
        ULONG ulWaitResult;

        //
        // Wait for the main thread to signal that there's something to do.
        //

        Dbg(DEB_TRACE, "_tThread_Proc: waiting for event\n");

        ulWaitResult = WaitForSingleObject(pThis->m_hThreadEvent, INFINITE);

        if (ulWaitResult != WAIT_OBJECT_0)
        {
            Dbg(DEB_ERROR,
                "_tThread_Proc: wait result %u, LastError = %uL\n",
                ulWaitResult,
                GetLastError());
            pThis->m_CurrentThreadState = WTS_EXIT;
            continue;
        }

        {
            CAutoCritSec Lock(&pThis->m_cs);

            pThis->m_CurrentThreadState = pThis->m_DesiredThreadState;
            pThis->m_usnCurWorkItem     = pThis->m_usnNextWorkItem;
            pThis->m_CurQueryParams     = pThis->m_NextQueryParams;
        }

        switch (pThis->m_CurrentThreadState)
        {
        case WTS_QUERY:
            // NTRAID#NTBUG9-562616-2002/07/19-artm   catch bad_alloc exceptions
            try
            {
                if (IsUplevel(pThis->m_CurQueryParams.rpScope.get()))
                {
                    pThis->_tPerformLdapQuery();
                }
                else
                {
                    pThis->_tPerformWinNtEnum();
                }
            }
            catch (const bad_alloc&)
            {
                Dbg(DEB_ERROR, "_tThread_Proc: caught bad_alloc exception\n");
                
                pThis->m_hrLastQueryResult = E_OUTOFMEMORY;

                // We need to tell the main thread that the query is done so
                // that it can perform its regular stopping actions.  Note that
                // we tell the main thread that we retrieved 0 items, which stops
                // the thread from trying to add any items we might have found 
                // to the list box (and decreases the chances of hitting out of
                // memory on the main thread as well).
                if (pThis->m_CurQueryParams.hwndNotify)
                {
                    PostMessage(pThis->m_CurQueryParams.hwndNotify,
                                OPM_QUERY_COMPLETE,
                                0,                        
                                pThis->m_usnCurWorkItem);
                }

                if (pThis->m_CurQueryParams.hQueryCompleteEvent != INVALID_HANDLE_VALUE)
                {
                    SetEvent(pThis->m_CurQueryParams.hQueryCompleteEvent);
                }

                // Now wait for the main thread to tell us what to do next.
                pThis->m_CurrentThreadState = WTS_WAIT;
            }
            break;

        case WTS_WAIT:
        case WTS_EXIT:
            break;
        }
    }

    CoUninitialize();
    Dbg(DEB_TRACE, "_tThread_Proc: exiting\n");
    return 0;
}

//  NTRAID#406082-2001/06/01-lucios - Begin
//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::addApprovedObjects
//
//  Synopsis:   Add to m_vObjects the approved objects of dsolToAdd. 
//  auxiliar in _tPerformLdapQuery
//
//  History:    06-01-2001   lucios   Created
//
//  Notes:      Runs in worker thread.
//
//---------------------------------------------------------------------------


HRESULT
CQueryEngine::_tAddApprovedObjects
(
   CDsObjectList &dsolToAdd
)
{
   TRACE_METHOD(CQueryEngine, _tAddApprovedObjects);
   
   HRESULT hr=S_OK;

   do
   {
      // this can happen only for the final call to _tAddApprovedObjects
      if(dsolToAdd.size()==0)
      {
         break; // we return S_OK
      }

      ICustomizeDsBrowser *pExternalCustomizer =  m_rop.GetExternalCustomizer();
      BOOL afApproved[NOTIFY_BLOCK_SIZE];

      if (pExternalCustomizer)
      {
         // let's check for approval
         // REVIEWED-2002-02-21-lucios.
         ZeroMemory(afApproved, sizeof afApproved);

         // Add the list to a CDataObject to pass to ApproveObjects
         CDataObject DataObject
         (
            const_cast<CObjectPicker*>(&m_rop), 
            dsolToAdd
         );

         // The main and only approval call...
         hr = pExternalCustomizer->ApproveObjects
         (
           m_CurQueryParams.rpScope.get(),
           &DataObject,
           afApproved
         );

         //
         // Failure hresult means no objects approved.
         //

         if (FAILED(hr))
         {
           Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
           // we propagate our hr
           break;
         }
      }
      else
      {
         hr=S_OK;
      }

      //
      // Now add all approved items to buffer.  S_FALSE means only some
      // were approved.  Any other success code means all were approved.
      //

      BOOL fApprovedAll = (hr != S_FALSE);
      CDsObjectList::iterator it;
      ULONG i;
      for (i = 0, it = dsolToAdd.begin(); it != dsolToAdd.end(); it++, i++)
      {
          if (fApprovedAll || afApproved[i])
          {
              CAutoCritSec Lock(&m_cs);
              m_vObjects.push_back(*it);
          }
          else
          {
              Dbg(DEB_TRACE, "Object '%ws' was not approved\n", it->GetName());
          }
      }

   } while(0);

   // let's clear the list for the next round
   dsolToAdd.clear();

   return hr;
}
//  NTRAID#406082-2001/06/01-lucios - End


//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tPerformLdapQuery
//
//  Synopsis:   Performs an LDAP directory search parameterized by
//              m_CurQueryParams.
//
//  History:    04-13-2000   DavidMun   Created
//
//  Notes:      Runs in worker thread.
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tPerformLdapQuery()
{
    TRACE_METHOD(CQueryEngine, _tPerformLdapQuery);

    HRESULT hr = S_OK;
    RpIDirectorySearch rpDirSearch;
    ULONG cRows = 0;

#ifdef FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY
static int icalls;
#endif // FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY


    //list to accumulate objects to be added
    CDsObjectList dsolToAdd;


    do
    {
#ifdef FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY
        if (!icalls++)
        {
            hr = HRESULT_FROM_WIN32(ERROR_DS_NONSAFE_SCHEMA_CHANGE);
            break;
        }
#endif // FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY

        Clear();

        _tAddCustomObjects();
        BOOL flSearchingXForest = (m_rop.GetScopeManager().GetCurScope().Type() 
                                                  == ST_XFOREST) ? TRUE: FALSE;

        //
        // Notify main thread of any custom objects added
        //

        if (m_vObjects.size())
        {
            PostMessage(m_CurQueryParams.hwndNotify,
                        OPM_NEW_QUERY_RESULTS,
                        m_vObjects.size(),
                        m_usnCurWorkItem);
        }

        //
        // If there is no ldap filter then there's nothing other than the
        // custom objects to add.
        //

        if (m_CurQueryParams.strLdapFilter.empty())
        {
            break;
        }

        //
        // Set up for performing an ldap query
        //

        hr = g_pBinder->BindToObject(m_CurQueryParams.hwndCredPromptParentDlg,
                                     m_CurQueryParams.strADsPath.c_str(),
                                     IID_IDirectorySearch,
                                     (void**)&rpDirSearch,
                                     m_CurQueryParams.ulBindFlags);
        BREAK_ON_FAIL_HRESULT(hr);

        ADS_SEARCHPREF_INFO aSearchPrefs[4];

        aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[0].vValue.Integer = DEFAULT_PAGE_SIZE;

        aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
        aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[1].vValue.Integer = ADS_DEREF_NEVER;

        aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        aSearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[2].vValue.Integer = m_CurQueryParams.ADsScope;

        aSearchPrefs[3].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
        aSearchPrefs[3].vValue.dwType = ADSTYPE_BOOLEAN;
        aSearchPrefs[3].vValue.Integer = FALSE;

        hr = rpDirSearch->SetSearchPreference(aSearchPrefs,
                                              ARRAYLEN(aSearchPrefs));
        BREAK_ON_FAIL_HRESULT(hr);

        CRow Row(m_CurQueryParams.hwndCredPromptParentDlg,
                 m_rop,
                 rpDirSearch.get(),
                 m_CurQueryParams.strLdapFilter,
                 m_CurQueryParams.vakAttributesToRead);

        while (1)
        {
            if (m_usnNextWorkItem > m_usnCurWorkItem)
            {
                Dbg(DEB_TRACE,
                    "Next work item usn is %u, current is %u, abandoning dir search\n",
                    m_usnNextWorkItem,
                    m_usnCurWorkItem);
                break;
            }

            hr = Row.Next();

            if (hr == S_ADS_NOMORE_ROWS)
            {
                Dbg(DEB_TRACE, "S_ADS_NOMORE_ROWS (got %u)\n", cRows);

                ULONG ulADsLastError;
                WCHAR wzError[MAX_PATH];
                WCHAR wzProvider[MAX_PATH];

                HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                              wzError,
                                              ARRAYLEN(wzError),
                                              wzProvider,
                                              ARRAYLEN(wzProvider));

                if (SUCCEEDED(hr2) && ulADsLastError == ERROR_MORE_DATA)
                {
                    Dbg(DEB_TRACE, "Got ERROR_MORE_DATA, trying again\n");
                    continue;
                }
                break;
            }

            BREAK_ON_FAIL_HRESULT(hr);

            // NTRAID#406082-2001/06/01-lucios - Begin
            // Add object to a temporary list of objects pending approval
            CDsObject temp
            (
                m_CurQueryParams.rpScope.get()->GetID(),
                Row.GetAttributes()
            );
            temp.SetNeedsSidFiltering(flSearchingXForest);
            dsolToAdd.push_back(temp);
            // NTRAID#406082-2001/06/01-lucios - End
                

            cRows++;

            if (m_CurQueryParams.Limit == QL_USE_REGISTRY_LIMIT &&
                cRows >= g_cQueryLimit)
            {
                Dbg(DEB_TRACE,
                    "Got %u rows, query limit is %u, stopping query\n",
                    cRows,
                    g_cQueryLimit);

                //
                // Post a message indicating query cut short so that
                // main dialog can pop up notice
                //

                if (m_CurQueryParams.hwndNotify)
                {
                    PostMessage(m_CurQueryParams.hwndNotify,
                                OPM_HIT_QUERY_LIMIT,
                                0,
                                0);
                }
                break;
            }

            //
            // If we've accumulated an even multiple of NOTIFY_BLOCK_SIZE rows,
            // post a notification that there's more stuff to show.
            //

            if (m_CurQueryParams.hwndNotify && !(cRows % NOTIFY_BLOCK_SIZE))
            {
               // NTRAID#NTBUG9-526896-2002/04/08-lucios
               ASSERT(dsolToAdd.size() <= NOTIFY_BLOCK_SIZE);
               // NTRAID#406082-2001/06/01-lucios - Begin
               // add to m_vObjects the approved objects
               HRESULT hrApproved=_tAddApprovedObjects(dsolToAdd);

               // a failed hr means there are no objects in
               // m_vObjects
               if (FAILED(hrApproved))
               {
                  Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
                  // This is not a fatal error but there is no need to notify
                  // the UI for 0 objects. 
                  // That is why the PostMessage is in the else clause.
               }
               else
               {
                  // NTRAID#424768-2001/07/13-lucios - Begin
                  // changing Post to Send to improve UI responsiveness
                  SendMessage(m_CurQueryParams.hwndNotify,
                               OPM_NEW_QUERY_RESULTS,
                               m_vObjects.size(),
                               m_usnCurWorkItem);
                  // NTRAID#406082-2001/07/13-lucios - End
               }
               // NTRAID#406082-2001/06/01-lucios - End
            }
        }
    } while (0);

    //
    // Remember status of query
    //

    m_hrLastQueryResult = hr;

    //
    // Post notification that query is complete
    //

    // NTRAID#406082-2001/06/01-lucios - Begin
    // add to m_vObjects the approved objects
    hr=_tAddApprovedObjects(dsolToAdd);
 
    // a failed hr means there are no objects in
    // m_vObjects
    if (FAILED(hr))
    {
       Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
       hr=S_OK; 
       // This is not a fatal error and we might 
       // notify even with the m_vObjects.size 0
    }
    // NTRAID#406082-2001/06/01-lucios - End

    if (m_CurQueryParams.hwndNotify)
    {
        PostMessage(m_CurQueryParams.hwndNotify,
                    OPM_QUERY_COMPLETE,
                    m_vObjects.size(),
                    m_usnCurWorkItem);
    }

    if (m_CurQueryParams.hQueryCompleteEvent != INVALID_HANDLE_VALUE)
    {
        SetEvent(m_CurQueryParams.hQueryCompleteEvent);
    }

    //
    // Return to waiting state
    //

    m_CurrentThreadState = WTS_WAIT;
}



#define ENUM_NEXT_REQUESTED_ELEMENTS    25

//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tPerformWinNtEnum
//
//  Synopsis:   Performs a WinNT enumeration parameterized by
//              m_CurQueryParams.
//
//  History:    04-26-2000   DavidMun   Created
//
//  Notes:      Runs in worker thread
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tPerformWinNtEnum()
{
    TRACE_METHOD(CQueryEngine, _tPerformWinNtEnum);

    HRESULT         hr = S_OK;
    IADsContainer  *pContainer = NULL;
    IEnumVARIANT   *pEnum = NULL;
    Variant         varFilter;
    ULONG           i;

    do
    {
        Clear();

        _tAddCustomObjects();

        if (m_usnNextWorkItem > m_usnCurWorkItem)
        {
            break;
        }

        //
        // If there aren't any class filters to use for an enumeration,
        // go to cleanup section, which will post a query-finished msg.
        //

        if (m_CurQueryParams.vstrWinNtFilter.empty())
        {
            Dbg(DEB_TRACE, "No filters, returning\n");
            break;
        }

        //
        // Notify main thread of any custom objects added
        //

        if (m_vObjects.size())
        {
            PostMessage(m_CurQueryParams.hwndNotify,
                        OPM_NEW_QUERY_RESULTS,
                        m_vObjects.size(),
                        m_usnCurWorkItem);
        }

        //
        // Set up to perform the enumeration
        //

        hr = g_pBinder->BindToObject(m_CurQueryParams.hwndCredPromptParentDlg,
                                     m_CurQueryParams.strADsPath.c_str(),
                                     IID_IADsContainer,
                                     (void **) &pContainer);
        BREAK_ON_FAIL_HRESULT(hr);

        PWSTR *apwzFilter = new PWSTR[m_CurQueryParams.vstrWinNtFilter.size()];

        for (i = 0; i < m_CurQueryParams.vstrWinNtFilter.size(); i++)
        {
            apwzFilter[i] = const_cast<PWSTR>(m_CurQueryParams.vstrWinNtFilter[i].c_str());
        }

        hr = ADsBuildVarArrayStr(apwzFilter,
                                 static_cast<ULONG>
                                   (m_CurQueryParams.vstrWinNtFilter.size()),
                                 &varFilter);
        delete [] apwzFilter;
        apwzFilter = NULL;
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pContainer->put_Filter(*&varFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = ADsBuildEnumerator(pContainer, &pEnum);
        BREAK_ON_FAIL_HRESULT(hr);

        VARIANT avarEnum[ENUM_NEXT_REQUESTED_ELEMENTS];
        ULONG   cFetched;
        ULONG cRows = 0;

        for (i = 0; i < ENUM_NEXT_REQUESTED_ELEMENTS; i++)
        {
            VariantInit(&avarEnum[i]);
        }

        //
        // Loop while the work item hasn't changed and the enumeration returns
        // objects
        //

        while (m_usnNextWorkItem == m_usnCurWorkItem)
        {
            hr = ADsEnumerateNext(pEnum,
                                  ENUM_NEXT_REQUESTED_ELEMENTS,
                                  avarEnum,
                                  &cFetched);
            BREAK_ON_FAIL_HRESULT(hr);

            ASSERT(cFetched <= ENUM_NEXT_REQUESTED_ELEMENTS);

            //
            // If nothing fetched enumeration is done
            //

            if (!cFetched)
            {
                Dbg(DEB_TRACE, "Enumeration complete, got %u\n", cRows);
                break;
            }

            //
            // varEnum contains an array with cFetched items.
            //

            CDsObjectList dsolToAdd;
            ULONG flDownlevelFilter;

            hr = m_CurQueryParams.rpScope.get()->GetResultantFilterFlags(
                    m_CurQueryParams.hwndCredPromptParentDlg,
                    &flDownlevelFilter);
            BREAK_ON_FAIL_HRESULT(hr);

            for (i = 0; i < cFetched; i++)
            {
                ASSERT(V_VT(&avarEnum[i]) == VT_DISPATCH);

                IDispatch *pdisp = V_DISPATCH(&avarEnum[i]);
                IADs *pADs = NULL;
                BSTR bstrClass = NULL;

                do
                {
                    hr = pdisp->QueryInterface(IID_IADs, (void**)&pADs);
                    BREAK_ON_FAIL_HRESULT(hr);

                    BOOL fIsDisabled = IsDisabled(pADs);

                    if (g_fExcludeDisabled && fIsDisabled)
                    {
                        break;
                    }

                    hr = pADs->get_Class(&bstrClass);
                    BREAK_ON_FAIL_HRESULT(hr);

                    //
                    // Group objects have an actual class of "group" but an
                    // internal representation as localgroup or globalgroup.
                    // If this is a group object, pwzClass will be reassigned
                    // to point to c_wzLocalGroupClass or c_wzGlobalGroupClass.
                    //

                    PCWSTR pwzClass = bstrClass;

                    if (!lstrcmpi(bstrClass, c_wzGroupObjectClass) &&
                        !WantThisGroup(flDownlevelFilter, pADs, &pwzClass))
                    {
                        break;
                    }

                    //
                    // Add the new item to the buffer.
                    //

                    dsolToAdd.push_back(
                        CDsObject(m_CurQueryParams.rpScope.get()->GetID(), pADs));
                } while (0);

                if (bstrClass!=NULL) SysFreeString(bstrClass);

                SAFE_RELEASE(pADs);
                VariantClear(&avarEnum[i]); // releases dispatch

                BREAK_IF_NEW_WORK_ITEM;
            }
            BREAK_IF_NEW_WORK_ITEM;

            BOOL afApproved[ENUM_NEXT_REQUESTED_ELEMENTS];

            ICustomizeDsBrowser *pExternalCustomizer =
                m_rop.GetExternalCustomizer();

            if (pExternalCustomizer)
            {
                //
                // Ask the customizer to approve this block of objects
                //

                CDataObject DataObject(const_cast<CObjectPicker*>(&m_rop), dsolToAdd);
                //REVIEWED-2002-02-21-lucios.
                ZeroMemory(afApproved, sizeof afApproved);

                hr = pExternalCustomizer->ApproveObjects(m_CurQueryParams.rpScope.get(),
                                                         &DataObject,
                                                         afApproved);
                //
                // Failure hresult means no objects approved.
                //

                if (FAILED(hr))
                {
                    Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
                    continue;
                }
            }
            else
            {
                hr = S_OK;
            }

            //
            // Now add all approved items to buffer.  S_FALSE means only some
            // were approved.  Any other success code means all were approved.
            //

            BOOL fApprovedAll = (hr != S_FALSE);
            CDsObjectList::iterator it;

            for (i = 0, it = dsolToAdd.begin(); it != dsolToAdd.end(); it++, i++)
            {
                if (fApprovedAll || afApproved[i])
                {
                    CAutoCritSec Lock(&m_cs);
                    m_vObjects.push_back(*it);
                }
                else
                {
                    Dbg(DEB_TRACE, "Object '%ws' was not approved\n", it->GetName());
                }
                BREAK_IF_NEW_WORK_ITEM;
            }

            if (m_CurQueryParams.hwndNotify && !(m_vObjects.size() % 8))
            {
                PostMessage(m_CurQueryParams.hwndNotify,
                            OPM_NEW_QUERY_RESULTS,
                            m_vObjects.size(),
                            m_usnCurWorkItem);
            }

            // ignore errors getting data

            hr = S_OK;
            cRows += cFetched;
        }
    }
    while (0);

    //
    // Clean up
    //

    if (pEnum)
    {
        ADsFreeEnumerator(pEnum);
    }

    SAFE_RELEASE(pContainer);

    m_hrLastQueryResult = hr;

    //
    // Post notification that query is complete
    //

    if (m_CurQueryParams.hwndNotify)
    {
        PostMessage(m_CurQueryParams.hwndNotify,
                    OPM_QUERY_COMPLETE,
                    m_vObjects.size(),
                    m_usnCurWorkItem);
    }

    if (m_CurQueryParams.hQueryCompleteEvent != INVALID_HANDLE_VALUE)
    {
        SetEvent(m_CurQueryParams.hQueryCompleteEvent);
    }

    //
    // Return to waiting state
    //

    m_CurrentThreadState = WTS_WAIT;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tAddCustomObjects
//
//  Synopsis:   Add any objects supplied by the browse customizer to the
//              query results.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tAddCustomObjects()
{
    // NTRAID#NTBUG9-529086-2002/06/24-lucios
    // The behavior of this method is dictated by
    // m_CurQueryParams.CustomizerInteraction that is set in
    // CAdvancedDlg::_StartWinNtQuery by a call to
    // CAdvancedDlg::GetDownlevelCustomizerInteraction 
    // or in CAdvancedDlg::_StartLdapQuery by a call to
    // CCommonQueriesTab::GetCustomizerInteraction

    HRESULT hr=S_OK;
    TRACE_METHOD(CQueryEngine, _tAddCustomObjects);

    ICustomizeDsBrowser *pExternalCustomizer = m_rop.GetExternalCustomizer();

    // If we should perform the external customization 
    // m_CurQueryParams.CustomizerInteraction is not 
    // CUSTINT_IGNORE_CUSTOM_OBJECTS. 
    // It should be either the prefix, exact or all objects.
    // For prefix we pass our prefix and PrefixSearch(in the customizer) 
    // uses it to build  something like (name=prefix*)+ customizer filter
    // and then to perform a search with the filter.
    // For exact we do the same as prefix but _tAddFromDataObject will check
    // for CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS and will only
    // add the object if it is an exact match.
    // for all objects, we don't pass a prefix, and the customizer uses
    // its own filter. all objects returned will be added to the matches
    if(m_CurQueryParams.performExternalCustomization && pExternalCustomizer)
    {
        ASSERT(m_CurQueryParams.CustomizerInteraction !=
                CUSTINT_IGNORE_CUSTOM_OBJECTS);
        IDataObject *pdoToAdd = NULL;

        if (m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS ||
            m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS)
        {
            hr = pExternalCustomizer->PrefixSearch(m_CurQueryParams.rpScope.get(),
                                                   m_CurQueryParams.strCustomizerArg.c_str(),
                                                   &pdoToAdd);
        }
        else
        {
            ASSERT(m_CurQueryParams.CustomizerInteraction ==
                   CUSTINT_INCLUDE_ALL_CUSTOM_OBJECTS);
            hr = pExternalCustomizer->AddObjects(m_CurQueryParams.rpScope.get(),
                                                 &pdoToAdd);
        }
        
        if (SUCCEEDED(hr) && pdoToAdd)
        {
            _tAddFromDataObject(pdoToAdd);
            pdoToAdd->Release();
        }
        else
        {
            CHECK_HRESULT(hr);
            ASSERT(!pdoToAdd);
        }
    }


    // The default customizer is reponsible for built in security principals.
    // The same assertions and comments we had in the external customizer
    // are valid for the default customizer.
    // For exact search we filter the objects in the subsequent loop instead of
    // inside _tAddFromDataObject.
    if( m_CurQueryParams.perfromDefaultCustomization )
    {
        ASSERT(m_CurQueryParams.CustomizerInteraction !=
                CUSTINT_IGNORE_CUSTOM_OBJECTS);

        const CAdminCustomizer &rDefaultCustomizer =
                        m_rop.GetDefaultCustomizer();

        CDsObjectList dsolToAdd;
        if (m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS ||
            m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS)
        {
            rDefaultCustomizer.PrefixSearch(m_CurQueryParams.hwndCredPromptParentDlg,
                                            *m_CurQueryParams.rpScope.get(),
                                            m_CurQueryParams.strCustomizerArg.c_str(),
                                            &dsolToAdd);
        }
        else
        {
            ASSERT(m_CurQueryParams.CustomizerInteraction ==
                   CUSTINT_INCLUDE_ALL_CUSTOM_OBJECTS);

            rDefaultCustomizer.AddObjects(m_CurQueryParams.hwndCredPromptParentDlg,
                                          *m_CurQueryParams.rpScope.get(),
                                          &dsolToAdd);
        }
        CDsObjectList::iterator it;
        CAutoCritSec Lock(&m_cs);

        if (m_CurQueryParams.CustomizerInteraction ==
                CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS ||
            m_CurQueryParams.CustomizerInteraction ==
                CUSTINT_INCLUDE_ALL_CUSTOM_OBJECTS)
        {
            for (it = dsolToAdd.begin(); it != dsolToAdd.end(); it++)
            {
                m_vObjects.push_back(*it);
            }
        }
        else 
        {
            ASSERT(m_CurQueryParams.CustomizerInteraction == 
                CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS);

            for (it = dsolToAdd.begin(); it != dsolToAdd.end(); it++)
            {
                if (!m_CurQueryParams.strCustomizerArg.icompare(it->GetName()))
                {
                    m_vObjects.push_back(*it);
                }
            }
        }
    }
}




    
    
    

    





//+--------------------------------------------------------------------------
//
//  Function:   TestObject
//
//  Synopsis:   Callback used to eliminate objects which don't have a name
//              matching the one pointed to by [lParam].
//
//  Arguments:  [dss]    -
//              [lParam] -
//
//  Returns:
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      This is used to get rid of the names returned by the
//              customizer's prefix match which are not exact matches of
//              the given string.  We do this when the user has chosen
//              "exact match" for a string search because unfortunately there
//              is no "ExactSearch" method for the customizer.
//
//---------------------------------------------------------------------------

BOOL
TestObject(
    const DS_SELECTION &dss,
    LPARAM lParam)
{
    const String *pstrCustomizerArg = reinterpret_cast<const String *>(lParam);

    if (!dss.pwzName || pstrCustomizerArg->icompare(dss.pwzName))
    {
        return FALSE;
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tAddFromDataObject
//
//  Synopsis:   Add copies of all objects in the Data Object pointed to by
//              [pdo] to the internal vector of objects.
//
//  Arguments:  [pdo] - points to data object from which to add objects
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Used with data object returned from
//              ICustomizeDsBrowser::AddObjects.
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tAddFromDataObject(
    IDataObject *pdo)
{
    CDsObjectList dsol;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    PFNOBJECTTEST pfnTest = NULL;

    if (m_CurQueryParams.CustomizerInteraction ==
        CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS)
    {
        pfnTest = TestObject;
    }

    AddFromDataObject(
        rCurScope.GetID(),
        pdo,
        pfnTest,
        reinterpret_cast<LPARAM>(&m_CurQueryParams.strCustomizerArg),
        &dsol);

    CDsObjectList::iterator it;

    CAutoCritSec    Lock(&m_cs);

    for (it = dsol.begin(); it != dsol.end(); it++)
    {
        m_vObjects.push_back(*it);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::GetObjectAttr
//
//  Synopsis:   Return the attribute with key [ak] from the [idxRow]th
//              object in internal buffer.
//
//  Arguments:  [idxRow] - zero based index indicating which object from
//                          which to retrieve an attribute
//              [ak]     - identifies attribute to return
//
//  Returns:    Variant containing copy of attribute.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

Variant
CQueryEngine::GetObjectAttr(
    size_t      idxRow,
    ATTR_KEY   ak) const
{
    CAutoCritSec Lock(&m_cs);

    //
    // In case of a bug causing caller to specify a row that doesn't exist,
    // avoid the STL array boundary exception by returning an empty variant.
    //

    ASSERT(idxRow < m_vObjects.size());
    static Variant s_varEmpty;

    if (idxRow >= m_vObjects.size())
    {
        return s_varEmpty;
    }

    //
    // take cs for read because if vector::push_back increments count
    // before it adds object, and read is attempted between increment
    // and add, an out of range exception would occur.
    //

    return m_vObjects[idxRow].GetAttr(ak);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Select.rc
//
#define IDD_MULTI                               107
#define IDC_ADD                                 101
#define IDC_NAME                                103
#define IDS_LVCOLUMN_0                          105
#define IDS_LVCOLUMN_1                          106
#define IDS_DIRECTORY                           112
#define IDS_OUT_OF_MEMORY                       122
#define IDC_NAME_LBL                            126
#define IDS_USER                                138 // caution these must remain
#define IDS_USERS                               139 // consecutive
#define IDS_CONTACT                             140
#define IDS_CONTACTS                            141
#define IDS_GROUP                               142
#define IDS_GROUPS                              143
#define IDS_COMPUTER                            144
#define IDS_COMPUTERS                           145 // end consecutive
#define IDS_COL1FORMAT                          151
#define IDC_SELECT_MATCHING_LBL                 153
#define IDC_MATCHING_LIST                       154
#define IDS_BAD_NAME_EXTRA_SLASH                155
#define IDS_NAME_NOT_FOUND_FMT_MULTI            156
#define IDS_MAX_HITS                            159
#define IDS_MULTI_PICK_ONE                      161
#define IDS_HIT_QUERY_LIMIT                     164
#define IDS_BAD_NAME_SLASH_AT_END               165
#define IDS_UNKNOWN_DOMAIN                      169
#define IDS_EXAMPLE_UPN_NT4                     173
#define IDS_EXAMPLE_NT4                         174
#define IDD_ERROR                               181
#define IDC_POPUP_MSG_ICON                      182
#define IDC_ERRORMSG                            183
#define IDC_ERROR_CODE_LBL                      185
#define IDC_ERROR_CODE_EDIT                     186
#define IDS_BAD_NAME                            190
#define IDD_NAMENOTFOUND                        195
#define IDC_NOT_FOUND_MESSAGE                   197
#define IDC_CORRECT_RADIO                       198
#define IDC_CORRECT_EDIT                        199
#define IDC_REMOVE_RADIO                        200
#define IDS_NAME_NOT_FOUND_FMT_SINGLE           201
//used by burnslib                              202
#define IDS_CANNOT_INVOKE                       203
#define IDS_CANNOT_PROCESS                      204
#define IDC_SIZEGRIP                            207
#define IDA_SEARCH                              208
#define IDC_ANIMATION                           209
#define IDS_INIT_FAILED_NO_SCOPES               210
#define IDS_BIND_ERROR                          211
#define IDC_RICHEDIT                            214
#define IDM_CUT                                 218
#define IDM_COPY                                219
#define IDM_PASTE                               220
#define IDM_RICHEDIT                            221
#define IDS_DNS_SLASH_NAME                      223
//used by burnslib                              225
//used by burnslib                              226
//used by burnslib                              227
#define IDS_DISABLED_WARNING_FMT                228
#define IDC_LOOK_FOR_PB                         230
#define IDC_LOOK_FOR_EDIT                       231
#define IDC_LOOK_IN_PB                          232
#define IDC_LOOK_IN_EDIT                        233
#define IDC_CHECK_NAMES_PB                      235
#define IDC_ADVANCED_PB                         236
#define IDD_STANDALONE_TEXT                     237
#define IDD_LOOK_FOR                            238
#define IDC_LOOK_FOR_LV                         239
#define IDD_LOOK_IN                             240
#define IDC_LOOK_IN_TV                          241
#define IDS_INIT_FAILED_MACHINE_CONFIG          246
#define IDS_INIT_FAILED_LOCAL_MACHINE_CONFIG    247
#define IDS_INIT_FAILED_BAD_ARGS                248
#define IDS_NEW_SCOPE_CLASSES_0_INTERSECTION    249
#define IDS_EXPAND_FAILED                       251
#define IDC_LOOK_FOR_LBL                        256
#define IDC_LOOK_IN_LBL                         257
#define IDC_TAB                                 258
#define IDC_FIND_NOW_PB                         259
#define IDC_STOP_PB                             260
#define IDD_ADVANCED                            261
#define IDS_COMMON_QUERIES                      262
#define IDD_COMMON_QUERIES                      264
#define IDC_NAME_COMBO                          266
#define IDC_NAME_EDIT                           267
#define IDC_DESCRIPTION_COMBO                   268
#define IDC_DESCRIPTION_EDIT                    269
#define IDC_DISABLED_CKBOX                      270
#define IDC_NON_EXPIRING_CKBOX                  271
#define IDS_STARTS_WITH                         278
#define IDS_IS_EXACTLY                          279
#define IDC_QUERY_LISTVIEW                      282
#define IDS_SINGLE_SELECT_INSTRUCTIONS          283
#define IDS_BUILTIN_WKSP                        284
#define IDS_BUILTIN_WKSPS                       285
#define IDI_GROUP                               286
#define IDI_USER                                287
#define IDI_COMPUTER                            288
#define IDS_OTHER_OBJECT                        289
#define IDS_OTHER_OBJECTS                       290
#define IDC_DESCRIPTION_LBL                     291
#define IDC_LASTLOGON_COMBO                     304
#define IDC_LASTLOGON_LBL                       305
#define IDS_SCOPE_ERROR                         306
#define IDS_NOTHINGFOUND                        307
#define IDS_QUERY_ERROR                         308
#define IDS_SEARCHING                           309
#define IDS_STOPPING_QUERY                      310
#define IDS_LOCAL_GROUP                         311
#define IDS_GLOBAL_GROUP                        312
#define IDC_AVAILABLE_LIST                      313
#define IDC_SHOWN_LIST                          314
#define IDS_CHOOSE_COLUMNS                      315
#define IDD_COLUMN_PICKER                       316
#define IDS_CANNOT_READ_RICHEDIT                317
#define IDS_MULTI_PICK_ONE_OR_MORE              318
#define IDC_COLUMNS_PB                          319
#define IDC_ADD_COL_BTN                         320
#define IDC_REMOVE_COL_BTN                      321
#define IDS_SEMICOLON_IN_NAME                   322
#define IDC_OBJECT_TYPE_LBL                     323
#define IDC_LOCATION_LBL                        324
#define IDS_REMOVE_FROM_SEL                     325
#define IDS_SINGLE_SEL_MSG                      326
#define IDS_PROGRESS_MESSAGE                    328 
#define IDS_CREDUI_MESSAGE                      330
#define IDS_CREDUI_TITLE                        331
#define IDS_CANNOT_INVOKE_ADV                   332
#define IDS_CANNOT_INVOKE_ADV_NOERROR           333
#define IDD_PROGRESS                            334
#define IDC_PRO_STATIC                          335
#define IDS_DOMAINS_NOT_AVAILABLE               336
#define IDS_NO_DOMAIN_RETRIEVED                 337
#define IDS_AND                                 338
#define IDS_NO_DOMAIN_TRY_AGAIN                 339

//
// BEGIN: Blocks of IDs which must remain consecutive
//

#define IDS_FILTER_ONE                          500
#define IDS_FILTER_TWO                          501
#define IDS_FILTER_THREE                        502
#define IDS_FILTER_FOUR                         503
#define IDS_FILTER_FIVE                         504
#define IDS_FILTER_SIX                          505

#define IDS_SELECT_ONE                          600
#define IDS_SELECT_TWO                          601
#define IDS_SELECT_THREE                        602
#define IDS_SELECT_FOUR                         603
#define IDS_SELECT_FIVE                         604
#define IDS_SELECT_SIX                          605

//
// END: Blocks of IDs which must remain consecutive
//

//
// Icons
//

#define IDI_LOCAL_GROUP                 100
#define IDI_SCOPE_WORKGROUP             105
#define IDI_SCOPE_DIRECTORY             106
#define IDI_SCOPE_DOMAIN                107
#define IDI_SCOPE_FEDERATED             108
#define IDI_SCOPE_UNFEDERATED           109


#define IDI_DISABLED_USER               200
#define IDI_DISABLED_COMPUTER           201
#define IDC_RESULTS_LABEL               1009

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\richeditcallback.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       RichEditCallback.cxx
//
//  Contents:   Implementation of rich edit callback interface
//
//  Classes:    CRichEditOleCallback
//
//  History:    03-23-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::CRichEditOleCallback
//
//  Synopsis:   ctor
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditOleCallback::CRichEditOleCallback(
    HWND hwndRichEdit):
        m_cRefs(1),
        m_hwndRichEdit(hwndRichEdit)
{
    TRACE_CONSTRUCTOR(CRichEditOleCallback);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::~CRichEditOleCallback
//
//  Synopsis:   dtor
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditOleCallback::~CRichEditOleCallback()
{
    TRACE_DESTRUCTOR(CRichEditOleCallback);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CRichEditOleCallback::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    //TRACE_METHOD(CRichEditOleCallback, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IRichEditOleCallback))
        {
            *ppvObj = (IRichEditOleCallback *)this;
        }
        else
        {
            hr = E_NOINTERFACE;
            DBG_OUT_NO_INTERFACE("CRichEditOleCallback", riid);
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}


LPSTORAGE StgCreateOnHglobal(VOID)
{
    LPLOCKBYTES plb = NULL;
    LPSTORAGE pstg = NULL;

    // Create lockbytes on hglobal
    if ( FAILED(CreateILockBytesOnHGlobal(NULL, TRUE, &plb)) )
        return NULL;

    // Create storage on lockbytes
    StgCreateDocfileOnILockBytes(plb, STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE |
            STGM_CREATE | STGM_READWRITE, 0, &pstg);

    // Release our reference on the lockbytes and return the storage
    plb->Release();
    return pstg;
}

STDMETHODIMP
CRichEditOleCallback::GetNewStorage(
    LPSTORAGE *ppstg)
{
    TRACE_METHOD(CRichEditOleCallback, GetNewStorage);

    *ppstg = StgCreateOnHglobal();

    if (!*ppstg)
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::GetInPlaceContext(
    LPOLEINPLACEFRAME *ppFrame,
    LPOLEINPLACEUIWINDOW *ppDoc,
    LPOLEINPLACEFRAMEINFO pFrameInfo)
{
    TRACE_METHOD(CRichEditOleCallback, GetInPlaceContext);

    return E_NOTIMPL;
}


STDMETHODIMP
CRichEditOleCallback::ShowContainerUI(
    BOOL fShow)
{
    TRACE_METHOD(CRichEditOleCallback, ShowContainerUI);

    return E_NOTIMPL;
}


STDMETHODIMP
CRichEditOleCallback::QueryInsertObject(
    LPCLSID pclsid,
    LPSTORAGE pstg,
    LONG cp)
{
    //TRACE_METHOD(CRichEditOleCallback, QueryInsertObject);

    if (IsEqualCLSID(*pclsid, CLSID_DsOpObject))
    {
        //Dbg(DEB_TRACE, "allowing insert of CLSID_DsOpObject object\n");
        return S_OK;
    }

    return E_FAIL;
}


STDMETHODIMP
CRichEditOleCallback::DeleteObject(
    LPOLEOBJECT poleobj)
{
    TRACE_METHOD(CRichEditOleCallback, DeleteObject);

    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::QueryAcceptData(
    LPDATAOBJECT pdataobj,
    CLIPFORMAT *pcfFormat,
    DWORD reco,
    BOOL fReally,
    HGLOBAL hMetaPict)
{
    TRACE_METHOD(CRichEditOleCallback, QueryAcceptData);

    *pcfFormat = CF_TEXT;
    return S_OK;
}

STDMETHODIMP
CRichEditOleCallback::ContextSensitiveHelp(
    BOOL fEnterMode)
{
    TRACE_METHOD(CRichEditOleCallback, ContextSensitiveHelp);

    return E_NOTIMPL;
}


//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::GetClipboardData
//
//  Synopsis:   Return a data object which can give out the contents of the
//              rich edit as a text string (which requires asking the
//              embedded objects to return their textual representation).
//
//  Arguments:  [pchrg]     - range of text to copy
//              [reco]      - RECO_*, ignored
//              [ppdataobj] - filled with new data object
//
//  Returns:    HRESULT
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CRichEditOleCallback::GetClipboardData(
    CHARRANGE *pchrg,
    DWORD reco,
    LPDATAOBJECT *ppdataobj)
{
    TRACE_METHOD(CRichEditOleCallback, GetClipboardData);

    //
    // Create a data object which contains a textual representation of the
    // contents of the rich edit control specified by [pchrg].
    //

    *ppdataobj = new CDataObject(m_hwndRichEdit, pchrg);
    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::GetDragDropEffect(
    BOOL fDrag,
    DWORD grfKeyState,
    LPDWORD pdwEffect)
{
    TRACE_METHOD(CRichEditOleCallback, GetDragDropEffect);
    ASSERT(!IsBadWritePtr(pdwEffect, sizeof(pdwEffect)));

    *pdwEffect = DROPEFFECT_NONE;
    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::GetContextMenu(
    WORD seltype,
    LPOLEOBJECT poleobj,
    CHARRANGE *pchrg,
    HMENU *phmenu)
{
    TRACE_METHOD(CRichEditOleCallback, GetContextMenu);
    ASSERT(phmenu);

    HMENU hmenuBar = NULL;

    do
    {
        hmenuBar = LoadMenu(g_hinst, MAKEINTRESOURCE(IDM_RICHEDIT));

        if (!hmenuBar)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        *phmenu = CreatePopupMenu();

        if (!*phmenu)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        //
        // Copy the menu items loaded from the resources to the new popup
        //

        HMENU hmenuContext = GetSubMenu(hmenuBar, 0);

        ASSERT(IsMenu(hmenuContext));

        ULONG cItems = GetMenuItemCount(hmenuContext);
        ULONG i;

        ASSERT(cItems);

        const ULONG flMenu = MF_STRING | MF_ENABLED;
        for (i = 0; i < cItems; i++)
        {
            MENUITEMINFO mii;
            WCHAR wzMenuItem[MAX_PATH];


            // REVIEWED-2002-02-2-lucios.
            ZeroMemory(&mii, sizeof mii);

            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID | MIIM_STRING;
            mii.fType = MIIM_STRING;
            mii.dwTypeData = wzMenuItem;
            mii.cch = ARRAYLEN(wzMenuItem);

            VERIFY(GetMenuItemInfo(hmenuContext, i, TRUE, &mii));
            VERIFY(AppendMenu(*phmenu, flMenu, mii.wID, (PWSTR)mii.dwTypeData));
        }

        // Disable paste if can't paste
        if (!SendMessage(GetFocus(), EM_CANPASTE, 0, 0))
        {
            EnableMenuItem(*phmenu, IDM_PASTE, MF_DISABLED | MF_GRAYED);
        }

        //
        // Disable cut and copy if no current selection.
        //

        if (pchrg->cpMin == pchrg->cpMax)
        {
            EnableMenuItem(*phmenu, IDM_CUT, MF_DISABLED | MF_GRAYED);
            EnableMenuItem(*phmenu, IDM_COPY, MF_DISABLED | MF_GRAYED);
        }
    } while (0);

    if (hmenuBar)
    {
        VERIFY(DestroyMenu(hmenuBar));
    }
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CRichEditOleCallback::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CRichEditOleCallback::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\richedithelper.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       RichEditHelper.cxx
//
//  Contents:   Implementation of class which helps turn text in a
//              rich edit control into CEmbeddedDsObjects.
//
//  Classes:    CRichEditHelper
//
//  History:    03-06-2000   davidmun   Created from dsselect.cxx code
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define DEFINE_GUIDXXX(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUIDXXX(IID_ITextDocument,0x8CC497C0,0xA1DF,0x11CE,0x80,0x98,
                0x00,0xAA,0x00,0x47,0xBE,0x5D);


//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::CRichEditHelper
//
//  Synopsis:   ctor
//
//  Arguments:  [pContainer]   - container which owns rich edit
//              [hwndRichEdit] - window handle
//              [pCurScope]    - current selection in look in control
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditHelper::CRichEditHelper(
    const CObjectPicker &rop,
    HWND hwndRichEdit,
    const CEdsoGdiProvider *pEdsoGdiProvider,
    IRichEditOle *pRichEditOle,
    BOOL fForceSingleSelect):
        m_rop(rop),
        m_hwndRichEdit(hwndRichEdit),
        m_pRichEditOle(pRichEditOle),
        m_pGdiProvider(pEdsoGdiProvider),
        m_itWindowLeft(0),
        m_itWindowRight(0)
{
    TRACE_CONSTRUCTOR(CRichEditHelper);
    ASSERT(m_hwndRichEdit);
    ASSERT(m_pRichEditOle);

    m_fMultiselect = !fForceSingleSelect &&
        m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT;


    m_pRichEditOle->AddRef();
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::~CRichEditHelper
//
//  Synopsis:   dtor
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditHelper::~CRichEditHelper()
{
    TRACE_DESTRUCTOR(CRichEditHelper);

    m_hwndRichEdit = NULL;
    m_pRichEditOle->Release();
    m_pRichEditOle = NULL;
    m_pGdiProvider = NULL;
}





//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::Consume
//
//  Synopsis:   Delete all characters in rich edit starting at position
//              [itLeft] that appear in the string [pwzToDelete]
//
//  Arguments:  [itLeft]      - starting point for deletion
//              [pwzToDelete] - characters to delete
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::Consume(
    CRichEditHelper::iterator itLeft,
    PCWSTR pwzToDelete)
{
    ASSERT(pwzToDelete);

    while (itLeft != end() && wcschr(pwzToDelete, ReadChar(itLeft)))
    {
        Erase(itLeft, itLeft + 1);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::TrimTrailing
//
//  Synopsis:   Delete from the end of the contents of the rich edit control
//              all instances of [pwzCharsToTrim]
//
//  Arguments:  [pwzCharsToTrim] - chars to delete
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::TrimTrailing(
    PCWSTR pwzCharsToTrim)
{
    ASSERT(pwzCharsToTrim);

    iterator itCur;
    iterator itLastDeleteable = begin();

    for (itCur = begin(); itCur != end(); itCur++)
    {
        if (!wcschr(pwzCharsToTrim, ReadChar(itCur)))
        {
            itLastDeleteable = itCur + 1;
        }
    }

    Erase(itLastDeleteable, end());
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::Erase
//
//  Synopsis:   Delete from rich edit control all characters in the range
//              [itFirst] to [itLast]
//
//  Arguments:  [itFirst] - pos of first character to delete
//              [itLast]  - pos just past last char to delete
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::Erase(
    iterator itFirst,
    iterator itLast)
{
    ASSERT(itFirst <= itLast);

    if (itFirst == itLast)
    {
        return; // handle NOP
    }

    ASSERT(itFirst <= end());
    ASSERT(itLast <= end());

    // since this deletion is the result of processing the text in the
    // control and not a user edit, disallow undoing it

    //NTRAID#NTBUG9-439651-2001/09/17-lucios
    // The fix bellow will not be necessary for richEdit
    // version 4.1 on that should be available on Windows
    // and might be removed in the next version of object Picker.
    Edit_SetSel(m_hwndRichEdit, 0, 0);

    Edit_SetSel(m_hwndRichEdit, itFirst, itLast);
    SendMessage(m_hwndRichEdit, EM_REPLACESEL, CANNOT_UNDO, (LPARAM)L"");
    

    //
    // If the window is empty, or all of the characters deleted are to its
    // right, no adjustments need be made.
    //

    if (m_strWindow.empty() || itFirst >= m_itWindowRight)
    {
        return;
    }

    //
    // if all of the characters deleted were to the left of the start of the
    // window, its contents are unaffected but its iterators must be 'moved'
    // left.
    //

    if (itLast <= m_itWindowLeft)
    {
        ULONG cchDeleted = itLast - itFirst;

        m_itWindowLeft -= cchDeleted;
        m_itWindowRight -= cchDeleted;
        return;
    }

    //
    // The range deleted overlaps or covers the window.
    //

    ASSERT(itFirst < m_itWindowRight && itLast > m_itWindowLeft);

    iterator itWindowDeleteLeft;
    iterator itWindowDeleteRight;
    ULONG cchDeletedBeforeWindow;

    if (itFirst < m_itWindowLeft)
    {
        itWindowDeleteLeft = m_itWindowLeft;
        cchDeletedBeforeWindow = m_itWindowLeft - itFirst;
    }
    else
    {
        itWindowDeleteLeft = itFirst;
        cchDeletedBeforeWindow = 0;
    }

    if (itLast > m_itWindowRight)
    {
        itWindowDeleteRight = m_itWindowRight;
    }
    else
    {
        itWindowDeleteRight = itLast;
    }

    ULONG cchDeletedInWindow = itWindowDeleteRight - itWindowDeleteLeft;

    m_strWindow.erase(itWindowDeleteLeft - m_itWindowLeft, cchDeletedInWindow);

    m_itWindowLeft -= cchDeletedBeforeWindow;
    m_itWindowRight -= (cchDeletedBeforeWindow + cchDeletedInWindow);

    ASSERT(m_itWindowRight >= m_itWindowLeft);
    ASSERT(m_strWindow.length() == m_itWindowRight - m_itWindowLeft);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::Insert
//
//  Synopsis:   Insert string [pwzToInsert] at position [itInsertPos]
//
//  Arguments:  [itInsertPos] - position at which to insert string
//              [pwzToInsert] - string to insert
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::Insert(
    iterator itInsertPos,
    PCWSTR pwzToInsert)
{
    ASSERT(!IsBadReadPtr(pwzToInsert, sizeof(WCHAR)));
    ASSERT(itInsertPos <= end());

    if (!pwzToInsert || !*pwzToInsert)
    {
        return; // handle NOP
    }

    //
    // Insert the text at the indicated position in the rich edit
    //

    Edit_SetSel(m_hwndRichEdit, itInsertPos, itInsertPos);
    Edit_ReplaceSel(m_hwndRichEdit, pwzToInsert);

    //
    // Update the window
    //

    _InsertionUpdateWindow(itInsertPos, pwzToInsert);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::_InsertionUpdateWindow
//
//  Synopsis:   Add [pwzToInsert] to the window if the window covers the
//              insertion position [itInsertPos]
//
//  Arguments:  [itInsertPos] - position in rich edit where string was
//                              inserted
//              [pwzToInsert] - string that was inserted in rich edit
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::_InsertionUpdateWindow(
    iterator itInsertPos,
    PCWSTR pwzToInsert)
{
    ASSERT(!IsBadReadPtr(pwzToInsert, sizeof(WCHAR)));
    ASSERT(itInsertPos <= end());

    //
    // If window is empty, or insertion was to right of window, we're done
    //

    if (m_strWindow.empty() || itInsertPos >= m_itWindowRight)
    {
        return;
    }

    //
    // If insertion was to left of window, just move its position right
    //

    if (itInsertPos < m_itWindowLeft)
    {
        ULONG cchInserted = lstrlen(pwzToInsert);
        m_itWindowLeft += cchInserted;
        m_itWindowRight += cchInserted;
        return;
    }

    //
    // Insertion occurred within window, add to window and expand it
    //

    m_strWindow.insert(itInsertPos - m_itWindowLeft, pwzToInsert);
    m_itWindowRight += lstrlen(pwzToInsert);

    // Note: window may now be larger than RE_WINDOW_READ_SIZE
}





//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::MakeObject
//
//  Synopsis:   Transform the text starting at [itStart] into an object or
//              objects, or delete it entirely.
//
//  Arguments:  [itStart] - start of text to convert to object
//
//  Returns:    Result of attempting translation.  Note success does not
//              necessarily mean that an object was inserted.
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CRichEditHelper::MakeObject(
    iterator itStart)
{
    TRACE_METHOD(CRichEditHelper, MakeObject);
    ASSERT(itStart < end());

    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    iterator itEnd;
    String strTerm;

    for (itEnd = itStart; itEnd != end(); itEnd++)
    {
        WCHAR wch = ReadChar(itEnd);

        //NTRAID#NTBUG9-525361-2002/04/08-lucios
        //Semicolon is not valid character in a name.
        if(!m_fMultiselect && (wch == L';' || wch == L'\r' || 
                            wch == OBJECT_REPLACEMENT_CHARACTER))
        {
            PopupMessage(m_hwndRichEdit,
                             IDS_SEMICOLON_IN_NAME);
            
            return NPR_STOP_PROCESSING;
        }
        if (m_fMultiselect &&
            (wch == L';' ||
             wch == L'\r' ||
             wch == OBJECT_REPLACEMENT_CHARACTER))
        {
            break;
        }
        strTerm += wch;
    }

    //
    // now itStart..itEnd is text to cut and replace with zero or more
    // objects.
    //

    // NTRAID#NTBUG9-486071-2002/01/15-lucios removed  m_strTerm.strip(String::BOTH);

    if (strTerm.empty())
    {
        Erase(itStart, itEnd);
        return npr;
    }

    //
    // strTerm is a nonempty string.  Replace it in the edit control with
    // a new object or objects.
    //


    CDsObject dsoNew(m_rop.GetScopeManager().GetCurScope().GetID(),
                     strTerm.c_str());

    return _ProcessObject(itStart, itEnd, &dsoNew);
}



//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::ReplaceSelOrAppend
//
//  Synopsis:   If the rich edit control has a selection, replace it
//              with the object [dso], otherwise append [dso] to the
//              rich edit's contents.
//
//  Arguments:  [dso] - object to insert
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::ReplaceSelOrAppend(
    const CDsObject &dso)
{
    //
    // See if the richedit has a selection.  If not, set the selection
    // to the end of the edit control.
    //

    ULONG cpStart = 0;
    ULONG cpEnd = 0;

    SendMessage(m_hwndRichEdit,
                EM_GETSEL,
                (WPARAM) &cpStart,
                (LPARAM) &cpEnd);

    iterator itInsertPos;

    if (cpStart == cpEnd)
    {
        // there is no selection

        ULONG cchRichEdit = GetWindowTextLength(m_hwndRichEdit);

        // append the object

        itInsertPos = cchRichEdit;

        if (cchRichEdit)
        {
            // there is something in the control already

            Insert(itInsertPos, L"; ");
            itInsertPos += 2;
        }
    }
    else
    {
        // there is a selection. delete it.
        SendMessage(m_hwndRichEdit, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)L"");

        // insert the object where the selection was
        itInsertPos = cpStart;
    }

    InsertObject(itInsertPos, dso);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::InsertObject
//
//  Synopsis:   Add a copy of [dso] to the selection dialog well.
//
//  History:    08-07-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::InsertObject(
    iterator itPos,
    const CDsObject &dso)
{
    TRACE_METHOD(CRichEditHelper, InsertObject);
    ASSERT(itPos <= end());

    HRESULT         hr = S_OK;
    REOBJECT        reobj;
    CEmbeddedDsObject *pedso = new CEmbeddedDsObject(dso, m_pGdiProvider);

    //
    // Initialize the object information structure
    //
    // REVIEWED-2002-02-2-lucios.
    ZeroMemory(&reobj, sizeof reobj);

    do
    {

        reobj.cbStruct  = sizeof(REOBJECT);
        reobj.cp        = REO_CP_SELECTION;
        reobj.clsid     = CLSID_DsOpObject;
        reobj.dwFlags   = REO_BELOWBASELINE
                            | REO_INVERTEDSELECT
                            | REO_DYNAMICSIZE
                            | REO_DONTNEEDPALETTE;
        reobj.dvaspect  = DVASPECT_CONTENT;
        reobj.poleobj   = (IOleObject *) pedso;

        hr = m_pRichEditOle->GetClientSite(&reobj.polesite);
        BREAK_ON_FAIL_HRESULT(hr);

        SendMessage(m_hwndRichEdit, EM_SETSEL, itPos, itPos);

        hr = m_pRichEditOle->InsertObject(&reobj);

        // NTRAID#NTBUG9-703188-2002/09/18-lucios
        // InsertObject addref'd it, so we should release it
        if(reobj.polesite) reobj.polesite->Release();

        BREAK_ON_FAIL_HRESULT(hr);

        _InsertionUpdateWindow(itPos, OBJECT_REPLACEMENT_CHARACTER_STR);
    } while (0);

    //
    // If the embedded ds object was successfully added to the richedit, the
    // control is keeping a refcount on it.
    //
    // Otherwise there was an error, and this release will drive its refcount
    // to zero, preventing it from being leaked.
    //

    pedso->Release();
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::AlreadyInRichEdit
//
//  Synopsis:   Return TRUE if [dso] matches an object already in the rich
//              edit control, FALSE otherwise.
//
//  Arguments:  [dso] - object for which to look for duplicate
//
//  History:    4-16-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CRichEditHelper::AlreadyInRichEdit(
    const CDsObject &dso)
{
    LONG cObjects = m_pRichEditOle->GetObjectCount();
    ASSERT(cObjects >= 0);
    LONG i;
    HRESULT hr = S_OK;

    for (i = 0; i < cObjects; i++)
    {
        REOBJECT reobj;

        reobj.cbStruct = sizeof(reobj);

        hr = m_pRichEditOle->GetObject(i, &reobj, REO_GETOBJ_POLEOBJ);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            continue;
        }

        ASSERT(reobj.poleobj);
        CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;
        reobj.poleobj->Release();

        if (*pdso == dso)
        {
            return TRUE;
        }
    }

    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::ReadChar
//
//  Synopsis:   Return the character in the rich edit control at position
//              [it].
//
//  Arguments:  [it] - position of character to read.
//
//  Returns:    Character read
//
//  History:    01-19-2000   davidmun   Created
//
//  Notes:      throws out_of_range exception if [it] is beyond the end of
//              the rich edit control
//
//---------------------------------------------------------------------------

WCHAR
CRichEditHelper::ReadChar(
    iterator it)
{
    if (it >= end())
    {
        ASSERT(it < end());
        return L'\0';
    }

    //
    // if char to read is within the nonempty window, read it from
    // window
    //

    if (m_itWindowLeft < m_itWindowRight &&
        it >= m_itWindowLeft &&
        it < m_itWindowRight)
    {
        return m_strWindow[it - m_itWindowLeft];
    }

    //
    // Rich edit contains requested character, fill the window starting
    // at that char.
    //
    //
    // NTRAID#NTBUG9-372779-2001/05/02-hiteshr
    // Office shipped with Richedit version4, Windows is using version3.
    // If we use EM_GETTEXTRANGE version4 which returns 0x0020 
    // for Embeddedchar while version 3 returns 0xfffc for Embeddedchar.
    // Since both version of Richedit control are shipped, we need to
    // change way we read text from richedit control.
    // Text Object Model interface returns 0xfffc for embeddedchar in 
    // both version3 and version4.
    ITextDocument * pTextDocument = NULL;
    if(SUCCEEDED(m_pRichEditOle->QueryInterface(IID_ITextDocument , (LPVOID*)&pTextDocument)))
    {
        ASSERT(pTextDocument);
        ITextRange *pTextRange = NULL;
        HRESULT hr = S_OK;
        if(SUCCEEDED(pTextDocument->Range(it, it + RE_WINDOW_READ_SIZE,&pTextRange)))
        {
            ASSERT(pTextRange);
            Bstr bstrText;
            hr = pTextRange->GetText(&bstrText);

            if(!bstrText.Empty())
                m_strWindow = bstrText.c_str();
            else
                m_strWindow = "";

            m_itWindowLeft = it;
            m_itWindowRight = static_cast<CRichEditHelper::iterator>(it + m_strWindow.length());
            pTextRange->Release();
        }
        else
        {
            pTextDocument->Release();
            return L'\0';
        }

        pTextDocument->Release();
    }
    else
    {
        TEXTRANGE TextRange;
        WCHAR wzBuf[RE_WINDOW_READ_SIZE + 1];

        TextRange.chrg.cpMin = it;
        TextRange.chrg.cpMax = TextRange.chrg.cpMin + ARRAYLEN(wzBuf) - 1;
        TextRange.lpstrText = wzBuf;

        SetLastError(0);
        LRESULT cchCopied = SendMessage(m_hwndRichEdit,
            EM_GETTEXTRANGE,
            0,
            (LPARAM) &TextRange);

        //
        // A read failure is probably out of memory
        //

        if (!cchCopied)
        {
            DBG_OUT_LASTERROR;
            return L'\0';
        }

        //
        // Fill window with the characters read
        //

        m_strWindow = wzBuf;
        m_itWindowLeft = it;
        m_itWindowRight = static_cast<CRichEditHelper::iterator>(it + cchCopied);
    }
    //
    // Return requested character
    //

    return !m_strWindow.empty() ? m_strWindow[it - m_itWindowLeft] : L'\0';
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::ProcessObject
//
//  Synopsis:   Ask the nth object [idxObject] which lies at position
//              [itPos] to process itself, which may result in its deletion
//              or in the insertion of additional objects.
//
//  Arguments:  [itPos]     - character position of object
//              [idxObject] - zero-based object number
//
//  Returns:    Result of processing
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CRichEditHelper::ProcessObject(
    iterator itPos,
    ULONG idxObject)
{
    ASSERT(itPos < end());
    ASSERT(idxObject < (ULONG) m_pRichEditOle->GetObjectCount());

    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    REOBJECT reobj;

    // REVIEWED-2002-02-2-lucios.
    ZeroMemory(&reobj, sizeof reobj);
    reobj.cbStruct = sizeof(reobj);

    do
    {
        HRESULT hr = m_pRichEditOle->GetObject(idxObject,
                                               &reobj,
                                               REO_GETOBJ_POLEOBJ);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            npr = NPR_STOP_PROCESSING;
            break;
        }

        ASSERT(reobj.poleobj);

        CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;

        npr = _ProcessObject(itPos, itPos, pdso);
        reobj.poleobj->Release();
    } while (0);

    return npr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::_ProcessObject
//
//  Synopsis:   Replace the range from [itStart] to [itEnd] with zero or
//              more objects that result from processing *[pdso].
//
//  Arguments:  [itStart] - start of range of text to replace
//              [itEnd]   - end of range of text to replace.  Equals
//                          [itStart] if the object is already in the
//                          control.
//              [pdso]    - object to process
//
//  Returns:    Result of processing object
//
//  History:    01-19-2000   davidmun   Created
//
//  Notes:      This private method does the work of the public methods
//              MakeObject and ProcessObject.
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CRichEditHelper::_ProcessObject(
    iterator itStart,
    iterator itEnd,
    CDsObject *pdso)
{
    ASSERT(itStart < end());
    ASSERT(itEnd <= end());
    ASSERT(pdso);

    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    CDsObjectList dsolAdditions;

    if (m_fMultiselect)
    {
        npr = pdso->Process(GetParent(m_hwndRichEdit),
                            m_rop,
                            &dsolAdditions);
    }
    else
    {
        npr = pdso->Process(GetParent(m_hwndRichEdit),
                            m_rop,
                            NULL);
    }

    if (npr != NPR_STOP_PROCESSING)
    {
        Erase(itStart, itEnd);
    }

    if (NAME_PROCESSING_FAILED(npr))
    {
        return npr; 
    }

    BOOL     fDuplicate = AlreadyInRichEdit(*pdso);
    iterator itPos = itStart;
    BOOL     fInsertedAnObject = FALSE;

    if (!fDuplicate)
    {
        fInsertedAnObject = TRUE;
        InsertObject(itPos, *pdso);
        itPos++;
    }

    CDsObjectList::iterator itDsol;

    for (itDsol = dsolAdditions.begin();
         itDsol != dsolAdditions.end();
         itDsol++)
    {
        if (AlreadyInRichEdit(*itDsol))
        {
            continue;
        }

        if (fInsertedAnObject)
        {
            Insert(itPos, L"; ");
            itPos += 2;
        }

        InsertObject(itPos, *itDsol);
        fInsertedAnObject = TRUE;
        itPos++;
    }

    return npr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\scope.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scope.cxx
//
//  Contents:   Implementations of the base and derived scope classes
//
//  Classes:    CScope
//              CLdapDomainScope
//              CLdapContainerScope
//              CTargetComputerScope
//              CWorkgroupScope
//              CGcScope
//              CWinNtDomainScope
//              CWinNtScope
//
//  History:    01-22-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


// declare storage for static member variable
ULONG CScope::s_ulNextID;

//
// Forward references
//

HRESULT
_DetermineDomainMode(
    HWND hwndDlg,
    const String &strDisplayName,
    DOMAIN_MODE *pDomainMode);



//+--------------------------------------------------------------------------
//
//  Member:     CScope::GetScopeFlags
//
//  Synopsis:   Return the DSOP_SCOPE_FLAG_* bits the caller set for scopes
//              of this type.
//
//  Returns:    DSOP_SCOPE_FLAG_* bits
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CScope::GetScopeFlags() const
{
    ASSERT(m_Type != ST_INVALID);

    if (m_Type == ST_LDAP_CONTAINER)
    {
        if (m_pParent)
        {
            return m_pParent->GetScopeFlags();
        }
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp;
    if(m_Type == ST_XFOREST)
    {
        psp = rsm.GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);
    }
    else
    {
        psp = rsm.GetScopeParams(m_Type);
    }
    ASSERT(psp);

    if (psp)
    {
        return psp->flScope;
    }
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScope::GetResultantDefaultFilterFlags
//
//  Synopsis:   Fill *[pulFlags] with the DSOP_FILTER_* or
//              DSOP_DOWNLEVEL_FILTER_* flags that apply to scopes of this
//              type--and this specific scope considering its domain mode.
//
//  Arguments:  [hwndDlg]  - for bind
//              [pulFlags] - filled with flags that apply to this scope
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CScope::GetResultantDefaultFilterFlags(
    HWND hwndDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CScope, GetResultantDefaultFilterFlags);

    ULONG flResultantFlags;

    HRESULT hr = GetResultantFilterFlags(hwndDlg, &flResultantFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    ULONG flScope = GetScopeFlags();
    ULONG flResultantDefaultFilterFlags = 0;

    if (::IsUplevel(m_Type))
    {
        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS) &&
            (flResultantFlags & DSOP_FILTER_USERS))
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_USERS;
        }

        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS) &&
            (flResultantFlags & DSOP_FILTER_COMPUTERS))
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_COMPUTERS;
        }

        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS) &&
            (flResultantFlags & DSOP_FILTER_CONTACTS))
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_CONTACTS;
        }

        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS) &&
            (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS);
        }

        if (!flResultantDefaultFilterFlags)
        {
            if (flResultantFlags & DSOP_FILTER_USERS)
            {
                flResultantDefaultFilterFlags |= DSOP_FILTER_USERS;
            }
            else if (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS)
            {
                flResultantDefaultFilterFlags |=
                    (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS);
            }
            else if (flResultantFlags & DSOP_FILTER_COMPUTERS)
            {
                flResultantDefaultFilterFlags |= DSOP_FILTER_COMPUTERS;
            }
            else if (flResultantFlags & DSOP_FILTER_CONTACTS)
            {
                flResultantDefaultFilterFlags |= DSOP_FILTER_CONTACTS;
            }
        }

        if (m_rop.GetExternalCustomizer() &&
            !(flScope & DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER);
        }

        flResultantDefaultFilterFlags |=
            (flResultantFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS);

        // something should be turned on at this point
        ASSERT(flResultantDefaultFilterFlags);

        if (flResultantFlags & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;
        }
    }
    else
    {
        if (m_Type != ST_WORKGROUP)
        {
            if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS) &&
                IsDownlevelFlagSet(flResultantFlags, DSOP_DOWNLEVEL_FILTER_USERS))
            {
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_USERS;
            }

            if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS) &&
                IsDownlevelFlagSet(flResultantFlags, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_COMPUTERS;
            }

            if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS) &&
                IsDownlevelFlagSet(flResultantFlags, ALL_DOWNLEVEL_GROUP_FILTERS))
            {
                flResultantDefaultFilterFlags |=
                    (flResultantFlags & ALL_DOWNLEVEL_GROUP_FILTERS);

                //
                // Since we're setting some group filter bits, make sure to
                // carry along the exclude_builtin_groups flag if it is set.
                //

                if (IsDownlevelFlagSet(flResultantFlags,
                                       DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
                }
            }
        }

        if (!flResultantDefaultFilterFlags)
        {
            if (m_Type == ST_WORKGROUP)
            {
                ASSERT(IsDownlevelFlagSet(flResultantFlags,
                                          DSOP_DOWNLEVEL_FILTER_COMPUTERS |
                                          DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER));

                //
                // These are the only two legal flags for a workgroup:
                // computers and external customizer.  if
                // DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER is not set,
                // check the customizer.  If
                // DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS is set, check the
                // computer.
                //

                if (!(flScope & DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER) &&
                    IsDownlevelFlagSet(flResultantFlags,
                                       DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
                }

                if (flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS)
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_COMPUTERS;
                }

                if (!flResultantDefaultFilterFlags)
                {
                    flResultantDefaultFilterFlags =
                        DSOP_DOWNLEVEL_FILTER_COMPUTERS;
                }
            }
            else if (IsDownlevelFlagSet(flResultantFlags,
                                   DSOP_DOWNLEVEL_FILTER_USERS))
            {
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_USERS;
            }
            else if (IsDownlevelFlagSet(flResultantFlags,
                                        ALL_DOWNLEVEL_GROUP_FILTERS))
            {
                flResultantDefaultFilterFlags |=
                    (flResultantFlags & ALL_DOWNLEVEL_GROUP_FILTERS);

                if (IsDownlevelFlagSet(flResultantFlags,
                                       DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
                }
            }
            else if (IsDownlevelFlagSet(flResultantFlags,
                                        DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                ASSERT(m_Type != ST_TARGET_COMPUTER);
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_COMPUTERS;
            }
        }

        if (m_rop.GetExternalCustomizer() &&
            !(flScope & DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER);
        }

        if (IsDownlevelFlagSet(flResultantFlags,
                               ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS);
        }
    }

    *pulFlags = flResultantDefaultFilterFlags;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapDomainScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags that are valid for this scope that
//              result from considering the domain mode.
//
//  Arguments:  [hwndBaseDlg] - for binding
//              [pulFlags]    - set to DSOP_FILTER_* flags
//
//  Returns:    HRESULT
//
//  History:    05-10-2000   DavidMun   Created
//
//  Notes:      Failure can result from user cancelling credentials dialog
//
//---------------------------------------------------------------------------

HRESULT
CLdapDomainScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CLdapDomainScope, GetResultantFilterFlags);

    HRESULT hr = S_OK;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    ASSERT(psp);
    ASSERT(pulFlags);

    do
    {
        if (!psp || !pulFlags)
        {
            hr = E_UNEXPECTED;  // if we get here it's a bug
            break;              // break to avoid AV on dereference
        }

        *pulFlags = 0;

        if (psp->FilterFlags.Uplevel.flMixedModeOnly !=
            psp->FilterFlags.Uplevel.flNativeModeOnly)
        {
            if (m_DomainMode == DM_UNDETERMINED)
            {
                hr = _DetermineDomainMode(hwndBaseDlg,
                                          m_strDisplayName,
                                          &m_DomainMode);
                BREAK_ON_FAIL_HRESULT(hr);
            }

            if (m_DomainMode == DM_NATIVE)
            {
                *pulFlags = psp->FilterFlags.Uplevel.flNativeModeOnly |
                            psp->FilterFlags.Uplevel.flBothModes;
            }
            else if (m_DomainMode == DM_MIXED)
            {
                *pulFlags = psp->FilterFlags.Uplevel.flMixedModeOnly |
                            psp->FilterFlags.Uplevel.flBothModes;
            }
            break;
        }

        *pulFlags = psp->FilterFlags.Uplevel.flNativeModeOnly |
                    psp->FilterFlags.Uplevel.flBothModes;
    } while (0);

    if (m_rop.GetExternalCustomizer())
    {
        *pulFlags |= DSOP_FILTER_EXTERNAL_CUSTOMIZER;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   _DetermineDomainMode
//
//  Synopsis:   Return the mode for domain with display name of
//              [strDisplayName].
//
//  Arguments:  [hwndBaseDlg] - for bind
//
//  Returns:    DM_MIXED or DM_NATIVE
//
//  History:    05-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
_DetermineDomainMode(
    HWND hwndBaseDlg,
    const String &strDisplayName,
    DOMAIN_MODE *pDomainMode)
{
    TRACE_FUNCTION(_DetermineDomainMode);

    HRESULT                             hr = S_OK;
    Variant                             varProcessor;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    PDOMAIN_CONTROLLER_INFO             pdci = NULL;
    DOMAIN_MODE                         DomainMode = DM_UNDETERMINED;

    do
    {

        ULONG  ulResult;
        RpIADs rpADs;

        //
        // DsRoleGetPrimaryDomainInformation will tell us the domain's
        // mode, but it requires the name of a computer in the domain.
        // Since all we have is the name of the domain, use that with
        // DsGetDcName to get the name of a DC for the domain.
        //

        {
            TIMER("DsGetDcName");

            ulResult = DsGetDcName(NULL,
                                   strDisplayName.c_str(),
                                   NULL,
                                   NULL,
                                   DS_IS_DNS_NAME
                                   |DS_RETURN_FLAT_NAME
                                   | DS_DIRECTORY_SERVICE_PREFERRED,
                                   &pdci);
        }

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws returned %uL, treating as native\n",
                strDisplayName.c_str(),
                ulResult);
            DomainMode = DM_NATIVE;
            break;
        }

        ULONG ulRetry;

        for (ulRetry = 0; ulRetry < 2; ulRetry++)
        {
            ASSERT(pdci->DomainControllerName && *pdci->DomainControllerName);

            {
                TIMER("DsRoleGetPrimaryDomainInformation");

                ulResult = DsRoleGetPrimaryDomainInformation(
                                pdci->DomainControllerName,
                                DsRolePrimaryDomainInfoBasic,
                                (PBYTE *)&pDsRole);
            }

            if (ulResult == ERROR_ACCESS_DENIED)
            {
                String strADsPath;

                strADsPath = pdci->DomainControllerName;
                strADsPath.strip(String::LEADING, L'\\');
                strADsPath.insert(0, c_wzWinNTPrefix);
                strADsPath += L",Computer";

                hr = g_pBinder->BindToObject(hwndBaseDlg,
                                             strADsPath.c_str(),
                                             IID_IADs,
                                             (void**)&rpADs);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else if (ulResult == RPC_S_SERVER_UNAVAILABLE)
            {
                Dbg(DEB_ERROR,
                    "DsRoleGetPrimaryDomainInformation for DC %ws in domain %ws returned RPC_S_SERVER_UNAVAILABLE, trying to find another DC\n",
                    pdci->DomainControllerName,
                    strDisplayName.c_str());

                String strPreviousDc(pdci->DomainControllerName);

                NetApiBufferFree(pdci);
                pdci = NULL;

                ULONG ulResult2;

                {
                    TIMER("DsGetDcName (forcing rediscovery)");

                    ulResult2 = DsGetDcName(NULL,
                                           strDisplayName.c_str(),
                                           NULL,
                                           NULL,
                                           DS_IS_DNS_NAME
                                           |DS_RETURN_FLAT_NAME
                                           | DS_FORCE_REDISCOVERY
                                           | DS_DIRECTORY_SERVICE_PREFERRED,
                                           &pdci);
                }

                if (ulResult2 != NO_ERROR)
                {
                    DBG_OUT_LRESULT(ulResult2);
                    break;
                }

                if (!strPreviousDc.icompare(pdci->DomainControllerName))
                {
                    Dbg(DEB_ERROR,
                        "DsGetDcName with DS_FORCE_REDISCOVERY returned same DC\n");
                    break;
                }

                rpADs = NULL;
            }
            else
            {
                break;
            }
        }
        BREAK_ON_FAIL_HRESULT(hr);

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsRoleGetPrimaryDomainInformation for DC %ws in domain %ws returned %uL, treating as native\n",
                pdci->DomainControllerName,
                strDisplayName.c_str(),
                ulResult);
            DomainMode = DM_NATIVE;
            break;
        }
        else if(NULL == pDsRole)
        {
            DBG_OUT_LRESULT(ERROR_UNEXP_NET_ERR);
            Dbg(DEB_TRACE,"Network issue found in WinSE Raid 21714, Whistler Raid 476297");
            hr = HRESULT_FROM_WIN32(ERROR_UNEXP_NET_ERR);
            break;
        }


        if (pDsRole->Flags & DSROLE_PRIMARY_DS_MIXED_MODE)
        {
            Dbg(DEB_TRACE,
                "Domain %ws is in mixed mode\n",
                strDisplayName.c_str());
            DomainMode = DM_MIXED;
        }
        else
        {
            Dbg(DEB_TRACE,
                "Domain %ws is in native mode\n",
                strDisplayName.c_str());
            DomainMode = DM_NATIVE;
        }
    } while (0);

    if (pdci)
    {
        NetApiBufferFree(pdci);
    }

    if (pDsRole)
    {
        DsRoleFreeMemory(pDsRole);
    }

    ASSERT(SUCCEEDED(hr) && DomainMode != DM_UNDETERMINED ||
           FAILED(hr) && DomainMode == DM_UNDETERMINED);
    *pDomainMode = DomainMode;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapDomainScope::CLdapDomainScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop]     - containing object picker instance
//              [asi]     - has initialization information
//              [pParent] - pointer to parent scope, or NULL if this is a
//                           root scope
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CLdapDomainScope::CLdapDomainScope(
    const CObjectPicker &rop,
    const ADD_SCOPE_INFO &asi,
    const CScope *pParent):
        CLdapContainerScope((SCOPE_TYPE)asi.flType, rop, pParent)
{
    TRACE_CONSTRUCTOR(CLdapDomainScope);

    m_strDisplayName = asi.Domain.strScopeName;
    m_strFlatName = asi.Domain.strFlatName;
    m_strADsPath = asi.Domain.strADsPath;
    m_DomainMode = asi.Domain.Mode;
    m_fPathIsDc = asi.Domain.fPathIsDc;
    m_bXForest = FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapContainerScope::Expand
//
//  Synopsis:   Fill *[pitBeginNew] and *[pitEndNew] with iterators at the
//              beginning and end of the child scopes of this.
//
//  Arguments:  [hwndDlg]     - for bind
//              [pitBeginNew] - filled with iterator at first child
//              [pitEndNew]   - filled with iterator at last child
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLdapContainerScope::Expand(
    HWND hwndDlg,
    vector<RpScope>::const_iterator *pitBeginNew,
    vector<RpScope>::const_iterator *pitEndNew) const
{
    TRACE_METHOD(CLdapContainerScope, Expand);
    ASSERT(!m_strADsPath.empty());

    // init for failure case: no scopes added
    *pitBeginNew = m_vrpChildren.begin();
    *pitEndNew = m_vrpChildren.begin();

    if (m_fExpanded)
    {
        return;
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();

    HRESULT hr = S_OK;
    SQueryParams qp;

    qp.rpScope                 = const_cast<CScope*>(static_cast<const CScope *>(this));
    qp.hwndCredPromptParentDlg = hwndDlg;
    qp.hwndNotify              = NULL;
    qp.strADsPath              = m_strADsPath;
    qp.strLdapFilter           = rsm.GetContainerFilter(hwndDlg);
    qp.ADsScope                = ADS_SCOPE_ONELEVEL;
    qp.Limit                   = QL_NO_LIMIT;
    qp.hQueryCompleteEvent     = CreateEvent(NULL, FALSE, FALSE, NULL);
    qp.vakAttributesToRead.push_back(AK_NAME);
    qp.vakAttributesToRead.push_back(AK_ADSPATH);
    // CustomizerInteraction initialized by ctor to IGNORE, which is correct

    //
    // If this is actually a CLdapDomainScope instance then it has a flag
    // indicating whether the path contains a server name.  If it does,
    // set a flag so we'll call ADsOpenObject with the ADS_SERVER_BIND bit.
    //

    const CLdapDomainScope *pThisAsDomain =
        dynamic_cast<const CLdapDomainScope *>(this);

    if (pThisAsDomain && pThisAsDomain->PathIsDc())
    {
        qp.ulBindFlags = DSOP_BIND_FLAG_PATH_IS_DC;
    }

    if (!qp.hQueryCompleteEvent)
    {
        DBG_OUT_LASTERROR;
        PopupMessage(hwndDlg, IDS_OUT_OF_MEMORY);
        return;
    }

    CQueryEngine qe(m_rop);
    hr = qe.Initialize();

    if(SUCCEEDED(hr))
        hr = qe.SyncDirSearch(qp);

    VERIFY(CloseHandle(qp.hQueryCompleteEvent));

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);

        String strError(GetErrorMessage(hr));

        PopupMessage(hwndDlg,
                     IDS_EXPAND_FAILED,
                     GetDisplayName().c_str(),
                     strError.c_str());
        return;
    }

    if (IsCredError(qe.GetLastQueryResult()))
    {
        Dbg(DEB_TRACE,
            "Query failed for lack of creds, not marking this as expanded\n");
        ASSERT(!qe.GetItemCount());
        return;
    }

    size_t i;
    size_t cChildrenBeforeAdding = m_vrpChildren.size();

    for (i = 0; i < qe.GetItemCount(); i++)
    {
        Variant varName    = qe.GetObjectAttr(i, AK_NAME);
        Variant varADsPath = qe.GetObjectAttr(i, AK_ADSPATH);

        if (varName.Type() != VT_BSTR || varADsPath.Type() != VT_BSTR)
        {
            continue;
        }

        RpScope rpScope;

        rpScope.Acquire(new CLdapContainerScope(ST_LDAP_CONTAINER,
                                                varName.GetBstr(),
                                                varADsPath.GetBstr(),
                                                m_rop,
                                                this));

        CLdapContainerScope *pNonConstThis = const_cast<CLdapContainerScope *>(this);

        pNonConstThis->AddChild(rpScope);
    }

    qe.Clear();
    m_fExpanded = TRUE;

    //
    // If we added any children, give caller iterators over them
    //

    if (cChildrenBeforeAdding < m_vrpChildren.size())
    {
        *pitBeginNew = m_vrpChildren.begin() + cChildrenBeforeAdding;
        *pitEndNew = m_vrpChildren.end();
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapContainerScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags that are valid for this scope that
//              result from considering the domain mode.
//
//  Arguments:  [hwndBaseDlg] - for bind
//              [pulFlags]    - points to variable filled with uplevel
//                              filter flags or 0 on error
//
//  Returns:    HRESULT
//
//  History:    02-25-2000   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLdapContainerScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CLdapContainerScope, GetResultantFilterFlags);

    HRESULT hr = S_OK;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    ASSERT(m_Type == ST_LDAP_CONTAINER ||
           m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE);
    ASSERT(m_Type == ST_LDAP_CONTAINER && !psp ||
           m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE && psp);
    ASSERT(m_Type == ST_LDAP_CONTAINER && m_pParent ||
           m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE && !m_pParent);
    ASSERT(pulFlags);

    //
    // This scope should either be an OU or a ST_USER_ENTERED_UPLEVEL_SCOPE.
    //
    // If it is an OU, recursively delegate to its parent until an
    // ldap domain scope is reached, which knows how to return flags for
    // itself.
    //
    // If it is a ST_USER_ENTERED_UPLEVEL_SCOPE, return the flags contained
    // in the scope parameters.
    //

    do
    {
        if (m_Type == ST_LDAP_CONTAINER)
        {
            if (!m_pParent)
            {
                break;
            }

            const CAdsiScope *pAdsiParent = dynamic_cast<const CAdsiScope *>(m_pParent);
            ASSERT(pAdsiParent);

            if (!pAdsiParent)
            {
                break;
            }

            hr = pAdsiParent->GetResultantFilterFlags(hwndBaseDlg, pulFlags);
            CHECK_HRESULT(hr);
            break;
        }

        // m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE

        if (m_DomainMode == DM_UNDETERMINED)
        {
            hr = _DetermineDomainMode(hwndBaseDlg,
                                      m_strDisplayName,
                                      &m_DomainMode);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        if(psp==NULL) {hr=E_FAIL;break;}
        *pulFlags = psp->FilterFlags.Uplevel.flBothModes;

        if (m_DomainMode == DM_NATIVE)
        {
            *pulFlags |= psp->FilterFlags.Uplevel.flNativeModeOnly;
        }
        else
        {
            *pulFlags |= psp->FilterFlags.Uplevel.flMixedModeOnly;
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTargetComputerScope::CTargetComputerScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CTargetComputerScope::CTargetComputerScope(
    const CObjectPicker &rop):
        CWinNtScope(ST_TARGET_COMPUTER, rop)
{
    TRACE_CONSTRUCTOR(CTargetComputerScope);

    m_strDisplayName = rop.GetTargetComputer();
    m_strADsPath = c_wzWinNTPrefix + m_strDisplayName + L",Computer";
}




//+--------------------------------------------------------------------------
//
//  Member:     CWorkgroupScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the workgroup
//
//  Arguments:  [hwnd]     - unused
//              [pstrPath] - filled with path of workgroup
//
//  Returns:    S_OK   - path valid
//              E_FAIL - path empty
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CWorkgroupScope::GetADsPath(
    HWND hwnd,
    String *pstrPath) const
{
    TRACE_METHOD(CWorkgroupScope, GetADsPath);

    if (!m_fInitialized)
    {
        CWorkgroupScope *pNonConstThis = const_cast<CWorkgroupScope *>(this);
        pNonConstThis->_Initialize();
    }
    *pstrPath = m_strADsPath;
    return m_strADsPath.empty() ? E_FAIL : S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWorkgroupScope::GetDisplayName
//
//  Synopsis:   Return the display name of this workgroup
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const String&
CWorkgroupScope::GetDisplayName() const
{
    TRACE_METHOD(CWorkgroupScope, GetDisplayName);

    if (!m_fInitialized)
    {
        CWorkgroupScope *pNonConstThis = const_cast<CWorkgroupScope *>(this);
        pNonConstThis->_Initialize();
    }
    return m_strDisplayName;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWorkgroupScope::_Initialize
//
//  Synopsis:   Initialize the workgroup scope by determining which
//              workgroup the target machine is in
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CWorkgroupScope::_Initialize()
{
    TRACE_METHOD(CWorkgroupScope, _Initialize);
    ASSERT(m_rop.GetTargetComputerConfig() == MC_IN_WORKGROUP);
    ASSERT(!m_fInitialized);

    HRESULT                     hr = S_OK;
    NTSTATUS                    nts = STATUS_SUCCESS;
    LSA_HANDLE                  hlsaServer = NULL;
    POLICY_ACCOUNT_DOMAIN_INFO *pAccountDomainInfo = NULL;
    POLICY_PRIMARY_DOMAIN_INFO *pPrimaryDomainInfo = NULL;

    do
    {
        hr = GetLsaAccountDomainInfo(m_rop.GetTargetComputer().c_str(),
                                     &hlsaServer,
                                     &pAccountDomainInfo);

        if (!hlsaServer)
        {
            DBG_OUT_HRESULT(hr);
            ASSERT(FAILED(hr));
            break;
        }

        //
        // Get the server's primary domain (or workgroup) and add it to the
        // scope
        //

        nts = LsaQueryInformationPolicy(hlsaServer,
                                        PolicyPrimaryDomainInformation,
                                        (LPVOID *)&pPrimaryDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);

        WCHAR wzPrimaryDomain[MAX_PATH];

        UnicodeStringToWsz(pPrimaryDomainInfo->Name,
                           wzPrimaryDomain,
                           ARRAYLEN(wzPrimaryDomain));

        m_strDisplayName = wzPrimaryDomain;
        m_strADsPath = c_wzWinNTPrefix;
        m_strADsPath += wzPrimaryDomain;
        //This is Just a hint in the path. This hint will not be
        //used in the path to bind.
        m_strADsPath += L",Workgroup";

        Dbg(DEB_TRACE, "Target machine is in workgroup '%ws'\n", wzPrimaryDomain);
        ASSERT(!pPrimaryDomainInfo->Sid);
    }
    while (0);

    if (pAccountDomainInfo)
    {
        LsaFreeMemory(pAccountDomainInfo);
    }

    if (pPrimaryDomainInfo)
    {
        LsaFreeMemory(pPrimaryDomainInfo);
    }

    if (hlsaServer)
    {
        LsaClose(hlsaServer);
    }

    m_fInitialized = TRUE;
}



//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::CGcScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of object picker
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CGcScope::CGcScope(
    const CObjectPicker &rop):
        CLdapContainerScope(ST_GLOBAL_CATALOG, rop, NULL)
{
    TRACE_CONSTRUCTOR(CGcScope);

    m_strDisplayName = String::load(IDS_DIRECTORY);
    m_strADsPath = c_wzGC;
    m_strADsPath += L"//";
    m_strADsPath += m_rop.GetTargetForest();
    // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
    // This looks safe, but there is no reason not to use format.
    WCHAR wzPort[20];
    wsprintf(wzPort, L":%u", LDAP_GC_PORT);
    m_strADsPath += wzPort;
}

//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags that apply to the GC scope.
//
//  Arguments:  [hwndBaseDlg] - unused
//              [pulFlags]    - points to variable filled with uplevel
//                              filter flags
//
//  Returns:    S_OK
//
//  History:    05-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CGcScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CGcScope, GetResultantFilterFlags);
    ASSERT(m_Type == ST_GLOBAL_CATALOG);

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    ASSERT(psp);
    ASSERT(pulFlags);

    if (!pulFlags)
    {
        DBG_OUT_HRESULT(E_POINTER);
        return E_POINTER;
    }

    *pulFlags = 0;

    if (psp)
    {
        *pulFlags = psp->FilterFlags.Uplevel.flBothModes |
                    psp->FilterFlags.Uplevel.flNativeModeOnly;
    }

    if (m_rop.GetExternalCustomizer())
    {
        *pulFlags |= DSOP_FILTER_EXTERNAL_CUSTOMIZER;
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::Expand
//
//  Synopsis:   Fill *[pitBeginNew] and *[pitEndNew] with iterators at the
//              beginning and end of the child scopes of this.
//
//  Arguments:  [hwndDlg]     - for bind
//              [pitBeginNew] - filled with iterator at first child
//              [pitEndNew]   - filled with iterator at last child
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CGcScope::Expand(
    HWND hwndDlg,
    vector<RpScope>::const_iterator *pitBeginNew,
    vector<RpScope>::const_iterator *pitEndNew) const
{
    TRACE_METHOD(CGcScope, Expand);

    //
    // This operation never results in new children; the only children
    // allowed under the GC scope are enterprise domains, which have already
    // been added.
    //

    *pitBeginNew = m_vrpChildren.begin();
    *pitEndNew = m_vrpChildren.begin();
    m_fExpanded = TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the Global Catalog
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CGcScope::GetADsPath(
    HWND hwnd,
    String *pstrPath) const
{
    *pstrPath = m_strADsPath;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the Global Catalog
//
//  Arguments:  [ppwzADsPath] - filled with GC path
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CGcScope::GetADsPath(
    PWSTR *ppwzADsPath)
{
    ASSERT(ppwzADsPath);
    HRESULT hr = S_OK;

    if (!m_strADsPath.empty())
    {
        hr = m_strADsPath.as_OLESTR(*ppwzADsPath);
    }
    else
    {
        *ppwzADsPath = NULL;
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWinNtScope::CWinNtScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning object picker instance
//              [asi] - intialization information
//
//  History:    03-15-2000   davidmun   Created
//
//  Notes:      This class is used for both NT4 domains discovered via
//              domain enumeration and for scopes created during name
//              resolution that have the type
//              DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE.
//
//---------------------------------------------------------------------------

CWinNtDomainScope::CWinNtDomainScope(
    const CObjectPicker &rop,
    const ADD_SCOPE_INFO &asi):
        CWinNtScope((SCOPE_TYPE)asi.flType, rop)
{
    TRACE_CONSTRUCTOR(CWinNtDomainScope);

    m_strDisplayName = asi.Domain.strScopeName;
    m_strADsPath = asi.Domain.strADsPath;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWinNtScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags which are valid for this scope
//
//  Arguments:  [hwndBaseDlg] - unused
//              [pulFlags]    - points to variable to be filled with flags
//
//  Returns:    S_OK
//
//  History:    05-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CWinNtScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CWinNtScope, GetResultantFilterFlags);

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    //
    // If target computer is joined to an NT4 domain, and this scope
    // represents that domain, then the type of this scope is
    // DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN.
    //
    // However, if no scope initializer with that scope type was specified
    // by caller, and caller did supply the scope initializer for
    // ST_ENTERPRISE_DOMAIN, use that.  This parallels the logic in
    // CScopeManager::_InitScopesJoinedNt4().
    //

    if (!psp)
    {
        psp = rsm.GetScopeParams(ST_ENTERPRISE_DOMAIN);
    }

    ASSERT(psp);
    ASSERT(pulFlags);

    if (!pulFlags)
    {
        DBG_OUT_HRESULT(E_POINTER);
        return E_POINTER;
    }

    *pulFlags = 0;

    if (psp)
    {
        *pulFlags = psp->FilterFlags.flDownlevel;

        if (m_Type == ST_TARGET_COMPUTER)
        {
            ULONG flComputerBit = DSOP_DOWNLEVEL_FILTER_COMPUTERS &
                                    ~DOWNLEVEL_FILTER_BIT;
            *pulFlags &= ~flComputerBit;
            ASSERT(*pulFlags & ~DOWNLEVEL_FILTER_BIT);
        }
        else if (m_Type == ST_WORKGROUP)
        {
            *pulFlags &= DSOP_DOWNLEVEL_FILTER_COMPUTERS;
            ASSERT(*pulFlags);
        }
    }

    if (m_rop.GetExternalCustomizer())
    {
        *pulFlags |= DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
    }

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Function:   IsUplevel
//
//  Synopsis:   Return TRUE if [Type] is an uplevel scope type, FALSE
//              otherwise.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsUplevel(
    SCOPE_TYPE Type)
{
    switch (Type)
    {
    case ST_ENTERPRISE_DOMAIN:
    case ST_GLOBAL_CATALOG:
    case ST_UPLEVEL_JOINED_DOMAIN:
    case ST_EXTERNAL_UPLEVEL_DOMAIN:
    case ST_USER_ENTERED_UPLEVEL_SCOPE:
    case ST_LDAP_CONTAINER:
    case ST_XFOREST:
        return TRUE;

    default:
        return FALSE;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   IsDownlevel
//
//  Synopsis:   Return TRUE if [Type] is a downlevel scope type, FALSE
//              otherwise.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsDownlevel(
    SCOPE_TYPE Type)
{
    switch (Type)
    {
    case ST_TARGET_COMPUTER:
    case ST_DOWNLEVEL_JOINED_DOMAIN:
    case ST_EXTERNAL_DOWNLEVEL_DOMAIN:
    case ST_WORKGROUP:
    case ST_USER_ENTERED_DOWNLEVEL_SCOPE:
        return TRUE;

    default:
        return FALSE;
    }
}



//
// Legacy methods (addref and release are used by both legacy and current
// implementation).
//

STDMETHODIMP_(HWND)
CScope::GetHwnd()
{
    TRACE_METHOD(CScope, GetHwnd);
    Dbg(DEB_WARN, "Warning: using legacy method\n");
    return NULL;
}

STDMETHODIMP
CScope::SetHwnd(
    HWND hwndScopeDialog)
{
    TRACE_METHOD(CScope, SetHwnd);
    Dbg(DEB_WARN, "Warning: using legacy method\n");
    return E_NOTIMPL;
}

STDMETHODIMP_(ULONG)
CScope::GetType()
{
    TRACE_METHOD(CScope, GetType);
    return static_cast<ULONG>(Type());
}

STDMETHODIMP
CScope::GetQueryInfo(
    PDSQUERYINFO *ppqi)
{
    TRACE_METHOD(CScope, GetQueryInfo);
    Dbg(DEB_WARN, "Warning: using legacy method\n");
    return E_NOTIMPL;
}

STDMETHODIMP_(BOOL)
CScope::IsUplevel()
{
    TRACE_METHOD(CScope, IsUplevel);
    return ::IsUplevel(m_Type);
}

STDMETHODIMP_(BOOL)
CScope::IsDownlevel()
{
    TRACE_METHOD(CScope, IsDownlevel);
    return ::IsDownlevel(m_Type);
}

STDMETHODIMP_(BOOL)
CScope::IsExternalDomain()
{
    TRACE_METHOD(CScope, IsExternalDomain);
    return m_Type == ST_EXTERNAL_DOWNLEVEL_DOMAIN ||
           m_Type == ST_EXTERNAL_UPLEVEL_DOMAIN;
}

STDMETHODIMP
CScope::GetADsPath(
    PWSTR *ppwzADsPath)
{
    TRACE_METHOD(CScope, GetADsPath(legacy));

    if (!ppwzADsPath)
    {
        return E_POINTER;
    }

    CAdsiScope *pAdsi = dynamic_cast<CAdsiScope *>(this);

    if (pAdsi)
    {
        String strPath;
        pAdsi->GetADsPath(NULL, &strPath);
        return strPath.as_OLESTR(*ppwzADsPath);
    }
    return E_UNEXPECTED;
}

STDMETHODIMP_(ULONG)
CScope::AddRef()
{
    return InterlockedIncrement((LONG*)&m_cRefs);
}

STDMETHODIMP_(ULONG)
CScope::Release()
{
    ULONG cRefs = InterlockedDecrement((LONG*)&m_cRefs);

    if (!cRefs)
    {
        delete this;
    }
    return cRefs;
}


STDMETHODIMP
CScope::QueryInterface(
    REFIID riid,
    LPVOID * ppv)
{
    TRACE_METHOD(CScope, QueryInterface);
    Dbg(DEB_WARN, "Warning: using legacy method\n");

    *ppv = NULL;
    return E_NOTIMPL;
}




/////////////// XForest Scope

//+--------------------------------------------------------------------------
//
//  Member:     CXForestScope::CXForestScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of object picker
//
//  History:    12-12-2001   Lucios   Created
//
//---------------------------------------------------------------------------

CXForestScope::CXForestScope(   const CObjectPicker &rop,
                                 const String &forest,
                                BOOL  _isFederated):
        CLdapContainerScope(ST_XFOREST, rop, NULL),
        m_forest(forest)
{
    TRACE_CONSTRUCTOR(CXForestScope);

    m_strDisplayName = forest;
    m_strADsPath = c_wzGC;
    m_strADsPath += L"//";
    m_strADsPath += forest;
    WCHAR wzPort[20];
    // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
    wsprintf(wzPort, L":%u", LDAP_GC_PORT);
    m_strADsPath += wzPort;
    m_isFederated = _isFederated;
}



//+--------------------------------------------------------------------------
//
//  Member:     CXForestScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags that apply to the GC scope.
//
//  Arguments:  [hwndBaseDlg] - unused
//              [pulFlags]    - points to variable filled with uplevel
//                              filter flags
//
//  Returns:    S_OK
//
//  History:    12-12-2001   Lucios   Created
//
//---------------------------------------------------------------------------

HRESULT
CXForestScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CGcScope, GetResultantFilterFlags);
    ASSERT(m_Type == ST_XFOREST);

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp=rsm.GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);

    ASSERT(psp);
    ASSERT(pulFlags);

    if (!pulFlags)
    {
        DBG_OUT_HRESULT(E_POINTER);
        return E_POINTER;
    }

    *pulFlags = 0;

    if (psp)
    {
        *pulFlags = psp->FilterFlags.Uplevel.flBothModes |
                    psp->FilterFlags.Uplevel.flNativeModeOnly;
    }

    if (m_rop.GetExternalCustomizer())
    {
        *pulFlags |= DSOP_FILTER_EXTERNAL_CUSTOMIZER;
    }
    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Member:     CXForestScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the Global Catalog
//
//  History:    12-12-2001   Lucios   Created
//
//---------------------------------------------------------------------------

HRESULT
CXForestScope::GetADsPath(
    HWND hwnd,
    String *pstrPath) const
{
    *pstrPath = m_strADsPath;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CXForestScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the Global Catalog
//
//  Arguments:  [ppwzADsPath] - filled with GC path
//
//  Returns:    HRESULT
//
//  History:    12-12-2001   Lucios   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CXForestScope::GetADsPath(
    PWSTR *ppwzADsPath)
{
    ASSERT(ppwzADsPath);
    HRESULT hr = S_OK;

    if (!m_strADsPath.empty())
    {
        hr = m_strADsPath.as_OLESTR(*ppwzADsPath);
    }
    else
    {
        *ppwzADsPath = NULL;
        hr = E_FAIL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\rootdse.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       rootdse.cxx
//
//  Contents:   Implementation of class to retrieve interfaces from
//              objects accessed via the RootDSE container.
//
//  Classes:    CRootDSE
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CRootDSE)

#define DSE_ATTEMPTED_INIT      0x0001
#define DSE_INIT_FAILED         0x0002


//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::CRootDSE
//
//  Synopsis:   ctor
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE::CRootDSE():
        m_pADsRootDSE(NULL),
        m_hrInitFailed(0)
{
    TRACE_CONSTRUCTOR(CRootDSE);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CRootDSE);

    m_wzTargetDomain[0] = L'\0';
    m_wzTargetForest[0] = L'\0';
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::CRootDSE
//
//  Synopsis:   Copy ctor
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE::CRootDSE(
    const CRootDSE &rdse)
{
    this->operator=(rdse);
}

//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::operator=
//
//  Synopsis:   Assignment operator
//
//  Arguments:  [rdse] - right hand side
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE &
CRootDSE::operator=(
    const CRootDSE &rdse)
{
    TRACE_CONSTRUCTOR(CRootDSE);

    m_pADsRootDSE = rdse.m_pADsRootDSE;

    if (m_pADsRootDSE)
    {
        m_pADsRootDSE->AddRef();
    }

    m_bstrConfigNamingContext = rdse.m_bstrConfigNamingContext;

    // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
    // both strings are MAX_PATH in size
    // can we make them String and be done with worries?
    lstrcpy(m_wzTargetDomain, rdse.m_wzTargetDomain);
    lstrcpy(m_wzTargetForest, rdse.m_wzTargetForest);

    return *this;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::Init
//
//  Synopsis:   Complete initialization.
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  History:    05-27-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::Init(
    PCWSTR pwzTargetDomain,
    PCWSTR pwzTargetForest)
{
    TRACE_METHOD(CRootDSE, Init);

    HRESULT hr = S_OK;

    do
    {
        if (pwzTargetDomain && *pwzTargetDomain)
        {
            // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
            // String might be a good alternative.
            lstrcpyn(m_wzTargetDomain,
                     pwzTargetDomain,
                     ARRAYLEN(m_wzTargetDomain));
        }
        else
        {
            hr = E_INVALIDARG;
            Dbg(DEB_ERROR,
                "CRootDSE::Init: target machine not joined to domain\n");
            break;
        }

        // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
        // String might be a good alternative.
        lstrcpyn(m_wzTargetForest,
                 pwzTargetForest,
                 ARRAYLEN(m_wzTargetForest));
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::~CRootDSE
//
//  Synopsis:   dtor
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE::~CRootDSE()
{
    TRACE_DESTRUCTOR(CRootDSE);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CRootDSE);

    SAFE_RELEASE(m_pADsRootDSE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::BindToWellKnownPrincipalsContainer
//
//  Synopsis:   Bind to the wkp container for interface [riid] and return
//              a pointer to that interface in *[ppvInterface].
//
//  Arguments:  [riid]         - interface for which to bind
//              [ppvInterface] - filled with interface instance
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppvInterface]
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::BindToWellKnownPrincipalsContainer(
    HWND        hwnd,
    REFIID      riid,
    void      **ppvInterface) const
{
    TRACE_METHOD(CRootDSE, BindToWellKnownPrincipalsContainer);

    HRESULT hr = S_OK;
    String  strWellKnown;

    do
    {
        if (_IsFlagSet(DSE_INIT_FAILED))
        {
            hr = m_hrInitFailed;
            break;
        }

        //
        // Demand-initialize
        //

        if (!_IsFlagSet(DSE_ATTEMPTED_INIT))
        {
            hr = _Init(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Create path to well-known security principals container
        //

        strWellKnown = String(c_wzLDAPPrefix) +
                       String(m_wzTargetDomain) +
                       String(L"/") +
                       String(c_wzWellKnown) +
                       String(m_bstrConfigNamingContext.c_str());

        //
        // Tell BindToObject that the config path may have a server portion
        // different than the DN.
        //
        // In other words, while the DN specifies a path to the root domain for
        // the WKSP container, the server portion will specify the joined
        // domain.
        //
        // This is possible because all domains replicate the contents of the
        // configuration container, which includes the WKSP container.  This is
        // a performance optimization because, in a large enterprise, the joined
        // domain DCs are more likely to be physically close to the target
        // machine than the root domain DCs.
        //

        hr = g_pBinder->BindToObject(hwnd,
                                     strWellKnown.c_str(),
                                     riid,
                                     ppvInterface,
                                     DSOP_BIND_FLAG_SERVER_NEQ_DN);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    ASSERT(SUCCEEDED(hr) && *ppvInterface ||
           FAILED(hr) && !*ppvInterface);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::BindToDisplaySpecifiersContainer
//
//  Synopsis:   Bind to the container beneath DisplaySpecifiers which
//              represents the user's default LANGID.
//
//  Arguments:  [hwnd]         - for bind
//              [riid]         - desired interface
//              [ppvInterface] - filled with desired interface on success
//
//  Returns:    HRESULT
//
//  History:    05-15-2000   DavidMun   Created
//
//  Notes:      If unable to get user's default lang id, uses system's.  If
//              Unable to get system's, uses US English.
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::BindToDisplaySpecifiersContainer(
    HWND        hwnd,
    REFIID      riid,
    void      **ppvInterface) const
{
    TRACE_METHOD(CRootDSE, BindToWellKnownPrincipalsContainer);

    HRESULT hr = S_OK;

    do
    {
        if (_IsFlagSet(DSE_INIT_FAILED))
        {
            hr = m_hrInitFailed;
            break;
        }

        //
        // Demand-initialize
        //

        if (!_IsFlagSet(DSE_ATTEMPTED_INIT))
        {
            hr = _Init(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Create path to well-known security principals
        //

        String strContainerPath;

        LANGID langid = GetUserDefaultUILanguage();

        if (!langid)
        {
            DBG_OUT_LASTERROR;
            langid = GetSystemDefaultUILanguage();
        }

        if (!langid)
        {
            DBG_OUT_LASTERROR;

            //
            // can't get user or system langid... try US English.
            // a fancier strategy would be to enumerate containers beneath
            // DisplaySpecifiers and pick one.
            //

            langid = 0x409;
        }

        strContainerPath = String(c_wzLDAPPrefix) +
                           String(m_wzTargetDomain )+
                           String(L"/") +
                           String::format(c_wzDisplaySpecifierContainerFmt,
                                          langid) +
                           String(m_bstrConfigNamingContext.c_str());

        hr = g_pBinder->BindToObject(hwnd,
                                     strContainerPath.c_str(),
                                     riid,
                                     ppvInterface,
                                     DSOP_BIND_FLAG_SERVER_NEQ_DN);
        if(hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            //
            //if langid is not 0x409, try with 0x409
            //
            if( langid != 0x409)
            {
                    langid = 0x409;
                    strContainerPath = String(c_wzLDAPPrefix) +
                           String(m_wzTargetDomain )+
                           String(L"/") +
                           String::format(c_wzDisplaySpecifierContainerFmt,
                                          langid) +
                           String(m_bstrConfigNamingContext.c_str());

                    hr = g_pBinder->BindToObject(hwnd,
                                                 strContainerPath.c_str(),
                                                 riid,
                                                 ppvInterface,
                                                 DSOP_BIND_FLAG_SERVER_NEQ_DN);
            }
        }
        
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);

    ASSERT(SUCCEEDED(hr) && *ppvInterface ||
           FAILED(hr) && !*ppvInterface);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::GetSchemaNc
//
//  Synopsis:   Return the schema naming context (the DN of the schema
//              container).
//
//  Returns:    Schema NC or empty string on error
//
//  History:    06-28-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CRootDSE::GetSchemaNc(
    HWND hwnd) const
{
    TRACE_METHOD(CRootDSE, GetSchemaNc);

    String strSchemaNc;

    do
    {
        if (_IsFlagSet(DSE_INIT_FAILED))
        {
            Dbg(DEB_ERROR, "DSE_INIT_FAILED set, returning empty string\n");
            break;
        }

        //
        // Demand-initialize
        //

        if (!_IsFlagSet(DSE_ATTEMPTED_INIT))
        {
            HRESULT hr = _Init(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        strSchemaNc = m_bstrSchemaNamingContext.c_str();
    } while (0);

    return strSchemaNc;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::_Init
//
//  Synopsis:   Obtain an interface to the RootDSE object.
//
//  Returns:    HRESULT
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::_Init(
    HWND hwnd) const
{
    TRACE_METHOD(CRootDSE, _Init);

    HRESULT hr = S_OK;
    Variant varConfig;

    m_hrInitFailed = S_OK;
    _SetFlag(DSE_ATTEMPTED_INIT);

    do
    {
        hr = g_pBinder->GetDomainRootDSE(hwnd,
                                         m_wzTargetDomain,
                                         &m_pADsRootDSE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Get the configuration naming context, used to build up
        // paths to configuration container, partitions container, etc.
        //

        hr = m_pADsRootDSE->Get(AutoBstr(c_wzConfigNamingContext), &varConfig);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(varConfig.GetBstr());

        m_bstrConfigNamingContext = varConfig.GetBstr();
        Dbg(DEB_TRACE,
            "m_bstrConfigNamingContext = '%ws'\n",
            m_bstrConfigNamingContext);

        //
        // Get the schema naming context
        //

        varConfig.Clear();

        hr = m_pADsRootDSE->Get(AutoBstr(c_wzSchemaNamingContext), &varConfig);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(varConfig.GetBstr());
        m_bstrSchemaNamingContext = varConfig.GetBstr();
    } while (0);

    //
    // If initialization failed because of a credential error, assume this
    // means that the user hit Cancel in a credential prompt dialog, and
    // clear the DSE_ATTEMPTED_INIT flag so that we will try again later
    // and give the user a second chance to enter creds.
    //
    // If the initialization failed for any other reason, set the
    // DSE_INIT_FAILED flag so we don't try to use the object.
    //

    if (FAILED(hr))
    {
        if (IsCredError(hr))
        {
            _ClearFlag(DSE_ATTEMPTED_INIT);
        }
        else
        {
            _SetFlag(DSE_INIT_FAILED);
            m_hrInitFailed = hr;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\row.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       row.cxx
//
//  Contents:   Implementation of class to fetch rows from an adsi query
//
//  Classes:    CRow
//
//  History:    03-30-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CRow)


//+--------------------------------------------------------------------------
//
//  Member:     CRow::CRow
//
//  Synopsis:   ctor
//
//  History:    03-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRow::CRow(
    HWND                       hwndParent,
    const CObjectPicker       &rop,
    IDirectorySearch          *pDirSearch,
    const String              &strQuery,
    const AttrKeyVector       &rvakAttrToRead):
#if (DBG == 1)
        m_fFirstRow(TRUE),
#endif
        m_rop(rop),
        m_hwndParent(hwndParent),
        m_hSearch(NULL),
        m_pDirSearch(pDirSearch),
        m_strQuery(strQuery),
        m_vakAttrToRead(rvakAttrToRead)
{
    TRACE_CONSTRUCTOR(CRow);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CRow);
    ASSERT(pDirSearch);
    ASSERT(!strQuery.empty());
    ASSERT(!rvakAttrToRead.empty());
    ASSERT(rvakAttrToRead.end() ==
           find(rvakAttrToRead.begin(), rvakAttrToRead.end(), AK_INVALID));

    pDirSearch->AddRef();
}




//+--------------------------------------------------------------------------
//
//  Member:     CRow::~CRow
//
//  Synopsis:   dtor
//
//  History:    03-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRow::~CRow()
{
    TRACE_DESTRUCTOR(CRow);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CRow);

    if (m_pDirSearch)
    {
        if (m_hSearch)
        {
            TIMER("Abandoning search and closing search handle");
            m_pDirSearch->AbandonSearch(m_hSearch);
            m_pDirSearch->CloseSearchHandle(m_hSearch);
            m_hSearch = NULL;
        }
        m_pDirSearch->Release();
        m_pDirSearch = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CRow::Next
//
//  Synopsis:   Read the next row returned by the query.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRow::Next()
{
    DBG_INDENTER;

    HRESULT hr = S_OK;
    const CAttributeManager &ram = m_rop.GetAttributeManager();
    ULONG i;

    do
    {
        //
        // Should have the search interface from Init
        //

        if (!m_pDirSearch)
        {
            hr = E_UNEXPECTED;
            Dbg(DEB_ERROR, "CRow::Next called but m_pDirSearch NULL\n");
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // If the search hasn't been started, do so
        //

        if (!m_hSearch)
        {
            ASSERT(m_pDirSearch);
            ASSERT(m_strQuery.length());

            DBG_DUMP_QUERY("Executing Search:", m_strQuery.c_str());

            //
            // ExecuteSearch wants an array of pointers to strings, where
            // each string is the name of an attribute to fetch.  Each of these
            // forms a column of the returned row.
            //

            PWSTR *apwzAttrs = new PWSTR[m_vakAttrToRead.size()];

            for (i = 0; i < m_vakAttrToRead.size(); i++)
            {
                apwzAttrs[i] =
                    const_cast<PWSTR>(ram.GetAttrAdsiName(m_vakAttrToRead[i]).c_str());
            }

            hr = m_pDirSearch->ExecuteSearch(const_cast<PWSTR>(m_strQuery.c_str()),
                                             apwzAttrs,
                                             static_cast<DWORD>(m_vakAttrToRead.size()),
                                             &m_hSearch);
            delete [] apwzAttrs;
            BREAK_ON_FAIL_HRESULT(hr);
            ASSERT(m_hSearch);
        }

        //
        // Get the next row
        //

        m_AttrValueMap.clear();

#if (DBG == 1)
        CTimer  *pTimer = NULL;

        if (m_fFirstRow)
        {
            pTimer = new CTimer;
            pTimer->Init("First call to GetNextRow");
        }
#endif
        hr = m_pDirSearch->GetNextRow(m_hSearch);

#if (DBG == 1)
        if (m_fFirstRow)
        {
            delete pTimer;
            pTimer = NULL;
            m_fFirstRow = FALSE;
        }
#endif

        BREAK_ON_FAIL_HRESULT(hr);

        if (hr == S_ADS_NOMORE_ROWS)
        {
            break;
        }

        //
        // Now put all the columns of the row into our variant vector
        //

        AttrKeyVector::const_iterator it;

        for (it = m_vakAttrToRead.begin();
             it != m_vakAttrToRead.end();
             it++)
        {
            ADS_SEARCH_COLUMN Col;
            //REVIEWED-2002-02-21-lucios.
            ZeroMemory(&Col, sizeof Col);

            hr = m_pDirSearch->GetColumn(m_hSearch,
                                         const_cast<PWSTR>(ram.GetAttrAdsiName(*it).c_str()),
                                         &Col);

            if (SUCCEEDED(hr))
            {
                Variant varFromCol = Col;

                m_AttrValueMap[*it] = varFromCol;
                hr = m_pDirSearch->FreeColumn(&Col);
                CHECK_HRESULT(hr);
            }
            else
            {
                hr = S_OK; // failure to get a particular column is not fatal
            }
        }
    }
    while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRow::GetColumnStr
//
//  Synopsis:   Return the string type attribute identified by [ak] from
//              the current row
//
//  Arguments:  [ak] - identifies attribute to fetch
//
//  Returns:    String attribute value, NULL if not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

PCWSTR
CRow::GetColumnStr(
    ATTR_KEY ak) const
{
    AttrValueMap::const_iterator it;

    it = m_AttrValueMap.find(ak);

    if (it == m_AttrValueMap.end())
    {
        return NULL;
    }

    const Variant &rvar = it->second;

    if (rvar.Type() != VT_BSTR)
    {
        ASSERT(rvar.Empty());

        if (!rvar.Empty())
        {
            Dbg(DEB_ERROR,
                "CRow::GetColumnStr: error vt=%uL, expected VT_BSTR or VT_EMPTY\n",
                rvar.Type());
        }
        return NULL;
    }

    return rvar.GetBstr();
}


PSID
CRow::GetObjectSid() 
{
    AttrValueMap::iterator it;

    it = m_AttrValueMap.find(AK_OBJECT_SID);

    if (it == m_AttrValueMap.end())
    {
        return NULL;
    }

    Variant &rvar = it->second;
    return (getSidFromVariant(rvar));
}

//+--------------------------------------------------------------------------
//
//  Member:     CRow::GetColumnInt
//
//  Synopsis:   Return the integer type attribute identified by [ak] from
//              the current row.
//
//  Arguments:  [ak] - identifies the attribute to fetch
//
//  Returns:    Integer attribute value, or 0 if not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CRow::GetColumnInt(
    ATTR_KEY ak) const
{
    AttrValueMap::const_iterator it;

    it = m_AttrValueMap.find(ak);

    if (it == m_AttrValueMap.end())
    {
        return NULL;
    }

    const Variant &rvar = it->second;

    if (rvar.Empty())
    {
        return 0;
    }

    ASSERT(rvar.Type() == VT_UI4);
    return V_UI4(&rvar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop



//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    Dbg(DEB_TRACE, "CSafeReg::Create(%x) '%s'\n", this, wszSubKey);
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    TRACE_METHOD(CSafeReg, Connect);
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;
    CWaitCursor Hourglass;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::DeleteTree
//
//  Synopsis:   Delete the subkey [wszSubKey] and all keys beneath it.
//
//  Arguments:  [wszSubKey] - name of root key of tree to delete
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::DeleteTree(
    LPCWSTR wszSubKey)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    do
    {
        CSafeReg shkSubKey;

        hr = shkSubKey.Open(_hKey,
                            wszSubKey,
                            KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        WCHAR wszEnumeratedKeyName[MAX_PATH];

        hr = shkSubKey.Enum(0,
                            wszEnumeratedKeyName,
                            ARRAYLEN(wszEnumeratedKeyName));
        CHECK_HRESULT(hr);

        if (hr != S_OK)
        {
            break;
        }

        //
        // Recursively delete keys below wszSubKey
        //

        hr = shkSubKey.DeleteTree(wszEnumeratedKeyName);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Since we've made a change to the key, the current enumeration
        // context is invalid.  We have to close the key and re-enumerate.
        //

        shkSubKey.Close();
    }
    while (TRUE);


    Dbg(DEB_TRACE, "CSafeReg::DeleteTree '%ws'\n", wszSubKey);
    LONG lr = RegDeleteKey(_hKey, wszSubKey);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::DeleteValue
//
//  Synopsis:   Delete the value [wszValueName] from the key
//
//  Arguments:  [wszValueName] - name of value to delete
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::DeleteValue(
    LPCWSTR wszValueName)
{
    Dbg(DEB_TRACE, "CSafeReg::DeleteValue '%ws'\n", wszValueName);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegDeleteValue(_hKey, wszValueName);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    // TRACE_METHOD(CSafeReg, Enum);
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    //REVIEWED-2002-02-23-lucios.
    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            DBG_OUT_LRESULT(lr);
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        *pwszSubkeyName = L'\0';
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        Dbg(DEB_WARN, "CSafeReg::Open: RegOpenKeyEx returned %uL\n", lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::QueryBufSize: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::QueryDword: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        DBG_OUT_LASTERROR;
                        hr = HRESULT_FROM_LASTERROR;
                    }
                    else
                    {
                        hr = E_FAIL;
                        Dbg(DEB_ERROR,
                            "CSafeReg::QueryPath: expanded string needs %u char buffer\n",
                            lr);
                    }
                }
                else
                {
                    // NTRAID#NTBUG9-548991-2002/02/23-lucios. Pending fix.
                    // We do have a cchPathBuf and an HRESULT!
                    // lets try to put them to some use
                    lstrcpy(pwszPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
        Dbg(DEB_ERROR,
            "CSafeReg::QueryPath: value '%s' has unexpected type %uL\n",
            pwszValueName,
            dwType);
    }
    else
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    if (FAILED(hr))
    {
        *pwszPathBuf = L'\0';
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryStr
//
//  Synopsis:   Query for a value named [pwszValueName] and put its string
//              value (REG_SZ, MULTI_SZ, or EXPAND_SZ) into [pwszBuf].
//
//  Arguments:  [pwszValueName] - name to query for
//              [pwszBuf]       - destination buffer
//              [cchBuf]        - size, in chars, of [pwszBuf]
//
//  Returns:    HRESULT
//
//  Modifies:   *[pwszBuf]; on failure it is set to an empty string.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
        Dbg(DEB_ERROR,
            "CSafeReg::QueryStr: value '%s' has unexpected type %uL\n",
            pwszValueName,
            dwType);
    }
    else if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    if (FAILED(hr))
    {
        *pwszBuf = L'\0';
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::WriteDword: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetValue
//
//  Synopsis:   Set the specified value
//
//  Arguments:  [wszValueName] - name of value, can be NULL if [ulType] is
//                                  REG_SZ
//              [ulType]       - REG_* type
//              [pbValue]      - points to value data
//              [cbValue]      - size, in bytes, of value data
//
//  Returns:    HRESULT
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\scopemanager.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scopemgr.cxx
//
//  Contents:   Implementation of scope manager and related classes
//
//  Classes:    CScopeManager
//              SScopeParameters
//
//  History:    01-25-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Class:      CDomainInfo (di)
//
//  Purpose:    Used to represent data elements returned by
//              DsEnumerateDomainTrusts.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CDomainInfo
{
public:

    CDomainInfo(): fAddedToParentsChildList(FALSE) {}

    list<CDomainInfo *> lpdiChildren;
    BOOL                fAddedToParentsChildList;
};

typedef list<CDomainInfo *> DomainInfoList;

//
// Forward references
//

inline BOOL
IsNonRootDomainInForest(
    PDS_DOMAIN_TRUSTS ptd);


void
GetContactAndAdvancedFilterSettings(
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel,
    BOOL fIsGc,
    BOOL *pfContactsYes,
    BOOL *pfContactsNo,
    BOOL *pfAdvancedYes,
    BOOL *pfAdvancedNo);




//+--------------------------------------------------------------------------
//
//  Member:     SScopeParameters::SScopeParameters
//
//  Synopsis:   ctor
//
//  Arguments:  [sii]           - caller's original parameter
//              [flLegalScopes] - mask indicating which of the scopes the
//                                 caller lists in [sii.flType] are valid
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

SScopeParameters::SScopeParameters(
    const DSOP_SCOPE_INIT_INFO &sii,
    ULONG flLegalScopes)
{
    flType = sii.flType & flLegalScopes;
    flScope = sii.flScope;
    FilterFlags = sii.FilterFlags;

    //
    // If the caller's init info structure contains the
    // DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS flag, it
    // represents all the downlevel group flags, so change it
    // into those flags in the private copy.
    //

    if ((FilterFlags.flDownlevel &
         DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS) ==
        DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS)
    {
        //
        // Turn off the DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS
        // flag in the private copy.  Note this momentarily
        // breaks flDownlevel by turning off the
        // DSOP_DOWNLEVEL_FILTER_BIT, but we're about to add
        // that back in.
        //

        FilterFlags.flDownlevel &= ~DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

        //
        // Add in all the builtin group flags.
        //

        FilterFlags.flDownlevel |= ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
    }

    if (sii.pwzDcName)
    {
        strDcName = sii.pwzDcName;
        strDcName.strip(String::LEADING, L'\\');
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   IsInitInfoForStartingScope
//
//  Synopsis:   Returns TRUE if [ScopeInfo] contains the
//              DSOP_SCOPE_FLAG_STARTING_SCOPE flag.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

inline BOOL
IsInitInfoForStartingScope(const DSOP_SCOPE_INIT_INFO &ScopeInfo)
{
    return 0 != (ScopeInfo.flScope & DSOP_SCOPE_FLAG_STARTING_SCOPE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::Clear
//
//  Synopsis:   Reset internal state.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CScopeManager::Clear()
{
    TRACE_METHOD(CScopeManager, Clear);

    if (m_hScopeImageList)
    {
        ImageList_RemoveAll(m_hScopeImageList);
    }
    m_vrpRootScopes.clear();
    m_vScopeParameters.clear();
    m_StartingScopeType = ST_INVALID;
    m_rpStartingScope.Relinquish();
    m_rpCurScope.Relinquish();
    m_strContainerFilter.erase();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::Initialize
//
//  Synopsis:   Process all the scope flags and related information in
//              [pInitInfo].
//
//  Arguments:  [pInitInfo] - points to scope initialization info
//
//  Returns:    HRESULT
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      If this routine returns a failure the OP dialog will not
//              open.
//
//---------------------------------------------------------------------------

HRESULT
CScopeManager::Initialize(
    PCDSOP_INIT_INFO pInitInfo)
{
    TRACE_METHOD(CScopeManager, Initialize);
    ASSERT(pInitInfo);

    HRESULT         hr = S_OK;
    MACHINE_CONFIG  mc = MC_UNKNOWN;

    do
    {
        //
        // Clear any data from previous initialization/use
        //

        if (!m_hScopeImageList)
        {
            m_hScopeImageList =
                ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 1, 1);
        }

        //
        // Caller must request at least one type of scope
        //

        if (!pInitInfo->cDsScopeInfos)
        {
            hr = E_INVALIDARG;
            Dbg(DEB_ERROR, "Error: scope count is 0\n");
            PopupMessage(GetForegroundWindow(), IDS_INIT_FAILED_BAD_ARGS);
            break;
        }

        //
        // Determine the target computer's configuration: no-net, standalone,
        // domain member, etc.
        //

        mc = m_rop.GetTargetComputerConfig();

        //
        // Make a mask of the scope types that are valid for the target
        // computer's configuration.
        //

        ULONG flLegalScopes = 0;

        switch (mc)
        {
        case MC_NO_NETWORK:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
            break;

        case MC_IN_WORKGROUP:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER
                                 | DSOP_SCOPE_TYPE_WORKGROUP
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            break;

        case MC_NT4_DC:
            if (!(m_rop.GetInitInfoOptions() &
                  DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK))
            {
                flLegalScopes = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
                                     | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
                break;
            }
            // else FALL THROUGH

        case MC_JOINED_NT4:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER
                                 | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
                                 | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                 | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            break;

        case MC_NT5_DC:
            if (!(m_rop.GetInitInfoOptions() &
                  DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK))
            {
                flLegalScopes = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                                     | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                     | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
                break;
            }
            // else FALL THROUGH

        case MC_JOINED_NT5:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER
                                 | DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                                 | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                 | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                                 | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            break;

        default:
            Dbg(DEB_ERROR,
                "Invalid target computer configuration const %uL\n",
                mc);
            ASSERT(0 && "invalid target computer configuration const");
            break;
        }

        //
        // Loop through the caller's scope initializers and make a private
        // copy of those which are meaningful for the target computer
        // configuration.
        //
        // At the same time, set pointers to the private copies of scope
        // initializers.  These will be passed to the individual scope
        // objects; they'll use them to determine what their settings are.
        //
        m_vScopeParameters.reserve(pInitInfo->cDsScopeInfos);

        PDSOP_SCOPE_INIT_INFO psiiCur = NULL;
        PDSOP_SCOPE_INIT_INFO psiiGc = NULL;
        PDSOP_SCOPE_INIT_INFO psiiUplevelJoinedDomain = NULL;
        ULONG i;

        for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
        {
            psiiCur = &pInitInfo->aDsScopeInfos[i];
            psiiCur->hr = S_OK;

            //
            // Skip this scope init struct if none of the scope types it
            // specifies apply given the target machine configuration.
            //

            if (!(psiiCur->flType & flLegalScopes))
            {
                psiiCur->hr = S_FALSE;
                continue;
            }

            //
            // Check the filter flags specified for the scope.  If they're
            // invalid, skip it.
            //

            psiiCur->hr = _ValidateFilterFlags(psiiCur,
                                               psiiCur->flType &
                                               flLegalScopes);

            if (FAILED(psiiCur->hr))
            {
                continue;
            }

            //
            // The scope initializer applies to the target computer's
            // configuration and has valid filter flags.  Make a copy.
            //

            SScopeParameters sp(*psiiCur, flLegalScopes);
            m_vScopeParameters.push_back(sp);

            if (sp.flType & DSOP_SCOPE_TYPE_GLOBAL_CATALOG)
            {
                psiiGc = psiiCur;
            }

            if (sp.flType & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN)
            {
                psiiUplevelJoinedDomain = psiiCur;
            }

            //
            // Remember the type of the scope initializer marked as the
            // starting scope.
            //

            if (IsInitInfoForStartingScope(*psiiCur))
            {
                m_StartingScopeType = static_cast<SCOPE_TYPE>(psiiCur->flType & flLegalScopes);
            }

        }
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If no scope initializer was marked valid, we have no
        // scopes and cannot open.
        //

        if (m_vScopeParameters.empty())
        {
            PopupMessage(GetForegroundWindow(), IDS_INIT_FAILED_NO_SCOPES);
            hr = E_INVALIDARG;
            break;
        }

        //
        // One last check: if the GC and uplevel joined domain scopes
        // are both supplied, they must have the same settings for
        // contacts and advanced view.
        //

        if (psiiGc && psiiUplevelJoinedDomain)
        {
            BOOL fJoinedContactsYes = FALSE;
            BOOL fJoinedContactsNo  = FALSE;
            BOOL fJoinedAdvancedYes = FALSE;
            BOOL fJoinedAdvancedNo  = FALSE;

            BOOL fGcContactsYes = FALSE;
            BOOL fGcContactsNo  = FALSE;
            BOOL fGcAdvancedYes = FALSE;
            BOOL fGcAdvancedNo  = FALSE;

            GetContactAndAdvancedFilterSettings(
                psiiUplevelJoinedDomain->FilterFlags.Uplevel,
                FALSE,
                &fJoinedContactsYes,
                &fJoinedContactsNo,
                &fJoinedAdvancedYes,
                &fJoinedAdvancedNo);

            GetContactAndAdvancedFilterSettings(
                psiiGc->FilterFlags.Uplevel,
                TRUE,
                &fGcContactsYes,
                &fGcContactsNo,
                &fGcAdvancedYes,
                &fGcAdvancedNo);

            if (fJoinedContactsYes && fGcContactsNo  ||
                fJoinedContactsNo  && fGcContactsYes ||
                fJoinedAdvancedYes && fGcAdvancedNo  ||
                fJoinedAdvancedNo  && fGcAdvancedYes)
            {
                hr = E_INVALIDARG;
                psiiGc->hr = hr;
                psiiUplevelJoinedDomain->hr = hr;
                DBG_OUT_HRESULT(hr);
                PopupMessage(GetForegroundWindow(),
                             IDS_INIT_FAILED_BAD_ARGS);
                break;
            }
        }

        //
        // There is at least one usable scope initializer.
        //
        // Scope objects are hierarchical and should be added in a particular
        // order.
        //

        if (GetScopeParams(ST_TARGET_COMPUTER))
        {
            RpScope rps;

            rps.Acquire(new CTargetComputerScope(m_rop));
            m_vrpRootScopes.push_back(rps);

            // NTRAID#NTBUG9-503865-2002/01/15-lucios
            if (
                    ( (m_StartingScopeType & ST_TARGET_COMPUTER)!=0 ) &&
                    !m_rpStartingScope.get()
               )
            {
                m_rpStartingScope = rps;
            }
        }

        if (GetScopeParams(ST_WORKGROUP))
        {
            RpScope rps;
            rps.Acquire(new CWorkgroupScope(m_rop));
            m_vrpRootScopes.push_back(rps);

            // NTRAID#NTBUG9-503865-2002/01/15-lucios
            if ( 
                    ( (m_StartingScopeType & ST_WORKGROUP)!=0 ) &&
                    !m_rpStartingScope.get()
               )
            {
                m_rpStartingScope = rps;
            }
        }

        RpScope rpScopeGc;

        if (GetScopeParams(ST_GLOBAL_CATALOG))
        {
            rpScopeGc.Acquire(new CGcScope(m_rop));

            m_vrpRootScopes.push_back(rpScopeGc);

            // NTRAID#NTBUG9-503865-2002/01/15-lucios
            if ( 
                ( (m_StartingScopeType & ST_GLOBAL_CATALOG)!=0 ) &&
                !m_rpStartingScope.get()
               )
            {
                m_rpStartingScope = rpScopeGc;
            }
        }

        if (mc == MC_JOINED_NT5 || mc == MC_NT5_DC)
        {
            if (GetScopeParams(ST_UPLEVEL_JOINED_DOMAIN)
                || GetScopeParams(ST_ENTERPRISE_DOMAIN)
                || GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN)
                || GetScopeParams(ST_EXTERNAL_DOWNLEVEL_DOMAIN))
            {
                _InitDomainScopesJoinedNt5((CGcScope*)rpScopeGc.get());
            }
        }
        else if (mc == MC_JOINED_NT4 || mc == MC_NT4_DC)
        {
            _InitScopesJoinedNt4();
        }

        //
        // At this point if there are no root scopes, then none of the
        // legal scopes specified by the caller could be added, and we
        // must fail.
        //

        if (m_vrpRootScopes.empty())
        {
            PopupMessage(GetForegroundWindow(), IDS_INIT_FAILED_NO_SCOPES);
            hr = E_INVALIDARG;
            break;
        }

        if (m_rpStartingScope.get())
        {
            m_rpCurScope = m_rpStartingScope;
        }
        else
        {
            m_rpCurScope = m_vrpRootScopes[0];
        }
    }
    while (0);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_InitContainerFilter
//
//  Synopsis:   Construct the LDAP filter to use when searching for
//              containers beneath domainDns objects.
//
//  Arguments:  [hwnd] - for bind
//
//  History:    06-19-2000   DavidMun   Created
//
//  Notes:      See CScope::Expand().
//
//---------------------------------------------------------------------------

void
CScopeManager::_InitContainerFilter(
    HWND hwnd) const
{
    TRACE_METHOD(CScopeManager, _InitContainerFilter);
    ASSERT(m_strContainerFilter.empty());
    ASSERT(IsWindow(hwnd));

    HRESULT hr = S_OK;

    do
    {
        RpIADsContainer rpContainer;
        const CRootDSE &dse = m_rop.GetRootDSE();

        hr = dse.BindToDisplaySpecifiersContainer(hwnd,
                                                  IID_IADsContainer,
                                                  reinterpret_cast<void**>(&rpContainer));
        BREAK_ON_FAIL_HRESULT(hr);

        RpIDispatch rpDispatch;

        hr = rpContainer->GetObject(AutoBstr(c_wzSettingsObjectClass),
                                    AutoBstr(c_wzSettingsObject),
                                    &rpDispatch);
        BREAK_ON_FAIL_HRESULT(hr);

        RpIADs rpADs;

        hr = rpDispatch->QueryInterface(IID_IADs, reinterpret_cast<void**>(&rpADs));
        BREAK_ON_FAIL_HRESULT(hr);

        Variant var;

        hr = rpADs->Get(AutoBstr(c_wzFilterContainers), &var);
        BREAK_ON_FAIL_HRESULT(hr);

        if (var.Type() == VT_BSTR)
        {
            m_strContainerFilter = L"(objectCategory=" +
                                        String(var.GetBstr()) +
                                   L")";
            break;
        }

        ASSERT(var.Type() == (VT_ARRAY | VT_VARIANT));

        if (var.Type() != (VT_ARRAY | VT_VARIANT))
        {
            break;
        }

        SAFEARRAY *saAttributes = V_ARRAY(&var);

        //
        // Figure out the dimensions of the array.
        //

        LONG lStart;
        LONG lEnd;

        hr = SafeArrayGetLBound(saAttributes, 1, &lStart);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = SafeArrayGetUBound(saAttributes, 1, &lEnd);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Process the array elements.
        //

        LONG lCurrent;
        ULONG cAdded = 0;
        String strSchemaNc = m_rop.GetRootDSE().GetSchemaNc(hwnd);

        for (lCurrent = lStart; lCurrent <= lEnd; lCurrent++)
        {
            Variant varElement;

            hr = SafeArrayGetElement( saAttributes, &lCurrent, &varElement);

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                continue;
            }

            ASSERT(varElement.Type() == VT_BSTR);

            if (varElement.Type() != VT_BSTR)
            {
                continue;
            }

            m_strContainerFilter += L"(objectCategory=CN=" +
                                         String(varElement.GetBstr()) +
                                         L"," +
                                         strSchemaNc +
                                    L")";
            cAdded++;
        }

        if (cAdded > 1)
        {
            m_strContainerFilter.insert(0, L"(|");
            m_strContainerFilter += L")";
        }
    } while (0);

    if (m_strContainerFilter.empty())
    {
        m_strContainerFilter = c_wzDefaultContainerFilter;
    }
}



const ULONG
c_ulDnPickerScopeFlagsTurnedOff =
    DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
    | DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP
    | DSOP_SCOPE_FLAG_WANT_PROVIDER_GC
    | DSOP_SCOPE_FLAG_WANT_SID_PATH
    | DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH;

const ULONG
c_ulDnPickerFilterFlagsTurnedOn =
    DSOP_FILTER_INCLUDE_ADVANCED_VIEW
    | DSOP_FILTER_USERS
    | DSOP_FILTER_BUILTIN_GROUPS
    | DSOP_FILTER_WELL_KNOWN_PRINCIPALS
    | DSOP_FILTER_UNIVERSAL_GROUPS_DL
    | DSOP_FILTER_UNIVERSAL_GROUPS_SE
    | DSOP_FILTER_GLOBAL_GROUPS_DL
    | DSOP_FILTER_GLOBAL_GROUPS_SE
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
    | DSOP_FILTER_CONTACTS
    | DSOP_FILTER_COMPUTERS;


//+--------------------------------------------------------------------------
//
//  Function:   GetContactAndAdvancedFilterSettings
//
//  Synopsis:
//
//  Arguments:  [Uplevel]       - the flags to examine when setting the out
//                                  parameters
//              [fIsGc]         - TRUE if [Uplevel] flags are for GC
//              [pfContactsYes] - set to TRUE if filter flag for contact
//                                 objects is set in any part of [Uplevel]
//              [pfContactsNo]  - set to TRUE if filter flag for contact
//                                 objects is NOT set in any part of
//                                 [Uplevel]
//              [pfAdvancedYes] - set to TRUE if filter flag for including
//                                 objects marked as advanced view only is
//                                 set in any part of [Uplevel].
//              [pfAdvancedNo]  - set to TRUE if filter flag for including
//                                 objects marked as advanced view only is
//                                 NOT set in any part of [Uplevel].
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
GetContactAndAdvancedFilterSettings(
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel,
    BOOL fIsGc,
    BOOL *pfContactsYes,
    BOOL *pfContactsNo,
    BOOL *pfAdvancedYes,
    BOOL *pfAdvancedNo)
{
    ULONG flAllModes = Uplevel.flBothModes
        | Uplevel.flNativeModeOnly
        | Uplevel.flMixedModeOnly;

    if (flAllModes & DSOP_FILTER_CONTACTS)
    {
        *pfContactsYes = TRUE;

        if (Uplevel.flBothModes & DSOP_FILTER_CONTACTS)
        {
            *pfContactsNo = FALSE;
        }
        else if (!(Uplevel.flNativeModeOnly & DSOP_FILTER_CONTACTS))
        {
            *pfContactsNo = TRUE;
        }
        else if (!(Uplevel.flMixedModeOnly & DSOP_FILTER_CONTACTS))
        {
            // the GC ignores the mixed mode flags

            if (!fIsGc)
            {
                *pfContactsNo = TRUE;
            }
        }
        else
        {
            *pfContactsNo = FALSE;
        }
    }
    else
    {
        *pfContactsYes = FALSE;
        *pfContactsNo = TRUE;
    }


    if (flAllModes & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
    {
        *pfAdvancedYes = TRUE;

        if (Uplevel.flBothModes & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
        {
            *pfAdvancedNo = FALSE;
        }
        else if (!(Uplevel.flNativeModeOnly & DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
        {
            *pfAdvancedNo = TRUE;
        }
        else if (!(Uplevel.flMixedModeOnly & DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
        {
            // the GC ignores the mixed mode flags

            if (!fIsGc)
            {
                *pfAdvancedNo = TRUE;
            }
        }
        else
        {
            *pfAdvancedNo = FALSE;
        }
    }
    else
    {
        *pfAdvancedYes = FALSE;
        *pfAdvancedNo = TRUE;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::GetScopeParams
//
//  Synopsis:   Return a pointer to the scope parameter structure which
//              governs operation of scopes of type [Type], or NULL if none
//              is found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const SScopeParameters *
CScopeManager::GetScopeParams(
    SCOPE_TYPE Type) const
{
    vector<SScopeParameters>::const_iterator it;

    for (it = m_vScopeParameters.begin(); it != m_vScopeParameters.end(); it++)
    {
        if (it->flType & Type)
        {
            return &*it;
        }
    }
    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::LookupScopeByDisplayName
//
//  Synopsis:   Return a reference to the scope which has name
//              [strDisplayName] in the UI.
//
//  Arguments:  [strDisplayName] - name to search for
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::LookupScopeByDisplayName(
    const String &strDisplayName) const
{
    return _LookupScopeByName(strDisplayName,
                              NAME_IS_DISPLAY_NAME,
                              m_vrpRootScopes.begin(),
                              m_vrpRootScopes.end());
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::LookupScopeByFlatName
//
//  Synopsis:   Return a reference to the scope which has netbios name
//              [strFlatName].
//
//  Arguments:  [strFlatName] - name to search for
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::LookupScopeByFlatName(
    const String &strFlatName) const
{
    return _LookupScopeByName(strFlatName,
                              NAME_IS_FLAT_NAME,
                              m_vrpRootScopes.begin(),
                              m_vrpRootScopes.end());
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_LookupScopeByName
//
//  Synopsis:   Return a reference to the scope which has netbios or display
//              name  [strName].
//
//  Arguments:  [strName] - name to search for
//              [NameIs]  - NAME_IS_DISPLAY_NAME or NAME_IS_FLAT_NAME
//              [itBegin] - scope to start search
//              [itEnd]   - just past scope to end search
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::_LookupScopeByName(
    const String &strName,
    SCOPE_NAME_TYPE NameIs,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd) const
{
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        // disregard scopes which are not domains or computers

        if (it->get()->Type() == ST_WORKGROUP ||
            it->get()->Type() == ST_LDAP_CONTAINER)
        {
            continue;
        }

        if (
                (it->get()->Type() == ST_GLOBAL_CATALOG) ||
                (it->get()->Type() == ST_XFOREST)
            )
        {
            // don't compare against GC itself, but do look at its children
            // In the XForest case the name should be UPN.
        }
        else if (NameIs == NAME_IS_DISPLAY_NAME || IsDownlevel(it->get()->Type()))
        {
            if (!strName.icompare(it->get()->GetDisplayName()))
            {
                return *it->get();
            }
        }
        else if ( (it->get()->Type() == ST_USER_ENTERED_UPLEVEL_SCOPE) )
        {
            CScope *pScope = it->get();
            const String &rstrDisplayName = pScope->GetDisplayName();

            if (!strName.icompare(rstrDisplayName))
            {
                return *it->get();
            }
        }
        else
        {
            ASSERT(it->get()->Type() == ST_EXTERNAL_UPLEVEL_DOMAIN ||
                it->get()->Type() == ST_UPLEVEL_JOINED_DOMAIN ||
                it->get()->Type() == ST_ENTERPRISE_DOMAIN);

            CScope *pScope = it->get();
            CLdapDomainScope *pDomainScope =
                dynamic_cast<CLdapDomainScope *>(pScope);

            ASSERT(pDomainScope);
            if (!pDomainScope)
            {
                continue;
            }

            if (!strName.icompare(pDomainScope->GetFlatName()))
            {
                return *it->get();
            }
        }


        if (it->get()->GetCurrentImmediateChildCount())
        {
            vector<RpScope>::const_iterator itChildBegin;
            vector<RpScope>::const_iterator itChildEnd;

            it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

            const CScope &rMatching = _LookupScopeByName(strName,
                                                         NameIs,
                                                         itChildBegin,
                                                         itChildEnd);

            if (rMatching.Type() != ST_INVALID)
            {
                return rMatching;
            }
        }
    }
    return *m_rpInvalidScope.get();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_LookupScopeByType
//
//  Synopsis:   Return a reference to the first scope found that has
//              scope type [Type].
//
//  Arguments:  [Type]    - type to search for
//              [itBegin] - scope to start search
//              [itEnd]   - just past scope to end search
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::_LookupScopeByType(
    SCOPE_TYPE Type,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd) const
{
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        if (it->get()->Type() == Type)
        {
            return *it->get();
        }

        if (it->get()->GetCurrentImmediateChildCount())
        {
            vector<RpScope>::const_iterator itChildBegin;
            vector<RpScope>::const_iterator itChildEnd;

            it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

            const CScope &rMatching = _LookupScopeByType(Type,
                                                         itChildBegin,
                                                         itChildEnd);

            if (rMatching.Type() != ST_INVALID)
            {
                return rMatching;
            }
        }
    }
    return *m_rpInvalidScope.get();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_LookupScopeById
//
//  Synopsis:   Return a reference to scope having id [id].
//
//  Arguments:  [id]      - id to search for
//              [itBegin] - scope to start search
//              [itEnd]   - just past scope to end search
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      Every scope is given a unique id upon creation.
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::_LookupScopeById(
    ULONG id,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd) const
{
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        if (it->get()->GetID() == id)
        {
            return *it->get();
        }

        if (it->get()->GetCurrentImmediateChildCount())
        {
            vector<RpScope>::const_iterator itChildBegin;
            vector<RpScope>::const_iterator itChildEnd;

            it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

            const CScope &rMatching = _LookupScopeById(id,
                                                       itChildBegin,
                                                       itChildEnd);

            if (rMatching.Type() != ST_INVALID)
            {
                return rMatching;
            }
        }
    }
    return *m_rpInvalidScope.get();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_ValidateFilterFlags
//
//  Synopsis:   Return E_INVALIDARG if any of the flags in [pScopeInit]
//              violate object picker's rules, or S_OK otherwise.
//
//  Arguments:  [pScopeInit]   - points to structure containing flags to
//                                 inspect
//              [flScopeTypes] - scope types to which these flags apply
//
//  Returns:    S_OK or E_INVALIDARG
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CScopeManager::_ValidateFilterFlags(
    PCDSOP_SCOPE_INIT_INFO pScopeInit,
    ULONG flScopeTypes)
{
    //TRACE_METHOD(CDsObjectPicker, _ValidateFilterFlags);

    HRESULT hr = E_INVALIDARG; // init for failure
    BOOL fWantUplevelFlags = FALSE;
    BOOL fWantDownlevelFlags = FALSE;
    MACHINE_CONFIG mc = m_rop.GetTargetComputerConfig();

    do
    {
        //
        // If the scope types contain uplevel scopes, require that some
        // uplevel filter flags are set.
        //

        if (flScopeTypes &
            (DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
             | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
             | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
             | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE))
        {
            fWantUplevelFlags = TRUE;
        }
        else if ((flScopeTypes & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN) &&
                 (mc == MC_JOINED_NT5 || mc == MC_NT5_DC))
        {
            fWantUplevelFlags = TRUE;
        }

        if (fWantUplevelFlags)
        {
            //
            // Error if no uplevel filter flags are set
            //

            if (!(pScopeInit->FilterFlags.Uplevel.flBothModes
                  | pScopeInit->FilterFlags.Uplevel.flMixedModeOnly
                  | pScopeInit->FilterFlags.Uplevel.flNativeModeOnly))
            {
                Dbg(DEB_ERROR,
                    "Error: uplevel scope type but no uplevel filter flags\n");
                break;
            }

            //
            // Error if only native mode or only mixed mode flags are set.
            // Exception: ok for GC to have only native, since that's what
            // we'll use for it.
            //

            if (pScopeInit->flType != DSOP_SCOPE_TYPE_GLOBAL_CATALOG &&
                !pScopeInit->FilterFlags.Uplevel.flBothModes &&
                (!pScopeInit->FilterFlags.Uplevel.flMixedModeOnly ||
                 !pScopeInit->FilterFlags.Uplevel.flNativeModeOnly))
            {
                Dbg(DEB_ERROR,
                    "Error: uplevel scope type, !flBothModes and either !flMixedModeOnly or !flNativeModeOnly\n");
                break;
            }

            //
            // Make sure there are no downlevel filter bits set in the
            // uplevel flags.
            //

            const DSOP_UPLEVEL_FILTER_FLAGS *pUF =
                &pScopeInit->FilterFlags.Uplevel;

            if ((pUF->flBothModes & DSOP_DOWNLEVEL_FILTER_BIT) ||
                (pUF->flMixedModeOnly & DSOP_DOWNLEVEL_FILTER_BIT) ||
                (pUF->flNativeModeOnly & DSOP_DOWNLEVEL_FILTER_BIT))
            {
                Dbg(DEB_ERROR,
                    "Error: downlevel bit set in uplevel filter\n");
                break;
            }

            //
            // If scope type GC is included, then either both
            // or native must have at least one filter flag, because
            // mixed mode is ignored.
            //

            if (flScopeTypes & DSOP_SCOPE_TYPE_GLOBAL_CATALOG)
            {
                if (!(pScopeInit->FilterFlags.Uplevel.flNativeModeOnly
                      | pScopeInit->FilterFlags.Uplevel.flBothModes))
                {
                    Dbg(DEB_ERROR,
                        "Error: DSOP_SCOPE_TYPE_GLOBAL_CATALOG requires native mode or both mode filter flags\n");
                    break;
                }
            }
        }

        //
        // If the scope types contain downlevel scopes, require that some
        // downlevel filter flags are set.
        //

        if (flScopeTypes &
            (DSOP_SCOPE_TYPE_TARGET_COMPUTER
             | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
             | DSOP_SCOPE_TYPE_WORKGROUP
             | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE))
        {
            fWantDownlevelFlags = TRUE;
        }
        else if ((flScopeTypes & DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN) &&
                 (mc == MC_JOINED_NT4 || mc == MC_NT4_DC))
        {
            fWantDownlevelFlags = TRUE;
        }

        if (fWantDownlevelFlags)
        {
            if (!pScopeInit->FilterFlags.flDownlevel)
            {
                Dbg(DEB_ERROR,
                    "Error: downlevel scope type but no downlevel filter flags\n");
                break;
            }

            //
            // If Workgroup scope is specified, computer
            // object is required, since that's the only thing a
            // workgroup can contain.
            //

            if (flScopeTypes & DSOP_SCOPE_TYPE_WORKGROUP)
            {
                if ((pScopeInit->FilterFlags.flDownlevel
                      & DSOP_DOWNLEVEL_FILTER_COMPUTERS) != DSOP_DOWNLEVEL_FILTER_COMPUTERS )
                {
                    Dbg(DEB_ERROR,
                        "Error: DSOP_SCOPE_TYPE_WORKGROUP requires DSOP_DOWNLEVEL_FILTER_COMPUTERS\n");
                    break;
                }
            }
        }

        //
        // Miscellaneous checks
        //

        // only uplevel joined domain scope is allowed to specify dc name

        if (pScopeInit->pwzDcName && *pScopeInit->pwzDcName)
        {
            if (!(flScopeTypes & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN))
            {
                Dbg(DEB_ERROR,
                    "Error: pwzDcName only supported for DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN\n");
                break;
            }
        }

        // computer scope must have downlevel filters other than computers,
        // since that flag will be ignored

        if (flScopeTypes & DSOP_SCOPE_TYPE_TARGET_COMPUTER)
        {
            if (!(pScopeInit->FilterFlags.flDownlevel &
                  ~DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                Dbg(DEB_ERROR,
                    "Error: computer scope must have downlevel filters other than DSOP_DOWNLEVEL_FILTER_COMPUTERS\n");
                break;
            }
        }

        //
        // Made it through the gauntlet--return success.
        //

        hr = S_OK;
    } while (0);

    return hr;
}

#define ENUMERATE_DOMAIN_TRUST_FLAGS    (DS_DOMAIN_PRIMARY              \
                                         | DS_DOMAIN_IN_FOREST          \
                                         | DS_DOMAIN_DIRECT_OUTBOUND)


#ifndef TRUST_ATTRIBUTE_CROSS_FEDERATION
#define TRUST_ATTRIBUTE_CROSS_FEDERATION 0
#endif

void
CScopeManager::_AddRootTrustScopes
(
    vector<ADD_SCOPE_INFO> &asiv,
    const SScopeParameters *pspExternalUplevel
)
{
    // if we don't have a domain DNS then our GetTargetDomainDc
    // might not be DNS and we will be dealing with a downlevel
    // domain and there will be no XForest trusts there.
    if(m_rop.GetTargetDomainDns().empty()) return;

    // If the user doesn't want uplevel external trusts we don't
    // try to add the forest trusts
    if(!pspExternalUplevel) return;

    // If the target domain is the same as the root forest
    // we have already enumerated the XForest trusts
    if(m_rop.GetTargetForest().icompare(m_rop.GetTargetDomainDns()) == 0)
        return;


    //  Now we need to get a DC in the forest. this will be
    //  a DC in the root tree that will have the XForest trusts
    PDOMAIN_CONTROLLER_INFO forestDc=NULL;
    
    if
    (
        DsGetDcName
        (
            NULL,
            m_rop.GetTargetForest().c_str(),
            NULL,
            NULL,
            DS_IS_DNS_NAME|DS_RETURN_DNS_NAME,
            &forestDc
        ) == NO_ERROR
    )
    {

        ASSERT(forestDc!=NULL);
        // Having a root DC we enummerate its trusts
        ULONG cDomains;
        NET_API_STATUS Status;
        PDS_DOMAIN_TRUSTS Domains;

        Status = MyDsEnumerateDomainTrusts(forestDc->DomainControllerName,
                                         ENUMERATE_DOMAIN_TRUST_FLAGS,
                                         &Domains,
                                         &cDomains);
        NetApiBufferFree(forestDc);

        if(Status==NO_ERROR)
        {
            for (ULONG i = 0; i < cDomains; i++)
            {
                PDS_DOMAIN_TRUSTS ptdCur = &Domains[i];

                if (!(ptdCur->Flags & DS_DOMAIN_IN_FOREST) &&
                     (ptdCur->TrustType != TRUST_TYPE_MIT)   &&
                     (ptdCur->TrustAttributes & 
                        TRUST_ATTRIBUTE_FOREST_TRANSITIVE))
                {
                    Dbg(DEB_TRACE, "XForest Root Domains[%u]:\n", i);
                    Dbg(DEB_TRACE, "  NetbiosDomainName %ws\n", ptdCur->NetbiosDomainName);
                    Dbg(DEB_TRACE, "  DnsDomainName %ws\n", ptdCur->DnsDomainName);
                    Dbg(DEB_TRACE, "  Flags %#x\n", ptdCur->Flags);
                    Dbg(DEB_TRACE, "  ParentIndex %u\n", ptdCur->ParentIndex);
                    Dbg(DEB_TRACE, "  TrustType %#x\n", ptdCur->TrustType);
                    Dbg(DEB_TRACE, "  TrustAttributes %#x\n", ptdCur->TrustAttributes);

                    ADD_SCOPE_INFO asi;

                    asi.Domain.strScopeName = ptdCur->DnsDomainName;
                    asi.flXForestFederated = (ptdCur->TrustType & 
                       TRUST_ATTRIBUTE_CROSS_FEDERATION) ? TRUE:FALSE;
                    asi.flType = ST_XFOREST;
                    asiv.push_back(asi);
                }
            }
            NetApiBufferFree(Domains);
        }
    }
}


NET_API_STATUS 
CScopeManager::MyDsEnumerateDomainTrusts
(
    LPWSTR pwzTarget,
    ULONG flags,
    PDS_DOMAIN_TRUSTS *Domains,
    ULONG *cDomains
)
{
    NET_API_STATUS Status;

    {
        TIMER("DsEnumerateDomainTrusts(%ws)\n", pwzTarget ? pwzTarget : L"NULL");

        Status = DsEnumerateDomainTrusts(pwzTarget,
                                         ENUMERATE_DOMAIN_TRUST_FLAGS,
                                         Domains,
                                         cDomains);
    }

    //
    // Might need to establish connection to remote machine to get this
    // info.
    //

    if (Status == ERROR_ACCESS_DENIED && pwzTarget)
    {
        Dbg(DEB_TRACE,
            "DsEnumerateDomainTrusts(%ws) returned ERROR_ACCESS_DENIED\n",
            pwzTarget);

        CImpersonateAnon AnonymousImpersonation;

        Status = DsEnumerateDomainTrusts(pwzTarget,
                                         ENUMERATE_DOMAIN_TRUST_FLAGS,
                                         Domains,
                                         cDomains);
    }

    if (Status)
    {
        Dbg(DEB_ERROR,
            "DsEnumerateDomainTrusts error<%uL>\n",
            Status);
    }
    
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_InitDomainScopesJoinedNt5
//
//  Synopsis:   Discover the domains in the enterprise to which the target
//              computer belongs and create scope objects for each of them.
//
//  Arguments:  [pGcScope] - pointer to GC scope, which is parent to all
//                            the trees in the enterprise, or NULL if
//                            there is no GC scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CScopeManager::_InitDomainScopesJoinedNt5(
    CGcScope *pGcScope)
{
    TRACE_METHOD(CScopeManager, _InitDomainScopesJoinedNt5);

    ULONG cDomains;
    NET_API_STATUS Status;
    PDS_DOMAIN_TRUSTS Domains;
    MACHINE_CONFIG mc = m_rop.GetTargetComputerConfig();

    //
    // Get the trust link information
    //

    PWSTR pwzTarget;

    if (m_rop.TargetComputerIsLocalComputer())
    {
        pwzTarget = NULL;
    }
    else if (mc == MC_JOINED_NT5)
    {
        pwzTarget = (PWSTR) m_rop.GetTargetDomainDc().c_str();
    }
    else
    {
        pwzTarget = (PWSTR) m_rop.GetTargetComputer().c_str();
    }
    
    Status = MyDsEnumerateDomainTrusts(pwzTarget,
                                         ENUMERATE_DOMAIN_TRUST_FLAGS,
                                         &Domains,
                                         &cDomains);

    if (Status) return;


    //
    // It comes back as an array with each element having an index to
    // its parent (if any).  Build up a parallel array that has, for
    // each element, a list of child elements.  This allows us to traverse
    // the tree(s) from the root(s) down, which is what we need to do to
    // add the domains to the scope control with proper indenting to
    // show parent/child relationship.
    //

    CDomainInfo *adi = new CDomainInfo[cDomains];
    ULONG        i;

    for (i = 0; i < cDomains; i++)
    {
        PDS_DOMAIN_TRUSTS ptdCur = &Domains[i];

        Dbg(DEB_TRACE, "Domains[%u]:\n", i);
        Dbg(DEB_TRACE, "  NetbiosDomainName %ws\n", ptdCur->NetbiosDomainName);
        Dbg(DEB_TRACE, "  DnsDomainName %ws\n", ptdCur->DnsDomainName);
        Dbg(DEB_TRACE, "  Flags %#x\n", ptdCur->Flags);
        Dbg(DEB_TRACE, "  ParentIndex %u\n", ptdCur->ParentIndex);
        Dbg(DEB_TRACE, "  TrustType %#x\n", ptdCur->TrustType);
        Dbg(DEB_TRACE, "  TrustAttributes %#x\n", ptdCur->TrustAttributes);

        while (ptdCur->TrustType != TRUST_TYPE_MIT &&
               IsNonRootDomainInForest(ptdCur) &&
               !adi[i].fAddedToParentsChildList)
        {
            ASSERT(ptdCur->ParentIndex < cDomains);
            PDS_DOMAIN_TRUSTS ptdParent = &Domains[ptdCur->ParentIndex];

            adi[ptdCur->ParentIndex].lpdiChildren.push_back(&adi[i]);
            adi[i].fAddedToParentsChildList = TRUE;
            ptdCur = ptdParent;
        }
    }

    //
    // Now traverse all the trees in the enterprise depth first, from the
    // root down.
    //

    for (i = 0; i < cDomains; i++)
    {
        if (Domains[i].Flags & DS_DOMAIN_TREE_ROOT)
        {
            _AddTreeJoinedNt5(pGcScope, i, adi, Domains);
        }
    }

    //
    // If caller wants external domains added, do them now.
    //

    const SScopeParameters *pspExternalUplevel =
        GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);

    const SScopeParameters *pspExternalDownlevel =
        GetScopeParams(ST_EXTERNAL_DOWNLEVEL_DOMAIN);

    if (pspExternalUplevel || pspExternalDownlevel)
    {
        vector<ADD_SCOPE_INFO> asiv;

        // First add the trusts of this domain in the loop bellow
        // including XForest trusts.
        for (i = 0; i < cDomains; i++)
        {
            PDS_DOMAIN_TRUSTS ptdCur = &Domains[i];
            if (!(ptdCur->Flags & DS_DOMAIN_IN_FOREST) &&
                ptdCur->TrustType != TRUST_TYPE_MIT)
            {
                ADD_SCOPE_INFO asi;
                // NTRAID#NTBUG9-515698-2002/01/15-lucios
                if( 
                    (ptdCur->TrustAttributes & 
                            TRUST_ATTRIBUTE_FOREST_TRANSITIVE) &&
                    pspExternalUplevel && ptdCur->DnsDomainName
                  )
                {
                    asi.Domain.strScopeName = ptdCur->DnsDomainName;
                    asi.flXForestFederated = (ptdCur->TrustType & 
                       TRUST_ATTRIBUTE_CROSS_FEDERATION) ? TRUE:FALSE;
                    asi.flType = ST_XFOREST;
                }
                else
                {
                asi.Domain.strFlatName = ptdCur->NetbiosDomainName;

                if (pspExternalUplevel && ptdCur->DnsDomainName)
                {
                    asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
                    asi.Domain.strScopeName = ptdCur->DnsDomainName;
                    asi.flScope = pspExternalUplevel->flScope;
                    asi.FilterFlags = pspExternalUplevel->FilterFlags;
                    asi.Domain.strADsPath = c_wzLDAPPrefix;
                    asi.Domain.strADsPath += ptdCur->DnsDomainName;
                    asi.Domain.Mode = DM_UNDETERMINED;
                }
                else if (pspExternalDownlevel && ptdCur->NetbiosDomainName
                            && !ptdCur->DnsDomainName)
                {
                    asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
                    asi.Domain.strScopeName = ptdCur->NetbiosDomainName;
                    asi.flScope = pspExternalDownlevel->flScope;
                    asi.FilterFlags = pspExternalDownlevel->FilterFlags;
                    asi.Domain.strADsPath = c_wzWinNTPrefix;
                    asi.Domain.strADsPath += ptdCur->NetbiosDomainName;
                    asi.Domain.strADsPath += L",Domain";
                }
                }
                if (asi.flType != DSOP_SCOPE_TYPE_INVALID)
                {
                    asiv.push_back(asi);
                }
            }
        }

        // Then add the XForest trusts of the root domain if we're not there yet
        _AddRootTrustScopes(asiv,pspExternalUplevel);

        sort(asiv.begin(), asiv.end());

        vector<ADD_SCOPE_INFO>::iterator it;

        for (it = asiv.begin(); it != asiv.end(); it++)
        {
            RpScope rpScope;

            if (it->flType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
            {
                rpScope.Acquire(new CLdapDomainScope(m_rop, *it, NULL));
            }
            else if(it->flType == ST_XFOREST)
            {
                rpScope.Acquire
                (
                    new CXForestScope
                    (
                        m_rop, 
                        it->Domain.strScopeName,
                        it->flXForestFederated
                    )
                );
            }
            else
            {
                rpScope.Acquire(new CWinNtDomainScope(m_rop, *it));
            }
            m_vrpRootScopes.push_back(rpScope);

            // NTRAID#NTBUG9-503865-2002/01/15-lucios
            if (
                (
                  ( (m_StartingScopeType & rpScope->Type())!=0 ) ||
                  ( 
                     ((m_StartingScopeType & ST_EXTERNAL_UPLEVEL_DOMAIN)!=0) &&
                     (rpScope->Type() == ST_XFOREST)
                  )
                ) &&
                !m_rpStartingScope.get()
               )
            {
                m_rpStartingScope = rpScope;
            }
        }
    }

    NetApiBufferFree((void *)Domains);
    delete [] adi;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_AddTreeJoinedNt5
//
//  Synopsis:   Recursively add the domain Domains[idxCur] and all its
//              children to the scope control.
//
//  Arguments:  [pParent] - parent scope (NULL if none)
//              [idxCur]  - current element of [Domains]
//              [adi]     - array used to process [Domains]
//              [Domains] - returned by
//                          DsEnumerateDomainTrusts
//
//  History:    11-17-1998   DavidMun   Created
//              01-25-2000   davidmun   move from querythd.cxx, change for
//                                       multiple hierarchical scopes
//
//---------------------------------------------------------------------------

void
CScopeManager::_AddTreeJoinedNt5(
    CLdapContainerScope *pParent,
    ULONG idxCur,
    CDomainInfo *adi,
    PDS_DOMAIN_TRUSTS Domains)
{
    TRACE_METHOD(CScopeManager, _AddTreeJoinedNt5);

    ADD_SCOPE_INFO asi;

    asi.Domain.strScopeName = Domains[idxCur].DnsDomainName ?
        Domains[idxCur].DnsDomainName :
        Domains[idxCur].NetbiosDomainName;
    asi.Domain.strFlatName = Domains[idxCur].NetbiosDomainName ?
        Domains[idxCur].NetbiosDomainName :
        L"";

    //
    // Add domain represented by Domains[idxCur]
    //

    const SScopeParameters *pspUplevelJoinedDomain =
        GetScopeParams(ST_UPLEVEL_JOINED_DOMAIN);

    const SScopeParameters *pspEnterpriseDomains =
        GetScopeParams(ST_ENTERPRISE_DOMAIN);

    if (pspUplevelJoinedDomain && (Domains[idxCur].Flags & DS_DOMAIN_PRIMARY))
    {
        asi.flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        asi.flScope = pspUplevelJoinedDomain->flScope;
        asi.FilterFlags = pspUplevelJoinedDomain->FilterFlags;
        asi.Domain.strADsPath = c_wzLDAPPrefix;
        asi.Domain.Mode = (Domains[idxCur].Flags & DS_DOMAIN_NATIVE_MODE)
                    ? DM_NATIVE
                    : DM_MIXED;

        if (!pspUplevelJoinedDomain->strDcName.empty())
        {
            asi.Domain.strADsPath += pspUplevelJoinedDomain->strDcName;
            asi.Domain.fPathIsDc = TRUE;
        }
        else
        {
            asi.Domain.strADsPath += Domains[idxCur].DnsDomainName ?
                                        Domains[idxCur].DnsDomainName :
                                        Domains[idxCur].NetbiosDomainName;
        }
    }
    else if (pspEnterpriseDomains)
    {
        asi.flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        asi.flScope = pspEnterpriseDomains->flScope;
        asi.FilterFlags = pspEnterpriseDomains->FilterFlags;
        asi.Domain.strADsPath = c_wzLDAPPrefix;
        asi.Domain.strADsPath += Domains[idxCur].DnsDomainName ?
                                    Domains[idxCur].DnsDomainName :
                                    Domains[idxCur].NetbiosDomainName;
        asi.Domain.Mode = DM_UNDETERMINED;
    }

    CLdapContainerScope *pNextParent = pParent;

    if (asi.flType != DSOP_SCOPE_TYPE_INVALID)
    {
        RpScope rpScope;

        rpScope.Acquire(new CLdapDomainScope(m_rop, asi, pParent));

        if (!pParent)
        {
            m_vrpRootScopes.push_back(rpScope);
            pNextParent = (CLdapContainerScope*)m_vrpRootScopes.back().get();
        }
        else
        {
            pParent->AddChild(rpScope);
            pNextParent = (CLdapContainerScope*)pParent->back().get(); // implemented as { return m_vrpRootScopes.back(); }
        }

        // NTRAID#NTBUG9-503865-2002/01/15-lucios
        if (
                ( (m_StartingScopeType & rpScope->Type())!=0 ) &&
                !m_rpStartingScope.get()
           )
        {
            m_rpStartingScope = rpScope;
        }
    }

    //
    // Add all its children
    //

    DomainInfoList::iterator it;

    for (it = adi[idxCur].lpdiChildren.begin();
         it != adi[idxCur].lpdiChildren.end();
         it++)
    {
        ULONG idxChild = static_cast<ULONG>(*it - adi);

        _AddTreeJoinedNt5(pNextParent, idxChild, adi, Domains);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   IsNonRootDomainInForest
//
//  Synopsis:   Return TRUE if [ptd] represents an enterprise domain that
//              is not the root of a domain tree.
//
//  History:    11-17-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

inline BOOL
IsNonRootDomainInForest(
    PDS_DOMAIN_TRUSTS ptd)
{
    return (ptd->Flags & DS_DOMAIN_IN_FOREST) &&
           !(ptd->Flags & DS_DOMAIN_TREE_ROOT);
}


#define ENUMERATE_REQUEST_BYTES 1024


//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_InitScopesJoinedNt4
//
//  Synopsis:   Add joined and external domains to scope control using
//              only downlevel domains.
//
//  History:    11-17-1998   DavidMun   Created
//              01-26-2000   davidmun   moved from querythd and changed for
//                                       new scope hierarchy
//
//---------------------------------------------------------------------------

void
CScopeManager::_InitScopesJoinedNt4()
{
    TRACE_METHOD(CScopeManager, _InitScopesJoinedNt4);

    const SScopeParameters *pspDownlevelJoinedDomain =
                        GetScopeParams(ST_DOWNLEVEL_JOINED_DOMAIN);
    const SScopeParameters *pspEnterpriseDomains =
                        GetScopeParams(ST_ENTERPRISE_DOMAIN);
    const SScopeParameters *pspExternalDownlevel =
                        GetScopeParams(ST_EXTERNAL_DOWNLEVEL_DOMAIN);
    const SScopeParameters *pspJoined = NULL;

    if (pspDownlevelJoinedDomain)
    {
        pspJoined = pspDownlevelJoinedDomain;
    }
    else if (pspEnterpriseDomains &&
             pspEnterpriseDomains->FilterFlags.flDownlevel)
    {
        pspJoined = pspEnterpriseDomains;
    }

    if (!pspJoined && !pspExternalDownlevel)
    {
        return;
    }

    HRESULT                     hr = S_OK;
    NTSTATUS                    nts;
    LSA_OBJECT_ATTRIBUTES       oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    LSA_HANDLE                  hlsaServer = NULL;
    LSA_HANDLE                  hlsaPDC = NULL;
    POLICY_PRIMARY_DOMAIN_INFO *pPrimaryDomainInfo = NULL;
    BOOL                        fOk;
    ADD_SCOPE_INFO              asi;
    vector<ADD_SCOPE_INFO>      asiv;
    WCHAR                       wzPrimaryDomain[MAX_PATH] = L"";
    PDOMAIN_CONTROLLER_INFO     pdci = NULL;

    //
    // To get accurate and completely up-to-date trusted domains enumeration,
    // call LsaQueryInformationPolicy to get the machine's domain, then call
    // DsGetDcName to find a DC, then call LsaEnumerateTrustedDomains on
    // that DC.
    //

    do
    {
        POLICY_ACCOUNT_DOMAIN_INFO *pAccountDomainInfo = NULL;

        hr = GetLsaAccountDomainInfo(m_rop.GetTargetComputer().c_str(),
                                     &hlsaServer,
                                     &pAccountDomainInfo);

        if (pAccountDomainInfo)
        {
            LsaFreeMemory(pAccountDomainInfo);
        }

        if (!hlsaServer)
        {
            ASSERT(FAILED(hr));
            break;
        }

        //
        // Get the server's primary domain (or workgroup) and add it to the
        // scope
        //

        nts = LsaQueryInformationPolicy(hlsaServer,
                                        PolicyPrimaryDomainInformation,
                                        (LPVOID *)&pPrimaryDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);

        UnicodeStringToWsz(pPrimaryDomainInfo->Name,
                           wzPrimaryDomain,
                           ARRAYLEN(wzPrimaryDomain));

        if (pspJoined)
        {
            asi.flType = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
            asi.flScope = pspJoined->flScope;
            asi.FilterFlags = pspJoined->FilterFlags;
            asi.Domain.strScopeName = wzPrimaryDomain;
            asi.Domain.strFlatName = wzPrimaryDomain;
            asi.Domain.strADsPath = c_wzWinNTPrefix;
            asi.Domain.strADsPath += wzPrimaryDomain;
            asi.Domain.strADsPath += L",Domain";

            ASSERT(pPrimaryDomainInfo->Sid);
            Dbg(DEB_TRACE,
                "target machine joined to NT4 domain '%ws'\n",
                wzPrimaryDomain);

            asiv.push_back(asi);
        }

        if (!pspExternalDownlevel)
        {
            break;
        }

        //
        // Now add each of the trusted domains listed from the PDC to the
        // scope.  We establish an API session (null session w/ IPC$) so we
        // don't have account conflicts (i.e., Admin w/ diff passwords)
        //

        // first get the name of a DC in the domain of the server

        ULONG ulResult;

        ulResult = DsGetDcName(NULL,
                               wzPrimaryDomain,
                               NULL,
                               NULL,
                               0,
                               &pdci);

        if (ulResult != ERROR_SUCCESS)
        {
            DBG_OUT_LRESULT(ulResult);
            break;
        }

        Dbg(DEB_TRACE, "  PDC '%ws'\n", pdci->DomainControllerName);

        CImpersonateAnon    Anonymous;

        UNICODE_STRING uszPDC;

        fOk = RtlCreateUnicodeString(&uszPDC, pdci->DomainControllerName);

        if (!fOk)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //REVIEWED-2002-02-20-lucios.
        ZeroMemory(&sqos, sizeof sqos);
        sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        //REVIEWED-2002-02-20-lucios.
        ZeroMemory(&oa, sizeof oa);
        oa.Length = sizeof oa;
        oa.SecurityQualityOfService = &sqos;

        {
            TIMER("LsaOpenPolicy");

            nts = LsaOpenPolicy(&uszPDC,
                                &oa,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &hlsaPDC);
        }
        RtlFreeUnicodeString(&uszPDC);

        BREAK_ON_FAIL_NTSTATUS(nts);

        ULONG cItems;
        LSA_ENUMERATION_HANDLE hEnum = NULL;
        PLSA_TRUST_INFORMATION pTrustInfo = NULL;

        while (1)
        {
            {
                TIMER("LsaEnumerateTrustedDomains");

                nts = LsaEnumerateTrustedDomains(hlsaPDC,
                                                 &hEnum,
                                                 (PVOID *)&pTrustInfo,
                                                 ENUMERATE_REQUEST_BYTES,
                                                 &cItems);
            }

            if (nts == STATUS_NO_MORE_ENTRIES)
            {
                ASSERT(!cItems);
                break;
            }

            BREAK_ON_FAIL_NTSTATUS(nts);

            ASSERT(cItems);

            if (!cItems)
            {
                break;
            }

            ULONG i;
            PLSA_TRUST_INFORMATION pCurTrust;

            for (i = 0, pCurTrust = pTrustInfo; i < cItems; i++, pCurTrust++)
            {
                WCHAR wzTrustedDomain[MAX_PATH];

                UnicodeStringToWsz(pCurTrust->Name,
                                   wzTrustedDomain,
                                   ARRAYLEN(wzTrustedDomain));

                Dbg(DEB_TRACE, "  %ws\n", wzTrustedDomain);

                asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
                asi.flScope = pspExternalDownlevel->flScope;
                asi.FilterFlags = pspExternalDownlevel->FilterFlags;
                asi.Domain.strScopeName = wzTrustedDomain;
                asi.Domain.strFlatName = wzTrustedDomain;
                asi.Domain.strADsPath = c_wzWinNTPrefix;
                asi.Domain.strADsPath += wzTrustedDomain;
                asi.Domain.strADsPath += L",Domain";

                asiv.push_back(asi);
            }

            LsaFreeMemory(pTrustInfo);
            pTrustInfo = NULL;
            hr = S_OK; // ignore failures
        }

        ASSERT(!pTrustInfo);
    } while (0);

    if (pdci)
    {
        NetApiBufferFree(pdci);
        pdci = NULL;
    }

    //
    // asiv now contains 0 or more scopes to add.  Sort them by name and
    // add them.
    //

    sort(asiv.begin(), asiv.end());

    vector<ADD_SCOPE_INFO>::iterator it;

    for (it = asiv.begin(); it != asiv.end(); it++)
    {
        RpScope rps;

        rps.Acquire(new CWinNtDomainScope(m_rop, *it));
        m_vrpRootScopes.push_back(rps);

        // NTRAID#NTBUG9-503865-2002/01/15-lucios
        if (
                ( (m_StartingScopeType & rps->Type())!=0 ) &&
                !m_rpStartingScope.get()
           )
        {
            m_rpStartingScope = rps;
        }
    }

    //
    // Release resources
    //

    if (pPrimaryDomainInfo)
    {
        LsaFreeMemory(pPrimaryDomainInfo);
    }

    if (hlsaServer)
    {
        LsaClose(hlsaServer);
    }

    if (hlsaPDC)
    {
        LsaClose(hlsaPDC);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::DoLookInDialog
//
//  Synopsis:   Invoke the modal "Look In" dialog and block until it returns
//
//  Arguments:  [hwndParent] - parent of modal dialog
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CScopeManager::DoLookInDialog(
    HWND hwndParent) const
{
    TRACE_METHOD(CScopeManager, DoLookInDialog);

    CLookInDlg  LookInDlg(m_rop);

    LookInDlg.DoModal(hwndParent, m_rpCurScope.get());

    m_rpCurScope = LookInDlg.GetSelectedScope();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::AddUserEnteredScope
//
//  Synopsis:   Add to the list of root scopes a scope created when
//              resolving a name the user typed of the form dom\obj or
//              obj@dom.
//
//  Arguments:  [asi] - describes the scope to add
//
//  Returns:    Reference to newly added scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::AddUserEnteredScope(
    const ADD_SCOPE_INFO &asi) const
{
    TRACE_METHOD(CScopeManager, AddUserEnteredScope);
    ASSERT(asi.flType == DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE ||
           asi.flType == DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE);

    if (asi.flType == DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE)
    {
        RpScope rps;

        rps.Acquire(new CLdapContainerScope(static_cast<SCOPE_TYPE>(asi.flType),
                                            asi.Domain.strScopeName,
                                            asi.Domain.strADsPath,
                                            m_rop,
                                            NULL));
        m_vrpRootScopes.push_back(rps);
        return *m_vrpRootScopes.back().get();
    }

    RpScope rps;

    rps.Acquire(new CWinNtDomainScope(m_rop, asi));
    m_vrpRootScopes.push_back(rps);
    return *m_vrpRootScopes.back().get();
}
//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::AddCrossForestDomainScope
//
//  Synopsis:   Add to the list of root scopes a scope created when
//              resolving a name the user typed of the form dom\obj or
//              obj@dom and name is resolved in a domain in a trusted cross
//              forest
//
//  Arguments:  [asi] - describes the scope to add
//
//  Returns:    Reference to newly added scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::AddCrossForestDomainScope(
    const ADD_SCOPE_INFO &asi) const
{
    TRACE_METHOD(CScopeManager, AddCrossForestDomainScope);
    ASSERT(asi.flType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN);

    RpScope rps;

    rps.Acquire(new CLdapDomainScope(m_rop,
                                    asi,
                                    NULL));        
    CLdapDomainScope * pLdapScope = dynamic_cast<CLdapDomainScope *>(rps.get());
    pLdapScope->SetXForest();
    m_vrpRootScopes.push_back(rps);
    return *m_vrpRootScopes.back().get();
}





//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::GetParent
//
//  Synopsis:   Return the parent of scope [Child], or an invalid scope if
//              [Child] doesn't have a parent scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::GetParent(
    const CScope &Child) const
{
    if (Child.GetParent())
    {
        return *Child.GetParent();
    }
    return *m_rpInvalidScope.get();
}


#if (DBG == 1)

BOOL
CScopeManager::IsValidScope(
    CScope *pScope) const
{
    vector<RpScope>::const_iterator itCur;

    for (itCur = m_vrpRootScopes.begin();
         itCur != m_vrpRootScopes.end();
         itCur++)
    {
        if (itCur->get() == pScope)
        {
            return TRUE;
        }

        if (_IsChildScope(itCur->get(), pScope))
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL
CScopeManager::_IsChildScope(
    CScope *pParent,
    CScope *pMaybeChild) const
{
    vector<RpScope>::const_iterator itCur;
    vector<RpScope>::const_iterator itChildEnd;

    pParent->GetChildScopeIterators(&itCur, &itChildEnd);

    for (; itCur != itChildEnd; itCur++)
    {
        if (itCur->get() == pMaybeChild)
        {
            return TRUE;
        }

        if (_IsChildScope(itCur->get(), pMaybeChild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

#endif // (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\sid.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       sid.cxx
//
//  Contents:   Class that encapsulates certain distasteful operations on
//              SIDs.
//
//  Classes:    CSid
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+--------------------------------------------------------------------------
//
//  Member:     CSid::CSid
//
//  Synopsis:   Initialize by copying sid stored in safearray of [pvarSid].
//
//  Arguments:  [pvarSid] - sid stored as safearray of bytes
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CSid::CSid(
    VARIANT *pvarSid):
        m_psid(NULL)
{
    TRACE_CONSTRUCTOR(CSid);
    ASSERT(pvarSid);
    ASSERT(V_VT(pvarSid) == (VT_ARRAY | VT_UI1));

    HRESULT hr = S_OK;
    PSID    psid;
    ULONG   cbSid = 0;
    VOID   *pvData = NULL;
    PUCHAR  pcSubAuth = NULL;

    do
    {
        hr = SafeArrayAccessData(V_ARRAY(pvarSid), &pvData);
        BREAK_ON_FAIL_HRESULT(hr);

        psid = (PSID) pvData;

        ASSERT(IsValidSid(psid));

        pcSubAuth = GetSidSubAuthorityCount(psid);

        ASSERT(pcSubAuth);

        cbSid = GetSidLengthRequired(*pcSubAuth);

        ASSERT(cbSid);
        ASSERT(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

        m_psid = new BYTE [cbSid];

        //REVIEWED-2002-02-23-lucios.
        VERIFY(CopySid(cbSid, m_psid, psid));
        ASSERT(IsValidSid(m_psid));
    } while (0);

    if (pvData)
    {
        SafeArrayUnaccessData(V_ARRAY(pvarSid));
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::CSid
//
//  Synopsis:   copy ctor
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CSid::CSid(
    const CSid &sidToCopy):
        m_psid(NULL)
{
    TRACE_CONSTRUCTOR(CSid);

    if (!sidToCopy.m_psid)
    {
        Dbg(DEB_WARN, "Warning: copying NULL sid\n");
        return;
    }

    ASSERT(IsValidSid(sidToCopy.m_psid));

    PUCHAR pcSubAuth =
                GetSidSubAuthorityCount(const_cast<PSID>(sidToCopy.m_psid));
    ULONG cbSid = GetSidLengthRequired(*pcSubAuth);

    //REVIEWED-2002-02-23-lucios.
    m_psid = new BYTE [cbSid];
    VERIFY(CopySid(cbSid, m_psid, sidToCopy.m_psid));
    ASSERT(IsValidSid(m_psid));
}




//+--------------------------------------------------------------------------
//
//  Member:     CSid::~CSid
//
//  Synopsis:   dtor
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CSid::~CSid()
{
    TRACE_DESTRUCTOR(CSid);

    delete [] m_psid;
    m_psid = NULL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::Decrement
//
//  Synopsis:   Consider the sid's subauthority array as a single unsigned
//              number and increment it.
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CSid::Decrement()
{
    if (!m_psid)
    {
        return;
    }

    PBYTE pbMSB = NULL;
    PBYTE pbCur = NULL;

    _GetSubAuthorityRange(&pbMSB, &pbCur);

    //
    // Treat the subauthorities as a single unsigned binary number.
    // Subtract one from the least significant byte; if this causes a
    // borrow, move on to the next most significant byte, and so on,
    // stopping if we reach the most significant byte.
    //

    for (; pbCur >= pbMSB; --pbCur)
    {
        if (--*pbCur != 0xFF)
        {
            break;
        }
    }

    //
    // We shouldn't have gone past the most significant byte, because that
    // means the subauthority values were all 0, which isn't a valid
    // SID.  Assert that there was no underflow.
    //

    ASSERT(pbCur >= pbMSB);

    // nothing we did should make the SID invalid, so test it again
    ASSERT(IsValidSid(m_psid));
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::Increment
//
//  Synopsis:   Consider the sid's subauthority array as a single unsigned
//              number and increment it.
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CSid::Increment()
{
    if (!m_psid)
    {
        return;
    }

    PBYTE pbMSB = NULL;
    PBYTE pbCur = NULL;

    _GetSubAuthorityRange(&pbMSB, &pbCur);

    for (; pbCur >= pbMSB; --pbCur)
    {
        if (++*pbCur != 0x00)
        {
            break;
        }
    }

    //
    // We shouldn't have gone past the most significant byte, because that
    // means the subauthority values were all 0xFF, which isn't a valid
    // SID.  Assert that there was no overflow.
    //

    ASSERT(pbCur >= pbMSB);

    // nothing we did should make the SID invalid, so test it again
    ASSERT(IsValidSid(m_psid));
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::GetSidAndRidAsByteStr
//
//  Synopsis:   Return a string representation of the sid with an appended
//              RID.
//
//  Arguments:  [strRid] - RID to append
//
//  Returns:    SID in byte string format:
//              \01\05\00\00...
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

String
CSid::GetSidAndRidAsByteStr(
    const String &strRid) const
{
    if (!m_psid)
    {
        return String();
    }

    ULONG   cbSid = 0;
    PUCHAR  pcSubAuth = NULL;
    String strResult;

    pcSubAuth = GetSidSubAuthorityCount(m_psid);
    ASSERT(pcSubAuth);

    cbSid = GetSidLengthRequired(*pcSubAuth);

    //
    // Convert the bytes of the sid to hex chars in the
    // form \xx
    //

    PBYTE  pbSid = (PBYTE) m_psid;
    ULONG  i;

    for (i = 0; i < cbSid; i++)
    {
        WCHAR wzCurByte[4]; // 4 == slash + 2 digits + NUL

        if (pbSid == pcSubAuth)
        {
            // bump the subauthority count in the copy to allow for the
            // RID which we'll concatenate
            // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
            wsprintf(wzCurByte, L"\\%02x", 1 + *pbSid);
        }
        else
        {
            // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
            wsprintf(wzCurByte, L"\\%02x", *pbSid);
        }
        strResult += wzCurByte;
        pbSid++;
    }

    return strResult + strRid;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSid::_GetSubAuthorityRange
//
//  Synopsis:   Return pointers to the most and least significant bytes of
//              the array of subauthorities in the sid.
//
//  Arguments:  [ppbMSB] - receives pointer to most significant byte
//              [ppbLSB] - receives pointer to least significant byte
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CSid::_GetSubAuthorityRange(
    PBYTE *ppbMSB,
    PBYTE *ppbLSB) const
{
    ASSERT(ppbMSB);
    ASSERT(ppbLSB);
    ASSERT(m_psid && IsValidSid(m_psid));

    PUCHAR pcSubAuth = GetSidSubAuthorityCount(m_psid);
    ASSERT(*pcSubAuth);

    *ppbMSB = (PBYTE) GetSidSubAuthority(m_psid, 0);
    *ppbLSB = *ppbMSB + *pcSubAuth * sizeof(ULONG) - 1;

    ASSERT(*ppbMSB < *ppbLSB);
    ASSERT(*ppbMSB > (PBYTE) m_psid);
    ASSERT(*ppbLSB == ((PBYTE) m_psid) + GetSidLengthRequired(*pcSubAuth) - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\srvinfo.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       srvinfo.cxx
//
//  Contents:   Classes for managing per-server credentials.
//
//  Classes:    CServerInfo
//
//  History:    04-24-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CServerInfo)

//
// The ADS_READONLY_SERVER flag was removed because it breaks some NT4 interop scenarios
//
#define OPEN_OBJECT_FLAGS           (ADS_SECURE_AUTHENTICATION | ADS_READONLY_SERVER)

//===========================================================================
//
// CServerInfo
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::CServerInfo
//
//  Synopsis:   ctor
//
//  Arguments:  [pBinder]   - backpointer to parent
//              [pwzServer] - server portion of ads path
//              [flags]     - flags describing [pwzServer]
//
//  History:    04-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CServerInfo::CServerInfo(
    CBinder *pBinder,
    PCWSTR pwzServer,
    USHORT flags):
        m_pBinder(pBinder),
        m_pADsNameTranslate(NULL),
        m_pADsRootDSE(NULL),
        m_hrLastCredError(S_OK),
        m_pNext(NULL),
        m_pADsContainer(NULL),
        m_flProvider(0),
        m_pwzDN(NULL)
{
    //TRACE_CONSTRUCTOR(CServerInfo);
    Dbg(DEB_BIND, "CServerInfo::CServerInfo(%x) '%ws'\n", this, pwzServer);
    DBG_INDENTER;
    ASSERT(!(flags & ~SRVINF_VALID_FLAG_MASK));
    DEBUG_INCREMENT_INSTANCE_COUNTER(CServerInfo);

    _SetFlag(flags);
    // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
    // String is a good option
    lstrcpyn(m_wzServer, pwzServer, ARRAYLEN(m_wzServer));

    //
    // Truncate at a trailing dot because sometimes we'll get it as
    // part of the server and sometimes we won't, and we don't want the
    // string comparison of server names to fail to match because of it.
    //

    PWSTR pwzLastDot = wcsrchr(m_wzServer, L'.');

    if (pwzLastDot && !pwzLastDot[1])
    {
        *pwzLastDot = L'\0';
    }
    
    // NTRAID#NTBUG9-548146-2002/02/20-lucios. Pending fix.
    InitializeCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::IsForServer
//
//  Synopsis:   Return TRUE if this has a container interface for server
//              [pwzServer].
//
//  Arguments:  [flProvider] - PROVIDER_*
//              [pwzServer]  - server name
//
//  History:    08-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CServerInfo::IsForServer(
    ULONG flProvider,
    PCWSTR pwzServer)
{
    return m_flProvider == flProvider && !lstrcmpi(pwzServer, m_wzServer);
}



//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::Init
//
//  Synopsis:   Perform the first part of the initialization of this which
//              can fail and is therefore done outside the ctor
//
//  Arguments:  [hwnd]    - for binding
//              [pwzPath] - NULL or path to bind to
//              [riid]    - identifies desired interface
//              [ppv]     - optional; on success filled with requested
//                           interface
//
//  Returns:    HRESULT
//
//  History:    07-14-1998   DavidMun   Created
//
//  Notes:      This method is only called once for each instance of this
//              class.  The _RepeatableInit() method may be called multiple
//              times.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::Init(
    HWND    hwnd,
    PCWSTR pwzPath,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CServerInfo, Init);
    ASSERT(pwzPath);

    HRESULT hr = S_OK;
    IADs   *pADs = NULL;
    BSTR    bstrProvider = NULL;
    BOOL    fUserIsLocal = IsCurrentUserLocalUser();

    do
    {
        if (pwzPath)
        {
            m_strOriginalPath = pwzPath;
        }
        else
        {
            hr = E_POINTER;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = ProviderFlagFromPath(m_strOriginalPath, &m_flProvider);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Bind to the server for the container interface.  First try
        // binding without credentials.  If this fails because different
        // credentials are needed, prompt the user for them and retry,
        // until success, a non credential error occurs, or the user
        // cancels the prompt.
        //

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     m_strOriginalPath.c_str(),
                                     ADS_FORMAT_PROVIDER,
                                     &bstrProvider);
        BREAK_ON_FAIL_HRESULT(hr);

        m_strOriginalContainerPath = String::format(L"%1://%2",
                                                    bstrProvider,
                                                    m_wzServer);

        if (m_flProvider == PROVIDER_WINNT)
        {
            //
            // Append winnt binding hint from pwzPath
            //

            PWSTR pwzComma = wcschr(pwzPath, L',');

            if (pwzComma)
            {
                m_strOriginalContainerPath += pwzComma;
            }
        }
       if (fUserIsLocal && !_IsFlagSet(SRVINF_WINNT_WORKGROUP_OBJECT) && !IsLocalComputername(m_wzServer))
        {
            //
            // Don't attempt to bind if the user is logged on locally but the
            // thing we need to bind to is not on the local machine.  Two
            // reasons: first, it is going to fail; second, if the user is
            // logged on as local admin the attempt will be logged as a
            // failed logon as DOMAIN admin, which can cause the domain admin
            // account to be locked out.
            //
            // Set a flag to remember that we didn't attempt a bind here so
            // we can suppress any non-credential error later.
            //
            //More comments by hiteshr
            //One more case in which binding will succeed is when server name is
            //name of local workgroup. However we always try to bind if machine 
            //name is workgroup. Reason being this is a very rare scenario( you are
            //logged in as local user and you are trying to browse a remote workgroup)
            //and litte delay caused by failed binding is acceptable.

            _SetFlag(SRVINF_USER_LOCAL_SERVER_REMOTE);

            Dbg(DEB_TRACE,
                "Current user is local and binding off-computer, skipping NULL/NULL bind\n");
            hr = E_ACCESSDENIED;
        }
        else
        {
            TIMER("CServerInfo::Init: ADsOpenObject(%ws,NULL,NULL) for IADsContainer",
                  m_strOriginalContainerPath.c_str());

            ASSERT(!m_pADsContainer);
            hr = _MyADsOpenObject(const_cast<PWSTR>(m_strOriginalContainerPath.c_str()),
                                NULL,
                                NULL,
                                IID_IADsContainer,
                                (void**)&m_pADsContainer);
        }

        //
        // If it worked, we're done.
        //
                  
        if (SUCCEEDED(hr))
        {
            if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT) ||
                _IsFlagSet(SRVINF_WINNT_COMPUTER_OBJECT))
            {
                //
                // Well, almost.  binding to WinNT for domain object
                // can succeed, however actually trying to get attributes from
                // it can fail with ERROR_LOGON_FAILURE.
                //
                // Binding using winnt provider to a computer object can
                // succeed, but reading attributes can fail with
                // E_ACCESSDENIED.  This is because ADSI caches some items
                // and doesn't actually attempt to connect until forced to.
                //

                // jeffjon 12/19/2000, (sburns didn't propogate the fix here as well)
                // that's well and good, but if you
                // don't read some properties, you have the problem
                // with adsi delaying the connect, and you therefore
                // cause regression bug 245866.

                hr = m_pADsContainer->QueryInterface(IID_IADs, (void**)&pADs);

                if (SUCCEEDED(hr))
                {
                    Variant var;

                    // NTRAID#NTBUG9-245866-2000/12/11-sburns

                    // Evidently, administrators can read the
                    // Processor attribute, but not plain users.

                    // workaround for the adsi workaround is to
                    // therefore ignore the result of the Get.
                    // How's that for elegant?
                    
                    if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT))
                    {
                        hr = pADs->Get(AutoBstr(L"MinPasswordLength"), &var);
                    }
                    else
                    {
                        hr = pADs->Get(AutoBstr(L"Processor"), &var);
                    }

                    // The Get call could fail for a number of
                    // reasons.  The remote machine might not be
                    // running the remote registry service, the
                    // creds supplied by the user might be bad, the
                    // creds supplied might be good, but
                    // insufficient to read the processor type from
                    // the remote reg, etc.
                    // 
                    // The error condition we're interested in is
                    // bad creds. In that case, the error returned
                    // is logon failure.  All other failures don't
                    // matter here, since all we interested
                    // in is making sure adsi opens a connection to
                    // the remote machine.
                    //                                     
                    // CODEWORK: the way to fix this is 1) pound on
                    // ADSI dev for a flag to ADsOpenObject that
                    // means "skip your connection optimization", or
                    // 2) do the connection management ourselves
                    // (thus admiting that yet again the ADSI WinNT
                    // provider offers very little value).
                    // NTRAID#NTBUG9-255397-2000/12/12-sburns
                                                                                   
                    if (hr != HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE))
                    {
                       // squeltch the error result

                       DBG_OUT_HRESULT(hr);                                 
                       hr = S_OK;
                    }

                    pADs->Release();
                    pADs = NULL;
                }

                if (FAILED(hr))
                {
                    m_pADsContainer->Release();
                    m_pADsContainer = NULL;
                }
            }
        }

        //
        // ADsOpenObject of the container path using NULL credentials
        // failed.  If the failure cannot be cured by binding with
        // different credentials, give up.
        //

        if (FAILED(hr))
        {

            Dbg(DEB_ERROR,
                "CServerInfo::Init ADsOpenObject(%ws,NULL,NULL) hr=0x%x\n",
                m_strOriginalContainerPath.c_str(),
                hr);
            ULONG ulADsLastError;
            WCHAR wzError[MAX_PATH];
            WCHAR wzProvider[MAX_PATH];

            HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                            wzError,
                                            ARRAYLEN(wzError),
                                            wzProvider,
                                            ARRAYLEN(wzProvider));

            if (SUCCEEDED(hr2))
            {
                Dbg(DEB_ERROR, "ADsGetLastError returns:\n");
                Dbg(DEB_ERROR, "  Error Code    %#x\n", ulADsLastError);
                Dbg(DEB_ERROR, "  Error Message %ws\n", wzError);
                Dbg(DEB_ERROR, "  Provider      %ws\n", wzProvider);
                

                if (ulADsLastError)
                {
                    hr = NT_ERROR(ulADsLastError)?
                         HRESULT_FROM_WIN32(RtlNtStatusToDosError(ulADsLastError)):
                         ulADsLastError;
                }
            }
            else
            {
                DBG_OUT_HRESULT(hr2);
            }

            if (IsCredError(hr))
            {
                Dbg(DEB_BIND,
                    "NULL credentials returned credential hr %#x\n",
                    hr);
                _SetFlag(SRVINF_REQUIRES_CREDENTIALS);

                //
                // Save off the credential related error; this will be returned
                // as the result of attempting to bind if the user cancels the
                // credential dialog.
                //

                m_hrLastCredError = hr;
            }
            else
            {
                break;
            }
        }

        hr = _RepeatableInit(hwnd, riid, ppv);
    } while (0);

    if (FAILED(hr) && m_pADsContainer)
    {
        m_pADsContainer->Release();
        m_pADsContainer = NULL;
    }

    SysFreeString(bstrProvider);
    SAFE_RELEASE(pADs);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_RepeatableInit
//
//  Synopsis:   Attempt to complete the initialization of this begun by the
//              Init() method.
//
//  Arguments:  [hwnd] - for binding
//              [riid] - identifies desired interface
//              [ppv]  - on success filled with requested interface
//
//  Returns:    HRESULT
//
//  History:    06-06-2000   DavidMun   Created
//
//  Notes:      Initializing this requires binding; if the bind requires
//              the user to enter credentials, and the user hits the Cancel
//              button in the credential prompt, this method will exit with
//              a failure code.
//
//              If the user then repeats the action which requires
//              initializing this, _RepeatableInit() will be called again,
//              giving the user another chance to enter credentials.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_RepeatableInit(
    HWND hwnd,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CServerInfo, _RepeatableInit);

    HRESULT hr = S_OK;
    String   userName;
    EncryptedString   password;
    Bstr    bstrContainerPath;
    IADs   *pADs = NULL;
    BSTR    bstrDN = NULL;

    do
    {
        BOOL fUsedDefaultCreds = FALSE;
        BOOL fBinderHadDefaultCreds = FALSE;
        BOOL fPromptedForCreds = FALSE;

        if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            ASSERT(IsCredError(m_hrLastCredError));

            if (_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS))
            {
                Dbg(DEB_BIND, "Previous call tried default creds\n");
                fBinderHadDefaultCreds = TRUE;
                fPromptedForCreds = TRUE;

                hr = _AskForCreds(hwnd, userName, password);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else
            {
                //
                // Obtaining the container interface requires credentials.  If
                // there are default credentials available from the binder, try
                // using those first.  If they aren't available or result in a
                // credential error, go into a loop prompting for and using
                // credentials from user.
                //

                g_pBinder->GetDefaultCreds( m_flProvider,
                                            userName, 
                                            password);

                if (!userName.empty())
                {
                    Dbg(DEB_BIND, "Using default credentials (%ws)\n", userName.c_str());
                    fBinderHadDefaultCreds = TRUE;
                    fUsedDefaultCreds = TRUE; // will use on entry to while(TRUE) loop
                }
                else
                {
                    Dbg(DEB_BIND, "No default credentials, prompting\n", hr);
                    fPromptedForCreds = TRUE;
                    hr = _AskForCreds(hwnd, userName, password);
                    BREAK_ON_FAIL_HRESULT(hr);
                }
            }

            ASSERT(!m_strOriginalContainerPath.empty());

            while (TRUE)
            {
                //
                // Since we're in this loop only because credentials are
                // required, we must have some for the bind we're about to
                // attempt.
                //
                // Creds are supplied by the user in response to a prompt
                // from this method.  The first set ever entered is stored
                // as the default set.
                //
                // If a default set is available it will be used first, or
                // else we should have just prompted for creds during this
                // execution of this method.
                //
                // Assert that we used one of these two methods.  Note that
                // only on the first pass of this loop could we assert that
                // exactly one method had been used.
                //

                ASSERT(fPromptedForCreds || fUsedDefaultCreds);

                {
                    TIMER("ADsOpenObject(%ws,%ws)",
                          m_strOriginalContainerPath.c_str(),
                          userName.c_str());

                    ASSERT(!m_pADsContainer);
                    hr = _MyADsOpenObject((PWSTR)m_strOriginalContainerPath.c_str(),
                                       &userName,
                                       &password,
                                       IID_IADsContainer,
                                       (void**)&m_pADsContainer);
                }

                
                if (SUCCEEDED(hr))
                {
                    if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT) ||
                        _IsFlagSet(SRVINF_WINNT_COMPUTER_OBJECT))
                    {
                        //
                        // Well, almost.  binding to WinNT for domain object
                        // can succeed, however actually trying to get attributes from
                        // it can fail with ERROR_LOGON_FAILURE.
                        //
                        // Binding using winnt provider to a computer object can
                        // succeed, but reading attributes can fail with
                        // E_ACCESSDENIED.  This is because ADSI caches some items
                        // and doesn't actually attempt to connect until forced to.
                        //

                        //Well we cannot assume that we will have access to processor
                        //or MinPasswordLength properties. I have seen intances, most
                        //notably when binding to redmond or ntdev dcs that reading Processor
                        //fails with ACCESS_DENIED error, but if i ignore that error
                        //Everything goes sucessfully. This check is not correct.

                        // sburns 12/7/2000, that's well and good, but if you
                        // don't read some properties, you have the problem
                        // with adsi delaying the connect, and you therefore
                        // cause regression bug 245866.

                        hr = m_pADsContainer->QueryInterface(IID_IADs, (void**)&pADs);

                        if (SUCCEEDED(hr))
                        {
                            Variant var;

                            if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT))
                            {
                                hr = pADs->Get(AutoBstr(L"MinPasswordLength"), &var);
                            }
                            else
                            {
                               // NTRAID#NTBUG9-245866-2000/12/11-sburns

                              // Evidently, administrators can read the
                              // Processor attribute, but not plain users.

                              // workaround for the adsi workaround is to
                              // therefore ignore the result of the Get.
                              // How's that for elegant?
                              
                              hr = pADs->Get(AutoBstr(L"Processor"), &var);

                              // The Get call could fail for a number of
                              // reasons.  The remote machine might not be
                              // running the remote registry service, the
                              // creds supplied by the user might be bad, the
                              // creds supplied might be good, but
                              // insufficient to read the processor type from
                              // the remote reg, etc.
                              // 
                              // The error condition we're interested in is
                              // bad creds. In that case, the error returned
                              // is logon failure.  All other failures don't
                              // matter here, since all we interested
                              // in is making sure adsi opens a connection to
                              // the remote machine.
                              //                                     
                              // CODEWORK: the way to fix this is 1) pound on
                              // ADSI dev for a flag to ADsOpenObject that
                              // means "skip your connection optimization", or
                              // 2) do the connection management ourselves
                              // (thus admiting that yet again the ADSI WinNT
                              // provider offers very little value).
                              // NTRAID#NTBUG9-255397-2000/12/12-sburns
                                                                                             
                              if (hr != HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE))
                              {
                                 // squeltch the error result

                                 DBG_OUT_HRESULT(hr);                                 
                                 hr = S_OK;
                              }
                            }
                            pADs->Release();
                            pADs = NULL;
                        }

                        if (FAILED(hr))
                        {
                            m_pADsContainer->Release();
                            m_pADsContainer = NULL;
                        }
                    }
                }
                
                //
                // If the three clauses in the following if statement are
                // true then tell the user the bind failed.  The three
                // clauses are:
                //
                // 1. the bind failed.
                //
                // 2. the bind attempt was not with the default credentials or
                // the error was not credential related.  In other words,
                // don't notify the user that there was a credential error
                // using the default credentials.
                //
                // 3. it is NOT the case that we got a non-credential related
                // error on the very first attempt to bind.  This can happen
                // if the Init method didn't attempt a bind because the user
                // is logged on locally and the server is remote.
                //

                if (FAILED(hr) && // clause 1
                    (fPromptedForCreds || !IsCredError(hr)) && // clause 2
                    !(!IsCredError(hr) && _IsFlagSet(SRVINF_USER_LOCAL_SERVER_REMOTE))) // clause 3
                {
                    DBG_OUT_HRESULT(hr);

                    ULONG ulADsLastError;
                    WCHAR wzError[MAX_PATH];
                    WCHAR wzProvider[MAX_PATH];

                    HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                                  wzError,
                                                  ARRAYLEN(wzError),
                                                  wzProvider,
                                                  ARRAYLEN(wzProvider));

                    if (SUCCEEDED(hr2))
                    {
                        Dbg(DEB_ERROR, "ADsGetLastError returns:\n");
                        Dbg(DEB_ERROR, "  Error Code    %#x\n", ulADsLastError);
                        Dbg(DEB_ERROR, "  Error Message %ws\n", wzError);
                        Dbg(DEB_ERROR, "  Provider      %ws\n", wzProvider);
                    }
                    else
                    {
                        DBG_OUT_HRESULT(hr2);
                    }

                    
                    String strError(GetErrorMessage(hr));

                    _PopupCredErr(hwnd,
                                  IDS_BIND_ERROR,
                                  strError.c_str());
                }

                //
                // If the bind succeeded, or failed but not because of a
                // problem with the credentials, get out of this bind/prompt
                // loop.
                //

                if (SUCCEEDED(hr) || !IsCredError(hr))
                {
                    if (!fBinderHadDefaultCreds)
                    {
                        ASSERT(fPromptedForCreds);

                        m_pBinder->SetDefaultCreds( userName, 
                                                    password);
                    }
                    break;
                }

                if (fUsedDefaultCreds && IsCredError(hr))
                {
                    //
                    // The binder had default credentials, and using them
                    // resulted in a credential error.  Therefore, completing
                    // this bind requires the use of non-default credentials.
                    //

                    _SetFlag(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS);
                }

                Dbg(DEB_ERROR,
                    "ADsOpenObject(%ws) 0x%x\n",
                    m_strOriginalContainerPath.c_str(),
                    hr);

                fPromptedForCreds = TRUE;
                hr = _AskForCreds(hwnd, userName, password);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Binding to container path without creds or with those in
        // wzUserName and wzPassword succeeded.  If caller wants also
        // a direct bind (i.e., cannot be done by GetObject on container)
        // do that now.
        //

        if (_IsFlagSet(SRVINF_SERVER_NEQ_DN))
        {
            ASSERT(ppv);

            if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
            {
                TIMER("ADsOpenObject(%ws,%ws)",
                      m_strOriginalPath.c_str(),
                      userName.c_str());

                hr = _MyADsOpenObject(const_cast<PWSTR>(m_strOriginalPath.c_str()),
                                   &userName,
                                   &password,
                                   riid,
                                   ppv);
            }
            else
            {
                TIMER("ADsOpenObject(%ws,NULL,NULL)", m_strOriginalPath.c_str());

                hr = _MyADsOpenObject(const_cast<PWSTR>(m_strOriginalPath.c_str()),
                                   NULL,
                                   NULL,
                                   riid,
                                   ppv);
            }
        }

        //
        // Get proper path from container and store its DN
        //

        hr = m_pADsContainer->QueryInterface(IID_IADs, (void**)&pADs);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pADs->get_ADsPath(&bstrContainerPath);
        BREAK_ON_FAIL_HRESULT(hr);

        Dbg(DEB_BIND, "Container path is '%ws'\n", bstrContainerPath.c_str());

        if (m_flProvider == PROVIDER_WINNT)
        {
            //
            // For a WinNT path, the DN is every element past the first.
            //
            // WinNT://FOO/BAR/BAZ  =>  "BAR/BAZ"
            // WinNT://FOO/BAR      =>  "BAR"
            // WinNT://FOO          =>  <no DN>
            //

            PWSTR pwzDnStart = bstrContainerPath.c_str() + lstrlen(c_wzWinNTPrefix);
            pwzDnStart = wcschr(pwzDnStart, L'/');

            if (pwzDnStart)
            {
                NewDupStr(&m_pwzDN, pwzDnStart + 1);
            }
        }
        else
        {
            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         bstrContainerPath.c_str(),
                                         ADS_FORMAT_X500_DN,
                                         &bstrDN);
            BREAK_ON_FAIL_HRESULT(hr);

            if (!bstrDN || !*bstrDN)
            {
                Dbg(DEB_BIND, "Container path has no DN\n");
            }
            else
            {
                NewDupStr(&m_pwzDN, bstrDN);
                Dbg(DEB_BIND, "container path X500 DN is '%ws'\n", m_pwzDN);
            }
        }

        //
        // We got a container.  If the path is a WinNT provider
        // then there is no name translate interface or root dse to
        // get, so we're done.
        //
        // Get a name translate interface and RootDSE object too if
        // credentials are required but default credentials were NOT used.
        //
        // We need to do this now because the name translate interface has
        // to be initialized with credentials, which, since they aren't the
        // default credentials, won't be available on exit from this
        // routine.
        //

        if (m_flProvider == PROVIDER_WINNT)
        {
            break;
        }

        if (_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS))
        {
            hr = _InitNameTranslate(&userName, &password);
            BREAK_ON_FAIL_HRESULT(hr);

            (void) _InitRootDSE(&userName, &password);
        }
    } while (0);


    if (FAILED(hr) && m_pADsContainer)
    {
        m_pADsContainer->Release();
        m_pADsContainer = NULL;
    }

    if (FAILED(hr) && m_pADsNameTranslate)
    {
        m_pADsNameTranslate->Release();
        m_pADsNameTranslate = NULL;
    }

    SysFreeString(bstrDN);
    SAFE_RELEASE(pADs);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_InitNameTranslate
//
//  Synopsis:   Create and initialize an instance of the IADsNameTranslate
//              interface focused on the domain represented by this.
//
//  Arguments:  [wzUserName] - NULL or non-default credentials
//              [wzPassword] - NULL or non-default credentials
//
//  Returns:    HRESULT
//
//  History:    5-11-1999   davidmun   Created
//
//---------------------------------------------------------------------------
HRESULT
CServerInfo::_InitNameTranslate(
    String *userNameArg,
    EncryptedString *passwordArg)
{
    TRACE_METHOD(CServerInfo, _InitNameTranslate);

    HRESULT hr = S_OK;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;
    PDOMAIN_CONTROLLER_INFO pdci2 = NULL;

    // default credentials
    EncryptedString defaultPassword;
    String defaultUserName;

    // point to NULL, defaultPassword or passwordArg
    PWSTR pwzPassword = NULL;
    
    // This might be needed to free clear text copies either from 
    // defaultPassword or passwordArg
    EncryptedString *passwordSource=NULL; 

    do
    {
        ASSERT(!m_pADsNameTranslate);
        hr = CoCreateInstance(CLSID_NameTranslate,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IADsNameTranslate,
                              (PVOID *)&m_pADsNameTranslate);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // The domain with which to initialize the name translate interface
        // is the same as the server, except that a port number must be
        // stripped off if present.
        //

        WCHAR wzServerNoPort[MAX_PATH];

        // NTRAID#NTBUG9-548991-2002/02/20-lucios. Pending fix.
        lstrcpy(wzServerNoPort, m_wzServer);
        PWSTR pwzColon = wcschr(wzServerNoPort, L':');

        if (pwzColon)
        {
            *pwzColon = L'\0';
        }


        // pointer to defaultUserName or userNameArg, if necessary
        PCWSTR pwzUserName=NULL;
        
        // hold the string pwzUserName will point to
        String userName; 
        
        // pointer to domain part of user name if necessary
        PCWSTR pwzLogonDomain=NULL;

        // this will hold the string pwzLogonDomain might point to.
        String logonDomain; 
        

        if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            //
            // Credentials are required.  If non-default creds are required,
            // they've been passed in, otherwise the arguments are NULL and
            // we need to ask the binder for the creds.
            //

            if (!userNameArg)
            {
                g_pBinder->GetDefaultCreds( m_flProvider,
                                            defaultUserName, 
                                            defaultPassword);
                passwordSource=&defaultPassword;
                pwzPassword = defaultPassword.GetClearTextCopy();
                userName = defaultUserName;
                pwzUserName = userName.c_str();
                
            }
            else
            {
                passwordSource=passwordArg;
                pwzPassword = passwordArg->GetClearTextCopy();;
                userName = *userNameArg;
                pwzUserName = userName.c_str();
            }

            String::size_type posWhack=userName.find(L'\\');

            if (posWhack!=String::npos)
            {
                logonDomain=userName.substr(0,posWhack);
                pwzLogonDomain=logonDomain.c_str();
                userName=userName.substr(posWhack+1);
                pwzUserName = userName.c_str();
            }
        }

        if (_IsFlagSet(SRVINF_SERVER_COMPONENT_IS_COMPUTER))
        {
            //
            // Caller specified a DC name, initialize with that
            // specific DC so name translate is sure to find objects which
            // have just been added there.
            //

            if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
            {
                TIMER("IADsNameTranslate::InitEx(ADS_NAME_INITTYPE_SERVER, %ws, %ws, %ws)",
                      wzServerNoPort,
                      CHECK_NULL(pwzUserName),
                      CHECK_NULL(pwzLogonDomain));

                hr = m_pADsNameTranslate->InitEx
                    (
                        ADS_NAME_INITTYPE_SERVER,
                        AutoBstr(wzServerNoPort),
                        AutoBstr(pwzUserName),
                        AutoBstr(pwzLogonDomain),
                        AutoBstr(pwzPassword)
                     );
                CHECK_HRESULT(hr);
            }
            else
            {
                TIMER("IADsNameTranslate::Init(ADS_NAME_INITTYPE_SERVER, %ws)",
                      wzServerNoPort);

                hr = m_pADsNameTranslate->Init(ADS_NAME_INITTYPE_SERVER,
                                                  AutoBstr(wzServerNoPort));
                CHECK_HRESULT(hr);
            }
            break;
        }

        ULONG ulResult;

        //
        // Need to init name translate to domain with name in
        // wzServerNoPort.  First see what DsGetDcName has in its
        // cache.  (If nothing is cached yet, this just means DsBind's
        // call will be fast).
        //

        ulResult = DsGetDcName(NULL,
                               wzServerNoPort,
                               NULL,
                               NULL,
                               0,
                               &pdci);

        if (ulResult != NO_ERROR)
        {
            ASSERT(!pdci);
            Dbg(DEB_WARN,
                "first DsGetDcName for domain %ws returned %uL\n",
                wzServerNoPort,
                ulResult);
        }

        //
        // Now attempt the name translate init.
        //

        if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            TIMER("IADsNameTranslate::InitEx(ADS_NAME_INITTYPE_DOMAIN, %ws, %ws, %ws)",
                  wzServerNoPort,
                  CHECK_NULL(pwzUserName),
                  CHECK_NULL(pwzLogonDomain));

            hr = m_pADsNameTranslate->InitEx
                (
                    ADS_NAME_INITTYPE_DOMAIN,
                    AutoBstr(wzServerNoPort),
                    AutoBstr(pwzUserName),
                    AutoBstr(pwzLogonDomain),
                    AutoBstr(pwzPassword)
                );
            CHECK_HRESULT(hr);
        }
        else
        {
            TIMER("IADsNameTranslate::Init(ADS_NAME_INITTYPE_DOMAIN, %ws)",
                  wzServerNoPort);

            hr = m_pADsNameTranslate->Init(ADS_NAME_INITTYPE_DOMAIN,
                                           AutoBstr(wzServerNoPort));
            CHECK_HRESULT(hr);
        }

        if (FAILED(hr))
        {
            //
            // Name translate init(ex) failed.  It may have been because
            // the cached DC name for domain wzServerNoPort is for a DC
            // that's down.  Try forcing rediscovery of a DC, and if that
            // gives a DC different than the original one, try the name
            // translate init again.
            //

            ulResult = DsGetDcName(NULL,
                                   wzServerNoPort,
                                   NULL,
                                   NULL,
                                   DS_FORCE_REDISCOVERY,
                                   &pdci2);

            if (ulResult != NO_ERROR)
            {
                Dbg(DEB_ERROR,
                    "DsGetDcName (2) for domain %ws returned %uL\n",
                    wzServerNoPort,
                    ulResult);
                hr = HRESULT_FROM_WIN32(ulResult);
                break;
            }

            if (!pdci ||
                lstrcmp(pdci->DomainControllerName,
                        pdci2->DomainControllerName))
            {
                if (pdci)
                {
                    Dbg(DEB_TRACE,
                        "DC changed from %ws to %ws, retrying\n",
                        pdci->DomainControllerName,
                        pdci2->DomainControllerName);
                }
                else
                {
                    Dbg(DEB_TRACE,
                        "second DsGetDcName (force) found DC %ws\n",
                        pdci2->DomainControllerName);
                }

                if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
                {
                    TIMER("IADsNameTranslate::InitEx(ADS_NAME_INITTYPE_DOMAIN, %ws, %ws, %ws)",
                          wzServerNoPort,
                          CHECK_NULL(pwzUserName),
                          CHECK_NULL(pwzLogonDomain));

                    hr = m_pADsNameTranslate->InitEx
                        (
                            ADS_NAME_INITTYPE_DOMAIN,
                            AutoBstr(wzServerNoPort),
                            AutoBstr(pwzUserName),
                            AutoBstr(pwzLogonDomain),
                            AutoBstr(pwzPassword)
                        );
                    CHECK_HRESULT(hr);
                }
                else
                {
                    TIMER("IADsNameTranslate::Init(ADS_NAME_INITTYPE_DOMAIN, %ws)",
                          wzServerNoPort);

                    hr = m_pADsNameTranslate->Init(ADS_NAME_INITTYPE_DOMAIN,
                                                   AutoBstr(wzServerNoPort));
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                Dbg(DEB_TRACE,
                    "Not retrying since only DC reported is %ws\n",
                    pdci->DomainControllerName);
            }
        }
    }
    while (0);



    if (pdci)
    {
        NetApiBufferFree(pdci);
    }

    if (pdci2)
    {
        NetApiBufferFree(pdci2);
    }
    
    if(passwordSource!=NULL && pwzPassword!=NULL)
    {
        passwordSource->DestroyClearTextCopy(pwzPassword);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_InitRootDSE
//
//  Synopsis:   Bind to the RootDSE object and hold onto an interface in
//              m_pADsRootDSE.
//
//  Arguments:  [wzUserName] - NULL or non-default credentials
//              [wzPassword] - NULL or non-default credentials
//
//  Returns:    HRESULT
//
//  History:    5-11-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_InitRootDSE(
    String *userName,
    EncryptedString *password)
{
    TRACE_METHOD(CServerInfo, _InitRootDSE);

    HRESULT hr = S_OK;
    WCHAR wzRootDSEPath[MAX_PATH];
    // NTRAID#NTBUG9-548039-2002/02/20-lucios. Pending fix.
    wsprintf(wzRootDSEPath, L"LDAP://%ws/RootDSE", m_wzServer);

    do
    {
        if (!_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            {
                TIMER("CServerInfo-ADsOpenObject(%ws,NULL,NULL)", wzRootDSEPath);

                hr = _MyADsOpenObject(wzRootDSEPath,
                                   NULL,
                                   NULL,
                                   IID_IADs,
                                   (void**)&m_pADsRootDSE);
            }
            CHECK_HRESULT(hr);
            break;
        }

        //
        // Credentials are required.  Either they were passed in or
        // we can use the default.
        //

        if (userName)
        {
            TIMER("CServerInfo-ADsOpenObject(%ws,%ws)",
                  wzRootDSEPath,
                  userName->c_str());

            hr = _MyADsOpenObject(wzRootDSEPath,
                               userName,
                               password,
                               IID_IADs,
                               (void**)&m_pADsRootDSE);
            CHECK_HRESULT(hr);
        }
        else
        {
            String      defaultUserName;
            EncryptedString   defaultPassword;

            g_pBinder->GetDefaultCreds( PROVIDER_LDAP,
                                        defaultUserName, 
                                        defaultPassword);

            {
                TIMER("CServerInfo-ADsOpenObject(%ws,%ws)",
                      wzRootDSEPath,
                      defaultUserName.c_str());

                hr = _MyADsOpenObject(wzRootDSEPath,
                                   &defaultUserName,
                                   &defaultPassword,
                                   IID_IADs,
                                   (void**)&m_pADsRootDSE);
            }
            CHECK_HRESULT(hr);
        }


    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::~CServerInfo
//
//  Synopsis:   dtor
//
//  History:    04-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CServerInfo::~CServerInfo()
{
    TRACE_DESTRUCTOR(CServerInfo);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CServerInfo);

    SAFE_RELEASE(m_pADsContainer);
    SAFE_RELEASE(m_pADsNameTranslate);
    SAFE_RELEASE(m_pADsRootDSE);

    delete [] m_pwzDN;
    DeleteCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_AskForCreds
//
//  Synopsis:   Dispatch based on whether we're running in the thread that
//              created [hwndParent].
//
//  Arguments:  [hwndParent] - parent for modal password dialog
//              [wzUserName] - buffer to fill with name entered by user
//              [wzPassword] - buffer to fill with password entered by user
//
//  Returns:    S_OK if user enters credentials.
//              E_* if password dialog couldn't be opened.
//              Last credential error if user cancels password dialog.
//
//  Modifies:   *[wzUserName], *[wzPassword]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called by CServerInfo::OpenObject when it gets a credential
//              error.
//
//              This method blocks until password dialog is closed.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_AskForCreds(
    HWND hwndParent,
    String &userName,
    EncryptedString &password)
{
    TRACE_METHOD(CServerInfo, _AskForCreds);

    HRESULT hr;

    //
    // This method is called via g_pBinder->BindToObject which itself may
    // be called from either thread.
    //
    // If we're running in the primary thread, use SendMessage to call
    // the routine that invokes the password dialog.
    //
    // If in non-primary thread post message to main thread to
    // pop up password dialog, then wait on event for it to complete.
    //

    ASSERT(!hwndParent || IsWindow(hwndParent));

    if (!hwndParent
        || GetWindowLongPtr(hwndParent, DWLP_DLGPROC) != (LONG_PTR) CDlg::_DlgProc)
    {
        Dbg(DEB_TRACE, "hwndParent = %#x, invoking password dialog directly\n", hwndParent);
        CPasswordDialog PasswordDlg(m_flProvider,
                                    m_wzServer,
                                    &userName,
                                    &password);

        hr = PasswordDlg.DoModalDialog(hwndParent);
    }
    else if (GetWindowThreadProcessId(hwndParent, NULL) == GetCurrentThreadId())
    {
        hr = _AskForCredsViaSendMessage(hwndParent, userName, password);
    }
    else
    {
        hr = _AskForCredsViaPostMessage(hwndParent, userName, password);
    }

    if (hr == S_FALSE)
    {
        hr = m_hrLastCredError;
    }
    else if (SUCCEEDED(hr))
    {
        //
        // If the username is neither in NT4 (domain\user) or UPN
        // (user@domain) format, then the bind will definitely fail.
        // If that's the case, change the name to domain\user, where
        // domain is the name of the thing we're trying to get access
        // to.
        //
        String::size_type posWhack=userName.find(L'\\');
        String::size_type posAt=userName.find(L'@');
        if ( (posWhack==String::npos) && (posAt==String::npos) )
        {
            String strNewName(m_wzServer);

            //
            // Strip port number, if any
            //

            if (strNewName.find(L':') != String::npos)
            {
                strNewName.erase(strNewName.find(L':'),
                                 String::npos);
            }

            //
            // If the server looks like a DNS name (contains at least one
            // '.' and one alpha character), use UPN format.
            // Otherwise assume it is a netbios or ip address and use NT4
            // format.
            //

            if (strNewName.find(L'.') != String::npos &&
                find_if(strNewName.begin(), strNewName.end(), IsCharAlpha) !=
                strNewName.end())
            {
                strNewName.insert(0, L"@");
                strNewName.insert(0, userName);

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    userName.c_str(),
                    strNewName.c_str());

                // NTRAID#NTBUG9-548991-2002/02/20-lucios. 
                userName=strNewName;
            }
            else
            {
                strNewName += L"\\";
                strNewName += userName;

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    userName.c_str(),
                    strNewName.c_str());
                
                // NTRAID#NTBUG9-548991-2002/02/20-lucios. 
                userName=strNewName;
            }
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_AskForCredsViaSendMessage
//
//  Synopsis:   Use SendMessage to call the CDsBrowseMgr routine that invokes
//              the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from main thread.  Blocks until password dialog
//              closes.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_AskForCredsViaSendMessage(
    HWND hwndParent,
    String &userName,
    EncryptedString &password)
{
    TRACE_METHOD(CServerInfo, _AskForCredsViaSendMessage);
    CRED_MSG_INFO cmi = {
                            m_flProvider,
                            m_wzServer,
                            &userName,
                            &password,
                            NULL,
                            S_OK
                        };

    SendMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_AskForCredsViaPostMessage
//
//  Synopsis:   Request that the main thread put up the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from worker thread.  Blocks until main thread
//              sets event after password dialog closes.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_AskForCredsViaPostMessage(
    HWND hwndParent,
    String &userName,
    EncryptedString &password)
{
    TRACE_METHOD(CServerInfo, _AskForCredsViaPostMessage);
    ASSERT(hwndParent && IsWindow(hwndParent));

    CRED_MSG_INFO cmi = {
                            m_flProvider,
                            m_wzServer,
                            &userName,
                            &password,
                            NULL,
                            S_OK
                        };

    cmi.hPrompt = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!cmi.hPrompt)
    {
        DBG_OUT_LASTERROR;
        cmi.hr = HRESULT_FROM_LASTERROR;
        return cmi.hr;
    }

    PostMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);

    WaitForSingleObject(cmi.hPrompt, INFINITE);
    CloseHandle(cmi.hPrompt);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_PopupCredErr
//
//  Synopsis:   Pop up a dialog indicating a failure with the credentials
//              the user entered and block until the dialog is dismissed
//
//  Arguments:  [hwnd]        - parent wiindow
//              [ids]         - resource id of dialog message
//              [pwzUserName] - name used in creds
//              [pwzError]    - error received when using them
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      This method may safely be called from the worker thread
//
//---------------------------------------------------------------------------

void
CServerInfo::_PopupCredErr(
    HWND hwnd,
    ULONG ids,
    PCWSTR pwzError)
{
    TRACE_METHOD(CServerInfo, _PopupCredErr);

    //
    // If we're in same thread that created [hwnd], just pop up the message
    //

    if (!hwnd || GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId())
    {
        PopupMessage(hwnd, ids, pwzError);
        return;
    }

    //
    // We're not running in the thread that created [hwnd], so post a message
    // to it and ask it to display message.
    //

    POPUP_MSG_INFO mi = {
                            hwnd,
                            ids,
                            pwzError,
                            NULL
                        };

    mi.hPrompt = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (mi.hPrompt)
    {
        PostMessage(hwnd,
                    OPM_POPUP_CRED_ERROR,
                    0,
                    reinterpret_cast<LPARAM>(&mi));
        WaitForSingleObject(mi.hPrompt, INFINITE);
        CloseHandle(mi.hPrompt);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::OpenObject
//
//  Synopsis:   Return the requested interface on the object with ADsPath
//              [pwzPath].
//
//  Arguments:  [hwnd]         - used as parent for modal password dialog.
//              [pwzPath]      - ads path of object to open; must have
//                                server portion of m_wzServer.
//              [riid]         - requested interface
//              [ppv]          - out pointer for interface instance
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppv]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only by CBinder::BindToObject.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::OpenObject(
    HWND    hwnd,
    PCWSTR pwzPath,
    REFIID riid,
    LPVOID *ppv)
{
    Dbg(DEB_BIND, "CServerInfo::OpenObject(%x) '%ws'\n", this, pwzPath);
    //ASSERT(hwnd);

    HRESULT hr = S_OK;
    CWaitCursor Hourglass;

    //
    // Init out pointer for failure
    //

    *ppv = NULL;


    do
    {
        //
        // If we don't have container interface, we can't get the object.
        //

        if (!m_pADsContainer)
        {
            if (SUCCEEDED(m_hrLastCredError))
            {
                hr = E_FAIL;
                break;
            }
            ASSERT(_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS));

            //
            // The reason we don't have the container interface is because
            // the user was prompted for credentials but hit cancel.
            //

            hr = _RepeatableInit(hwnd, riid, ppv);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        ASSERT(m_pADsContainer);

        //
        // We already have a container interface on the domain
        // for this path, so use it to bind to the object.
        //
        // To do that, we'll have to obtain the RDN of the object; it
        // must be relative to the path to the container.
        //
        // To obtain the RDN for pwzPath being a WinNT path, find the
        // server inside the path, and delete everything from the start
        // to the slash just past the server.  Also, if there is a
        // binding hint (",Domain" or ",Computer"), truncate that.
        //
        // To obtain the RDN for pwzPath being an LDAP path, use the
        // path cracker interface.
        //

        String strRDN;

        if (m_flProvider == PROVIDER_WINNT)
        {
            //
            // NTRAID#NTBUG9-348828-2001/03/20-hiteshr
            // For a XWRK/X/USER, rdn was coming as
            // WRK/X/USER. 
            //
            hr = g_pADsPath->GetWinntPathRDN(   pwzPath, 
                                                &strRDN);
            BREAK_ON_FAIL_HRESULT(hr);            

            size_t idxComma = strRDN.find(L',');

            if (idxComma != String::npos)
            {
                strRDN.erase(idxComma);
            }

            Dbg(DEB_BIND, "WinNT RDN is '%ws'\n", strRDN.c_str());
        }
        else
        {
            Bstr bstrDN;

            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         pwzPath,
                                         ADS_FORMAT_X500_DN,
                                         &bstrDN);
            BREAK_ON_FAIL_HRESULT(hr);

            if (bstrDN.c_str() && *bstrDN.c_str())
            {
                if (m_pwzDN)
                {
                    PWSTR pwzMatchingDN = wcsistr(bstrDN.c_str(), m_pwzDN);

                    //
                    // Convert the DN of the object we're trying to bind to into
                    // an RDN which is relative to the container.  Do this by
                    // truncating at the substring of the object path which
                    // matches the container's DN.
                    //

                    if (!pwzMatchingDN)
                    {
                        Dbg(DEB_ERROR,
                            "no match for container DN '%ws' in object RDN '%ws', attempting direct bind\n",
                            m_pwzDN,
                            bstrDN.c_str());
                        hr = BindDirect(hwnd, pwzPath, riid, ppv);
                        break;
                    }

                    Dbg(DEB_BIND, "ldap matching DN is '%ws'\n", pwzMatchingDN);

                    strRDN = bstrDN.c_str();
                    strRDN.erase(pwzMatchingDN - bstrDN.c_str());

                    //
                    // this may leave a trailing comma, if so, zap it.
                    //

                    size_t idxLastComma = strRDN.rfind(L',');

                    if (idxLastComma != String::npos &&
                        idxLastComma == strRDN.length() - 1)
                    {
                        strRDN.erase(idxLastComma);
                    }
                }
                else
                {
                    strRDN = bstrDN.c_str();
                }
            }
            else
            {
                strRDN.erase();
            }
            Dbg(DEB_BIND, "ldap RDN is '%ws'\n", strRDN.c_str());
        }

        //
        // If there is no RDN, caller actually wants interface on
        // container.
        //

        if (strRDN.empty())
        {
            Dbg(DEB_BIND, "Empty RDN, doing QI on container\n");

            hr = m_pADsContainer->QueryInterface(riid, ppv);
            CHECK_HRESULT(hr);
            break;
        }

        IDispatch *pdisp = NULL;
        {
            TIMER("GetObject(%ws)", strRDN.c_str());
            hr = m_pADsContainer->GetObject(NULL,
                                            AutoBstr(strRDN),
                                            &pdisp);
        }

        if (SUCCEEDED(hr))
        {
            hr = pdisp->QueryInterface(riid, ppv);
            pdisp->Release();
            break;
        }
        else
        {
            DBG_OUT_HRESULT(hr);
        }
    }
    while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::BindDirect
//
//  Synopsis:   Bind directly to [pwzPath] instead of taking the path apart
//              and retrieving the object it refers to via
//              IADsContainer::GetObject.
//
//  Arguments:  [hwnd]    - parent for modal password dialog
//              [pwzPath] - full ADsPath to bind to
//              [riid]    - interface to bind for
//              [ppv]     - filled with interface instance
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppv]
//
//  History:    5-11-1999   davidmun   Created
//
//  Notes:      This method should only be called when it is impossible to
//              use IADsContainer::GetObject, i.e., when
//              CServerInfo::OpenObject is guaranteed to fail.  See code
//              for initializing the list of WKSP objects.
//
//              Caller must Release returned interface.
//
//---------------------------------------------------------------------------
HRESULT
CServerInfo::BindDirect(
    HWND hwnd,
    PCWSTR pwzPath,
    REFIID riid,
    PVOID *ppv)
{
    TRACE_METHOD(CServerInfo, BindDirect);
    ASSERT(ppv);

    HRESULT hr = S_OK;

    if (!_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
    {
        TIMER("ADsOpenObject(%ws,NULL,NULL)", pwzPath);

        hr = _MyADsOpenObject((PWSTR)pwzPath,
                           NULL,
                           NULL,
                           riid,
                           ppv);
        CHECK_HRESULT(hr);
        return hr;
    }

    //
    // Credentials required for bind.
    //

    String userName;
    EncryptedString password;

    if (_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS))
    {
        hr = _AskForCreds(hwnd, userName, password);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }
    }
    else
    {
        g_pBinder->GetDefaultCreds( m_flProvider,
                                    userName, 
                                    password);

        //
        // The fact that SRVINF_REQUIRES_CREDENTIALS is set implies that
        // CServerInfo::Init has already been called, however _RepeatableInit
        // may not have been called, or may not have gotten creds.  If there
        // are no default creds, ask for some.
        //

        if (userName.empty())
        {
            Dbg(DEB_WARN, "No default credentials, prompting\n");

            hr = _AskForCreds(hwnd, userName, password);

            if (SUCCEEDED(hr))
            {
                g_pBinder->SetDefaultCreds( userName, 
                                            password);
            }
            else
            {
                DBG_OUT_HRESULT(hr);
                return hr;
            }
        }
    }

    BOOL fFirstPass = TRUE;

    while (TRUE)
    {
        {
            TIMER("ADsOpenObject(%ws,%ws)", pwzPath, userName.c_str());

            hr = _MyADsOpenObject((PWSTR)pwzPath,
                               &userName,
                               &password,
                               riid,
                               ppv);
        }

        //
        // If the bind failed, tell the user, unless the bind
        // attempt was with the default credentials.
        //

        if (FAILED(hr) &&
            !(fFirstPass && !_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS)))
        {
            DBG_OUT_HRESULT(hr);
            String strError(GetErrorMessage(hr));

            _PopupCredErr(hwnd,
                          IDS_BIND_ERROR,
                          strError.c_str());
        }

        if (SUCCEEDED(hr) || !IsCredError(hr))
        {
            break;
        }

        fFirstPass = FALSE;

        Dbg(DEB_ERROR,
            "ADsOpenObject(%ws) 0x%x\n",
            pwzPath,
            hr);

        hr = _AskForCreds(hwnd, userName, password);
        BREAK_ON_FAIL_HRESULT(hr);
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::GetNameTranslate
//
//  Synopsis:   Return the name translate interface for use with this
//              server, or NULL if one couldn't be created or initialized.
//
//  Arguments:  [ppNameTranslate] - out pointer for interface.
//
//  Returns:    S_OK or E_FAIL.
//
//  Modifies:   *[ppNameTranslate]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Caller must Release returned interface.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::GetNameTranslate(
    IADsNameTranslate **ppNameTranslate)
{
    TRACE_METHOD(CServerInfo, GetNameTranslate);

    HRESULT hr = S_OK;

    if (!m_pADsNameTranslate)
    {
        hr = _InitNameTranslate(NULL, NULL);
    }

    if (m_pADsNameTranslate)
    {
        m_pADsNameTranslate->AddRef();
        *ppNameTranslate = m_pADsNameTranslate;
    }
    else
    {
        *ppNameTranslate = NULL;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::GetRootDSE
//
//  Synopsis:   Fill *[ppADsRootDSE] with an AddRef'd instance of the
//              RootDSE object.
//
//  Arguments:  [ppADsRootDSE] - filled with pointer to interface on RootDSE
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppADsRootDSE]
//
//  History:    5-11-1999   davidmun   Created
//
//  Notes:      Caller must call Release on returned interface.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::GetRootDSE(
    IADs **ppADsRootDSE)
{
    TRACE_METHOD(CServerInfo, GetRootDSE);

    HRESULT hr = S_OK;

    if (!m_pADsRootDSE)
    {
        hr = _InitRootDSE(NULL, NULL);
    }

    if (m_pADsRootDSE)
    {
        m_pADsRootDSE->AddRef();
        *ppADsRootDSE = m_pADsRootDSE;
    }
    else
    {
        *ppADsRootDSE = NULL;
    }

    return hr;
}



// Wrapper used to ensure consistent flags used.
// NTRAID#NTBUG9-107524-2000/11/13-sburns

HRESULT
CServerInfo::_MyADsOpenObject(
   PCWSTR path,
   String *user,
   EncryptedString *password,
   REFIID riid,
   void** ppObject)
{
   TRACE_METHOD(CServerInfo, _MyADsOpenObject);

   HRESULT hr = S_OK;

   DWORD flags = OPEN_OBJECT_FLAGS;

   if (
      
      // we're using the LDAP provider
      
         (m_flProvider == PROVIDER_LDAP)

      // and the path contains a server component
      
      && (_IsFlagSet(SRVINF_SERVER_COMPONENT_IS_COMPUTER)) )
   {
      // we need to specify ADS_SERVER_BIND, to satisfy
      // NTRAID#NTBUG9-372285-2000/11/09-sburns

      flags |= ADS_SERVER_BIND;
   }
   
#if DBG==1
   static DWORD adminFlags=GetADsOpenObjectFlags();
   Dbg(
      DEB_BIND,
      "CServerInfo::_MyADsOpenObject(%x) '%ws' '%ws' %x\n",
       this,
       path ? path : L"(null)",
       user ? user->c_str() : L"(null)",
       flags | adminFlags );
#endif
   
   PWSTR pwzPassword=NULL;
   PCWSTR pwzUser=NULL;
   if(password && user)
   {
        pwzPassword=password->GetClearTextCopy();
        pwzUser=user->c_str();
   }
                 
   hr =
      AdminToolsOpenObject(
         path,
         pwzUser,
         pwzPassword,
         flags,
         riid,
         ppObject);
   
   if(pwzPassword!=NULL)
   {
        password->DestroyClearTextCopy(pwzPassword);
   }
         
   Dbg(DEB_BIND, "hr = %x\n", hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\variant.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       variant.cxx
//
//  Contents:   Implementation of Variant safe wrapper class
//
//  Classes:    Variant
//
//  History:    02-14-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+--------------------------------------------------------------------------
//
//  Member:     Variant::operator =
//
//  Synopsis:   copy ctor
//
//  History:    03-21-2000   davidmun   Created
//
//---------------------------------------------------------------------------

Variant &
Variant::operator =(
    const Variant &rhs)
{
    do
    {
        if (&rhs.m_var == &m_var)
        {
            ASSERT(0 && "assigning to self");
            break;
        }

        VariantClear(&m_var);

        if (rhs.Type() == VT_UI8)
        {
            SetUI8(rhs.GetUI8());
            break;
        }

        HRESULT hr = VariantCopy(&m_var, (VARIANT*)&rhs.m_var);

        if (FAILED(hr))
        {
            Dbg(DEB_ERROR,
                "Error %#x copying source type %#x to dest type %#x\n",
                hr,
                V_VT((VARIANT*)&rhs.m_var),
                V_VT(&m_var));
            ASSERT(Empty());
        }
    } while (0);

    m_cArrayAccess = 0;

    return *this;
}




//+--------------------------------------------------------------------------
//
//  Member:     Variant::operator =
//
//  Synopsis:   Convert an ADS_SEARCH_COLUMN into a VARIANT
//
//  Arguments:  [ADsCol] - value to convert
//
//  History:    02-14-2000   davidmun   Created
//
//---------------------------------------------------------------------------

Variant &
Variant::operator =(
    const ADS_SEARCH_COLUMN &ADsCol)
{
    ASSERT(ADsCol.dwNumValues);

    SAFEARRAYBOUND sab = { 0, 0 };
    SAFEARRAY *psa = NULL;

    VariantClear(&m_var);
    m_cArrayAccess = 0;

    switch (ADsCol.dwADsType)
    {
    case ADSTYPE_INVALID:
        // leave variant empty
        break;

    case ADSTYPE_DN_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].DNString);
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].CaseExactString);
        break;

    case ADSTYPE_CASE_IGNORE_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].CaseIgnoreString);
        break;

    case ADSTYPE_PRINTABLE_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].PrintableString);
        break;

    case ADSTYPE_NUMERIC_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].NumericString);
        break;

    case ADSTYPE_OBJECT_CLASS:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].ClassName);
        break;

    case ADSTYPE_BOOLEAN:
        V_VT(&m_var) = VT_BOOL;
        V_BOOL(&m_var) = static_cast<VARIANT_BOOL>(ADsCol.pADsValues[ADsCol.dwNumValues - 1].Boolean);
        break;

    case ADSTYPE_INTEGER:
        V_VT(&m_var) = VT_UI4;
        V_UI4(&m_var) = ADsCol.pADsValues[ADsCol.dwNumValues - 1].Integer;
        break;

    case ADSTYPE_OCTET_STRING:
        V_VT(&m_var) = VT_ARRAY | VT_UI1;
        sab.cElements =
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].OctetString.dwLength;
        psa = SafeArrayCreate(VT_UI1, 1, &sab);
        if (psa)
        {
            CopyMemory(psa->pvData,
                       ADsCol.pADsValues[ADsCol.dwNumValues - 1].OctetString.lpValue,
                       sab.cElements);
        }
        break;

    case ADSTYPE_PROV_SPECIFIC:
        V_VT(&m_var) = VT_ARRAY | VT_UI1;
        sab.cElements =
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].ProviderSpecific.dwLength;
        psa = SafeArrayCreate(VT_UI1, 1, &sab);
        if (psa)
        {
            CopyMemory(psa->pvData,
                       ADsCol.pADsValues[ADsCol.dwNumValues - 1].ProviderSpecific.lpValue,
                       sab.cElements);
        }
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        V_VT(&m_var) = VT_ARRAY | VT_UI1;
        sab.cElements =
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].SecurityDescriptor.dwLength;
        psa = SafeArrayCreate(VT_UI1, 1, &sab);
        if (psa)
        {
            CopyMemory(psa->pvData,
                       ADsCol.pADsValues[ADsCol.dwNumValues - 1].SecurityDescriptor.lpValue,
                       sab.cElements);
        }
        break;

    case ADSTYPE_UTC_TIME:
        // systemtime
        V_VT(&m_var) = VT_DATE;
        VERIFY(SystemTimeToVariantTime(
                const_cast<LPSYSTEMTIME>(&ADsCol.pADsValues[ADsCol.dwNumValues - 1].UTCTime),
                &V_DATE(&m_var)));
        break;

    case ADSTYPE_LARGE_INTEGER:
        V_VT(&m_var) = VT_I8;
        V_I8(&m_var) = ADsCol.pADsValues[ADsCol.dwNumValues - 1].LargeInteger.QuadPart;
        break;


    case ADSTYPE_CASEIGNORE_LIST:
    case ADSTYPE_OCTET_LIST:
    case ADSTYPE_POSTALADDRESS:
    case ADSTYPE_PATH:
    case ADSTYPE_TIMESTAMP:
    case ADSTYPE_BACKLINK:
    case ADSTYPE_TYPEDNAME:
    case ADSTYPE_HOLD:
    case ADSTYPE_NETADDRESS:
    case ADSTYPE_REPLICAPOINTER:
    case ADSTYPE_FAXNUMBER:
    case ADSTYPE_EMAIL:
        // according to SDK these are "mainly used for the NDS provider",
        // which object picker does not support.
        Dbg(DEB_WARN, "Ignoring NDS type value %uL\n", ADsCol.dwADsType);
        break;

    case ADSTYPE_UNKNOWN:
        // apparently this is a private internal type, we shouldn't see it
        Dbg(DEB_WARN, "Ignoring type value ADSTYPE_UNKNOWN\n");
        break;

    case ADSTYPE_DN_WITH_BINARY:
    case ADSTYPE_DN_WITH_STRING:
        // don't expect these to be exposed for querying
        Dbg(DEB_WARN, "Ignoring type value %uL\n", ADsCol.dwADsType);
        break;

    default:
        ASSERT(0 && "Variant::Variant: Unexpected ADsType");
        Dbg(DEB_WARN, "Ignoring unexpected type value %uL\n", ADsCol.dwADsType);
        break;
    }


    if (V_VT(&m_var) == VT_BSTR && !V_BSTR(&m_var) ||
        (V_VT(&m_var) & VT_ARRAY) && !psa)
    {
        V_VT(&m_var) = VT_EMPTY;
        Dbg(DEB_ERROR, "Variant::Variant: out of memory for string, throwing bad_alloc\n");
        throw bad_alloc();
    }

    if (V_VT(&m_var) & VT_ARRAY)
    {
        if (!psa)
        {
            V_VT(&m_var) = VT_EMPTY;
            Dbg(DEB_ERROR, "Variant::Variant: out of memory for array, throwing bad_alloc\n");
            throw bad_alloc();
        }

        V_ARRAY(&m_var) = psa;
        psa = NULL;
    }
    return *this;
}


void
Variant::Clear()
{
    ULONG i;

    for (i = 0; i < m_cArrayAccess; i++)
    {
        ::SafeArrayUnaccessData(V_ARRAY(&m_var));
    }
    VariantClear(&m_var);
}



HRESULT
Variant::SetBstr(
    const String &strNew)
{
    if (!Empty())
    {
        Clear();
    }

    V_VT(&m_var) = VT_BSTR;
    V_BSTR(&m_var) = SysAllocString(strNew.c_str());

    if (!V_BSTR(&m_var))
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________


#include "admindbg.h"
#include <tchar.h>

//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #if DBG==1
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG==1
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     CDbg::Trace(lpstrfmt, ...);
//
//      Same as CDbg::DebugOut, except that debug_level is internally
//      set to DEB_TRACE.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

#undef ASSERT
#undef ASSERTMSG

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#undef  TRACE
#undef  ASSERT
#undef  VERIFY


#if DBG==1

    #define Dbg                         DBG_COMP.DebugOut
    #define TRACE                       DBG_COMP.Trace

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1

    #define DBG_INDENTER    \
            CIndenter Indent(&DBG_COMP)

    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD_EX(Infolevel, Class, Method) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION_EX(Infolevel, Function) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

#else

    inline void __cdecl __DummyDbg(ULONG, PCWSTR, ...) { }
    inline void __cdecl __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __cdecl __DummyTrace(PCWSTR, ...) { }
    inline void __cdecl __DummyTrace(LPCSTR, ...) { }
    #define TRACE           1 ? (void)0 : ::__DummyTrace

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK
    #define DBG_INDENTER

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)
    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls)
    #define TRACE_DESTRUCTOR_EX(Infolevel, cls)
    #define TRACE_METHOD_EX(Infolevel, ClassName, MethodName)
    #define TRACE_FUNCTION_EX(Infolevel, FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   e

    #define ASSERT(e)
    #define VERIFY(e)   e

#endif // DBG==1



#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\test\main.cxx ===
#include "headers.hxx"
#pragma hdrstop
#include <compobj.h>
#include <initguid.h>

//
// Helpful debug macros
//

#define DBG_OUT_HRESULT(hr) printf("error 0x%x at line %u\n", hr, __LINE__)


#define BREAK_ON_FAIL_HRESULT(hr)   \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            break;                  \
        }

//
// Forward references
//

VOID
DumpDsSelectedItemList(
    PDSSELECTIONLIST pDsSelList,
    ULONG cRequestedAttributes,
    LPCTSTR *aptzRequestedAttributes);

VOID
Usage();

HRESULT
AnsiToUnicode(
    LPWSTR pwszTo,
    LPCSTR szFrom,
    LONG   cchTo);

BOOL
ParseFetchSwitch(
    char *pzFetchSwitch,
    PULONG pcRequestedAttributes,
    LPCTSTR **paptzRequestedAttributes);

BOOL
ParseGroupSwitch(
    char *pzGroupSwitch,
    ULONG *pulFlags);

BOOL
ParseUserSwitch(
    char *pzUserSwitch,
    ULONG *pulFlags);

BOOL
ParseInitialScope(
    char *pzScopeSwitch,
    ULONG *pulFlags);

BOOL
ParseScope(
    char *pzScopeSwitch,
    ULONG *pulFlags,
    PWSTR wzComputer,
    PWSTR wzDomain);

BOOL
ParseProviders(
    char *pzProviderSwitch,
    PULONG cAcceptableProviders,
    LPCWSTR **paptzAcceptableProviders);

BOOL
ParseRunCount(
    char *pzRunCountSwitch,
    PULONG pcRunCount);

LPWSTR
VariantString(
    VARIANT *pvar);

void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchbuf);

//
// Entry point
//

enum API_TO_CALL
{
    NONE,
    COMPUTER,
    USER_GROUP
};

void _cdecl
main(int argc, char * argv[])
{
    HRESULT     hr;
    BOOL        fBadArg = FALSE;
    API_TO_CALL api = NONE;

    ULONG       flObjectPicker = 0;
    ULONG       flDsObjectPicker = 0;
    ULONG       flUserGroupObjectPickerSpecifiedDomain = 0;
    ULONG       flUserGroupObjectPickerOtherDomains = 0;
    ULONG      *pflUserGroup = &flUserGroupObjectPickerOtherDomains;
    ULONG       flComputerObjectPicker = 0;
    ULONG       flInitialScope = 0;

    WCHAR       wzComputer[MAX_PATH] = L"";
    WCHAR       wzDomain[MAX_PATH] = L"";

    ULONG       cAcceptableProviders = 0;
    LPCWSTR     *aptzAcceptableProviders = NULL;

    ULONG       cInvocations = 1;
    ULONG       cRequestedAttributes = 0;
    LPCTSTR     *aptzRequestedAttributes = NULL;

    for (int idxArg = 1; idxArg < argc && !fBadArg; idxArg++)
    {
        switch (argv[idxArg][1])
        {
        case 'c':
        case 'C':
            if (argv[idxArg][2] == ':' &&
                tolower(argv[idxArg][3]) == 'a')
            {
                if (api == USER_GROUP)
                {
                    fBadArg = TRUE;
                    printf("Can't specify /C:Api with user/group switches\n");
                }
                api = COMPUTER;
            }
            else
            {
                if (api == COMPUTER)
                {
                    fBadArg = TRUE;
                    printf("Can't specify both /C and /C:Api\n");
                }
                api = USER_GROUP;
                *pflUserGroup |= UGOP_COMPUTERS;
            }
            break;

        case 'd':
        case 'D':
            if (argv[idxArg][2] != ':')
            {
                printf("Expected ':' after /D\n");
                fBadArg = TRUE;
                break;
            }

            switch (argv[idxArg][3])
            {
            case 's':
            case 'S':
                pflUserGroup = &flUserGroupObjectPickerSpecifiedDomain;
                break;

            case 'o':
            case 'O':
            case '0': // allow a typo
                pflUserGroup = &flUserGroupObjectPickerOtherDomains;
                break;

            default:
                fBadArg = TRUE;
                printf("Expected S or O after /D:\n");
                break;
            }
            break;

        case 'f':
        case 'F':
            fBadArg = !ParseFetchSwitch(argv[idxArg], &cRequestedAttributes, &aptzRequestedAttributes);
            break;

        case 'g':
        case 'G':
            if (api != NONE && api != USER_GROUP)
            {
                fBadArg = TRUE;
                break;
            }
            api = USER_GROUP;
            fBadArg = !ParseGroupSwitch(argv[idxArg], pflUserGroup);
            break;

        case 'h':
        case 'H':
            if (api != NONE && api != USER_GROUP)
            {
                fBadArg = TRUE;
                break;
            }
            api = USER_GROUP;
            *pflUserGroup |= UGOP_INCLUDE_HIDDEN;
            break;

        case 'i':
        case 'I':
            fBadArg = !ParseInitialScope(argv[idxArg], &flInitialScope);
            break;

        case 'm':
        case 'M':
            flObjectPicker |= OP_MULTISELECT;
            break;

        case 'n':
        case 'N':
            flDsObjectPicker |= DSOP_RESTRICT_NAMES_TO_KNOWN_DOMAINS;
            break;

        case 'p':
        case 'P':
            fBadArg = !ParseProviders(argv[idxArg],
                                      &cAcceptableProviders,
                                      &aptzAcceptableProviders);
            break;

        case 'r':
        case 'R':
            fBadArg = !ParseRunCount(argv[idxArg], &cInvocations);
            break;

        case 's':
        case 'S':
            fBadArg = !ParseScope(argv[idxArg],
                                  &flDsObjectPicker,
                                  wzComputer,
                                  wzDomain);
            break;

        case 'u':
        case 'U':
            if (api == COMPUTER)
            {
                fBadArg = TRUE;
                break;
            }
            api = USER_GROUP;
            fBadArg = !ParseUserSwitch(argv[idxArg], pflUserGroup);
            break;

        case 'x':
        case 'X':
            flDsObjectPicker |= DSOP_CONVERT_EXTERNAL_PATHS_TO_SID;
            break;

        default:
            fBadArg = TRUE;
            break;
        }
    }

    if (fBadArg || api == NONE)
    {
        Usage();
        return;
    }

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        printf("CoInitializeEx - 0x%x\n", hr);
        return;
    }

    //
    // Call the API
    //

    PDSSELECTIONLIST    pDsSelList = NULL;

    if (api == USER_GROUP)
    {
        GETUSERGROUPSELECTIONINFO ugsi;

        ZeroMemory(&ugsi, sizeof ugsi);
        ugsi.cbSize = sizeof(ugsi);
        ugsi.ptzComputerName = *wzComputer ? wzComputer : NULL;
        ugsi.ptzDomainName = *wzDomain ? wzDomain : NULL;
        ugsi.flObjectPicker = flObjectPicker;
        ugsi.flDsObjectPicker = flDsObjectPicker;
        ugsi.flStartingScope = flInitialScope;
        ugsi.flUserGroupObjectPickerSpecifiedDomain =
            flUserGroupObjectPickerSpecifiedDomain;
        ugsi.flUserGroupObjectPickerOtherDomains =
            flUserGroupObjectPickerOtherDomains;
        ugsi.ppDsSelList = &pDsSelList;
        ugsi.cAcceptableProviders = cAcceptableProviders;
        ugsi.aptzAcceptableProviders = aptzAcceptableProviders;
        ugsi.cRequestedAttributes = cRequestedAttributes;
        ugsi.aptzRequestedAttributes = aptzRequestedAttributes;

        for (ULONG i = 0; i < cInvocations; i++)
        {
            hr = GetUserGroupSelection(&ugsi);

            if (hr == S_FALSE)
            {
                printf("Invocation %u: User/Group picker dialog cancelled\n", i);
            }
            else if (SUCCEEDED(hr))
            {
                DumpDsSelectedItemList(pDsSelList,
                                       cRequestedAttributes,
                                       aptzRequestedAttributes);
            }
            else
            {
                printf("Invocation %u: User/Group picker dialog failed 0x%x\n", i, hr);
            }

            FreeDsSelectionList(pDsSelList);
            pDsSelList = NULL;
        }
    }
    else if (api == COMPUTER)
    {
        GETCOMPUTERSELECTIONINFO csi;

        ZeroMemory(&csi, sizeof csi);
        csi.cbSize = sizeof(csi);
        csi.ptzComputerName = *wzComputer ? wzComputer : NULL;
        csi.ptzDomainName = *wzDomain ? wzDomain : NULL;
        csi.flObjectPicker = flObjectPicker;
        csi.flDsObjectPicker = flDsObjectPicker;
        csi.flStartingScope = flInitialScope;
        csi.flComputerObjectPicker = flComputerObjectPicker;
        csi.ppDsSelList = &pDsSelList;
        csi.cAcceptableProviders = cAcceptableProviders;
        csi.aptzAcceptableProviders = aptzAcceptableProviders;
        csi.cRequestedAttributes = cRequestedAttributes;
        csi.aptzRequestedAttributes = aptzRequestedAttributes;

        for (ULONG i = 0; i < cInvocations; i++)
        {
            hr = GetComputerSelection(&csi);

            if (hr == S_FALSE)
            {
                printf("Invocation %u: Computer picker dialog cancelled\n", i);
            }
            else if (SUCCEEDED(hr))
            {
                DumpDsSelectedItemList(pDsSelList,
                                       cRequestedAttributes,
                                       aptzRequestedAttributes);
            }
            else
            {
                printf("Invocation %u: Computer picker dialog failed 0x%x\n", i, hr);
            }

            FreeDsSelectionList(pDsSelList);
            pDsSelList = NULL;
        }
    }
    else
    {
        printf("unexpected api setting\n");
    }

    CoUninitialize();
}


LPWSTR apwzAttr[100];

BOOL
ParseFetchSwitch(
    char *pzFetchSwitch,
    PULONG pcRequestedAttributes,
    LPCTSTR **paptzRequestedAttributes)
{
    BOOL fOk = TRUE;

    pzFetchSwitch += 2; // advance past '/' (or '-') and 'G'

    if (*pzFetchSwitch != ':')
    {
        printf("expected : after /Fetch\n");
        return FALSE;
    }

    *pcRequestedAttributes = 0;
    *paptzRequestedAttributes = NULL;

    ULONG cRequestedAttributes = 0;

    for (pzFetchSwitch++; *pzFetchSwitch && fOk; pzFetchSwitch++)
    {
        if (*pzFetchSwitch == ',')
        {
            continue;
        }

        PSTR pzComma = strchr(pzFetchSwitch, ',');

        if (pzComma)
        {
            *pzComma = '\0';
        }

        ULONG cchFetchSwitch = strlen(pzFetchSwitch) + 1;

        // BUGBUG this is leaked.  (who cares?)
        apwzAttr[cRequestedAttributes] = new WCHAR[cchFetchSwitch];
        if (!apwzAttr[cRequestedAttributes])
        {
            printf("out of memory\n");
            return FALSE;
        }
        AnsiToUnicode(apwzAttr[cRequestedAttributes],
                      pzFetchSwitch,
                      cchFetchSwitch);
        cRequestedAttributes++;

        if (pzComma)
        {
            *pzComma = ',';
            pzFetchSwitch = pzComma;
        }
        else
        {
            pzFetchSwitch += strlen(pzFetchSwitch) - 1;
        }
    }

    if (cRequestedAttributes && fOk)
    {
        *pcRequestedAttributes = cRequestedAttributes;
        *paptzRequestedAttributes = (LPCTSTR *)apwzAttr;
    }

    return fOk;
}




BOOL
ParseGroupSwitch(
    char *pzGroupSwitch,
    ULONG *pulFlags)
{
    BOOL fOk = TRUE;

    pzGroupSwitch += 2; // advance past '/' (or '-') and 'G'

    if (*pzGroupSwitch != ':')
    {
        printf("expected : after /Groups\n");
        return FALSE;
    }

    for (pzGroupSwitch++; *pzGroupSwitch && fOk; pzGroupSwitch++)
    {
        if (*pzGroupSwitch == ',')
        {
            continue;
        }

        PSTR pzComma = strchr(pzGroupSwitch, ',');

        if (pzComma)
        {
            *pzComma = '\0';
        }

        BOOL fMatch = FALSE;

        if (!lstrcmpiA(pzGroupSwitch, "all"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_ALL_GROUPS;
        }

        if (pzComma)
        {
            *pzComma = ',';
        }

        if (fMatch)
        {
            if (pzComma)
            {
                pzGroupSwitch = pzComma;
            }
            else
            {
                pzGroupSwitch += strlen(pzGroupSwitch) - 1;
            }
            continue;
        }

        switch (tolower(*pzGroupSwitch))
        {
        case 'u':
            if (tolower(pzGroupSwitch[1]) == 's')
            {
                *pulFlags |= UGOP_UNIVERSAL_GROUPS_SE;
                pzGroupSwitch++;
            }
            else
            {
                *pulFlags |= UGOP_UNIVERSAL_GROUPS;
            }
            break;

        case 'a':
            if (tolower(pzGroupSwitch[1]) == 's')
            {
                *pulFlags |= UGOP_ACCOUNT_GROUPS_SE;
                pzGroupSwitch++;
            }
            else
            {
                *pulFlags |= UGOP_ACCOUNT_GROUPS;
            }
            break;

        case 'r':
            if (tolower(pzGroupSwitch[1]) == 's')
            {
                *pulFlags |= UGOP_RESOURCE_GROUPS_SE;
                pzGroupSwitch++;
            }
            else
            {
                *pulFlags |= UGOP_RESOURCE_GROUPS;
            }
            break;

        case 'l':
            *pulFlags |= UGOP_LOCAL_GROUPS;
            break;

        case 'g':
            *pulFlags |= UGOP_GLOBAL_GROUPS;
            break;

        case 'b':
            *pulFlags |= UGOP_BUILTIN_GROUPS;
            break;

        case 'w':
            *pulFlags |= UGOP_WELL_KNOWN_PRINCIPALS_USERS;
            break;

        default:
            fOk = FALSE;
            printf("unexpected character '%c' in group type switch\n",
                   *pzGroupSwitch);
            break;
        }
    }
    printf("flags = 0x%x\n", *pulFlags);
    return fOk;
}




BOOL
ParseUserSwitch(
    char *pzUserSwitch,
    ULONG *pulFlags)
{
    BOOL fOk = TRUE;

    pzUserSwitch += 2; // advance past '/' (or '-') and 'U'

    if (*pzUserSwitch != ':')
    {
        printf("expected : after /Users\n");
        return FALSE;
    }

    for (pzUserSwitch++; *pzUserSwitch && fOk; pzUserSwitch++)
    {
        if (*pzUserSwitch == ',')
        {
            continue;
        }

        PSTR pzComma = strchr(pzUserSwitch, ',');

        if (pzComma)
        {
            *pzComma = '\0';
        }

        BOOL fMatch = FALSE;

        if (!lstrcmpiA(pzUserSwitch, "all"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_ALL_USERS;
        }
        else if (!lstrcmpiA(pzUserSwitch, "world"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_WORLD;
        }
        else if (!lstrcmpiA(pzUserSwitch, "authenticated"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_AUTHENTICATED_USER;
        }
        else if (!lstrcmpiA(pzUserSwitch, "anonymous"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_ANONYMOUS;
        }
        else if (!lstrcmpiA(pzUserSwitch, "dialup"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_DIALUP;
        }
        else if (!lstrcmpiA(pzUserSwitch, "network"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_NETWORK;
        }
        else if (!lstrcmpiA(pzUserSwitch, "Batch"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_BATCH;
        }
        else if (!lstrcmpiA(pzUserSwitch, "Interactive"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_INTERACTIVE;
        }
        else if (!lstrcmpiA(pzUserSwitch, "Service"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_SERVICE;
        }
        else if (!lstrcmpiA(pzUserSwitch, "System"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_SYSTEM;
        }

        if (pzComma)
        {
            *pzComma = ',';
        }

        if (fMatch)
        {
            if (pzComma)
            {
                pzUserSwitch = pzComma;
            }
            else
            {
                pzUserSwitch += strlen(pzUserSwitch) - 1;
            }
            continue;
        }

        switch (tolower(*pzUserSwitch))
        {
        case 'u':
            *pulFlags |= UGOP_USERS;
            break;

        case 'c':
            *pulFlags |= UGOP_CONTACTS;
            break;

        default:
            fOk = FALSE;
            printf("unexpected character '%c' in user type switch\n",
                   *pzUserSwitch);
            break;
        }

        if (pzComma)
        {
            pzUserSwitch = pzComma;
        }
    }
    return fOk;
}




BOOL
ParseInitialScope(
    char *pzScopeSwitch,
    ULONG *pulFlags)
{
    PSTR pzCur = strchr(pzScopeSwitch, ':');

    if (!pzCur)
    {
        printf("expected : after /InitialScope switch\n");
        return FALSE;
    }

    // advance past colon

    pzCur++;

    switch (tolower(*pzCur))
    {
    case 'c':
        *pulFlags |= DSOP_SCOPE_SPECIFIED_MACHINE;
        break;

    case 'd':
        *pulFlags |= DSOP_SCOPE_SPECIFIED_DOMAIN;
        break;

    case 'g':
        *pulFlags |= DSOP_SCOPE_DIRECTORY;
        break;

    case 't':
        *pulFlags |= DSOP_SCOPE_DOMAIN_TREE;
        break;

    case 'x':
        *pulFlags |= DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS;
        break;

    default:
        printf("invalid /InitialScope switch\n");
        return FALSE;
    }

    return TRUE;
}




BOOL
ParseProviders(
    char *pzProviderSwitch,
    PULONG pcAcceptableProviders,
    LPCWSTR **paptzAcceptableProviders)
{
    BOOL fOk = TRUE;
    PSTR pzCur = strchr(pzProviderSwitch, ':');
    static LPCWSTR apwzProviders[3];

    *paptzAcceptableProviders = apwzProviders;

    if (!pzCur)
    {
        printf("expected : after /Providers switch\n");
        return FALSE;
    }

    ZeroMemory(apwzProviders, sizeof apwzProviders);

    // advance past colon

    pzCur++;
    while (*pzCur)
    {
        switch (tolower(*pzCur))
        {
        case 'w':
            apwzProviders[(*pcAcceptableProviders)++] = L"WinNT";
            break;

        case 'l':
            apwzProviders[(*pcAcceptableProviders)++] = L"LDAP";
            break;

        case 'g':
            apwzProviders[(*pcAcceptableProviders)++] = L"GC";
            break;

        default:
            printf("invalid provider switch\n");
            return FALSE;
        }

        for (; *pzCur && *pzCur != ','; pzCur++)
        {
        }

        if (*pzCur == ',')
        {
            pzCur++;
        }

        // ignore extras
        if (*pcAcceptableProviders == 3)
        {
            break;
        }
    }

    return fOk;
}




BOOL
ParseRunCount(
    char *pzRunCountSwitch,
    PULONG pcRunCount)
{
    PSTR pzCur = strchr(pzRunCountSwitch, ':');

    if (!pzCur)
    {
        printf("expected : after /Runcount switch\n");
        return FALSE;
    }

    *pcRunCount = (ULONG) atol(pzCur + 1);

    if (!*pcRunCount || *pcRunCount > 10)
    {
        printf("Invalid run count %u\n", *pcRunCount);
    }
    return TRUE;
}




BOOL
ParseScope(
    char *pzScopeSwitch,
    ULONG *pulFlags,
    PWSTR wzComputer,
    PWSTR wzDomain)
{
    PSTR pzCur = strchr(pzScopeSwitch, ':');

    if (!pzCur)
    {
        printf("expected : after /Scope switch\n");
        return FALSE;
    }

    // advance past colon

    pzCur++;

    while (*pzCur)
    {
        switch (tolower(*pzCur))
        {
        case 'c':
        {
            *pulFlags |= DSOP_SCOPE_SPECIFIED_MACHINE;

            // find '='

            for (PSTR pzEqual = pzCur;
                 *pzEqual && *pzEqual != ',' && *pzEqual != '=';
                 pzEqual++)
            {
            }

            if (*pzEqual == '=')
            {
                CHAR szTemp[MAX_PATH];

                strcpy(szTemp, pzEqual + 1);
                LPSTR pzComma = strchr(szTemp, ',');

                if (pzComma)
                {
                    *pzComma = '\0';
                }
                AnsiToUnicode(wzComputer, szTemp, MAX_PATH);
                pzCur = pzEqual + 1;
            }
            break;
        }

        case 'd':
        {
            *pulFlags |= DSOP_SCOPE_SPECIFIED_DOMAIN;

            for (PSTR pzEqual = pzCur;
                 *pzEqual && *pzEqual != ',' && *pzEqual != '=';
                 pzEqual++)
            {
            }

            if (*pzEqual == '=')
            {
                CHAR szTemp[MAX_PATH];
                LPSTR pzOpenQuote = strchr(pzEqual, '\'');

                if (!pzOpenQuote)
                {
                    printf("Expected single quote after = in domain spec\n");
                    return FALSE;
                }

                LPSTR pzCloseQuote = strchr(pzOpenQuote + 1, '\'');

                if (!pzCloseQuote)
                {
                    printf("Expected closing single quote after = in domain spec\n");
                    return FALSE;
                }

                CopyMemory(szTemp, pzOpenQuote + 1, pzCloseQuote - pzOpenQuote - 1);
                szTemp[pzCloseQuote - pzOpenQuote - 1] = '\0';
                AnsiToUnicode(wzDomain, szTemp, MAX_PATH);
                pzCur = pzCloseQuote + 1;
            }
            break;
        }

        case 'g':
            *pulFlags |= DSOP_SCOPE_DIRECTORY;
            break;

        case 't':
            *pulFlags |= DSOP_SCOPE_DOMAIN_TREE;
            break;

        case 'x':
            *pulFlags |= DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS;
            break;

        default:
            printf("invalid scope switch\n");
            return FALSE;
        }

        for (; *pzCur && *pzCur != ','; pzCur++)
        {
        }

        if (*pzCur == ',')
        {
            pzCur++;
        }
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   DumpDsSelectedItemList
//
//  Synopsis:   Dump the contents of the list of DS items the user selected
//              to the console.
//
//  Arguments:  [pDsSelList] - list of Ds items
//
//  History:    11-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
DumpDsSelectedItemList(
    PDSSELECTIONLIST pDsSelList,
    ULONG cRequestedAttributes,
    LPCTSTR *aptzRequestedAttributes)
{
    if (!pDsSelList)
    {
        printf("List is empty\n");
        return;
    }

    ULONG i;
    PDSSELECTION pCur = &pDsSelList->aDsSelection[0];

    for (i = 0; i < pDsSelList->cItems; i++, pCur++)
    {
        printf("Name:    %ws\n", pCur->pwzName);
        printf("Class:   %ws\n", pCur->pwzClass);
        printf("Path:    %ws\n", pCur->pwzADsPath);
        printf("UPN:     %ws\n", pCur->pwzUPN);

        for (ULONG j = 0; j < cRequestedAttributes; j++)
        {
            printf("Attr %02u: %ws = %ws\n",
                   j,
                   aptzRequestedAttributes[j],
                   VariantString(&pCur->pvarOtherAttributes[j]));
        }
        printf("\n");
    }
}



LPWSTR
VariantString(
    VARIANT *pvar)
{
    static WCHAR wzBuf[1024];

    wzBuf[0] = L'\0';

    switch (pvar->vt)
    {
    case VT_EMPTY:
        lstrcpy(wzBuf, L"VT_EMPTY");
        break;

    case VT_NULL:
        lstrcpy(wzBuf, L"VT_NULL");
        break;

    case VT_I2:
        wsprintf(wzBuf, L"%d", V_I2(pvar));
        break;

    case VT_I4:
        wsprintf(wzBuf, L"%d", V_I4(pvar));
        break;

    case VT_R4:
        wsprintf(wzBuf, L"%f", V_R4(pvar));
        break;

    case VT_R8:
        wsprintf(wzBuf, L"%f", V_R8(pvar));
        break;

    case VT_CY:
        wsprintf(wzBuf, L"$%f", V_CY(pvar));
        break;

    case VT_DATE:
        wsprintf(wzBuf, L"date %f", V_DATE(pvar));
        break;

    case VT_BSTR:
        if (V_BSTR(pvar))
        {
            wsprintf(wzBuf, L"'%ws'", V_BSTR(pvar));
        }
        else
        {
            lstrcpy(wzBuf, L"VT_BSTR NULL");
        }
        break;

    case VT_DISPATCH:
        wsprintf(wzBuf, L"VT_DISPATCH 0x%x", V_DISPATCH(pvar));
        break;

    case VT_UNKNOWN:
        wsprintf(wzBuf, L"VT_UNKNOWN 0x%x", V_UNKNOWN(pvar));
        break;

    case VT_ERROR:
    case VT_HRESULT:
        wsprintf(wzBuf, L"hr 0x%x", V_ERROR(pvar));
        break;

    case VT_BOOL:
        wsprintf(wzBuf, L"%s", V_BOOL(pvar) ? "TRUE" : "FALSE");
        break;

    case VT_VARIANT:
        wsprintf(wzBuf, L"variant 0x%x", V_VARIANTREF(pvar));
        break;

    case VT_DECIMAL:
        lstrcpy(wzBuf, L"VT_DECIMAL");
        break;

    case VT_I1:
        wsprintf(wzBuf, L"%d", V_I1(pvar));
        break;

    case VT_UI1:
        wsprintf(wzBuf, L"%u", V_UI1(pvar));
        break;

    case VT_UI2:
        wsprintf(wzBuf, L"%u", V_UI2(pvar));
        break;

    case VT_UI4:
        wsprintf(wzBuf, L"%u", V_UI4(pvar));
        break;

    case VT_I8:
        lstrcpy(wzBuf, L"VT_I8");
        break;

    case VT_UI8:
        lstrcpy(wzBuf, L"VT_UI8");
        break;

    case VT_INT:
        wsprintf(wzBuf, L"%d", V_INT(pvar));
        break;

    case VT_UINT:
        wsprintf(wzBuf, L"%u", V_UINT(pvar));
        break;

    case VT_VOID:
        lstrcpy(wzBuf, L"VT_VOID");
        break;

    case VT_UI1 | VT_ARRAY:
        VarArrayToStr(pvar, wzBuf, ARRAYLEN(wzBuf));
        break;

    case VT_PTR:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_RECORD:
    case VT_FILETIME:
    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_CLSID:
    case VT_BSTR_BLOB:
    default:
        wsprintf(wzBuf, L"VT 0x%x", V_VT(pvar));
        break;
    }
    return wzBuf;
}



void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf)
{
    ULONG i;
    LPWSTR pwzNext = wzBuf;
    LPWSTR pwzEnd = wzBuf + cchBuf;

    for (i = 0; i < pvar->parray->rgsabound[0].cElements && pwzNext < pwzEnd + 6; i++)
    {
        wsprintf(pwzNext, L"x%02x ", ((LPBYTE)(pvar->parray->pvData))[i]);
        pwzNext += lstrlen(pwzNext);
    }
}




VOID
Usage()
{
    printf("\n");
    printf("Usage: opt <switches>\n");
    printf("\n");
    printf("Switches are:\n");
    printf("    /Computers[:Api]\n");
    printf("       If API is specified, GetComputerSelection is called, otherwise\n");
    printf("       this means include computer objects in the query\n");
    printf("    /Domain:{S|O}\n");
    printf("       If S is specified, then any following /Users, /Groups, or\n");
    printf("       /Computers switches apply only to the specified domain scope.\n");
    printf("       Otherwise, those switches apply to all other scopes\n");
    printf("    /Fetch:<attr>[,<attr>]...\n");
    printf("       <attr> is the name of an attribute to retrieve\n");
    printf("    /Groups:<group-type>[,<group-type>]...\n");
    printf("       <group-type> is one of:\n");
    printf("        ALL - same as specifiying each of the following\n");
    printf("        U   - Universal\n");
    printf("        A   - Account\n");
    printf("        R   - Resource\n");
    printf("        US  - Universal Security Enabled\n");
    printf("        AS  - Account Security Enabled\n");
    printf("        RS  - Resource Security Enabled\n");
    printf("        L   - Local\n");
    printf("        G   - Global\n");
    printf("        B   - Builtin\n");
    printf("        W   - Well-Known Security Principals\n");
    printf("    /Hidden\n");
    printf("       Include objects hidden from address book.\n");
    printf("    /Initialscope:{Computer|Domain|Gc|Tree|Xternal}\n");
    printf("    /Multiselect\n");
    printf("    /Namerestrict - reject names in unknown domains\n");
    printf("    /Providers:<provider>[,<provider>]\n");
    printf("       <provider> is one of:\n");
    printf("        WINNT\n");
    printf("        LDAP\n");
    printf("        GC\n");
    printf("    /Runcount:<n>\n");
    printf("        <n> is number of times to invoke object picker\n");
    printf("    /Scopes:<scope-spec>[,<scope-spec>]...\n");
    printf("       <scope-spec> is one of:\n");
    printf("        Computer[=name]\n");
    printf("        Domain[='<domain-spec>']\n");
    printf("        Gc\n");
    printf("        Tree\n");
    printf("        Xternal\n");
    printf("       <domain-spec> is one of:\n");
    printf("        <path> - the ADs path of a DS namespace\n");
    printf("        <name> - the flat name of a downlevel domain\n");
    printf("    /Users:<user-type>[,<user-type>]...\n");
    printf("       <user-type> is one of:\n");
    printf("        ALL - same as specifying each of the following\n");
    printf("        U   - User\n");
    printf("        C   - Contact\n");
    printf("        WORLD\n");
    printf("        AUTHENTICATED\n");
    printf("        ANONYMOUS\n");
    printf("        DIALUP\n");
    printf("        NETWORK\n");
    printf("        BATCH\n");
    printf("        INTERACTIVE\n");
    printf("        SERVICE\n");
    printf("        SYSTEM\n");
    printf("    /Xternal - force conversion of external paths to SIDs\n");
    printf("\n");
    printf("You must specify the Scope switch and at least one of the Computers,\n");
    printf("Groups, or Users switches.\n");
    printf("The significant characters in the switches are shown in upper case.\n");
}



//+---------------------------------------------------------------------------
//
//  Function:   AnsiToUnicode
//
//  Synopsis:   Convert ANSI string [szFrom] to Unicode string in buffer
//              [pwszTo].
//
//  Arguments:  [pwszTo] - destination buffer
//              [szFrom] - source string
//              [cchTo]  - size of destination buffer, in WCHARS
//
//  Returns:    S_OK               - conversion succeeded
//              HRESULT_FROM_WIN32 - MultiByteToWideChar failed
//
//  Modifies:   *[pwszTo]
//
//  History:    10-29-96   DavidMun   Created
//
//  Notes:      The string in [pwszTo] will be NULL terminated even on
//              failure.
//
//----------------------------------------------------------------------------

HRESULT
AnsiToUnicode(
    LPWSTR pwszTo,
    LPCSTR szFrom,
    LONG   cchTo)
{
    HRESULT hr = S_OK;
    ULONG   cchWritten;

    cchWritten = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwszTo, cchTo);

    if (!cchWritten)
    {
        pwszTo[cchTo - 1] = L'\0';  // ensure NULL termination

        hr = HRESULT_FROM_WIN32(GetLastError());
        printf("AnsiToUnicode: MultiByteToWideChar hr=0x%x\n", hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\src\util.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       util.cxx
//
//  Contents:   Miscellaneous utility functions
//
//  History:    09-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define __THIS_FILE__   L"util"
#include <Sddl.h>

//+--------------------------------------------------------------------------
//
//  Function:   LoadStr
//
//  Synopsis:   Load string with resource id [ids] into buffer [wszBuf],
//              which is of size [cchBuf] characters.
//
//  Arguments:  [ids]        - string to load
//              [wszBuf]     - buffer for string
//              [cchBuf]     - size of buffer
//              [wszDefault] - NULL or string to use if load fails
//
//  Returns:    S_OK or error from LoadString
//
//  Modifies:   *[wszBuf]
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      If the load fails and no default is supplied, [wszBuf] is
//              set to an empty string.
//
//---------------------------------------------------------------------------

HRESULT
LoadStr(
    ULONG ids,
    PWSTR wszBuf,
    ULONG cchBuf,
    PCWSTR wszDefault)
{
    HRESULT hr = S_OK;
    ULONG cchLoaded;

    cchLoaded = LoadString(g_hinst, ids, wszBuf, cchBuf);

    if (!cchLoaded)
    {
        DBG_OUT_LASTERROR;
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (wszDefault)
        {
            // NTRAID#NTBUG9-548215-2002/02/19-lucios. Pending fix.    
            lstrcpyn(wszBuf, wszDefault, cchBuf);
        }
        else
        {
            *wszBuf = L'\0';
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   NewDupStr
//
//  Synopsis:   Allocate a copy of [wszSrc] using operator new.
//
//  Arguments:  [ppwzDup] - filled with pointer to copy of [wszSrc].
//              [wszSrc]  - string to copy
//
//  Modifies:   *[ppwzDup]
//
//  History:    10-15-1997   DavidMun   Created
//
//  Notes:      Caller must delete string
//
//---------------------------------------------------------------------------


void
NewDupStr(
    PWSTR *ppwzDup,
    PCWSTR wszSrc)
{
    if (wszSrc)
    {
        *ppwzDup = new WCHAR[wcslen(wszSrc) + 1];
        wcscpy(*ppwzDup, wszSrc);
    }
    else
    {
        *ppwzDup = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   CoTaskDupStr
//
//  Synopsis:   Allocate a copy of [wzSrc] using CoTaskMemAlloc.
//
//  Arguments:  [ppwzDup] - filled with pointer to copy of [wszSrc].
//              [wszSrc]  - string to copy
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppwzDup]
//
//  History:    06-03-1998   DavidMun   Created
//
//  Notes:      Caller must CoTaskMemFree string
//
//---------------------------------------------------------------------------

HRESULT
CoTaskDupStr(
    PWSTR *ppwzDup,
    PCWSTR wzSrc)
{
    HRESULT hr = S_OK;

    *ppwzDup = (PWSTR) CoTaskMemAlloc(sizeof(WCHAR) *
                                            (lstrlen(wzSrc) + 1));

    if (*ppwzDup)
    {
        //REVIEWED-2002-02-23-lucios.
        lstrcpy(*ppwzDup, wzSrc);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   UnicodeStringToWsz
//
//  Synopsis:   Copy the string in [refustr] to the buffer [wszBuf],
//              truncating if necessary and ensuring null termination.
//
//  Arguments:  [refustr] - string to copy
//              [wszBuf]  - destination buffer
//              [cchBuf]  - size, in characters, of destination buffer.
//
//  Modifies:   *[wszBuf]
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
UnicodeStringToWsz(
    const UNICODE_STRING &refustr,
    PWSTR wszBuf,
    ULONG cchBuf)
{
    if (!refustr.Length)
    {
        wszBuf[0] = L'\0';
    }
    else if (refustr.Length < cchBuf * sizeof(WCHAR))
    {
        //REVIEWED-2002-02-23-lucios.
        CopyMemory(wszBuf, refustr.Buffer, refustr.Length);
        wszBuf[refustr.Length / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        // NTRAID#NTBUG9-548215-2002/02/19-lucios. Pending fix.    
        lstrcpyn(wszBuf, refustr.Buffer, cchBuf);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   StripLeadTrailSpace
//
//  Synopsis:   Delete leading and trailing spaces from [pwz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

void
StripLeadTrailSpace(
    PWSTR pwz)
{
    size_t cchLeadingSpace = _tcsspn(pwz, TEXT(" \t"));
    size_t cch = lstrlen(pwz);

    //
    // If there are any leading spaces or tabs, move the string
    // (including its nul terminator) left to delete them.
    //
    
    //REVIEWED-2002-02-23-lucios.
    if (cchLeadingSpace)
    {
        MoveMemory(pwz,
                   pwz + cchLeadingSpace,
                   (cch - cchLeadingSpace + 1) * sizeof(TCHAR));
        cch -= cchLeadingSpace;
    }

    //
    // Truncate at the first trailing space
    //

    LPTSTR pwzTrailingSpace = NULL;
    LPTSTR pwzCur;

    for (pwzCur = pwz; *pwzCur; pwzCur++)
    {
        if (*pwzCur == L' ' || *pwzCur == L'\t')
        {
            if (!pwzTrailingSpace)
            {
                pwzTrailingSpace = pwzCur;
            }
        }
        else if (pwzTrailingSpace)
        {
            pwzTrailingSpace = NULL;
        }
    }

    if (pwzTrailingSpace)
    {
        *pwzTrailingSpace = TEXT('\0');
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   InvokeWinHelp
//
//  Synopsis:   Helper (ahem) function to invoke winhelp.
//
//  Arguments:  [message]                 - WM_CONTEXTMENU or WM_HELP
//              [wParam]                  - depends on [message]
//              [wszHelpFileName]         - filename with or without path
//              [aulControlIdToHelpIdMap] - see WinHelp API
//
//  History:    06-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
InvokeWinHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PCWSTR wszHelpFileName,
    ULONG aulControlIdToHelpIdMap[])
{
    TRACE_FUNCTION(InvokeWinHelp);

    ASSERT(wszHelpFileName);
    ASSERT(aulControlIdToHelpIdMap);

    switch (message)
    {
    case WM_CONTEXTMENU:                // Right mouse click - "What's This" context menu
                WinHelp((HWND) wParam,
                wszHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR) aulControlIdToHelpIdMap);
        break;

        case WM_HELP:                           // Help from the "?" dialog
    {
        const LPHELPINFO pHelpInfo = (LPHELPINFO) lParam;

        if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
        {
            WinHelp((HWND) pHelpInfo->hItemHandle,
                    wszHelpFileName,
                    HELP_WM_HELP,
                    (DWORD_PTR) aulControlIdToHelpIdMap);
        }
        break;
    }

    default:
        Dbg(DEB_ERROR, "Unexpected message %uL\n", message);
        break;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   SetDefaultColumns
//
//  Synopsis:   Add the default ATTR_KEY values to [pvakListviewColumns]
//              for all the classes selected in look for.
//
//  Arguments:  [hwnd]                - for bind
//              [rop]                 - object picker
//              [pvakListviewColumns] - attributes added to this
//
//  History:    06-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
SetDefaultColumns(
    HWND hwnd,
    const CObjectPicker &rop,
    AttrKeyVector *pvakListviewColumns)
{
    const CAttributeManager &ram = rop.GetAttributeManager();
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG ulSelectedFilters = rfm.GetCurScopeSelectedFilterFlags();
    ASSERT(ulSelectedFilters);

    AddIfNotPresent(pvakListviewColumns, AK_NAME);

    if (ulSelectedFilters & DSOP_FILTER_USERS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzUserObjectClass);
        if(ram.IsAttributeLoaded(AK_SAMACCOUNTNAME))
            AddIfNotPresent(pvakListviewColumns, AK_SAMACCOUNTNAME);
        if(ram.IsAttributeLoaded(AK_EMAIL_ADDRESSES))
            AddIfNotPresent(pvakListviewColumns, AK_EMAIL_ADDRESSES);
    }

    if (ulSelectedFilters & ALL_UPLEVEL_GROUP_FILTERS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzGroupObjectClass);
        if(ram.IsAttributeLoaded(AK_DESCRIPTION))
            AddIfNotPresent(pvakListviewColumns, AK_DESCRIPTION);
    }

    if (ulSelectedFilters & DSOP_FILTER_COMPUTERS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzComputerObjectClass);
        if(ram.IsAttributeLoaded(AK_DESCRIPTION))
            AddIfNotPresent(pvakListviewColumns, AK_DESCRIPTION);
    }

    if (ulSelectedFilters & DSOP_FILTER_CONTACTS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzContactObjectClass);
        if(ram.IsAttributeLoaded(AK_EMAIL_ADDRESSES))
            AddIfNotPresent(pvakListviewColumns, AK_EMAIL_ADDRESSES);
        if(ram.IsAttributeLoaded(AK_COMPANY))
            AddIfNotPresent(pvakListviewColumns, AK_COMPANY);
    }

    AddIfNotPresent(pvakListviewColumns, AK_DISPLAY_PATH);
}

//>>
String
GetClassName(const CObjectPicker &rop)
{
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG ulSelectedFilters = rfm.GetCurScopeSelectedFilterFlags();
    ASSERT(ulSelectedFilters);


    if (ulSelectedFilters & DSOP_FILTER_USERS)
    {
        return c_wzUserObjectClass;
    }

    if (ulSelectedFilters & ALL_UPLEVEL_GROUP_FILTERS)
    {
        return c_wzGroupObjectClass;
    }

    if (ulSelectedFilters & DSOP_FILTER_COMPUTERS)
    {
        return c_wzComputerObjectClass;
    }

    if (ulSelectedFilters & DSOP_FILTER_CONTACTS)
    {
        return c_wzContactObjectClass;
    }

    return L"*";
}
//+--------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Wide character case insensitive substring search.
//
//  Arguments:  [pwzSearchIn]  - string to look in
//              [pwzSearchFor] - substring to look for
//
//  Returns:    Pointer to first occurence of [pwzSearchFor] within
//              [pwzSearchIn], or NULL if none found.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

PWSTR
wcsistr(
    PCWSTR pwzSearchIn,
    PCWSTR pwzSearchFor)
{
    PCWSTR pwzSearchInCur;
    PCWSTR pwzSearchForCur = pwzSearchFor;

    //
    // Handle special case of search for string empty by returning
    // pointer to end of search in string.
    //

    if (!*pwzSearchFor)
    {
        return (PWSTR) (pwzSearchIn + lstrlen(pwzSearchIn));
    }

    //
    // pwzSearchFor is at least one character long.
    //

    for (pwzSearchInCur = pwzSearchIn; *pwzSearchInCur; pwzSearchInCur++)
    {
        //
        // If current char of both strings matches, advance in search
        // for string.
        //

        if (towlower(*pwzSearchInCur) == towlower(*pwzSearchForCur))
        {
            pwzSearchForCur++;

            //
            // If we just hit the end of the substring we're searching
            // for, then we've found a match.  The start of the match
            // is at the current location of the search in pointer less
            // the length of the substring we just matched, plus 1 since
            // we haven't advanced pwzSearchInCur past the last matching
            // character yet.
            //

            if (!*pwzSearchForCur)
            {
                return (PWSTR)(pwzSearchInCur - lstrlen(pwzSearchFor) + 1);
            }
        }
        else
        {
            //
            // Mismatch, start searching from the beginning of
            // the search for string again.
            //

            pwzSearchForCur = pwzSearchFor;
        }
    }

    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Function:   AllocateQueryInfo
//
//  Synopsis:   Create a new empty query info, and put a pointer to it in
//              *[ppdsqi].
//
//  Arguments:  [ppdsqi] - receives pointer to new query info.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Modifies:   *[ppdsqi]
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
AllocateQueryInfo(
    PDSQUERYINFO *ppdsqi)
{
    HRESULT hr = S_OK;

    *ppdsqi = (PDSQUERYINFO) CoTaskMemAlloc(sizeof DSQUERYINFO);

    if (!*ppdsqi)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    ZeroMemory(*ppdsqi, sizeof DSQUERYINFO);

    (*ppdsqi)->cbSize = sizeof(DSQUERYINFO);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsi
//
//  Synopsis:   Convert unicode string [pwsz] to multibyte in buffer [sz].
//
//  Arguments:  [szTo]     - destination buffer
//              [pwszFrom] - source string
//              [cbTo]     - size of destination buffer, in bytes
//
//  Returns:    S_OK               - conversion succeeded
//              HRESULT_FROM_WIN32 - WideCharToMultiByte failed
//
//  Modifies:   *[szTo]
//
//  History:    10-29-96   DavidMun   Created
//
//  Notes:      The string in [szTo] will be NULL terminated even on
//              failure.
//
//----------------------------------------------------------------------------

HRESULT
UnicodeToAnsi(
    LPSTR   szTo,
    LPCWSTR pwszFrom,
    ULONG   cbTo)
{
    HRESULT hr = S_OK;
    ULONG   cbWritten;

    cbWritten = WideCharToMultiByte(CP_ACP,
                                    0,
                                    pwszFrom,
                                    -1,
                                    szTo,
                                    cbTo,
                                    NULL,
                                    NULL);

    if (!cbWritten)
    {
        szTo[cbTo - 1] = '\0'; // ensure NULL termination

        hr = HRESULT_FROM_WIN32(GetLastError());
        Dbg(DEB_ERROR, "UnicodeToAnsi: WideCharToMultiByte hr=0x%x\n", hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   FreeQueryInfo
//
//  Synopsis:   Free all resources associated with [pdsqi].
//
//  Arguments:  [pdsqi] - NULL or pointer to query info.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

void
FreeQueryInfo(
    PDSQUERYINFO pdsqi)
{
    if (!pdsqi)
    {
        return;
    }

    ASSERT((ULONG_PTR)pdsqi->pwzLdapQuery != 1);

    CoTaskMemFree((void *)pdsqi->pwzLdapQuery);
    CoTaskMemFree((void *)pdsqi->apwzFilter);
    CoTaskMemFree((void *)pdsqi->pwzCaption);
    CoTaskMemFree((void *)pdsqi);
}




//+--------------------------------------------------------------------------
//
//  Function:   ProviderFlagFromPath
//
//  Synopsis:   Return a PROVIDER_* flag describing the ADSI provider used
//              by [strADsPath].
//
//  History:    09-14-1998   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
ProviderFlagFromPath(
    const String &strADsPath,
    ULONG *pulProvider)
{
    HRESULT hr = S_OK;

    String strProvider = strADsPath;
    size_t idxColon = strProvider.find(L':');
        ASSERT(idxColon != String::npos);
        strProvider.erase(idxColon);
    ULONG flPathProvider = PROVIDER_UNKNOWN;

    if (!cmpNoCase(strProvider.c_str(), L"LDAP"))
    {
        flPathProvider = PROVIDER_LDAP;
    }
    else if (!cmpNoCase(strProvider.c_str(), L"WinNT"))
    {
        flPathProvider = PROVIDER_WINNT;
    }
    else if (!cmpNoCase(strProvider.c_str(), L"GC"))
    {
        flPathProvider = PROVIDER_GC;
    }
    else
    {
        hr = E_UNEXPECTED;
        Dbg(DEB_ERROR,
            "ProviderFlagFromPath: Unknown provider '%ws'",
            strProvider.c_str());
        ASSERT(!"Unknown provider");
    }

    *pulProvider = flPathProvider;
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   MessageWait
//
//  Synopsis:   Wait on the [cObjects] handles in [aObjects] for a maximum
//              of [ulTimeout] ms, processing paint, posted, and sent messages
//              during the wait.
//
//  Arguments:  [cObjects]  - number of handles in [aObjects]
//              [aObjects]  - array of handles to wait on
//              [ulTimeout] - max time to wait (can be INFINITE)
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

void
MessageWait(
    ULONG cObjects,
    const HANDLE *aObjects,
    ULONG ulTimeout)
{
    TRACE_FUNCTION(MessageWait);
    ULONG ulWaitResult;

    while (TRUE)
    {
        //
        // CAUTION: the allowable messages (QS_* flags) MUST MATCH the
        // message filter passed to PeekMessage (PM_QS_*), else an infinite
        // loop will occur!
        //

        ulWaitResult = MsgWaitForMultipleObjects(cObjects,
                                                 aObjects,
                                                 FALSE,
                                                 ulTimeout,
                                                 QS_POSTMESSAGE
                                                 | QS_PAINT
                                                 | QS_SENDMESSAGE);


        if (ulWaitResult == WAIT_OBJECT_0)
        {
            Dbg(DEB_TRACE, "MessageWait: object signaled\n");
            break;
        }

        if (ulWaitResult == WAIT_OBJECT_0 + cObjects)
        {
            MSG msg;

            BOOL fMsgAvail = PeekMessage(&msg,
                                         NULL,
                                         0,
                                         0,
                                         PM_REMOVE
                                         | PM_QS_POSTMESSAGE
                                         | PM_QS_PAINT
                                         | PM_QS_SENDMESSAGE);

            if (fMsgAvail)
            {
                Dbg(DEB_TRACE, "MessageWait: Translate/dispatch\n");
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                //Dbg(DEB_TRACE, "MessageWait: Ignoring new message\n");
            }
        }
        else
        {
            Dbg(DEB_ERROR,
                "MsgWaitForMultipleObjects <%uL>\n",
                ulWaitResult);
            break;
        }
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   GetPolicySettings
//
//  Synopsis:   Fill *[pcMaxHits] with the maximum number of objects that
//              should appear in the browse listview, and *[pfExcludeDisabled]
//              with a flag indicating whether disabled objects are illegal.
//
//  Arguments:  [pcMaxHits] - filled with query limit
//              [pfExcludeDisabled] - filled with flag indicating whether
//                                      disabled objects should be treated
//                                      as illegal
//
//  Modifies:   *[pcMaxHits], *[pfExcludeDisabled]
//
//  History:    03-12-1999   DavidMun   Created
//              11-23-1999   DavidMun   Add ExcludeDisabledObjects
//              2002-05-10   ArtM       Made HKLM have precedence over HKLU (NTRAID#NTBUG9-572243)
//
//  Notes:      Key:   HKCU\Software\Policies\Microsoft\Windows\Directory UI
//              Value: QueryLimit (DWORD)
//              Value: ExcludeDisabledObjects (DWORD)
//
//              Key:   HKLM\Software\Policies\Microsoft\Windows\Directory UI
//              Value: QueryLimit (DWORD) (NTRAID#NTBUG9-490947-2001/11/06-lucios)
//              Value: ExcludeDisabledObjects (DWORD)
//
//---------------------------------------------------------------------------

void
GetPolicySettings(
    ULONG *pcMaxHits,
    BOOL  *pfExcludeDisabled)
{
    TRACE_FUNCTION(GetPolicySettings);
    ASSERT(!IsBadWritePtr(pcMaxHits, sizeof(*pcMaxHits)));
    ASSERT(!IsBadWritePtr(pfExcludeDisabled, sizeof(*pfExcludeDisabled)));

    if (!pcMaxHits || !pfExcludeDisabled)
    {
        // should never happen, o'wise we'd have to change the function
        // to return an error code
        return;
    }

    HRESULT     hr = S_OK;
    CSafeReg    shkPolicy;

    // Use flag to track if we've read a value from the registry, since the value
    // read may be the same as the default value.

    bool fUsingLimitDefault = true;
    *pcMaxHits              = MAX_QUERY_HITS_DEFAULT;

    bool fUsingExcludeDefault = true;
    *pfExcludeDisabled        = EXCLUDE_DISABLED_DEFAULT;

    hr = shkPolicy.Open(HKEY_LOCAL_MACHINE,
                        c_wzPolicyKeyPath,
                        STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);

    if (SUCCEEDED(hr))
    {
        hr = shkPolicy.QueryDword((PWSTR)c_wzQueryLimitValueName, pcMaxHits);

        if (SUCCEEDED(hr))
        {
            fUsingLimitDefault = false;
        }

        hr = shkPolicy.QueryDword((PWSTR)c_wzExcludeDisabled,
                                  (PULONG)pfExcludeDisabled);

        if (SUCCEEDED(hr))
        {
            fUsingExcludeDefault = false;
        }
    }

    shkPolicy.Close();

    // If we did not read one of the values from HKLM, try
    // reading the value from HKCU.
    if (fUsingExcludeDefault || fUsingLimitDefault)
    {
        hr = shkPolicy.Open(HKEY_CURRENT_USER,
                            c_wzPolicyKeyPath,
                            STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);

        if (SUCCEEDED(hr))
        {
            if (fUsingExcludeDefault)
            {
                hr = shkPolicy.QueryDword((PWSTR)c_wzExcludeDisabled,
                                          (PULONG)pfExcludeDisabled);
            }

            if (fUsingLimitDefault)
            {
                hr = shkPolicy.QueryDword((PWSTR)c_wzQueryLimitValueName,
                                          (PULONG)pcMaxHits);
            }
        }

        shkPolicy.Close();
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   IsDisabled
//
//  Synopsis:   Return TRUE if the object with interface [pADs] has the
//              UF_ACCOUNTDISABLE flag set in either its userAccountControl
//              (LDAP) or UserFlags (WinNT) attribute.
//
//  Arguments:  [pADs] - object to check
//
//  Returns:    TRUE or FALSE.  Returns FALSE if attributes not found.
//
//  History:    09-24-1999   davidmun   Created
//
//---------------------------------------------------------------------------

BOOL
IsDisabled(
    IADs *pADs)
{
    Variant varUAC;
    BOOL    fDisabled = FALSE;
    HRESULT hr = S_OK;

    hr = pADs->Get(AutoBstr(c_wzUserAcctCtrlAttr), &varUAC);

    if (SUCCEEDED(hr))
    {
        fDisabled = V_I4(&varUAC) & UF_ACCOUNTDISABLE;
    }
    else
    {
        hr = pADs->Get(AutoBstr(c_wzUserFlagsAttr), &varUAC);

        if (SUCCEEDED(hr))
        {
            fDisabled = V_I4(&varUAC) & UF_ACCOUNTDISABLE;
        }
    }
    return fDisabled;
}




//+--------------------------------------------------------------------------
//
//  Function:   IsLocalComputername
//
//  Synopsis:   Return TRUE if [pwzComputerName] represents the local
//              machine
//
//  Arguments:  [pwzComputerName] - name to check or NULL
//
//  Returns:    TRUE if [pwzComputerName] is NULL, an empty string, or
//              the name of the local computer.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsLocalComputername(
    PCWSTR pwzComputerName)
{
    TRACE_FUNCTION(IsLocalComputername);

    static WCHAR s_wzComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    static WCHAR s_wzDnsComputerName[DNS_MAX_NAME_BUFFER_LENGTH];

    if (!pwzComputerName || !*pwzComputerName)
    {
        return TRUE;
    }

    if (L'\\' == pwzComputerName[0] && L'\\' == pwzComputerName[1])
    {
        pwzComputerName += 2;
    }

    // compare with the local computer name
    if (!*s_wzComputerName)
    {
        DWORD dwSize = ARRAYLEN(s_wzComputerName);
        // NTRAID#NTBUG9-550683-2002/02/19-lucios. Pending fix.
        VERIFY(GetComputerName(s_wzComputerName, &dwSize));
    }

    if (!lstrcmpi(pwzComputerName, s_wzComputerName))
    {
        return TRUE;
    }

    // compare with the local DNS name
    // SKwan confirms that ComputerNameDnsFullyQualified is the right name to use
    // when clustering is taken into account

    if (!*s_wzDnsComputerName)
    {
        DWORD dwSize = ARRAYLEN(s_wzDnsComputerName);

        // NTRAID#NTBUG9-550683-2002/02/19-lucios. Pending fix.
        VERIFY(GetComputerNameEx(ComputerNameDnsFullyQualified,
                                 s_wzDnsComputerName,
                                 &dwSize));
    }

    if (!lstrcmpi(pwzComputerName, s_wzDnsComputerName))
    {
        Dbg(DEB_TRACE, "returning TRUE\n");
        return TRUE;
    }

    Dbg(DEB_TRACE, "returning FALSE\n");
    return FALSE;
}


/*******************************************************************

    NAME:       LocalAllocSid

    SYNOPSIS:   Copies a SID

    ENTRY:      pOriginal - pointer to SID to copy

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:      Caller must free the returned SID with LocalFree

    HISTORY:
        JeffreyS    12-Apr-1999     Created
        Copied by hiteshr from ACLUI code base

********************************************************************/

PSID
LocalAllocSid(PSID pOriginal)
{
    PSID pCopy = NULL;
    if (pOriginal && IsValidSid(pOriginal))
    {
        DWORD dwLength = GetLengthSid(pOriginal);
        pCopy = (PSID)LocalAlloc(LMEM_FIXED, dwLength);
        if (NULL != pCopy)
            CopyMemory(pCopy, pOriginal, dwLength); //REVIEWED-2002-02-23-lucios.
    }
    return pCopy;
}

/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (wcslen(pString) + 1)*sizeof(WCHAR));

    if ( !*ppResult )
        return E_OUTOFMEMORY;

    //REVIEWED-2002-02-19-lucios.
    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success

}

/*******************************************************************

    NAME:       GetAuthenticationID

    SYNOPSIS:   Retrieves the UserName associated with the credentials
                currently being used for network access.
                (runas /netonly credentials)

    
    HISTORY:
        JeffreyS    05-Aug-1999     Created
        Modified by hiteshr to return credentials

********************************************************************/
NTSTATUS
GetAuthenticationID(LPWSTR *ppszResult)
{        
    HANDLE hLsa;
    NTSTATUS Status = 0;
    *ppszResult = NULL;
    //
    // These LSA calls are delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        Status = LsaConnectUntrusted(&hLsa);

        if (Status == 0)
        {
            NEGOTIATE_CALLER_NAME_REQUEST Req = {0};
            PNEGOTIATE_CALLER_NAME_RESPONSE pResp;
            ULONG cbSize =0;
            NTSTATUS SubStatus =0;

            Req.MessageType = NegGetCallerName;

            Status = LsaCallAuthenticationPackage(
                            hLsa,
                            0,
                            &Req,
                            sizeof(Req),
                            (void**)&pResp,
                            &cbSize,
                            &SubStatus);

            if ((Status == 0) && (SubStatus == 0))
            {
                // NTRAID#NTBUG9-553761-2002/02/19-lucios. 
                HRESULT hr=LocalAllocString(ppszResult,pResp->CallerName);
                if(FAILED(hr)) 
                {
                    Status=STATUS_UNSUCCESSFUL;
                }
                LsaFreeReturnBuffer(pResp);
            }

            LsaDeregisterLogonProcess(hLsa);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return Status;
    
}




//+--------------------------------------------------------------------------
//
//  Function:   IsCurrentUserLocalUser
//
//  Synopsis:   Return TRUE if the current user is a local machine user.
//
//  History:    08-15-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsCurrentUserLocalUser()
{
    TRACE_FUNCTION(IsCurrentUserLocalUser);

    BOOL  fUserIsLocal = FALSE;
    ULONG cchName;
    WCHAR wzComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    BOOL  fOk;
    LPWSTR pszUserName = NULL;    
    NTSTATUS Status = 0;
    do
    {
        Status = GetAuthenticationID(&pszUserName);
        if (!NT_SUCCESS(Status) || !pszUserName)
        {
            DBG_OUT_LRESULT(Status);
            break;
        }
        
        String strUserName(pszUserName);
        LocalFree(pszUserName);

        Dbg(DEB_TRACE, "NameSamCompatible of User is= %ws\n", strUserName.c_str());

        cchName = ARRAYLEN(wzComputerName);
        //REVIEWED-2002-02-23-lucios.
        fOk = GetComputerName(wzComputerName, &cchName);

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }


        strUserName.strip(String::BOTH, L'\\');

        size_t idxWhack = strUserName.find(L'\\');

        if (idxWhack != String::npos)
        {
            strUserName.erase(idxWhack);
        }

        String strComputerName(wzComputerName);
        strComputerName.strip(String::BOTH, L'\\');

        if (!strUserName.icompare(strComputerName))
        {
            fUserIsLocal = TRUE;
        }
    } while (0);

    Dbg(DEB_TRACE, "fUserIsLocal = %ws\n", fUserIsLocal ? L"TRUE" : L"FALSE");
    return fUserIsLocal;
}




//+--------------------------------------------------------------------------
//
//  Function:   DisableSystemMenuClose
//
//  Synopsis:   Disable the "Close" option on the system menu of window
//              [hwnd].
//
//  Arguments:  [hwnd] - window owning system menu
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
DisableSystemMenuClose(
    HWND hwnd)
{
    HMENU hmenuSystem = GetSystemMenu(hwnd, FALSE);
    ASSERT(IsMenu(hmenuSystem));

    MENUITEMINFO mii;

    ZeroMemory(&mii, sizeof mii);
    mii.cbSize = sizeof mii;
    mii.fMask = MIIM_STATE;
    mii.fState = MFS_DISABLED;

    SetMenuItemInfo(hmenuSystem, SC_CLOSE, FALSE, &mii);
}




//+--------------------------------------------------------------------------
//
//  Function:   AddStringToCombo
//
//  Synopsis:   Add the resource string with id [ids] to the combobox with
//              window handle [hwndCombo].
//
//  Arguments:  [hwndCombo] - window handle of combobox
//              [ids]       - resource id of string to add
//
//  Returns:    HRESULT
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
AddStringToCombo(
    HWND hwndCombo,
    ULONG ids)
{
    HRESULT hr = S_OK;

    String strRes = String::load((int)ids, g_hinst);
    int iRet = ComboBox_AddString(hwndCombo, strRes.c_str());

    if (iRet == CB_ERR)
    {
        DBG_OUT_LASTERROR;
        hr = HRESULT_FROM_LASTERROR;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   LdapEscape
//
//  Synopsis:   Escape the characters in *[pstrEscaped] as required by
//              RFC 2254.
//
//  Arguments:  [pstrEscaped] - string to escape
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      RFC 2254
//
//              If a value should contain any of the following characters
//
//                     Character       ASCII value
//                     ---------------------------
//                     *               0x2a
//                     (               0x28
//                     )               0x29
//                     \               0x5c
//                     NUL             0x00
//
//              the character must be encoded as the backslash '\'
//              character (ASCII 0x5c) followed by the two hexadecimal
//              digits representing the ASCII value of the encoded
//              character.  The case of the two hexadecimal digits is not
//              significant.
//
//---------------------------------------------------------------------------

void
LdapEscape(
    String *pstrEscaped)
{
    size_t i = 0;

    while (1)
    {
        i = pstrEscaped->find_first_of(L"*()\\", i);

        if (i == String::npos)
        {
            break;
        }

        PCWSTR pwzReplacement;

        switch ((*pstrEscaped)[i])
        {
        case L'*':
            pwzReplacement = L"\\2a";
            break;

        case L'(':
            pwzReplacement = L"\\28";
            break;

        case L')':
            pwzReplacement = L"\\29";
            break;

        case L'\\':
            pwzReplacement = L"\\5c";
            break;

        default:
            Dbg(DEB_ERROR, "find_first_of stopped at '%c'\n", (*pstrEscaped)[i]);
            ASSERT(0 && "find_first_of stopped at unexpected character");
            return;
        }

        //
        // replace the 1 character at position i with the first 3 characters
        // of pwzReplacement
        //

        // NTRAID#NTBUG9-503698-2002/02/04-lucios added ",1" to erase
        pstrEscaped->erase(i,1);

        pstrEscaped->insert(i, String(pwzReplacement));
        i += 3; // move past string just inserted
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   UpdateLookForInText
//
//  Synopsis:   Update the text in the look for and look in r/o edit
//              controls as well as the window caption.
//
//  Arguments:  [hwndDlg] - handle to dialog owning the controls to update
//              [rop]     - instance of object picker associated with the
//                            dialog.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
UpdateLookForInText(
    HWND hwndDlg,
    const CObjectPicker &rop)
{
    TRACE_FUNCTION(UpdateLookForInText);

    const CFilterManager &rfm = rop.GetFilterManager();
    const CScopeManager &rsm = rop.GetScopeManager();

    Edit_SetText(GetDlgItem(hwndDlg, IDC_LOOK_IN_EDIT),
                 rsm.GetCurScope().GetDisplayName().c_str());
    Edit_SetText(GetDlgItem(hwndDlg, IDC_LOOK_FOR_EDIT),
                 rfm.GetFilterDescription(hwndDlg, FOR_LOOK_FOR).c_str());
    SetWindowText(hwndDlg,
                  rfm.GetFilterDescription(hwndDlg, FOR_CAPTION).c_str());
}




//+--------------------------------------------------------------------------
//
//  Function:   AddFromDataObject
//
//  Synopsis:   Add the objects in [pdo] to the list in [pdsol].
//
//  Arguments:  [idScope]       - id of scope to own the objects added
//              [pdo]           - points to data object containing objects
//                                 to add
//              [pfnTestObject] - NULL or a pointer to a function which
//                                 is used to indicate whether each object
//                                 should be added to [pdsol]
//              [lParam]        - parameter for [pfnTestObject]
//              [pdsol]         - points to list to add objects to
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
AddFromDataObject(
    ULONG idScope,
    IDataObject *pdo,
    PFNOBJECTTEST pfnTestObject,
    LPARAM lParam,
    CDsObjectList *pdsol)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)CDataObject::s_cfDsSelectionList,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    hr = pdo->GetData(&formatetc, &stgmedium);

    if (FAILED(hr) || hr == S_FALSE)
    {
        CHECK_HRESULT(hr);
        return;
    }

    PDS_SELECTION_LIST pdssl =
        static_cast<PDS_SELECTION_LIST>(GlobalLock(stgmedium.hGlobal));

    ULONG i;

    for (i = 0; i < pdssl->cItems; i++)
    {
        if (pfnTestObject && !pfnTestObject(pdssl->aDsSelection[i], lParam))
        {
            continue;
        }

        SDsObjectInit sdi;

        sdi.idOwningScope       = idScope;
        sdi.pwzName             = pdssl->aDsSelection[i].pwzName;
        sdi.pwzClass            = pdssl->aDsSelection[i].pwzClass;
        sdi.pwzADsPath          = pdssl->aDsSelection[i].pwzADsPath;
        sdi.pwzUpn              = pdssl->aDsSelection[i].pwzUPN;

        pdsol->push_back(CDsObject(sdi));
    }

    GlobalUnlock(stgmedium.hGlobal);
    ReleaseStgMedium(&stgmedium);
}




//+--------------------------------------------------------------------------
//
//  Function:   UliToStr
//
//  Synopsis:   Convert the unsigned long integer [uli] to a string.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
UliToStr(
    const ULARGE_INTEGER &uli)
{
    String strResult;
    ULARGE_INTEGER uliCopy = uli;

    while (uliCopy.QuadPart)
    {
        WCHAR wzDigit[] = L"0";

        wzDigit[0] = wzDigit[0] + static_cast<WCHAR>(uliCopy.QuadPart % 10);
        strResult += wzDigit;
        uliCopy.QuadPart /= 10;
    }

    reverse(strResult.begin(), strResult.end());
    return strResult;
}


/*
This Function verifies if the SID is good. This is done when 
the sid is from crossforest. IDirectorySearch doesn't do any Sid 
Filtering. So we get some spoofed sid. To check we get the sid
through LSA also and match the two sids. If sids match then its good
all other cases it considered as spoofed
*/

HRESULT
IsSidGood( IN LPCWSTR pszTargetMachineName,  //Name of the Target Machine
           IN LPCWSTR pszAccountName,        //Name of the account
           IN PSID pInputSid,
           OUT PBOOL pbGood)                        //Sid to verify
{

    // If the input sid is NULL it is because we couldn't get it and
    // the objects that don't have Sids don't have to be sid filtered.
    if(!pInputSid) return S_OK;

    ASSERT(IsValidSid(pInputSid));

    if(!pszAccountName || !pbGood)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    WCHAR wzDomainName[1024];
    BYTE Sid[1024];
    PSID pSid = NULL;
    LPWSTR pszDomainName = NULL;
    DWORD cbSid = 1024;
    DWORD cbDomainName = 1023;
    SID_NAME_USE Use ;
    
    DWORD dwErr = ERROR_SUCCESS;
    
    *pbGood = FALSE;
    
    pSid = (PSID)Sid;
    pszDomainName = (LPWSTR)wzDomainName;


    //
    //Lookup the names
    //
    //REVIEWED-2002-02-23-lucios.
    if(LookupAccountName(pszTargetMachineName,  // name of local or remote computer
                         pszAccountName,              // security identifier
                         pSid,           // account name buffer
                         &cbSid,
                         pszDomainName,
                         &cbDomainName ,
                         &Use ) == FALSE)
    {
        dwErr = GetLastError();
        
        //
        //Function succeeded. But since we can't verify the sid
        //pbGood is false
        //            
        if(dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
            Dbg(DEB_WARN,"Cannot retrieve LSA SID in first "
                "attempt. Error: 0x%x\n",dwErr);
            return S_OK;
        }

        pSid = (PSID)LocalAlloc(LPTR, cbSid);
        if(!pSid)
            return E_OUTOFMEMORY;


        pszDomainName = (LPWSTR)LocalAlloc(LPTR, (cbDomainName + 1)* sizeof(WCHAR));
        if(!pszDomainName)
        {
            LocalFree(pSid);
            return E_OUTOFMEMORY;
        }
        //REVIEWED-2002-02-23-lucios.
        if(LookupAccountName(pszTargetMachineName,  // name of local or remote computer
                             pszAccountName,        // security identifier
                             pSid,                  // account name buffer
                             &cbSid,
                             pszDomainName ,
                             &cbDomainName ,
                             &Use ) == FALSE )
        {
            dwErr=GetLastError();
            LocalFree(pSid);
            LocalFree(pszDomainName);
            Dbg(DEB_WARN,"Cannot retrieve LSA SID in second "
                "attempt. Error: 0x%x\n",dwErr);
            return S_OK;
        }
    }

    if(IsValidSid(pSid))
    {
        *pbGood = EqualSid(pSid,pInputSid);
        if(*pbGood==FALSE)
        {
            LPTSTR sidLSA=NULL,sidOrg=NULL;
            if
            (
                ConvertSidToStringSid(pSid,&sidLSA)==FALSE ||
                ConvertSidToStringSid(pInputSid,&sidOrg)==FALSE
            )
            {
                 Dbg(DEB_WARN,"sid Mismatch, and cannot convert "
                    "Sids to string format.");
            }
            else
            {
                Dbg(DEB_WARN,"sid Mismatch, between LSA SID:%ws and SID:%ws ",
                    sidLSA,sidOrg);
            }
            if(sidLSA!=NULL) LocalFree(sidLSA);
            if(sidOrg!=NULL) LocalFree(sidOrg);
        }
    }

    if(pSid != Sid)
        LocalFree(pSid);
    if(wzDomainName != pszDomainName)
        LocalFree(pszDomainName);

    return S_OK;

}

// This is a replacement for lstrcmpi due to PREfast warning 400
// that states that lstrcmpi is locale dependent and sometimes
// this is not the intention.
INT cmpNoCase(IN LPCWSTR str1,
              IN LPCWSTR str2)
{

    // The three lines bellow immitate lstrcmpi
    if(str1==NULL && str2==NULL) return 0;
    if(str1==NULL && str2!=NULL) return -1;
    if(str1!=NULL && str2==NULL) return 1;
    
    switch(CompareString(LOCALE_INVARIANT,NORM_IGNORECASE,str1,-1,str2,-1))
    {
        case CSTR_EQUAL:
            return 0;
        break;
        case CSTR_GREATER_THAN:
            return 1;
        break;
        case CSTR_LESS_THAN:
            return -1;
        break;
        default:
            // The only possible error that would cause
            // CompareString to return 0 would be ERROR_INVALID_PARAMETER
            // and this is not possible since we are checking for NULL
            // arguments at the begining
            ASSERT(FALSE);
            //return for compiler reasons
            return -1;
    }
}

PSID getSidFromVariant(Variant &rvar)
{
    if (rvar.Type() != (VT_ARRAY | VT_UI1))
    {
        ASSERT(rvar.Empty());

        if (!rvar.Empty())
        {
            Dbg(DEB_ERROR,
                "getSidFromVariant: error vt=%uL, \
                expected (VT_ARRAY | VT_UI1) or VT_EMPTY\n",
                rvar.Type());
            return NULL;
        }
    }
    PSID pSid = NULL;
    rvar.SafeArrayAccessData(&pSid);
    return pSid;
}

BOOL makeSidLookupName
(
    const String &samName,
    const String &adsPath,
    String &result,
    String &domainName
)
{
    if(samName.empty())
    {
         Dbg(DEB_TRACE,"empty samName in makeSidLookupName.\n");
         return FALSE;
    }

    if(adsPath.empty())
    {
         Dbg(DEB_TRACE,"empty adsPath in makeSidLookupName.\n");
         return FALSE;
    }

    BSTR dn;
    HRESULT hr=g_pADsPath->SetRetrieve
    (
        ADS_SETTYPE_FULL ,
        adsPath.c_str(),
        ADS_FORMAT_X500_DN  ,
        &dn
    );
    if(FAILED(hr)) 
    {
        Dbg(DEB_TRACE,"SetRetrieve failed in makeSidLookupName.\n");
        return FALSE;
    }
    PDS_NAME_RESULT pCN=NULL;
    DWORD res=DsCrackNames
    (
        NULL,
        DS_NAME_FLAG_SYNTACTICAL_ONLY,
        DS_FQDN_1779_NAME,
        DS_CANONICAL_NAME,
        1,
        &dn,
        &pCN
    );
    SysFreeString(dn);
    if(res!=NO_ERROR) 
    {
        Dbg(DEB_TRACE,"DsCrackNames failed in makeSidLookupName.\n");
        return FALSE;
    }
    ASSERT(pCN!=NULL);
    if(pCN==NULL) return FALSE;
    if(pCN->cItems!=1 || pCN->rItems->status!=DS_NAME_NO_ERROR) 
    {
        Dbg(DEB_TRACE,"DsCrackNames failed in makeSidLookupName."
            " Items: %u, Status: %lx.\n",pCN->cItems,pCN->rItems->status);
        DsFreeNameResult(pCN);
        return FALSE;
    }
    domainName = pCN->rItems->pDomain;
    result = domainName + L"\\" + samName;
    DsFreeNameResult(pCN);
    return TRUE;
}


// auxilliary in AddSidOkSelection

enum SID_STATUS
{
    SID_INVALID,
    COULD_NOT_MAKE_ACCOUNT,
    SID_MISMATCH,
    SID_OK
};

struct sAccountSids
{
    sAccountSids():pSid(NULL),indx(-1) {};
    String account; // returned from makeSidLookupName
    String domain; // returned from makeSidLookupName
    PSID pSid; // returned from CDsObject::GetSid
    enum SID_STATUS sidStatus;
    int indx; // indx of the array reruned by LsaLookupNames2
};

// We need to copy only the objects that have matching Sids.
// Since we want to make a single call to lsaLookupNames to 
// validate all the objects we have to include them in a temporary
// list and only add to okObjects the objects if
// the sids match.
// Failed domains will have a set of the failed domains for the error
// message.
void 
AddSidOkSelection
(
    const CDsObjectList &selObjects,
    const String& target,
    CDsObjectList &okObjects,
    HWND errorParent
)
{
    TRACE_FUNCTION(AddSidOkSelection);

    // We will have one of this structs for each selObjects
    list<struct sAccountSids> accounts;

    // First we get and classify all the SIDS as we include
    // them in accounts
    CDsObjectList::const_iterator selCsr=selObjects.begin(),
                                  selEnd=selObjects.end();

    for (long indx=0;selCsr!=selEnd;selCsr++)
    {

        sAccountSids tmpAccount;

        do
        {
            if(selCsr->GetNeedsSidFiltering()==FALSE)
            {
                tmpAccount.sidStatus = SID_OK;
                break;
            }
        
            tmpAccount.pSid=selCsr->GetSid();

            // Contacts and a few other objects don't have SIDs.
            // the Sid for them should be NULL.
            if(tmpAccount.pSid)
            {
                // The Sid from the AD should always be valid
                ASSERT(IsValidSid(tmpAccount.pSid));
                String account,domain;
                if
                (
                    makeSidLookupName
                    (
                        selCsr->GetAttr(AK_SAMACCOUNTNAME).GetBstr(),
                        selCsr->GetADsPath(),
                        account,
                        domain
                    )
                )
                {
                    ASSERT(!account.empty());
                    ASSERT(!domain.empty());

                    // Since the sid is valid, and we can make
                    // an account name out of it we will
                    // try to retrieve the SID through LsaLookupNames2 
                    tmpAccount.domain=domain;
                    tmpAccount.account=account;
                    tmpAccount.indx=indx++;
                
                    // We set for SID_MISMATCH initially.
                    // If the SID verification is ok we reset 
                    // it for SID_OK
                    tmpAccount.sidStatus = SID_MISMATCH;
                }
                else
                {
                    Dbg(DEB_TRACE, 
                    "Could not get SID for object %ws.\n",selCsr->GetName());
                    // We must be able to get an account name
                    // from an object with a valid sid, otherwise
                    // we don't want to include the object in okObjects. 
                    tmpAccount.sidStatus = COULD_NOT_MAKE_ACCOUNT;
                }

            }
            else
            {
                // NOT_VALID_SID will be included in okObjects.
                // some objects don't have SIDS and there is no
                // reason to SID filter them.
                tmpAccount.sidStatus = SID_INVALID;
            }
        } while(0);

        accounts.push_back(tmpAccount);
    }

    
    Dbg(DEB_TRACE, 
        "%u Objects and %u accounts to be SID filtered:\n", 
        selObjects.size(), indx);

    list<sAccountSids>::iterator csr,end;
    PLSA_UNICODE_STRING lsaNames=NULL;
    PLSA_REFERENCED_DOMAIN_LIST domains=NULL;
    PLSA_TRANSLATED_SID2 sids=NULL;

    do
    {
        if(indx==0) break; 

        // Then we build an array of LSA strings pointing
        // to the accounts we want to check
        lsaNames = new LSA_UNICODE_STRING[indx];
        if(lsaNames==NULL) break;
    
        csr=accounts.begin(),end=accounts.end();    
        long count=0;
        for(;csr!=end;csr++) 
        {
            if (!csr->account.empty())
            {
                lsaNames[count].Length=(USHORT)
                                    (csr->account.length()*sizeof(WCHAR));
                lsaNames[count].MaximumLength=(USHORT)
                                    ((csr->account.length()+1)*sizeof(WCHAR));
                lsaNames[count].Buffer=const_cast<PWSTR>(csr->account.c_str());
                count++;
            }
        }
        ASSERT(count==indx);


        LSA_UNICODE_STRING systemName=
        {
            (USHORT)(target.length() * sizeof(WCHAR)),
            (USHORT)((target.length()+1) * sizeof(WCHAR)),
            const_cast<PWSTR>(target.c_str())
        };

        LSA_OBJECT_ATTRIBUTES ObjectAttributes;
        ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
        LSA_HANDLE lsahPolicyHandle=NULL;

        NTSTATUS ntsResult = LsaOpenPolicy
        (
            &systemName,
            &ObjectAttributes, 
            POLICY_LOOKUP_NAMES,
            &lsahPolicyHandle
        );

        if(ntsResult!=STATUS_SUCCESS || lsahPolicyHandle==NULL) 
        {
            Dbg(DEB_TRACE,"Could not open sid filtering policy for %ws.\n",
                target.c_str());
            // we will not be able to change the initial status
            // for all the valid SIDs that was set as SID_MISMATCH
            break;
        }

        ntsResult=LsaLookupNames2
        ( 
            lsahPolicyHandle,
            0,
            (ULONG)(indx),
            lsaNames,
            &domains,
            &sids
        );

        if( (
                (ntsResult!=STATUS_SUCCESS) && 
                (ntsResult!=STATUS_SOME_NOT_MAPPED)
            ) ||
            (domains==NULL) || 
            (sids==NULL) )
        {
            if(ntsResult!=STATUS_NONE_MAPPED)
            {
                Dbg(DEB_TRACE,"Unknown return value for "
                            "LsaLookupNames2: %lx.\n",ntsResult);
            }
            // we will not be able to change the initial status
            // for all the valid SIDs that was set as SID_MISMATCH
            break;
        }

        // Now we try to change our initial SID_MISMATCH assestment
        csr=accounts.begin(),end=accounts.end();    
        for(;csr!=end;csr++) 
        {
            if(csr->sidStatus == SID_MISMATCH)
            {
                PSID retSid=sids[csr->indx].Sid;
                if(retSid && IsValidSid(retSid) && EqualSid(retSid,csr->pSid))
                {
                    csr->sidStatus = SID_OK;
                }
                else
                {
                    Dbg(DEB_TRACE,
                        "Sid mismatch for %ws.\n",csr->account.c_str());
                }
            }
        }
    } while(0);

    // finally we build the okObjects list
    okObjects.clear();
    csr=accounts.begin(),end=accounts.end();
    selCsr=selObjects.begin();
    set<String> failedDomains;
    for(;csr!=end;csr++,selCsr++) 
    {
        if( (csr->sidStatus == SID_OK) || (csr->sidStatus == SID_INVALID) )
        {
            okObjects.push_back(*selCsr);
        }
        else 
        {
            if(csr->domain.empty())    
            {
                failedDomains.insert(String::format(IDS_NO_DOMAIN_RETRIEVED));
            }
            else failedDomains.insert(csr->domain);
        }
    }

    if(selObjects.size()!=okObjects.size())
    {
        ASSERT(!failedDomains.empty());
        
        set<String>::iterator csrDomains=failedDomains.begin();
        
        String comma;
        WCHAR lpComma[10]={0};
        GetLocaleInfo(LOCALE_USER_DEFAULT,LOCALE_SLIST,lpComma,9);
        if(*lpComma) comma= L", ";
        else {comma=lpComma;comma += L" ";}

        String err=String::format(IDS_DOMAINS_NOT_AVAILABLE);
        if(failedDomains.size()==1) err += *csrDomains;
        else
        {
            set<String>::iterator endDomains=failedDomains.end();
            endDomains--;endDomains--;
            for(;csrDomains!=endDomains;csrDomains++)
            {
                err+= *csrDomains + comma;
            }
            err+=*csrDomains + comma;//String::format(IDS_AND);
            csrDomains++; 
            err+=*csrDomains;
        }
        err+=String::format(IDS_NO_DOMAIN_TRY_AGAIN);


        WCHAR   wzCaption[MAX_PATH];
        GetWindowText(errorParent, wzCaption, ARRAYLEN(wzCaption));

        MessageBox
        (
            errorParent,
            err.c_str(),
            wzCaption,
            MB_OK
        );

        Dbg(DEB_TRACE, 
            "%u Objects passed to AddSidOkSelection and %u are Ok.\n", 
            selObjects.size(), okObjects.size());
    }

    if(lsaNames!=NULL) delete [] lsaNames;
    if(domains!=NULL) LsaFreeMemory(domains);
    if(sids!=NULL) LsaFreeMemory(sids);
}

HRESULT 
MyGetModuleFileName
(
    HMODULE hModule,
    String &moduleName
)
{
    moduleName.erase();
    DWORD bufferSize=MAX_PATH;
    moduleName.resize(bufferSize);
    DWORD res=GetModuleFileName(hModule,const_cast<wchar_t *>(moduleName.c_str()),bufferSize);

    while(res==bufferSize)
    {
        bufferSize+=MAX_PATH;
        moduleName.resize(bufferSize);
        res=GetModuleFileName(hModule,const_cast<wchar_t *>(moduleName.c_str()),bufferSize);
    }

    moduleName.resize(res);
    if(res==0) return HRESULT_FROM_WIN32(GetLastError());
    else return S_OK;
}


/*-----------------------------------------------------------------------------
/ Dialog box handler functions (core guts)
/----------------------------------------------------------------------------*/

#define REAL_WINDOW(hwnd)                   \
        (hwnd &&                            \
            IsWindowVisible(hwnd) &&        \
                IsWindowEnabled(hwnd) &&    \
                    (GetWindowLong(hwnd, GWL_STYLE) & WS_TABSTOP))

HWND _NextTabStop(HWND hwndSearch, BOOL fShift)
{
    HWND hwnd;

    // do we have a window to search into?
    
    while (hwndSearch)
    {
        // if we have a window then lets check to see if it has any children?

        hwnd = GetWindow(hwndSearch, GW_CHILD);

        if (hwnd)
        {
            // it has a child therefore lets to go its first/last
            // and continue the search there for a window that
            // matches the criteria we are looking for.

            hwnd = GetWindow(hwnd, fShift ? GW_HWNDLAST:GW_HWNDFIRST);

            if (!REAL_WINDOW(hwnd))
            {
                hwnd = _NextTabStop(hwnd, fShift);
            }

        }

        // after all that is hwnd a valid window?  if so then pass
        // that back out to the caller.

        if (REAL_WINDOW(hwnd))
        {
            return hwnd;
        }

        // do we have a sibling?  if so then lets return that otherwise
        // lets just continue to search until we either run out of windows
        // or hit something interesting

        hwndSearch = GetWindow(hwndSearch, fShift ? GW_HWNDPREV:GW_HWNDNEXT);

        if (REAL_WINDOW(hwndSearch))
        {
            return hwndSearch;
        }
    }

    return hwndSearch;
}



BOOL SafeEnableWindow(HWND hw,BOOL fEnable)
{
    if(hw==NULL || !IsWindow(hw)) return FALSE;
    if (!fEnable && GetFocus()==hw) 
    {
        // If we disable a control with the focus, 
        // typing Tab will not cause the focus to 
        // go to the next control, so we find a 
        // replacement before we disable the control

        // Look for the next copntrol in the tab order
        HWND next=_NextTabStop(hw,FALSE);
        
        // If there is no next, the previous will do
        if(!next) next=_NextTabStop(hw,TRUE);

        if(next)
        {
            // WM_NEXTDLGCTL is better than SetFocus because it updates
            // the visual focus arround buttons, etc.
            // hw,TRUE for the last parameters unfortunatelly doesn't search
            // efficiently for a good replacement, so we need _NextTabStop
            SendMessage(GetParent(next),WM_NEXTDLGCTL,(WPARAM)next,FALSE);
        }
    }
    return EnableWindow(hw,fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\test\dsopt\main.cxx ===
#include "headers.hxx"
#pragma hdrstop
#include <compobj.h>

#include <initguid.h>
#include <objsel.h>

PWSTR
ScopeTypeStr(
    ULONG flType);
LPWSTR
VariantString(
    VARIANT *pvar);
void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf);


//
// Helpful macros
//
#define ARRAYLEN(a)                             (sizeof(a) / sizeof((a)[0]))

#define DBG_OUT_HRESULT(hr) printf("error 0x%x at line %u\n", hr, __LINE__)


#define BREAK_ON_FAIL_HRESULT(hr)   \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            break;                  \
        }

VOID
DumpDsSelectedItemList(
    PDS_SELECTION_LIST pDsSelList,
    ULONG cRequestedAttributes,
    LPCTSTR *aptzRequestedAttributes)
{
    if (!pDsSelList)
    {
        printf("List is empty\n");
        return;
    }

    ULONG i;
    PDS_SELECTION pCur = &pDsSelList->aDsSelection[0];

    for (i = 0; i < pDsSelList->cItems; i++, pCur++)
    {
        printf("ScopeType:  %ws\n", ScopeTypeStr(pCur->flScopeType));
        printf("Name:       %ws\n", pCur->pwzName);
        printf("Class:      %ws\n", pCur->pwzClass);
        printf("Path:       %ws\n", pCur->pwzADsPath);
        printf("UPN:        %ws\n", pCur->pwzUPN);

        for (ULONG j = 0; j < cRequestedAttributes; j++)
        {
            printf("Attr %02u: %ws = %ws\n",
                   j,
                   aptzRequestedAttributes[j],
                   VariantString(&pCur->pvarFetchedAttributes[j]));
        }
        printf("\n");
    }
}


PWSTR
ScopeTypeStr(
    ULONG flType)
{
    switch (flType)
    {
    case DSOP_SCOPE_TYPE_TARGET_COMPUTER:
        return L"DSOP_SCOPE_TYPE_TARGET_COMPUTER";

    case DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN:
        return L"DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN";

    case DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN:
        return L"DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN";

    case DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN:
        return L"DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN";

    case DSOP_SCOPE_TYPE_GLOBAL_CATALOG:
        return L"DSOP_SCOPE_TYPE_GLOBAL_CATALOG";

    case DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN:
        return L"DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN";

    case DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN:
        return L"DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN";

    case DSOP_SCOPE_TYPE_WORKGROUP:
        return L"DSOP_SCOPE_TYPE_WORKGROUP";

    case DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE:
        return L"DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE";

    case DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE:
        return L"DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE";

    default:
        return L"*** invalid scope type ***";
    }
}


LPWSTR
VariantString(
    VARIANT *pvar)
{
    static WCHAR wzBuf[1024];

    wzBuf[0] = L'\0';

    switch (pvar->vt)
    {
    case VT_EMPTY:
        lstrcpy(wzBuf, L"VT_EMPTY");
        break;

    case VT_NULL:
        lstrcpy(wzBuf, L"VT_NULL");
        break;

    case VT_I2:
        wsprintf(wzBuf, L"%d", V_I2(pvar));
        break;

    case VT_I4:
        wsprintf(wzBuf, L"%d", V_I4(pvar));
        break;

    case VT_R4:
        wsprintf(wzBuf, L"%f", V_R4(pvar));
        break;

    case VT_R8:
        wsprintf(wzBuf, L"%f", V_R8(pvar));
        break;

    case VT_CY:
        wsprintf(wzBuf, L"$%f", V_CY(pvar));
        break;

    case VT_DATE:
        wsprintf(wzBuf, L"date %f", V_DATE(pvar));
        break;

    case VT_BSTR:
        if (V_BSTR(pvar))
        {
            wsprintf(wzBuf, L"'%ws'", V_BSTR(pvar));
        }
        else
        {
            lstrcpy(wzBuf, L"VT_BSTR NULL");
        }
        break;

    case VT_DISPATCH:
        wsprintf(wzBuf, L"VT_DISPATCH 0x%x", V_DISPATCH(pvar));
        break;

    case VT_UNKNOWN:
        wsprintf(wzBuf, L"VT_UNKNOWN 0x%x", V_UNKNOWN(pvar));
        break;

    case VT_ERROR:
    case VT_HRESULT:
        wsprintf(wzBuf, L"hr 0x%x", V_ERROR(pvar));
        break;

    case VT_BOOL:
        wsprintf(wzBuf, L"%s", V_BOOL(pvar) ? "TRUE" : "FALSE");
        break;

    case VT_VARIANT:
        wsprintf(wzBuf, L"variant 0x%x", V_VARIANTREF(pvar));
        break;

    case VT_DECIMAL:
        lstrcpy(wzBuf, L"VT_DECIMAL");
        break;

    case VT_I1:
        wsprintf(wzBuf, L"%d", V_I1(pvar));
        break;

    case VT_UI1:
        wsprintf(wzBuf, L"%u", V_UI1(pvar));
        break;

    case VT_UI2:
        wsprintf(wzBuf, L"%u", V_UI2(pvar));
        break;

    case VT_UI4:
        wsprintf(wzBuf, L"%u", V_UI4(pvar));
        break;

    case VT_I8:
        lstrcpy(wzBuf, L"VT_I8");
        break;

    case VT_UI8:
        lstrcpy(wzBuf, L"VT_UI8");
        break;

    case VT_INT:
        wsprintf(wzBuf, L"%d", V_INT(pvar));
        break;

    case VT_UINT:
        wsprintf(wzBuf, L"%u", V_UINT(pvar));
        break;

    case VT_VOID:
        lstrcpy(wzBuf, L"VT_VOID");
        break;

    case VT_UI1 | VT_ARRAY:
        VarArrayToStr(pvar, wzBuf, ARRAYLEN(wzBuf));
        break;

    case VT_PTR:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_RECORD:
    case VT_FILETIME:
    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_CLSID:
    case VT_BSTR_BLOB:
    default:
        wsprintf(wzBuf, L"VT 0x%x", V_VT(pvar));
        break;
    }
    return wzBuf;
}



void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf)
{
    ULONG i;
    LPWSTR pwzNext = wzBuf;
    LPWSTR pwzEnd = wzBuf + cchBuf;

    for (i = 0; i < pvar->parray->rgsabound[0].cElements && pwzNext < pwzEnd + 6; i++)
    {
        wsprintf(pwzNext, L"x%02x ", ((LPBYTE)(pvar->parray->pvData))[i]);
        pwzNext += lstrlen(pwzNext);
    }
}

//
// This example allows the user to pick a single computer object
// from any domain in the enterprise, the global catalog, or any
// user-specified domain.  If the target (local) computer is not
// joined to a domain, it allows the user to choose a computer
// object from the workgroup.
//

void func1(HWND hwndParent)
{
    HRESULT hr;
    IDsObjectPicker *pDsObjectPicker;

    hr = CoCreateInstance(CLSID_DsObjectPicker,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsObjectPicker,
                          (void **) &pDsObjectPicker);

    DSOP_SCOPE_INIT_INFO aScopes[1];

    ZeroMemory(aScopes, sizeof(aScopes));

    aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopes[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                      | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                      | DSOP_SCOPE_TYPE_WORKGROUP
                      | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                      | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

    aScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopes[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.cDsScopeInfos = 1;
    InitInfo.aDsScopeInfos = aScopes;

    hr = pDsObjectPicker->Initialize(&InitInfo);

    IDataObject *pdo = NULL;

    hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL
    };

    UINT cf = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

    FORMATETC formatetc =
    {
        cf,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    hr = pdo->GetData(&formatetc, &stgmedium);

    PDS_SELECTION_LIST pDsSelList =
        (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

    ULONG i;

    for (i = 0; i < pDsSelList->cItems; i++)
    {
        printf("item %u: %ws\n", i + 1, pDsSelList->aDsSelection[i].pwzName);
    }
    GlobalUnlock(stgmedium.hGlobal);
    ReleaseStgMedium(&stgmedium);
    pdo->Release();
    pDsObjectPicker->Release();
}


//
// This example allows the user to select one or more objects which may
// legally be added to a security enabled global group.  It will not
// allow the user to specify objects which are contained in domains other
// than those in the enterprise.  The objectSid attribute is fetched for
// all selected objects.  The ADsPath of all selected objects is converted
// to a form using the WinNT provider.
//

void func2(HWND hwndParent)
{
    HRESULT hr;
    IDsObjectPicker *pDsObjectPicker;

    hr = CoCreateInstance(CLSID_DsObjectPicker,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsObjectPicker,
                          (void **) &pDsObjectPicker);

    PCWSTR apwzAttrs[] =
    {
        L"objectSid"
    };

    //
    // Specify the objects which should be displayed for the domain
    // to which the target computer is joined.
    //

    DSOP_SCOPE_INIT_INFO aScopes[2];

    ZeroMemory(aScopes, sizeof(aScopes));

    aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                        | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopes[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_USERS
        | DSOP_FILTER_CONTACTS
        | DSOP_FILTER_COMPUTERS;
    aScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
        DSOP_FILTER_GLOBAL_GROUPS_DL
        | DSOP_FILTER_GLOBAL_GROUPS_SE;
    aScopes[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    // include downlevel filter in case target computer is joined to
    // an NT4 domain

    aScopes[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // Specify the objects which should be displayed for all other
    // domains in the enterprise.
    //

    aScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_CONTACTS;
    aScopes[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.cDsScopeInfos = 2;
    InitInfo.aDsScopeInfos = aScopes;
    InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

    hr = pDsObjectPicker->Initialize(&InitInfo);

    IDataObject *pdo = NULL;

    hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);


}

#include <initguid.h>
#include <objselp.h>

int _cdecl
main(int argc, char * argv[])
{
    HRESULT hr;
    IDsObjectPicker *pDsObjectPicker = NULL;

    do
    {
        hr = CoInitialize(NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPickerEx,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        DSOP_SCOPE_INIT_INFO aScopes[1];

        ZeroMemory(aScopes, sizeof(aScopes));

        aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        aScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        aScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_WELL_KNOWN_PRINCIPALS
            | DSOP_FILTER_USERS;
        aScopes[0].FilterFlags.flDownlevel =
            DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

#if 0
        aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        aScopes[0].flType =
            DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
            | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
        aScopes[0].FilterFlags.Uplevel.flMixedModeOnly =
            DSOP_FILTER_INCLUDE_ADVANCED_VIEW
            | DSOP_FILTER_USERS
            | DSOP_FILTER_BUILTIN_GROUPS
            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS
            | DSOP_FILTER_GLOBAL_GROUPS_SE
            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
            | DSOP_FILTER_COMPUTERS;
        aScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
            DSOP_FILTER_INCLUDE_ADVANCED_VIEW
            | DSOP_FILTER_USERS
            | DSOP_FILTER_BUILTIN_GROUPS
            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS
            | DSOP_FILTER_UNIVERSAL_GROUPS_SE
            | DSOP_FILTER_GLOBAL_GROUPS_SE
            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
            | DSOP_FILTER_COMPUTERS;
        aScopes[0].FilterFlags.flDownlevel = 0x800079fd;

        aScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        aScopes[1].flScope = 0;
        aScopes[1].FilterFlags.Uplevel.flBothModes = 0x8a3;

        aScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        aScopes[2].flScope = 0;
        aScopes[2].FilterFlags.Uplevel.flBothModes = 0x8a3;
        aScopes[2].FilterFlags.flDownlevel = 0x80000005;

        aScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[3].flType =
            DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
            | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
        aScopes[3].flScope = 0;
        aScopes[3].FilterFlags.Uplevel.flBothModes = 0x8a3;
        aScopes[3].FilterFlags.flDownlevel = 0x80000005;
#endif
        DSOP_INIT_INFO  InitInfo;
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        PCWSTR apwzAttributeNames[] = {
            L"ObjectSid"
        };

        InitInfo.cbSize = sizeof(InitInfo);
        InitInfo.pwzTargetComputer = NULL;
        //InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
        InitInfo.cDsScopeInfos = ARRAYLEN(aScopes);
        InitInfo.aDsScopeInfos = aScopes;
        InitInfo.cAttributesToFetch = ARRAYLEN(apwzAttributeNames);
        InitInfo.apwzAttributeNames = apwzAttributeNames;

        hr = pDsObjectPicker->Initialize(&InitInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        IDataObject *pdo = NULL;

        hr = pDsObjectPicker->InvokeDialog(NULL, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        if (hr == S_FALSE)
        {
            printf("User cancelled dialog\n");
            break;
        }

        STGMEDIUM stgmedium =
        {
            TYMED_HGLOBAL,
            NULL
        };

        UINT cf = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

        FORMATETC formatetc =
        {
            cf,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        DumpDsSelectedItemList(
            pDsSelList,
            InitInfo.cAttributesToFetch,
            InitInfo.apwzAttributeNames);

        GlobalUnlock(stgmedium.hGlobal);
        ReleaseStgMedium(&stgmedium);
        pdo->Release();
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }

    OutputDebugString(L"main.cxx: uninitializing OLE\n");
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\test\listview\listtest.cpp ===
// test listview control for broken rendering



#include "headers.hxx"
#include "resource.h"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available
const wchar_t* RUNTIME_NAME = L"listtest";
DWORD DEFAULT_LOGGING_OPTIONS = Log::OUTPUT_TYPICAL;



void
AddIconImage(HIMAGELIST imageList, int iconResID)
{
   LOG_FUNCTION(AddIconImage);
   ASSERT(imageList);
   ASSERT(iconResID);
   
   if (iconResID && imageList)
   {
      HICON icon = 0;
      HRESULT hr = Win::LoadImage(iconResID, icon);

      ASSERT(SUCCEEDED(hr));

      if (SUCCEEDED(hr))
      {
         Win::ImageList_AddIcon(imageList, icon);

         // once the icon is added (copied) to the image list, we can
         // destroy the original.

         Win::DestroyIcon(icon);
      }
   }
}


static const DWORD HELP_MAP[] =
{
   0, 0
};

class ListViewDialog : public Dialog
{
   public:

   ListViewDialog()
      :
      Dialog(IDD_LOOK_FOR, HELP_MAP)
   {
   }

   ~ListViewDialog()
   {
   }

   protected:

   // Dialog overrides

   virtual
   void
   OnInit()
   {
      HWND listview = Win::GetDlgItem(hwnd, IDC_LOOK_FOR_LV);
      
      //
      // put listview in checkbox style
      //

      ListView_SetExtendedListViewStyleEx(
         listview,
         LVS_EX_CHECKBOXES,
         LVS_EX_CHECKBOXES);

//ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 1, 1);
         
      HIMAGELIST images =
         Win::ImageList_Create(
            16, // Win::GetSystemMetrics(SM_CXSMICON),
            16, // Win::GetSystemMetrics(SM_CYSMICON),
            ILC_MASK,
            1,
            1);
   
      // the order in which these are added must be the same that the
      // MemberInfo::Type enum values are listed!
   
      AddIconImage(images, IDI_SCOPE_WORKGROUP);
      AddIconImage(images, IDI_LOCAL_GROUP);
      AddIconImage(images, IDI_SCOPE_DIRECTORY);
      AddIconImage(images, IDI_SCOPE_DOMAIN);
      AddIconImage(images, IDI_DISABLED_USER);
      AddIconImage(images, IDI_DISABLED_COMPUTER);
   
      Win::ListView_SetImageList(listview, images, LVSIL_SMALL);
      
      //
      // Add a single column to the listview
      //

      LV_COLUMN   lvc;
      RECT        rcLv;

      GetClientRect(listview, &rcLv);
      ZeroMemory(&lvc, sizeof lvc);
      lvc.mask = LVCF_FMT | LVCF_WIDTH;
      lvc.fmt  = LVCFMT_LEFT;
      lvc.cx = rcLv.right;
      Win::ListView_InsertColumn(listview, 0, lvc);

      static PCWSTR itemLabels[] =
      {
         L"workgroup",
         L"Group",
         L"Directory",
         L"Domain",
         L"User",
         L"Computer",
         0
      };
            
      LVITEM  lvi;
      int i = 0;
      PCWSTR* labels = itemLabels;

      while (*labels)
      {
         ZeroMemory(&lvi, sizeof lvi);
         lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
         lvi.pszText = const_cast<PWSTR>(*labels);
         lvi.iImage = i;
         ++labels;
         ++i;
         
         Win::ListView_InsertItem(listview, lvi);
      };
      

      //
      // Make the first item in the listview have the focus
      //

      ListView_SetItemState(
         listview,
         0,
         LVIS_FOCUSED | LVIS_SELECTED,
         LVIS_FOCUSED | LVIS_SELECTED);
   }

   private:

   ListViewDialog(const ListViewDialog&);
   const ListViewDialog& operator=(const ListViewDialog&);   
};




int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   int exitCode = 0;

   INITCOMMONCONTROLSEX s_e_x;
   s_e_x.dwSize = sizeof(s_e_x);      
   s_e_x.dwICC  = ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;

   BOOL init = ::InitCommonControlsEx(&s_e_x);
   ASSERT(init);
         
   ListViewDialog().ModalExecute(Win::GetDesktopWindow());
            
   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\test\opt\dlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       dlg.cxx
//
//  Contents:   Implementation of modeless dialog base class
//
//  Classes:    CDlg
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop





//+--------------------------------------------------------------------------
//
//  Member:     CDlg::CDlg
//
//  Synopsis:   ctor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::CDlg():
    m_hwnd(NULL)
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::~CDlg
//
//  Synopsis:   dtor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::~CDlg()
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModalDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog's return code
//
//  History:    04-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR
CDlg::_DoModalDlg(
    HWND hwndParent,
    INT idd) const
{
    INT_PTR iResult = DialogBoxParam(GetModuleHandle(NULL),
                          MAKEINTRESOURCE(idd),
                          hwndParent,
                          CDlg::_DlgProc,
                          (LPARAM) this);

    return iResult;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModelessDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog window handle, or NULL on failure
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HWND
CDlg::_DoModelessDlg(
    HWND hwndParent,
    INT idd)
{

    HWND hwnd;

    hwnd = CreateDialogParam(GetModuleHandle(NULL),
                             MAKEINTRESOURCE(idd),
                             hwndParent,
                             CDlg::_DlgProc,
                             (LPARAM) this);
    return hwnd;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DlgProc
//
//  Synopsis:   Dispatch selected messages to derived class
//
//  Arguments:  standard windows dialog
//
//  Returns:    standard windows dialog
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK
CDlg::_DlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fReturn = TRUE;
    CDlg *pThis = (CDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message)
    {
    case WM_INITDIALOG:
    {
        HRESULT hr = S_OK;

        //
        // pThis isn't valid because we haven't set DWLP_USER yet.  Make
        // it valid.
        //

        pThis = (CDlg*) lParam;

        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pThis);
        pThis->m_hwnd = hwnd;
        BOOL fInitResult = TRUE;
        hr = pThis->_OnInit(&fInitResult);
        fReturn = fInitResult;

        //
        // If the initialization failed do not allow the dialog to start.
        //

        if (FAILED(hr))
        {
            DestroyWindow(hwnd);
        }
        break;
    }

    case WM_COMMAND:
        fReturn = pThis->_OnCommand(wParam, lParam);
        break;

    case WM_SIZE:
        fReturn = pThis->_OnSize(wParam, lParam);
        break;

    case WM_GETMINMAXINFO:
        fReturn = pThis->_OnMinMaxInfo((LPMINMAXINFO) lParam);
        break;

    case WM_NOTIFY:
        fReturn = pThis->_OnNotify(wParam, lParam);
        break;

    case WM_DRAWITEM:
        fReturn = pThis->_OnDrawItem(wParam, lParam);
        break;

    case WM_CTLCOLORSTATIC:
        fReturn = static_cast<ULONG>(pThis->_OnStaticCtlColor((HDC) wParam, (HWND) lParam));
        break;

    case WM_SYSCOLORCHANGE:
        pThis->_OnSysColorChange();
        break;
/*
    case WM_SETFOCUS:
        pThis->_OnSetFocus((HWND)wParam);
        break;
*/

    case WM_DESTROY:
        //
        // It's possible to get a WM_DESTROY message without having gotten
        // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
        // comctl32.dll) fails, so guard pThis access here.
        //

        if (pThis)
        {
            pThis->_OnDestroy();
            pThis->m_hwnd = NULL;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        pThis->_OnHelp(message, wParam, lParam);
        break;

    default:
        fReturn = FALSE;
        break;
    }
    return fReturn;
}


#define VERIFY(x) x

//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_GetChildWindowRect
//
//  Synopsis:   Init *[prc] with the window rect, in client coordinates, of
//              child window [hwndChild].
//
//  Arguments:  [hwndChild] - child window for which to retrieve rect
//              [prc]       - pointer to rect struct to receive info
//
//  Modifies:   *[prc]
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDlg::_GetChildWindowRect(
    HWND hwndChild,
    RECT *prc)
{

    VERIFY(GetWindowRect(hwndChild, prc));
    VERIFY(MapWindowPoints(NULL, m_hwnd, (LPPOINT) prc, 2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\test\listview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Select.rc
//
#define IDD_FRAME                               101
#define IDD_SELECTION                           102
#define IDD_PASSWORD                            103
#define IDD_BROWSE_MULTI                        104
#define IDD_BROWSE_SINGLE                       106
#define IDD_MULTI                               107

#define IDC_ENUMWINDOW                          1002
#define IDC_SELECTWINDOW                        1003
#define IDC_SEARCH                              1004
#define IDC_SCOPE                               1005
#define IDC_LOOKIN                              1006
#define IDC_TOOLBAR                             1007


#define IDB_TOOLBAR                             101
#define IDC_ADD                                 101
#define IDC_NAME                                103
#define IDS_LVCOLUMN_0                          105
#define IDS_LVCOLUMN_1                          106
#define IDC_BROWSER                             108
#define IDS_DIRECTORY                           112
#define IDS_OTHER_TRUSTED                       113
#define IDC_EMPTY                               115
#define IDS_NO_SELECTION                        120
#define IDS_NO_SELECTIONS                       121
#define IDS_OUT_OF_MEMORY                       122
#define IDC_NAME_LBL                            126
#define IDS_SELECT_COMPUTERS                    127
#define IDS_WORKING                             128
#define IDS_NO_OBJECTS                          129
#define IDS_SELECT_COMPUTER                     133
#define IDC_USER_NAME_LBL                       134
#define IDC_USER_NAME                           135
#define IDC_PASSWORD_LBL                        136
#define IDC_PASSWORD                            137
#define IDS_USER                                138 // caution these must remain
#define IDS_USERS                               139 // consecutive
#define IDS_CONTACT                             140
#define IDS_CONTACTS                            141
#define IDS_GROUP                               142
#define IDS_GROUPS                              143
#define IDS_COMPUTER                            144
#define IDS_COMPUTERS                           145 // end consecutive
#define IDC_BROWSER_STATIC_OVERLAY              150
#define IDS_COL1FORMAT                          151
#define IDC_SELECTIONLIST_LBL                   152
#define IDC_SELECT_MATCHING_LBL                 153
#define IDC_MATCHING_LIST                       154
#define IDS_BAD_NAME_EXTRA_SLASH                155
#define IDS_NAME_NOT_FOUND_FMT_MULTI            156
#define IDS_NAME_BAD_CLASS_FMT                  157
#define IDS_NAME_QUERY_FAILED                   158
#define IDS_MAX_HITS                            159
#define IDS_MULTI_PICK_ONE                      161
#define IDS_HIT_QUERY_LIMIT                     164
#define IDS_BAD_NAME_SLASH_AT_END               165
#define IDC_PASSWORD_EXPLANATION                166
#define IDC_TARGET                              168
#define IDS_UNKNOWN_DOMAIN                      169
#define IDC_PASSWORD_EXPLANATION2               170
#define IDC_PASSWORD_EXPLANATION3               171
#define IDC_EXAMPLE_LBL                         172
#define IDS_EXAMPLE_UPN_NT4                     173
#define IDS_EXAMPLE_NT4                         174
#define IDS_NO_SCOPES                           175
#define IDS_BAD_NAME_EXTRA_START_SLASH          176
#define IDS_COMP_IN_UNKNOWN_DOMAIN              179
#define IDS_COMP_IN_INVALID_DOMAIN              180
#define IDD_ERROR                               181
#define IDC_POPUP_MSG_ICON                      182
#define IDC_ERRORMSG                            183
#define IDC_ERROR_CODE_LBL                      185
#define IDC_ERROR_CODE_EDIT                     186
#define IDS_NO_SELECTION2                       187
#define IDS_INIT_FAILED_MEMORY                  189
#define IDS_BAD_NAME                            190
#define IDS_COMPUTER_NOT_FOUND                  192
#define IDS_INTERNAL_ERROR_COMPUTER             193
#define IDS_GET_ITEM_FAILED                     194
#define IDD_NAMENOTFOUND                        195
#define IDC_NOT_FOUND_ICON                      196
#define IDC_NOT_FOUND_MESSAGE                   197
#define IDC_CORRECT_RADIO                       198
#define IDC_CORRECT_EDIT                        199
#define IDC_REMOVE_RADIO                        200
#define IDS_NAME_NOT_FOUND_FMT_SINGLE           201
//used by burnslib                              202
#define IDS_CANNOT_INVOKE                       203
#define IDS_CANNOT_PROCESS                      204
#define IDC_SIZEGRIP                            207
#define IDA_SEARCH                              208
#define IDC_ANIMATION                           209
#define IDS_INIT_FAILED_NO_SCOPES               210
#define IDS_BIND_ERROR                          211
#define IDC_RICHEDIT                            214
#define IDC_REPLACE_RADIO                       216
#define IDS_REPLACE_SINGLE                      217
#define IDM_CUT                                 218
#define IDM_COPY                                219
#define IDM_PASTE                               220
#define IDM_RICHEDIT                            221
#define IDC_WHAT                                222
#define IDS_DNS_SLASH_NAME                      223
#define IDC_SELECTION_LBL                       224
//used by burnslib                              225
//used by burnslib                              226
//used by burnslib                              227
#define IDS_DISABLED_WARNING_FMT                228
#define IDS_UPN_FORM_NOT_ALLOWED                229
#define IDC_LOOK_FOR_PB                         230
#define IDC_LOOK_FOR_EDIT                       231
#define IDC_LOOK_IN_PB                          232
#define IDC_LOOK_IN_EDIT                        233
#define IDC_INSTRUCTION_LBL                     234
#define IDC_CHECK_NAMES_PB                      235
#define IDC_ADVANCED_PB                         236
#define IDD_STANDALONE_TEXT                     237
#define IDD_LOOK_FOR                            238
#define IDC_LOOK_FOR_LV                         239
#define IDD_LOOK_IN                             240
#define IDC_LOOK_IN_TV                          241
#define IDS_BROWSE_ERROR_FMT                    242
#define IDS_INIT_FAILED_MACHINE_CONFIG          246
#define IDS_INIT_FAILED_LOCAL_MACHINE_CONFIG    247
#define IDS_INIT_FAILED_BAD_ARGS                248
#define IDS_NEW_SCOPE_CLASSES_0_INTERSECTION    249
#define IDS_CANNOT_CONTACT_GC                   250
#define IDS_EXPAND_FAILED                       251
#define IDC_LOOK_FOR_LBL                        256
#define IDC_LOOK_IN_LBL                         257
#define IDC_TAB                                 258
#define IDC_FIND_NOW_PB                         259
#define IDC_STOP_PB                             260
#define IDD_ADVANCED                            261
#define IDS_COMMON_QUERIES                      262
#define IDS_QUERY_BUILDER                       263
#define IDD_COMMON_QUERIES                      264
#define IDD_QUERY_BUILDER                       265
#define IDC_NAME_COMBO                          266
#define IDC_NAME_EDIT                           267
#define IDC_DESCRIPTION_COMBO                   268
#define IDC_DESCRIPTION_EDIT                    269
#define IDC_DISABLED_CKBOX                      270
#define IDC_NON_EXPIRING_CKBOX                  271
#define IDC_LAST_LOGON_COMBO                    272
#define IDC_EXPIRED_EDIT                        273
#define IDC_CLAUSE_LIST                         274
#define IDC_ADD_BTN                             275
#define IDC_EDIT_BTN                            276
#define IDC_REMOVE_BTN                          277
#define IDS_STARTS_WITH                         278
#define IDS_IS_EXACTLY                          279
#define IDC_LBL1                                280
#define IDC_LBL2                                281
#define IDC_QUERY_LISTVIEW                      282
#define IDS_SINGLE_SELECT_INSTRUCTIONS          283
#define IDS_BUILTIN_WKSP                        284
#define IDS_BUILTIN_WKSPS                       285
#define IDI_GROUP                               286
#define IDI_USER                                287
#define IDI_COMPUTER                            288
#define IDS_OTHER_OBJECT                        289
#define IDS_OTHER_OBJECTS                       290
#define IDC_DESCRIPTION_LBL                     291
#define IDC_ATTR_LIST                           292
#define IDD_ADDCLAUSE                           293
#define IDS_UNIQUE_ATTR_FMT                     294
#define IDD_STRING_ATTR                         295
#define IDC_CONDITION_COMBO                     296
#define IDC_VALUE_EDIT                          297
#define IDS_STR_FILTER_EXACT_DESCRIPTION_FMT    298
#define IDS_STR_FILTER_PREFIX_DESCRIPTION_FMT   299
#define IDD_DN_ATTR                             300
#define IDD_CLEAR_QB                            301
#define IDS_CLEAR_QB_CAPTION                    302
#define IDS_CLEAR_QB_TEXT                       303
#define IDC_LASTLOGON_COMBO                     304
#define IDC_LASTLOGON_LBL                       305
#define IDS_SCOPE_ERROR                         306
#define IDS_NOTHINGFOUND                        307
#define IDS_QUERY_ERROR                         308
#define IDS_SEARCHING                           309
#define IDS_STOPPING_QUERY                      310
#define IDS_LOCAL_GROUP                         311
#define IDS_GLOBAL_GROUP                        312
#define IDC_AVAILABLE_LIST                      313
#define IDC_SHOWN_LIST                          314
#define IDS_CHOOSE_COLUMNS                      315
#define IDD_COLUMN_PICKER                       316
#define IDS_CANNOT_READ_RICHEDIT                317
#define IDS_MULTI_PICK_ONE_OR_MORE              318
#define IDC_COLUMNS_PB                          319
#define IDC_ADD_COL_BTN                         320
#define IDC_REMOVE_COL_BTN                      321
#define IDS_SEMICOLON_IN_NAME                   322



//
// BEGIN: Blocks of IDs which must remain consecutive
//

#define IDS_FILTER_ONE                          500
#define IDS_FILTER_TWO                          501
#define IDS_FILTER_THREE                        502
#define IDS_FILTER_FOUR                         503
#define IDS_FILTER_FIVE                         504
#define IDS_FILTER_SIX                          505

#define IDS_SELECT_ONE                          600
#define IDS_SELECT_TWO                          601
#define IDS_SELECT_THREE                        602
#define IDS_SELECT_FOUR                         603
#define IDS_SELECT_FIVE                         604
#define IDS_SELECT_SIX                          605

//
// END: Blocks of IDs which must remain consecutive
//

//
// Icons
//

#define IDI_LOCAL_GROUP                 100
#define IDI_SCOPE_WORKGROUP             105
#define IDI_SCOPE_DIRECTORY             106
#define IDI_SCOPE_DOMAIN                107

#define IDI_DISABLED_USER               200
#define IDI_DISABLED_COMPUTER           201

//
// Timers
//

#define ID_CRED_PROMPT_TIMER            100


//
// Sizing values
//

#define CX_PLUGIN_DIALOG    355
#define CX_MAIN_CONTROL     353

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\test\opt\glopres.h ===
#define IDC_ADD                         1000
#define IDD_GLOP                        1001
#define IDC_FILTER_LIST                 1002
#define IDR_MENU1                       1003
#define IDC_INIT_BUTTON                 1004
#define IDC_TARGET_COMPUTER_EDIT        1005
#define IDC_MULTISELECT_CHECK           1006
#define IDC_SKIP_DC_CHECK               1007
#define IDC_SCOPE_FILTER_LIST           1008
#define IDC_SCOPE_FLAG_LIST             1009
#define IDC_REMOVE                      1010

#define IDC_BOTH_RADIO                  1011
#define FIRST_MODE_RADIO                IDC_BOTH_RADIO
#define IDC_MIXED_RADIO                 1012
#define IDC_NATIVE_RADIO                1013
#define IDC_DOWNLEVEL_RADIO             1014
#define LAST_MODE_RADIO                 IDC_DOWNLEVEL_RADIO

#define IDC_ATTRIBUTES_EDIT             1015
#define IDC_SCOPE_LIST                  1016
#define IDC_INVOKE_BUTTON               1017
#define IDC_ADD_SCOPE_RADIO1            1018
#define FIRST_SCOPE_RADIO               IDC_ADD_SCOPE_RADIO1
#define IDC_ADD_SCOPE_RADIO2            1019
#define IDC_ADD_SCOPE_RADIO3            1020
#define IDC_ADD_SCOPE_RADIO4            1021
#define IDC_ADD_SCOPE_RADIO5            1022
#define IDC_ADD_SCOPE_RADIO6            1023
#define IDC_ADD_SCOPE_RADIO7            1024
#define IDC_ADD_SCOPE_RADIO8            1025
#define IDC_ADD_SCOPE_RADIO9            1026
#define IDC_ADD_SCOPE_RADIO10           1027
#define LAST_SCOPE_RADIO                IDC_ADD_SCOPE_RADIO10
#define IDD_ADD_SCOPE                   1028
#define IDC_RELEASE_BUTTON              1029
#define IDC_COCREATE_BUTTON             1030







#define IDM_OPEN                        40001
#define IDM_SAVE                        40002
#define IDM_EXIT                        40003
#define IDM_LUM                         40004
#define IDM_ACL_FILE                    40005
#define IDM_SAVE_AS                     40006
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 2000 - 2000

Module Name:

    sources.inc

Note:

    Common Drizzle build switches.

!ENDIF

# USE_WININET=1
# BITS_V12=1

MSC_WARNING_LEVEL=/WX /W3
USE_MSVCRT=1
USE_NATIVE_EH=1
USE_STL=1

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE  -DWPP_CHECK_FOR_NULL_STRING

!if defined(USE_WININET)
C_DEFINES = $(C_DEFINES) -DUSE_WININET
!endif

!if defined(BITS_V12_ON_NT4)
C_DEFINES = $(C_DEFINES) -DBITS_V12_ON_NT4 -DBITS_DONT_USE_ASYNC_DCOM
BITS_V12=1
MIDL_OPTIMIZATION = /Oicf -error all
!endif

!if defined(BITS_V12)
C_DEFINES = $(C_DEFINES) -DBITS_V12
!endif

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bitsadmin\bitsadmin.cpp ===
/************************************************************************

Copyright (c) 2000-2000 Microsoft Corporation

Module Name :

    bitsadmin.cpp

Abstract :

    This file contains a very simple commandline utility for controlling
    the BITS service.

Author :

    Mike Zoran  mzoran   July 2000.

Revision History :

Notes:

    This tools does not do all the necessary Release and memory
    free calls that a long lived program would need to do.   Since
    this tool is generally short lived, or only a small section of code
    is used when it isn't, the system can be relied on for resource
    cleanup.

  ***********************************************************************/

#include "bitsadmin.h"

void CheckBITSHR( const WCHAR *pFailTxt, HRESULT Hr )
{
   // Check on error code returned from BITS,
   // and exit with a printed error messeage on an error

   if ( !SUCCEEDED(Hr) )
        {
        WCHAR ErrorCode[12];

        if ( SUCCEEDED( StringCbPrintf( ErrorCode, sizeof(ErrorCode), L"0x%8.8x", Hr ) ) )
            {

                bcout << pFailTxt << L" - " << ErrorCode << L"\n";

                AutoStringPointer Message;

                HRESULT LookupHr = HRESULT_FROM_WIN32( ERROR_RESOURCE_LANG_NOT_FOUND );

                LCID LcidsToTry[] =
                {
                    GetThreadLocale(),
                    GetUserDefaultLCID(),
                    GetSystemDefaultLCID(),
                    MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), 0 )
                };

                SIZE_T NumberOfLCIDs = sizeof( LcidsToTry ) / sizeof( *LcidsToTry );

                for( int i = 0;
                       ( HRESULT_FROM_WIN32( ERROR_RESOURCE_LANG_NOT_FOUND ) == LookupHr ||
                         HRESULT_FROM_WIN32( ERROR_MR_MID_NOT_FOUND ) == LookupHr ) &&
                       i < NumberOfLCIDs;
                       i++ )
                    {

                    LookupHr =
                        g_Manager->GetErrorDescription(
                            Hr,
                            LcidsToTry[ i ],
                            Message.GetRecvPointer() );

                    if ( SUCCEEDED( LookupHr ) )
                        {
                        bcout << Message << L"\n";
                        break;
                        }
                    }

                throw AbortException( Hr );

            }

        }
}

void ConnectToBITS()
{

    // Connects to the BITS service

    if ( g_Manager.Get() )
        return;

    if ( !pComputerName )
        {
        CheckHR( L"Unable to connect to BITS",
                 CoCreateInstance( CLSID_BackgroundCopyManager,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IBackgroundCopyManager,
                                   (void**)g_Manager.GetRecvPointer() ) );
        }
    else
        {
        COSERVERINFO ServerInfo;
        memset( &ServerInfo, 0 , sizeof( ServerInfo ) );
        ServerInfo.pwszName = pComputerName;

        IClassFactory *pFactory = NULL;

        CheckHR( L"Unable to connect to BITS",
                 CoGetClassObject(
                     CLSID_BackgroundCopyManager,
                     CLSCTX_REMOTE_SERVER,
                     &ServerInfo,
                     IID_IClassFactory,
                     (void**) &pFactory ) );


        CheckHR( L"Unable to connect to BITS",
                 pFactory->CreateInstance(
                     NULL,
                     IID_IBackgroundCopyManager,
                     (void**)g_Manager.GetRecvPointer() ));
        pFactory->Release();
        }
}

//
// Generic commandline parsing structures and functions
//

typedef void (*PCMDPARSEFUNC)(int, WCHAR** );
typedef struct _PARSEENTRY
{
  const WCHAR * pCommand;
  PCMDPARSEFUNC pParseFunc;
} PARSEENTRY;

typedef struct _PARSETABLE
{
  const PARSEENTRY *pEntries;
  PCMDPARSEFUNC pErrorFunc;
  void * pErrorContext;
} PARSETABLE;

void ParseCmd( int argc, WCHAR **argv, const PARSETABLE *pParseTable )
{
    if ( !argc) goto InvalidCommand;

    for( const PARSEENTRY *pEntry = pParseTable->pEntries;
         pEntry->pCommand; pEntry++ )
    {
       if (!_wcsicmp( *argv, pEntry->pCommand ))
       {
           argc--;
           argv++;
           (*pEntry->pParseFunc)( argc, argv  );
           return;
       }
    }

InvalidCommand:
    // Couldn't find a match, so complain
    bcout << L"Invalid command\n";
    (*pParseTable->pErrorFunc)( argc, argv );
    throw AbortException( 1 );

}

//
// BITS specific input and output
//

BITSOUTStream & operator<<( BITSOUTStream &s, SmartJobPointer Job )
{
    GUID guid;
    CheckBITSHR( L"Unable to get guid to job", Job->GetId( &guid ) );
    return (s << guid );
}

BITSOUTStream& operator<<( BITSOUTStream &s, SmartJobErrorPointer Error )
{
    SmartFilePointer pFile;
    AutoStringPointer LocalName;
    AutoStringPointer URL;

    CheckBITSHR( L"Unable to get error file", Error->GetFile( pFile.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get error URL", pFile->GetRemoteName( URL.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get error file name", pFile->GetLocalName( LocalName.GetRecvPointer() ) );

    bcout << AddIntensity() << L"ERROR FILE:    " << ResetIntensity() << URL << L" -> " << LocalName << L"\n";

    BG_ERROR_CONTEXT Context;
    HRESULT Code;
    AutoStringPointer ErrorDescription;
    AutoStringPointer ContextDescription;
    CheckBITSHR( L"Unable to get error code", Error->GetError( &Context, &Code ) );

    HRESULT LookupHr = HRESULT_FROM_WIN32( ERROR_RESOURCE_LANG_NOT_FOUND );

    LCID LcidsToTry[] =
    {
        GetThreadLocale(),
        GetUserDefaultLCID(),
        GetSystemDefaultLCID(),
        MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), 0 )
    };

    SIZE_T NumberOfLCIDs = sizeof( LcidsToTry ) / sizeof( *LcidsToTry );

    for( int i = 0;
           ( HRESULT_FROM_WIN32( ERROR_RESOURCE_LANG_NOT_FOUND ) == LookupHr ||
             HRESULT_FROM_WIN32( ERROR_MR_MID_NOT_FOUND ) == LookupHr ) &&
           i < NumberOfLCIDs;
           i++ )
        {

        LookupHr =
            Error->GetErrorDescription(
                LcidsToTry[ i ],
                ErrorDescription.GetRecvPointer() );

        if ( SUCCEEDED( LookupHr ) )
            {
            break;
            }
        }
    CheckBITSHR( L"Unable to get error description", LookupHr );

    LookupHr = HRESULT_FROM_WIN32( ERROR_RESOURCE_LANG_NOT_FOUND );

    for( int i = 0;
           ( HRESULT_FROM_WIN32( ERROR_RESOURCE_LANG_NOT_FOUND ) == LookupHr ||
             HRESULT_FROM_WIN32( ERROR_MR_MID_NOT_FOUND ) == LookupHr ) &&
           i < NumberOfLCIDs;
           i++ )
        {

        LookupHr =
            Error->GetErrorContextDescription(
                LcidsToTry[ i ],
                ContextDescription.GetRecvPointer() );

        if ( SUCCEEDED( LookupHr ) )
            {
            break;
            }
        }

    CheckBITSHR( L"Unable to get context description", LookupHr );

    bcout << AddIntensity() << L"ERROR CODE:    " << ResetIntensity() <<
             HRESULTToString(Code) << L" - " << ErrorDescription;
    bcout << AddIntensity() << L"ERROR CONTEXT: " << ResetIntensity() <<
             HRESULTToString((HRESULT)Context) << L" - " << ContextDescription;

    return s;
}

BITSOUTStream & operator<<( BITSOUTStream &s, BG_JOB_TYPE type )
{
    if ( BG_JOB_TYPE_DOWNLOAD == type )
        return ( s << L"DOWNLOAD" );
    else if ( BG_JOB_TYPE_UPLOAD == type )
        return ( s << L"UPLOAD" );
    else if ( BG_JOB_TYPE_UPLOAD_REPLY == type )
        return ( s << L"UPLOAD-REPLY" );
    else
        return ( s << L"UNKNOWN" );
}

BITSOUTStream & operator<<( BITSOUTStream &s, BG_JOB_STATE state )
{
    switch(state)
        {
        case BG_JOB_STATE_QUEUED:
            return ( s << L"QUEUED" );
        case BG_JOB_STATE_CONNECTING:
            return ( s << L"CONNECTING" );
        case BG_JOB_STATE_TRANSFERRING:
            return ( s << L"TRANSFERRING" );
        case BG_JOB_STATE_SUSPENDED:
            return ( s << L"SUSPENDED" );
        case BG_JOB_STATE_ERROR:
            return ( s << L"ERROR" );
        case BG_JOB_STATE_TRANSIENT_ERROR:
            return ( s << L"TRANSIENT_ERROR" );
        case BG_JOB_STATE_TRANSFERRED:
            return ( s << L"TRANSFERRED" );
        case BG_JOB_STATE_ACKNOWLEDGED:
            return ( s << L"ACKNOWLEDGED" );
        case BG_JOB_STATE_CANCELLED:
            return ( s << L"CANCELLED" );
        default:
            return ( s << L"UNKNOWN" );
        }
}

BITSOUTStream & operator<<( BITSOUTStream &s, BG_JOB_PRIORITY priority )
{
    switch(priority)
        {
        case BG_JOB_PRIORITY_FOREGROUND:
            return ( s << L"FOREGROUND" );
        case BG_JOB_PRIORITY_HIGH:
            return ( s << L"HIGH" );
        case BG_JOB_PRIORITY_NORMAL:
            return ( s << L"NORMAL" );
        case BG_JOB_PRIORITY_LOW:
            return ( s << L"LOW" );
        default:
            return ( s << L"UNKNOWN" );
        }
}

BG_JOB_PRIORITY JobInputPriority(  WCHAR *pText )
{
    if ( _wcsicmp( pText, L"FOREGROUND" )  == 0 )
        return BG_JOB_PRIORITY_FOREGROUND;
    if ( _wcsicmp( pText, L"HIGH" ) == 0 )
        return BG_JOB_PRIORITY_HIGH;
    if ( _wcsicmp( pText, L"NORMAL" ) == 0 )
        return BG_JOB_PRIORITY_NORMAL;
    if ( _wcsicmp( pText, L"LOW" ) == 0 )
        return BG_JOB_PRIORITY_LOW;

    bcout << L"Invalid priority.\n";
    throw AbortException(1);
}

SmartJobPointer
JobLookupViaDisplayName( const WCHAR * JobName )
{
     SmartEnumJobsPointer Enum;
     CheckBITSHR( L"Unable to lookup job", g_Manager->EnumJobs( 0, Enum.GetRecvPointer() ) );

     size_t FoundJobs = 0;
     SmartJobPointer FoundJob;

     SmartJobPointer Job;
     while( Enum->Next( 1, Job.GetRecvPointer(), NULL ) == S_OK )
         {

         PollShutdown();

         AutoStringPointer DisplayName;
         CheckBITSHR( L"Unable to lookup job", Job->GetDisplayName( DisplayName.GetRecvPointer() ) );

         if ( wcscmp( DisplayName, JobName) == 0 )
             {
             FoundJobs++;
             FoundJob = Job;
             }

         }

     if ( 1 == FoundJobs )
         {
         return FoundJob;
         }

     if ( !FoundJobs )
         {
         bcout << L"Unable to find job named \"" << JobName << L"\".\n";
         throw AbortException( 1 );
         }

     bcout << L"Found " << FoundJobs << L" jobs named \"" << JobName << L"\".\n";
     bcout << L"Use the job identifier instead of the job name.\n";

     throw AbortException( 1 );

}

SmartJobPointer
JobLookup( WCHAR * JobName )
{
    ConnectToBITS();

    GUID JobGuid;
    SmartJobPointer Job;
    if ( FAILED( CLSIDFromString( JobName, &JobGuid) ) )
        return JobLookupViaDisplayName( JobName );

    if ( FAILED( g_Manager->GetJob( JobGuid, Job.GetRecvPointer() ) ) )
        return JobLookupViaDisplayName( JobName );

    return Job;
}

SmartJobPointer
JobLookupForNoArg( int argc, WCHAR **argv )
{
    if (1 != argc)
        {
        bcout << L"Invalid number of arguments.\n";
        throw AbortException(1);
        }
    return JobLookup( argv[0] );
}

void JobValidateArgs( int argc, WCHAR**argv, int required )
{
    if ( argc != required )
        {
        bcout << L"Invalid number of arguments.\n";
        throw AbortException(1);
        }
}

//
// Actual command functions
//

void JobCreate( int argc, WCHAR **argv )
{
    GUID guid;
    SmartJobPointer Job;

    BG_JOB_TYPE type = BG_JOB_TYPE_DOWNLOAD;

    while (argc > 0)
        {
        if (argv[0][0] != '/')
            {
            break;
            }

        if ( !_wcsicmp( argv[0], L"/UPLOAD" ) )
            {
            type = BG_JOB_TYPE_UPLOAD;
            }
        else if ( !_wcsicmp( argv[0], L"/UPLOAD-REPLY" ) )
            {
            type = BG_JOB_TYPE_UPLOAD_REPLY;
            }
        else if ( !_wcsicmp( argv[0], L"/DOWNLOAD" ) )
            {
            type = BG_JOB_TYPE_DOWNLOAD;
            }
        else
            {
            bcout << L"Invalid argument.\n";
            throw AbortException(1);
            }

        --argc;
        ++argv;
        }

    JobValidateArgs( argc, argv, 1 );

    ConnectToBITS();

    CheckBITSHR( L"Unable to create group",
                 g_Manager->CreateJob( argv[0],
                                       type,
                                       &guid,
                                       Job.GetRecvPointer() ) );
    if (bRawReturn)
        bcout << Job;
    else
        bcout << L"Created job " << Job << L".\n";
}

void JobAddFile( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 3 );
     SmartJobPointer Job = JobLookup( argv[0] );
     CheckBITSHR( L"Unable to add file to job", Job->AddFile( argv[1], argv[2] ) );
     bcout << L"Added " << argv[1] << L" -> " << argv[2] << L" to job.\n";
}

size_t JobListFiles( SmartJobPointer Job, bool bDoIndent )
{
    SmartEnumFilesPointer Enum;
    CheckBITSHR( L"Unable to enum files in job", Job->EnumFiles( Enum.GetRecvPointer() ) );
    SmartFilePointer pFile;
    size_t FilesListed = 0;
    while( Enum->Next( 1, pFile.GetRecvPointer(), NULL ) == S_OK )
        {
        BG_FILE_PROGRESS progress;
        AutoStringPointer URL;
        AutoStringPointer Local;

        CheckBITSHR( L"Unable to get file progress", pFile->GetProgress( &progress ) );
        CheckBITSHR( L"Unable to get file URL", pFile->GetRemoteName( URL.GetRecvPointer() ) );
        CheckBITSHR( L"Unable to get local file name", pFile->GetLocalName( Local.GetRecvPointer() ) );

        if ( bDoIndent )
            bcout << L"\t";

        WCHAR *pCompleteText = progress.Completed ? L"COMPLETED" : L"WORKING";

        bcout << progress.BytesTransferred << L" / ";
        if ( progress.BytesTotal != (UINT64)-1 )
            {
            bcout << progress.BytesTotal;
            }
        else
            {
            bcout << L"UNKNOWN";
            }
        bcout << L" " << pCompleteText << L" " << URL << L" -> " << Local << L"\n";

        // Example output:
        // 10 / 1000 INCOMPLETE http://www.microsoft.com -> c:\temp\microsoft.htm

        FilesListed++;

        }
    return FilesListed;
}

void JobListFiles( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    size_t FilesListed = JobListFiles( Job, false );

    if (!bRawReturn)
        bcout << L"Listed " << FilesListed << L" file(s).\n";
}

void JobSuspend( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to suspend job", Job->Suspend() );
    bcout << L"Job suspended.\n";
}

void JobResume( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to resume job", Job->Resume() );
    bcout << L"Job resumed.\n";
}

void JobCancel( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to cancel job", Job->Cancel() );
    bcout <<  L"Job canceled.\n";
}

void JobComplete( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to complete job", Job->Complete() );
    bcout << L"Job completed.\n";
}

void JobGetType( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TYPE type;
    CheckBITSHR( L"Unable to get job type", Job->GetType(&type) );
    bcout << type;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetBytesTotal( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get total bytes in job", Job->GetProgress( &progress ) );
    bcout << progress.BytesTotal;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetBytesTransferred( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get bytes transferred in job", Job->GetProgress( &progress ) );
    bcout << progress.BytesTransferred;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetFilesTotal( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get number of files in job", Job->GetProgress( &progress ) );
    bcout << progress.FilesTotal;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetFilesTransferred( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get numeber of transferred files in job", Job->GetProgress( &progress ) );
    bcout << progress.FilesTransferred;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetCreationTime( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TIMES times;
    CheckBITSHR( L"Unable to get job creation time", Job->GetTimes( &times ) );
    bcout << times.CreationTime;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetModificationTime( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TIMES times;
    CheckBITSHR( L"Unable to get job modification time", Job->GetTimes( &times ) );
    bcout << times.ModificationTime;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetCompletionTime( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TIMES times;
    CheckBITSHR( L"Unable to get job completion time", Job->GetTimes( &times ) );
    if ( !times.TransferCompletionTime.dwLowDateTime && !times.TransferCompletionTime.dwHighDateTime )
        bcout << L"WORKING";
    else
        bcout << times.TransferCompletionTime;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetError( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    SmartJobErrorPointer Error;
    CheckBITSHR( L"Unable to get error", Job->GetError( Error.GetRecvPointer() ) );
    bcout << Error;
}

void JobGetState( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_STATE state;
    CheckBITSHR( L"Unable to get job state", Job->GetState( &state ) );
    bcout << state;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetOwner( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    AutoStringPointer Owner;
    CheckBITSHR( L"Unable to get job owner", Job->GetOwner( Owner.GetRecvPointer() ) );
    bcout << PrintSidString( Owner );
    if (!bRawReturn) bcout << L"\n";
}

void JobGetDisplayName( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    AutoStringPointer DisplayName;
    CheckBITSHR( L"Unable to get job displayname", Job->GetDisplayName( DisplayName.GetRecvPointer() ) );
    bcout << DisplayName;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetDisplayName( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     CheckBITSHR( L"Unable to set display name", Job->SetDisplayName( argv[1] ) );
     bcout << L"Display name set to " << argv[1] << L".\n";
}

void JobGetDescription( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    AutoStringPointer Description;
    CheckBITSHR( L"Unable to get job displayname", Job->GetDescription( Description.GetRecvPointer() ) );
    bcout << Description;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetDescription( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     CheckBITSHR( L"Unable to set description", Job->SetDescription( argv[1] ) );
     bcout << L"Description set to " << argv[1] << L".\n";
}

void JobGetReplyFileName( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    AutoStringPointer ReplyFileName;
    CheckBITSHR( L"Unable to get reply file name", Job2->GetReplyFileName( ReplyFileName.GetRecvPointer() ) );
    if (ReplyFileName)
        {
        bcout << L"'" << ReplyFileName << L"'";
        }
    else
        {
        bcout << L"(null)";
        }

    if (!bRawReturn) bcout << L"\n";
}

void JobSetReplyFileName( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     CheckBITSHR( L"Unable to set reply file name", Job2->SetReplyFileName( argv[1] ) );
     bcout << L"reply file name set to " << argv[1] << L".\n";
}

void JobGetReplyProgress( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    BG_JOB_REPLY_PROGRESS Progress;
    CheckBITSHR( L"Unable to get reply progress", Job2->GetReplyProgress( &Progress ) );

    bcout << L"progress: " << ULONG(Progress.BytesTransferred) << L" / ";

    if (Progress.BytesTotal == BG_SIZE_UNKNOWN)
        bcout << L"(unknown)";
    else
        bcout << ULONG(Progress.BytesTotal);

    bcout << L".\n";

    if (!bRawReturn) bcout << L"\n";
}

bool
printable( char c )
{
    if ( c < 32 )
        {
        return false;
        }

    if ( c > 126 )
        {
        return false;
        }

    return true;
}

void
DumpBuffer(
          void * Buffer,
          unsigned Length
          )
{
    const BYTES_PER_LINE = 16;

    unsigned char FAR *p = (unsigned char FAR *) Buffer;

    //
    // 3 chars per byte for hex display, plus an extra space every 4 bytes,
    // plus a byte for the printable representation, plus the \0.
    //
    const buflen = BYTES_PER_LINE*3+BYTES_PER_LINE/4+BYTES_PER_LINE;
    wchar_t Outbuf[buflen+1];
    Outbuf[0] = 0;
    Outbuf[buflen] = 0;
    wchar_t * HexDigits = L"0123456789abcdef";

    unsigned Index;
    for ( unsigned Offset=0; Offset < Length; Offset++ )
        {
        Index = Offset % BYTES_PER_LINE;

        if ( Index == 0 )
            {
            bcout << L"    " << Outbuf << L"\n";

            for (int i=0; i < buflen; ++i)
                {
                Outbuf[i] = L' ';
                }
            }

        Outbuf[Index*3+Index/4  ] = HexDigits[p[Offset] / 16];
        Outbuf[Index*3+Index/4+1] = HexDigits[p[Offset] % 16];
        Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+Index] = printable(p[Offset]) ? p[Offset] : L'.';
        }

    bcout << L"    " << Outbuf << L"\n";
}

void JobGetReplyData( int argc, WCHAR **argv )
{
    byte * Buffer = 0;
    UINT64 Length = 0;

    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    CheckBITSHR( L"Unable to get reply data", Job2->GetReplyData( &Buffer, &Length ) );

    bcout << L"data length is " << Length;
    DumpBuffer( Buffer, ULONG(Length) );
}

void JobGetNotifyCmdLine( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    LPWSTR Program = 0;
    LPWSTR Parms = 0;
    CheckBITSHR( L"Unable to get callback command line", Job2->GetNotifyCmdLine( &Program, &Parms ) );

    bcout << L"the notification command line is '" << Program << L"' '" << Program << L"'";

    if (!bRawReturn) bcout << L"\n";
}

void JobSetNotifyCmdLine( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 3 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     WCHAR * Program;
     WCHAR * Parameters;
     if (_wcsicmp( argv[1], L"NULL") == 0)
         {
         Program = NULL;
         }
     else
         {
         Program = argv[1];

         if (!GetFileType( Program ))
             {
             }
         }

     if (_wcsicmp( argv[2], L"NULL") == 0)
         {
         Parameters = NULL;
         }
     else
         {
         Parameters = argv[2];
         }

     CheckBITSHR( L"Unable to set the notification command line", Job2->SetNotifyCmdLine( Program, Parameters ) );
     bcout << L"notification command line set to '" << argv[1] << L"' '" << argv[2] << L"'.\n";
}



BG_AUTH_TARGET TargetFromString( LPCWSTR s )
{
    if (0 == _wcsicmp(s, L"server"))
        {
        return BG_AUTH_TARGET_SERVER;
        }
    else if (0 == _wcsicmp(s, L"proxy"))
        {
        return BG_AUTH_TARGET_PROXY;
        }

    bcout << L"'" << s << L"' is not a valid credential target.  It must be 'proxy' or 'server'.\n";
    throw AbortException( 1 );
}

struct
{
    LPCWSTR        Name;
    BG_AUTH_SCHEME Scheme;
}
SchemeNames[] =
{
    { L"basic",      BG_AUTH_SCHEME_BASIC },
    { L"digest",     BG_AUTH_SCHEME_DIGEST },
    { L"ntlm",       BG_AUTH_SCHEME_NTLM },
    { L"negotiate",  BG_AUTH_SCHEME_NEGOTIATE },
    { L"passport",   BG_AUTH_SCHEME_PASSPORT },

    { NULL,         BG_AUTH_SCHEME_BASIC }
};

BG_AUTH_SCHEME SchemeFromString( LPCWSTR s )
{
    int i;

    i = 0;
    while (SchemeNames[i].Name != NULL)
        {
        if (0 == _wcsicmp( s, SchemeNames[i].Name ))
            {
            return SchemeNames[i].Scheme;
            }

        ++i;
        }

    bcout << L"'" << s << L"is not a valid credential scheme.\n"
        L"It must be one of the following:\n"
        L"    basic\n"
        L"    digest\n"
        L"    ntlm\n"
        L"    negotiate\n"
        L"    passport\n";

    throw AbortException( 1 );
}


void JobSetCredentials( int argc, WCHAR **argv )
/*

    args:

        0:  job ID
        1:  "proxy" | "server"
        2:  "basic" | "digest" | "ntlm" | "negotiate" | "passport"
        3:  user name
        4:  password

*/
{
     JobValidateArgs( argc, argv, 5 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     BG_AUTH_CREDENTIALS cred;

     cred.Target = TargetFromString( argv[1] );
     cred.Scheme = SchemeFromString( argv[2] );

     cred.Credentials.Basic.UserName = argv[3];

     cred.Credentials.Basic.Password = argv[4];

     CheckBITSHR( L"Unable to add credentials", Job2->SetCredentials( &cred ));

     bcout << L"OK" << L".\n";
}

void JobRemoveCredentials( int argc, WCHAR **argv )
/*

    args:

        0:  job ID
        1:  "proxy" | "server"
        2:  "basic" | "digest" | "ntlm" | "negotiate" | "passport"

*/
{
     JobValidateArgs( argc, argv, 3 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     HRESULT hr;
     BG_AUTH_TARGET Target;
     BG_AUTH_SCHEME Scheme;

     Target = TargetFromString( argv[1] );
     Scheme = SchemeFromString( argv[2] );

     hr = Job2->RemoveCredentials( Target, Scheme );

     CheckBITSHR( L"Unable to remove credentials", hr);

     if (hr == S_FALSE)
         {
         bcout << L"no matching credential was found.\n";
         }
     else
         {
         bcout << L"OK" << L".\n";
         }
}


void JobGetPriority( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PRIORITY priority;
    CheckBITSHR( L"Unable to get job displayname", Job->GetPriority( &priority ) );
    bcout << priority;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetPriority( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     BG_JOB_PRIORITY priority = JobInputPriority(  argv[1] );
     CheckBITSHR( L"Unable to set description", Job->SetPriority( priority ) );
     bcout << L"Priority set to " << priority << L".\n";
}

void JobGetNotifyFlags( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG flags;
    CheckBITSHR( L"Unable to get notify flags", Job->GetNotifyFlags( &flags ) );
    bcout << flags;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetNotifyFlags( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     ULONG NewFlags = InputULONG( argv[1] );
     CheckBITSHR( L"Unable to set description", Job->SetNotifyFlags( NewFlags ) );
     bcout << L"Notification flags set to " << NewFlags << L".\n";
}

void JobGetNotifyInterface( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    SmartIUnknownPointer pUnknown;
    CheckBITSHR( L"Unable to get notify interface", Job->GetNotifyInterface( pUnknown.GetRecvPointer() ) );
    if ( pUnknown.Get() )
        bcout << L"REGISTERED";
    else
        bcout << L"UNREGISTERED";
    if (!bRawReturn) bcout << L"\n";
}

void JobSetMinimumRetryDelay( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     ULONG NewDelay = InputULONG( argv[1] );
     CheckBITSHR( L"Unable to set new minimum retry delay", Job->SetMinimumRetryDelay( NewDelay ) );
     bcout << L"Minimum retry delay set to " << NewDelay << L".\n";
}

void JobGetMinimumRetryDelay( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG delay;
    CheckBITSHR( L"Unable to get minimum retry delay", Job->GetMinimumRetryDelay( &delay ) );
    bcout << delay;
    if (!bRawReturn) bcout << L"\n";
}


void JobGetNoProgressTimeout( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG timeout;
    CheckBITSHR( L"Unable to get no progress timeout", Job->GetNoProgressTimeout( &timeout ) );
    bcout << timeout;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetNoProgressTimeout( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     ULONG NewTimeout = InputULONG( argv[1] );
     CheckBITSHR( L"Unable to set new no progress timeout", Job->SetNoProgressTimeout( NewTimeout ) );
     bcout << L"No progress timeout set to " << NewTimeout << L".\n";
}

void JobGetErrorCount( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG errors;
    CheckBITSHR( L"Unable to get no progress timeout", Job->GetErrorCount( &errors ) );
    bcout << errors;
    if (!bRawReturn) bcout << L"\n";
}

void JobInfo( SmartJobPointer Job )
{
     GUID id;
     BG_JOB_STATE    state;
     BG_JOB_PROGRESS progress;
     AutoStringPointer DisplayName;

     CheckBITSHR( L"Unable to get job ID",       Job->GetId( &id ));
     CheckBITSHR( L"Unable to get job state",    Job->GetState( &state ));
     CheckBITSHR( L"Unable to get job progress", Job->GetProgress( &progress ));
     CheckBITSHR( L"Unable to get display name", Job->GetDisplayName( DisplayName.GetRecvPointer() ) );

     bcout << id << L" " << DisplayName << L" " << state;
     bcout << L" " << progress.FilesTransferred << L" / " << progress.FilesTotal;
     bcout << L" " << progress.BytesTransferred << L" / ";
     if ( (UINT64)-1 == progress.BytesTotal )
         bcout << L"UNKNOWN";
     else
         bcout << progress.BytesTotal;
     bcout << L"\n";
}

void JobVerboseInfo( SmartJobPointer Job )
{
    GUID id;
    AutoStringPointer Display;
    BG_JOB_TYPE type;
    BG_JOB_STATE state;
    AutoStringPointer Owner;
    BG_JOB_PRIORITY priority;
    BG_JOB_PROGRESS progress;
    BG_JOB_TIMES times;
    SmartIUnknownPointer Notify;
    ULONG NotifyFlags;
    ULONG retrydelay;
    ULONG noprogresstimeout;
    ULONG ErrorCount;
    AutoStringPointer Description;
    SmartJobErrorPointer Error;
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;

    bool fShow15Fields;
    SmartJob2Pointer Job2;
    BG_JOB_REPLY_PROGRESS ReplyProgress;
    AutoStringPointer ReplyFileName;
    AutoStringPointer NotifyProgram;
    AutoStringPointer NotifyParms;

    CheckBITSHR( L"Unable to get job ID",                    Job->GetId( &id) );
    CheckBITSHR( L"Unable to get job display name",          Job->GetDisplayName(Display.GetRecvPointer()) );
    CheckBITSHR( L"Unable to get job type",                  Job->GetType( &type ) );
    CheckBITSHR( L"Unable to get job state",                 Job->GetState( &state ) );
    CheckBITSHR( L"Unable to get job owner",                 Job->GetOwner( Owner.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get job priority",              Job->GetPriority( &priority ) );
    CheckBITSHR( L"Unable to get job progress",              Job->GetProgress( &progress ) );
    CheckBITSHR( L"Unable to get job times",                 Job->GetTimes( &times ) );
    bool NotifyAvailable = SUCCEEDED( Job->GetNotifyInterface( Notify.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get job notification flags",    Job->GetNotifyFlags( &NotifyFlags ) );
    CheckBITSHR( L"Unable to get job retry delay",           Job->GetMinimumRetryDelay( &retrydelay ) );
    CheckBITSHR( L"Unable to get job no progress timeout",   Job->GetNoProgressTimeout( &noprogresstimeout ) );
    CheckBITSHR( L"Unable to get job error count",           Job->GetErrorCount( &ErrorCount ) );
    CheckBITSHR( L"Unable to get job description",           Job->GetDescription( Description.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get proxy settings",            Job->GetProxySettings( &ProxyUsage,
                                                                                    ProxyList.GetRecvPointer(),
                                                                                    ProxyBypassList.GetRecvPointer() ) );

    if (FAILED(Job->GetError( Error.GetRecvPointer() )) )
        Error.Clear();

    if (SUCCEEDED(Job2FromJob( Job, Job2 )))
        {
        fShow15Fields = true;
        CheckBITSHR( L"unable to get notification command line",
                     Job2->GetNotifyCmdLine( NotifyProgram.GetRecvPointer(),  NotifyParms.GetRecvPointer() ));

        if (type == BG_JOB_TYPE_UPLOAD_REPLY )
            {
            CheckBITSHR( L"unable to get reply progress",  Job2->GetReplyProgress( &ReplyProgress ));
            CheckBITSHR( L"unable to get reply file name", Job2->GetReplyFileName( ReplyFileName.GetRecvPointer() ));
            }
        }
    else
        {
        fShow15Fields = false;
        }

    // Example output
    // GUID: {F196178C-0C00-4E92-A8AD-1F44E30C2485} DISPLAY: Test Job
    // TYPE: DOWNLOAD STATE: SUSPENDED OWNER: ntdev\somedev
    // PRIORITY: NORMAL FILES: 0 / 0 BYTES: 0 / 0
    // CREATION TIME: 5:29:35 PM 11/9/2000 MODIFICATION TIME: 5:29:35 PM 11/9/2000
    // COMPLETION TIME: 5:29:35 PM 11/9/2000
    // NOTIFY INTERFACE: 00000000 NOTIFICATION FLAGS: 3
    // RETRY DELAY: 300 NO PROGRESS TIMEOUT: 1209600 ERROR COUNT: 0
    // PROXY USAGE: PRECONFIG PROXY LIST: NULL PROXY BYPASS LIST: NULL
    // [ error info ]
    // DESCRIPTION:
    // [ file list ]

    //
    // Additional output for BITS 1.5:
    // NOTIFICATION COMMAND LINE: NULL
    // REPLY FILE: 'C:\foo\replyfile' 10 / 1000
    //

    bcout << AddIntensity() << L"GUID: " << ResetIntensity() << id << AddIntensity() << L" DISPLAY: " << ResetIntensity() << Display << L"\n";

    bcout << AddIntensity() << L"TYPE: " << ResetIntensity() << type;
    bcout << AddIntensity() << L" STATE: " << ResetIntensity() << state;
    bcout << AddIntensity() << L" OWNER: " << ResetIntensity() << PrintSidString( Owner ) << L"\n";

    bcout << AddIntensity() << L"PRIORITY: " << ResetIntensity() << priority;
    bcout << AddIntensity() << L" FILES: " << ResetIntensity() << progress.FilesTransferred << L" / " << progress.FilesTotal;
    bcout << AddIntensity() << L" BYTES: " << ResetIntensity() << progress.BytesTransferred << L" / ";
    if ( (UINT64)-1 == progress.BytesTotal )
        bcout << L"UNKNOWN";
    else
        bcout << progress.BytesTotal;
    bcout << L"\n";

    bcout << AddIntensity() << L"CREATION TIME: " << ResetIntensity() << times.CreationTime;
    bcout << AddIntensity() << L" MODIFICATION TIME: " << ResetIntensity() << times.ModificationTime << L"\n";

    bcout << AddIntensity() << L"COMPLETION TIME: " << ResetIntensity() << times.TransferCompletionTime << L"\n";

    bcout << AddIntensity() << L"NOTIFY INTERFACE: " << ResetIntensity();

    if ( NotifyAvailable )
        {
        if ( Notify.Get() )
            bcout << L"REGISTERED";
        else
            bcout << L"UNREGISTERED";
        }
    else
        bcout << L"UNAVAILABLE";

    bcout << AddIntensity() << L" NOTIFICATION FLAGS: " << ResetIntensity() << NotifyFlags << L"\n";

    bcout << AddIntensity() << L"RETRY DELAY: " << ResetIntensity() << retrydelay;
    bcout << AddIntensity() << L" NO PROGRESS TIMEOUT: " << ResetIntensity() << noprogresstimeout;
    bcout << AddIntensity() << L" ERROR COUNT: " << ResetIntensity() << ErrorCount << L"\n";

    bcout << AddIntensity() << L"PROXY USAGE: " << ResetIntensity() << ProxyUsage;
    bcout << AddIntensity() << L" PROXY LIST: " << ResetIntensity() << ( (WCHAR*)ProxyList ? (WCHAR*)ProxyList : L"NULL" );
    bcout << AddIntensity() << L" PROXY BYPASS LIST: " << ResetIntensity() << ((WCHAR*)ProxyBypassList ? (WCHAR*)ProxyBypassList : L"NULL" );
    bcout << L"\n";

    if ( Error.Get() )
        bcout << Error;

    bcout << AddIntensity() << L"DESCRIPTION: " << ResetIntensity() << Description << L"\n";
    bcout << AddIntensity() << L"JOB FILES: \n" << ResetIntensity();
    JobListFiles( Job, true );

    if (fShow15Fields)
        {
        bcout << AddIntensity() << L"NOTIFICATION COMMAND LINE: " << ResetIntensity();

        if (NotifyProgram)
            {
            bcout << L"'" << NotifyProgram << L"'";

            if (NotifyParms)
                {
                bcout << L" '" << NotifyParms << L"'";
                }
            }
        else
            {
            bcout << L"none";
            }

        bcout << L"\n";

        if (type == BG_JOB_TYPE_UPLOAD_REPLY )
            {
            bcout << AddIntensity() << L"REPLY FILE: " << ResetIntensity();

            if (LPCWSTR(ReplyFileName) == NULL)
                {
                bcout << L"none\n";
                }
            else
                {
                bcout << L"'" << ReplyFileName << L"'  ";
                bcout << ReplyProgress.BytesTransferred << L" / ";
                if ( (UINT64)-1 == ReplyProgress.BytesTotal )
                    bcout << L"UNKNOWN";
                else
                    bcout << ReplyProgress.BytesTotal;
                bcout << L"\n";
                }
            }
        }
}

void JobInfo( int argc, WCHAR **argv )
{
     if ( ( argc != 1 ) && (argc != 2 ) )
         {
         bcout << L"Invalid argument.\n";
         throw AbortException(1);
         }

     bool Verbose = false;
     if ( 2 == argc )
         {

         if ( !_wcsicmp( argv[1], L"/VERBOSE" ) )
             Verbose = true;
         else
             {
             bcout << L"Invalid argument.\n";
             throw AbortException(1);
             }

         }

     SmartJobPointer Job = JobLookup( argv[0] );

     if ( Verbose )
         JobVerboseInfo( Job );
     else
         JobInfo( Job );
}

size_t JobList( bool Verbose, bool AllUsers )
{
     DWORD dwFlags = 0;
     if ( AllUsers )
         dwFlags |= BG_JOB_ENUM_ALL_USERS;

     size_t JobsListed = 0;
     SmartEnumJobsPointer Enum;
     CheckBITSHR( L"Unable to enum jobs", g_Manager->EnumJobs( dwFlags, Enum.GetRecvPointer() ) );
     SmartJobPointer Job;
     while( Enum->Next( 1, Job.GetRecvPointer(), NULL ) == S_OK )
         {
         if ( Verbose )
             {
             JobVerboseInfo( Job );
             bcout << L"\n";
             }
         else
             JobInfo( Job );
         JobsListed++;
         }
     Enum.Release();
     Job.Release();
     return JobsListed;
}

void JobList( int argc, WCHAR **argv )
{
     if ( argc > 2 )
         {
         bcout << L"Invalid number of arguments.\n";
         throw AbortException(1);
         }

     bool Verbose = false;
     bool AllUsers = false;

     for( int i = 0; i < argc; i++)
         {
         if ( !_wcsicmp( argv[i], L"/VERBOSE" ) )
             {
             Verbose = true;
             }
         else if ( !_wcsicmp( argv[i], L"/ALLUSERS" ) )
             {
             AllUsers = true;
             }
         else
             {
             bcout << L"Invalid argument.\n";
             throw AbortException(1);
             }
         }

     ConnectToBITS();
     size_t JobsListed = JobList( Verbose, AllUsers );

     if (!bRawReturn)
         bcout << L"Listed " << JobsListed << L" job(s).\n";
}

void JobMonitor( int argc, WCHAR**argv )
{
    DWORD dwSleepSeconds = 5;
    bool AllUsers = false;

    // the default wrap is different for the /monitor command
    if ( !bExplicitWrap )
        {
        bWrap = false;
        ChangeConsoleMode();
        }

    if ( argc > 3 )
        {
        bcout << L"Invalid number of arguments.\n";
        throw AbortException( 1 );
        }

    for( int i=0; i < argc; i++ )
        {
        if ( !_wcsicmp( argv[i], L"/ALLUSERS" ) )
            {
            AllUsers = true;
            }
        else if ( !_wcsicmp( argv[i], L"/REFRESH" ) )
            {
            i++;
            if ( i >= argc )
                {
                bcout << L"/REFRESH is missing the refresh rate.";
                throw AbortException(1);
                }
            dwSleepSeconds = InputULONG( argv[i] );
            }
        else
            {
            bcout << L"Invalid argument.\n";
            throw AbortException(1);
            }
        }

    if ( GetFileType( bcout.GetHandle() ) != FILE_TYPE_CHAR )
    {
        bcerr << L"/MONITOR will not work with a redirected stdout.\n";
        throw AbortException(1);
    }

    ConnectToBITS();

    for(;;)
    {
        ClearScreen();
        bcout << L"MONITORING BACKGROUND COPY MANAGER(" << dwSleepSeconds << L" second refresh)\n";
        JobList( false, AllUsers );
        SleepEx( dwSleepSeconds * 1000, TRUE );
        PollShutdown();
    }
}

void JobReset( int argc, WCHAR **argv )
{
    JobValidateArgs( argc, argv, 0 );
    ConnectToBITS();

    ULONG JobsFound = 0;
    ULONG JobsCanceled = 0;

    SmartEnumJobsPointer Enum;
    CheckBITSHR( L"Unable to enum jobs", g_Manager->EnumJobs( 0, Enum.GetRecvPointer() ) );
    SmartJobPointer Job;
    while( Enum->Next( 1, Job.GetRecvPointer(), NULL ) == S_OK )
        {
        JobsFound++;
        if (SUCCEEDED( Job->Cancel() ) )
            {
            bcout << Job << L" canceled.\n";
            JobsCanceled++;
            }
        }

    bcout << JobsCanceled << L" out of " << JobsFound << L" jobs canceled.\n";
}

void JobGetProxyUsage( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;
    CheckBITSHR( L"Unable to get proxy usage",
                 Job->GetProxySettings( &ProxyUsage, ProxyList.GetRecvPointer(), ProxyBypassList.GetRecvPointer() ) );
    bcout << ProxyUsage;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetProxyList( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;
    CheckBITSHR( L"Unable to get proxy list",
                 Job->GetProxySettings( &ProxyUsage, ProxyList.GetRecvPointer(), ProxyBypassList.GetRecvPointer() ) );
    bcout << ( (WCHAR*)ProxyList ? (WCHAR*)ProxyList : L"NULL");
    if (!bRawReturn) bcout << L"\n";
}

void JobGetProxyBypassList( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;
    CheckBITSHR( L"Unable to get proxy bypass list",
                 Job->GetProxySettings( &ProxyUsage, ProxyList.GetRecvPointer(), ProxyBypassList.GetRecvPointer() ) );
    bcout << ( (WCHAR*)ProxyBypassList ? (WCHAR*)ProxyBypassList : L"NULL");
    if (!bRawReturn) bcout << L"\n";
}

WCHAR *
FindMatching( WCHAR *pStr, WCHAR start, WCHAR finish, ULONG CurrentLevel )
{
    while( *pStr != L'\0' )
    {

        if ( start == *pStr )
            CurrentLevel++;
        else if ( finish == *pStr )
            CurrentLevel--;

        if ( !CurrentLevel )
            return pStr;

        pStr++;
    }

    return NULL;
}

void JobSetProxySettings( int argc, WCHAR **argv )
{
    if (argc < 2)
        {
        bcout << L"/SetProxySettings must be followed by a job name or guid, then a proxy usage name\n";
        throw AbortException(1);
        }

     SmartJobPointer Job = JobLookup( argv[0] );

     WCHAR *pSettings = argv[1];
     // The format of the settings is usage,<ProxyList>,<ProxyBypassList>

     WCHAR *pEndUsage = wcsstr( pSettings, L"," );
     if ( !pEndUsage )
         pEndUsage = pSettings + wcslen( pSettings );

     size_t UsageSize = ((char*)pEndUsage - (char*)pSettings)/sizeof(WCHAR);
     AutoStringPointer Usage( new WCHAR[UsageSize + 1] );
     memcpy( Usage.Get(), pSettings, UsageSize * sizeof(WCHAR) );
     Usage.Get()[UsageSize] = L'\0';

     BG_JOB_PROXY_USAGE ProxyUsage;
     if ( _wcsicmp( Usage, L"PRECONFIG" ) == 0 )
         {
         ProxyUsage = BG_JOB_PROXY_USAGE_PRECONFIG;
         CheckBITSHR( L"Unable to set proxy settings", Job->SetProxySettings( ProxyUsage, NULL, NULL ) );
         bcout << L"Proxy usage set to " << ProxyUsage << L".\n";
         return;
         }
     else if ( _wcsicmp( Usage, L"NO_PROXY" ) == 0 )
         {
         ProxyUsage = BG_JOB_PROXY_USAGE_NO_PROXY;
         CheckBITSHR( L"Unable to set proxy settings", Job->SetProxySettings( ProxyUsage, NULL, NULL ) );
         bcout << L"Proxy usage set to " << ProxyUsage << L".\n";
         return;
         }
     else if ( _wcsicmp( Usage, L"OVERRIDE" ) == 0 )
         {
         if (argc != 4)
             {
             bcout << L"OVERRIDE must be followed by a proxy list and a proxy bypass list\n";
             throw AbortException(1);
             }

         ProxyUsage = BG_JOB_PROXY_USAGE_OVERRIDE;
         }
     else
         {
         bcout << L"proxy usage must be one of OVERRIDE, NO_PROXY, or PRECONFIG\n";
         throw AbortException(0);
         }

     WCHAR * ProxyList = argv[2];
     WCHAR * ProxyBypassList = argv[3];

     if ( _wcsicmp( ProxyList, L"NULL" ) == 0 )
         {
         ProxyList = NULL;
         }

     if ( _wcsicmp( ProxyBypassList, L"NULL" ) == 0 )
         {
         ProxyBypassList = NULL;
         }

     CheckBITSHR( L"Unable to set proxy settings", Job->SetProxySettings( ProxyUsage, ProxyList, ProxyBypassList ) );
     bcout << L"Proxy usage set to " << ProxyUsage << L".\n";
     bcout << L"Proxy list set to " << ( ProxyList ? ProxyList : L"NULL" )<< L".\n";
     bcout << L"Proxy bypass list set to " << ( ProxyBypassList ? ProxyBypassList : L"NULL" ) << L".\n";
}

void JobTakeOwnership( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to take ownership", Job->TakeOwnership() );
    bcout << L"Took ownership of " << Job << L".\n";
}

void PrintBanner()
{
    const char ProductVer[] = VER_PRODUCTVERSION_STR;
    // double for extra protection
    wchar_t WProductVer[ sizeof(ProductVer) * 2];

    memset( WProductVer, 0, sizeof(WProductVer) );
    mbstowcs( WProductVer, ProductVer, sizeof(ProductVer) );

    bcout <<
        L"\n" <<
        L"BITSADMIN version 1.5 [ " << WProductVer << L" ]\n" <<
        L"BITS administration utility.\n" <<
        L"(C) Copyright 2000-2002 Microsoft Corp.\n" <<
        L"\n";

}

const wchar_t UsageLine[] = L"USAGE: BITSADMIN [/RAWRETURN] [/WRAP | /NOWRAP] command\n";

void JobHelp()
{
    bcout << UsageLine;
    bcout <<
        L"The following commands are available:\n"
        L"\n"
        L"/HELP                                    Prints this help \n"
        L"/?                                       Prints this help \n"
        L"/LIST [/ALLUSERS] [/VERBOSE]             List the jobs\n"
        L"/MONITOR [/ALLUSERS] [/REFRESH sec]      Monitors the copy manager\n"
        L"/RESET                                   Deletes all jobs in the manager\n"
        L"/CREATE [type] display_name              Creates a job\n"
        L"    [type] may be /DOWNLOAD, /UPLOAD, or /UPLOAD-REPLY; default is download\n"
        L"\n"
        L"/INFO job [/VERBOSE]               Displays information about the job\n"
        L"/ADDFILE job remote_url local_name Adds a file to the job\n"
        L"/LISTFILES job                     Lists the files in the job\n"
        L"/SUSPEND job                       Suspends the job\n"
        L"/RESUME job                        Resumes the job\n"
        L"/CANCEL job                        Cancels the job\n"
        L"/COMPLETE job                      Completes the job\n"
        L"\n"
        L"/GETTYPE job                       Retrieves the job type\n"
        L"/GETBYTESTOTAL job                 Retrieves the size of the job\n"
        L"/GETBYTESTRANSFERRED job           Retrieves the number of bytes transferred\n"
        L"/GETFILESTOTAL job                 Retrieves the number of files in the job\n"
        L"/GETFILESTRANSFERRED job           Retrieves the number of files transferred\n"
        L"/GETCREATIONTIME job               Retrieves the job creation time\n"
        L"/GETMODIFICATIONTIME job           Retrieves the job modification time\n"
        L"/GETCOMPLETIONTIME job             Retrieves the job completion time\n"
        L"/GETSTATE job                      Retrieves the job state\n"
        L"/GETERROR job                      Retrieves detailed error information\n"
        L"/GETOWNER job                      Retrieves the job owner\n"
        L"/GETDISPLAYNAME job                Retrieves the job display name\n"
        L"/SETDISPLAYNAME job display_name   Sets the job display name\n"
        L"/GETDESCRIPTION job                Retrieves the job description\n"
        L"/SETDESCRIPTION job description    Sets the job description\n"
        L"/GETPRIORITY    job                Retrieves the job priority\n"
        L"/SETPRIORITY    job priority       Sets the job priority\n"
        L"/GETNOTIFYFLAGS job                Retrieves the notify flags\n"
        L"/SETNOTIFYFLAGS job notify_flags   Sets the notify flags\n"
        L"/GETNOTIFYINTERFACE job            Determines if notify interface is registered\n"
        L"/GETMINRETRYDELAY job              Retrieves the retry delay in seconds\n"
        L"/SETMINRETRYDELAY job retry_delay  Sets the retry delay in seconds\n"
        L"/GETNOPROGRESSTIMEOUT job          Retrieves the no progress timeout in seconds\n"
        L"/SETNOPROGRESSTIMEOUT job timeout  Sets the no progress timeout in seconds\n"
        L"/GETERRORCOUNT job                 Retrieves an error count for the job\n"
        L"\n"
        L"/SETPROXYSETTINGS job <usage>      Sets the proxy usage\n"
        L"   usage choices:\n"
        L"    PRECONFIG   - Use the owner's IE defaults.\n"
        L"    NO_PROXY    - Do not use a proxy server.\n"
        L"    OVERRIDE    - Use an explicit proxy list and bypass list. \n"
        L"                  Must be followed by a proxy list and a proxy bypass list.\n"
        L"                  NULL or \"\" may be used for an empty proxy bypass list.\n"
        L"  Examples:\n"
        L"      bitsadmin /setproxysettings MyJob PRECONFIG\n"
        L"      bitsadmin /setproxysettings MyJob NO_PROXY\n"
        L"      bitsadmin /setproxysettings MyJob OVERRIDE proxy1:80 \"<local>\" \n"
        L"      bitsadmin /setproxysettings MyJob OVERRIDE proxy1,proxy2,proxy3 NULL \n"
        L"\n"
        L"/GETPROXYUSAGE job                 Retrieves the proxy usage setting\n"
        L"/GETPROXYLIST job                  Retrieves the proxy list\n"
        L"/GETPROXYBYPASSLIST job            Retrieves the proxy bypass list\n"
        L"\n"
        L"/TAKEOWNERSHIP job                 Take ownership of the job\n"
        L"\n"
        L"/SETNOTIFYCMDLINE job program_name [program_parameters] \n"
        L"    Sets a program to execute for notification, and optionally parameters.\n"
        L"    The program name and parameters can be NULL.\n"
        L"\n"
        L"  Examples:\n"
        L"    bitsadmin /SetNotifyCmdLine MyJob c:\\winnt\\system32\\notepad.exe  NULL\n"
        L"    bitsadmin /SetNotifyCmdLine MyJob c:\\handler.exe \"parm1 parm2 parm3\" \n"
        L"    bitsadmin /SetNotifyCmdLine MyJob NULL NULL\n"
        L"\n"
        L"/GETNOTIFYCMDLINE job              returns the job's notification command line\n"
        L"\n"
        L"/SETCREDENTIALS job <target> <scheme> <username> <password>\n"
        L"  Adds credentials to a job.\n"
        L"  <target> may be either SERVER or PROXY\n"
        L"  <scheme> may be BASIC, DIGEST, NTLM, NEGOTIATE, or PASSPORT. \n"
        L"\n"
        L"/REMOVECREDENTIALS job <target> <scheme> \n"
        L"  Removes credentials from a job.\n"
        L"\n"
        L"The following options are valid for UPLOAD-REPLY jobs only:\n"
        L"\n"
        L"/GETREPLYFILENAME job      Gets the path of the file containing the server reply\n"
        L"/SETREPLYFILENAME job path Sets the path of the file containing the server reply\n"
        L"/GETREPLYPROGRESS job      Gets the size and progress of the server reply\n"
        L"/GETREPLYDATA     job      Dumps the server's reply data in hex format\n"
        L"\n"
        L"The following options can be placed before the command:\n"
        L"/RAWRETURN                         Return data more suitable for parsing\n"
        L"/WRAP                              Wrap output around console (default)\n"
        L"/NOWRAP                            Don't wrap output around console\n"
        L"\n"
        L"The /RAWRETURN option strips new line characters and formatting.\n"
        L"It is recognized by the /CREATE and /GET* commands.\n"
        L"\n"
        L"Commands that take a job parameter will accept either a job name or a job-ID\n"
        L"GUID inside braces.  BITSADMIN reports an error if a name is ambiguous.\n";
}

void JobHelpAdapter( int, WCHAR ** )
{
    JobHelp();
}

void JobNotImplemented( int, WCHAR ** )
{
    bcout << L"Not implemented.\n";
    throw AbortException(1);
}

const PARSEENTRY JobParseTableEntries[] =
{
    {L"/HELP",                  JobHelpAdapter },
    {L"/?",                     JobHelpAdapter },
    {L"/LIST",                  JobList },
    {L"/MONITOR",               JobMonitor },
    {L"/RESET",                 JobReset },
    {L"/CREATE",                JobCreate },
    {L"/INFO",                  JobInfo },
    {L"/ADDFILE",               JobAddFile },
    {L"/LISTFILES",             JobListFiles },
    {L"/SUSPEND",               JobSuspend },
    {L"/RESUME",                JobResume },
    {L"/CANCEL",                JobCancel },
    {L"/COMPLETE",              JobComplete },
    {L"/GETTYPE",               JobGetType },
    {L"/GETBYTESTOTAL",         JobGetBytesTotal },
    {L"/GETBYTESTRANSFERRED",   JobGetBytesTransferred },
    {L"/GETFILESTOTAL",         JobGetFilesTotal },
    {L"/GETFILESTRANSFERRED",   JobGetFilesTransferred },
    {L"/GETCREATIONTIME",       JobGetCreationTime },
    {L"/GETMODIFICATIONTIME",   JobGetModificationTime },
    {L"/GETCOMPLETIONTIME",     JobGetCompletionTime },
    {L"/GETSTATE",              JobGetState },
    {L"/GETERROR",              JobGetError },
    {L"/GETOWNER",              JobGetOwner },
    {L"/GETDISPLAYNAME",        JobGetDisplayName },
    {L"/SETDISPLAYNAME",        JobSetDisplayName },
    {L"/GETDESCRIPTION",        JobGetDescription },
    {L"/SETDESCRIPTION",        JobSetDescription },
    {L"/GETPRIORITY",           JobGetPriority },
    {L"/SETPRIORITY",           JobSetPriority },
    {L"/GETNOTIFYFLAGS",        JobGetNotifyFlags },
    {L"/SETNOTIFYFLAGS",        JobSetNotifyFlags },
    {L"/GETNOTIFYINTERFACE",    JobGetNotifyInterface },
    {L"/GETMINRETRYDELAY",      JobGetMinimumRetryDelay },
    {L"/SETMINRETRYDELAY",      JobSetMinimumRetryDelay },
    {L"/GETNOPROGRESSTIMEOUT",  JobGetNoProgressTimeout },
    {L"/SETNOPROGRESSTIMEOUT",  JobSetNoProgressTimeout },
    {L"/GETERRORCOUNT",         JobGetErrorCount },
    {L"/GETPROXYUSAGE",         JobGetProxyUsage },
    {L"/GETPROXYLIST",          JobGetProxyList },
    {L"/GETPROXYBYPASSLIST",    JobGetProxyBypassList },
    {L"/SETPROXYSETTINGS",      JobSetProxySettings },
    {L"/TAKEOWNERSHIP",         JobTakeOwnership },
    {L"/GETREPLYFILENAME",      JobGetReplyFileName },
    {L"/SETREPLYFILENAME",      JobSetReplyFileName },
    {L"/GETREPLYPROGRESS",      JobGetReplyProgress },
    {L"/GETREPLYDATA",          JobGetReplyData },
    {L"/GETNOTIFYCMDLINE",      JobGetNotifyCmdLine },
    {L"/SETNOTIFYCMDLINE",      JobSetNotifyCmdLine },
    {L"/SETCREDENTIALS",        JobSetCredentials },
    {L"/REMOVECREDENTIALS",     JobRemoveCredentials },
    {NULL,                      NULL }
};

const PARSETABLE JobParseTable =
{
    JobParseTableEntries,
    JobHelpAdapter,
    NULL
};

void ParseCmdAdapter( int argc, WCHAR **argv, void *pContext )
{
    ParseCmd( argc, argv, (const PARSETABLE *) pContext );
}

BOOL ControlHandler( DWORD Event )
{
    switch( Event )
        {
        case CTRL_C_EVENT:
        case CTRL_CLOSE_EVENT:
            SignalShutdown( 5000 );
            return TRUE;

        case CTRL_BREAK_EVENT:
            SignalShutdown( 500 );
            return TRUE;

        default:
            return FALSE;
        }
}

int _cdecl wmain(int argc, WCHAR **argv )
{

    //
    // Wrap long lines by default.  /NOWRAP overrides this.
    //
    bWrap = true;

    try
    {

        DuplicateHandle(
            GetCurrentProcess(),    // handle to source process
            GetCurrentThread(),     // handle to duplicate
            GetCurrentProcess(),    // handle to target process
            &g_MainThreadHandle,    // duplicate handle
            0,                      // requested access
            TRUE,                   // handle inheritance option
            DUPLICATE_SAME_ACCESS   // optional actions
            );

        SetConsoleCtrlHandler( ControlHandler, TRUE );

        BITSADMINSetThreadUILanguage();

        _wsetlocale (LC_COLLATE, L".OCP" );    // sets the sort order
        _wsetlocale (LC_MONETARY, L".OCP" ); // sets the currency formatting rules
        _wsetlocale (LC_NUMERIC, L".OCP" );  // sets the formatting of numerals
        _wsetlocale (LC_TIME, L".OCP" );     // defines the date/time formatting

        // skip command name
        argc--;
        argv++;

        if ( 0 == argc )
            {

            PrintBanner();
            bcout << UsageLine;
            return 0;
            }

        // parse /RAWRETURN
        if ( argc >= 1 && ( _wcsicmp( argv[0], L"/RAWRETURN" ) ==  0 ))
            {
            bRawReturn = true;

            // skip /RAWRETURN
            argc--;
            argv++;
            }

        // parse /WRAP
        if ( argc >= 1 && ( _wcsicmp( argv[0], L"/WRAP" ) ==  0 ))
            {
            bWrap           = true;
            bExplicitWrap   = true;

            // skip /WRAP
            argc--;
            argv++;
            }

        // parse /NOWRAP
        if ( argc >= 1 && ( _wcsicmp( argv[0], L"/NOWRAP" ) ==  0 ))
            {
            bWrap           = false;
            bExplicitWrap   = true;

            // skip /NOWRAP
            argc--;
            argv++;
            }


        if ( !bRawReturn )
            PrintBanner();

#ifdef DBG

        // parse /COMPUTERNAME

        if ( argc >= 1 && ( _wcsicmp( argv[0], L"/COMPUTERNAME" ) == 0 ))
            {
            argc--;
            argv++;

            if (argc < 1)
                {
                bcout << L"/COMPUTERNAME option is missing the computer name.\n";
                throw AbortException(1);
                }

            pComputerName = argv[0];
            argc--;
            argv++;

            }
#endif



        CheckHR( L"Unable to initialize COM", CoInitializeEx(NULL, COINIT_MULTITHREADED ) );

        SetupConsole();
        ParseCmd( argc, argv, &JobParseTable );

        g_Manager.Clear();
        CoUninitialize();
        bcout.FlushBuffer();
        RestoreConsole();

        if ( g_MainThreadHandle )
            CloseHandle( g_MainThreadHandle );

    }
    catch( AbortException & Exception )
    {
        bcout.FlushBuffer();
        RestoreConsole();
        exit( Exception.Code );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\select\test\opt\main.cxx ===
#include "headers.hxx"
#pragma hdrstop
#include "glopres.h"

const wchar_t* RUNTIME_NAME = L"opt";
#define DOWNLEVEL_FILTER_BIT        0x80000000

unsigned long  DEFAULT_LOGGING_OPTIONS = 0;
HINSTANCE hResourceModuleHandle;
#define ARRAYLEN(a)                             (sizeof(a) / sizeof((a)[0]))

#define DBG_OUT_HRESULT(hr) printf("error 0x%x at line %u\n", hr, __LINE__)


#define BREAK_ON_FAIL_HRESULT(hr)   \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            break;                  \
        }
enum SCOPE_TYPE
{
    ST_INVALID = 0,
    ST_TARGET_COMPUTER              = DSOP_SCOPE_TYPE_TARGET_COMPUTER,
    ST_UPLEVEL_JOINED_DOMAIN        = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
    ST_DOWNLEVEL_JOINED_DOMAIN      = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,
    ST_ENTERPRISE_DOMAIN            = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
    ST_GLOBAL_CATALOG               = DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
    ST_EXTERNAL_UPLEVEL_DOMAIN      = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN,
    ST_EXTERNAL_DOWNLEVEL_DOMAIN    = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
    ST_WORKGROUP                    = DSOP_SCOPE_TYPE_WORKGROUP,
    ST_USER_ENTERED_UPLEVEL_SCOPE   = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE,
    ST_USER_ENTERED_DOWNLEVEL_SCOPE = DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE,
    ST_LDAP_CONTAINER               = 0x00000400
};

BOOL
IsUplevel(
    SCOPE_TYPE Type)
{
    switch (Type)
    {
    case ST_ENTERPRISE_DOMAIN:
    case ST_GLOBAL_CATALOG:
    case ST_UPLEVEL_JOINED_DOMAIN:
    case ST_EXTERNAL_UPLEVEL_DOMAIN:
    case ST_USER_ENTERED_UPLEVEL_SCOPE:
    case ST_LDAP_CONTAINER:
        return TRUE;

    default:
        return FALSE;
    }
}

PWSTR
ScopeNameFromType(ULONG st)
{
    PWSTR pwz = L"unknown";

    switch (st)
    {
    case DSOP_SCOPE_TYPE_TARGET_COMPUTER:
        pwz = L"Target Computer";
        break;

    case DSOP_SCOPE_TYPE_GLOBAL_CATALOG:
        pwz = L"Global Catalog";
        break;

    case DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN:
        pwz = L"Uplevel Joined Domain";
        break;

    case DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN:
        pwz = L"Enterprise Domain";
        break;

    case DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN:
        pwz = L"External Uplevel Domain";
        break;

    case DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN:
        pwz = L"External Downlevel Domain";
        break;

    case DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN:
        pwz = L"Downlevel Joined Domain";
        break;

    case DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE:
        pwz = L"User Entered Uplevel Scope";
        break;

    case DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE:
        pwz = L"User Entered Downlevel Scope";
        break;

    case DSOP_SCOPE_TYPE_WORKGROUP:
        pwz = L"Workgroup";
        break;
    }
    return pwz;
}

void
NewDupStr(
    PWSTR *ppwzDup,
    PCWSTR wszSrc)
{
    if (wszSrc)
    {
        *ppwzDup = new WCHAR[lstrlen(wszSrc) + 1];
        lstrcpy(*ppwzDup, wszSrc);
    }
    else
    {
        *ppwzDup = NULL;
    }
}

class CScopeInitInfo: public DSOP_SCOPE_INIT_INFO
{
public:

    CScopeInitInfo() { ZeroMemory(this, sizeof *this); cbSize = sizeof *this; }

    CScopeInitInfo(const CScopeInitInfo &ToCopy)
    {
                ZeroMemory(this, sizeof *this);
        CScopeInitInfo::operator =(ToCopy);
    }

    ~CScopeInitInfo()
    {
        delete [] const_cast<PWSTR>(pwzDcName);
        pwzDcName = NULL;
        delete [] const_cast<PWSTR>(pwzADsPath);
        pwzADsPath = NULL;
    }

    CScopeInitInfo &
    operator =(const CScopeInitInfo &rhs)
    {
        cbSize = rhs.cbSize;
        flType = rhs.flType;
        flScope = rhs.flScope;
        delete [] const_cast<PWSTR>(pwzDcName);
        NewDupStr(const_cast<PWSTR*>(&pwzDcName), rhs.pwzDcName);
        delete [] const_cast<PWSTR>(pwzADsPath);
        NewDupStr(const_cast<PWSTR*>(&pwzADsPath), rhs.pwzADsPath);
        hr = rhs.hr;
        FilterFlags.Uplevel.flBothModes = rhs.FilterFlags.Uplevel.flBothModes;
        FilterFlags.Uplevel.flMixedModeOnly = rhs.FilterFlags.Uplevel.flMixedModeOnly;
        FilterFlags.Uplevel.flNativeModeOnly = rhs.FilterFlags.Uplevel.flNativeModeOnly;
        FilterFlags.flDownlevel = rhs.FilterFlags.flDownlevel;
        return *this;
    }
};


class COpTestDlg: public CDlg
{
public:

    COpTestDlg():
        m_pop(NULL),
        m_idcLastRadioClicked(0),
        m_fIgnoreNotifications(FALSE)
    {
        m_wzFilename[0] = L'\0';
    }

    ~COpTestDlg()
    {
        if (m_pop)
        {
            m_pop->Release();
            m_pop = NULL;
        }
    }

    void
    DoModalDialog(HWND hwnd)
    {
        _DoModalDlg(hwnd, IDD_GLOP);
    }

    HRESULT
    Init()
    {
        HRESULT
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &m_pop);
        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
        }
        return hr;
    }

protected:
    virtual BOOL _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual HRESULT _OnInit(BOOL *pfSetFocus);
    virtual BOOL _OnNotify(WPARAM, LPARAM);

private:

    void
    _AddScope(
        ULONG stNew);

    void
    _SetFlagFilterUiFromInitInfo(int iItem);

    void
    _SetInitInfoFromFlagFilterUi(int iItem);

    void
    _PopulateScopeFlagList();

    void
    _PopulateFilterList(
        BOOL fUplevel);

    void
    _EnableScopeFlagWindows(
        BOOL fEnable);

    void
    _SaveAs();

    void
    _Save();

    void
    _Load();

    void
    _Clear();

    void
    _InitObjectPicker();

    void
    _PresetLocalUserManager();

    void
    _PresetAclUiFile();

    IDsObjectPicker                *m_pop;
    vector<CScopeInitInfo>          m_vsii;
    ULONG                           m_idcLastRadioClicked;
    WCHAR                           m_wzFilename[MAX_PATH];
    BOOL                            m_fIgnoreNotifications;
};

class CAddScopeDlg: public CDlg
{
public:

    CAddScopeDlg(): m_stNew(0) {}

    void
    DoModal(HWND hwndParent)
    {
        _DoModalDlg(hwndParent, IDD_ADD_SCOPE);
    }
    ULONG
    GetNewScopeType()
    {
        return m_stNew;
    }
protected:

    virtual HRESULT
    _OnInit(
        BOOL *pfSetFocus)
    {
        CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_ADD_SCOPE_RADIO1);
        return S_OK;
    }

    virtual BOOL _OnCommand(WPARAM wParam, LPARAM lParam);

private:

    ULONG   m_stNew;
};


void
COpTestDlg::_EnableScopeFlagWindows(
    BOOL fEnable)
{
    EnableWindow(_hCtrl(IDC_SCOPE_FLAG_LIST), fEnable);
    EnableWindow(_hCtrl(IDC_SCOPE_FILTER_LIST), fEnable);
    EnableWindow(_hCtrl(IDC_BOTH_RADIO), fEnable);
    EnableWindow(_hCtrl(IDC_MIXED_RADIO), fEnable);
    EnableWindow(_hCtrl(IDC_NATIVE_RADIO), fEnable);
    EnableWindow(_hCtrl(IDC_DOWNLEVEL_RADIO), fEnable);
}


BOOL
CAddScopeDlg::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    static ULONG s_ast[] =
    {
        DSOP_SCOPE_TYPE_TARGET_COMPUTER,
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
        DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN,
        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
        DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE,
        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE,
        DSOP_SCOPE_TYPE_WORKGROUP
    };

    if (LOWORD(wParam) == IDCANCEL)
    {
        EndDialog(m_hwnd, 0);
        return FALSE;
    }

    if (LOWORD(wParam) != (WORD)IDOK)
    {
        return FALSE;
    }

    for (int i = IDC_ADD_SCOPE_RADIO1; i <= LAST_SCOPE_RADIO; i++)
    {
        if (IsDlgButtonChecked(m_hwnd, i))
        {
            m_stNew = s_ast[i - IDC_ADD_SCOPE_RADIO1];
        }
    }
    EndDialog(m_hwnd, 0);
    return FALSE;
}



struct SScopeFlagInfo
{
    LPWSTR  pwzName;
    ULONG   flValue;
};

static SScopeFlagInfo s_ScopeFlagInfo[] =
{
    {L"Starting scope", DSOP_SCOPE_FLAG_STARTING_SCOPE},
    {L"Default users", DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS},
    {L"Default groups", DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS},
    {L"Default computers", DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS},
    {L"Default contacts", DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS},
    {L"Convert provider to WinNT", DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT},
    {L"Convert provider to LDAP", DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP},
    {L"Convert provider to GC", DSOP_SCOPE_FLAG_WANT_PROVIDER_GC},
    {L"Want SID path", DSOP_SCOPE_FLAG_WANT_SID_PATH},
    {L"Want downlevel builtins to have path", DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH}
};

struct SScopeFilterInfo
{
    LPWSTR pwzName;
    ULONG flValue;
};

static SScopeFlagInfo s_DownlevelScopeFilterInfo[] =
{
    {L"Downlevel users", DSOP_DOWNLEVEL_FILTER_USERS},
    {L"Downlevel local groups", DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS},
    {L"Downlevel global groups", DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS},
    {L"Downlevel computers", DSOP_DOWNLEVEL_FILTER_COMPUTERS},
    {L"Downlevel world", DSOP_DOWNLEVEL_FILTER_WORLD},
    {L"Downlevel authenticated user", DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER},
    {L"Downlevel anonymous", DSOP_DOWNLEVEL_FILTER_ANONYMOUS},
    {L"Downlevel batch", DSOP_DOWNLEVEL_FILTER_BATCH},
    {L"Downlevel creator owner", DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER},
    {L"Downlevel creator group", DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP},
    {L"Downlevel dialup", DSOP_DOWNLEVEL_FILTER_DIALUP},
    {L"Downlevel interactive", DSOP_DOWNLEVEL_FILTER_INTERACTIVE},
    {L"Downlevel network", DSOP_DOWNLEVEL_FILTER_NETWORK},
    {L"Downlevel service", DSOP_DOWNLEVEL_FILTER_SERVICE},
    {L"Downlevel system", DSOP_DOWNLEVEL_FILTER_SYSTEM},
    {L"Downlevel exclude builtin groups", DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS},
    {L"Downlevel terminal server", DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER},
    {L"Downlevel local service", DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE},
    {L"Downlevel network service", DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE},
    {L"Downlevel remote logon", DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON},
    {L"Downlevel all well-known SIDs", DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS}
};

static SScopeFlagInfo s_UplevelScopeFilterInfo[] =
{
    {L"Include advanced view", DSOP_FILTER_INCLUDE_ADVANCED_VIEW},
    {L"Users",                  DSOP_FILTER_USERS},
    {L"Builtin groups",             DSOP_FILTER_BUILTIN_GROUPS},
    {L"Well-known principals", DSOP_FILTER_WELL_KNOWN_PRINCIPALS},
    {L"Universal groups DL",        DSOP_FILTER_UNIVERSAL_GROUPS_DL},
    {L"Universal groups SE",        DSOP_FILTER_UNIVERSAL_GROUPS_SE},
    {L"Global groups DL",       DSOP_FILTER_GLOBAL_GROUPS_DL},
    {L"Global groups SE",       DSOP_FILTER_GLOBAL_GROUPS_SE},
    {L"Domain local groups DL", DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL},
    {L"Domain local groups SE", DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE},
    {L"Contacts",                DSOP_FILTER_CONTACTS},
    {L"Computers",                  DSOP_FILTER_COMPUTERS}
};


HRESULT
COpTestDlg::_OnInit(
    BOOL *pfSetFocus)
{
    LV_COLUMN   lvc;
    RECT        rcLv;
    HWND        hwndLv;

    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;

    hwndLv = _hCtrl(IDC_SCOPE_LIST);
    GetClientRect(hwndLv, &rcLv);
    lvc.cx = rcLv.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndLv, 0, &lvc);

    hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);
    GetClientRect(hwndLv, &rcLv);
    lvc.cx = rcLv.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndLv, 0, &lvc);

    hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);
    GetClientRect(hwndLv, &rcLv);
    lvc.cx = rcLv.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndLv, 0, &lvc);

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_SCOPE_LIST),
                                        LVS_EX_FULLROWSELECT,
                                        LVS_EX_FULLROWSELECT);

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_SCOPE_FILTER_LIST),
                                        LVS_EX_CHECKBOXES,
                                        LVS_EX_CHECKBOXES);

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_SCOPE_FLAG_LIST),
                                        LVS_EX_CHECKBOXES,
                                        LVS_EX_CHECKBOXES);

    _EnableScopeFlagWindows(FALSE);
    SetMenu(m_hwnd, LoadMenu(hResourceModuleHandle, MAKEINTRESOURCE(IDR_MENU1)));
    CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_BOTH_RADIO);

    EnableWindow(_hCtrl(IDC_COCREATE_BUTTON), FALSE);
    return S_OK;
}

BOOL
COpTestDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);
    BOOL fResult = TRUE;

    if (m_fIgnoreNotifications)
    {
        return fResult;
    }
    if (pnmh->idFrom == IDC_SCOPE_LIST)
    {
        LPNMLISTVIEW pnmlv = reinterpret_cast<LPNMLISTVIEW> (lParam);

        switch(pnmh->code)
        {
        case LVN_ITEMCHANGING:
            if (pnmlv->uOldState & LVIS_SELECTED &&
                !(pnmlv->uNewState & LVIS_SELECTED))
            {
                _SetInitInfoFromFlagFilterUi(pnmlv->iItem);
            }

            break;

        case LVN_ITEMCHANGED:
            if (pnmlv->uNewState & LVIS_SELECTED &&
                !(pnmlv->uOldState & LVIS_SELECTED))
            {
                _SetFlagFilterUiFromInitInfo(pnmlv->iItem);
            }
            break;
        }
    }
    return fResult;
}


void
COpTestDlg::_SetFlagFilterUiFromInitInfo(
    int iItem)
{
    if (iItem < 0)
    {
        return;
    }
    HWND hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);

    for (int i = 0; i < ARRAYLEN(s_ScopeFlagInfo); i++)
    {
        if (m_vsii[iItem].flScope & s_ScopeFlagInfo[i].flValue)
        {
            ListView_SetCheckState(hwndLv, i, TRUE);
        }
        else
        {
            ListView_SetCheckState(hwndLv, i, FALSE);
        }
    }

    ULONG *pFilter = NULL;
    BOOL fShowingUplevel = TRUE;

    if (Button_GetCheck(_hCtrl(IDC_BOTH_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flBothModes;
    }
    else if (Button_GetCheck(_hCtrl(IDC_MIXED_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flMixedModeOnly;
    }
    else if (Button_GetCheck(_hCtrl(IDC_NATIVE_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flNativeModeOnly;
    }
    else if (Button_GetCheck(_hCtrl(IDC_DOWNLEVEL_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.flDownlevel;
        fShowingUplevel = FALSE;
    }

    if (!pFilter)
    {
        return;
    }

    hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);
    if (!ListView_GetItemCount(hwndLv))
    {
        return;
    }
    if (fShowingUplevel)
    {
        for (i = 0; i < ARRAYLEN(s_UplevelScopeFilterInfo); i++)
        {
            if (*pFilter & s_UplevelScopeFilterInfo[i].flValue)
            {
                ListView_SetCheckState(hwndLv, i, TRUE);
            }
            else
            {
                ListView_SetCheckState(hwndLv, i, FALSE);
            }
        }
    }
    else
    {
        for (i = 0; i < ARRAYLEN(s_DownlevelScopeFilterInfo); i++)
        {
            if ((*pFilter & s_DownlevelScopeFilterInfo[i].flValue) ==
                s_DownlevelScopeFilterInfo[i].flValue)
            {
                ListView_SetCheckState(hwndLv, i, TRUE);
            }
            else
            {
                ListView_SetCheckState(hwndLv, i, FALSE);
            }
        }
    }
}


void
COpTestDlg::_SetInitInfoFromFlagFilterUi(int iItem)
{
    if (iItem < 0)
    {
        return;
    }
    HWND hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);

    for (int i = 0; i < ARRAYLEN(s_ScopeFlagInfo); i++)
    {
        if (ListView_GetCheckState(hwndLv, i))
        {
            m_vsii[iItem].flScope |= s_ScopeFlagInfo[i].flValue;
        }
        else
        {
            m_vsii[iItem].flScope &= ~s_ScopeFlagInfo[i].flValue;
        }
    }

    if (!m_idcLastRadioClicked)
    {
        return;
    }

    ULONG *pFilter = NULL;
    BOOL fShowingUplevel = TRUE;

    if (m_idcLastRadioClicked == IDC_BOTH_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flBothModes;
    }
    else if (m_idcLastRadioClicked == IDC_MIXED_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flMixedModeOnly;
    }
    else if (m_idcLastRadioClicked == IDC_NATIVE_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flNativeModeOnly;
    }
    else if (m_idcLastRadioClicked == IDC_DOWNLEVEL_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.flDownlevel;
        fShowingUplevel = FALSE;
    }

    if (!pFilter)
    {
        return;
    }

    hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);

    if (!ListView_GetItemCount(hwndLv))
    {
        return;
    }

    if (fShowingUplevel)
    {
        for (i = 0; i < ARRAYLEN(s_UplevelScopeFilterInfo); i++)
        {
            if (ListView_GetCheckState(hwndLv, i))
            {
                *pFilter |= s_UplevelScopeFilterInfo[i].flValue;
            }
            else
            {
                *pFilter &= ~s_UplevelScopeFilterInfo[i].flValue;
            }
        }
    }
    else
    {
        for (i = 0; i < ARRAYLEN(s_DownlevelScopeFilterInfo); i++)
        {
            if (ListView_GetCheckState(hwndLv, i))
            {
                *pFilter |= s_DownlevelScopeFilterInfo[i].flValue;
            }
            else
            {
                *pFilter &= ~s_DownlevelScopeFilterInfo[i].flValue;
                if (*pFilter)
                {
                    *pFilter |= DOWNLEVEL_FILTER_BIT;
                }
            }
        }
    }
}

#define GetFirstSelected(hwndLv) ListView_GetNextItem(hwndLv, -1, LVNI_SELECTED)

BOOL
COpTestDlg::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = TRUE;

    if (m_fIgnoreNotifications)
    {
        return FALSE;
    }

    switch (LOWORD(wParam))
    {
    case IDC_ADD:
    {
        CAddScopeDlg    dlg;

        dlg.DoModal(m_hwnd);
        ULONG stNew = dlg.GetNewScopeType();
        if (stNew)
        {
            _AddScope(stNew);
        }
        break;
    }

    case IDC_REMOVE:
    {
        int iItem = GetFirstSelected(_hCtrl(IDC_SCOPE_LIST));

        if (iItem == -1)
        {
            break;
        }

        ListView_DeleteItem(_hCtrl(IDC_SCOPE_LIST), iItem);
        m_vsii.erase(m_vsii.begin() + iItem);

        if (m_vsii.empty())
        {
            _Clear();
            _EnableScopeFlagWindows(FALSE);
        }
        break;
    }

    case IDM_OPEN:
        _Clear();
        _Load();
        if (ListView_GetItemCount(_hCtrl(IDC_SCOPE_LIST)) > 0)
        {
            m_fIgnoreNotifications = TRUE;
            ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
            _SetFlagFilterUiFromInitInfo(0);
            m_fIgnoreNotifications = FALSE;
        }
        else
        {
            _EnableScopeFlagWindows(FALSE);
        }
        break;

    case IDM_SAVE:
        _SetInitInfoFromFlagFilterUi(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
        _Save();
        break;

    case IDM_SAVE_AS:
        _SetInitInfoFromFlagFilterUi(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
        _SaveAs();
        break;

    case IDM_LUM:
        _PresetLocalUserManager();
        break;

    case IDM_ACL_FILE:
        _PresetAclUiFile();
        break;

    case IDM_EXIT:
    case IDCANCEL:
        EndDialog(GetHwnd(), 0);
        break;

    case IDC_DOWNLEVEL_RADIO:
    case IDC_BOTH_RADIO:
    case IDC_MIXED_RADIO:
    case IDC_NATIVE_RADIO:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            m_idcLastRadioClicked = LOWORD(wParam);
            _SetInitInfoFromFlagFilterUi(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
            _PopulateFilterList(LOWORD(wParam) != IDC_DOWNLEVEL_RADIO);
            _SetFlagFilterUiFromInitInfo(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
        }
        break;

    case IDC_INIT_BUTTON:
        _InitObjectPicker();
        break;

    case IDC_COCREATE_BUTTON:
        if (!m_pop)
        {
            HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IDsObjectPicker,
                                          (void **) &m_pop);
            BREAK_ON_FAIL_HRESULT(hr);

            EnableWindow(_hCtrl(IDC_COCREATE_BUTTON), FALSE);
            EnableWindow(_hCtrl(IDC_RELEASE_BUTTON), TRUE);
            EnableWindow(_hCtrl(IDC_INIT_BUTTON), TRUE);
            EnableWindow(_hCtrl(IDC_INVOKE_BUTTON), TRUE);
        }
        else
        {
            MessageBeep(0);
        }
        break;

    case IDC_RELEASE_BUTTON:
        if (m_pop)
        {
            m_pop->Release();
            m_pop = NULL;
            EnableWindow(_hCtrl(IDC_RELEASE_BUTTON), FALSE);
            EnableWindow(_hCtrl(IDC_COCREATE_BUTTON), TRUE);
            EnableWindow(_hCtrl(IDC_INIT_BUTTON), FALSE);
            EnableWindow(_hCtrl(IDC_INVOKE_BUTTON), FALSE);
        }
        break;

    case IDC_INVOKE_BUTTON:
    {
        IDataObject *pdo;
        m_pop->InvokeDialog(m_hwnd, &pdo);
        if (pdo)
        {
            STGMEDIUM stgmedium =
            {
                TYMED_HGLOBAL,
                NULL
            };

            FORMATETC formatetc =
            {
                static_cast<CLIPFORMAT>(RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST)),
                NULL,
                DVASPECT_CONTENT,
                -1,
                TYMED_HGLOBAL
            };

            pdo->GetData(&formatetc, &stgmedium);

            ReleaseStgMedium(&stgmedium);
            pdo->Release();
        }
        break;
    }

    default:
        fHandled = FALSE;
        break;
    }

    return fHandled;
}

void
COpTestDlg::_PresetLocalUserManager()
{
    _Clear();
    m_fIgnoreNotifications = TRUE;
    CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_CHECKED);
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), L"groupType; ObjectSID");
    m_vsii.reserve(7);

    CScopeInitInfo sii;

    sii.flType =                                0x1;
    sii.flScope =                               0x21;
    sii.FilterFlags.Uplevel.flBothModes =       0x2;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0x0;
    sii.FilterFlags.flDownlevel =               0x80020001;
    m_vsii.push_back(sii);

    sii.flType =                               0x2;
    sii.flScope =                              0x2;
    sii.FilterFlags.Uplevel.flBothModes =      0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =  0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly = 0x2a2;
    sii.FilterFlags.flDownlevel =              0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x4;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0x2a2;
    sii.FilterFlags.flDownlevel =               0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x8;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x0;
    m_vsii.push_back(sii);

    sii.flType =                                0x20;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x40;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x10;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x0;
    m_vsii.push_back(sii);


    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;
    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);

    for (int i = 0; i < m_vsii.size(); i++)
    {
        lvi.pszText = ScopeNameFromType(m_vsii[i].flType);
        ListView_InsertItem(hwndLv, &lvi);
    }

    BOOL fUplevel = IsUplevel((SCOPE_TYPE)m_vsii[0].flType);
    _EnableScopeFlagWindows(TRUE);
    _PopulateScopeFlagList();
    _PopulateFilterList(fUplevel);
    ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
    m_fIgnoreNotifications = FALSE;

    if (fUplevel)
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_BOTH_RADIO);
    }
    else
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_DOWNLEVEL_RADIO);
    }
    _SetFlagFilterUiFromInitInfo(0);
}

void
COpTestDlg::_PresetAclUiFile()
{
    _Clear();
    m_fIgnoreNotifications = TRUE;
    CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_CHECKED);
    CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_CHECKED);
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), L"ObjectSID");
    m_vsii.reserve(6);

    CScopeInitInfo sii;

    sii.flType =                                 0x2;
    sii.flScope =                                0x1;
    sii.FilterFlags.Uplevel.flBothModes =        0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x88b;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0xaab;
    sii.FilterFlags.flDownlevel =                0x0;
    m_vsii.push_back(sii);

    sii.flType =                                 0x4;
    sii.flScope =                                0x1;
    sii.FilterFlags.Uplevel.flBothModes =        0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cfd;
    m_vsii.push_back(sii);

    sii.flType =                                 0x1;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cff;
    m_vsii.push_back(sii);

    sii.flType =                                 0x10;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8ab;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x0;
    m_vsii.push_back(sii);

    sii.flType =                                 0x8;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8a3;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x0;
    m_vsii.push_back(sii);

    sii.flType =                                 0x20;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8a3;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cf5;
    m_vsii.push_back(sii);

    sii.flType =                                 0x40;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8a3;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cf5;
    m_vsii.push_back(sii);

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;
    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);

    for (int i = 0; i < m_vsii.size(); i++)
    {
        lvi.pszText = ScopeNameFromType(m_vsii[i].flType);
        ListView_InsertItem(hwndLv, &lvi);
    }

    BOOL fUplevel = IsUplevel((SCOPE_TYPE)m_vsii[0].flType);
    _EnableScopeFlagWindows(TRUE);
    _PopulateScopeFlagList();
    _PopulateFilterList(fUplevel);
    ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
    m_fIgnoreNotifications = FALSE;
    _SetFlagFilterUiFromInitInfo(0);

    if (fUplevel)
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_BOTH_RADIO);
    }
    else
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_DOWNLEVEL_RADIO);
    }
    _SetFlagFilterUiFromInitInfo(0);
}



void
COpTestDlg::_InitObjectPicker()
{
    DSOP_INIT_INFO ii;

    ZeroMemory(&ii, sizeof ii);
    ii.cbSize = sizeof(ii);
    ULONG flags = 0;

    if (IsDlgButtonChecked(m_hwnd, IDC_MULTISELECT_CHECK))
    {
        flags |= DSOP_FLAG_MULTISELECT;
    }

    if (IsDlgButtonChecked(m_hwnd, IDC_SKIP_DC_CHECK))
    {
        flags |= DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK;
    }

    ii.flOptions = flags;
    WCHAR wzTarget[MAX_PATH];
    Edit_GetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), wzTarget, ARRAYLEN(wzTarget));
    ii.pwzTargetComputer = wzTarget;

    ULONG cchAttributes = Edit_GetTextLength(_hCtrl(IDC_ATTRIBUTES_EDIT));
    PWSTR pwzAttributes = new WCHAR[cchAttributes + 1];
    if (!pwzAttributes)
    {
        printf("out of memory\n");
        return;
    }
    Edit_GetText(_hCtrl(IDC_ATTRIBUTES_EDIT), pwzAttributes, cchAttributes + 1);

    String strAttr = pwzAttributes;
    delete [] pwzAttributes;

    list<String> tokens;
    strAttr.tokenize(back_inserter(tokens), L"; ");

    ii.cAttributesToFetch = static_cast<ULONG>(tokens.size());
    list<String>::iterator it;

    ii.apwzAttributeNames = new PCWSTR[tokens.size()];
    int i;

    for (i = 0, it = tokens.begin(); it != tokens.end(); it++, i++)
    {
        ii.apwzAttributeNames[i] = it->c_str();
    }

    ii.cDsScopeInfos = static_cast<ULONG>(m_vsii.size());
    ii.aDsScopeInfos = new DSOP_SCOPE_INIT_INFO[m_vsii.size()];


    for (i = 0; i < ii.cDsScopeInfos; i++)
    {
        CopyMemory(&ii.aDsScopeInfos[i], &m_vsii[i], sizeof DSOP_SCOPE_INIT_INFO);
    }

    HRESULT hr = m_pop->Initialize(&ii);

    if (FAILED(hr))
    {
        printf("init failed %#x\n", hr);
    }

    delete [] ii.aDsScopeInfos;
    delete [] ii.apwzAttributeNames;
}



void
COpTestDlg::_SaveAs()
{
    OPENFILENAME ofn;

    ZeroMemory(&ofn, sizeof ofn);
    ofn.lStructSize = sizeof ofn;
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = L"Object Picker Tester (*.opt)\0*.OPT\0";
    ofn.lpstrDefExt = L"opt";
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = m_wzFilename;
    ofn.nMaxFile = ARRAYLEN(m_wzFilename);
    ofn.Flags = OFN_PATHMUSTEXIST;

    BOOL fOk = GetSaveFileName(&ofn);

    if (!fOk)
    {
        return;
    }

    _Save();
}


void
COpTestDlg::_Save()
{
    String c_strCRLF(L"\r\n");
    String c_strQuote(L"\"");

    if (!*m_wzFilename)
    {
        _SaveAs();
        return;
    }

    // target
    // options
    // attribute string
    // cScopeInfos
    // Scopes

    String strBuffer;

    WCHAR wzTarget[MAX_PATH];
    Edit_GetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), wzTarget, ARRAYLEN(wzTarget));

    strBuffer = c_strQuote + wzTarget + c_strQuote + c_strCRLF;

    ULONG flags = 0;

    if (IsDlgButtonChecked(m_hwnd, IDC_MULTISELECT_CHECK))
    {
        flags |= DSOP_FLAG_MULTISELECT;
    }

    if (IsDlgButtonChecked(m_hwnd, IDC_SKIP_DC_CHECK))
    {
        flags |= DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK;
    }

    WCHAR wzBuf[20];

    wsprintf(wzBuf, L"%#x", flags);
    strBuffer += wzBuf + c_strCRLF;

    ULONG cchAttributes = Edit_GetTextLength(_hCtrl(IDC_ATTRIBUTES_EDIT));
    PWSTR pwzAttributes = new WCHAR[cchAttributes + 1];
    if (!pwzAttributes)
    {
        printf("out of memory\n");
        return;
    }
    Edit_GetText(_hCtrl(IDC_ATTRIBUTES_EDIT), pwzAttributes, cchAttributes + 1);
    strBuffer += c_strQuote + pwzAttributes + c_strQuote + c_strCRLF;
    delete [] pwzAttributes;

    wsprintf(wzBuf, L"%u", m_vsii.size());
    strBuffer += wzBuf + c_strCRLF;

    for (int i = 0; i < m_vsii.size(); i++)
    {
        wsprintf(wzBuf, L"%#x", m_vsii[i].flType);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].flScope);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.Uplevel.flBothModes);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.Uplevel.flMixedModeOnly);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.Uplevel.flNativeModeOnly);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.flDownlevel);
        strBuffer += wzBuf + c_strCRLF;

        if (m_vsii[i].pwzDcName)
        {
            strBuffer += c_strQuote + m_vsii[i].pwzDcName + c_strQuote + c_strCRLF;
        }
        else
        {
            strBuffer += c_strQuote + c_strQuote + c_strCRLF;
        }

        if (m_vsii[i].pwzADsPath)
        {
            strBuffer += c_strQuote + m_vsii[i].pwzADsPath + c_strQuote + c_strCRLF;
        }
        else
        {
            strBuffer += c_strQuote + c_strQuote + c_strCRLF;
        }
    }

    HANDLE hFile = CreateFile(m_wzFilename,
                              GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("CreateFile failed %u\n", GetLastError());
        return;
    }

    AnsiString  straBuffer;

    strBuffer.convert(straBuffer);

    ULONG cbWritten;

    WriteFile(hFile,
              straBuffer.c_str(),
              static_cast<ULONG>(straBuffer.length()),
              &cbWritten,
              NULL);

    CloseHandle(hFile);
}



void
COpTestDlg::_Load()
{
    OPENFILENAME ofn;

    ZeroMemory(&ofn, sizeof ofn);
    ofn.lStructSize = sizeof ofn;
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = L"Object Picker Tester (*.opt)\0*.opt\0";
    ofn.lpstrDefExt = L"opt";
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = m_wzFilename;
    ofn.nMaxFile = ARRAYLEN(m_wzFilename);
    ofn.Flags = OFN_PATHMUSTEXIST;

    BOOL fOk = GetOpenFileName(&ofn);

    if (!fOk)
    {
        return;
    }

    HANDLE hFile = CreateFile(m_wzFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("CreateFile failed %u\n", GetLastError());
        return;
    }

    ULONG cbFile = GetFileSize(hFile, NULL);

    PSTR pstr = new CHAR[cbFile + 1];

    if (!pstr)
    {
        printf("out of memory\n");
        CloseHandle(hFile);
        return;
    }

    ULONG cbRead;

    ReadFile(hFile, pstr, cbFile, &cbRead, NULL);
    CloseHandle(hFile);

    pstr[cbRead] = '\0';
    String strBuffer(pstr);
    delete [] pstr;

    list<String> tokens;
    String c_strCRLF(L"\r\n");

    strBuffer.tokenize(back_inserter(tokens), c_strCRLF);

    list<String>::iterator it;

    it = tokens.begin();

    // target
    // options
    // attribute string
    // cScopeInfos
    // Scopes

    it->strip(String::BOTH, L' ');
    it->strip(String::BOTH, L'"');
    Edit_SetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), it->c_str());

    it++;
    ULONG flags;

    it->convert(flags, 16);

    if (flags & DSOP_FLAG_MULTISELECT)
    {
        CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_UNCHECKED);
    }

    if (flags & DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK)
    {
        CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_UNCHECKED);
    }

    it++;
    it->strip(String::BOTH, L' ');
    it->strip(String::BOTH, L'"');
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), it->c_str());

    it++;
    ULONG cInitInfos;
    it->convert(cInitInfos);

    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);
    BOOL fFirstIsUplevel = FALSE;

    for (int i = 0; i < cInitInfos; i++)
    {
        CScopeInitInfo sii;

        it++;
        it->convert(sii.flType, 16);

        if (!i)
        {
            fFirstIsUplevel = IsUplevel((SCOPE_TYPE)sii.flType);
        }

        it++;
        it->convert(sii.flScope, 16);

        it++;
        it->convert(sii.FilterFlags.Uplevel.flBothModes, 16);

        it++;
        it->convert(sii.FilterFlags.Uplevel.flMixedModeOnly, 16);

        it++;
        it->convert(sii.FilterFlags.Uplevel.flNativeModeOnly, 16);

        it++;
        it->convert(sii.FilterFlags.flDownlevel, 16);

        it++;
        it->strip(String::BOTH, L' ');
        it->strip(String::BOTH, L'"');
        NewDupStr(const_cast<PWSTR*>(&sii.pwzDcName),it->c_str());

        it++;
        it->strip(String::BOTH, L' ');
        it->strip(String::BOTH, L'"');
        NewDupStr(const_cast<PWSTR*>(&sii.pwzADsPath), it->c_str());

        m_vsii.push_back(sii);

        LVITEM lvi;
        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_TEXT;
        lvi.iItem = 1000;
        lvi.pszText = ScopeNameFromType(sii.flType);

        ListView_InsertItem(hwndLv, &lvi);
    }


    if (cInitInfos)
    {
        m_fIgnoreNotifications = TRUE;
        BOOL fUplevel = IsUplevel((SCOPE_TYPE)m_vsii[0].flType);
        _EnableScopeFlagWindows(TRUE);
        _PopulateScopeFlagList();
        _PopulateFilterList(fUplevel);
        ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
        m_fIgnoreNotifications = FALSE;
    }
}





void
COpTestDlg::_PopulateFilterList(
    BOOL fUplevel)
{
    HWND hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);
    ListView_DeleteAllItems(hwndLv);
    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;

    int i=0;
    if (fUplevel)
    {
        for (i = 0; i < ARRAYLEN(s_UplevelScopeFilterInfo); i++)
        {
            lvi.pszText = s_UplevelScopeFilterInfo[i].pwzName;
            ListView_InsertItem(hwndLv, &lvi);
        }
    }
    else
    {
        for (i = 0; i < ARRAYLEN(s_DownlevelScopeFilterInfo); i++)
        {
            lvi.pszText = s_DownlevelScopeFilterInfo[i].pwzName;
            ListView_InsertItem(hwndLv, &lvi);
        }
    }
}
void
COpTestDlg::_AddScope(
    ULONG stNew)
{
    LVITEM lvi;

    CScopeInitInfo sii;

    sii.flType = stNew;
    m_vsii.push_back(sii);

    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;
    lvi.pszText = ScopeNameFromType(stNew);

    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);
    INT iNew = ListView_InsertItem(hwndLv, &lvi);
    ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), iNew, LVIS_SELECTED, LVIS_SELECTED);

    hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);
    if (!ListView_GetItemCount(hwndLv))
    {
        _EnableScopeFlagWindows(TRUE);
        _PopulateScopeFlagList();
    }

    if (IsUplevel((SCOPE_TYPE)stNew))
    {
        CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_BOTH_RADIO);
    }
    else
    {
        CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_DOWNLEVEL_RADIO);
    }

    _SetFlagFilterUiFromInitInfo(static_cast<ULONG>(m_vsii.size() - 1));
}

void
COpTestDlg::_PopulateScopeFlagList()
{
    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM | LVIF_TEXT;
    lvi.iItem = 1000;
    HWND hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);
    for (int i = 0; i < ARRAYLEN(s_ScopeFlagInfo); i++)
    {
        lvi.pszText = s_ScopeFlagInfo[i].pwzName;
        lvi.lParam = s_ScopeFlagInfo[i].flValue;
        ListView_InsertItem(hwndLv, &lvi);
    }
}




void
COpTestDlg::_Clear()
{
    CheckDlgButton(m_hwnd, m_idcLastRadioClicked, BST_UNCHECKED);
    CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_UNCHECKED);
    CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_UNCHECKED);
    m_idcLastRadioClicked = 0;
    m_vsii.clear();
    ListView_DeleteAllItems(_hCtrl(IDC_SCOPE_LIST));
    ListView_DeleteAllItems(_hCtrl(IDC_SCOPE_FLAG_LIST));
    ListView_DeleteAllItems(_hCtrl(IDC_SCOPE_FILTER_LIST));
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), L"");
    Edit_SetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), L"");
}




void __cdecl
main(int argc, char *argv[])
{
    hResourceModuleHandle = GetModuleHandle(NULL);
    INITCOMMONCONTROLSEX icce;

    icce.dwSize = sizeof icce;
    icce.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx(&icce);

    HRESULT hr;
    do
    {
        hr = CoInitialize(NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        COpTestDlg    dlg;

        hr = dlg.Init();
        BREAK_ON_FAIL_HRESULT(hr);

        dlg.DoModalDialog(NULL);
    }
    while (0);
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bits_client_msm\makefile.inc ===
MSM_NAME=$(TARGETPATH)\$(TARGETNAME)

make_msm: $(MSM_NAME)


$(MSM_NAME): *.idt
        md   Binary
        copy $(TARGETPATH)\bitscnfg.exe Binary\New_Binary3.7AA0B4BB_5B6C_41AE_84E6_F3C3C865051A.ibd
        msidb -c -d $(MSM_NAME) -f $(MAKEDIR) *
        msidb -d $(MSM_NAME) -a $(TARGETPATH)\qmgr.dll
        msidb -d $(MSM_NAME) -a $(TARGETPATH)\qmgrprxy.dll
        msidb -d $(MSM_NAME) -a $(TARGETPATH)\bitsprx2.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bitsadmin\utils.cpp ===
/************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name :

    utils.cpp

Abstract :

    Utility functions for BITSADMIN

Author :

    Mike Zoran  mzoran   May 2002.

Revision History :

Notes:

  ***********************************************************************/

#include "bitsadmin.h"
  
//
// Globals
//

bool g_Shutdown = false;
HANDLE g_MainThreadHandle = NULL;

WCHAR* pComputerName;
SmartManagerPointer g_Manager;
bool bRawReturn         = false;
bool bWrap              = true;
bool bExplicitWrap      = false;

bool bConsoleInfoRetrieved = false;
HANDLE hConsole;
CRITICAL_SECTION CritSection;
CONSOLE_SCREEN_BUFFER_INFO StartConsoleInfo;
DWORD StartConsoleMode;

BITSOUTStream bcout( STD_OUTPUT_HANDLE );
BITSOUTStream bcerr( STD_ERROR_HANDLE );


void BITSADMINSetThreadUILanguage()
{

    LANGID LangId;

    switch (GetConsoleOutputCP()) 
        {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) 
                {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
                }
            else 
                {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
                }
            break;
        }   

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );

    return;
}

void
BITSOUTStream::OutputString( const WCHAR *RawString )
{
   SIZE_T CurrentPos = 0;

   PollShutdown();

   if ( !RawString )
       RawString = L"NULL";

   while( RawString[ CurrentPos ] != '\0' )
       {

       if ( L'\n' == RawString[ CurrentPos ] )
           {
           Buffer[ BufferUsed++ ] = L'\x000D';
           Buffer[ BufferUsed++ ] = L'\x000A';
           CurrentPos++;
           FlushBuffer( true );
           }

       else if ( L'\t' == RawString[ CurrentPos ] )
           {
           // Tabs complicate things, flush them
           FlushBuffer();
           Buffer[ BufferUsed++ ] = RawString[ CurrentPos++ ];
           FlushBuffer();
           }

       else
           {
           Buffer[ BufferUsed++ ] = RawString[ CurrentPos++ ];

           if ( BufferUsed >= ( 4096 - 10 ) ) // keep a pad of 10 chars
               FlushBuffer();
           }
       }
}

void
BITSOUTStream::FlushBuffer( bool HasNewLine )
{

    if (!BufferUsed)
        return;

    if( GetFileType(Handle) == FILE_TYPE_CHAR )
        {
        DWORD CharsWritten;
        if ( bWrap )
            WriteConsoleW( Handle, Buffer, BufferUsed, &CharsWritten, 0);
        else
            {

            // The console code has what appears to be a bug in that it doesn't
            // handle the case were line wrapping is disabled and WriteConsoleW
            // is called.  Need to manually handle the truncation.

            CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo;
            GetConsoleScreenBufferInfo( Handle, &ConsoleScreenBufferInfo );

            SHORT Columns = ( ConsoleScreenBufferInfo.dwSize.X - 1 ) -
                            ( ConsoleScreenBufferInfo.dwCursorPosition.X );

            DWORD ActualChars = HasNewLine ? ( BufferUsed - 2 ) : BufferUsed;

            if ( Columns >= (INT32)ActualChars )
                WriteConsoleW( Handle, Buffer, BufferUsed, &CharsWritten, 0 );
            else
                {
                WriteConsoleW( Handle, Buffer, Columns, &CharsWritten, 0 );
                if ( HasNewLine )
                    WriteConsoleW( Handle, Buffer + ActualChars, 2, &CharsWritten, 0 );
                }
            }
        }
    else
        {
        int ByteCount = WideCharToMultiByte( GetConsoleOutputCP(), 0, Buffer, BufferUsed, MBBuffer, sizeof(MBBuffer), 0, 0); // SEC-REVIEWED: 2002-03-21
        if ( ByteCount )
            {
            
            if ( MBBuffer[ByteCount-1] == '\0' )
                ByteCount--;
            
            DWORD BytesWritten;
            while( ByteCount )
                {
                
                if ( !WriteFile(Handle, MBBuffer, ByteCount, &BytesWritten, 0) )  // SEC-REVIEWED: 2002-03-21 
                    CheckHR( L"Unable to write to the output file", 
                             HRESULT_FROM_WIN32( GetLastError() ) );

                ByteCount -= BytesWritten;

                }
            
            }
        }

    BufferUsed = 0;

}

BITSOUTStream& operator<< (BITSOUTStream &s, const WCHAR * String )
{
    s.OutputString( String );
    return s;
}

BITSOUTStream& operator<< (BITSOUTStream &s, UINT64 Number )
{
    static WCHAR Buffer[256];
    if ( FAILED( StringCbPrintf( Buffer, sizeof(Buffer), L"%I64u", Number ) ) )
         return s;
    return ( s << Buffer );
}

WCHAR * HRESULTToString( HRESULT Hr )
{
    static WCHAR ErrorCode[12];
    if ( FAILED( StringCbPrintf( ErrorCode, sizeof(ErrorCode), L"0x%8.8x", Hr ) ) )
        {
        ErrorCode[0] = '\0';
        }

    return ErrorCode;
}

BITSOUTStream& operator<< ( BITSOUTStream &s, AutoStringPointer & String )
{
    return ( s << String.Get() );
}


BITSOUTStream& operator<< ( BITSOUTStream &s, GUID & guid )
{
    WCHAR GUIDSTR[40];
    if (!StringFromGUID2( guid, GUIDSTR, 40 ))
    {
        bcout << L"Internal error converting guid to string.\n";
        throw AbortException(1);
    }
    return ( s << GUIDSTR );
}

BITSOUTStream& operator<< ( BITSOUTStream &s, FILETIME & filetime )
{

     // Convert the time and date into a localized string.
     // If an error occures, ignore it and print ERROR instead

     if ( !filetime.dwLowDateTime && !filetime.dwHighDateTime )
         return ( s << L"UNKNOWN" );

     FILETIME localtime;
     FileTimeToLocalFileTime( &filetime, &localtime );

     SYSTEMTIME systemtime;
     FileTimeToSystemTime( &localtime, &systemtime );

     // Get the required date size
     int RequiredDateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if (!RequiredDateSize)
         return ( s << L"ERROR" );

     CAutoString DateBuffer( new WCHAR[ RequiredDateSize + 1 ]);

     // Actually retrieve the date

     int DateSize =
         GetDateFormatW( LOCALE_USER_DEFAULT,
                        0,
                        &systemtime,
                        NULL,
                        DateBuffer.get(),
                        RequiredDateSize );

     if (!DateSize)
         return ( s << L"ERROR" );

     // Get the required time size
     int RequiredTimeSize =
         GetTimeFormatW( LOCALE_USER_DEFAULT,
                        0,
                        &systemtime,
                        NULL,
                        NULL,
                        0 );

     if (!RequiredTimeSize)
         return ( s << L"ERROR" );

     CAutoString TimeBuffer( new WCHAR[ RequiredTimeSize + 1 ]);

     int TimeSize =
         GetTimeFormatW( LOCALE_USER_DEFAULT,
                        0,
                        &systemtime,
                        NULL,
                        TimeBuffer.get(),
                        RequiredTimeSize );

     if (!TimeSize)
         return ( s << L"ERROR" );

     return ( s << DateBuffer.get() << L" " << TimeBuffer.get() );
}

BITSOUTStream& operator<< ( BITSOUTStream &s, BG_JOB_PROXY_USAGE ProxyUsage )
{
     switch( ProxyUsage )
         {
         case BG_JOB_PROXY_USAGE_PRECONFIG:
             return (s << L"PRECONFIG");
         case BG_JOB_PROXY_USAGE_NO_PROXY:
             return (s << L"NO_PROXY");
         case BG_JOB_PROXY_USAGE_OVERRIDE:
             return (s << L"OVERRIDE");
         default:
             return (s << L"UNKNOWN");
         }
}

ULONG InputULONG( WCHAR *pText )
{
   ULONG number;
   if ( 1 != swscanf( pText, L"%u", &number ) )
       {
       bcout << L"Invalid number.\n";
       throw AbortException(1);
       }
   return number;
}

BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_INVALID_SID indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;
    WCHAR Stub, *StubPtr = NULL;
    ULONG Index;
    INT gBase=10;
    INT lBase=10;
    ULONG Auto;

    if ( NULL == StringSid || NULL == Sid || NULL == End ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );

    }

    //
    // no need to check length because StringSid is NULL
    // and if the first char is NULL, it won't access the second char
    //
    if ( (*StringSid != L'S' && *StringSid != L's') ||
         *( StringSid + 1 ) != L'-' ) {
        //
        // string sid should always start with S-
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }


    Curr = StringSid + 2;

    if ( (*Curr == L'0') &&
         ( *(Curr+1) == L'x' ||
           *(Curr+1) == L'X' ) ) {

        gBase = 16;
    }

    Revision = ( UCHAR )wcstol( Curr, &CurrEnd, gBase );

    if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
        //
        // no revision is provided, or invalid delimeter
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );
        
    if ( (*Curr == L'0') &&
         ( *(Curr+1) == L'x' ||
           *(Curr+1) == L'X' ) ) {

        lBase = 16;
    } else {
        lBase = gBase;
    }

    Auto = wcstoul( Curr, &CurrEnd, lBase );

    if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
        //
        // no revision is provided, or invalid delimeter
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

    IDAuth.Value[0] = IDAuth.Value[1] = 0;
    IDAuth.Value[5] = ( UCHAR )Auto & 0xFF;
    IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
    IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
    IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
    Curr = CurrEnd;

    //
    // Now, count the number of sub auths, at least one sub auth is required
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //

    while ( Next ) {

        if ( *Next == L'-' && *(Next-1) != L'-') {

            //
            // do not allow two continuous '-'s
            // We've found one!
            //
            Subs++;

            if ( (*(Next+1) == L'0') &&
                 ( *(Next+2) == L'x' ||
                   *(Next+2) == L'X' ) ) {
                //
                // this is hex indicator
                //
                Next += 2;

            }

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' ||
                    *Next == SDDL_ACE_ENDC || *Next == L' ' ||
                    ( *(Next+1) == SDDL_DELIMINATORC &&
                      (*Next == L'G' || *Next == L'O' || *Next == L'S')) ) {
            //
            // space is a terminator too
            //
            if ( *( Next - 1 ) == L'-' ) {
                //
                // shouldn't allow a SID terminated with '-'
                //
                Err = ERROR_INVALID_SID;
                Next--;

            } else {
                Subs++;
            }

            *End = Next;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            Err = ERROR_INVALID_SID;
            *End = Next;
            break;

        } else {

            //
            // Note: SID is also used as a owner or group
            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == L'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We'll also need to temporarily truncate the string to this length so
                // we don't accidentally include the character in one of the conversions
                //
                Stub = *Next;
                StubPtr = Next;
                *StubPtr = UNICODE_NULL;
                *End = Next;
                Subs++;
                break;
            }

        }

        Next++;

    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) Subs--;

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    if ( (*Curr == L'0') &&
                         ( *(Curr+1) == L'x' ||
                           *(Curr+1) == L'X' ) ) {

                        lBase = 16;
                    } else {
                        lBase = gBase;
                    }

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, lBase );
                    Curr = CurrEnd + 1;
                }
            }

        } else {

            Err = ERROR_INVALID_SID;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            ISid->IdentifierAuthority = IDAuth;
            RtlCopyMemory( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) ); // SEC-REVIEWED: 2002-03-21
        }
    }

    LocalFree( SubAuth );

    //
    // Restore any character we may have stubbed out
    //
    if ( StubPtr ) {

        *StubPtr = Stub;
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}

BOOL
AltConvertStringSidToSid(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    )

/*++

Routine Description:

    This routine converts a stringized SID into a valid, functional SID

Arguments:

    StringSid - SID to be converted.

    Sid - Where the converted SID is returned.  Buffer is allocated via LocalAlloc and should
        be free via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL name was given

        ERROR_INVALID_SID - The format of the given sid was incorrect

--*/

{
    PWSTR End = NULL;
    BOOL ReturnValue = FALSE;
    PSID pSASid=NULL;
    ULONG Len=0;
    DWORD SaveCode=0;
    DWORD Err=0;

    if ( StringSid == NULL || Sid == NULL )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    ReturnValue = LocalConvertStringSidToSid( ( PWSTR )StringSid, Sid, &End );

    if ( !ReturnValue )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    if ( ( ULONG )( End - StringSid ) != wcslen( StringSid ) ) {

        SetLastError( ERROR_INVALID_SID );
        LocalFree( *Sid );
        *Sid = FALSE;
        ReturnValue = FALSE;

        } else {
            SetLastError(ERROR_SUCCESS);
        }

    return ReturnValue;

}

BITSOUTStream& operator<< ( BITSOUTStream &s, PrintSidString SidString )
{

    // Convert the SID string into the user name
    // in domain\account format.
    // If an error occures, just return the SID string

    PSID pSid = NULL;
    BOOL bResult =
        AltConvertStringSidToSid(
            SidString.m_SidString,
            &pSid );

    if ( !bResult )
        {
        return ( s << SidString.m_SidString );
        }

    SID_NAME_USE NameUse;
    DWORD dwNameSize = 0;
    DWORD dwDomainSize = 0;
    bResult = LookupAccountSid(
        NULL,
        pSid,
        NULL,
        &dwNameSize,
        NULL,
        &dwDomainSize,
        &NameUse);

    if ( bResult ||
         ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) )
        {
        LocalFree( pSid );
        return ( s << SidString.m_SidString );
        }

    CAutoString pName( new WCHAR[ dwNameSize ] );
    CAutoString pDomain( new WCHAR[ dwDomainSize ] );

    bResult = LookupAccountSid(
        NULL,
        pSid,
        pName.get(),
        &dwNameSize,
        pDomain.get(),
        &dwDomainSize,
        &NameUse);

    if (!bResult)
        {
        LocalFree( pSid );
        return ( s << SidString.m_SidString );
        }

    LocalFree( pSid );
    return ( s << pDomain.get() << L"\\" << pName.get() );

}

void * _cdecl operator new( size_t Size )
{
   void *Memory = CoTaskMemAlloc( Size );

   if ( !Memory )
      {
      bcout << L"Out of memory while allocating " << Size << L" bytes.\n";
      throw AbortException( (int)E_OUTOFMEMORY );
      }

   return Memory;
}

void _cdecl operator delete( void *Mem )
{
   CoTaskMemFree( Mem );
}

void PollShutdown()
{
    if ( g_Shutdown )
        throw AbortException( (DWORD)CONTROL_C_EXIT );
}


void ShutdownAPC( ULONG_PTR )
{
    return;
}

void SignalShutdown( DWORD MilliTimeout )
{
    g_Shutdown = true;

    // Queue a shutdown APC

    if ( g_MainThreadHandle )
        {
        QueueUserAPC( ShutdownAPC, g_MainThreadHandle, NULL );
        }

    Sleep( MilliTimeout );
    RestoreConsole();
    TerminateProcess( GetCurrentProcess(),  (DWORD)CONTROL_C_EXIT );
}



void CheckHR( const WCHAR *pFailTxt, HRESULT Hr )
{

    // Check error code for success, and exit
    // with a failure message if unsuccessfull.

    if ( !SUCCEEDED(Hr) ) {
        WCHAR ErrorCode[12];
        
        if ( SUCCEEDED( StringCbPrintf( ErrorCode, sizeof(ErrorCode), L"0x%8.8x", Hr ) ) )
            {

            bcout << pFailTxt << L" - " << ErrorCode << L"\n";

            WCHAR *pMessage = NULL;

            if ( FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    (DWORD)Hr,
                    GetThreadLocale(),
                    (WCHAR*)&pMessage,
                    0,
                    NULL ) )
                {
                bcout << pMessage << L"\n";
                LocalFree( pMessage );
                }

            }
        
        throw AbortException( Hr );
    }
}

void SetupConsole()
{
    if (!( GetFileType( bcout.GetHandle() ) == FILE_TYPE_CHAR ) )
        return;

    hConsole = bcout.GetHandle();
    if ( INVALID_HANDLE_VALUE == hConsole )
        CheckHR( L"Unable to get console handle", HRESULT_FROM_WIN32( GetLastError() ) );

    if (!GetConsoleScreenBufferInfo( hConsole, &StartConsoleInfo ) )
        CheckHR( L"Unable get setup console information", HRESULT_FROM_WIN32( GetLastError() ) );

    if (!GetConsoleMode( hConsole, &StartConsoleMode ) )
        CheckHR( L"Unable get setup console information", HRESULT_FROM_WIN32( GetLastError() ) );

    InitializeCriticalSection( &CritSection );
    bConsoleInfoRetrieved = true;

    EnterCriticalSection( &CritSection );

    DWORD NewConsoleMode = ( bWrap ) ?
        ( StartConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT ) :
        ( StartConsoleMode & ~ENABLE_WRAP_AT_EOL_OUTPUT );

    if (!SetConsoleMode( hConsole, NewConsoleMode ) )
        CheckHR( L"Unable set console mode", HRESULT_FROM_WIN32( GetLastError() ) );
    LeaveCriticalSection( &CritSection );
}

void ChangeConsoleMode()
{

    EnterCriticalSection( &CritSection );

    DWORD NewConsoleMode = ( bWrap ) ?
        ( StartConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT ) :
        ( StartConsoleMode & ~ENABLE_WRAP_AT_EOL_OUTPUT );

    if (!SetConsoleMode( hConsole, NewConsoleMode ) )
        CheckHR( L"Unable set console mode", HRESULT_FROM_WIN32( GetLastError() ) );
    LeaveCriticalSection( &CritSection );

}

void RestoreConsole()
{
    if ( bConsoleInfoRetrieved )
        {
        EnterCriticalSection( &CritSection );
        SetConsoleTextAttribute( hConsole, StartConsoleInfo.wAttributes );
        SetConsoleMode( hConsole, StartConsoleMode );
        // Do not unlock, since we shouldn't allow any more console attribute changes
        }
}

void ClearScreen()
{
  COORD coordScreen = { 0, 0 };
  BOOL bSuccess;
  DWORD cCharsWritten;
  CONSOLE_SCREEN_BUFFER_INFO csbi;
  DWORD dwConSize;

  EnterCriticalSection( &CritSection );
  if (!GetConsoleScreenBufferInfo(hConsole, &csbi))
      goto error;
  dwConSize = csbi.dwSize.X * csbi.dwSize.Y;
  if (!FillConsoleOutputCharacter(hConsole, (WCHAR) ' ',
      dwConSize, coordScreen, &cCharsWritten))
      goto error;
  if (!GetConsoleScreenBufferInfo(hConsole, &csbi))
      goto error;
  if (!FillConsoleOutputAttribute(hConsole, csbi.wAttributes,
      dwConSize, coordScreen, &cCharsWritten))
      goto error;
  if  (!SetConsoleCursorPosition(hConsole, coordScreen))
      goto error;
  LeaveCriticalSection( &CritSection );
  return;

error:

  DWORD dwError = GetLastError();
  LeaveCriticalSection( &CritSection );
  CheckHR( L"Unable to clear the console window", HRESULT_FROM_WIN32( dwError ) );
  throw AbortException( dwError );
}


BITSOUTStream & operator<<( BITSOUTStream & s, AddIntensity  )
{
    if ( GetFileType( s.GetHandle() ) == FILE_TYPE_CHAR )
        {
        s.FlushBuffer();
        EnterCriticalSection( &CritSection );
        SetConsoleTextAttribute( hConsole, StartConsoleInfo.wAttributes | FOREGROUND_INTENSITY );
        LeaveCriticalSection( &CritSection );
    }
    return s;
}

BITSOUTStream & operator<<( BITSOUTStream & s, ResetIntensity )
{
    if ( GetFileType( s.GetHandle() ) == FILE_TYPE_CHAR )
        {
        s.FlushBuffer();
        EnterCriticalSection( &CritSection );
        SetConsoleTextAttribute( hConsole, StartConsoleInfo.wAttributes );
        LeaveCriticalSection( &CritSection );
        }
    return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bitsadmin\bitsadmin.h ===
/************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name :

    bitsadmin.h

Abstract :

    Main header file for bitsadmin.

Author :

    Mike Zoran  mzoran   May 2002.

Revision History :

Notes:

*************************************************************************/
  
#define MAKE_UNICODE(x)      L ## x

#include <windows.h>
#include <sddl.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <bits.h>
#include <bits1_5.h>
#include <ntverp.h>
#include <locale.h>
#include <strsafe.h>
#include <memory>

void CheckHR( const WCHAR *pFailTxt, HRESULT Hr );
using namespace std;

typedef auto_ptr<WCHAR> CAutoString;

const UINT MAX_GUID_CHARS=40;
typedef OLECHAR GUIDSTR[MAX_GUID_CHARS];

extern bool g_Shutdown;
extern HANDLE g_MainThreadHandle;
void PollShutdown();
void SignalShutdown( DWORD MilliTimeout );

class AbortException
{
public:
    int Code;

    AbortException( int ErrorCode ) :
        Code( ErrorCode )
    {
    }
};
template<class T> class SmartRefPointer
{
private:
   T * m_Interface;

   void ReleaseIt()
   {
      if ( m_Interface )
         m_Interface->Release();
      m_Interface = NULL;
   }

   void RefIt()
   {
      if ( m_Interface )
          m_Interface->AddRef();
   }

public:

   SmartRefPointer()
   {
      m_Interface = NULL;
   }

   SmartRefPointer( T * RawInterface )
   {
      m_Interface = RawInterface;
      RefIt();
   }

   SmartRefPointer( SmartRefPointer & Other )
   {
      m_Interface = Other.m_Interface;
      RefIt();
   }

   ~SmartRefPointer()
   {
      ReleaseIt();
   }

   T * Get() const
   {
      return m_Interface;
   }

   T * Release()
   {
      T * temp = m_Interface;
      m_Interface = NULL;
      return temp;
   }

   void Clear()
   {
      ReleaseIt();
   }

   T** GetRecvPointer()
   {
      ReleaseIt();
      return &m_Interface;
   }

   SmartRefPointer & operator=( SmartRefPointer & Other )
   {
      ReleaseIt();
      m_Interface = Other.m_Interface;
      RefIt();
      return *this;
   }

   T* operator->() const
   {
      return m_Interface;
   }

   operator const T*() const
   {
      return m_Interface;
   }
};

typedef SmartRefPointer<IUnknown> SmartIUnknownPointer;
typedef SmartRefPointer<IBackgroundCopyManager> SmartManagerPointer;
typedef SmartRefPointer<IBackgroundCopyJob> SmartJobPointer;
typedef SmartRefPointer<IBackgroundCopyJob2> SmartJob2Pointer;
typedef SmartRefPointer<IBackgroundCopyError> SmartJobErrorPointer;
typedef SmartRefPointer<IBackgroundCopyFile> SmartFilePointer;
typedef SmartRefPointer<IEnumBackgroundCopyFiles> SmartEnumFilesPointer;
typedef SmartRefPointer<IEnumBackgroundCopyJobs> SmartEnumJobsPointer;

class AutoStringPointer
{
private:
   WCHAR * m_String;

public:

   AutoStringPointer( WCHAR *pString = NULL )
   {
      m_String = pString;
   }

   ~AutoStringPointer()
   {
      delete m_String;
      m_String = NULL;
   }

   WCHAR *Get()
   {
      return m_String;
   }

   WCHAR ** GetRecvPointer()
   {
      delete m_String;
      m_String = NULL;
      return &m_String;
   }

   void Clear()
   {
      delete m_String;
      m_String = NULL;
   }

   operator WCHAR *() const
   {
      return m_String;
   }

   AutoStringPointer & operator=( WCHAR *pString )
   {
      delete m_String;
      m_String = pString;
      return *this;
   }
};

extern WCHAR* pComputerName;
extern SmartManagerPointer g_Manager;
extern bool bRawReturn;
extern bool bWrap;
extern bool bExplicitWrap;

inline HRESULT
Job2FromJob(
    SmartJobPointer & Job,
    SmartJob2Pointer & Job2
    )
{
    return Job->QueryInterface( __uuidof(IBackgroundCopyJob2), (void **) Job2.GetRecvPointer() );
}


//
//  Generic print operators and input functions
//

class BITSOUTStream
{

  HANDLE Handle;

  char  MBBuffer[ 4096 * 8 ];
  WCHAR Buffer[ 4096 ];
  DWORD BufferUsed;

public:

  BITSOUTStream( DWORD StdHandle ) :
      BufferUsed( 0 ),
      Handle( GetStdHandle( StdHandle ) )
  {
  }

  void FlushBuffer( bool HasNewLine=false );
  void OutputString( const WCHAR *RawString );
  HANDLE GetHandle() { return Handle; }

};

extern BITSOUTStream bcout;
extern BITSOUTStream bcerr;

BITSOUTStream& operator<< (BITSOUTStream &s, const WCHAR * String );
BITSOUTStream& operator<< (BITSOUTStream &s, UINT64 Number );
WCHAR * HRESULTToString( HRESULT Hr );
BITSOUTStream& operator<< ( BITSOUTStream &s, AutoStringPointer & String );
BITSOUTStream& operator<< ( BITSOUTStream &s, GUID & guid );
BITSOUTStream& operator<< ( BITSOUTStream &s, FILETIME & filetime );
BITSOUTStream& operator<< ( BITSOUTStream &s, BG_JOB_PROXY_USAGE ProxyUsage );

ULONG InputULONG( WCHAR *pText );

class PrintSidString
{

public:

   WCHAR *m_SidString;

   PrintSidString( WCHAR * SidString ) :
       m_SidString( SidString )
   {
   }

};

void BITSADMINSetThreadUILanguage();

BOOL LocalConvertStringSidToSid( PWSTR StringSid, PSID *Sid, PWSTR *End );
BOOL AltConvertStringSidToSid( LPCWSTR StringSid, PSID *Sid ); 
                               
BITSOUTStream& operator<< ( BITSOUTStream &s, PrintSidString SidString );

void * _cdecl operator new( size_t Size );
void _cdecl operator delete( void *Mem );

void RestoreConsole();
void PollShutdown();
void ShutdownAPC( ULONG_PTR );
void SignalShutdown( DWORD MilliTimeout );
void CheckHR( const WCHAR *pFailTxt, HRESULT Hr );

//
// Code to handle console pretty printing mode changes
//

extern bool bConsoleInfoRetrieved;
extern HANDLE hConsole;
extern CRITICAL_SECTION CritSection;
extern CONSOLE_SCREEN_BUFFER_INFO StartConsoleInfo;
extern DWORD StartConsoleMode;

void SetupConsole();
void ChangeConsoleMode();
void RestoreConsole();
void ClearScreen();

//
// Classes set the intensity mode for the text.  Use as follows
// bcout << L"Some normal text " << AddIntensity();
// bcout << L"Intense text" << ResetIntensity() << L"Normal";
//


class AddIntensity
{
};

BITSOUTStream & operator<<( BITSOUTStream & s, AddIntensity  );

class ResetIntensity
{
};

BITSOUTStream & operator<<( BITSOUTStream & s, ResetIntensity );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bits_client_msm\bits_service_config\customactions.cpp ===
//-------------------------------------------------------------------------
//
//
//  Copyright (c) 1995 Microsoft Corporation
//
//  Module Name:
//
//    CustomActions.cpp
//
//  Abstract:
//
//    Windows Installer custom actions for installing the BITS client
//    service.
//
//  Author:
//
//    Edward Reus (Edwardr)
//
//  Revision History:
//
//    EdwardR    03-26-2002  Initial version.
//
//--------------------------------------------------------------------------

#include <windows.h>

HINSTANCE  g_hInstance = NULL;

//--------------------------------------------------------------------------
//  DllMain()
//
//--------------------------------------------------------------------------
extern "C"
BOOL WINAPI DllMain( IN HINSTANCE hInstance, 
                     IN DWORD     dwReason, 
                     IN LPVOID    lpReserved )
    {
    if (dwReason == DLL_PROCESS_ATTACH)
        {
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        }

    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bits_client_msm\bitscnfg\bitscnfg.cpp ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       bitscnfg.cpp
//
//  Contents:   Configure BITS client service to default settings.
//
//  EdwardR     07/27/2001   Initial version.
//              08/03/2001   Add code to fixup ServiceDLL in registry.
//                           Add code to regsvr qmgrprxy.dll
//              08/13/2001   Add code to support XP as well as Win2k.
//----------------------------------------------------------------------------

#define  UNICODE
#include <windows.h>
#include <stdio.h>
#include <malloc.h>

#define  VER_WINDOWS_2000         500
#define  VER_WINDOWS_XP           501
//
//  Service configuration settings:
//
#define BITS_SERVICE_NAME        TEXT("BITS")
#define BITS_DISPLAY_NAME        TEXT("Background Intelligent Transfer Service")
#define BITS_BINARY_PATH         TEXT("%SystemRoot%\\System32\\svchost.exe -k BITSgroup")
#define BITS_LOAD_ORDER_GROUP    TEXT("BITSgroup")

#define BITS_SERVICE_TYPE        SERVICE_WIN32_SHARE_PROCESS
#define BITS_START_TYPE          SERVICE_DEMAND_START
#define BITS_ERROR_CONTROL       SERVICE_ERROR_NORMAL

//
//  This additional service registry setting is set incorrectly by the
//  Darwin install
//
#define REG_SERVICE_PATH         TEXT("SYSTEM\\CurrentControlSet\\Services\\BITS")
#define REG_PARAMETERS           TEXT("Parameters")
#define REG_SERVICEDLL           TEXT("ServiceDll")
#define REG_SERVICEDLL_PATH      TEXT("%SystemRoot%\\System32\\qmgr.dll")

//
//  For side-by-side install on Windows XP
//
#define BACKSLASH_STR            TEXT("\\")
#define BITS_SUBDIRECTORY        TEXT("BITS")
#define BITS_QMGR_DLL            TEXT("qmgr.dll")

#define REG_BITS                 TEXT("BITS")
#define REG_BITS_SERVICEDLL      TEXT("ServiceDLL")
#define REG_SERVICEDLL_KEY       TEXT("Software\\Microsoft\\Windows\\CurrentVersion")

//
//  Constants to register qmgrprxy.dll
//
#define BITS_QMGRPRXY_DLL        TEXT("qmgrprxy.dll")
#define BITS_BITS15PRXY_DLL      TEXT("bitsprx2.dll")
#define BITS_DLL_REGISTER_FN     "DllRegisterServer"

typedef HRESULT (*RegisterFn)();

//
//  Constants for parsing bitscnfg.exe runstring arguments
//
#define SZ_DELIMITERS            " \t"
#define SZ_INSTALL               "/i"
#define SZ_UNINSTALL             "/u"
#define SZ_DELETE_SERVICE        "/d"

#define ACTION_INSTALL             0
#define ACTION_UNINSTALL           1
#define ACTION_DELETE_SERVICE      2

//
//  Log file for testing
//
FILE   *f = NULL;

//---------------------------------------------------------------------
//  RegSetKeyAndValue()
//
//  Helper function to create a key, sets a value in the key,
//  then close the key.
//
//  Parameters:
//    pwsKey       WCHAR* The name of the key
//    pwsSubkey    WCHAR* The name of a subkey
//    pwsValueName WCHAR* The value name.
//    pwsValue     WCHAR* The data value to store
//    dwType       The type for the new registry value.
//    dwDataSize   The size for non-REG_SZ registry entry types.
//
//  Return:
//    BOOL         TRUE if successful, FALSE otherwise.
//---------------------------------------------------------------------
DWORD RegSetKeyAndValue( const WCHAR *pwsKey,
                         const WCHAR *pwsSubKey,
                         const WCHAR *pwsValueName,
                         const WCHAR *pwsValue,
                         const DWORD  dwType = REG_SZ,
                               DWORD  dwDataSize = 0,
                               BOOL   fReCreate = TRUE )
    {
    HKEY   hKey;
    DWORD  dwStatus;
    DWORD  dwSize = 0;
    WCHAR  *pwsCompleteKey;

    if (pwsKey)
        dwSize = wcslen(pwsKey);

    if (pwsSubKey)
        dwSize += wcslen(pwsSubKey);

    dwSize = (1+1+dwSize)*sizeof(WCHAR);  // Extra +1 for the backslash...

    pwsCompleteKey = (WCHAR*)_alloca(dwSize);

    wcscpy(pwsCompleteKey,pwsKey);

    if (NULL!=pwsSubKey)
        {
        wcscat(pwsCompleteKey, BACKSLASH_STR);
        wcscat(pwsCompleteKey, pwsSubKey);
        }

    // If the key is already there then delete it, we will recreate it.
    if (fReCreate)
        {
        dwStatus = RegDeleteKey( HKEY_LOCAL_MACHINE,
                                 pwsCompleteKey );
        }

    dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pwsCompleteKey,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               NULL );
    if (dwStatus != ERROR_SUCCESS)
        {
        return dwStatus;
        }

    if (pwsValue)
        {
        if ((dwType == REG_SZ)||(dwType == REG_EXPAND_SZ))
          dwDataSize = (1+wcslen(pwsValue))*sizeof(WCHAR);

        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, dwDataSize );
        }
    else
        {
        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, 0 );
        }

    RegCloseKey(hKey);
    return dwStatus;
    }

//-------------------------------------------------------------------------
//  RegDeleteKeyOrValue()
//
//  Delete either the specified sub-key or delete the specified value
//  within the sub-key. If pwszValueName is specified, the just delete
//  it and leave the key alone. If pwszValueName is NULL, then delete
//  the key.
//-------------------------------------------------------------------------
DWORD RegDeleteKeyOrValue( IN const WCHAR *pwszKey,
                           IN const WCHAR *pwszSubKey,
                           IN const WCHAR *pwszValueName )
    {
    LONG    lStatus = 0;
    DWORD   dwLen;
    DWORD   dwSize;
    HKEY    hKey;
    WCHAR  *pwszCompleteKey;

    if (!pwszKey || !pwszSubKey)
        {
        return lStatus;
        }

    dwLen = wcslen(pwszKey) + wcslen(pwszSubKey) + 2;
    dwSize = dwLen * sizeof(WCHAR);
    pwszCompleteKey = (WCHAR*)_alloca(dwSize);
    wcscpy(pwszCompleteKey,pwszKey);
    wcscat(pwszCompleteKey,BACKSLASH_STR);
    wcscat(pwszCompleteKey,pwszSubKey);

    if (pwszValueName)
        {
        // Delete a value in a key:
        if (f) fwprintf(f,TEXT("Delete Reg Value: %s : %s\n"),pwszCompleteKey,pwszValueName);

        lStatus = RegOpenKey(HKEY_LOCAL_MACHINE,pwszCompleteKey,&hKey);
        if (lStatus == ERROR_SUCCESS)
            {
            lStatus = RegDeleteValue(hKey,pwszValueName);
            RegCloseKey(hKey);
            }
        }
    else
        {
        // Delete the specified key:
        if (f) fwprintf(f,TEXT("Delete Reg Key: %s\n"),pwszCompleteKey);

        lStatus = RegDeleteKey(HKEY_LOCAL_MACHINE,pwszCompleteKey);
        }

    return lStatus;
    }

//-------------------------------------------------------------------------
// RegisterDLL()
//
//-------------------------------------------------------------------------
DWORD RegisterDLL( IN WCHAR *pwszSubdirectory,
                   IN WCHAR *pwszDllName )
    {
    DWORD      dwStatus = 0;
    HMODULE    hModule;
    RegisterFn pRegisterFn;
    UINT       nChars;
    WCHAR      wszDllPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    if (pwszSubdirectory)
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(pwszDllName))) )
            {
            return ERROR_BUFFER_OVERFLOW;
            }

        wcscpy(wszDllPath,wszSystemDirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszSubdirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszDllName);
        }
    else
        {
        if (MAX_PATH < wcslen(pwszDllName))
            {
            return ERROR_BUFFER_OVERFLOW;
            }
        wcscpy(wszDllPath,pwszDllName);
        }

    hModule = LoadLibrary(wszDllPath);
    if (!hModule)
        {
        dwStatus = GetLastError();
        return dwStatus;
        }

    pRegisterFn = (RegisterFn)GetProcAddress(hModule,BITS_DLL_REGISTER_FN);
    if (!pRegisterFn)
        {
        dwStatus = GetLastError();
        FreeLibrary(hModule);
        return dwStatus;
        }

    dwStatus = pRegisterFn();

    FreeLibrary(hModule);

    return dwStatus;
    }

//-------------------------------------------------------------------------
// ParseCmdLine()
//
//-------------------------------------------------------------------------
void ParseCmdLine( LPSTR  pszCmdLine,
                   DWORD *pdwAction )
    {
    CHAR  *pszTemp = pszCmdLine;
    CHAR  *pszArg;
    BOOL   fFirstTime = TRUE;

    *pdwAction = ACTION_INSTALL;   // default is install.

    while (pszArg=strtok(pszTemp,SZ_DELIMITERS))
        {
        if (fFirstTime)
            {
            fFirstTime = FALSE;
            pszTemp = NULL;
            continue;       // Skip over program name...
            }

        if (!_stricmp(pszArg,SZ_INSTALL))
            {
            *pdwAction = ACTION_INSTALL;
            if (f) fwprintf(f,TEXT("Install: %S\n"),SZ_INSTALL);
            }
        if (!_stricmp(pszArg,SZ_UNINSTALL))
            {
            *pdwAction = ACTION_UNINSTALL;
            if (f) fwprintf(f,TEXT("Uninstall: %S\n"),SZ_UNINSTALL);
            }
        if (!_stricmp(pszArg,SZ_DELETE_SERVICE))
            {
            *pdwAction = ACTION_DELETE_SERVICE;
            if (f) fwprintf(f,TEXT("DeleteService: %S\n"),SZ_UNINSTALL);
            }
        }
    }

//-------------------------------------------------------------------------
//  DoInstall()
//-------------------------------------------------------------------------
DWORD DoInstall( DWORD dwOsVersion )
{
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwStatus = 0;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    //
    // Cleanup the service configuration:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));

        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (!ChangeServiceConfig(hService,
                                 BITS_SERVICE_TYPE,
                                 BITS_START_TYPE,
                                 BITS_ERROR_CONTROL,
                                 BITS_BINARY_PATH,
                                 NULL,   // Load order group (not changing this).
                                 NULL,   // Tag ID for load order group (not needed).

                                 // Service dependencies (this is different for Win2k )
                                 // reply on XP installer to overwrite this.
                                 TEXT("LanmanWorkstation\0Rpcss\0SENS\0Wmi\0"),   
                                 NULL,   // Account Name (not changing this).
                                 NULL,   // Account Password (not changing this).
                                 BITS_DISPLAY_NAME))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("ChangeServiceConfig(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        //
        //  Fix the ServiceDll registry value...
        //
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Fix ServiceDll entry.\n"));

        dwStatus = RegSetKeyAndValue( REG_SERVICE_PATH,
                                      REG_PARAMETERS,
                                      REG_SERVICEDLL,
                                      REG_SERVICEDLL_PATH,
                                      REG_EXPAND_SZ);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register qmgrproxy.dll
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_QMGRPRXY_DLL);

        dwStatus = RegisterDLL(NULL,BITS_QMGRPRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_QMGRPRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register bits15prxy.dll
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_BITS15PRXY_DLL);

        dwStatus = RegisterDLL(BITS_SUBDIRECTORY,BITS_BITS15PRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_BITS15PRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    // Configure WindowsXP BITS to run V1.5 qmgr.dll. This is also configured on Windows2000 systems to ready
    // it in case the system is upgraded to WindowsXP. This is done because there is no Migrate.dll to go from
    // Windows2000 to WindowsXP.
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(BITS_QMGR_DLL))) )
            {
            if (f) fwprintf(f,TEXT("GetSystemDirectory(): System Path too long.\n"));
            goto error;
            }

        wcscpy(wszQmgrPath,wszSystemDirectory);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_SUBDIRECTORY);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_QMGR_DLL);

        if (f) fwprintf(f,TEXT("Set BITS V1.5 Override Path: %s\n"),wszQmgrPath);


        dwStatus = RegSetKeyAndValue( REG_SERVICEDLL_KEY,
                                      REG_BITS,
                                      REG_BITS_SERVICEDLL,
                                      wszQmgrPath,
                                      REG_SZ, 0, FALSE);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DoUninstall()
//
//  If this is Windows2000 then delete the BITS service.
//-------------------------------------------------------------------------
DWORD DoUninstall( DWORD dwOsVersion )
{
    DWORD      dwStatus = 0;
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;


    //
    // Delete the BITS thunk DLL registry entry:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        // If Windows2000, then delete the BITS subkey and all its values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             NULL );
        }

    if (dwOsVersion == VER_WINDOWS_XP)
        {
        // If WindowsXP, then just delete the ServiceDLL value and leave the key and any other values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             REG_BITS_SERVICEDLL );
        }

    //
    //  If this is Windows2000, then delete the service.
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));
        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (dwStatus == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                dwStatus = 0;
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d) Service doesn't exist.\n"),dwStatus,dwStatus);
                }
            else
                {
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
                }
            goto error;
            }

        if (!DeleteService(hService))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("DeleteService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DeleteBitsService()
//
//  Currently this is the same action as DoInstall().
//-------------------------------------------------------------------------
DWORD DeleteBitsService( IN DWORD dwOsVersion )
    {
    return DoUninstall( dwOsVersion );
    }

//-------------------------------------------------------------------------
// main()
//
//-------------------------------------------------------------------------
int PASCAL WinMain( HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     pszCmdLine,
                    int       nCmdShow )
    {
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwAction;
    DWORD      dwStatus;
    DWORD      dwOsVersion;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];
    OSVERSIONINFO osVersionInfo;

    f = _wfopen(TEXT("c:\\temp\\bitscnfg.log"),TEXT("w"));

    if (f) fwprintf(f,TEXT("Runstring: %S\n"),pszCmdLine);

    ParseCmdLine(pszCmdLine,&dwAction);

    //
    // Get the operating system verison (Win2k == 500, XP == 501):
    //
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo))
        {
        dwStatus = GetLastError();
        if (f) fwprintf(f,TEXT("GetVersionEx(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
        goto error;
        }

    dwOsVersion = 100*osVersionInfo.dwMajorVersion + osVersionInfo.dwMinorVersion;

    if (f) fwprintf(f,TEXT("Windows Version: %d\n"),dwOsVersion);

    switch (dwAction)
        {
        case ACTION_INSTALL:
             dwStatus = DoInstall(dwOsVersion);
             break;

        case ACTION_UNINSTALL:
             dwStatus = DoUninstall(dwOsVersion);
             break;

        case ACTION_DELETE_SERVICE:
             dwStatus = DeleteBitsService(dwOsVersion);
             break;

        default:
             if (f) fwprintf(f,TEXT("Undefined Custom Action: %d\n"),dwAction);
             break;
        }

error:
    if (f) fwprintf(f,TEXT("bitscnfg.exe: Complete.\n"));

    if (f) fclose(f);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bits_client_msm\bits_service_config\register.cpp ===
//--------------------------------------------------------------------------
//  Copyright (c) Microsoft Corporation, 2001
//
//  register.cpp
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <advpub.h>
#include <msi.h>
#include <msiquery.h>
#include "resource.h"

extern   HMODULE  g_hInstance;   // Defined in ..\service\service.cxx

#define  BITS_SERVICE_NAME        TEXT("BITS")
#define  BITS_DISPLAY_NAME        TEXT("Background Intelligent Transfer Service")
#define  BITS_SVCHOST_CMDLINE_W2K TEXT("%SystemRoot%\\system32\\svchost.exe -k BITSgroup")
#define  BITS_SVCHOST_CMDLINE_XP  TEXT("%SystemRoot%\\system32\\svchost.exe -k netsvcs")
#define  BITS_DEPENDENCIES        TEXT("LanmanWorkstation\0Rpcss\0SENS\0Wmi\0")

#define  WSZ_MSI_REMOVE_PROP      TEXT("REMOVE")

#define  DEFAULT_INSTALL         "BITS_DefaultInstall"
#define  DEFAULT_UNINSTALL       "BITS_DefaultUninstall"

// Operating system versions.
#define  VER_WINDOWS_2000         500
#define  VER_WINDOWS_XP           501

// Constants used if we need to retry CreateService() because the service
// is marked for delete but not deleted yet.
#define  MAX_RETRIES               10
#define  RETRY_SLEEP_MSEC         200

// Constants for service restart on failure. 
#define  FAILURE_COUNT_RESET_SEC  (10*60)
#define  RESTART_DELAY_MSEC       (60*1000)

// The minimum DLL version for BITS RTM is 6.0
#define  BITS_MIN_DLL_VERSION      0x0006000000000000

// Old qmgr.dll name
#define  QMGR_DLL                  TEXT("qmgr.dll")
#define  QMGR_RENAME_DLL           TEXT("qmgr_old.dll")

#define  QMGRPRXY_DLL              TEXT("qmgrprxy.dll")
#define  QMGRPRXY_RENAME_DLL       TEXT("qmgrprxy_old.dll")

//
//  Constants to register qmgrprxy.dll
//
#define QMGRPRXY_DLL               TEXT("qmgrprxy.dll")
#define BITSPRX2_DLL               TEXT("bitsprx2.dll")
#define BITS_DLL_REGISTER_FN      "DllRegisterServer"

typedef HRESULT (*RegisterFn)();

//--------------------------------------------------------------------------
//  GetOsVersion()
//--------------------------------------------------------------------------
HRESULT GetOsVersion( OUT DWORD *pdwOsVersion )
    {
    HRESULT        hr = S_OK;
    OSVERSIONINFO  osVersionInfo;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo))
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        }
    else
        {
        *pdwOsVersion = 100*osVersionInfo.dwMajorVersion + osVersionInfo.dwMinorVersion;
        }

    return hr;
    }

//--------------------------------------------------------------------------
//  GetFileVersion()
//
//  Return file version information (if the file has any).
//--------------------------------------------------------------------------
HRESULT GetFileVersion( IN  WCHAR   *pwszFilePath,
                        OUT ULONG64 *pVersion )
    {
    DWORD  dwHandle = 0;
    DWORD  dwStatus = 0;
    DWORD  dwInfoSize;
    DWORD  dwLen;
    UINT   uiLen;
    char  *pData;
    VS_FIXEDFILEINFO *pFixedInfo;

    *pVersion = 0;

    //
    // Allocate enough memory to hold the version info
    //
    dwInfoSize = GetFileVersionInfoSize(pwszFilePath,&dwHandle);
    if (dwInfoSize == 0)
        {
        dwStatus = GetLastError();
        return HRESULT_FROM_WIN32(dwStatus);
        }

    pData = new char [dwInfoSize];
    if (!pData)
        {
        return E_OUTOFMEMORY;
        }

    memset(pData,0,dwInfoSize);

    //
    // Get the version info
    //
    if (!GetFileVersionInfo(pwszFilePath,dwHandle,dwInfoSize,pData))
        {
        dwStatus = GetLastError();
        delete [] pData;
        return HRESULT_FROM_WIN32(dwStatus);
        }

    if (!VerQueryValue(pData,L"\\",(void**)&pFixedInfo,&uiLen))
        {
        *pVersion = ( (ULONG64)(pFixedInfo->dwFileVersionMS) << 32) | (ULONG64)(pFixedInfo->dwFileVersionLS);
        }

    delete [] pData;

    return 0;
}

//-------------------------------------------------------------------------
// RegisterDLL()
//
//-------------------------------------------------------------------------
DWORD RegisterDLL( IN WCHAR *pwszSubdirectory,
                   IN WCHAR *pwszDllName )
    {
    DWORD      dwStatus = 0;
    HMODULE    hModule;
    RegisterFn pRegisterFn;
    UINT       nChars;
    WCHAR      wszDllPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];


    if (pwszSubdirectory)
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(pwszSubdirectory)+wcslen(pwszDllName))) )
            {
            return ERROR_BUFFER_OVERFLOW;
            }

        wcscpy(wszDllPath,wszSystemDirectory);
        wcscat(wszDllPath,L"\\");
        wcscat(wszDllPath,pwszSubdirectory);
        wcscat(wszDllPath,L"\\");
        wcscat(wszDllPath,pwszDllName);
        }
    else
        {
        if (MAX_PATH < wcslen(pwszDllName))
            {
            return ERROR_BUFFER_OVERFLOW;
            }
        wcscpy(wszDllPath,pwszDllName);
        }

    hModule = LoadLibrary(wszDllPath);
    if (!hModule)
        {
        dwStatus = GetLastError();
        return dwStatus;
        }

    pRegisterFn = (RegisterFn)GetProcAddress(hModule,BITS_DLL_REGISTER_FN);
    if (!pRegisterFn)
        {
        dwStatus = GetLastError();
        FreeLibrary(hModule);
        return dwStatus;
        }

    dwStatus = pRegisterFn();

    FreeLibrary(hModule);

    return dwStatus;
    }

//--------------------------------------------------------------------------
//  FileExists()
//
//  Return TRUE iff the specified file exists.
//--------------------------------------------------------------------------
BOOL FileExists( IN WCHAR *pwszFilePath )
    {
    BOOL   fExists;
    DWORD  dwAttributes;

    if (!pwszFilePath)
        {
        return FALSE;
        }
         
    dwAttributes = GetFileAttributes(pwszFilePath);

    fExists = (dwAttributes != INVALID_FILE_ATTRIBUTES);

    return fExists;
    }

//--------------------------------------------------------------------------
//  DoRegInstall()
//
//--------------------------------------------------------------------------
HRESULT DoRegInstall( IN HMODULE hModule,
                      IN LPCSTR  pszSection )
    {
    HRESULT  hr;
    DWORD    dwStatus;

    #if FALSE
    // This is test code to verify the INF is in the DLL resources...
    HRSRC    hResource;
    HGLOBAL  hGlobal;
    DWORD    dwSize;
    void    *pvInfData;


    hResource = FindResource(hModule,TEXT("REGINST"),TEXT("REGINST"));
    if (!hResource)
        {
        dwStatus = GetLastError();
        return HRESULT_FROM_WIN32(dwStatus);
    }

    dwSize = SizeofResource(hModule,hResource);

    hGlobal = LoadResource(hModule,hResource);
    if (!hGlobal)
        {
        dwStatus = GetLastError();
        return HRESULT_FROM_WIN32(dwStatus);
        }

    pvInfData = LockResource(hGlobal);

    // Note: No need to free hGlobal or "unlock" the data...

    // End test code...

    #endif

    hr = RegInstall( hModule, pszSection, NULL );

    #if FALSE
    if (FAILED(hr))
        {
        return hr;
        }

    // Temporary fixed for bitsprx2.dll registration...
    dwStatus = RegisterDLL(NULL,QMGRPRXY_DLL);
    if (dwStatus)
        {
        hr = HRESULT_FROM_WIN32(dwStatus);
        }

    dwStatus = RegisterDLL(NULL,BITSPRX2_DLL);
    if (dwStatus)
        {
        hr = HRESULT_FROM_WIN32(dwStatus);
        }
    #endif

    return hr;
    }

//------------------------------------------------------------------------
//  StopAndDeleteService()
//
//  Used to stop and delete the BITS service if it is currently installed.
//------------------------------------------------------------------------
HRESULT StopAndDeleteService( IN SC_HANDLE hSCM,
                              IN BOOL      fStopAndDelete )
    {
    HRESULT        hr = S_OK;
    DWORD          dwStatus;
    SC_HANDLE      hService;
    SERVICE_STATUS serviceStatus;
     
    hService = OpenService(hSCM, BITS_SERVICE_NAME, SERVICE_ALL_ACCESS);
    if(hService != NULL)
        {

        if (!ControlService(hService,SERVICE_CONTROL_STOP,&serviceStatus))
            {
            dwStatus = GetLastError();
            if (dwStatus != ERROR_SERVICE_NOT_ACTIVE)
                {
                hr = HRESULT_FROM_WIN32(dwStatus);
                }
            }
            
        if (!fStopAndDelete)
            {
            CloseServiceHandle(hService);
            return hr;
            }

        if (!DeleteService(hService))
            {
            dwStatus = GetLastError();
            if (dwStatus != ERROR_SERVICE_MARKED_FOR_DELETE)
                {
                hr = HRESULT_FROM_WIN32(dwStatus);
                }
            }

        CloseServiceHandle(hService);
        }
    else
        {
        dwStatus = GetLastError();
        
        // If the service doesn't exist, then that's Ok...
        if (dwStatus != ERROR_SERVICE_DOES_NOT_EXIST)
            {
            hr = HRESULT_FROM_WIN32(dwStatus);
            }
        }

    return hr;
    }

//----------------------------------------------------------------------
//  CreateBitsService()
//
//----------------------------------------------------------------------
HRESULT CreateBitsService( IN SC_HANDLE hSCM )
{
    HRESULT    hr = S_OK;
    DWORD      i;
    DWORD      dwStatus = 0;
    DWORD      dwOsVersion;
    SC_HANDLE  hService;
    WCHAR     *pwszSvcHostCmdLine;
    WCHAR     *pwszString;
    WCHAR      wszString[1024];
    SERVICE_DESCRIPTION     ServiceDescription;
    SERVICE_FAILURE_ACTIONS FailureActions;
    SC_ACTION               saActions[3];

    hr = GetOsVersion(&dwOsVersion);
    if (FAILED(hr))
        {
        return hr;
        }

    pwszSvcHostCmdLine = (dwOsVersion == VER_WINDOWS_2000)? BITS_SVCHOST_CMDLINE_W2K : BITS_SVCHOST_CMDLINE_XP;

    // Setup service failure recovery actions
    memset(&FailureActions,0,sizeof(SERVICE_FAILURE_ACTIONS));
    FailureActions.dwResetPeriod = FAILURE_COUNT_RESET_SEC;
    FailureActions.lpRebootMsg = NULL;
    FailureActions.lpCommand = NULL;
    FailureActions.cActions = sizeof(saActions)/sizeof(saActions[0]);  // Number of array elements.
    FailureActions.lpsaActions = saActions;

    // Wait for 60 seconds (RESTART_DELAY_MSEC), then for the first two failures try to restart the 
    // service, after that give up.
    saActions[0].Type = SC_ACTION_RESTART;
    saActions[0].Delay = RESTART_DELAY_MSEC;
    saActions[1].Type = SC_ACTION_RESTART;
    saActions[1].Delay = RESTART_DELAY_MSEC;
    saActions[2].Type = SC_ACTION_NONE;
    saActions[2].Delay = RESTART_DELAY_MSEC;


    if (LoadString(g_hInstance,IDS_SERVICE_NAME,wszString,sizeof(wszString)/sizeof(WCHAR)))
        {
        pwszString = wszString;
        }
    else
        {
        pwszString = BITS_DISPLAY_NAME;
        }

    for (i=0; i<MAX_RETRIES; i++)
        {
        hService = CreateService( hSCM,
                                  BITS_SERVICE_NAME,
                                  pwszString,
                                  SERVICE_ALL_ACCESS,
                                  SERVICE_WIN32_SHARE_PROCESS,
                                  SERVICE_DEMAND_START,
                                  SERVICE_ERROR_NORMAL,
                                  pwszSvcHostCmdLine,
                                  NULL,    // lpLoadOrderGroup
                                  NULL,    // lpdwTagId
                                  BITS_DEPENDENCIES,
                                  NULL,    // lpServiceStartName
                                  NULL );  // lpPassword

        if (hService)
            {
            // Set the service description string.
            if (LoadString(g_hInstance,IDS_SERVICE_DESC,wszString,sizeof(wszString)/sizeof(WCHAR)))
                {
                ServiceDescription.lpDescription = wszString;
    
                if (!ChangeServiceConfig2(hService,SERVICE_CONFIG_DESCRIPTION,&ServiceDescription))
                    {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
    
            // Set the service failure recovery actions.
            if (SUCCEEDED(hr))
                {
                if (!ChangeServiceConfig2(hService,SERVICE_CONFIG_FAILURE_ACTIONS,&FailureActions))
                  {
                  hr = HRESULT_FROM_WIN32(GetLastError());
                  }
                }

            CloseServiceHandle(hService);
            break;
            }
        else
            {
            dwStatus = GetLastError();
            if (dwStatus == ERROR_SERVICE_MARKED_FOR_DELETE)
                {
                Sleep(RETRY_SLEEP_MSEC);
                continue;
                }

            hr = HRESULT_FROM_WIN32(dwStatus);
            break;
            }
        }

    return hr;
    }

//----------------------------------------------------------------------
//  InfInstall()
//
//  Called durning setup to configure registry and service. This function
//  optionally creates the BITS service, then runs the qmgr_v15.inf INF 
//  file (stored as a resouce in CustomActions.dll) to either install or 
//  uninstall BITS.
//
//  fInstall       IN - TRUE if this is install, FALSE for uninstall.
//
//----------------------------------------------------------------------
STDAPI InfInstall( IN BOOL fInstall )
    {
    HRESULT   hr = S_OK;
    SC_HANDLE hSCM;
    DWORD     dwStatus;
    DWORD     dwOsVersion;
    BOOL      fStopAndDelete = TRUE;

    hr = GetOsVersion(&dwOsVersion);
    if (FAILED(hr))
        {
        return hr;
        }

    if ((fInstall == FALSE) && (dwOsVersion == VER_WINDOWS_XP))
        {
        fStopAndDelete = FALSE;  // Stop only in this case...
        }

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM)
        {
        hr = StopAndDeleteService(hSCM,fStopAndDelete);

        if (fInstall)
            {
            hr = CreateBitsService(hSCM);
            }

        CloseServiceHandle(hSCM);

        if (FAILED(hr))
            {
            return hr;
            }
        }
    else
        {
        dwStatus = GetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);
        return hr;
        }
     
    if (fInstall)
        {
        hr = DoRegInstall(g_hInstance,DEFAULT_INSTALL);
        }
    else
        {
        hr = DoRegInstall(g_hInstance,DEFAULT_UNINSTALL);
        }
        
    return hr;
    }

//----------------------------------------------------------------------
//  DllRegisterServer()
//
//----------------------------------------------------------------------
STDAPI DllRegisterServer(void)
    {
    return InfInstall(TRUE);
    }

//----------------------------------------------------------------------
//  DllUnregisterServer(void)
//
//----------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
    {
    return InfInstall(FALSE);
    }

//----------------------------------------------------------------------
//  BitsSetupAction()
//
//----------------------------------------------------------------------
UINT __stdcall BitsSetupAction( IN MSIHANDLE hInstall )
    {
    UINT   uiStatus;

    uiStatus = InfInstall(TRUE);

    return ERROR_SUCCESS;
    }

//----------------------------------------------------------------------
//  BitsRemoveAction()
//
//----------------------------------------------------------------------
UINT __stdcall BitsRemoveAction( IN MSIHANDLE hInstall )
    {
    UINT   uiStatus;
    WCHAR  wszPropVal[MAX_PATH];
    DWORD  dwLen = MAX_PATH;


    #if TRUE
    uiStatus = InfInstall(FALSE);
    #else
    uiStatus = MsiGetProperty( hInstall, WSZ_MSI_REMOVE_PROP, wszPropVal, &dwLen );
    if ((uiStatus == ERROR_SUCCESS)||(uiStatus == ERROR_MORE_DATA))
        {
        uiStatus = ERROR_SUCCESS;
        // If the propery REMOVE is set, then proceed with the uninstall.
        if (dwLen > 0)
            {
            uiStatus = InfInstall(FALSE);
            }
        }
    #endif

    return ERROR_SUCCESS;
    }

//----------------------------------------------------------------------
//  CopyCat()
//
//----------------------------------------------------------------------
WCHAR *CopyCat( IN WCHAR *pwszPath,
                IN WCHAR *pwszFile )
{
    DWORD  dwLen;
    WCHAR *pwszNew;

    if ((!pwszPath) || (!pwszFile))
        {
        return NULL;
        }
     
    dwLen = sizeof(WCHAR)*(wcslen(pwszPath) + wcslen(pwszFile) + 2);

    pwszNew = new WCHAR [dwLen];
    if (!pwszNew)
        {
        return NULL;
        }

    wcscpy(pwszNew,pwszPath);
    wcscat(pwszNew,L"\\");
    wcscat(pwszNew,pwszFile);

    return pwszNew;
}

//----------------------------------------------------------------------
//  BitsRenameAction()
//
//  See if an old qmgr.dll exists in the system32 directory. If yes,
//  then try to rename it.
//
//  NOTE: Currently we will "try" to move this file, but will will 
//        continue to run even if the attempt fails (i.e. we will 
//        always return success).
//----------------------------------------------------------------------
UINT __stdcall BitsRenameAction( IN MSIHANDLE hInstall )
    {
    ULONG64 uVersion;
    HRESULT hr;
    DWORD   dwLen;
    DWORD   dwCount;
    WCHAR   wszSystem32Path[MAX_PATH+1];
    WCHAR  *pwszQmgrPath = NULL;
    WCHAR  *pwszNewQmgrPath = NULL;
    WCHAR  *pwszQmgrprxyPath = NULL;
    WCHAR  *pwszNewQmgrprxyPath = NULL;

    dwLen = sizeof(wszSystem32Path)/sizeof(wszSystem32Path[0]);

    dwCount = GetSystemDirectory(wszSystem32Path,dwLen);
    if ((dwLen == 0) || (dwCount > dwLen))
        {
        goto cleanup;
        }

    pwszQmgrPath = CopyCat(wszSystem32Path,QMGR_DLL);
    pwszNewQmgrPath = CopyCat(wszSystem32Path,QMGR_RENAME_DLL);
    pwszQmgrprxyPath = CopyCat(wszSystem32Path,QMGRPRXY_DLL);
    pwszNewQmgrprxyPath = CopyCat(wszSystem32Path,QMGRPRXY_RENAME_DLL);

    if ((!pwszQmgrPath)||(!pwszNewQmgrPath)||(!pwszQmgrprxyPath)||(!pwszNewQmgrprxyPath))
        {
        goto cleanup;
        }

    if (!FileExists(pwszQmgrPath))
        {
        goto cleanup;
        }

    hr = GetFileVersion(pwszQmgrPath,&uVersion);
    if (FAILED(hr))
        {
        goto cleanup;
        }

    if (uVersion < BITS_MIN_DLL_VERSION)
        {
        // Old dll is present, rename it.
        DeleteFile(pwszNewQmgrPath);
        MoveFile(pwszQmgrPath,pwszNewQmgrPath);
        DeleteFile(pwszNewQmgrPath);
        }
    
    if (FileExists(pwszQmgrprxyPath))
        {
        DeleteFile(pwszNewQmgrprxyPath);
        MoveFile(pwszQmgrprxyPath,pwszNewQmgrprxyPath);
        DeleteFile(pwszNewQmgrprxyPath);
        }

cleanup:
    if (pwszQmgrPath) delete [] pwszQmgrPath;
    if (pwszNewQmgrPath) delete [] pwszNewQmgrPath;
    if (pwszQmgrprxyPath) delete [] pwszQmgrprxyPath;
    if (pwszNewQmgrprxyPath) delete [] pwszNewQmgrprxyPath;

    return ERROR_SUCCESS;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bits_client_msm\bits_service_config\resource.h ===
//---------------------------------------------------------------------
//  Copyright (c) Microsoft Corporation, 2001
//
//  resource.h
//
//---------------------------------------------------------------------

#define  IDS_SERVICE_NAME           1000
#define  IDS_SERVICE_DESC           1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\idl\drizcompat.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//=======================================================================


#define IBackgroundCopyJob          IBackgroundCopyJob1
#define IBackgroundCopyCallback     IBackgroundCopyCallback1
#define IEnumBackgroundCopyJobs     IEnumBackgroundCopyJobs1

#define IID_IBackgroundCopyJob          IID_IBackgroundCopyJob1
#define IID_IBackgroundCopyCallback     IID_IBackgroundCopyCallback1
#define IID_IEnumBackgroundCopyJobs     IID_IEnumBackgroundCopyJobs1

#define CLSID_IBackgroundCopyJob          CLSID_IBackgroundCopyJob1
#define CLSID_IBackgroundCopyCallback     CLSID_IBackgroundCopyCallback1
#define CLSID_IEnumBackgroundCopyJobs     CLSID_IEnumBackgroundCopyJobs1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bits_ie\bits_ie.cpp ===
/************************************************************************

Copyright (c) Microsoft Corporation

Module Name :

    bits_ie.cpp

Abstract :

    Sample background downloader which uses BITS.

Revision History :

Notes:

    This program is a very simple background downloader which demonstrates
    the use of BITS. The program hooks into the IE context menu, to
    allow the user to schedule the download instead of using the default
    IE downloader.

Concepts Covered:

    1. Basic connection with manager and job submission.
    2. Example presentation to user of job state.
    3. Job control such as suspend/resume/cancel/complete.
    4. Interface based callbacks for updating progress/state.
    5. How to get the text message for a BITS error code.
    
 ***********************************************************************/

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#pragma warning( disable : 4786 )

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>
#include <float.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <wininet.h>
#include <shlobj.h>
#include "resource.h"
#include <bits.h>
#include <comdef.h>

template<class T> class SmartRefPointer
{
private:
   T * m_Interface;

   void ReleaseIt()
   {
      if ( m_Interface )
         m_Interface->Release();
      m_Interface = NULL;
   }

   void RefIt()
   {
      if ( m_Interface )
          m_Interface->AddRef();
   }

public:

   SmartRefPointer()
   {
      m_Interface = NULL;
   }

   SmartRefPointer( T * RawInterface )
   {
      m_Interface = RawInterface;
      RefIt();
   }

   SmartRefPointer( SmartRefPointer & Other )
   {
      m_Interface = Other.m_Interface;
      RefIt();
   }

   ~SmartRefPointer()
   {
      ReleaseIt();
   }

   T * Get() const
   {
      return m_Interface;
   }

   T * Release()
   {
      T * temp = m_Interface;
      m_Interface = NULL;
      return temp;
   }

   void Clear()
   {
      ReleaseIt();
   }

   T** GetRecvPointer()
   {
      ReleaseIt();
      return &m_Interface;
   }

   SmartRefPointer & operator=( SmartRefPointer & Other )
   {
      ReleaseIt();
      m_Interface = Other.m_Interface;
      RefIt();
      return *this;
   }

   T* operator->() const
   {
      return m_Interface;
   }

   operator const T*() const
   {
      return m_Interface;
   }
};

typedef SmartRefPointer<IUnknown> SmartIUnknownPointer;
typedef SmartRefPointer<IBackgroundCopyManager> SmartManagerPointer;
typedef SmartRefPointer<IBackgroundCopyJob> SmartJobPointer;
typedef SmartRefPointer<IBackgroundCopyJob2> SmartJob2Pointer;
typedef SmartRefPointer<IBackgroundCopyError> SmartJobErrorPointer;
typedef SmartRefPointer<IBackgroundCopyFile> SmartFilePointer;
typedef SmartRefPointer<IEnumBackgroundCopyFiles> SmartEnumFilesPointer;
typedef SmartRefPointer<IEnumBackgroundCopyJobs> SmartEnumJobsPointer;
typedef SmartRefPointer<IShellLink> SmartShellLinkPointer;
typedef SmartRefPointer<IPersistFile> SmartPersistFilePointer;

// Maxstring size, bump up on problems
#define MAX_STRING 0x800 // 2K

GUID g_JobId;
WCHAR g_szFileName[MAX_PATH];
HWND g_hwndDlg = NULL;

// These two global variables throttle updates.
// The algorithm is to set a timer on the first update request,
// and delay additional updates until after the timer expires.

// The timer is set
bool g_UpdateTimerSet = FALSE;
// Received on update request while timer is active
bool g_RefreshOnTimer = FALSE; 

SmartJobPointer g_pJob;
SmartManagerPointer g_pManager;

void HandleUpdate( );
void CheckHR( HWND hwnd, HRESULT Hr, bool bThrow );

void SafeCopy( WCHAR * Dest, const WCHAR * Source, size_t Count )
{
    if ( !Count )
        return;

    while (Count && (*Source != L'\0'))
    {
        *Dest++ = *Source++;
        Count--;
    }

    if (Count == 0)
    {
        // we are going to truncate Dest
        Dest--;
    }

    *Dest= L'\0';
}

void SafeCat( WCHAR * Dest, const WCHAR * Source, size_t Count )
{
    size_t DestSize = wcslen( Dest );

    if ( DestSize > Count )
        return;

    SafeCopy( Dest + DestSize,
              Source,
              Count - DestSize );
}

void SafeStringPrintf( WCHAR *Dest, DWORD Count, const WCHAR * Format, ... )
{
     va_list arglist;
     va_start( arglist, Format );

     if ( !Count )
         return;
     
     int Ret;
     size_t Max;

     // leave the last space for the null terminator
     Max = Count - 1;

     Ret = _vsnwprintf( Dest, Max, Format, arglist);

     if ((Ret < 0) || (((size_t)Ret) > Max))
     {
         // need to null terminate the string
         Dest += Max;
         *Dest = '\0';
     }
     else if (((size_t)Ret) == Max)
     {
         // need to null terminate the string
         Dest += Max;
         *Dest = '\0';
     }
}

const WCHAR * GetString( UINT id )
{

    //
    // Retrieves the localized string for the resource id
    // caching the string when loaded.

    static const WCHAR* pStringArray[ IDS_MAX ];
    static WCHAR TempStringBuffer[ MAX_STRING ];
    const WCHAR * & pStringPointer = pStringArray[ id - 1 ];

    // Cache resource strings
    if ( pStringPointer )
        return pStringPointer;

    // Load string from resource

    int CharsLoaded =
        LoadStringW(
            (HINSTANCE)GetModuleHandle(NULL),
            id,
            TempStringBuffer,
            MAX_STRING );

    if ( !CharsLoaded )
        {
        CheckHR( NULL, HRESULT_FROM_WIN32( GetLastError() ), false );
        return L"";
        }

    WCHAR *pNewString = new WCHAR[ CharsLoaded + 1];
    if ( !pNewString )
        {
        CheckHR( NULL, E_OUTOFMEMORY, false );
        return L"";
        }

    SafeCopy( pNewString, TempStringBuffer, CharsLoaded + 1 );
    return ( pStringPointer = pNewString );

}

void
DeleteStartupLink(
    GUID JobID
    )
{

    //
    // Delete the link in the Startup folder for the job
    //

    WCHAR szLinkFileName[MAX_PATH] = {0};
    WCHAR szGUIDString[MAX_PATH] = {0};

    BOOL bResult =
        SHGetSpecialFolderPath(
            NULL,
            szLinkFileName,
            CSIDL_STARTUP,
            FALSE );

    if ( !bResult )
        return;

    SafeCat( szLinkFileName, L"\\", MAX_PATH );
    SafeCat( szLinkFileName, GetString( IDS_STARTUPLINK ), MAX_PATH );
    SafeCat( szLinkFileName, L" ", MAX_PATH );

    StringFromGUID2( JobID, szGUIDString, MAX_PATH );
    SafeCat( szLinkFileName, szGUIDString, MAX_PATH );
    SafeCat( szLinkFileName, L".lnk", MAX_PATH );

    if (!DeleteFile( szLinkFileName ))
        {
        DWORD dwError = GetLastError();
        if ( ERROR_PATH_NOT_FOUND != dwError &&
             ERROR_FILE_NOT_FOUND != dwError )
            {
            CheckHR( NULL, HRESULT_FROM_WIN32( dwError ), false );
            }
        }

}

void
CreateStartupLink(
    GUID JobID,
    WCHAR *pszFileName
    )
{
    //
    // Create a link in the Startup folder for this job.
    //

    SmartShellLinkPointer   ShellLink;
    SmartPersistFilePointer PersistFile;

    WCHAR szLinkFileName[MAX_PATH] = {0};

    BOOL bResult =
        SHGetSpecialFolderPath(
            NULL,
            szLinkFileName,
            CSIDL_STARTUP,
            FALSE );

    if ( !bResult )
        CheckHR( NULL, E_FAIL, true );

    WCHAR szLinkDescription[MAX_PATH] = {0};
    SafeCopy( szLinkDescription, GetString( IDS_STARTUPLINK ), MAX_PATH );
    SafeCat( szLinkDescription, L" ", MAX_PATH );

    WCHAR szGUIDString[MAX_PATH] = {0};
    StringFromGUID2( JobID, szGUIDString, MAX_PATH );
    SafeCat( szLinkDescription, szGUIDString, MAX_PATH );

    WCHAR szArguments[MAX_PATH] = {0};
    SafeCopy( szArguments, L"/RESUMEJOB ", MAX_PATH);
    SafeCat( szArguments, szGUIDString, MAX_PATH );
    SafeCat( szArguments, L" ", MAX_PATH );
    SafeCat( szArguments, pszFileName, MAX_PATH );

    SafeCat( szLinkFileName, L"\\", MAX_PATH );
    SafeCat( szLinkFileName, szLinkDescription, MAX_PATH );
    SafeCat( szLinkFileName, L".lnk", MAX_PATH );

    CheckHR( NULL, 
             CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                               IID_IShellLink, (LPVOID*)ShellLink.GetRecvPointer() ),
             true );

    CheckHR( NULL, ShellLink->SetShowCmd( SW_SHOWMINIMIZED ), true );
    CheckHR( NULL, ShellLink->QueryInterface( IID_IPersistFile, (LPVOID*)PersistFile.GetRecvPointer() ), true );
    CheckHR( NULL, ShellLink->SetPath( L"%windir%\\system32\\bits_ie.exe" ), true );
    CheckHR( NULL, ShellLink->SetArguments( szArguments ), true );
    CheckHR( NULL, ShellLink->SetDescription( szLinkDescription ), true );
    CheckHR( NULL, PersistFile->Save( szLinkFileName, TRUE ), true );

}


void SetWindowTime(
    HWND hwnd,
    FILETIME filetime
    )
{
     // Set the window text to be the text representation
     // of the file time.
     // If an error occurs, set the window text to be error

     FILETIME localtime;
     FileTimeToLocalFileTime( &filetime, &localtime );

     SYSTEMTIME systemtime;
     FileTimeToSystemTime( &localtime, &systemtime );

     WCHAR DateBuffer[ MAX_STRING ];

     int DateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             DateBuffer,
             MAX_STRING );

     if (!DateSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR TimeBuffer[ MAX_STRING ];

     int TimeSize =
        GetTimeFormatW(
            LOCALE_USER_DEFAULT,
            0,
            &systemtime,
            NULL,
            TimeBuffer,
            MAX_STRING );

     if (!TimeSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR FullTime[ MAX_STRING ];
     SafeStringPrintf( FullTime, MAX_STRING, 
                       L"%s %s", DateBuffer, TimeBuffer );

     SetWindowText( hwnd, FullTime );
}

UINT64
GetSystemTimeAsUINT64()
{

    //
    // Returns the system time as an UINT instead of a FILETIME.
    //

    FILETIME filetime;
    GetSystemTimeAsFileTime( &filetime );

    ULARGE_INTEGER large;
    memcpy( &large, &filetime, sizeof(FILETIME) );

    return large.QuadPart;
}

void SignalAlert(
    HWND hwndDlg,
    UINT Type
    )
{

    //
    // Alert the user that an important event has occurred
    //

    FLASHWINFO FlashInfo;
    FlashInfo.cbSize    = sizeof(FlashInfo);
    FlashInfo.hwnd      = hwndDlg;
    FlashInfo.dwFlags   = FLASHW_ALL | FLASHW_TIMERNOFG;
    FlashInfo.uCount    = 0;
    FlashInfo.dwTimeout = 0;

    FlashWindowEx( &FlashInfo );
    MessageBeep( Type );

}

const WCHAR *
MapStateToString(
    BG_JOB_STATE state
    )
{

   //
   // Maps a BITS job state to a human readable string
   //

   switch( state )
       {

       case BG_JOB_STATE_QUEUED:
           return GetString( IDS_QUEUED );

       case BG_JOB_STATE_CONNECTING:
           return GetString( IDS_CONNECTING );

       case BG_JOB_STATE_TRANSFERRING:
           return GetString( IDS_TRANSFERRING );

       case BG_JOB_STATE_SUSPENDED:
           return GetString( IDS_SUSPENDED );

       case BG_JOB_STATE_ERROR:
           return GetString( IDS_FATALERROR );

       case BG_JOB_STATE_TRANSIENT_ERROR:
           return GetString( IDS_TRANSIENTERROR );

       case BG_JOB_STATE_TRANSFERRED:
           return GetString( IDS_TRANSFERRED );

       case BG_JOB_STATE_ACKNOWLEDGED:
           return GetString( IDS_ACKNOWLEDGED );

       case BG_JOB_STATE_CANCELLED:
           return GetString( IDS_CANCELLED );

       default:

           // NOTE: Always provide a default case
           // since new states may be added in future versions.
           return GetString( IDS_UNKNOWN );

       }
}

double
ScaleDownloadRate(
    double Rate, // rate in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download rate and selects the correct
    // format to pass to wprintf for printing.
    //

    double RateBounds[] =
    {
       1073741824.0, // Gigabyte
       1048576.0,    // Megabyte
       1024.0,       // Kilobyte
       0             // Byte
    };

    UINT RateFormat[] =
    {
        IDS_GIGAFORMAT,
        IDS_MEGAFORMAT,
        IDS_KILOFORMAT,
        IDS_BYTEFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Rate >= RateBounds[c] )
            {
            *pFormat = GetString( RateFormat[c] );
            double scale = (RateBounds[c] >= 1.0) ? RateBounds[c] : 1.0;
            return Rate / scale;
            }
        }
}

UINT64
ScaleDownloadEstimate(
    double Time, // time in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download time estimate and selects the correct
    // format to pass to wprintf for printing.
    //


    double TimeBounds[] =
    {
       60.0 * 60.0 * 24.0,        // Days
       60.0 * 60.0,               // Hours
       60.0,                      // Minutes
       0.0                        // Seconds
    };

    UINT TimeFormat[] =
    {
        IDS_DAYSFORMAT,
        IDS_HOURSFORMAT,
        IDS_MINUTESFORMAT,
        IDS_SECONDSFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Time >= TimeBounds[c] )
            {
            *pFormat = GetString( TimeFormat[c] );
            double scale = (TimeBounds[c] >= 1.0) ? TimeBounds[c] : 1.0;
            return (UINT64)floor( ( Time / scale ) + 0.5);
            }
        }

}

void
UpdateDialog(
    HWND hwndDlg
    )
{

   //
   // Main update routine for the dialog box.
   // Retries the job state/properties from
   // BITS and updates the dialog box.
   //

   {
   // update the display name

   HWND hwndDisplayName = GetDlgItem( hwndDlg, IDC_DISPLAYNAME );
   WCHAR * pszDisplayName = NULL;
   if (FAILED( g_pJob->GetDisplayName( &pszDisplayName ) ) ) 
       return; // stop updating on an error
   SetWindowText( hwndDisplayName, pszDisplayName );
   ShowWindow( hwndDisplayName, SW_SHOW );
   CoTaskMemFree( pszDisplayName );

   }

   static BG_JOB_STATE prevstate = BG_JOB_STATE_SUSPENDED;
   BG_JOB_STATE state;

   if (FAILED(g_pJob->GetState( &state )))
       return; // stop updating on an error

   if ( BG_JOB_STATE_ACKNOWLEDGED == state ||
        BG_JOB_STATE_CANCELLED == state )
       {
       // someone else cancelled or completed the job on us,
       // just exist the exit.
       // May happen if job is canceled with bitsadmin

       DeleteStartupLink( g_JobId );
       PostQuitMessage( 0 );
       return;
       }

   BG_JOB_PROGRESS progress;
   if (FAILED(g_pJob->GetProgress( &progress )))
       return; // stop updating on an error

   {
      // update the title, progress bar, and progress description
      WCHAR szProgress[MAX_STRING];
      WCHAR szTitle[MAX_STRING];
      WPARAM newpos = 0;

      if ( progress.BytesTotal &&
           ( progress.BytesTotal != BG_SIZE_UNKNOWN ) )
          {
          SafeStringPrintf( 
              szProgress, MAX_STRING, GetString( IDS_LONGPROGRESS ), 
              progress.BytesTransferred, progress.BytesTotal );

          double Percent = (double)(__int64)progress.BytesTransferred /
                           (double)(__int64)progress.BytesTotal;
          Percent *= 100.0;
          SafeStringPrintf( 
              szTitle, MAX_STRING, L"%u%% %s", 
              (unsigned int)Percent, g_szFileName );
          newpos = (WPARAM)Percent;

          }
      else
          {
          SafeStringPrintf( 
              szProgress, MAX_STRING, GetString( IDS_SHORTPROGRESS ), 
              progress.BytesTransferred );
          SafeCopy( szTitle, g_szFileName, MAX_STRING );
          newpos = 0;
          }

      SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETPOS, newpos, 0 );
      SetWindowText( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), szProgress );
      ShowWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), SW_SHOW );
      EnableWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFOTXT ), TRUE );
      SetWindowText( hwndDlg, szTitle );

   }

   {
   // update the status
   HWND hwndStatus = GetDlgItem( hwndDlg, IDC_STATUS );

   SetWindowText( hwndStatus, MapStateToString( state ) );
   ShowWindow( hwndStatus, SW_SHOW );

   // Only enable the finish button if the job is finished.
   EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_TRANSFERRED ) );

   // Only enable the suspend button if the job is not finished or transferred
   BOOL EnableSuspend =
       ( state != BG_JOB_STATE_SUSPENDED ) && ( state != BG_JOB_STATE_TRANSFERRED );
   EnableWindow( GetDlgItem( hwndDlg, IDC_SUSPEND ), EnableSuspend );

   // Only enable the resume button if the job is suspended
   BOOL EnableResume = ( BG_JOB_STATE_SUSPENDED == state );
   EnableWindow( GetDlgItem( hwndDlg, IDC_RESUME ), EnableResume );

   // Alert the user when something important happens
   // such as the job completes or a unrecoverable error occurs
   if ( BG_JOB_STATE_TRANSFERRED == state &&
        BG_JOB_STATE_TRANSFERRED != prevstate )
       SignalAlert( hwndDlg, MB_OK );

   else if ( BG_JOB_STATE_ERROR == state &&
        BG_JOB_STATE_ERROR != prevstate )
       SignalAlert( hwndDlg, MB_ICONEXCLAMATION );

   }

   {
   // update times
   BG_JOB_TIMES times;
   if (FAILED(g_pJob->GetTimes( &times )))
       return;

   HWND hwndCreationTime = GetDlgItem( hwndDlg, IDC_STARTTIME );
   SetWindowTime( hwndCreationTime, times.CreationTime );
   ShowWindow( hwndCreationTime, SW_SHOW );

   HWND hwndModificationTime = GetDlgItem( hwndDlg, IDC_MODIFICATIONTIME );
   SetWindowTime( hwndModificationTime, times.ModificationTime );
   ShowWindow( hwndModificationTime, SW_SHOW );

   HWND hwndCompletionTime = GetDlgItem( hwndDlg, IDC_COMPLETIONTIME );
   if ( !times.TransferCompletionTime.dwLowDateTime && !times.TransferCompletionTime.dwHighDateTime )
       {

       // BITS sets the CompletionTime to all zeros
       // if the job is incomplete

       ShowWindow( hwndCompletionTime, SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_COMPLETIONTIMETXT ), FALSE );
       }
   else
       {
       SetWindowTime( hwndCompletionTime, times.TransferCompletionTime );
       ShowWindow( hwndCompletionTime, SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_COMPLETIONTIMETXT ), TRUE );
       }
   }

   {
   // update the error message
   IBackgroundCopyError *pError;
   HRESULT Hr = g_pJob->GetError( &pError );

   if ( FAILED(Hr) )
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ERRORMSG ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), FALSE );
       }
   else
       {

       WCHAR* pszDescription = NULL;
       WCHAR* pszContext = NULL;

       // If these APIs fail, we should get back
       // a NULL string. So everything should be harmless.

       pError->GetErrorDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszDescription );
       pError->GetErrorContextDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszContext );

       WCHAR FullText[ MAX_STRING ];
       FullText[0] = L'\0';

       if ( pszDescription )
           SafeCopy( FullText, pszDescription, MAX_STRING );
       if ( pszContext )
           SafeCat( FullText, pszContext, MAX_STRING );
       CoTaskMemFree( pszDescription );
       CoTaskMemFree( pszContext );

       HWND hwndErrorText = GetDlgItem( hwndDlg, IDC_ERRORMSG );
       SetWindowText( hwndErrorText, FullText );
       ShowWindow( hwndErrorText, SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), TRUE );

       }

   }

   if (!SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_GETDROPPEDSTATE, 0, 0) )
       {
       // set the priority, but only do it if user isn't trying to
       // set the priority.
       BG_JOB_PRIORITY priority;
       g_pJob->GetPriority( &priority );
       SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_SETCURSEL, (WPARAM)priority, 0 );
       }

   {

   //
   // This large block of text computes the average transfer rate
   // and estimated completion time.  This code has much
   // room for improvement.
   //

   static BOOL HasRates = FALSE;
   static UINT64 LastMeasurementTime;
   static UINT64 LastMeasurementBytes;
   static double LastMeasurementRate;

   WCHAR szRateText[MAX_STRING];
   BOOL EnableRate = FALSE;

   if ( !( BG_JOB_STATE_QUEUED == state ) &&
        !( BG_JOB_STATE_CONNECTING == state ) &&
        !( BG_JOB_STATE_TRANSFERRING == state ) )
       {
       // If the job isn't running, then rate values won't
       // make any sense. Don't display them.
       HasRates = FALSE;
       }
   else
       {

       if ( !HasRates )
           {
           LastMeasurementTime = GetSystemTimeAsUINT64();
           LastMeasurementBytes = progress.BytesTransferred;
           LastMeasurementRate = 0;
           HasRates = TRUE;
           }
       else
           {

           UINT64 CurrentTime = GetSystemTimeAsUINT64();
           UINT64 NewTotalBytes = progress.BytesTransferred;

           UINT64 NewTimeDiff = CurrentTime - LastMeasurementTime;
           UINT64 NewBytesDiff = NewTotalBytes - LastMeasurementBytes;
           double NewInstantRate = (double)(__int64)NewBytesDiff /
                                   (double)(__int64)NewTimeDiff;
           double NewAvgRate = (0.3 * LastMeasurementRate) +
                               (0.7 * NewInstantRate );

           if ( !_finite(NewInstantRate) || !_finite(NewAvgRate) )
               {
               NewInstantRate = 0;
               NewAvgRate = LastMeasurementRate;
               }

           LastMeasurementTime = CurrentTime;
           LastMeasurementBytes = NewTotalBytes;
           LastMeasurementRate = NewAvgRate;

           // convert from FILETIME units to seconds
           double NewDisplayRate = NewAvgRate * 10000000;

           const WCHAR *pRateFormat = NULL;
           double ScaledRate = ScaleDownloadRate( NewDisplayRate, &pRateFormat );
           SafeStringPrintf( szRateText, MAX_STRING, pRateFormat, ScaledRate );
           
           EnableRate = TRUE;
           }

       }

   if (!EnableRate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), szRateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), TRUE );
       }

   BOOL EnableEstimate = FALSE;
   WCHAR szEstimateText[MAX_STRING];

   if ( EnableRate )
       {

       if ( progress.BytesTotal != 0 &&
            progress.BytesTotal != BG_SIZE_UNKNOWN )
           {

           double TimeRemaining =
               ( (__int64)progress.BytesTotal - (__int64)LastMeasurementBytes ) / LastMeasurementRate;

           // convert from FILETIME units to seconds
           TimeRemaining = TimeRemaining / 10000000.0;

           static const double SecsPer30Days = 60.0 * 60.0 * 24.0 * 30.0;

           // Don't estimate if estimate is larger then 30 days.
           if ( TimeRemaining < SecsPer30Days )
               {

               const WCHAR *pFormat = NULL;
               UINT64 Time = ScaleDownloadEstimate( TimeRemaining, &pFormat );
               SafeStringPrintf( szEstimateText, MAX_STRING, pFormat, Time );
               EnableEstimate = TRUE;
               }
           }
       }

   if (!EnableEstimate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), szEstimateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), TRUE );
       }

   }

   prevstate = state;
}

void
InitDialog(
    HWND hwndDlg
    )
{

   //
   // Populate the priority list with priority descriptions
   //

   const WCHAR *Foreground    = GetString( IDS_FOREGROUND );
   const WCHAR *High          = GetString( IDS_HIGH );
   const WCHAR *Normal        = GetString( IDS_NORMAL );
   const WCHAR *Low           = GetString( IDS_LOW );

   SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETRANGE, 0, MAKELPARAM(0, 100) );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Foreground );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)High );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Normal );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Low );

}

void CheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{
    //
    // Provides automatic error code checking and dialog
    // for generic system errors
    //

    if (SUCCEEDED(Hr))
        return;

    WCHAR * pszError = NULL;

    DWORD dwFormatError =
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        (DWORD)Hr,
        LANGIDFROMLCID( GetThreadLocale() ),
        (WCHAR*)&pszError,
        0,
        NULL );

    if ( !dwFormatError ) 
       {
       WCHAR ErrorMsg[ MAX_STRING ];
       SafeStringPrintf( ErrorMsg, MAX_STRING, GetString( IDS_DISPLAYERRORCODE ), Hr );
       
       MessageBox( hwnd, ErrorMsg, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );
       }
    else
       {
       MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );
       LocalFree( pszError );
       }

    if ( bThrow )
        throw _com_error( Hr );

}

void BITSCheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{

   //
   // Provides automatic error code checking and dialog
   // for BITS specific errors
   //


   if (SUCCEEDED(Hr))
       return;

   WCHAR * pszError = NULL;
   HRESULT hErrorHr = 
   g_pManager->GetErrorDescription(
       Hr,
       LANGIDFROMLCID( GetThreadLocale() ),
       &pszError );

   if ( FAILED(hErrorHr) || !pszError )
       {

       WCHAR ErrorMsg[ MAX_STRING ];
       SafeStringPrintf( ErrorMsg, MAX_STRING, GetString( IDS_DISPLAYERRORCODE ), Hr );

       MessageBox( hwnd, ErrorMsg, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );

       }

   else
       {
      
       MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );
       CoTaskMemFree( pszError );

       }


   if ( bThrow )
       throw _com_error( Hr );
}

void
DoCancel(
    HWND hwndDlg,
    bool PromptUser
    )
{

   //
   // Handle all the operations required to cancel the job.
   // This includes asking the user for confirmation.
   //

   if ( PromptUser )
       {

       int Result =
           MessageBox(
               hwndDlg,
               GetString( IDS_CANCELTEXT ),
               GetString( IDS_CANCELCAPTION ),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
               MB_SETFOREGROUND | MB_TOPMOST );


       if ( IDYES != Result )
           return;

       }

   try
   {
       BITSCheckHR( hwndDlg, g_pJob->Cancel(), true );
   }
   catch( _com_error Error )
   {
       // If we can't cancel for some unknown reason,
       // don't exit
       return;
   }

   DeleteStartupLink( g_JobId );
   PostQuitMessage( 0 );
}

void
DoFinish(
    HWND hwndDlg
    )
{

   //
   // Handles all the necessary work to complete
   // the download.
   //

   try
   {
       BITSCheckHR( hwndDlg, g_pJob->Complete(), true );
   }
   catch( _com_error Error )
   {
       // If we can't finish/complete for some unknown reason,
       // don't exit
       return;
   }

   DeleteStartupLink( g_JobId );
   PostQuitMessage( 0 );

}

void
DoClose(
    HWND hwndDlg
    )
{
    //
    // Handles an attempt by the user to close the sample.
    //

    // Check to see if the download has finished,
    // if so don't let the user exit.

    BG_JOB_STATE state;
    HRESULT hResult = g_pJob->GetState( &state );

    if (FAILED( hResult ))
        {
        BITSCheckHR( hwndDlg, hResult, false );
        return;
        }

    if ( BG_JOB_STATE_ERROR == state ||
         BG_JOB_STATE_TRANSFERRED == state )
        {

        MessageBox(
            hwndDlg,
            GetString( IDS_ALREADYFINISHED ),
            GetString( IDS_ALREADYFINISHEDCAPTION ),
            MB_OK | MB_ICONERROR | MB_DEFBUTTON1 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );


        return;
        }


    //
    // Inform the user that he selected close and ask
    // confirm the intention to exit.  Explain that the job 
    // will be canceled.

    int Result =
        MessageBox(
            hwndDlg,
            GetString( IDS_CLOSETEXT ),
            GetString( IDS_CLOSECAPTION ),
            MB_OKCANCEL | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );

    if ( IDOK == Result )
        {
        
        // User confirmed the cancel, just do it.

        DoCancel( hwndDlg, false );
        return;
        }

    // The user didn't really want to exit, so ignore him
    else
        return;

}

void
HandleTimerTick( HWND hwndDlg )
{

    //
    // Handle the throttling timer event 
    // and update the dialog if needed
    //

    if ( g_RefreshOnTimer )
        {
        // The timer fired, handle all updates at once.
        UpdateDialog( hwndDlg );
        g_RefreshOnTimer = FALSE;
        }
    else
        {
        // The timer expired with an additional modification
        // notification.  Just kill the timer.
        KillTimer( hwndDlg, 0 );
        g_RefreshOnTimer = g_UpdateTimerSet = FALSE;
        }

}

void
HandleUpdate()
{

    //
    // Handle a update request, batching the update if needed
    //

    if ( !g_UpdateTimerSet )
        {
        // We aren't currently batching updates,
        // so do this one update but prevent
        // further updates until the timer expires.
        SetTimer( g_hwndDlg, 0, 1000, NULL );
        g_UpdateTimerSet = TRUE;
        UpdateDialog( g_hwndDlg );
        }
    else
        {
        // We've started batching and yet received
        // another update request.  Delay this
        // update until the timer fires.
        g_RefreshOnTimer = TRUE;
        }

}

INT_PTR CALLBACK
DialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
  )
{

  //
  // Dialog proc for main dialog window
  //

  switch( uMsg )
      {

      case WM_INITDIALOG:
          g_hwndDlg = hwndDlg;
          InitDialog( hwndDlg );
          return TRUE;

      case WM_TIMER:
          HandleTimerTick( hwndDlg );
          return TRUE;

      case WM_CLOSE:
          DoClose( hwndDlg );
          return TRUE;

      case WM_COMMAND:

          switch( LOWORD( wParam ) )
              {

              case IDC_RESUME:
                  BITSCheckHR( hwndDlg, g_pJob->Resume(), false );
                  return TRUE;

              case IDC_SUSPEND:
                  BITSCheckHR( hwndDlg, g_pJob->Suspend(), false );
                  return TRUE;

              case IDC_CANCEL:
                  DoCancel( hwndDlg, true );
                  return TRUE;

              case IDC_FINISH:
                  DoFinish( hwndDlg );
                  return TRUE;

              case IDC_PRIORITY:
                  switch( HIWORD( wParam ) )
                      {

                      case CBN_SELENDOK:

                          // User clicked on priority,
                          // update it.

                          BITSCheckHR( hwndDlg,
                              g_pJob->SetPriority( (BG_JOB_PRIORITY)
                                  SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_GETCURSEL, 0, 0 ) ), false );
                          return TRUE;

                      case CBN_SELENDCANCEL:
                          return TRUE;

                      default:
                          return FALSE;
                      }

              default:
                  return FALSE;
              }
      default:
          return FALSE;
      }
}

HRESULT
HandleCOMCallback(
    IBackgroundCopyJob* pJob,
    bool CriticalEvent
    );

class CBackgroundCopyCallback : public IBackgroundCopyCallback
{

    //
    // Callback class.   Used for change notifications.
    //

public:
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject)
    {

        if ( riid == _uuidof(IUnknown) )
            {
            *ppvObject = (IUnknown*)(IBackgroundCopyCallback*)this;
            return S_OK;
            }

        else if ( riid == _uuidof(IBackgroundCopyCallback) )
            {
            *ppvObject = (IBackgroundCopyCallback*)this;
            return S_OK;
            }

        else
            return E_NOINTERFACE;

    }

    virtual HRESULT STDMETHODCALLTYPE CreateInstance(
        IUnknown *pUnkOuter,
        REFIID riid,
        void **ppvObject )
    {

        if ( pUnkOuter )
            return CLASS_E_NOAGGREGATION;

        return QueryInterface( riid, ppvObject );

    }

    // We are cheating on COM here, but we
    // are forcing the lifetime of the callback object
    // to be the same of the lifetime of the exe.

    virtual ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return 0;
    }
    virtual ULONG STDMETHODCALLTYPE Release(void)
    {
        return 0;
    }

    virtual HRESULT STDMETHODCALLTYPE JobTransferred(IBackgroundCopyJob *pJob)
    {
        return HandleCOMCallback( pJob, true );
    }

    virtual HRESULT STDMETHODCALLTYPE JobError(IBackgroundCopyJob *pJob, IBackgroundCopyError *pError)
    {
        return HandleCOMCallback( pJob, true );
    }

    virtual HRESULT STDMETHODCALLTYPE JobModification( IBackgroundCopyJob *pJob, DWORD dwReserved )
    {
        return HandleCOMCallback( pJob, true );
    }
} g_Callback;

HRESULT
HandleCOMCallback(
    IBackgroundCopyJob* pJob,
    bool CriticalEvent
    )
{

    // In addition to the work of HandleUpdate,
    // this function checks to see if we've
    // already initialized the manager.  If not,
    // do it now.

    if ( !g_pManager )
        {

        try
        {
            CheckHR( NULL,
                     CoCreateInstance( CLSID_BackgroundCopyManager,
                         NULL,
                         CLSCTX_LOCAL_SERVER,
                         IID_IBackgroundCopyManager,
                         (void**)g_pManager.GetRecvPointer() ), true );

            *g_pJob.GetRecvPointer() = pJob;

            BITSCheckHR( NULL, g_pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

            // As an optimization, set the notification interface to be the callback
            // It shouldn't matter if this fails
            g_pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback );

            HandleUpdate();

            ShowWindow( g_hwndDlg, CriticalEvent ? SW_NORMAL : SW_MINIMIZE );

        }
        catch(_com_error error )
        {
            g_pManager.Release();
            g_pJob.Release();

            return error.Error();
        }

        }

    HandleUpdate();
    return S_OK; 
}

void
CreateUI( int nShowCmd )
{

    //
    // Creates the dialog box for the sample.
    //

    g_hwndDlg =
      CreateDialog(
         (HINSTANCE)GetModuleHandle(NULL),
         MAKEINTRESOURCE( IDD_DIALOG ),
         GetDesktopWindow(),
         DialogProc );

    if ( !g_hwndDlg )
        CheckHR( NULL, HRESULT_FROM_WIN32(GetLastError()), true );

    ShowWindow( g_hwndDlg, nShowCmd );
}

void CreateJob(
    WCHAR* szJobURL
    )
{
    //
    // Request a destination file name from the user
    // and submit a new job.
    //

    try
    {

        // crack the URL and get the filename
        WCHAR szURLFilePath[MAX_PATH] = {L'\0'};
        URL_COMPONENTS UrlComponents;

        memset( &UrlComponents, 0, sizeof(UrlComponents) );
        UrlComponents.dwStructSize = sizeof(URL_COMPONENTS);
        UrlComponents.lpszUrlPath = szURLFilePath;
        UrlComponents.dwUrlPathLength =
            sizeof(szURLFilePath)/sizeof(*szURLFilePath);

        BOOL CrackResult =
            InternetCrackUrl(
                szJobURL,
                0,
                0,
                &UrlComponents );

        if (!CrackResult)
            CheckHR( NULL, HRESULT_FROM_WIN32( GetLastError() ), false );

        if ( UrlComponents.nScheme != INTERNET_SCHEME_HTTP &&
             UrlComponents.nScheme != INTERNET_SCHEME_HTTPS
             )
            {

            MessageBox(
                NULL,
                GetString( IDS_NOHTTPORHTTPS ),
                GetString( IDS_ERRORBOXTITLE ),
                MB_OK | MB_ICONERROR | MB_APPLMODAL |
                MB_SETFOREGROUND | MB_TOPMOST );


            throw _com_error( E_INVALIDARG );

            }

        const WCHAR *szURLFileName =
            szURLFilePath + wcslen( szURLFilePath );

        // parse out the filename part of the URL
        while( szURLFileName != szURLFilePath )
            {

            if ( L'/' == *szURLFileName ||
                 L'\\' == *szURLFileName )
                {
                szURLFileName++;
                break;
                }

            szURLFileName--;
            }
       
		// This is needed in case the first
		// character is a slash.
        if ( L'/' == *szURLFileName ||
			 L'\\' == *szURLFileName )
			 szURLFileName++;

        // parse out the extension from the name
        const WCHAR *szURLFileExtension =
            szURLFileName + wcslen( szURLFileName );

        while( szURLFileName != szURLFileExtension )
            {
            if ( L'.' == *szURLFileExtension )
                break;
            szURLFileExtension--;
            }

        // build the extension list

        WCHAR *szExtensionList = NULL;
        const WCHAR *szAllFiles = GetString( IDS_ALLFILES );
        const size_t AllFilesSize = wcslen( szAllFiles ) + 1;
        const WCHAR *szAllFilesPattern = L"*";
        const size_t AllFilesPatternSize = sizeof(L"*")/sizeof(WCHAR);

        WCHAR *p;

        if ( szURLFileExtension == szURLFileName &&
             *szURLFileExtension != L'.' )
            {
            size_t StringSize = sizeof(WCHAR) * ( AllFilesSize + AllFilesPatternSize + 2 );
            szExtensionList = (WCHAR*)_alloca( StringSize );
            p = szExtensionList;
            }
        else
            {
            size_t ExtensionSize = wcslen( szURLFileExtension ) + 1;
            size_t StringSize =
                sizeof(WCHAR) * ( ExtensionSize + ExtensionSize + 1 + AllFilesSize
                                  + AllFilesPatternSize + 2 );
            szExtensionList = (WCHAR*)_alloca( StringSize );
            p = szExtensionList;

            memcpy( p, szURLFileExtension, ExtensionSize * sizeof(WCHAR) );
            p += ExtensionSize;
            *p++ = L'*';
            memcpy( p, szURLFileExtension, ExtensionSize * sizeof(WCHAR) );
            p += ExtensionSize;
            }

        memcpy( p, szAllFiles, AllFilesSize * sizeof(WCHAR) );
        p += AllFilesSize;
        memcpy( p, szAllFilesPattern, AllFilesPatternSize * sizeof(WCHAR) );
        p += AllFilesPatternSize;
        memset( p, 0, sizeof(WCHAR) * 2 );


        OPENFILENAME ofn;
        memset( &ofn, 0, sizeof( ofn ) );

        WCHAR szFileName[MAX_PATH];
        WCHAR szFileTitle[MAX_PATH];

        SafeCopy( szFileName, szURLFileName, MAX_PATH );
        SafeCopy( szFileTitle, szURLFileName, MAX_PATH );

        /* fill in non-variant fields of OPENFILENAME struct. */
        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = g_hwndDlg;
        ofn.lpstrFilter       = szExtensionList;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter    = 0;
        ofn.nFilterIndex      = 0;
        ofn.lpstrFile         = szFileName;
        ofn.nMaxFile          = MAX_PATH;
        ofn.lpstrInitialDir   = NULL;
        ofn.lpstrFileTitle    = szFileTitle;
        ofn.nMaxFileTitle     = MAX_PATH;
        ofn.lpstrTitle        = GetString( IDS_FILEDLGTITLE );
        ofn.lpstrDefExt       = NULL;
        ofn.Flags             = 0;

        /* Use standard open dialog */
        BOOL bResult = GetSaveFileName ((LPOPENFILENAME)&ofn);

        if ( !bResult )
            {
            if ( !CommDlgExtendedError() )
                {
                // user canceled the box
                PostQuitMessage( 0 );
                return;
                }
            else
                CheckHR( NULL, HRESULT_FROM_WIN32( GetLastError() ), true );
            }


        SafeCopy( g_szFileName, szFileTitle, MAX_STRING );

        CheckHR( NULL,
                 CoCreateInstance( CLSID_BackgroundCopyManager,
                     NULL,
                     CLSCTX_LOCAL_SERVER,
                     IID_IBackgroundCopyManager,
                     (void**)g_pManager.GetRecvPointer() ), true );

        GUID guid;
        BITSCheckHR( NULL,
            g_pManager->CreateJob( szJobURL,
                                 BG_JOB_TYPE_DOWNLOAD,
                                 &guid,
                                 g_pJob.GetRecvPointer() ),
                        true );

        memset( &g_JobId, 0, sizeof(GUID) );
        BITSCheckHR( NULL, g_pJob->GetId( &g_JobId ), true );
        BITSCheckHR( NULL, g_pJob->AddFile( szJobURL, szFileName ), true );

        CreateStartupLink( g_JobId, g_szFileName );

        BITSCheckHR( NULL, g_pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

        BITSCheckHR( NULL,
                     g_pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback ),
                     true );
        BITSCheckHR( NULL, g_pJob->Resume(), true );

        HandleUpdate();

    }
    catch( const _com_error &error )
    {
        if ( g_pJob )
            {
            g_pJob->Cancel();
            DeleteStartupLink( g_JobId );
            }

        throw error;
    }

}

void ResumeJob(
    WCHAR* szJobGUID,
    WCHAR* szJobFileName
    )
{

    //
    // Resume the display on an existing job
    //

    SafeCopy( g_szFileName, szJobFileName, MAX_PATH );
    CheckHR( NULL, IIDFromString( szJobGUID, &g_JobId ), true );

    CheckHR( NULL,
             CoCreateInstance( CLSID_BackgroundCopyManager,
                 NULL,
                 CLSCTX_LOCAL_SERVER,
                 IID_IBackgroundCopyManager,
                 (void**)g_pManager.GetRecvPointer() ), true );

    BITSCheckHR( NULL, g_pManager->GetJob( g_JobId, g_pJob.GetRecvPointer() ), true );
    BITSCheckHR( NULL,
                 g_pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback ),
                 true );
    BITSCheckHR( NULL, g_pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

    ShowWindow( g_hwndDlg, SW_MINIMIZE );
    HandleUpdate();

}

int WINAPI WinMain(
  HINSTANCE hInstance,      // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,          // command line
  int nCmdShow)             // show state
{

  //
  // Expected syntax:
  // bits_ie /CREATEJOB URL
  // bits_ie /RESUMEJOB JobGUID DestinationFile

  // /CREATEJOB - Called from the script which is run when 
  //              "Background Download As" is selected.
  // /RESUMEJOB - Called from the link in the startup directory
  //              to resume a job when it is restarted.

  try
  {
      CheckHR( NULL, CoInitialize(NULL), true );

      InitCommonControls();

      CreateUI( nCmdShow );

      LPTSTR lpCommandLine = GetCommandLine();

      int argc;
      WCHAR **argv =
          CommandLineToArgvW(
              lpCommandLine,
              &argc );

      if ( argc < 2 )
          CheckHR( NULL, E_INVALIDARG, true );

      if ( argc == 3 &&
           _wcsicmp( L"/CREATEJOB", argv[1] ) == 0 )
          CreateJob( argv[2] );

      else if ( argc == 4 &&
                _wcsicmp( L"/RESUMEJOB", argv[1] ) == 0 )
          ResumeJob( argv[2], argv[3] );

      else
          CheckHR( NULL, E_INVALIDARG, true );

      MSG msg;
      while( GetMessage( &msg, NULL, 0, 0 ) )
      {
          TranslateMessage( &msg );
          DispatchMessage( &msg );
      }

  }
  catch(_com_error error )
  {
      return -1;
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\bits_ie\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bits_ie.rc
//
#define IDS_LONGPROGRESS                1
#define IDS_ERROR                       2
#define IDS_SHORTPROGRESS               3
#define IDS_QUEUED                      4
#define IDS_CONNECTING                  5
#define IDS_TRANSFERRING                6
#define IDS_SUSPENDED                   7
#define IDS_FATALERROR                  8
#define IDS_TRANSIENTERROR              9
#define IDS_TRANSFERRED                 10
#define IDS_ACKNOWLEDGED                11
#define IDS_CANCELLED                   12
#define IDS_UNKNOWN                     13
#define IDS_DAYSFORMAT                  14
#define IDS_HOURSFORMAT                 15
#define IDS_MINUTESFORMAT               16
#define IDS_SECONDSFORMAT               17
#define IDS_FOREGROUND                  18
#define IDS_HIGH                        19
#define IDS_NORMAL                      20
#define IDS_LOW                         21
#define IDS_ERRORBOXTITLE               22
#define IDS_FILEDLGTITLE                23
#define IDS_CANCELCAPTION               24
#define IDS_CANCELTEXT                  25
#define IDS_NOHTTPORHTTPS               26
#define IDS_ALLFILES                    27
#define IDS_STARTUPLINK                 28
#define IDS_CLOSECAPTION                29
#define IDS_CLOSETEXT                   30
#define IDS_ALREADYFINISHED             31
#define IDS_ALREADYFINISHEDCAPTION      32
#define IDS_GIGAFORMAT                  33
#define IDS_MEGAFORMAT                  34
#define IDS_KILOFORMAT                  35
#define IDS_BYTEFORMAT                  36
#define IDS_DISPLAYERRORCODE            37
#define IDS_MAX                         IDS_DISPLAYERRORCODE
#define IDD_DIALOG                      101
#define IDI_ICON1                       105
#define IDC_COMPLETE2                   1004
#define IDC_FINISH                      1004
#define IDC_CANCEL2                     1005
#define IDC_CANCEL                      1005
#define IDC_SUSPEND2                    1006
#define IDC_SUSPEND                     1006
#define IDC_PROGRESS                    1007
#define IDC_PROGRESSBAR                 1007
#define IDC_STATUSTXT                   1008
#define IDC_CREATIONTIMETXT             1009
#define IDC_MODIFICATONTIMETXT          1010
#define IDC_COMPLETIONTIMETXT           1011
#define IDC_ESTIMATEDTIMETXT            1012
#define IDC_TRANSFERRATETXT             1013
#define IDC_PRIORITY                    1014
#define IDC_RESUME2                     1015
#define IDC_RESUME                      1015
#define IDC_PRIORITYTXT                 1016
#define IDC_ERRORMSGTXT                 1017
#define IDC_STATUS                      1021
#define IDC_STARTTIME                   1022
#define IDC_MODIFICATIONTIME            1023
#define IDC_COMPLETIONTIME              1024
#define IDC_ESTIMATEDTIME               1025
#define IDC_TRANSFERRATE                1026
#define IDC_ERRORMSG                    1027
#define IDC_PROGRESSINFOTXT             1045
#define IDC_PROGRESSINFO                1046
#define IDC_DISPLAYNAME                 1047

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\client_cust_action\bitscnfg.cpp ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       bitscnfg.cpp
//
//  Contents:   Configure BITS client service to default settings.
//
//  EdwardR     07/27/2001   Initial version.
//              08/03/2001   Add code to fixup ServiceDLL in registry.
//                           Add code to regsvr qmgrprxy.dll
//              08/13/2001   Add code to support XP as well as Win2k.
//----------------------------------------------------------------------------

#define  UNICODE
#include <windows.h>
#include <stdio.h>
#include <memory>

using namespace std;

#define  VER_WINDOWS_2000         500
#define  VER_WINDOWS_XP           501
//
//  Service configuration settings:
//
#define BITS_SERVICE_NAME        TEXT("BITS")
#define BITS_DISPLAY_NAME        TEXT("Background Intelligent Transfer Service")
#define BITS_BINARY_PATH         TEXT("%SystemRoot%\\System32\\svchost.exe -k BITSgroup")
#define BITS_LOAD_ORDER_GROUP    TEXT("BITSgroup")

#define BITS_SERVICE_TYPE        SERVICE_WIN32_SHARE_PROCESS
#define BITS_START_TYPE          SERVICE_DEMAND_START
#define BITS_ERROR_CONTROL       SERVICE_ERROR_NORMAL

//
//  This additional service registry setting is set incorrectly by the
//  Darwin install
//
#define REG_SERVICE_PATH         TEXT("SYSTEM\\CurrentControlSet\\Services\\BITS")
#define REG_PARAMETERS           TEXT("Parameters")
#define REG_SERVICEDLL           TEXT("ServiceDll")
#define REG_SERVICEDLL_PATH      TEXT("%SystemRoot%\\System32\\qmgr.dll")

//
//  For side-by-side install on Windows XP
//
#define BACKSLASH_STR            TEXT("\\")
#define BITS_SUBDIRECTORY        TEXT("BITS")
#define BITS_QMGR_DLL            TEXT("qmgr.dll")

#define REG_BITS                 TEXT("BITS")
#define REG_BITS_SERVICEDLL      TEXT("ServiceDLL")
#define REG_SERVICEDLL_KEY       TEXT("Software\\Microsoft\\Windows\\CurrentVersion")

//
//  Constants to register qmgrprxy.dll
//
#define BITS_QMGRPRXY_DLL        TEXT("qmgrprxy.dll")
#define BITS_BITS15PRXY_DLL      TEXT("bitsprx2.dll")
#define BITS_DLL_REGISTER_FN     "DllRegisterServer"

typedef HRESULT (*RegisterFn)();

//
//  Constants for parsing bitscnfg.exe runstring arguments
//
#define SZ_DELIMITERS            " \t"
#define SZ_INSTALL               "/i"
#define SZ_UNINSTALL             "/u"
#define SZ_DELETE_SERVICE        "/d"

#define ACTION_INSTALL             0
#define ACTION_UNINSTALL           1
#define ACTION_DELETE_SERVICE      2

//
//  Log file for testing
//
FILE   *f = NULL;

//---------------------------------------------------------------------
//  RegSetKeyAndValue()
//
//  Helper function to create a key, sets a value in the key,
//  then close the key.
//
//  Parameters:
//    pwsKey       WCHAR* The name of the key
//    pwsSubkey    WCHAR* The name of a subkey
//    pwsValueName WCHAR* The value name.
//    pwsValue     WCHAR* The data value to store
//    dwType       The type for the new registry value.
//    dwDataSize   The size for non-REG_SZ registry entry types.
//
//  Return:
//    BOOL         TRUE if successful, FALSE otherwise.
//---------------------------------------------------------------------
DWORD RegSetKeyAndValue( const WCHAR *pwsKey,
                         const WCHAR *pwsSubKey,
                         const WCHAR *pwsValueName,
                         const WCHAR *pwsValue,
                         const DWORD  dwType = REG_SZ,
                               DWORD  dwDataSize = 0,
                               BOOL   fReCreate = TRUE )
    {
    DWORD  dwStatus = ERROR_SUCCESS;
    HKEY   hKey = NULL;
    DWORD  dwSize = 0;
    WCHAR *pwsCompleteKey = NULL;

    if (pwsKey)
        dwSize = wcslen(pwsKey);

    if (pwsSubKey)
        dwSize += wcslen(pwsSubKey);

    pwsCompleteKey = new WCHAR[ 1+1+dwSize ];   // Extra +1 for the backslash...
    if (!pwsCompleteKey)
        {
        return ERROR_NOT_ENOUGH_MEMORY;
        }

    wcscpy(pwsCompleteKey, pwsKey);

    if (NULL!=pwsSubKey)
        {
        wcscat(pwsCompleteKey, BACKSLASH_STR);
        wcscat(pwsCompleteKey, pwsSubKey);
        }

    // If the key is already there then delete it, we will recreate it.
    if (fReCreate)
        {
        dwStatus = RegDeleteKey( HKEY_LOCAL_MACHINE,
                                 pwsCompleteKey );
        }

    dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pwsCompleteKey,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               NULL );
    if (dwStatus != ERROR_SUCCESS)
        {
        goto error;
        }

    if (pwsValue)
        {
        if ((dwType == REG_SZ)||(dwType == REG_EXPAND_SZ))
          dwDataSize = (1+wcslen(pwsValue))*sizeof(WCHAR);

        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, dwDataSize );
        }
    else
        {
        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, 0 );
        }

error:
    if (hKey)
        {
        RegCloseKey(hKey);
        }
    if (pwsCompleteKey)
        {
        delete pwsCompleteKey;
        }
    return dwStatus;
    }

//-------------------------------------------------------------------------
//  RegDeleteKeyOrValue()
//
//  Delete either the specified sub-key or delete the specified value
//  within the sub-key. If pwszValueName is specified, the just delete
//  it and leave the key alone. If pwszValueName is NULL, then delete
//  the key.
//-------------------------------------------------------------------------
DWORD RegDeleteKeyOrValue( IN const WCHAR *pwszKey,
                           IN const WCHAR *pwszSubKey,
                           IN const WCHAR *pwszValueName )
    {
    LONG    lStatus = 0;
    DWORD   dwLen;
    HKEY    hKey = 0;
    WCHAR  *pwszCompleteKey = NULL;

    if (!pwszKey || !pwszSubKey)
        {
        return lStatus;
        }

    dwLen = wcslen(pwszKey) + wcslen(pwszSubKey) + 2;

    pwszCompleteKey = new WCHAR[dwLen];
    if (!pwszCompleteKey)
        {
        return ERROR_NOT_ENOUGH_MEMORY;
        }

    wcscpy(pwszCompleteKey,pwszKey);
    wcscat(pwszCompleteKey,BACKSLASH_STR);
    wcscat(pwszCompleteKey,pwszSubKey);

    if (pwszValueName)
        {
        // Delete a value in a key:
        if (f) fwprintf(f,TEXT("Delete Reg Value: %s : %s\n"),pwszCompleteKey,pwszValueName);

        lStatus = RegOpenKey(HKEY_LOCAL_MACHINE,pwszCompleteKey,&hKey);
        if (lStatus == ERROR_SUCCESS)
            {
            lStatus = RegDeleteValue(hKey,pwszValueName);
            RegCloseKey(hKey);
            }
        }
    else
        {
        // Delete the specified key:
        if (f) fwprintf(f,TEXT("Delete Reg Key: %s\n"),pwszCompleteKey);

        lStatus = RegDeleteKey(HKEY_LOCAL_MACHINE,pwszCompleteKey);
        }

    if (pwszCompleteKey)
        {
        delete pwszCompleteKey;
        }

    return lStatus;
    }

//-------------------------------------------------------------------------
// RegisterDLL()
//
//-------------------------------------------------------------------------
DWORD RegisterDLL( IN WCHAR *pwszSubdirectory,
                   IN WCHAR *pwszDllName )
    {
    DWORD      dwStatus = 0;
    HMODULE    hModule;
    RegisterFn pRegisterFn;
    UINT       nChars;
    WCHAR      wszDllPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    if (pwszSubdirectory)
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(pwszDllName))) )
            {
            return ERROR_BUFFER_OVERFLOW;
            }

        wcscpy(wszDllPath,wszSystemDirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszSubdirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszDllName);
        }
    else
        {
        if (MAX_PATH < wcslen(pwszDllName))
            {
            return ERROR_BUFFER_OVERFLOW;
            }
        wcscpy(wszDllPath,pwszDllName);
        }

    hModule = LoadLibrary(wszDllPath);
    if (!hModule)
        {
        dwStatus = GetLastError();
        return dwStatus;
        }

    pRegisterFn = (RegisterFn)GetProcAddress(hModule,BITS_DLL_REGISTER_FN);
    if (!pRegisterFn)
        {
        dwStatus = GetLastError();
        FreeLibrary(hModule);
        return dwStatus;
        }

    dwStatus = pRegisterFn();

    FreeLibrary(hModule);

    return dwStatus;
    }

//-------------------------------------------------------------------------
// ParseCmdLine()
//
//-------------------------------------------------------------------------
void ParseCmdLine( LPSTR  pszCmdLine,
                   DWORD *pdwAction )
    {
    CHAR  *pszTemp = pszCmdLine;
    CHAR  *pszArg;
    BOOL   fFirstTime = TRUE;

    *pdwAction = ACTION_INSTALL;   // default is install.

    while (pszArg=strtok(pszTemp,SZ_DELIMITERS))
        {
        if (fFirstTime)
            {
            fFirstTime = FALSE;
            pszTemp = NULL;
            continue;       // Skip over program name...
            }

        if (!_stricmp(pszArg,SZ_INSTALL))
            {
            *pdwAction = ACTION_INSTALL;
            if (f) fwprintf(f,TEXT("Install: %S\n"),SZ_INSTALL);
            }
        if (!_stricmp(pszArg,SZ_UNINSTALL))
            {
            *pdwAction = ACTION_UNINSTALL;
            if (f) fwprintf(f,TEXT("Uninstall: %S\n"),SZ_UNINSTALL);
            }
        if (!_stricmp(pszArg,SZ_DELETE_SERVICE))
            {
            *pdwAction = ACTION_DELETE_SERVICE;
            if (f) fwprintf(f,TEXT("DeleteService: %S\n"),SZ_UNINSTALL);
            }
        }
    }

//-------------------------------------------------------------------------
//  DoInstall()
//-------------------------------------------------------------------------
DWORD DoInstall( DWORD dwOsVersion )
{
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwStatus = 0;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    //
    // Cleanup the service configuration:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));

        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (!ChangeServiceConfig(hService,
                                 BITS_SERVICE_TYPE,
                                 BITS_START_TYPE,
                                 BITS_ERROR_CONTROL,
                                 BITS_BINARY_PATH,
                                 NULL,   // Load order group (not changing this).
                                 NULL,   // Tag ID for load order group (not needed).

                                 // Service dependencies (this is different for Win2k )
                                 // reply on XP installer to overwrite this.
                                 TEXT("LanmanWorkstation\0Rpcss\0SENS\0Wmi\0"),
                                 NULL,   // Account Name (not changing this).
                                 NULL,   // Account Password (not changing this).
                                 BITS_DISPLAY_NAME))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("ChangeServiceConfig(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        //
        //  Fix the ServiceDll registry value...
        //
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Fix ServiceDll entry.\n"));

        dwStatus = RegSetKeyAndValue( REG_SERVICE_PATH,
                                      REG_PARAMETERS,
                                      REG_SERVICEDLL,
                                      REG_SERVICEDLL_PATH,
                                      REG_EXPAND_SZ);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register qmgrproxy.dll
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_QMGRPRXY_DLL);

        dwStatus = RegisterDLL(NULL,BITS_QMGRPRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_QMGRPRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register bits15prxy.dll
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_BITS15PRXY_DLL);

        dwStatus = RegisterDLL(BITS_SUBDIRECTORY,BITS_BITS15PRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_BITS15PRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    // Configure WindowsXP BITS to run V1.5 qmgr.dll. This is also configured on Windows2000 systems to ready
    // it in case the system is upgraded to WindowsXP. This is done because there is no Migrate.dll to go from
    // Windows2000 to WindowsXP.
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(BITS_QMGR_DLL))) )
            {
            if (f) fwprintf(f,TEXT("GetSystemDirectory(): System Path too long.\n"));
            goto error;
            }

        wcscpy(wszQmgrPath,wszSystemDirectory);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_SUBDIRECTORY);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_QMGR_DLL);

        if (f) fwprintf(f,TEXT("Set BITS V1.5 Override Path: %s\n"),wszQmgrPath);


        dwStatus = RegSetKeyAndValue( REG_SERVICEDLL_KEY,
                                      REG_BITS,
                                      REG_BITS_SERVICEDLL,
                                      wszQmgrPath,
                                      REG_SZ, 0, FALSE);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DoUninstall()
//
//  If this is Windows2000 then delete the BITS service.
//-------------------------------------------------------------------------
DWORD DoUninstall( DWORD dwOsVersion )
{
    DWORD      dwStatus = 0;
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;


    //
    // Delete the BITS thunk DLL registry entry:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        // If Windows2000, then delete the BITS subkey and all its values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             NULL );
        }

    if (dwOsVersion == VER_WINDOWS_XP)
        {
        // If WindowsXP, then just delete the ServiceDLL value and leave the key and any other values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             REG_BITS_SERVICEDLL );
        }

    //
    //  If this is Windows2000, then delete the service.
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));
        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (dwStatus == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                dwStatus = 0;
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d) Service doesn't exist.\n"),dwStatus,dwStatus);
                }
            else
                {
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
                }
            goto error;
            }

        if (!DeleteService(hService))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("DeleteService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DeleteBitsService()
//
//  Currently this is the same action as DoInstall().
//-------------------------------------------------------------------------
DWORD DeleteBitsService( IN DWORD dwOsVersion )
    {
    return DoUninstall( dwOsVersion );
    }

//-------------------------------------------------------------------------
// main()
//
//-------------------------------------------------------------------------
int PASCAL WinMain( HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     pszCmdLine,
                    int       nCmdShow )
    {
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwAction;
    DWORD      dwStatus;
    DWORD      dwOsVersion;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];
    OSVERSIONINFO osVersionInfo;

    f = _wfopen(TEXT("c:\\temp\\bitscnfg.log"),TEXT("w"));

    if (f) fwprintf(f,TEXT("Runstring: %S\n"),pszCmdLine);

    ParseCmdLine(pszCmdLine,&dwAction);

    //
    // Get the operating system verison (Win2k == 500, XP == 501):
    //
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo))
        {
        dwStatus = GetLastError();
        if (f) fwprintf(f,TEXT("GetVersionEx(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
        goto error;
        }

    dwOsVersion = 100*osVersionInfo.dwMajorVersion + osVersionInfo.dwMinorVersion;

    if (f) fwprintf(f,TEXT("Windows Version: %d\n"),dwOsVersion);

    switch (dwAction)
        {
        case ACTION_INSTALL:
             dwStatus = DoInstall(dwOsVersion);
             break;

        case ACTION_UNINSTALL:
             dwStatus = DoUninstall(dwOsVersion);
             break;

        case ACTION_DELETE_SERVICE:
             dwStatus = DeleteBitsService(dwOsVersion);
             break;

        default:
             if (f) fwprintf(f,TEXT("Undefined Custom Action: %d\n"),dwAction);
             break;
        }

error:
    if (f) fwprintf(f,TEXT("bitscnfg.exe: Complete.\n"));

    if (f) fclose(f);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\inc\bitsverp.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    bitsverp.h

Abstract :

    Version file for BITS.

Author :

Revision History :

 ***********************************************************************/

#include <ntverp.h>

#undef VER_PRODUCTMAJORVERSION
#undef VER_PRODUCTMINORVERSION
#undef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBETA_STR
#undef VER_PRODUCTVERSION_MAJORMINOR2
#undef VER_PRODUCTVERSION_MAJORMINOR1
#undef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_DW

#define VER_PRODUCTMAJORVERSION     6
#define VER_PRODUCTMINORVERSION     5

#define VER_PRODUCTBUILD_QFE        0
#define VER_PRODUCTBETA_STR         /* NT */     ""

//
// not sure why VER_PRODUCTVERSION_MAJORMINOR1 needs to be defined in terms of VER_PRODUCTVERSION_MAJORMINOR2
//
#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION_MAJORMINOR2_WSTRING(x,y) L#x L"." L#y
#define VER_PRODUCTVERSION_MAJORMINOR1_WSTRING(x,y) VER_PRODUCTVERSION_MAJORMINOR2_WSTRING(x, y)
#define VER_PRODUCTVERSION_WSTRING   VER_PRODUCTVERSION_MAJORMINOR1_WSTRING(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0605)
#define VER_PRODUCTVERSION_DW       (0x06050000 | VER_PRODUCTBUILD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\inc\resource.h ===
//---------------------------------------------------------------------
//  Copyright (c) Microsoft Corporation, 2001
//
//  resource.h
//
//---------------------------------------------------------------------

#define  IDS_SERVICE_NAME           1000
#define  IDS_SERVICE_DESC           1001
#define IDS_UNKNOWN_USER         1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\inc\trust.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
//
//  SYSTEM:     Industry Update
//
//  CLASS:      N/A
//  MODULE:     TRUST.LIB
//  FILE:       TRUST.H
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   this header file declares functions used to make cabs
//          signed by certain providers trusted.
//
//  AUTHOR: Charles Ma, converted from WU CDMLIB
//  DATE:   10/4/2000
//
/////////////////////////////////////////////////////////////////////
//
//  Revision History:
//
//  Date        Author    Description
//  ~~~~        ~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  2002-01-18  KenSh     Added revocation check param to VerifyFileTrust
//
/////////////////////////////////////////////////////////////////////
//

//
// This file  is copied from the Windows AutoUpdate sources at \nt\enduser\windows.com\inc\trust.h
// modified to use BITS logging and remove UI.
//

#pragma once


//
// define the number of bytes needed to store a SHA1 hashing value
// of the public key
//
const UINT HASH_VAL_SIZE = 20;      

//
// define structure used to pass in the hash values to the following
// function in order to detect if one of the hash matches the
// public key of the leaf cert of a file.
//
typedef struct _HASH_STRUCT {
    UINT uiCount;
    PBYTE pCerts;
} CERT_HASH_ARRAY, *pCERT_HASH_ARRAY;


/////////////////////////////////////////////////////////////////////////////
//
// Public Function VerifyFileTrust()
//
// This is a wrapper function for CheckWinTrust that both Whistler
// and WU classic code should use.
//
// Input:   szFileName - the file with complete path
//          pbSha1HashVae - a pointer to a 20 byte long buffer, containing
//                          the signature SHA1 hashing value that should
//                          be used to check this file, or NULL for checking
//                          known Microsoft cert.
//          fCheckRevocation - whether the certificat revocation list (CRL) is
//                             checked to see whether any of the certs in the chain
//                             have been revoked. Never prompts the user to initiate
//                             a dial-up connection. Default = FALSE.
//
// Return:  HRESULT - S_OK the file is signed with a valid cert
//                    or error code.
//                    If the file is signed correctly but cert is not
//                    a known Microsoft cert, or it's SHA1 hash does not match
//                    the one passed in, then CERT_UNTRUSTED_ROOT is returned.
//
// Good Cert: Here is the deifnition of a good cert, in addition to the fact
//            that the signature must be valid and not expired.
//              (1) The signature was signed with a cert that has
//                  "Microsoft Root Authority" as root, or
//              (2) Parameter pbSha1HashVal is not NULL, and the file's SHA1
//                  hashing value of signature matches this value, or
//              (3) The signature was signed with one of the following known
//                  Microsoft cert's (they are not rooted to MS) and
//                  pbSha1HashVal is NULL.
//                  * Microsoft Corporation
//                  * Microsoft Corporation MSN (Europe)
//                  * Microsoft Corporation (Europe)
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFileTrust(
                        IN LPCTSTR          szFileName,
                        IN pCERT_HASH_ARRAY pHashArray,
                        BOOL                fCheckRevocation = FALSE
                        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\inc\qmgrlib.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    qmgrlib.h

Abstract :

    External header for library functions.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <sddl.h>
#include <unknwn.h>
#include <memory>
#include <tchar.h>
#include <strsafe.h>
#include "bitsverp.h"

// strsafe.h deprecates the shlwapi string functions
//
#define NO_SHLWAPI_STRFCNS

//
// Version Control
//

enum PLATFORM_PRODUCT_VERSION
{
   WIN95_PLATFORM,
   WIN98_PLATFORM,
#if defined( BITS_V12_ON_NT4 )
   NT4_PLATFORM,
#endif
   WINDOWS2000_PLATFORM,
   WINDOWSXP_PLATFORM
};

extern PLATFORM_PRODUCT_VERSION g_PlatformVersion;
extern DWORD g_PlatformMajorVersion;
extern DWORD g_PlatformMinorVersion;
extern bool  bIsWin9x;

extern HINSTANCE g_hInstance;

BOOL DetectProductVersion();


//
// Limits
//

const size_t INT_DIGITS = 10;
const size_t INT64_DIGITS = 20;

const SIZE_T MAX_DISPLAYNAME        = 255;
const SIZE_T MAX_DESCRIPTION        = 1023;
const SIZE_T MAX_PROXYLIST          = 32767;
const SIZE_T MAX_PROXYBYPASSLIST    = 32767;
const SIZE_T MAX_NOTIFY_PROGRAM    = MAX_PATH;
const SIZE_T MAX_NOTIFY_PARAMETERS    = 4000;
const SIZE_T MAX_SESSION_ID = 100;
const SIZE_T MAX_HOST_ID = 300;         // allow room for a full DNS name
const SIZE_T MAX_PACKET_TYPE = 40;  // maximum length of Bits-Packet-Type header
const SIZE_T MAX_USERNAME = 300;
const SIZE_T MAX_PASSWORD = 300;

//
// Metadata overhead
//

const SIZE_T METADATA_PADDING                  = 4096;  // Padding on metadata for small changes such as timers
const SIZE_T METADATA_PREALLOC_SIZE          = 262144;  // Size to prealloc before a change
const SIZE_T METADATA_FOR_FILE                 = 4096;  // Initial file size.

const UINT MAX_GUID_CHARS=40;
typedef WCHAR GUIDSTR[MAX_GUID_CHARS];

template <class T>
inline void SafeRelease( T * & p ) { if (NULL != (p)) { p->Release(); p = NULL; } }

//
// Metadata internal file marker GUIDs
//

// {2B196AF5-007C-438f-8D12-1CFCA4CC9B76}
const GUID QmgrStateStorageGUID =
{ 0x2b196af5, 0x7c, 0x438f, { 0x8d, 0x12, 0x1c, 0xfc, 0xa4, 0xcc, 0x9b, 0x76 } };

// {005F4447-BDA9-44ba-9851-C47BB6C07ACE}
const GUID GroupListStorageGUID =
{ 0x5f4447, 0xbda9, 0x44ba, { 0x98, 0x51, 0xc4, 0x7b, 0xb6, 0xc0, 0x7a, 0xce } };

// {C82BF713-9940-4a12-9F1A-3AAEBD894EEA}
const GUID PriorityQueuesStorageGUID =
{ 0xc82bf713, 0x9940, 0x4a12, { 0x9f, 0x1a, 0x3a, 0xae, 0xbd, 0x89, 0x4e, 0xea } };

//
// The standard error class.  This is the only type of C++ exception that
// BITS functions should throw.
//
class ComError
{
public:

    HRESULT m_error;
    unsigned m_line;

    ComError(HRESULT NewErrorCode) : m_error ( NewErrorCode ), m_line(0) {}
    ComError(HRESULT NewErrorCode, unsigned line) : m_error ( NewErrorCode ), m_line(line) {}

    HRESULT Error() { return m_error; }

};

#define THROW_HRESULT( _expr_ )                \
{                                              \
    HRESULT _hr_ = _expr_;                     \
    if (FAILED(_hr_))                          \
        {                                      \
        throw ComError( _hr_, __LINE__ );      \
        }                                      \
}

#define ThrowLastError() throw ComError( HRESULT_FROM_WIN32( GetLastError() ), __LINE__)

using namespace std;

template<HANDLE InvalidValue=NULL>
class auto_HANDLE
    {
public:
    auto_HANDLE(HANDLE Handle = InvalidValue)
    : m_Handle(Handle) {}
    auto_HANDLE(auto_HANDLE<InvalidValue>& Other)
    : m_Handle(Other.release()) {}
    auto_HANDLE<InvalidValue>& operator=( HANDLE Handle )
    {
        if (InvalidValue != m_Handle)
            {
            CloseHandle(m_Handle);
            }
        m_Handle = Handle;
        return *this;
    }
    auto_HANDLE<InvalidValue>& operator=(auto_HANDLE<InvalidValue>& Other)
    {
        if (this != &Other)
            {
            m_Handle = Other.release();
            }
        return *this;
    }
    ~auto_HANDLE()
    {
        if (InvalidValue != m_Handle)
            CloseHandle(m_Handle);
    }
    HANDLE get() const
    {
        return m_Handle;
    }

    HANDLE * GetWritePointer()
    {
        return &m_Handle;
    }

    HANDLE release()
    {
        HANDLE Handle = m_Handle;
        m_Handle = InvalidValue;
        return Handle;
    }
private:
    HANDLE m_Handle;
    };
typedef auto_HANDLE<INVALID_HANDLE_VALUE> auto_FILE_HANDLE;

class SidHandle
{
    PSID    m_pValue;
    long *  m_pRefs;

public:

    PSID operator->()  { ASSERT( *m_pRefs > 0); return m_pValue; }

    SidHandle( PSID value=NULL ) : m_pValue( value ), m_pRefs( new long(1) )
    {
    }

    SidHandle( const SidHandle & r ) : m_pValue( r.m_pValue ), m_pRefs( r.m_pRefs )
    {
        InterlockedIncrement( m_pRefs );
    }

    ~SidHandle()
    {
        if ( InterlockedDecrement( m_pRefs ) == 0 )
            {
            delete m_pRefs;
            delete m_pValue;
            m_pRefs = NULL;
            m_pValue = NULL;
            }
    }

    SidHandle & operator=( const SidHandle & r );

    bool operator==( const SidHandle & r ) const
    {
        // this odd construction converts BOOL to bool.
        //
        return !!EqualSid( get(), r.get());
    }

    bool operator!=( const SidHandle & r ) const
    {
        return !((*this) == r);
    }

    PSID get() const  { ASSERT( *m_pRefs > 0); return m_pValue; }

};

template<class T>
class GenericStringHandle
{

    struct StringData
    {
        SIZE_T        m_Count;
        long          m_Refs;
        T             m_Data[1];
    };

    static StringData s_EmptyString;

    StringData *m_Value;

    void NewString( const T *String )
    {
       if ( !String )
           {
           m_Value = Alloc( 0 );
           return;
           }

       size_t Length = wcslen( String );
       m_Value = Alloc( Length );

       THROW_HRESULT( StringCchCopy( m_Value->m_Data, Length+1, String ));
    }

    static StringData * Alloc( SIZE_T max )
    {
        if (max == 0)
            {
            InterlockedIncrement( &s_EmptyString.m_Refs );
            return &s_EmptyString;
            }

        StringData * Value;

        Value = (StringData*) new char[sizeof(StringData)+(max*sizeof(T))];
        Value->m_Count = max;
        Value->m_Refs  = 1;

        Value->m_Data[0] = L'\0';

        return Value;
    }

    StringData * RefIt() const
    {
        InterlockedIncrement( &m_Value->m_Refs );
        return m_Value;
    }

    void FreeIt()
    {
        if ( m_Value->m_Refs && InterlockedDecrement( &m_Value->m_Refs ) == 0 )
            {
            delete m_Value;
            m_Value = NULL;
            }
    }

public:

    GenericStringHandle( const T *String = NULL )
    {
        NewString( String );
    }

    GenericStringHandle( const GenericStringHandle & Other ) :
        m_Value( Other.RefIt() )
    {
    }

    ~GenericStringHandle()
    {
        FreeIt();
    }

    GenericStringHandle & operator=( const GenericStringHandle & r )
    {
        FreeIt();
        m_Value = r.RefIt();
        return *this;
    }

    void operator=( const T * r )
    {
        FreeIt();
        NewString( r );
    }

    SIZE_T Size() const
    {
        return m_Value->m_Count;
    }

    operator const T *() const
    {
        return m_Value->m_Data;
    }

    //
    // Force a new copy of the data to be made.
    //
    GenericStringHandle Copy()
    {
        GenericStringHandle temp = m_Value->m_Data;
        return temp;
    }

    bool operator <( const GenericStringHandle & r ) const
    {
        if ( m_Value == r.m_Value)
            return false;
        return (wcscmp( this->m_Value->m_Data, r.m_Value->m_Data ) < 0);
    }

    T & operator[] ( const SIZE_T offset )
    {
        if (offset > Size())
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        return m_Value->m_Data[ offset ];
    }

    void Truncate( SIZE_T max )
    {
        if (Size() <= max)
            {
            return;
            }

        //
        // Create the new value string.
        //
        StringData * NewValue = Alloc( max );

        StringCchCopy( NewValue->m_Data, max+1, m_Value->m_Data );

        //
        // Replace the current value with the new value.
        //
        FreeIt();
        m_Value = NewValue;
    }

    T * GetToken( T * CursorIn, const T Separators[], T ** CursorOut );
};

typedef GenericStringHandle<TCHAR> StringHandleT;
typedef GenericStringHandle<CHAR> StringHandleA;
typedef GenericStringHandle<WCHAR> StringHandle;

inline WCHAR *
GenericStringHandle<WCHAR>::GetToken( WCHAR * Cursor, const WCHAR Separators[], WCHAR **pCursor )
{
    if (Cursor == NULL)
        {
        Cursor = m_Value->m_Data;
        }

    WCHAR * Token = NULL;

    if (Cursor < m_Value->m_Data + m_Value->m_Count)
        {
        Token = wcstok( Cursor, Separators );
        }

    if (Token)
        {
        *pCursor = Token + wcslen(Token) + 1;
        }
    else
        {
        *pCursor = m_Value->m_Data + m_Value->m_Count;
        }

    return Token;
}

typedef auto_ptr<WCHAR> CAutoStringW;
typedef auto_ptr<TCHAR> CAutoStringT;
typedef auto_ptr<char> CAutoStringA;
typedef  CAutoStringW CAutoString;

//
// PSID does not have an obvious ordering of the type required by the MAP classes.
// So we define one here.
//
class CSidSorter
{
public:

    bool operator()( const SidHandle & psid1, const SidHandle & psid2 ) const;
};

PSID DuplicateSid( PSID _Sid );

//---------------------------------------------

enum FILE_DOWNLOAD_RESULT
{
    QM_IN_PROGRESS,
    QM_FILE_ABORTED,
    QM_FILE_DONE,
    QM_FILE_TRANSIENT_ERROR,
    QM_FILE_FATAL_ERROR,
    QM_SERVER_FILE_CHANGED
};
/*
 The source field is divided into regions, like NTSTATUS and HRESULT codes.
 The lowest-order bit is bit 0; the highest is bit 31.

  bit 31:     reserved, MBZ

  bits 30-29: component

                00 = unknown
                01 = queue manager
                10 = transport
                11 =

  bits 28-16: sub-component

                for queue manager:  0 = unknown
                                    1 = local file handling
                                    2 = queue management
                                    3 = notification

                for transport:      0 = unknown
                                    1 = HTTP
                                    2 = HTTPS
                                    3 = FTP
                                    4 = SMB
                                    5 = DAV

  bits 15-0:  defined by sub-component

                for HTTP:           0 = unknown
                                    1 = client connection
                                    2 = server connection
                                    3 = server file handling

*/

#define COMPONENT_MASK  (0x3    << 30)
#define SUBCOMP_MASK    (0x3fff << 16)
#define FINAL_MASK      (0xffff << 0 )

#define COMPONENT_QMGR  (0x1 << 30)
#define COMPONENT_TRANS (0x2 << 30)

#define SUBCOMP_QMGR_FILE       (0x1 << 16)
#define SUBCOMP_QMGR_QUEUE      (0x2 << 16)
#define SUBCOMP_QMGR_NOTIFY     (0x3 << 16)
#define SUBCOMP_QMGR_CACHE      (0x4 << 16)

#define SUBCOMP_TRANS_HTTP      (COMPONENT_TRANS | (0x1 << 16))
#define SUBCOMP_TRANS_HTTPS     (COMPONENT_TRANS | (0x2 << 16))
#define SUBCOMP_TRANS_FTP       (COMPONENT_TRANS | (0x3 << 16))

enum ERROR_SOURCE
{
    SOURCE_NONE             = 0,
    SOURCE_QMGR_FILE        = (COMPONENT_QMGR | SUBCOMP_QMGR_FILE   | 0x0),
    SOURCE_QMGR_QUEUE       = (COMPONENT_QMGR | SUBCOMP_QMGR_QUEUE  | 0x0),
    SOURCE_QMGR_NOTIFY      = (COMPONENT_QMGR | SUBCOMP_QMGR_NOTIFY | 0x0),

    SOURCE_HTTP_UNKNOWN     = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x0),
    SOURCE_HTTP_CLIENT_CONN = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x1),
    SOURCE_HTTP_SERVER      = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x2),
    SOURCE_HTTP_SERVER_FILE = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x3),
    SOURCE_HTTP_SERVER_APP  = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x4)
};

enum ERROR_STYLE
{
    ERROR_STYLE_NONE        = 0,
    ERROR_STYLE_HRESULT     = 1,
    ERROR_STYLE_WIN32       = 2,
    ERROR_STYLE_HTTP        = 3
};

struct QMErrInfo
{
    FILE_DOWNLOAD_RESULT result;

    UINT64          Code;
    ERROR_STYLE     Style;
    ERROR_SOURCE    Source;
    wchar_t *       Description;

    QMErrInfo()
    {
        result = QM_FILE_DONE;
        Clear();
    }

    QMErrInfo(
        ERROR_SOURCE  Source,
        ERROR_STYLE   Style,
        UINT64        Code,
        char *        comment = 0
        );

    QMErrInfo(
        FILE_DOWNLOAD_RESULT Result,
        ERROR_SOURCE  Source,
        ERROR_STYLE   Style,
        UINT64        Code,
        char *        comment = 0
        ) : result( Result ), Description( NULL )
    {
        Set( Source, Style, Code, comment );
    }

    void
    Set(
        ERROR_SOURCE  Source,
        ERROR_STYLE   Style,
        UINT64        Code,
        char *        comment = 0
        );

    void Clear()
    {
        Source   = SOURCE_NONE;
        Style    = ERROR_STYLE_NONE;
        Code     = 0;
        Description = NULL;
    }

    bool IsSet()
    {
        return (Style != ERROR_STYLE_NONE);
    }

    void Log();

    bool operator==( const QMErrInfo & err )
    {
        if (Source == err.Source &&
            Style  == err.Style  &&
            Code   == err.Code)
            {
            return true;
            }

        return false;
    }

    bool operator!=( const QMErrInfo & err )
    {
        if (*this == err)
            {
            return false;
            }

        return true;
    }
};

//---------------------------------------------

const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per sec

const TCHAR * const C_BITS_USER_AGENT = _T("Microsoft BITS/") VER_PRODUCTVERSION_WSTRING;

// Registry keys
const TCHAR * const  C_QMGR_REG_KEY = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\BITS");

// Registry Value(REG_SZ).
// Point to where to load the upgraded DLL
const TCHAR * const  C_QMGR_SERVICEDLL = _T("ServiceDLL");

// Registry Values(REG_DWORD/seconds)
const TCHAR * const  C_QMGR_STATE_INDEX            = _T("StateIndex");
const TCHAR * const  C_QMGR_JOB_INACTIVITY_TIMEOUT = _T("JobInactivityTimeout");
const TCHAR * const  C_QMGR_TIME_QUANTA_LENGTH     = _T("TimeQuantaLength");
const TCHAR * const  C_QMGR_NO_PROGRESS_TIMEOUT    = _T("JobNoProgressTimeout");
const TCHAR * const  C_QMGR_MINIMUM_RETRY_DELAY    = _T("JobMinimumRetryDelay");
const TCHAR * const  C_QMGR_ALLOW_TEST_DLL      = _T("AllowTestDll");

// Logging registry Values(REG_DWORD)
const TCHAR * const C_QMGR_LOGFILE_SIZE            = _T("LogFileSize"); // In MB
const TCHAR * const C_QMGR_LOGFILE_FLAGS           = _T("LogFileFlags");
const TCHAR * const C_QMGR_LOGFILE_MINMEMORY       = _T("LogFileMinMemory"); // In MB

// default values
const UINT32 C_QMGR_JOB_INACTIVITY_TIMEOUT_DEFAULT  = (60ui64 * 60ui64 * 24ui64 * 90ui64); // 90 days
const UINT32 C_QMGR_TIME_QUANTA_LENGTH_DEFAULT      = (5 * 60); // 5 minutes
const UINT32 C_QMGR_NO_PROGRESS_TIMEOUT_DEFAULT     = (14 * 24 * 60 * 60); //14 days
const UINT32 C_QMGR_MINIMUM_RETRY_DELAY_DEFAULT     = (10 * 60); // ten minutes

// Logging default values
const UINT32 C_QMGR_LOGFILE_SIZE_DEFAULT            = 1;

#if DBG
// Debug/Non-ship mode
// everything except 0x010 - Ref Counts and 0x020 - State File
//
const UINT32 C_QMGR_LOGFILE_FLAGS_DEFAULT           = 0xFFCF;
#else
const UINT32 C_QMGR_LOGFILE_FLAGS_DEFAULT           = 0;
#endif

const UINT32 C_QMGR_LOGFILE_MINMEMORY_DEFAULT       = 120;

// Policy keys
const TCHAR * const  C_QMGR_POLICY_REG_KEY = _T("Software\\Policies\\Microsoft\\Windows\\BITS");

// Policy values
const TCHAR * const  C_QMGR_POLICY_JOB_INACTIVITY_TIMEOUT = _T("JobInactivityTimeout");

//
// The directory "%ALLUSERSPROFILE%\Application Data\Microsoft" should always exist.
// At startup, we create "Microsoft\Network" and "Microsoft\Network\Downloader" if necessary.
// To avoid having to parse and verify the whole path, the last two components are explicitly checked.
//
const TCHAR * const  C_QMGR_PARENT_DIRECTORY = _T("\\Microsoft\\Network\\");
const TCHAR * const  C_QMGR_DIRECTORY = _T("\\Microsoft\\Network\\Downloader\\");

const wchar_t NullString[] = L"(null)";



// cfreg.cpp - Functions to handle registry keys
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int iBufferSize);
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue);
HRESULT DeleteRegStringValue(LPCTSTR lpszValueName);
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue);
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue);

// service.cxx
HRESULT SetServiceStartup( bool bAutoStart );

// helpers.cpp
BOOL QMgrFileExists(LPCTSTR szFile);
FILETIME GetTimeAfterDelta( UINT64 uDelta );
BOOL IsConnected();

LPCWSTR TruncateString( LPCWSTR String, SIZE_T MaxLength, auto_ptr<WCHAR> & AutoPointer );

////////////////////////////////////////////////////////////////////////
//
//   Global info class
//
////////////////////////////////////////////////////////////////////////


class GlobalInfo
{
private:

    GlobalInfo( TCHAR *QmgrDirectory,
                LARGE_INTEGER PerfamceCounterFrequency,
                HKEY QmgrRegistryRoot,
                UINT64 JobInactivityTimeout,
                UINT64 TimeQuantaLength,
                UINT32 DefaultNoProgressTimeout,
                UINT32 DefaultMinimumRetryDelay,
                SECURITY_DESCRIPTOR *MetadataSecurityDescriptor,
                DWORD MetadataSecurityDescriptorLength,
                SidHandle AdministratorsSid,
                SidHandle LocalSystemSid,
                SidHandle NetworkUsersSid,
                SidHandle AnonymousSid
                );

    ~GlobalInfo();

public:

    static DWORD RegGetDWORD( HKEY hKey, const TCHAR * pValue, DWORD dwDefault );

    const TCHAR * const m_QmgrDirectory;
    const LARGE_INTEGER m_PerformanceCounterFrequency;
    const HKEY m_QmgrRegistryRoot;
    const UINT64 m_JobInactivityTimeout;
    const UINT64 m_TimeQuantaLength;
    const UINT32 m_DefaultNoProgressTimeout;
    const UINT32 m_DefaultMinimumRetryDelay;
    const SECURITY_DESCRIPTOR * const m_MetadataSecurityDescriptor;
    const DWORD m_MetadataSecurityDescriptorLength;
    const SidHandle m_AdministratorsSid;
    const SidHandle m_LocalSystemSid;
    const SidHandle m_NetworkUsersSid;
    const SidHandle m_AnonymousSid;

    static HRESULT Init(void);
    static HRESULT Uninit(void);

};

extern class GlobalInfo *g_GlobalInfo;

//
// variables to keep track of service state
//
enum MANAGER_STATE
{
    MANAGER_INACTIVE,
    MANAGER_STARTING,
    MANAGER_ACTIVE,
    MANAGER_TERMINATING
};

extern MANAGER_STATE g_ServiceState;
extern long          g_ServiceInstance;
extern DWORD         g_LastServiceControl;

//
// Jump to a label on failure.  Assumes an HRESULT "hr" and a label "Cleanup".
//
#define CLEANUP_ON_FAILURE( x ) \
                hr = x; \
                if (FAILED(hr)) \
                    { \
                    goto Cleanup; \
                    }

#define RETURN_HRESULT( x ) \
            { \
            HRESULT _hr_ = (x); \
            if (FAILED(_hr_)) \
                { \
                return _hr_; \
                } \
            }

#define GFA_FAILED   DWORD(-1)

inline BOOL FileExists( LPWSTR szFile )
{
    DWORD dwAttr = GetFileAttributes( szFile );

    if( GFA_FAILED == dwAttr )
        return FALSE;

    return (BOOL)( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) );
}

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
}

inline FILETIME UINT64ToFILETIME( UINT64 Int64Value )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.QuadPart = Int64Value;

    FILETIME FileTime;
    FileTime.dwHighDateTime = LargeInteger.HighPart;
    FileTime.dwLowDateTime = LargeInteger.LowPart;

    return FileTime;
}

//------------------------------------------------------------------------
//
// NT security
//
//------------------------------------------------------------------------

SidHandle GetThreadClientSid();

HRESULT
ImpersonateSid(
    PSID sid
    );

BOOL
SidToString(
    PSID sid,
    wchar_t buffer[],
    USHORT bytes
    );

HRESULT
IsRemoteUser();

HRESULT
IsAdministratorUser();

HRESULT
DenyRemoteAccess();

HRESULT
DenyNonAdminAccess();

PSID DuplicateSid( PSID _Sid );

//
// allows CreateInstanceInSession to choose an arbitrary session.
//
#define ANY_SESSION  DWORD(-1)

HRESULT
CreateInstanceInSession(
    REFCLSID clsid,
    REFIID   iid,
    DWORD    session,
    void **  pif
    );

HRESULT
SetStaticCloaking(
    IUnknown *pUnk
    );

HRESULT
ApplyIdentityToInterface(
  IUnknown *pUnk,
  PSID sid
  );

struct IBackgroundCopyCallback;
struct IBackgroundCopyCallback1;

HRESULT
CreateUserCallback(
  CLSID clsid,
  PSID sid,
  IBackgroundCopyCallback **pICB
  );

HRESULT
CreateOldUserCallback(
  CLSID clsid,
  PSID sid,
  IBackgroundCopyCallback1 **pICB
  );

HRESULT
SessionLogonCallback(
    DWORD SessionId
    );

HRESULT
SessionLogoffCallback(
    DWORD SessionId
    );

DWORD
DeviceEventCallback(
    DWORD dwEventType,
    LPVOID lpEventData
    );


BOOL Log_Init();
void Log_StartLogger();
void Log_Close();

HRESULT GlobalInit();
HRESULT GlobalUninit();

HRESULT InitQmgr();
HRESULT UninitQmgr();

const GUID BITSCtrlGuid = {0x4a8aaa94,0xcfc4,0x46a7,{0x8e,0x4e,0x17,0xbc,0x45,0x60,0x8f,0x0a}};

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(CtlGuid,(4a8aaa94,cfc4,46a7,8e4e,17bc45608f0a),  \
        WPP_DEFINE_BIT(LogFlagInfo)                 \
        WPP_DEFINE_BIT(LogFlagWarning)              \
        WPP_DEFINE_BIT(LogFlagError)                \
        WPP_DEFINE_BIT(LogFlagFunction)             \
        WPP_DEFINE_BIT(LogFlagRefCount)             \
        WPP_DEFINE_BIT(LogFlagSerialize)            \
        WPP_DEFINE_BIT(LogFlagDownload)             \
        WPP_DEFINE_BIT(LogFlagTask)                 \
        WPP_DEFINE_BIT(LogFlagLock)                 \
        WPP_DEFINE_BIT(LogFlagService)              \
        )


#define LogLevelEnabled(flags) WPP_LEVEL_ENABLED(flags)                                                       \

LONG ExternalFuncExceptionFilter( struct _EXCEPTION_POINTERS *ExceptionInfo );

//
// We keep track of COM calls because we can't delete our objects at shutdown
// until all the active calls have stopped referring to them.
//
extern long g_cCalls;

inline void IncrementCallCount()
{
    InterlockedIncrement(&g_cCalls);
}

inline void DecrementCallCount()
{
    InterlockedDecrement(&g_cCalls);
}

inline long ActiveCallCount()
{
    return g_cCalls;
}

//
// A simple helper class to keep track of our call count.
//
class DispatchedCall
{
public:
    DispatchedCall()  { IncrementCallCount(); }
    ~DispatchedCall() { DecrementCallCount(); }
};

//
// Each member function of our public COM interfaces has an external
// and an internal version.  The external version is simply
//    {
//        EXTERNAL_FUNC_WRAP( internal-version );
//    }
// This captures any exceptions in a way that can be reported by the OfficeWatson
// error-reporting apparatus.
// It also checks for service shutdown.
//
HRESULT
CheckServerInstance(
    long ObjectServiceInstance
    );

#define EXTERNAL_FUNC_WRAP( call_parent )                       \
                                                                \
    __try                                                       \
        {                                                       \
        RETURN_HRESULT( CheckServerInstance( m_ServiceInstance )); \
                                                                \
        HRESULT hr = call_parent ;                              \
                                                                \
        DecrementCallCount();                                   \
        return hr;                                              \
        }                                                       \
    __except( ExternalFuncExceptionFilter( GetExceptionInformation() ) ) \
        {                                                       \
        DecrementCallCount();                                   \
        return RPC_E_SERVERFAULT;                               \
        }                                                       \

//
// IUnknown member functions use these alternate macros.
//
#define BEGIN_EXTERNAL_FUNC                                     \
    __try                                                       \
        {                                                       \

#define END_EXTERNAL_FUNC                                       \
        }                                                       \
    __except( ExternalFuncExceptionFilter( GetExceptionInformation() ) ) \
        {                                                       \
        return RPC_E_SERVERFAULT;                               \
        }                                                       \


StringHandle
BITSCrackFileName(
    const WCHAR * RawFileName,
    StringHandle & ReturnFileName
    );

StringHandle
BITSCreateTempFile(
    StringHandle Directory
    );

HRESULT
BITSCheckFileWritability(
    LPCWSTR name
    );

StringHandle
CombineUrl(
    LPCWSTR BaseUrl,
    LPCWSTR RelativeUrl,
    DWORD Flags
    );

LPWSTR MidlCopyString( LPCWSTR source, size_t Length  = -1);

inline LPWSTR MidlCopyString( StringHandle source )
{
    return MidlCopyString( source, source.Size()+1 );
}

LPWSTR CopyString( LPCWSTR source, size_t Length  = -1);

inline LPWSTR CopyString( StringHandle source )
{
    return CopyString( source, source.Size()+1 );
}

inline bool operator==( const FILETIME left, const FILETIME right )
{
    return ((left.dwLowDateTime  == right.dwLowDateTime) &&
            (left.dwHighDateTime == right.dwHighDateTime));
}

inline bool operator!=( const FILETIME left, const FILETIME right )
{
    return !(left == right);
}

bool IsServiceShuttingDown();

bool IsAnyDebuggerPresent();

bool InitCompilerLibrary();
bool UninitCompilerLibrary();

#if defined(BITS_V12_ON_NT4)

extern ULONG BITSFlags;
void Log( const CHAR *Prefix, const CHAR *Format, va_list ArgList );

const DWORD LogFlagInfo         = 0;
const DWORD LogFlagWarning      = 1;
const DWORD LogFlagError        = 2;
const DWORD LogFlagFunction     = 4;
const DWORD LogFlagRefCount     = 8;
const DWORD LogFlagRef          = LogFlagRefCount;
const DWORD LogFlagSerialize    = 16;
const DWORD LogFlagSerial       = LogFlagSerialize;
const DWORD LogFlagDownload     = 32;
const DWORD LogFlagDl           = LogFlagDownload;
const DWORD LogFlagTask         = 64;
const DWORD LogFlagLock         = 128;
const DWORD LogFlagService      = 256;
const DWORD LogFlagPublicApiBegin = LogFlagFunction;
const DWORD LogFlagPublicApiEnd   = LogFlagFunction;

#define DEFINE_SIMPLE_LOG_FUNCT( flag, prefix )                    \
inline void Log##flag##( const char *format, ...)                  \
{                                                                  \
    if ( ! ( BITSFlags & ~LogFlag##flag ) )                        \
        return;                                                    \
    va_list marker;                                                \
    va_start( marker, format );                                    \
    Log( prefix, format, marker );                                 \
}                                                                  \

DEFINE_SIMPLE_LOG_FUNCT( Info,              " INFO        :" )
DEFINE_SIMPLE_LOG_FUNCT( Warning,           " WARNING     :" )
DEFINE_SIMPLE_LOG_FUNCT( Error,             " ERROR       :" )
DEFINE_SIMPLE_LOG_FUNCT( PublicApiBegin,    " FUNC_BEGIN  :" )
DEFINE_SIMPLE_LOG_FUNCT( PublicApiEnd,      " FUNC_END    :" )
DEFINE_SIMPLE_LOG_FUNCT( Ref,               " REF         :" )
DEFINE_SIMPLE_LOG_FUNCT( Lock,              " LOCK        :" )
DEFINE_SIMPLE_LOG_FUNCT( Task,              " TASK        :" )
DEFINE_SIMPLE_LOG_FUNCT( Service,           " SERVICE     :" )
DEFINE_SIMPLE_LOG_FUNCT( Dl,                " DOWNLOAD    :" )
DEFINE_SIMPLE_LOG_FUNCT( Serial,            " SERIALIZE   :" )

BOOL
BITSAltGetFileSizeEx(
   HANDLE hFile,              // handle to file
   PLARGE_INTEGER lpFileSize  // file size
   );

BOOL
BITSAltSetFilePointerEx(
    HANDLE hFile,                    // handle to file
    LARGE_INTEGER liDistanceToMove,  // bytes to move pointer
    PLARGE_INTEGER lpNewFilePointer, // new file pointer
    DWORD dwMoveMethod               // starting point
    );

BOOL
BITSAltConvertSidToStringSidW(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    );

BOOL
BITSAltConvertStringSidToSidW(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    );

BOOL
BITSAltCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    );

SERVICE_STATUS_HANDLE
BITSAltRegisterServiceCtrlHandlerExW(
  LPCTSTR lpServiceName,                // name of service
  LPHANDLER_FUNCTION_EX lpHandlerProc,  // handler function
  LPVOID lpContext                      // user data
);

#define GetFileSizeEx BITSAltGetFileSizeEx
#define SetFilePointerEx BITSAltSetFilePointerEx
#define ConvertSidToStringSidW BITSAltConvertSidToStringSidW
#define ConvertStringSidToSidW BITSAltConvertStringSidToSidW
#define CheckTokenMembership  BITSAltCheckTokenMembership
#define RegisterServiceCtrlHandlerExW BITSAltRegisterServiceCtrlHandlerExW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\isapi\bitisapi.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    bitisapi.cpp

Abstract :

    ISAPI to get HTTP/1.1 byte range to work through HTTP/1.0 proxies.

Author :

Revision History :

 ***********************************************************************/

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <httpfilt.h>
#include <strsafe.h>

// From ntrtl.h:
//
extern "C"
{
ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );
}

const size_t INT_DIGITS = 10;
const size_t INT64_DIGITS = 20;

BOOL
DecodeURL(LPSTR pszUrl, LPCSTR * ppRange);

BOOL WINAPI
GetFilterVersion(HTTP_FILTER_VERSION * pVer)
{
    //
    //  Specify the types and order of notification
    //
    pVer->dwFlags = (SF_NOTIFY_PREPROC_HEADERS | SF_NOTIFY_ORDER_HIGH);
    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    StringCchCopyA( pVer->lpszFilterDesc, SF_MAX_FILTER_DESC_LEN, "ISAPI filter for BITS download");

    return TRUE;
}


DWORD WINAPI
HttpFilterProc( HTTP_FILTER_CONTEXT *   pfc,
                DWORD                   NotificationType,
                VOID *                  pvData )
{
    char Template[] = " bytes=%s\r\n";

    HTTP_FILTER_PREPROC_HEADERS *pHeaders;

    char szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cbUrl = sizeof(szUrl);

    // The value of the range header.  Looks like "bytes=<start>-<end>".
    //
    char szValue[ RTL_NUMBER_OF(Template) + INT64_DIGITS + 1 + INT64_DIGITS ];

    LPCSTR szRange = 0;


    if (NotificationType == SF_NOTIFY_PREPROC_HEADERS)
    {
        pHeaders = (PHTTP_FILTER_PREPROC_HEADERS) pvData;
        if (! pHeaders->GetHeader(pfc, "url", szUrl, &cbUrl))
            {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
            }

        if (! DecodeURL(szUrl, &szRange))
            {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
            }

        if (! pHeaders->SetHeader(pfc, "url", szUrl))
            {
            #if DBG
            DbgPrint("unable to set URL='%s'", szUrl);
            #endif
            return SF_STATUS_REQ_ERROR;
            }

        if (S_OK != StringCbPrintfA(szValue, sizeof(szValue), Template, szRange))
            {
            #if DBG
            DbgPrint("byte range is too long: '%s'", szRange );
            #endif
            return SF_STATUS_REQ_ERROR;
            }

        if (! pHeaders->AddHeader(pfc, "Range:", szValue))
            {
            return SF_STATUS_REQ_ERROR;
            }
    }
    return SF_STATUS_REQ_NEXT_NOTIFICATION;

}

BOOL
DecodeURL(LPSTR pszUrl, LPCSTR * ppRange)
{
    LPSTR pszStart = strchr(pszUrl, '@');
    if (!pszStart)
        {
        return FALSE;
        }

    ++pszStart;

    LPSTR pszEnd = strchr(pszStart, '@');
    if (!pszEnd)
        {
        return FALSE;
        }

    //
    // Plant '\0' over the leading and trailing '@'.
    //
    *(pszStart-1) = '\0';
    *pszEnd = '\0';

    *ppRange = pszStart;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\inc\inethttp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    inethttp.h

Abstract:

    This header maps some wininet API to winhttp

--*/

// API mappings

#define INTERNET_MAX_URL_LENGTH  2200
#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_RFC1123_BUFSIZE    WINHTTP_TIME_FORMAT_BUFSIZE
#define INTERNET_RFC1123_FORMAT     0

inline BOOL __stdcall
InternetTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format
    OUT LPWSTR lpszTime,        // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
{
    if (cbTime < WINHTTP_TIME_FORMAT_BUFSIZE)
        {
        return ERROR_BUFFER_OVERFLOW;
        }

    return WinHttpTimeFromSystemTime( pst, lpszTime );
}

#define InternetTimeToSystemTime    WinHttpTimeToSystemTime

#define InternetCrackUrl            WinHttpCrackUrl

#define InternetCreateUrl           WinHttpCreateUrl

#define INTERNET_OPEN_TYPE_PRECONFIG        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY
#define INTERNET_OPEN_TYPE_DIRECT           WINHTTP_ACCESS_TYPE_NO_PROXY
#define INTERNET_OPEN_TYPE_PROXY            WINHTTP_ACCESS_TYPE_NAMED_PROXY

#define InternetOpen                WinHttpOpen

#define InternetSetStatusCallback(h, pcb)\
    WinHttpSetStatusCallback(h, pcb, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, 0)


#define INTERNET_OPTION_END_BROWSER_SESSION     42

inline BOOL __stdcall
InternetSetOption(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    if (dwOption == INTERNET_OPTION_END_BROWSER_SESSION)
        {
        return TRUE;
        }

    return WinHttpSetOption( hInternet, dwOption, lpBuffer, dwBufferLength );
}


#define InternetQueryOption         WinHttpQueryOption

#define INTERNET_SERVICE_HTTP   3

inline HINTERNET __stdcall
InternetConnect(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return WinHttpConnect( hInternet,
                           lpszServerName,
                           nServerPort,
                           0 );
}


inline HINTERNET __stdcall
HttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return WinHttpOpenRequest( hConnect,
                               lpszVerb,
                               lpszObjectName,
                               lpszVersion,
                               lpszReferrer,
                               lplpszAcceptTypes,
                               dwFlags
                               );
}


#define HttpAddRequestHeaders       WinHttpAddRequestHeaders


typedef struct _INTERNET_BUFFERS {
    DWORD dwStructSize;                 // used for API versioning. Set to sizeof(INTERNET_BUFFERS)
    struct _INTERNET_BUFFERSW * Next;   // chain of buffers
    LPCWSTR  lpcszHeader;               // pointer to headers (may be NULL)
    DWORD dwHeadersLength;              // length of headers if not NULL
    DWORD dwHeadersTotal;               // size of headers if not enough buffer
    LPVOID lpvBuffer;                   // pointer to data buffer (may be NULL)
    DWORD dwBufferLength;               // length of data buffer if not NULL
    DWORD dwBufferTotal;                // total size of chunk, or content-length if not chunked
    DWORD dwOffsetLow;                  // used for read-ranges (only used in HttpSendRequest2)
    DWORD dwOffsetHigh;
} INTERNET_BUFFERS, * LPINTERNET_BUFFERS;

#define HSR_INITIATE 8

inline BOOL __stdcall
HttpSendRequestEx(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERS lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERS lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    if (dwFlags != HSR_INITIATE ||
        lpBuffersOut)
        {
        return ERROR_CALL_NOT_IMPLEMENTED;
        }

    return WinHttpSendRequest( hRequest,
                               NULL,
                               0,
                               NULL,
                               WINHTTP_NO_REQUEST_DATA,
                               lpBuffersIn->dwBufferTotal,
                               0
                               );
}

inline  BOOL __stdcall
HttpEndRequest(
    IN HINTERNET hRequest,
    OUT INTERNET_BUFFERS * lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    DWORD dwStatus = 0;
    DWORD dwLength = sizeof(DWORD);

    if (lpBuffersOut || dwFlags)
        {
        return ERROR_CALL_NOT_IMPLEMENTED;
        }

    if (!WinHttpReceiveResponse(hRequest,0))
        {
        return FALSE;
        }

    //
    // On slow connections, it is possible that the server will send a 100 Continue
    // status after receiving the headers. If that happens, then we want to skip
    // that response and receive again to get the final response/status.
    //
    if (!WinHttpQueryHeaders(hRequest,
                             WINHTTP_QUERY_STATUS_CODE|WINHTTP_QUERY_FLAG_NUMBER,
                             NULL,
                             &dwStatus,
                             &dwLength,
                             NULL))
        {
        return FALSE;
        }

    if (dwStatus == HTTP_STATUS_CONTINUE)
        {
        return WinHttpReceiveResponse(hRequest,0);
        }

    return TRUE;
}


#define InternetWriteFile(h,p,cb,pcb) WinHttpWriteData(h,p,cb,pcb)


#define HttpQueryInfo(h,dw,pb,pcb,ndx)\
    WinHttpQueryHeaders(h,dw,((LPCWSTR) pb),pb,pcb,ndx)

#define InternetQueryDataAvailable  WinHttpQueryDataAvailable

#define InternetReadFile(h,p,cb,pcb) WinHttpReadData(h,p,cb,pcb)

#define InternetCloseHandle         WinHttpCloseHandle

inline HINTERNET __stdcall
InternetOpenUrl(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return NULL;
}


// InternetSetOption values

#define INTERNET_FIRST_OPTION                        WINHTTP_FIRST_OPTION
#define INTERNET_OPTION_CALLBACK                     WINHTTP_OPTION_CALLBACK
#define INTERNET_OPTION_RESOLVE_TIMEOUT              WINHTTP_OPTION_RESOLVE_TIMEOUT
#define INTERNET_OPTION_CONNECT_TIMEOUT              WINHTTP_OPTION_CONNECT_TIMEOUT
#define INTERNET_OPTION_CONNECT_RETRIES              WINHTTP_OPTION_CONNECT_RETRIES
#define INTERNET_OPTION_SEND_TIMEOUT                 WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT              WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_HANDLE_TYPE                  WINHTTP_OPTION_HANDLE_TYPE
#define INTERNET_OPTION_READ_BUFFER_SIZE             WINHTTP_OPTION_READ_BUFFER_SIZE
#define INTERNET_OPTION_WRITE_BUFFER_SIZE            WINHTTP_OPTION_WRITE_BUFFER_SIZE
#define INTERNET_OPTION_PARENT_HANDLE                WINHTTP_OPTION_PARENT_HANDLE
#define INTERNET_OPTION_REQUEST_FLAGS                WINHTTP_OPTION_REQUEST_FLAGS
#define INTERNET_OPTION_EXTENDED_ERROR               WINHTTP_OPTION_EXTENDED_ERROR
#define INTERNET_OPTION_SECURITY_FLAGS               WINHTTP_OPTION_SECURITY_FLAGS
#define INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT  WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT
#define INTERNET_OPTION_URL                          WINHTTP_OPTION_URL
#define INTERNET_OPTION_SECURITY_KEY_BITNESS         WINHTTP_OPTION_SECURITY_KEY_BITNESS
#define INTERNET_OPTION_PROXY                        WINHTTP_OPTION_PROXY
#define INTERNET_OPTION_VERSION                      WINHTTP_OPTION_VERSION
#define INTERNET_OPTION_USER_AGENT                   WINHTTP_OPTION_USER_AGENT
#define INTERNET_OPTION_CONTEXT_VALUE                WINHTTP_OPTION_CONTEXT_VALUE
#define INTERNET_OPTION_CLIENT_CERT_CONTEXT          WINHTTP_OPTION_CLIENT_CERT_CONTEXT
#define INTERNET_OPTION_POLICY                       WINHTTP_OPTION_POLICY
#define INTERNET_OPTION_REQUEST_PRIORITY             WINHTTP_OPTION_REQUEST_PRIORITY
#define INTERNET_OPTION_HTTP_VERSION                 WINHTTP_OPTION_HTTP_VERSION
#define INTERNET_OPTION_ERROR_MASK                   WINHTTP_OPTION_ERROR_MASK
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT         WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT      WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT            WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT         WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_CODEPAGE                     WINHTTP_OPTION_CODEPAGE
#define INTERNET_OPTION_MAX_CONNS_PER_SERVER         WINHTTP_OPTION_MAX_CONNS_PER_SERVER
#define INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER     WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER
#define INTERNET_OPTION_PER_CONNECTION_OPTION        WINHTTP_OPTION_PER_CONNECTION_OPTION
#define INTERNET_OPTION_DIGEST_AUTH_UNLOAD           WINHTTP_OPTION_DIGEST_AUTH_UNLOAD
#define INTERNET_LAST_OPTION                         WINHTTP_LAST_OPTION

// status callback

#define INTERNET_ASYNC_RESULT                        WINHTTP_ASYNC_RESULT
#define LPINTERNET_ASYNC_RESULT                      LPWINHTTP_ASYNC_RESULT

#define INTERNET_STATUS_RESOLVING_NAME               WINHTTP_STATUS_RESOLVING_NAME
#define INTERNET_STATUS_NAME_RESOLVED                WINHTTP_STATUS_NAME_RESOLVED
#define INTERNET_STATUS_CONNECTING_TO_SERVER         WINHTTP_STATUS_CONNECTING_TO_SERVER
#define INTERNET_STATUS_CONNECTED_TO_SERVER          WINHTTP_STATUS_CONNECTED_TO_SERVER
#define INTERNET_STATUS_SENDING_REQUEST              WINHTTP_STATUS_SENDING_REQUEST
#define INTERNET_STATUS_REQUEST_SENT                 WINHTTP_STATUS_REQUEST_SENT
#define INTERNET_STATUS_RECEIVING_RESPONSE           WINHTTP_STATUS_RECEIVING_RESPONSE
#define INTERNET_STATUS_RESPONSE_RECEIVED            WINHTTP_STATUS_RESPONSE_RECEIVED
#define INTERNET_STATUS_CLOSING_CONNECTION           WINHTTP_STATUS_CLOSING_CONNECTION
#define INTERNET_STATUS_CONNECTION_CLOSED            WINHTTP_STATUS_CONNECTION_CLOSED
#define INTERNET_STATUS_HANDLE_CREATED               WINHTTP_STATUS_HANDLE_CREATED
#define INTERNET_STATUS_HANDLE_CLOSING               WINHTTP_STATUS_HANDLE_CLOSING
#define INTERNET_STATUS_DETECTING_PROXY              WINHTTP_STATUS_DETECTING_PROXY
#define INTERNET_STATUS_REQUEST_COMPLETE             WINHTTP_STATUS_REQUEST_COMPLETE
#define INTERNET_STATUS_REDIRECT                     WINHTTP_STATUS_REDIRECT
#define INTERNET_STATUS_INTERMEDIATE_RESPONSE        WINHTTP_STATUS_INTERMEDIATE_RESPONSE

#define INTERNET_STATUS_CALLBACK                     WINHTTP_STATUS_CALLBACK
#define LPINTERNET_STATUS_CALLBACK                   LPWINHTTP_STATUS_CALLBACK
#define INTERNET_INVALID_STATUS_CALLBACK             WINHTTP_INVALID_STATUS_CALLBACK
#define INTERNET_NO_CALLBACK                         0

// flags

#define INTERNET_FLAG_PRAGMA_NO_CACHE                WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_DONT_CACHE                     WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_SECURE                         WINHTTP_FLAG_SECURE
#define INTERNET_FLAG_NO_UI                          0
#define INTERNET_FLAG_RELOAD                          0



// handle types

#define INTERNET_HANDLE_TYPE_INTERNET           WINHTTP_HANDLE_TYPE_SESSION
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       WINHTTP_HANDLE_TYPE_CONNECT
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       WINHTTP_HANDLE_TYPE_REQUEST


#define HTTP_ADDREQ_INDEX_MASK        WINHTTP_ADDREQ_INDEX_MASK
#define HTTP_ADDREQ_FLAGS_MASK        WINHTTP_ADDREQ_FLAGS_MASK
#define HTTP_ADDREQ_FLAG_ADD_IF_NEW   WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
#define HTTP_ADDREQ_FLAG_ADD          WINHTTP_ADDREQ_FLAG_ADD
#define HTTP_ADDREQ_FLAG_REPLACE      WINHTTP_ADDREQ_FLAG_REPLACE
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
#define HTTP_ADDREQ_FLAG_COALESCE                  WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA


#define HTTP_QUERY_MIME_VERSION                 WINHTTP_QUERY_MIME_VERSION
#define HTTP_QUERY_CONTENT_TYPE                 WINHTTP_QUERY_CONTENT_TYPE
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING
#define HTTP_QUERY_CONTENT_ID                   WINHTTP_QUERY_CONTENT_ID
#define HTTP_QUERY_CONTENT_DESCRIPTION          WINHTTP_QUERY_CONTENT_DESCRIPTION
#define HTTP_QUERY_CONTENT_LENGTH               WINHTTP_QUERY_CONTENT_LENGTH
#define HTTP_QUERY_CONTENT_LANGUAGE             WINHTTP_QUERY_CONTENT_LANGUAGE
#define HTTP_QUERY_ALLOW                        WINHTTP_QUERY_ALLOW
#define HTTP_QUERY_PUBLIC                       WINHTTP_QUERY_PUBLIC
#define HTTP_QUERY_DATE                         WINHTTP_QUERY_DATE
#define HTTP_QUERY_EXPIRES                      WINHTTP_QUERY_EXPIRES
#define HTTP_QUERY_LAST_MODIFIED                WINHTTP_QUERY_LAST_MODIFIED
#define HTTP_QUERY_MESSAGE_ID                   WINHTTP_QUERY_MESSAGE_ID
#define HTTP_QUERY_URI                          WINHTTP_QUERY_URI
#define HTTP_QUERY_DERIVED_FROM                 WINHTTP_QUERY_DERIVED_FROM
#define HTTP_QUERY_COST                         WINHTTP_QUERY_COST
#define HTTP_QUERY_LINK                         WINHTTP_QUERY_LINK
#define HTTP_QUERY_PRAGMA                       WINHTTP_QUERY_PRAGMA
#define HTTP_QUERY_VERSION                      WINHTTP_QUERY_VERSION
#define HTTP_QUERY_STATUS_CODE                  WINHTTP_QUERY_STATUS_CODE
#define HTTP_QUERY_STATUS_TEXT                  WINHTTP_QUERY_STATUS_TEXT
#define HTTP_QUERY_RAW_HEADERS                  WINHTTP_QUERY_RAW_HEADERS
#define HTTP_QUERY_RAW_HEADERS_CRLF             WINHTTP_QUERY_RAW_HEADERS_CRLF
#define HTTP_QUERY_CONNECTION                   WINHTTP_QUERY_CONNECTION
#define HTTP_QUERY_ACCEPT                       WINHTTP_QUERY_ACCEPT
#define HTTP_QUERY_ACCEPT_CHARSET               WINHTTP_QUERY_ACCEPT_CHARSET
#define HTTP_QUERY_ACCEPT_ENCODING              WINHTTP_QUERY_ACCEPT_ENCODING
#define HTTP_QUERY_ACCEPT_LANGUAGE              WINHTTP_QUERY_ACCEPT_LANGUAGE
#define HTTP_QUERY_AUTHORIZATION                WINHTTP_QUERY_AUTHORIZATION
#define HTTP_QUERY_CONTENT_ENCODING             WINHTTP_QUERY_CONTENT_ENCODING
#define HTTP_QUERY_FORWARDED                    WINHTTP_QUERY_FORWARDED
#define HTTP_QUERY_FROM                         WINHTTP_QUERY_FROM
#define HTTP_QUERY_IF_MODIFIED_SINCE            WINHTTP_QUERY_IF_MODIFIED_SINCE
#define HTTP_QUERY_LOCATION                     WINHTTP_QUERY_LOCATION
#define HTTP_QUERY_ORIG_URI                     WINHTTP_QUERY_ORIG_URI
#define HTTP_QUERY_REFERER                      WINHTTP_QUERY_REFERER
#define HTTP_QUERY_RETRY_AFTER                  WINHTTP_QUERY_RETRY_AFTER
#define HTTP_QUERY_SERVER                       WINHTTP_QUERY_SERVER
#define HTTP_QUERY_TITLE                        WINHTTP_QUERY_TITLE
#define HTTP_QUERY_USER_AGENT                   WINHTTP_QUERY_USER_AGENT
#define HTTP_QUERY_WWW_AUTHENTICATE             WINHTTP_QUERY_WWW_AUTHENTICATE
#define HTTP_QUERY_PROXY_AUTHENTICATE           WINHTTP_QUERY_PROXY_AUTHENTICATE
#define HTTP_QUERY_ACCEPT_RANGES                WINHTTP_QUERY_ACCEPT_RANGES
#define HTTP_QUERY_SET_COOKIE                   WINHTTP_QUERY_SET_COOKIE
#define HTTP_QUERY_COOKIE                       WINHTTP_QUERY_COOKIE
#define HTTP_QUERY_REQUEST_METHOD               WINHTTP_QUERY_REQUEST_METHOD
#define HTTP_QUERY_REFRESH                      WINHTTP_QUERY_REFRESH
#define HTTP_QUERY_CONTENT_DISPOSITION          WINHTTP_QUERY_CONTENT_DISPOSITION
#define HTTP_QUERY_AGE                          WINHTTP_QUERY_AGE
#define HTTP_QUERY_CACHE_CONTROL                WINHTTP_QUERY_CACHE_CONTROL
#define HTTP_QUERY_CONTENT_BASE                 WINHTTP_QUERY_CONTENT_BASE
#define HTTP_QUERY_CONTENT_LOCATION             WINHTTP_QUERY_CONTENT_LOCATION
#define HTTP_QUERY_CONTENT_MD5                  WINHTTP_QUERY_CONTENT_MD5
#define HTTP_QUERY_CONTENT_RANGE                WINHTTP_QUERY_CONTENT_RANGE
#define HTTP_QUERY_ETAG                         WINHTTP_QUERY_ETAG
#define HTTP_QUERY_HOST                         WINHTTP_QUERY_HOST
#define HTTP_QUERY_IF_MATCH                     WINHTTP_QUERY_IF_MATCH
#define HTTP_QUERY_IF_NONE_MATCH                WINHTTP_QUERY_IF_NONE_MATCH
#define HTTP_QUERY_IF_RANGE                     WINHTTP_QUERY_IF_RANGE
#define HTTP_QUERY_IF_UNMODIFIED_SINCE          WINHTTP_QUERY_IF_UNMODIFIED_SINCE
#define HTTP_QUERY_MAX_FORWARDS                 WINHTTP_QUERY_MAX_FORWARDS
#define HTTP_QUERY_PROXY_AUTHORIZATION          WINHTTP_QUERY_PROXY_AUTHORIZATION
#define HTTP_QUERY_RANGE                        WINHTTP_QUERY_RANGE
#define HTTP_QUERY_TRANSFER_ENCODING            WINHTTP_QUERY_TRANSFER_ENCODING
#define HTTP_QUERY_UPGRADE                      WINHTTP_QUERY_UPGRADE
#define HTTP_QUERY_VARY                         WINHTTP_QUERY_VARY
#define HTTP_QUERY_VIA                          WINHTTP_QUERY_VIA
#define HTTP_QUERY_WARNING                      WINHTTP_QUERY_WARNING
#define HTTP_QUERY_EXPECT                       WINHTTP_QUERY_EXPECT
#define HTTP_QUERY_PROXY_CONNECTION             WINHTTP_QUERY_PROXY_CONNECTION
#define HTTP_QUERY_UNLESS_MODIFIED_SINCE        WINHTTP_QUERY_UNLESS_MODIFIED_SINCE
#define HTTP_QUERY_ECHO_REQUEST                 WINHTTP_QUERY_ECHO_REQUEST
#define HTTP_QUERY_ECHO_REPLY                   WINHTTP_QUERY_ECHO_REPLY
#define HTTP_QUERY_ECHO_HEADERS                 WINHTTP_QUERY_ECHO_HEADERS
#define HTTP_QUERY_ECHO_HEADERS_CRLF            WINHTTP_QUERY_ECHO_HEADERS_CRLF
#define HTTP_QUERY_PROXY_SUPPORT                WINHTTP_QUERY_PROXY_SUPPORT
#define HTTP_QUERY_AUTHENTICATION_INFO          WINHTTP_QUERY_AUTHENTICATION_INFO
#define HTTP_QUERY_MAX                          WINHTTP_QUERY_MAX
#define HTTP_QUERY_CUSTOM                       WINHTTP_QUERY_CUSTOM
#define HTTP_QUERY_FLAG_REQUEST_HEADERS         WINHTTP_QUERY_FLAG_REQUEST_HEADERS
#define HTTP_QUERY_FLAG_SYSTEMTIME              WINHTTP_QUERY_FLAG_SYSTEMTIME
#define HTTP_QUERY_FLAG_NUMBER                  WINHTTP_QUERY_FLAG_NUMBER

#define ERROR_INTERNET_FORCE_RETRY              ERROR_WINHTTP_RESEND_REQUEST
#define ERROR_HTTP_HEADER_NOT_FOUND             ERROR_WINHTTP_HEADER_NOT_FOUND
#define ERROR_INTERNET_CONNECTION_RESET         ERROR_WINHTTP_CONNECTION_ERROR


#define INTERNET_ERROR_BASE WINHTTP_ERROR_BASE

#define ERROR_INTERNET_INTERNAL_ERROR           (INTERNET_ERROR_BASE + 4)
#define ERROR_INTERNET_SEC_CERT_DATE_INVALID    (INTERNET_ERROR_BASE + 37)
#define ERROR_INTERNET_SEC_CERT_CN_INVALID      (INTERNET_ERROR_BASE + 38)
#define ERROR_INTERNET_INVALID_CA               (INTERNET_ERROR_BASE + 45)
#define ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP    (INTERNET_ERROR_BASE + 46)
#define ERROR_INTERNET_SEC_CERT_ERRORS          (INTERNET_ERROR_BASE + 55)
#define ERROR_INTERNET_SEC_CERT_NO_REV          (INTERNET_ERROR_BASE + 56)
#define ERROR_INTERNET_SEC_CERT_REV_FAILED      (INTERNET_ERROR_BASE + 57)
#define ERROR_INTERNET_SEC_INVALID_CERT         (INTERNET_ERROR_BASE + 169)
#define ERROR_INTERNET_SEC_CERT_REVOKED         (INTERNET_ERROR_BASE + 170)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\mmcexts\cleanup.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cleanup.cpp

Abstract:

    This file implements the BITS server extensions cleanup worker

--*/

#include "precomp.h"

const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per second

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
};

class CleanupWorker
{

public:
    CleanupWorker( HWND hwnd, const WCHAR* Path, const WCHAR *WorkItemName,
                   const WCHAR *GuidString );
    ~CleanupWorker();
    void DoIt();

private:

    HWND          m_hwnd;
    const WCHAR * m_Path;
    const WCHAR * m_WorkItemName;
    const WCHAR * m_GuidString;
    const WCHAR * m_ADSIPath;
    IADs        * m_VDir;
    BSTR          m_VDirPath;
    BSTR          m_SessionDirectory;
    BSTR          m_UNCUsername;
    BSTR          m_UNCPassword;
    UINT64        m_CleanupThreshold;
    
    VARIANT       m_vt;
    HANDLE        m_FindHandle;

    HANDLE        m_UserToken;

    WCHAR * BuildPath( const WCHAR * Dir, const WCHAR *Sub );
    BSTR    GetBSTRProp( BSTR PropName );
    void  LogonIfRequired();
    void PollKill();

    void RemoveConnectionsFromTree( 
        const WCHAR * DirectoryPath,
        bool IsConnectionDirectory );

    void RemoveConnection( const WCHAR * ConnectionDirectory );

};

CleanupWorker::CleanupWorker( 
    HWND hwnd, 
    const WCHAR* Path, 
    const WCHAR* WorkItemName,
    const WCHAR* GuidString ) :
m_hwnd( hwnd ),
m_Path( Path ),
m_WorkItemName( WorkItemName ),
m_GuidString( GuidString ),
m_ADSIPath( NULL ),
m_VDir( NULL ),
m_VDirPath( NULL ),
m_SessionDirectory( NULL ),
m_CleanupThreshold( 0 ),
m_UNCUsername( NULL ),
m_UNCPassword( NULL ),
m_UserToken( NULL )
{
    VariantInit( &m_vt );
}

CleanupWorker::~CleanupWorker()
{

    if ( m_UserToken )
        {
        SetThreadToken( NULL, NULL );
        CloseHandle( m_UserToken );
        }

    delete m_ADSIPath;
    SysFreeString( m_VDirPath );
    SysFreeString( m_SessionDirectory );
    SysFreeString( m_UNCUsername );
    SysFreeString( m_UNCPassword );
}


void 
CleanupWorker::RemoveConnection( const WCHAR * ConnectionDirectory )
{
   UINT64 LatestTime = 0; 
   HANDLE FindHandle = INVALID_HANDLE_VALUE;
   WCHAR *SearchPath = NULL;
   WCHAR *FileName   = NULL;

   try
   {

       SearchPath = BuildPath( ConnectionDirectory, L"*" );
       
       WIN32_FIND_DATA FindData;

       FindHandle =
            FindFirstFile(
                SearchPath,
                &FindData
                );

       if ( INVALID_HANDLE_VALUE == FindHandle )
           throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

       bool FoundFile = false;
       do
           {

           if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
               continue;

           FoundFile = true;
           UINT64 CreationTime      = FILETIMEToUINT64( FindData.ftCreationTime );
           UINT64 LastWriteTime     = FILETIMEToUINT64( FindData.ftLastWriteTime ); 
           LatestTime = max( LatestTime, max( CreationTime, LastWriteTime ) );
           }
       while ( FindNextFile( FindHandle, &FindData ) );

       FindClose( FindHandle );
       FindHandle = INVALID_HANDLE_VALUE;

       FILETIME ftCurrentTime;
       GetSystemTimeAsFileTime( &ftCurrentTime );
       UINT64 CurrentTime = FILETIMEToUINT64( ftCurrentTime );

       if ( FoundFile &&
            ( 0xFFFFFFFF - LatestTime > m_CleanupThreshold ) && 
            ( LatestTime + m_CleanupThreshold < CurrentTime ) )
           {
           
           FindHandle =
                FindFirstFile(
                    SearchPath,
                    &FindData
                    );

           if ( INVALID_HANDLE_VALUE == FindHandle )
               throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

           do
               {

               if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                   continue;

               FileName = BuildPath( ConnectionDirectory, FindData.cFileName );
               DeleteFile( FileName );

               delete FileName;
               FileName = NULL;

               }
           while ( FindNextFile( FindHandle, &FindData ) );

           FindClose( FindHandle );
           FindHandle = INVALID_HANDLE_VALUE;
                      
           }

       RemoveDirectory( ConnectionDirectory );
   }

   catch( ComError Error )
   {
       if ( INVALID_HANDLE_VALUE != FindHandle )
           FindClose( FindHandle );
       
       delete SearchPath;
       delete FileName;
       
       throw;
   }    

   if ( INVALID_HANDLE_VALUE != FindHandle )
       FindClose( FindHandle );

   delete SearchPath;
   delete FileName;

}


void 
CleanupWorker::RemoveConnectionsFromTree( 
    const WCHAR * DirectoryPath,
    bool IsConnectionDirectory )
{
    WCHAR *ConnectionDir    = NULL;
    HANDLE FindHandle       = INVALID_HANDLE_VALUE;
    WCHAR *SearchString     = NULL;
    WCHAR *NextSearchPath   = NULL;

    try
    {
        // Look for BITS-Sessions directory in connection tree

        SearchString = BuildPath( DirectoryPath, L"*" );
        
        WIN32_FIND_DATA FindData;


        FindHandle =
            FindFirstFile(
                SearchString,
                &FindData );


        if ( INVALID_HANDLE_VALUE == FindHandle )
            return;

        do
            {

            PollKill();

            if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                continue;

            if ( _wcsicmp( L".", FindData.cFileName ) == 0 )
                continue;

            if ( _wcsicmp( L"..", FindData.cFileName ) == 0 )
                continue;

            if ( IsConnectionDirectory )
                {

                GUID Guid;
                if (SUCCEEDED( IIDFromString( FindData.cFileName, &Guid ) ) )
                    {

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnection( NextSearchPath );

                    delete NextSearchPath;
                    NextSearchPath = NULL;
                    }

                }
            else
                {

                if ( _wcsicmp( m_SessionDirectory, FindData.cFileName ) == 0 )
                    {

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnectionsFromTree( NextSearchPath, true );

                    // Mark this as the connection directory so it
                    // will be closed after the search handles are closed.
                    ConnectionDir = NextSearchPath;
                    NextSearchPath = NULL;

                    }
                else
                    {

                    // just another directory to recurse into

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnectionsFromTree( NextSearchPath, false );

                    delete NextSearchPath;
                    NextSearchPath = NULL;

                    }

                }

                
            }
        while( FindNextFile( FindHandle, &FindData ) );

        if ( INVALID_HANDLE_VALUE != FindHandle )
            FindClose( FindHandle );
        delete SearchString;
        delete NextSearchPath;

        if ( ConnectionDir )
            {
            // The attempt to remove the directory will fail if 
            // the directory still has valid connections 
            RemoveDirectory( ConnectionDir );
            delete ConnectionDir;
            }

    }
    catch( ComError Error )
    {

        if ( INVALID_HANDLE_VALUE != FindHandle )
            FindClose( FindHandle );
        delete SearchString;
        delete NextSearchPath;
        delete ConnectionDir;

        throw;
    }

}

void 
CleanupWorker::PollKill()
{
    MSG msg;

    while( PeekMessage(
               &msg,
               m_hwnd,
               0,
               0,
               PM_REMOVE ) )
        {

        if ( WM_QUIT == msg.message )
            throw ComError( (HRESULT)msg.wParam );

        TranslateMessage( &msg );
        DispatchMessage( &msg );

        }

}

WCHAR * 
CleanupWorker::BuildPath( 
    const WCHAR *Dir, 
    const WCHAR *Sub )
{
    
    SIZE_T DirLen = wcslen( Dir );
    SIZE_T SubLen = wcslen( Sub );
    SIZE_T MaxStringSize = DirLen + SubLen + 2; // one slash, one terminator
    WCHAR *RetString = new WCHAR[ MaxStringSize ];

    if ( !RetString )
        throw ComError( E_OUTOFMEMORY );

    memcpy( RetString, Dir, sizeof(WCHAR) * (DirLen + 1) );
    WCHAR *p = RetString + DirLen;
    
    if ( p != RetString && *(p - 1) != L'\\' && *(p - 1) != L'/' )
        *p++ = L'\\';

    memcpy( p, Sub, sizeof(WCHAR) * ( SubLen + 1 ) );
    
    return RetString;
}

BSTR
CleanupWorker::GetBSTRProp( BSTR PropName )
{

  BSTR Retval;

  THROW_COMERROR( m_VDir->Get( PropName, &m_vt ) );
  THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BSTR ) );
  Retval = m_vt.bstrVal;
  m_vt.bstrVal = NULL;
  VariantClear( &m_vt );

  return Retval;

}

void
CleanupWorker::LogonIfRequired()
{

    // Don't logon if the path isn't a UNC path
    // or the user name is blank

    if ( ((WCHAR*)m_VDirPath)[0] != L'\\' ||
         ((WCHAR*)m_VDirPath)[1] != L'\\' ||
         *(WCHAR*)m_UNCUsername == L'\0' )
        return; // no logon required

    // crack the user name into a user and domain
    
    WCHAR *UserName     = (WCHAR*)m_UNCUsername;
    WCHAR *DomainName   = NULL;

    WCHAR *p = UserName;
    while(*p != L'\0')
    {
        if(*p == L'\\')
        {
            *p = L'\0';
            p++;
            //
            // first part is domain
            // second is user.
            //
            DomainName  = UserName;
            UserName    = p;
            break;
        }
        p++;
    }

    if ( !LogonUser(
            UserName,
            DomainName,
            (WCHAR*)m_UNCPassword,
            LOGON32_LOGON_BATCH,
            LOGON32_PROVIDER_DEFAULT,
            &m_UserToken ) )
        {

        if ( GetLastError() == ERROR_LOGON_TYPE_NOT_GRANTED )
            {


            if ( !LogonUser(
                    UserName,
                    DomainName,
                    (WCHAR*)m_UNCPassword,
                    LOGON32_LOGON_INTERACTIVE,
                    LOGON32_PROVIDER_DEFAULT,
                    &m_UserToken ) )
                {

                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

                }

             }

        }


    if ( !ImpersonateLoggedOnUser( m_UserToken ) )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

    
}

void 
CleanupWorker::DoIt()
{

    m_ADSIPath = ConvertObjectPathToADSI( m_Path );

    try
    {
        THROW_COMERROR( ADsGetObject( m_ADSIPath, __uuidof(*m_VDir), (void**)&m_VDir ) );

        if ( m_GuidString )
           {

           BSTR BSTRGuid = GetBSTRProp( (BSTR)L"BITSCleanupWorkItemKey" );
           int Result = wcscmp( (LPWSTR)BSTRGuid, m_GuidString );

           SysFreeString( BSTRGuid );

           if ( Result != 0 )
              throw ComError( E_ADS_UNKNOWN_OBJECT );

           }

    }
    catch( ComError Error )
    {
        
        if ( ( Error.m_Hr == E_ADS_UNKNOWN_OBJECT ) ||
			 ( Error.m_Hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) ||
          ( Error.m_Hr == E_ADS_PROPERTY_NOT_FOUND ) )
            {
            // Somehow the virtual directory was deleted, but the 
            // task scheduler work item wasn't.  Try to delete it now.

            ITaskScheduler *TaskScheduler;
            if ( SUCCEEDED( ConnectToTaskScheduler( NULL, &TaskScheduler ) ) )
                {
                TaskScheduler->Delete( m_WorkItemName );
                TaskScheduler->Release();
                }

            }

        throw;
    }

    THROW_COMERROR( m_VDir->Get( (BSTR)L"BITSUploadEnabled", &m_vt ) );
    THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BOOL ) );

    if ( !m_vt.boolVal ) // Uploads arn't enabled on this directory
        return;

    THROW_COMERROR( m_VDir->Get( (BSTR)L"BITSSessionTimeout", &m_vt ) );
    THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BSTR ) );

    if ( L'-' == *m_vt.bstrVal )
        return; // do not run cleanup in this directory since cleanup has been disabled 

    UINT64 CleanupSeconds;
    if ( 1 != swscanf( (WCHAR*)m_vt.bstrVal, L"%I64u", &CleanupSeconds ) )
        return;

    if (  CleanupSeconds > ( 0xFFFFFFFFFFFFFFFF / NanoSec100PerSec ) )
        m_CleanupThreshold = 0xFFFFFFFFFFFFFFFF; // overflow case
    else
        m_CleanupThreshold = CleanupSeconds * NanoSec100PerSec;

    m_VDirPath          = GetBSTRProp( (BSTR)L"Path" );
    m_SessionDirectory  = GetBSTRProp( (BSTR)L"BITSSessionDirectory" );
    m_UNCUsername       = GetBSTRProp( (BSTR)L"UNCUserName" );
    m_UNCPassword       = GetBSTRProp( (BSTR)L"UNCPassword" );

    LogonIfRequired();

    RemoveConnectionsFromTree( (WCHAR*)m_VDirPath, false );
}

void Cleanup_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow )
{
    int NumArgs;

    LPWSTR * CommandArgs =
        CommandLineToArgvW(
            lpszCmdLine,
            &NumArgs );

    if ( !CommandArgs )
        return;


    if ( FAILED( CoInitializeEx( NULL, COINIT_MULTITHREADED ) ) )
        return;

    if ( NumArgs != 2 && NumArgs != 3 )
        return;

    LPWSTR Path         = CommandArgs[0];
    LPWSTR WorkItemName = CommandArgs[1];
    LPWSTR GuidString   = NumArgs == 3 ? CommandArgs[2] : NULL;

    try
    {
        CleanupWorker Worker( hwndStub, Path, WorkItemName, GuidString );
        Worker.DoIt();
    }
    catch( ComError Error )
    {
    }

    CoUninitialize( );
    GlobalFree( CommandArgs );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cache.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cache.cpp

Abstract :

    Sources files for file cache management

Author :

Revision History :

 ***********************************************************************/


#include "stdafx.h"
#include <accctrl.h>
#include <aclapi.h>

#if !defined(BITS_V12_ON_NT4)
#include "cache.tmh"
#endif

BOOL
CProgressiveDL::OpenLocalDownloadFile(
    LPCTSTR Path,
    UINT64  Offset,
    UINT64  Size,
    FILETIME UrlModificationTime, // 0 if unknown
    FILETIME * pFileCreationTime
    )
{
    HANDLE hFile;

    bool bOpenExisting;

    if (Offset > 0)
        {
        // Storing the creation time via SetFileTime doesn't provide ironclad reliability due to granularity problems.
        // A tighter condition for a changed server file would be to check the "etag" header if available from the server.

        bOpenExisting = true;

        hFile = CreateFile( Path,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL );

        if (hFile == INVALID_HANDLE_VALUE )
            {
            DWORD dwError = GetLastError();
            LogError("error %!winerr!, opening '%S'", dwError, Path );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "CreateFile" );
            return FALSE;
            }

        LARGE_INTEGER liFileSize;

        if ( !GetFileSizeEx( hFile, &liFileSize ) )
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError("error %!winerr!, retrieving size of '%S'", dwError, Path );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "GetFileSizeEx" );
            return FALSE;
            }


        if ( Size != liFileSize.QuadPart )
            {

            CloseHandle( hFile );
            LogError("File size of '%S' changed", Path );
            m_pQMInfo->result = QM_SERVER_FILE_CHANGED;
            return FALSE;
            }

        LARGE_INTEGER liOffset;

        liOffset.QuadPart = Offset;

        if (!SetFilePointerEx( hFile,
                               liOffset,
                               NULL,        // don't need the new file pointer
                               FILE_BEGIN ))
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError("error %!winerr!, seeking to current position in '%S'", dwError, Path );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }

        }
    else
        {

        bOpenExisting = false;

        hFile = CreateFile( Path,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_HIDDEN,
                            NULL );

        if (hFile == INVALID_HANDLE_VALUE )
            {
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, GetLastError(), "CreateFile" );
            return FALSE;
            }

        // Reserve space for the file upfront.

        LARGE_INTEGER liOffset;
        liOffset.QuadPart = Size;

        if (!SetFilePointerEx( hFile,
                               liOffset,
                               NULL,
                               FILE_BEGIN ))
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError( "error %!winerr! setting end of file, out of disk space?", dwError );

            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }

        if ( !SetEndOfFile( hFile ) )
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError( "error %!winerr! setting end of file, out of disk space?", dwError );

            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }

        liOffset.QuadPart = 0;
        if (!SetFilePointerEx( hFile,
                               liOffset,
                               NULL,
                               FILE_BEGIN ))
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError( "error %!winerr! returning to the beginning of the file", dwError );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }


        if ( UrlModificationTime.dwHighDateTime ||
             UrlModificationTime.dwLowDateTime )
            {

            if (!SetFileTime( hFile, &UrlModificationTime, NULL, NULL ) )
                {
                DWORD dwError = GetLastError();
                CloseHandle( hFile );
                LogError( "error %!winerr! setting creation time", dwError );

                if (dwError == ERROR_INVALID_PARAMETER)
                    {
                    dwError = BG_E_INVALID_SERVER_RESPONSE;
                    }

                SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFileTime" );
                return FALSE;
                }

            }

        }

    if (!GetFileTime( hFile, pFileCreationTime, NULL, NULL ) )
        {

        DWORD dwError = GetLastError();
        CloseHandle( hFile );
        LogError( "error %!winerr!, unable to get file creation time", dwError );

        SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "GetFileTime" );
        return FALSE;
        }

    if ( bOpenExisting )
        {

        if ( UrlModificationTime.dwHighDateTime ||
             UrlModificationTime.dwLowDateTime )
            {

            if ( CompareFileTime( &UrlModificationTime, pFileCreationTime ) > 0 )
                {
                // UrlModificationTime is newer
                CloseHandle( hFile );
                LogError("File time of '%S' changed", Path );
                m_pQMInfo->result = QM_SERVER_FILE_CHANGED;
                return FALSE;
                }

            }

        }

    m_hFile = hFile;
    m_CurrentOffset = Offset;

    return TRUE;
}

BOOL CProgressiveDL::CloseLocalFile()
{

    if (m_hFile == INVALID_HANDLE_VALUE)
        {
        return FALSE;
        }

    CloseHandle( m_hFile );
    m_hFile = INVALID_HANDLE_VALUE;
    return TRUE;
}

BOOL
CProgressiveDL::WriteBlockToCache(
    LPBYTE lpBuffer,
    DWORD dwRead
    )
{
    DWORD dwWritten = 0;

    ASSERT( m_hFile != INVALID_HANDLE_VALUE );

    if (! WriteFile( m_hFile,
                     lpBuffer,
                     dwRead,
                     &dwWritten,
                     NULL)
        || (dwRead != dwWritten))
        {
        SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, GetLastError(), "WriteFile" );
        return FALSE;
        }

    m_CurrentOffset += dwWritten;

    return TRUE;
}

BOOL
CProgressiveDL::SetFileTimes()
{

    ASSERT( m_hFile != INVALID_HANDLE_VALUE );

    if ( !m_wupdinfo->UrlModificationTime.dwHighDateTime &&
         !m_wupdinfo->UrlModificationTime.dwLowDateTime )
        {
        LogWarning( "Server doesn't support modification times, can't set it on the files." );
        return TRUE;
        }

    if ( !SetFileTime( m_hFile,
                       &m_wupdinfo->UrlModificationTime,
                       &m_wupdinfo->UrlModificationTime,
                       &m_wupdinfo->UrlModificationTime ) )
        {
        DWORD dwError = GetLastError();
        LogError( "Unable to get times on the local file, error %!winerr!", dwError );
        SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFileTime" );
        return FALSE;
        }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\caddress.cpp ===
#include "stdafx.h"
#include "caddress.h"
#if !defined( BITS_V12_ON_NT4 )
#include "caddress.tmh"
#endif

CIpAddressMonitor::CIpAddressMonitor() :
    m_AddressCount( -1 ),
    m_ListenSocket( INVALID_SOCKET ),
    m_CallbackFn ( NULL ),
    m_CallbackArg( NULL )
{
    m_Overlapped.Internal = 0;

    WSADATA data;

    DWORD s = WSAStartup( MAKEWORD( 2, 0 ), &data );

    if (s)
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( s ));
        }

    THROW_HRESULT( CreateListenSocket() );
}

CIpAddressMonitor::~CIpAddressMonitor()
{
    CancelListen();

    if (m_ListenSocket != INVALID_SOCKET)
        {
        closesocket( m_ListenSocket );
        }

    WSACleanup();
}

HRESULT
CIpAddressMonitor::CreateListenSocket()
{
    //
    // Create an overlapped socket.
    //
    m_ListenSocket = WSASocket( AF_INET,
                                SOCK_STREAM,
                                IPPROTO_TCP,
                                NULL,           // no explicit protocol info
                                NULL,           // no group
                                WSA_FLAG_OVERLAPPED
                                );

    if (m_ListenSocket == INVALID_SOCKET)
        {
        return HRESULT_FROM_WIN32( WSAGetLastError() );
        }

    return S_OK;
}

bool
CIpAddressMonitor::IsListening()
{
    return (m_Overlapped.Internal == STATUS_PENDING);
}

long
CIpAddressMonitor::GetAddressCount()
{
    if (m_AddressCount == -1)
        {
        UpdateAddressCount();

        //  if this failed, m_AddressCount may still be -1.
        }
    return m_AddressCount;
}

HRESULT
CIpAddressMonitor::Listen(
    LISTEN_CALLBACK_FN fn,
    PVOID arg
    )
{
    LogInfo("begin listen");
    m_Mutex.Enter();

    //
    // Only one listen at a time.
    //
    if (IsListening())
        {
        m_Mutex.Leave();
        LogInfo("already listening");
        return S_FALSE;
        }

    if (m_ListenSocket == INVALID_SOCKET)
        {
        HRESULT hr = CreateListenSocket();

        if (FAILED(hr))
            {
            m_Mutex.Leave();
            LogInfo("failed %x", hr);
            return hr;
            }
        }

    //
    // Listen for address list changes.
    //
    DWORD bytes;
    if (SOCKET_ERROR == WSAIoctl( m_ListenSocket,
                                  SIO_ADDRESS_LIST_CHANGE,
                                  NULL,                 // no in buffer
                                  0,                    // no in buffer
                                  NULL,                 // no out buffer
                                  0,                    // no out buffer,
                                  &bytes,
                                  &m_Overlapped,
                                  CIpAddressMonitor::ListenCompletionRoutine
                                  ))
        {
        if (WSAGetLastError() != ERROR_IO_PENDING)
            {
            HRESULT HrError = HRESULT_FROM_WIN32( WSAGetLastError() );
            m_Mutex.Leave();
            LogInfo("failed %x", HrError);
            return HrError;
            }
        }

    //
    // Note our success.
    //
    m_CallbackFn = fn;
    m_CallbackArg = arg;

    m_Mutex.Leave();
    LogInfo("end listen");
    return S_OK;
}

void CALLBACK
CIpAddressMonitor::ListenCompletionRoutine(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    )
{
    CIpAddressMonitor * obj = CONTAINING_RECORD( lpOverlapped, CIpAddressMonitor, m_Overlapped );

    LogInfo("completion routine, object %p, err %d", obj, dwError );

    if (dwError == 0)
        {
        obj->m_Mutex.Enter();

        obj->UpdateAddressCount();

        PVOID arg = obj->m_CallbackArg;
        LISTEN_CALLBACK_FN fn = obj->m_CallbackFn;

        obj->m_Mutex.Leave();

        if (fn)
            {
            fn( arg );
            }
        }
}

void
CIpAddressMonitor::CancelListen()
{
    LogInfo("begin cancel");

    m_Mutex.Enter();

    if (!IsListening())
        {
        m_Mutex.Leave();
        LogInfo("no need to cancel");
        return;
        }

    //
    // Must wait for the I/O to be completed or aborted, since m_Overlapped
    // is written to in both cases.
    //
    CancelIo( HANDLE(m_ListenSocket) );

    long count = 0;
    while (m_Overlapped.Internal == STATUS_PENDING)
        {
        if (0 == (count % 100) )
            {
            LogInfo("waiting %d times...", count);
            }

        SleepEx( 1, TRUE );
        ++count;
        }

    closesocket( m_ListenSocket );
    m_ListenSocket = INVALID_SOCKET;

    m_Mutex.Leave();

    //
    // The overlapped operation is no longer pending, but the APC may still be queued.
    // Allow it to run.
    //
    SleepEx( 1, TRUE );

    LogInfo("end cancel");
}

HRESULT
CIpAddressMonitor::UpdateAddressCount()
{
    //
    // First call gets the required buffer size...
    //
    DWORD bytes;
    WSAIoctl( m_ListenSocket,
              SIO_ADDRESS_LIST_QUERY,
              NULL,                 // no in buffer
              0,                    // no in buffer
              NULL,                 // no out buffer
              0,                    // no out buffer,
              &bytes,
              NULL,                 // no OVERLAPPED
              NULL                  // no completion routine
              );

    if (WSAGetLastError() != WSAEFAULT)
        {
        m_AddressCount = -1;
        return HRESULT_FROM_WIN32( WSAGetLastError());
        }

    auto_ptr<char> Buffer;

    try
        {
        Buffer = auto_ptr<char>( new char[ bytes ] );
        }
    catch( ComError Error )
        {
        return Error.Error();
        }

    SOCKET_ADDRESS_LIST * List = reinterpret_cast<SOCKET_ADDRESS_LIST *>(Buffer.get());

    //
    // ...second call gets the data.
    //
    if (SOCKET_ERROR == WSAIoctl( m_ListenSocket,
                                  SIO_ADDRESS_LIST_QUERY,
                                  NULL,
                                  0,
                                  List,
                                  bytes,
                                  &bytes,
                                  NULL,
                                  NULL
                                  ))
        {
        m_AddressCount = -1;
        return HRESULT_FROM_WIN32( WSAGetLastError());
        }

    m_AddressCount = List->iAddressCount;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\caddress.h ===
#pragma once

#include "winsock2.h"
#include <stllock.h>

class CIpAddressMonitor
/*

    This is a class to monitor the number of active networks on the local machine.
    It does so by using the Winsock 2.0 SIO_ADDRESS_LIST_CHANGE ioctl.  Currently it
    only monitors IP addresses, but it could monitor other networks that conform to
    the Winsock model.

*/
{
public:

    CIpAddressMonitor();
    ~CIpAddressMonitor();

    typedef void (CALLBACK * LISTEN_CALLBACK_FN)( PVOID arg );

    HRESULT
    Listen(
        LISTEN_CALLBACK_FN fn,
        PVOID              arg
        );

    void     CancelListen();

    bool     IsListening();

    long     GetAddressCount();

protected:

    CCritSec    m_Mutex;

    long        m_AddressCount;

    SOCKET      m_ListenSocket;

    OVERLAPPED  m_Overlapped;

    LISTEN_CALLBACK_FN m_CallbackFn;
    PVOID       m_CallbackArg;

    //--------------------------------------------------------------------

    HRESULT CreateListenSocket();

    HRESULT UpdateAddressCount();

    static void CALLBACK
    ListenCompletionRoutine(
        IN DWORD dwError,
        IN DWORD cbTransferred,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN DWORD dwFlags
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\ccred.h ===
#include <wincrypt.h>
#include <map>

//
// abstraction of CryptEncodeBlob/CryptDecodeBlob
//

class CEncryptedBlob
{
public:

    CEncryptedBlob(
        void *  Buffer,
        size_t  Length,
        LPCWSTR Description
        );

    CEncryptedBlob();

    //
    // used when unserializing
    //
    ~CEncryptedBlob();

    size_t GetLength()
    {
        return m_Length;
    }

    void
    Decrypt(
        void * Buffer,
        size_t Length
        );

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );

protected:

    DATA_BLOB       m_Blob;
    size_t          m_Length;

};

class CEncryptedCredentials
{
public:

    CEncryptedCredentials( const BG_AUTH_CREDENTIALS & cred );
    ~CEncryptedCredentials();

    //
    // used by unserialize
    //
    CEncryptedCredentials()
    {
        m_Blob = 0;
    }

    BG_AUTH_CREDENTIALS * Decrypt();

    void Serialize( HANDLE hFile )
    {
        if (m_Blob)
            {
            SafeWriteFile( hFile, true );
            m_Blob->Serialize( hFile );
            }
        else
            {
            SafeWriteFile( hFile, false );
            }
    }

    void Unserialize( HANDLE hFile )
    {
        bool b;

        SafeReadFile( hFile, &b );

        if (b)
            {
            m_Blob = new CEncryptedBlob;
            m_Blob->Unserialize( hFile );
            }
    }

protected:

    CEncryptedBlob * m_Blob;

};


//
// a set of (encrypted) credentials
//
class CCredentialsContainer
{
    typedef DWORD KEY;

    typedef std::map<KEY, CEncryptedCredentials *> Dictionary;

public:

    typedef Dictionary::iterator Cookie;

    CCredentialsContainer();
    ~CCredentialsContainer();

    void Clear();

    HRESULT Update( const BG_AUTH_CREDENTIALS * Credentials );

    HRESULT Remove( BG_AUTH_TARGET Target, BG_AUTH_SCHEME Scheme );

    size_t GetSizeEstimate( const BG_AUTH_CREDENTIALS * Credentials ) const;

    HRESULT Find( BG_AUTH_TARGET Target, BG_AUTH_SCHEME Scheme, BG_AUTH_CREDENTIALS ** pCredentials ) const;

    BG_AUTH_CREDENTIALS * FindFirst( Cookie & cookie ) const throw( ComError );
    BG_AUTH_CREDENTIALS * FindNext( Cookie & cookie ) const throw( ComError );

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );

protected:

    Dictionary m_Dictionary;

    //--------------------------------------------------------------------

    inline KEY MakeKey( BG_AUTH_TARGET Target, BG_AUTH_SCHEME Scheme ) const
    {
        return (WORD(Scheme) << 16) | WORD(Target);
    }
};

HRESULT
ValidateCredentials(
    BG_AUTH_CREDENTIALS * cred
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\ccred.cpp ===
#include "stdafx.h"

LPCWSTR g_CredentialBlobDescription = L"BITS job credentials";

//------------------------------------------------------------------------

CEncryptedBlob::CEncryptedBlob(
    void *  Buffer,
    size_t  Length,
    LPCWSTR Description
    )
    : m_Length( Length )
{
    m_Blob.pbData = 0;
    m_Blob.cbData = 0;

    DATA_BLOB blobIn;
    blobIn.pbData = reinterpret_cast<BYTE *>( Buffer );
    blobIn.cbData = Length;

    // Encrypt the data.

    if (!CryptProtectData( &blobIn,
                           Description,
                           NULL,
                           NULL,
                           NULL,
                           CRYPTPROTECT_UI_FORBIDDEN,
                           &m_Blob))
        {
        ThrowLastError();
        }
}

CEncryptedBlob::CEncryptedBlob()
{
    m_Length = 0;
    m_Blob.cbData = 0;
    m_Blob.pbData = 0;
}

CEncryptedBlob::~CEncryptedBlob()
{
    if (m_Blob.pbData)
        {
        LocalFree( m_Blob.pbData );
        }
}

void
CEncryptedBlob::Decrypt(
    void * Buffer,
    size_t Length
    )
{
    if (Length < m_Length)
        {
        THROW_HRESULT( E_INVALIDARG );
        }

    DATA_BLOB blobOut;

    // Decrypt the data.

    if (!CryptUnprotectData( &m_Blob,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             CRYPTPROTECT_UI_FORBIDDEN,
                             &blobOut))
        {
        ThrowLastError();
        }

    ASSERT( blobOut.cbData == Length );

    memcpy( Buffer, blobOut.pbData, Length );

    LocalFree( blobOut.pbData );
}

void CEncryptedBlob::Serialize( HANDLE hFile )
{
    SafeWriteFile( hFile, m_Length );
    SafeWriteFile( hFile, m_Blob.cbData );
    SafeWriteFile( hFile, m_Blob.pbData, m_Blob.cbData );
}

void CEncryptedBlob::Unserialize( HANDLE hFile )
{
    SafeReadFile( hFile, &m_Length );
    SafeReadFile( hFile, &m_Blob.cbData );

    m_Blob.pbData = static_cast<BYTE *> (LocalAlloc( LMEM_FIXED, m_Blob.cbData ));
    if (m_Blob.pbData == NULL)
        {
        throw ComError( E_OUTOFMEMORY );
        }

    SafeReadFile( hFile, m_Blob.pbData, m_Blob.cbData );
}

//------------------------------------------------------------------------

CEncryptedCredentials::CEncryptedCredentials( const BG_AUTH_CREDENTIALS & cred )
{
    size_t Length = CAuthCredentialsMarshaller::Size( &cred );

    auto_ptr<char> Buffer( new char[ Length ] );

    CMarshalCursor Cursor( Buffer.get(), Length );

    CAuthCredentialsMarshaller m1( Cursor, &cred );

    m_Blob = new CEncryptedBlob( Buffer.get(), Length, g_CredentialBlobDescription );
}

CEncryptedCredentials::~CEncryptedCredentials()
{
    delete m_Blob;
}

BG_AUTH_CREDENTIALS * CEncryptedCredentials::Decrypt()
{
    BG_AUTH_CREDENTIALS * cred = 0;

    size_t Length = m_Blob->GetLength();
    auto_ptr<char> Buffer( new char[ Length ] );

    m_Blob->Decrypt( Buffer.get(), Length );

    CMarshalCursor Cursor( Buffer.get(), Length );

    CAuthCredentialsUnmarshaller m1( Cursor, &cred );

    return cred;
}

//------------------------------------------------------------------------

CCredentialsContainer::CCredentialsContainer()
{
}

CCredentialsContainer::~CCredentialsContainer()
{
    Clear();
}

void
CCredentialsContainer::Clear()
{
    Dictionary::iterator iter;

    //
    // Keep deleting the first element until the map is empty.
    //
    while (iter = m_Dictionary.begin(), (iter != m_Dictionary.end()))
        {
        CEncryptedCredentials * cred = iter->second;

        m_Dictionary.erase( iter );

        delete cred;
        }
}

HRESULT
CCredentialsContainer::Update(
    const BG_AUTH_CREDENTIALS * Credentials
    )
{
    try
        {
        KEY Key = MakeKey( Credentials->Target, Credentials->Scheme );

        CEncryptedCredentials * OldCredentials = m_Dictionary[ Key ];
        auto_ptr<CEncryptedCredentials> NewCredentials(new CEncryptedCredentials( *Credentials ));

        m_Dictionary[ Key ] = NewCredentials.get();

        NewCredentials.release();
        delete OldCredentials;

        return S_OK;
        }
    catch( ComError err )
        {
        return err.Error();
        }
}

HRESULT
CCredentialsContainer::Remove(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme
    )
{
    try
        {
        KEY Key = MakeKey( Target, Scheme );

        CEncryptedCredentials * OldCredentials = m_Dictionary[ Key ];

        m_Dictionary[ Key ] = 0;

        delete OldCredentials;

        if (OldCredentials == NULL)
            {
            return S_FALSE;
            }

        return S_OK;
        }
    catch( ComError err )
        {
        return err.Error();
        }
}

size_t CCredentialsContainer::GetSizeEstimate(
    const BG_AUTH_CREDENTIALS * Credentials
    ) const
{
    const Overhead = 1000;

    //
    // accurate sizing is expensive, so do something cheap and conservative.
    //

    size_t Size = Overhead;

    Size += CUnicodeStringMarshaller::Size( Credentials->Credentials.Basic.UserName );
    Size += CUnicodeStringMarshaller::Size( Credentials->Credentials.Basic.Password );

    return Size;
}

HRESULT CCredentialsContainer::Find(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme,
    BG_AUTH_CREDENTIALS ** pCredentials
    ) const
{
    *pCredentials = 0;

    KEY Key = MakeKey( Target, Scheme );

    try
        {
        // This is what we want, except that it doesn't work on a const container:
        // CEncryptedCredentials * cred = m_Dictionary[ Key ];

        CEncryptedCredentials * cred = 0;

        Dictionary::iterator iter = m_Dictionary.find( Key );

        if (iter != m_Dictionary.end())
            {
            cred = iter->second;
            }

        if (!cred)
            {
            return S_FALSE;
            }

        *pCredentials = cred->Decrypt();
        return S_OK;
        }
    catch( ComError err )
        {
        return err.Error();
        }
}

BG_AUTH_CREDENTIALS * CCredentialsContainer::FindFirst( Cookie & cookie ) const
{
    cookie = m_Dictionary.begin();
    return FindNext( cookie );
}

BG_AUTH_CREDENTIALS * CCredentialsContainer::FindNext( Cookie & cookie ) const
{
    while (cookie != m_Dictionary.end() && cookie->second == NULL)
        {
        ++cookie;
        }

    if (cookie == m_Dictionary.end())
        {
        return NULL;
        }

    CEncryptedCredentials * EncryptedCredentials = cookie->second;

    BG_AUTH_CREDENTIALS * Credentials = EncryptedCredentials->Decrypt();

    ++cookie;
    return Credentials;
}

void
CCredentialsContainer::Serialize( HANDLE hFile )
{
    Dictionary::iterator iter;

    long count = 0;

    for ( iter = m_Dictionary.begin(); iter != m_Dictionary.end(); ++iter)
        {
        KEY Key = iter->first;
        CEncryptedCredentials * cred = iter->second;

        if (cred)
            {
            count++;
            }
        }

    SafeWriteFile( hFile, count );

    for ( iter = m_Dictionary.begin(); iter != m_Dictionary.end(); ++iter)
        {
        KEY Key = iter->first;
        CEncryptedCredentials * cred = iter->second;

        if (!cred)
            {
            continue;
            }

        SafeWriteFile( hFile, Key );
        cred->Serialize( hFile );
        }
}

void
CCredentialsContainer::Unserialize( HANDLE hFile )
{
    long count;

    SafeReadFile( hFile, &count );

    while (count-- > 0)
        {
        KEY Key;
        auto_ptr<CEncryptedCredentials> cred( new CEncryptedCredentials );

        SafeReadFile( hFile, &Key );
        cred->Unserialize( hFile );

        m_Dictionary[ Key ] = cred.get();

        cred.release();
        }
}


HRESULT
ValidateCredentials(
    BG_AUTH_CREDENTIALS * cred
    )
{
    if (cred->Target != BG_AUTH_TARGET_SERVER &&
        cred->Target != BG_AUTH_TARGET_PROXY)
        {
        return BG_E_INVALID_AUTH_TARGET;
        }

    switch (cred->Scheme)
        {
        case BG_AUTH_SCHEME_BASIC:
        case BG_AUTH_SCHEME_DIGEST:
        case BG_AUTH_SCHEME_NTLM:
        case BG_AUTH_SCHEME_NEGOTIATE:
        case BG_AUTH_SCHEME_PASSPORT:
            {
            if (cred->Credentials.Basic.UserName && wcslen(cred->Credentials.Basic.UserName) > MAX_USERNAME)
                {
                return BG_E_USERNAME_TOO_LARGE;
                }

            if (cred->Credentials.Basic.Password && wcslen(cred->Credentials.Basic.Password) > MAX_PASSWORD)
                {
                return BG_E_PASSWORD_TOO_LARGE;
                }

            return S_OK;
            }

        default:
            return BG_E_INVALID_AUTH_SCHEME;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cenum.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cenum.cpp

Abstract :

    CPP files to enumeration abstraction.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#if !defined( BITS_V12_ON_NT4 )
#include "cenum.tmh"
#endif

#define MAGIC_ACTIVE    0x44446666
#define MAGIC_INACTIVE  0x55553333

template<class B, class T, class P>
CEnum<B,T,P>::CEnum() :
m_CurrentIndex(0),
    m_magic( MAGIC_ACTIVE )
{
    memset( m_stack, 0, sizeof(m_stack) );
}

template<class B, class T, class P>
HRESULT
CEnum<B,T,P>::NextInternal(
    ULONG   celt,
    T       rgelt[],
    ULONG * pceltFetched
    )
{
    CheckMagicValue();

    ULONG i;
    HRESULT Hr = S_OK;

    CAutoExclusiveLock LockHolder(m_mutex);

    LogPublicApiBegin( "celt %u, rgelt %p, pceltFetched %p", celt, rgelt, pceltFetched );

    ULONG Fetched = 0;

    try
    {
        for (unsigned int c=0; c<celt; c++)
            m_ItemPolicy.Init( rgelt[c] );

        if ( !pceltFetched && (1 != celt) )
            {
            LogWarning("Return count pointer is NULL, but requested count isn't 1" );
            throw ComError( E_INVALIDARG );
            }

        for (i=0; ( i < celt ) && ( m_CurrentIndex < m_items.size() ); i++, m_CurrentIndex++)
            {

            m_ItemPolicy.Copy( rgelt[i], m_items[m_CurrentIndex] );

            Fetched++;
            }

        if ( pceltFetched )
            {
            *pceltFetched = Fetched;
            }

        if ( Fetched != celt )
            {
            Hr = S_FALSE;
            }
    }

    catch ( ComError exception )
        {
        Hr = exception.Error();
        }

    LogPublicApiEnd( "celt %u, rgelt %p, pceltFetched %p(%u)", celt, rgelt, pceltFetched, pceltFetched ? *pceltFetched : 1 );

    return Hr;
}

template<class B, class T, class P>
HRESULT
CEnum<B,T,P>::CloneInternal(
    B **ppEnum
    )
{
    CheckMagicValue();

    HRESULT Hr = S_OK;
    CEnum<B,T,P> * pEnum = NULL;

    CAutoExclusiveLock LockHolder( m_mutex );

    LogPublicApiBegin( "ppEnum %p", ppEnum );

    try
        {
        pEnum = new CEnum<B,T,P>;

        for (CItemList::iterator iter = m_items.begin(); iter != m_items.end(); ++iter)
            {
            pEnum->Add( *iter );
            }

        pEnum->m_CurrentIndex = m_CurrentIndex;
        }
    catch ( ComError exception )
        {
        delete pEnum;
        pEnum = NULL;

        Hr = exception.Error();
        }

    *ppEnum = pEnum;

    LogPublicApiEnd( "ppEnum %p(%p)", ppEnum, *ppEnum );

    return Hr;

}

template<class B, class T, class P>
void
CEnum<B, T,P>::Add(
    T item
    )
{
    CheckMagicValue();

    CAutoExclusiveLock LockHolder( m_mutex );

    T MyItem;

    try
        {
        m_ItemPolicy.Copy( MyItem, item );
        m_items.push_back( MyItem );
        }
    catch( ComError Error )
        {
        m_ItemPolicy.Destroy( MyItem );
        throw;
        }
}

template<class B, class T, class P>
HRESULT
CEnum<B,T,P>::GetCountInternal(
    ULONG * pCount
    )
{
    CheckMagicValue();

    HRESULT Hr = S_OK;

    CAutoSharedLock LockHolder( m_mutex );

    LogPublicApiBegin( "pCount %p", pCount );

    *pCount = m_items.size();

    LogPublicApiEnd( "pCount %p(%u)", pCount, *pCount );
    return Hr;
}

template<class B, class T, class P>
HRESULT
CEnum<B, T, P>::ResetInternal()
{
    CheckMagicValue();

    HRESULT Hr = S_OK;

    CAutoExclusiveLock LockHolder( m_mutex );

    LogPublicApiBegin( " " );

    m_CurrentIndex = 0;

    LogPublicApiEnd( " " );
    return Hr;
}

template<class B, class T, class P>
HRESULT
CEnum<B, T, P>::SkipInternal(
    ULONG celt
    )
{
    CheckMagicValue();

    HRESULT Hr = S_OK;

    CAutoExclusiveLock LockHolder( m_mutex );

    LogPublicApiBegin( "celt %u", celt );

    while(celt)
        {
        if ( m_CurrentIndex >= m_items.size() )
            break; // Hit the end of the list
        m_CurrentIndex++;
        --celt;
        }

    if (celt)
        {
        LogWarning( "Attempt to skip too many elements." );
        Hr = S_FALSE;
        }

    LogPublicApiEnd(  "celt %u", celt );

    return Hr;
}

template<class B, class T, class P>
CEnum<B,T,P>::~CEnum()
{
    CheckMagicValue();

    m_magic = MAGIC_INACTIVE;

    for (CItemList::const_iterator iter = m_items.begin(); iter != m_items.end(); ++iter)
        {
        T Item = (*iter);
        m_ItemPolicy.Destroy( Item );
        }
}

template<class B, class T, class P>
void CEnum<B,T,P>::CheckMagicValue()
{
    ASSERT( m_magic == MAGIC_ACTIVE );
}


CEnumJobs::CEnumJobs() :
    CEnumInterface<IEnumBackgroundCopyJobs,IBackgroundCopyJob>()
{}

CEnumFiles::CEnumFiles() :
    CEnumInterface<IEnumBackgroundCopyFiles,IBackgroundCopyFile>()
{}


CEnumOldGroups::CEnumOldGroups() :
    CEnumItem<IEnumBackgroundCopyGroups,GUID>( )
{}

CEnumOldJobs::CEnumOldJobs() :
    CEnumItem<IEnumBackgroundCopyJobs1,GUID>( )
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cenum.h ===
template<class B, class T, class P>
class CEnum : public CSimpleExternalIUnknown<B>
{
public:

    // External callable methods

    // IEnum methods

    HRESULT STDMETHODCALLTYPE NextInternal(
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ T rgelt[],
        /* [out] */ ULONG *pceltFetched);

    HRESULT STDMETHODCALLTYPE Next(
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ T rgelt[],
        /* [out] */ ULONG *pceltFetched)
    {
        EXTERNAL_FUNC_WRAP( NextInternal( celt, rgelt, pceltFetched ) )
    }


    HRESULT STDMETHODCALLTYPE SkipInternal(
        /* [in] */ ULONG celt);

    HRESULT STDMETHODCALLTYPE Skip(
        /* [in] */ ULONG celt)
    {
        EXTERNAL_FUNC_WRAP( SkipInternal( celt ) )
    }

    HRESULT STDMETHODCALLTYPE ResetInternal( void );

    HRESULT STDMETHODCALLTYPE Reset( void )
    {
        EXTERNAL_FUNC_WRAP( ResetInternal() )
    }

    HRESULT STDMETHODCALLTYPE CloneInternal(
        /* [out] */ B **ppenum);

    HRESULT STDMETHODCALLTYPE Clone(
        /* [out] */ B **ppenum)
    {
        EXTERNAL_FUNC_WRAP( CloneInternal( ppenum ) )
    }

    HRESULT STDMETHODCALLTYPE GetCountInternal(
        /* [out] */ ULONG *puCount);

    HRESULT STDMETHODCALLTYPE GetCount(
        /* [out] */ ULONG *puCount)
    {
        EXTERNAL_FUNC_WRAP( GetCountInternal( puCount ) )
    }

    // other methods

    void CheckMagicValue();

    // internal methods

    CEnum();

    void
    Add(
        T Item
        );

protected:

    virtual ~CEnum();

    typedef vector<T> CItemList;

    DWORD       m_magic;
    PVOID       m_stack[4];

    CSharedLock m_mutex;
    CItemList   m_items;
    typename CItemList::size_type   m_CurrentIndex;
    P           m_ItemPolicy;

};

template <class T>
class CEnumIterfaceCopyPolicy
{
public:
    void Init(T * & InitItem ) { InitItem = NULL; }
    void Copy(T * & DestItem, T * SourceItem )
    {
        DestItem = SourceItem;
        DestItem->AddRef();
    }
    void Destroy(T * & DestroyItem )
    {
        DestroyItem->Release();
        Init( DestroyItem );
    }
};

template <class T>
class CEnumItemCopyPolicy
{
public:
    void Init(T & InitItem ) { memset( &InitItem, 0, sizeof(InitItem) ); }
    void Copy(T & DestItem, T SourceItem ) { DestItem = SourceItem; }
    void Destroy(T & DestroyItem ) { Init( DestroyItem ); }
};

template< class B, class T >
class CEnumInterface : public CEnum<B,T*,CEnumIterfaceCopyPolicy<T> >
{
};


template< class B, class T>
class CEnumItem : public CEnum<B,T,CEnumItemCopyPolicy<T> >
{
};


class CEnumJobs : public CEnumInterface<IEnumBackgroundCopyJobs,IBackgroundCopyJob>
{
public:
    CEnumJobs();
};

class CEnumFiles : public CEnumInterface<IEnumBackgroundCopyFiles,IBackgroundCopyFile>
{
public:
    CEnumFiles();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cfile.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.cpp

Abstract :

    Main code file for handling jobs and files.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#if !defined(BITS_V12_ON_NT4)
#include "cfile.tmh"
#endif

//------------------------------------------------------------------------

StringHandle
BITSGetVolumePathName(
    const WCHAR * FileName )
{

#if defined( BITS_V12_ON_NT4 )

    WCHAR VolumePath[4];

    if ( !(
             ( FileName[0] >= L'A' && FileName[0] <= L'Z') ||
             ( FileName[0] >= L'a' && FileName[0] <= L'z')
          ) ||
         ( FileName[1] != L':' ) ||
         ( FileName[2] != L'\\' ) )
        {
        LogError( "%s doesn't appear to start with a drive letter", FileName );
        throw ComError( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) );
        }

    VolumePath[0] = FileName[0];
    VolumePath[1] = FileName[1];
    VolumePath[2] = FileName[2];
    VolumePath[3] = '\0';

    return StringHandle( VolumePath );

#else

    // Call get full path name to get the
    // required buffer size

    DWORD dwBufferLength =
        GetFullPathName(
            FileName,
            0,
            NULL,
            NULL );

    if ( !dwBufferLength )
        {
        DWORD dwError = GetLastError();
        LogError( "GetFullPathName failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    auto_ptr<WCHAR> VolumePathName( new WCHAR[ dwBufferLength + 1 ] );

    BOOL bResult =
        GetVolumePathName(
            FileName,
            VolumePathName.get(),
            dwBufferLength + 1 );

    if ( !bResult )
        {
        DWORD dwError = GetLastError();
        LogError( "GetVolumePathName failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    return StringHandle( VolumePathName.get() );

#endif

}

StringHandle
BITSGetVolumeNameForVolumeMountPoint(
    const WCHAR * VolumeMountPoint )
{

#if defined( BITS_V12_ON_NT4 )

    return BITSGetVolumePathName( VolumeMountPoint );

#else

    WCHAR VolumeName[50]; // 50 is listed in MSDN

    BOOL bResult =
        GetVolumeNameForVolumeMountPoint(
            VolumeMountPoint,
            VolumeName,
            50 );

    if ( !bResult )
        {
        DWORD dwError = GetLastError();
        LogError( "GetVolumeNameForVolumeMountPoint failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    return StringHandle( VolumeName );

#endif

}

DWORD
BITSGetVolumeSerialNumber(
    const WCHAR * VolumePath )
{
    DWORD VolumeSerialNumber;

    BOOL bResult =
        GetVolumeInformation(
            VolumePath,                 // root directory
            NULL,                       // volume name buffer
            0,                          // length of name buffer
            &VolumeSerialNumber,        // volume serial number
            NULL,                       // maximum file name length
            NULL,                       // file system options
            NULL,                       // file system name buffer
            0                           // length of file system name buffer
            );

    if ( !bResult )
        {
        DWORD dwError = GetLastError();
        LogError( "GetVolumeInformation failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    return VolumeSerialNumber;

}

StringHandle
BITSGetTempFileName(
    const WCHAR *PathName,
    const WCHAR *Prefix,
    UINT Unique )
{

    auto_ptr<WCHAR> TempBuffer( new WCHAR[MAX_PATH+1] );

    UINT Result =
        GetTempFileName(
            PathName,
            Prefix,
            Unique,
            TempBuffer.get() );

    if ( !Result )
        {
        DWORD dwError = GetLastError();
        LogError( "GetTempFileName( '%S', '%S' ) failed, error %!winerr!", PathName, Prefix, dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    StringHandle ReturnVal;

    try
    {
        ReturnVal = TempBuffer.get();
    }
    catch( ComError Error )
    {
        LogError( "Out of memory returning temp filename, deleting temp file" );
        DeleteFile( TempBuffer.get() );
        throw;
    }

    return ReturnVal;
}

StringHandle
BITSCrackFileName(
    const WCHAR * RawFileName,
    StringHandle & ReturnFileName )
{

    DWORD FullPathSize =
        GetFullPathName( RawFileName,
                         0,
                         NULL,
                         NULL );

    DWORD dwAllocSize = FullPathSize;
    if ( !FullPathSize )
        {
        DWORD dwError = GetLastError();
        LogError( "GetFullPathName failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    if ( FullPathSize > MAX_PATH )
        {
        // Fail large paths until the code can be cleanup up
        LogError( "Path larger then MAX_PATH, failing" );
        throw ComError( E_INVALIDARG );
        }

    auto_ptr<WCHAR> FullPath( new WCHAR[ dwAllocSize ] );

    WCHAR *FilePointer = NULL;
    FullPathSize =
        GetFullPathName( RawFileName,
                         dwAllocSize,
                         FullPath.get(),
                         &FilePointer
                         );

    if (FullPathSize == 0 ||
        FullPathSize > dwAllocSize)
        {
        LogError( "GetFullPathName failed " );
        throw ComError( E_INVALIDARG );
        }

    if ( !FilePointer ||
         (*FilePointer == L'\0') ||
         (FilePointer == FullPath.get()))
        {
        throw ComError( E_INVALIDARG );
        }

    auto_ptr<WCHAR> DirectoryName( new WCHAR[ dwAllocSize ] );
    auto_ptr<WCHAR> FileName( new WCHAR[ dwAllocSize ] );

    memcpy( DirectoryName.get(), FullPath.get(), (char*)FilePointer - (char*)FullPath.get() );
    (DirectoryName.get())[ ((char*)FilePointer - (char*)FullPath.get()) / sizeof(WCHAR) ] = L'\0';

    THROW_HRESULT( StringCchCopy( FileName.get(), dwAllocSize, FilePointer ));

    FilePointer = NULL;

    ReturnFileName = FileName.get();
    return StringHandle( DirectoryName.get() );

}

StringHandle
BITSCreateTempFile(
    StringHandle Directory
    )
{
    StringHandle TempFileName;

    TempFileName = BITSGetTempFileName( Directory, L"BITS", 0 ); //throw ComError

    //
    // Make sure the client can create the temp file.
    //
    HANDLE hFile;

    hFile = CreateFile( TempFileName,
                        GENERIC_WRITE,
                        0,                              // no file sharing
                        NULL,                           // generic security descriptor
                        CREATE_ALWAYS,
                        FILE_FLAG_WRITE_THROUGH | FILE_ATTRIBUTE_HIDDEN,
                        NULL                            // no template file
                        );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        ThrowLastError();
        }

    CloseHandle( hFile );

    return TempFileName;
}


HRESULT
BITSCheckFileWritability(
    LPCWSTR name
    )
{
    HANDLE hFile;
    hFile = CreateFile( name,
                        GENERIC_WRITE,
                        0,                              // no file sharing
                        NULL,                           // generic security descriptor
                        OPEN_EXISTING,
                        0,
                        NULL                            // no template file
                        );

    if (hFile == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (hFile != INVALID_HANDLE_VALUE)
        {
        if (GetFileType( hFile ) != FILE_TYPE_DISK)
            {
            CloseHandle( hFile );
            return E_INVALIDARG;
            }

        CloseHandle( hFile );
        }

    return S_OK;
}
HRESULT
BITSCheckFileReadability(
    LPCWSTR name
    )
{
    HANDLE hFile;
    hFile = CreateFile( name,
                        GENERIC_READ,
                        FILE_SHARE_READ,      // no file sharing
                        NULL,                           // generic security descriptor
                        OPEN_EXISTING,
                        0,
                        NULL                            // no template file
                        );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (GetFileType( hFile ) != FILE_TYPE_DISK)
        {
        CloseHandle( hFile );
        return E_INVALIDARG;
        }

    CloseHandle( hFile );
    return S_OK;
}

CFile::CFile(
    CJob*   Job,
    BG_JOB_TYPE FileType,
    StringHandle RemoteName,
    StringHandle LocalName
    )
{
    m_Job = Job;
    m_RemoteName = RemoteName;
    m_LocalName = LocalName;
    m_BytesTransferred = 0;
    m_BytesTotal = BG_SIZE_UNKNOWN;
    m_Completed = false;

    if (!VerifyRemoteName( RemoteName ))
        {
        throw ComError( E_INVALIDARG );
        }

    HRESULT hr = VerifyLocalName( LocalName, FileType );
    if (FAILED(hr))
        {
        throw ComError( hr );
        }
}

// private constructor used during unserialization
// It initializes only the transient data.
CFile::CFile(
    CJob*   Job
    )
{
    m_Job = Job;
    m_BytesTotal = 0;
    m_BytesTransferred = 0;
    m_Completed = false;
}

CFile::~CFile()
{
}

//----------------------------------------------

CFileExternal *
CFile::CreateExternalInterface()
{
    return new CFileExternal( this, m_Job->GetExternalInterface() );
}

HRESULT
CFile::GetLocalName(
    LPWSTR *pVal
    ) const
{
    *pVal = MidlCopyString( m_LocalName );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CFile::GetRemoteName(
    LPWSTR *pVal
    ) const
{
    *pVal = MidlCopyString( m_RemoteName );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

void
CFile::GetProgress(
    BG_FILE_PROGRESS * s
    ) const
{
    s->BytesTransferred = m_BytesTransferred;
    s->BytesTotal       = m_BytesTotal;
    s->Completed        = m_Completed;
}

HRESULT
CFile::Serialize(
    HANDLE hFile
    )
{
    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //


    // not needed for download jobs, and serializing it would be incompatible
    // with BITS 1.0.
    //
    if (m_Job->GetType() != BG_JOB_TYPE_DOWNLOAD)
        {
        SafeWriteFile( hFile, m_LocalFileTime );
        }

    SafeWriteStringHandle( hFile, m_LocalName );
    SafeWriteStringHandle( hFile, m_RemoteName );
    SafeWriteStringHandle( hFile, m_TemporaryName );

    SafeWriteFile( hFile, m_BytesTransferred );
    SafeWriteFile( hFile, m_BytesTotal );
    SafeWriteFile( hFile, m_Completed );

    // Drive info
    SafeWriteStringHandle( hFile, m_VolumePath );
    SafeWriteStringHandle( hFile, m_CanonicalVolumePath );
    SafeWriteFile( hFile, m_DriveType );
    SafeWriteFile( hFile, m_VolumeSerialNumber );

    return S_OK;
}

CFile *
CFile::Unserialize(
    HANDLE  hFile,
    CJob*   Job
    )
{
    CFile * file = NULL;

    try
        {
        file = new CFile(Job);

        if (Job->GetType() != BG_JOB_TYPE_DOWNLOAD)
            {
            SafeReadFile( hFile, &file->m_LocalFileTime );
            }

        file->m_LocalName = SafeReadStringHandle( hFile );
        file->m_RemoteName = SafeReadStringHandle( hFile );
        file->m_TemporaryName = SafeReadStringHandle( hFile );

        SafeReadFile( hFile, &file->m_BytesTransferred );
        SafeReadFile( hFile, &file->m_BytesTotal );
        SafeReadFile( hFile, &file->m_Completed );

        file->m_VolumePath = SafeReadStringHandle( hFile );
        file->m_CanonicalVolumePath = SafeReadStringHandle( hFile );
        SafeReadFile( hFile, &file->m_DriveType );
        SafeReadFile( hFile, &file->m_VolumeSerialNumber );
        }
    catch ( ComError Error )
        {
        delete file;

        throw;
        }

    return file;
}

inline HRESULT
CFile::CheckClientAccess(
    DWORD RequestedAccess
    ) const
{
    return m_Job->CheckClientAccess( RequestedAccess );
}

HRESULT
CFile::VerifyLocalFileName(
    LPCWSTR name,
    BG_JOB_TYPE FileType
    )
{
    if (name == NULL)
        {
        return E_INVALIDARG;
        }

    //
    // Make sure the client can create a file there.
    //

    HRESULT Hr = S_OK;

    try
        {
        DWORD s;
        BOOL bResult;

        if (!IsAbsolutePath( name ))
            throw ComError( E_INVALIDARG );

        if ( wcsncmp( name, L"\\\\?\\", 4 ) == 0 )
            throw ComError( E_INVALIDARG );

        if (FileType == BG_JOB_TYPE_DOWNLOAD)
            {
            HRESULT hr;

            hr = BITSCheckFileWritability( name );
            if (FAILED(hr))
                {
                throw ComError( hr );
                }
            }
        else
            {
            //
            // See if the client can read the destination file.
            //
            auto_HANDLE<NULL> hFile;

            hFile = CreateFile( name,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,           // gneeric security descriptor
                                OPEN_EXISTING,
                                0,
                                NULL            // no template file
                                );

            if (hFile.get() == INVALID_HANDLE_VALUE)
                {
                ThrowLastError();
                }

            if (GetFileType( hFile.get() ) != FILE_TYPE_DISK)
                {
                throw ComError( E_INVALIDARG );
                }
            }

        //
        // Success.
        //
        Hr = S_OK;
        }
    catch ( ComError exception )
        {
        Hr = exception.Error();
        }

    return Hr;
}

HRESULT
CFile::VerifyLocalName(
    LPCWSTR name,
    BG_JOB_TYPE FileType
    )
{
    if (name == NULL)
        {
        return E_INVALIDARG;
        }

    //
    // Make sure the client can create a file there.
    //

    HRESULT Hr = S_OK;

    try
        {
        DWORD s;
        BOOL bResult;

        if (!IsAbsolutePath( name ))
            throw ComError( E_INVALIDARG );

        if ( wcsncmp( name, L"\\\\?\\", 4 ) == 0 )
            throw ComError( E_INVALIDARG );

        StringHandle FileName;
        StringHandle DirectoryName =
            BITSCrackFileName(
                name,
                FileName ); // throws ComError

        StringHandle VolumePath =
            BITSGetVolumePathName(
                DirectoryName ); // throws ComError

        UINT DriveType = GetDriveType( VolumePath );

        BOOL bIsRemote = IsDriveTypeRemote( DriveType );

        StringHandle CanonicalPath;
        DWORD VolumeSerialNumber = 0;

        if ( !bIsRemote )
            {

            CanonicalPath =
                BITSGetVolumeNameForVolumeMountPoint(
                    VolumePath ); // throw ComError

            VolumeSerialNumber =
                BITSGetVolumeSerialNumber( CanonicalPath ); //throws ComError

            }

        m_VolumePath            = VolumePath;
        m_CanonicalVolumePath   = CanonicalPath;
        m_DriveType             = DriveType;
        m_VolumeSerialNumber    = VolumeSerialNumber;

        if (FileType == BG_JOB_TYPE_DOWNLOAD)
            {
            HRESULT hr;

            m_TemporaryName = BITSCreateTempFile( DirectoryName );

            hr = BITSCheckFileWritability( name );
            if (FAILED(hr))
                {
                DeleteFile( m_TemporaryName );
                throw ComError( hr );
                }
            }
        else
            {
            //
            // See if the client can read the destination file.
            //
            auto_HANDLE<NULL> hFile;

            hFile = CreateFile( name,
                                GENERIC_READ,
                                FILE_SHARE_READ,                // no file sharing
                                NULL,                           // generic security descriptor
                                OPEN_EXISTING,
                                0,
                                NULL                            // no template file
                                );

            if (hFile.get() == INVALID_HANDLE_VALUE)
                {
                ThrowLastError();
                }

            LARGE_INTEGER size;
            if (!GetFileSizeEx( hFile.get(), &size ))
                {
                ThrowLastError();
                }

            m_BytesTotal = size.QuadPart;

            BY_HANDLE_FILE_INFORMATION info;

            if (!GetFileInformationByHandle( hFile.get(), &info ))
                {
                ThrowLastError();
                }

            m_LocalFileTime = info.ftLastWriteTime;
            }

        //
        // Success.
        //
        Hr = S_OK;
        }
    catch ( ComError exception )
        {
        Hr = exception.Error();
        }

    return Hr;
}

HRESULT
CFile::ValidateAccessForUser(
    SidHandle sid,
    bool fWrite
    )
{
    try
        {

        StringHandle CanonicalPath;
        DWORD VolumeSerialNumber = 0;
        UINT DriveType = 0;

        CNestedImpersonation imp( sid );

        StringHandle VolumePath =
            BITSGetVolumePathName( m_LocalName );

        DriveType = GetDriveType( VolumePath );

        bool bIsRemote = IsDriveTypeRemote( DriveType );

        if ( !bIsRemote )
            {

            CanonicalPath =
                BITSGetVolumeNameForVolumeMountPoint( VolumePath );

            // Need to stop impersonating at this point since registration
            // for notifications doesn't seem to tolerate impersonating callers

            imp.Revert();

#if !defined( BITS_V12_ON_NT4 )
            THROW_HRESULT( g_Manager->IsVolumeLocked( CanonicalPath ));
#endif

            VolumeSerialNumber =
                BITSGetVolumeSerialNumber( CanonicalPath );

            }

        bool bValid =
            ( _wcsicmp( VolumePath, m_VolumePath ) == 0 ) &&
            ( _wcsicmp( CanonicalPath, m_CanonicalVolumePath ) == 0 ) &&
            ( m_DriveType == DriveType ) &&
            ( m_VolumeSerialNumber == VolumeSerialNumber );

        if ( !bValid )
            return BG_E_NEW_OWNER_DIFF_MAPPING;

        // Revalidate access to the file.  There are three cases:
        //
        // 1.file is not renamed: test the temporary file and local file.
        // 2. Mars job, file is renamed: test the local file
        // 3. new job, file is renamed: no test; the app owns the local file

        HANDLE hFile;
        HRESULT hr;

        imp.Impersonate();

        if (IsCompleted())
            {
            if (m_Job->GetOldExternalGroupInterface())
                {
                //
                // case 2
                //
                hr = BITSCheckFileWritability( m_LocalName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );
                }
            else
                {
                //
                // case 3
                //
                }
            }
        else
            {
            //
            // case 1
            //
            if (fWrite)
                {
                hr = BITSCheckFileWritability( m_TemporaryName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );

                hr = BITSCheckFileWritability( m_LocalName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );
                }
            else
                {
                hr = BITSCheckFileReadability( m_LocalName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );
                }
            }

        return S_OK;
        }
    catch( ComError Error )
        {
        return Error.Error();
        }
}

bool
CFile::ValidateDriveInfo(
    HANDLE hToken,
    QMErrInfo & ErrInfo
    )
{
    try
        {
        StringHandle CanonicalPath;
        DWORD VolumeSerialNumber = 0;
        UINT DriveType = 0;

        CNestedImpersonation imp( hToken );

        StringHandle VolumePath =
           BITSGetVolumePathName( m_LocalName ); // throws ComError

        DriveType = GetDriveType( VolumePath );

        bool bIsRemote = IsDriveTypeRemote( DriveType );

        if ( !bIsRemote )
            {
            CanonicalPath =
                BITSGetVolumeNameForVolumeMountPoint(
                    VolumePath ); // throws ComError

            // Need to stop impersonating at this point since registration
            // for notifications doesn't seem to tolerate impersonating callers

            imp.Revert();

#if !defined( BITS_V12_ON_NT4 )
            THROW_HRESULT( g_Manager->IsVolumeLocked( CanonicalPath ));
#endif

            VolumeSerialNumber =
                BITSGetVolumeSerialNumber( CanonicalPath ); //throws ComError
            }

        bool bValid =
           ( _wcsicmp( VolumePath, m_VolumePath ) == 0 ) &&
           ( _wcsicmp( CanonicalPath, m_CanonicalVolumePath ) == 0 ) &&
           ( m_DriveType == DriveType ) &&
           ( m_VolumeSerialNumber == VolumeSerialNumber );

        if ( !bValid )
            {
            imp.Revert();

            g_Manager->OnDiskChange( m_CanonicalVolumePath, m_VolumeSerialNumber );

            ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, BG_E_VOLUME_CHANGED, "Volume has changed");
            ErrInfo.result = QM_FILE_FATAL_ERROR;
            return false;
            }
        }
    catch( ComError Error )
        {
        HRESULT Hr = Error.Error();
        LogWarning( "Transient error while reading volume info for %ls, hr %!winerr!",
                   (const WCHAR*)m_LocalName, Hr );

        if ( Hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
            {
            LogWarning( "Volume info APIs returned access denied, assume locked volume." );
            Hr = BG_E_DESTINATION_LOCKED;
            }

        ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, Hr, "Volume has changed");
        ErrInfo.result = QM_FILE_TRANSIENT_ERROR;

        return false;
        }

    return true;
}

bool
CFile::OnDiskChange(
    const WCHAR *CanonicalVolume,
    DWORD VolumeSerialNumber )
{
    bool bFail =
        ( _wcsicmp( m_CanonicalVolumePath, CanonicalVolume ) == 0 ) &&
        ( VolumeSerialNumber == m_VolumeSerialNumber );

    if (!bFail)
        return true;

    LogWarning( "Failing job %p, to do disk change affecting file %ls",
                m_Job, (const WCHAR*)m_LocalName );

    QMErrInfo   ErrInfo;
    ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, BG_E_VOLUME_CHANGED, "Volume has changed");
    m_Job->FileFatalError( &ErrInfo );

    return false;
}

bool
CFile::OnDismount(
    const WCHAR *CanonicalVolume )
{
    bool bFail =
        ( _wcsicmp( m_CanonicalVolumePath, CanonicalVolume ) == 0 );

    if (!bFail)
        return true;

    LogWarning( "Failing job %p, to do dismount affecting file %ls",
                m_Job, (const WCHAR*)m_LocalName );

    QMErrInfo   ErrInfo;
    ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, BG_E_VOLUME_CHANGED, "Volume has changed");
    m_Job->FileFatalError( &ErrInfo );

    return false;
}

bool CFile::Transfer(
    HANDLE hToken,
    BG_JOB_PRIORITY priority,
    const PROXY_SETTINGS & ProxySettings,
    const CCredentialsContainer * Credentials,
    QMErrInfo & ErrInfo
    )
{
    // Check if the destination is locked or changed.
    if (!ValidateDriveInfo( hToken, ErrInfo ))
        {
        return true;
        }

    if (m_BytesTransferred == m_BytesTotal)
        {
        ErrInfo.result = QM_FILE_DONE;
        return true;
        }

    //
    // Release the global lock while the download is in progress.
    //
    g_Manager->m_TaskScheduler.UnlockWriter();

    LogDl( "Download starting." );

    g_Manager->m_pPD->Download( m_RemoteName,
                                m_TemporaryName,
                                m_BytesTransferred,
                                this,
                                &ErrInfo,
                                hToken,
                                priority,
                                &ProxySettings,
                                Credentials,
                                m_Job->GetHostId()
                                );

    LogDl( "Download Ended." );

    ErrInfo.Log();

    switch (ErrInfo.result)
        {
        case QM_FILE_ABORTED:

            //
            // If the abort was due to quantum timeout, don't poke the workitem.
            //
            if (g_Manager->m_TaskScheduler.PollAbort())
                {
                g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
                }
            break;

        case QM_IN_PROGRESS:         ASSERT( ErrInfo.result != QM_IN_PROGRESS ); break;
        case QM_SERVER_FILE_CHANGED: ChangedOnServer(); break;
        case QM_FILE_TRANSIENT_ERROR:

#if !defined( BITS_V12_ON_NT4 )
            //
            // Map any connection failure to BG_E_NETWORK_DISCONNECTED, if no nets are active.
            //
            if (g_Manager->m_NetworkMonitor.GetAddressCount() == 0)
                {
                ErrInfo.Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_NETWORK_DISCONNECTED, NULL );
                }
#else
            break;
#endif

        }

    //
    // Take the writer lock, since the caller expects it to be taken
    // upon return.
    //
    while (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        ErrInfo.result = QM_FILE_ABORTED;
        }

    if (ErrInfo.result == QM_FILE_ABORTED)
        {
        return false;
        }

    return true;
}

bool
CFile::UploaderProgress(
    UINT64 BytesTransferred
    )
{
    ASSERT( g_Manager->m_TaskScheduler.IsWriter() );

    //
    // Skip the progress update if the server is rewinding the file.  Thus the no-progress
    // timer is cleared only after we actually see progress.
    //
    if (BytesTransferred > m_BytesTransferred)
        {
        m_BytesTransferred = BytesTransferred;

        m_Job->UpdateProgress( BytesTransferred, m_BytesTotal );
        }
    else
        {
        m_BytesTransferred = BytesTransferred;
        }

    bool bAbortQuantumExpired = g_Manager->CheckForQuantumTimeout();

    return bAbortQuantumExpired;
}

bool
CFile::DownloaderProgress(
    UINT64 BytesTransferred,
    UINT64 BytesTotal
    )
{
    if ( g_Manager->m_TaskScheduler.LockWriter() )
        {
        // Cancel was requested, notify downloader.
        return true;
        }

    m_BytesTransferred = BytesTransferred;
    m_BytesTotal       = BytesTotal;

    m_Job->UpdateProgress( BytesTransferred, BytesTotal );

    bool bAbortQuantumExpired = g_Manager->CheckForQuantumTimeout();

    g_Manager->m_TaskScheduler.UnlockWriter();

    return bAbortQuantumExpired;
}

bool
CFile::PollAbort()
{
    if (g_Manager->m_TaskScheduler.PollAbort() ||
        g_Manager->CheckForQuantumTimeout())
        {
        return true;
        }

    return false;
}

BOOL
CFile::VerifyRemoteName(
    LPCWSTR name
    )
{
    if (name == NULL)
        {
        return FALSE;
        }

    if ( ( 0 != wcsncmp(name, L"http://", 7)) &&
         ( 0 != wcsncmp(name, L"https://", 8)) )
        {
        return FALSE;
        }

    if (( wcslen(name) > INTERNET_MAX_URL_LENGTH))
        return FALSE;

    return TRUE;
}

HRESULT
CFile::MoveTempFile()
{
    LogInfo( "commit: moving '%S' to '%S'", (const WCHAR*)m_TemporaryName, (const WCHAR*)m_LocalName );

    ASSERT( !m_Completed );

    DWORD dwFileAttributes =
        GetFileAttributes( (const WCHAR*)m_TemporaryName );

    if ( (DWORD)-1 == dwFileAttributes )
        {
        DWORD dwError = GetLastError();
        LogError( "GetFileAttributes error %!winerr!%", dwError );
        return HRESULT_FROM_WIN32( dwError );
        }

    if (!SetFileAttributes( m_TemporaryName, FILE_ATTRIBUTE_NORMAL ))
        {
        DWORD dwError = GetLastError();
        LogError( "SetFileAttributes error %d", dwError );
        return HRESULT_FROM_WIN32( dwError );
        }

    const DWORD dwMaxRetries = 10;
    DWORD dwError;
    DWORD dwSleepMSec = 50;

    for (int i=0; i<dwMaxRetries; i++)
        {
        if ( MoveFileEx( m_TemporaryName, m_LocalName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ) )
            {
            LogInfo( "file moved ok.");
            m_Completed = true;
            return S_OK;
            }

        dwError = GetLastError();
        LogError( "Unable to move file '%S' to '%S' due to %!winerr!, sleeping",
                  (const WCHAR*) m_TemporaryName, (const WCHAR*)m_LocalName, dwError );

        // Only try three times if this isn't a file sharing violation.
        if ((i>3) && (dwError != ERROR_SHARING_VIOLATION))
            {
            break;
            }

        if (i<dwMaxRetries-1)  // Don't hang the thread for the last sleep...
            {
            Sleep( dwSleepMSec );
            }

        dwSleepMSec *= 2;
        }

    LogError( "Timed out renaming temp file" );

    // Attemp to reset the attributes on the file.
    SetFileAttributes( (const WCHAR*)m_TemporaryName, dwFileAttributes );
    return HRESULT_FROM_WIN32( dwError );
}

HRESULT
CFile::DeleteTempFile()
{
    if (!DeleteFile( m_TemporaryName ))
        {
        DWORD s = GetLastError();
        LogWarning("error %!winerr! deleting %S", s, LPCWSTR( m_TemporaryName ));
        return HRESULT_FROM_WIN32( s );
        }

    return S_OK;
}

void
CFile::ChangedOnServer()
{
    LogError( "deleting '%S' since it was changed on the server", (const WCHAR*)m_TemporaryName );

    DeleteTempFile();

    m_BytesTransferred = 0;
    m_Completed = false;
    m_BytesTotal = BG_SIZE_UNKNOWN;
}

void
CFile::DiscoverBytesTotal(
    HANDLE Token,
    const PROXY_SETTINGS & ProxySettings,
    const CCredentialsContainer * Credentials,
    QMErrInfo & ErrorInfo
    )
{
    UINT64       FileSize;
    FILETIME     FileTime;

    LogDl( "Retrieving remote infomation for %ls", m_RemoteName );

    g_Manager->m_TaskScheduler.UnlockWriter();

    g_Manager->m_pPD->GetRemoteFileInformation(
        Token,
        m_RemoteName,
        &FileSize,
        &FileTime,
        &ErrorInfo,
        &ProxySettings,
        Credentials,
        m_Job->GetHostId()
         );

    {
    bool fCancelled = false;

    while (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        fCancelled = true;
        }

    if (fCancelled)
        {
        ErrorInfo.result = QM_FILE_ABORTED;
        }
    }

    LogDl("result was %d", ErrorInfo.result );

    switch (ErrorInfo.result)
        {
        case QM_FILE_DONE:            m_BytesTotal = FileSize;  break;
        case QM_IN_PROGRESS:          ASSERT( 0 );              break;
        case QM_SERVER_FILE_CHANGED:  ChangedOnServer();        break;
        }
}

HANDLE
CFile::OpenLocalFileForUpload()
{
    auto_HANDLE<NULL> hFile = CreateFile( m_LocalName,
                                          GENERIC_READ,
                                          FILE_SHARE_READ,
                                          NULL,
                                          OPEN_EXISTING,
                                          0,
                                          NULL );

    if ( hFile.get() == INVALID_HANDLE_VALUE )
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError() ));
        }

    BY_HANDLE_FILE_INFORMATION info;

    if (!GetFileInformationByHandle( hFile.get(), &info ))
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError() ));
        }

    if (m_LocalFileTime != info.ftLastWriteTime)
        {
        THROW_HRESULT( BG_E_LOCAL_FILE_CHANGED );
        }

    LARGE_INTEGER Offset;

    Offset.QuadPart = m_BytesTransferred;

    if (!SetFilePointerEx( hFile.get(), Offset, NULL, FILE_BEGIN ))
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError() ));
        }

    return hFile.release();
}

HRESULT
CFile::SetLocalFileTime( FILETIME Time )
/*
    This is used as a special case to set the file time of a zero-length file, since
    the normal download path is skipped.
*/
{
    try
        {
        auto_HANDLE<NULL> hFile = CreateFile( m_TemporaryName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL );

        if ( hFile.get() == INVALID_HANDLE_VALUE )
            {
            ThrowLastError();
            }

        if (!SetFileTime( hFile.get(), &Time, &Time, &Time ) )
            {
            ThrowLastError();
            }

        return S_OK;
        }
    catch ( ComError err )
        {
        LogError( "error %x setting creation time", err.Error() );
        return err.Error();
        }
}

//------------------------------------------------------------------------

typedef CLockedReadPointer<CFile, BG_JOB_READ> CLockedFileReadPointer;
typedef CLockedWritePointer<CFile, BG_JOB_WRITE> CLockedFileWritePointer;


CFileExternal::CFileExternal(
    CFile * file,
    CJobExternal * JobExternal
    )
    : m_ServiceInstance( g_ServiceInstance ),
      m_refs(1),
      m_file( file ),
      m_JobExternal( JobExternal )
{
    m_JobExternal->AddRef();
}

CFileExternal::~CFileExternal()
{
    SafeRelease( m_JobExternal );
}

STDMETHODIMP
CFileExternal::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == IID_IBackgroundCopyFile))
        {
        *ppvObject = (IBackgroundCopyFile *)this;
        AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "iid %!guid!, hr %x", &iid, Hr );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG
CFileExternal::AddRef()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef("refs %d", newrefs);

    return newrefs;

    END_EXTERNAL_FUNC
}

ULONG
CFileExternal::Release()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef("refs %d", newrefs);

    if (0 == newrefs)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}

STDMETHODIMP
CFileExternal::GetRemoteNameInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedFileReadPointer LockedPointer(m_file);
    LogPublicApiBegin( "pVal %p", pVal );

    HRESULT Hr = LockedPointer.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedPointer->GetRemoteName( pVal );
        }

    LogPublicApiEnd( "pVal %p(%S) ", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CFileExternal::GetLocalNameInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedFileReadPointer LockedPointer(m_file);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedPointer.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedPointer->GetLocalName( pVal );
        }
    LogPublicApiEnd( "pVal %p(%S) ", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CFileExternal::GetProgressInternal(
    /* [out] */ BG_FILE_PROGRESS *pVal
    )
{
    CLockedFileReadPointer LockedPointer(m_file);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedPointer.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        LockedPointer->GetProgress( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cerror.cpp ===
#include "stdafx.h"
#include "cerror.tmh"

void
CJobError::Set(
    CJob  *     job,
    LONG       FileIndex,
    QMErrInfo * ErrInfo
    )
{
    m_ErrorSet  = true;
    m_job       = job;
    m_FileIndex = FileIndex;
    m_ErrInfo   = *ErrInfo;
}

void
CJobError::ClearError()
{
    m_ErrorSet  = false;
    m_job       = 0;
    m_FileIndex = 0;
    memset( &m_ErrInfo, 0, sizeof(m_ErrInfo));
}

CJobError::CJobError()
{
    ClearError();
}

CFileExternal *
CJobError::CreateFileExternal() const
{
    CFile * file = m_job->_GetFileIndex( m_FileIndex );
    if (!file)
        {
        return NULL;
        }

    return file->CreateExternalInterface();
}


void
CJobError::GetOldInterfaceErrors(
    DWORD *pdwWin32Result,
    DWORD *pdwTransportResult ) const
{

    if (!IsErrorSet())
        {
        *pdwWin32Result = *pdwTransportResult = 0;
        return;
        }

    if ( GetStyle() == ERROR_STYLE_WIN32 )
        {
        *pdwWin32Result = GetCode();
        }
    else if ( GetStyle() == ERROR_STYLE_HRESULT &&
              ( (GetCode() & 0xffff0000) == 0x80070000 )  )
        {
        // If this is a win32 wrapped as an HRESULT, unwrap it.
        *pdwWin32Result = (GetCode() & 0x0000ffff);
        }

    if ( (GetSource() & COMPONENT_MASK) == COMPONENT_TRANS )
        {
        *pdwTransportResult = GetCode();
        }
    else
        {
        *pdwTransportResult = 0;
        }

}



HRESULT
CJobError::Serialize(
    HANDLE hFile
    ) const
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //


    if (!m_ErrorSet)
        {
        BOOL TrueBool = FALSE;
        SafeWriteFile( hFile, TrueBool );
        return S_OK;
        }

    BOOL FalseBool = TRUE;
    SafeWriteFile( hFile, FalseBool );
    SafeWriteFile( hFile, m_FileIndex );
    SafeWriteFile( hFile, m_ErrInfo.Code );
    SafeWriteFile( hFile, m_ErrInfo.Style );
    SafeWriteFile( hFile, m_ErrInfo.Source );
    SafeWriteFile( hFile, m_ErrInfo.result );
    SafeWriteFile( hFile, m_ErrInfo.Description );

    return S_OK;
}

void
CJobError::Unserialize(
    HANDLE hFile,
    CJob * job
    )
{
    BOOL ReadBool;
    SafeReadFile( hFile, &ReadBool );

    if (!ReadBool)
        {
        ClearError();
        return;
        }

    m_ErrorSet = true;
    SafeReadFile( hFile, &m_FileIndex );
    SafeReadFile( hFile, &m_ErrInfo.Code );
    SafeReadFile( hFile, &m_ErrInfo.Style );
    SafeReadFile( hFile, &m_ErrInfo.Source );
    SafeReadFile( hFile, &m_ErrInfo.result );
    SafeReadFile( hFile, &m_ErrInfo.Description );

    m_job = job;
}

//------------------------------------------------------------------------

CJobErrorExternal::CJobErrorExternal() :
    m_Context(BG_ERROR_CONTEXT_NONE),
    m_Code(S_OK),
    m_FileExternal(NULL)
{
}

CJobErrorExternal::CJobErrorExternal( CJobError const * JobError ) :
    m_Context( BG_ERROR_CONTEXT_UNKNOWN ),
    m_Code( S_OK ),
    m_FileExternal( NULL )
{
    try
        {
        m_FileExternal = JobError->CreateFileExternal();

        // Map source into a context
        ERROR_SOURCE Source = JobError->GetSource();
        switch(Source & COMPONENT_MASK)
            {
            case COMPONENT_QMGR:
                switch(Source & SUBCOMP_MASK)
                    {
                    case SUBCOMP_QMGR_FILE:
                        m_Context = BG_ERROR_CONTEXT_LOCAL_FILE;
                        break;
                    case SUBCOMP_QMGR_QUEUE:
                        m_Context = BG_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER;
                        break;
                    case SUBCOMP_QMGR_NOTIFY:
                        m_Context = BG_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION;
                        break;
                    default:
                        ASSERT(0);
                    }
                 break;
            case COMPONENT_TRANS:

                if (Source == SOURCE_HTTP_SERVER_APP)
                    {
                    m_Context = BG_ERROR_CONTEXT_REMOTE_APPLICATION;
                    }
                else
                    {
                    m_Context = BG_ERROR_CONTEXT_REMOTE_FILE;
                    }
                 break;
            default:
                m_Context = BG_ERROR_CONTEXT_NONE;
                break;
            }

        // map code into a HRESULT
        switch( JobError->GetStyle() )
            {
            case ERROR_STYLE_NONE:
                ASSERT(0);
                m_Code = JobError->GetCode();
                break;;
            case ERROR_STYLE_HRESULT:
                m_Code = JobError->GetCode();
                break;
            case ERROR_STYLE_WIN32:
                m_Code = HRESULT_FROM_WIN32( JobError->GetCode() );
                break;
            case ERROR_STYLE_HTTP:
                m_Code = MAKE_HRESULT( SEVERITY_ERROR, 0x19, JobError->GetCode() );
                break;
            default:
                ASSERT(0);
                m_Code = JobError->GetCode();
                break;
            }
        }
    catch (ComError err)
        {
        SafeRelease( m_FileExternal );
        }
}


CJobErrorExternal::~CJobErrorExternal()
{
    SafeRelease( m_FileExternal );
}

STDMETHODIMP
CJobErrorExternal::GetErrorInternal(
    BG_ERROR_CONTEXT *pContext,
    HRESULT *pCode
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "pContext %p, pCode %p", pContext, pCode );

    ASSERT( pContext );
    ASSERT( pCode );

    *pContext = m_Context;
    *pCode = m_Code;

    LogPublicApiEnd( "pContext %p(%u), pCode %p(%u)", pContext, pContext ? *pContext : 0, pCode, pCode ? *pCode : 0 );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetFileInternal(
    IBackgroundCopyFile ** pVal
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "pVal %p", pVal );

    if (!m_FileExternal)
        {
        *pVal = NULL;
        Hr = BG_E_FILE_NOT_AVAILABLE;
        }
    else
        {
        m_FileExternal->AddRef();
        *pVal = m_FileExternal;
        }

    LogPublicApiEnd( "pVal %p(%p)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetProtocolInternal( LPWSTR *pProtocol )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "pProtocol %p", pProtocol );

    *pProtocol = NULL;
    if ( !m_FileExternal )
        {
        Hr = BG_E_PROTOCOL_NOT_AVAILABLE;
        }
    else
        {
        Hr = m_FileExternal->GetRemoteName( pProtocol );
        if (SUCCEEDED(Hr))
            {
            // replace the : with a '\0'
            WCHAR *pColon = wcsstr( *pProtocol, L":" );

            // Shouldn't happen since the name should have been verified
            // during the AddFile.
            ASSERT( pColon );

            if ( pColon )
                {
                *pColon = L'\0';
                }
            }
        }

    LogPublicApiEnd( "pProtocol %p(%p,%S)", pProtocol, *pProtocol, (*pProtocol ? *pProtocol : L"NULL") );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetErrorDescriptionInternal(
    DWORD LanguageId,
    LPWSTR *pErrorDescription
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "LanguageId %u, pErrorDescription %p", LanguageId, pErrorDescription );
    Hr = g_Manager->GetErrorDescription( m_Code, LanguageId, pErrorDescription );
    LogPublicApiEnd( "LanguageId %u, pErrorDescription %p(%S)", LanguageId, pErrorDescription,
                     (*pErrorDescription ? *pErrorDescription : L"NULL") );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetErrorContextDescriptionInternal(
    DWORD LanguageId,
    LPWSTR *pContextDescription
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "LanguageId %u, pErrorDescription %p", LanguageId, pContextDescription );

    HRESULT hMappedError = BG_E_ERROR_CONTEXT_UNKNOWN;
    switch( m_Context )
        {
        case BG_ERROR_CONTEXT_NONE:
            hMappedError = BG_S_ERROR_CONTEXT_NONE;
            break;
        case BG_ERROR_CONTEXT_UNKNOWN:
            hMappedError = BG_E_ERROR_CONTEXT_UNKNOWN;
            break;
        case BG_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER:
            hMappedError = BG_E_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER;
            break;
        case BG_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION:
            hMappedError = BG_E_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION;
            break;
        case BG_ERROR_CONTEXT_LOCAL_FILE:
            hMappedError = BG_E_ERROR_CONTEXT_LOCAL_FILE;
            break;
        case BG_ERROR_CONTEXT_REMOTE_FILE:
            hMappedError = BG_E_ERROR_CONTEXT_REMOTE_FILE;
            break;
        case BG_ERROR_CONTEXT_GENERAL_TRANSPORT:
            hMappedError = BG_E_ERROR_CONTEXT_GENERAL_TRANSPORT;
            break;
        case BG_ERROR_CONTEXT_REMOTE_APPLICATION:
            hMappedError = BG_E_ERROR_CONTEXT_REMOTE_APPLICATION;
            break;
        default:
            ASSERT(0);
            break;
        }

    Hr = g_Manager->GetErrorDescription( hMappedError, LanguageId, pContextDescription );

    LogPublicApiEnd( "LanguageId %u, pContextDescription %p(%S)",
                     LanguageId, pContextDescription,
                     (*pContextDescription ? *pContextDescription : L"NULL" ) );
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cerror.h ===
class CJobError
{
public:

    CJobError();

    UINT64 GetCode() const
    {
        return m_ErrInfo.Code;
    }

    ERROR_STYLE GetStyle() const
    {
        return m_ErrInfo.Style;
    }

    ERROR_SOURCE GetSource() const
    {
        return m_ErrInfo.Source;
    }

    CFileExternal * CreateFileExternal() const;

    LONG GetFileIndex() const
    {
        return m_FileIndex;
    }

    void GetOldInterfaceErrors(
        DWORD *pdwWin32Result,
        DWORD *pdwTransportResult ) const;

    void Set(
        CJob  *         Job,
        LONG           FileIndex,
        QMErrInfo *     ErrInfo
        );

    bool IsErrorSet() const
        {
        return m_ErrorSet;
        }

    void ClearError();

    bool operator==( const CJobError & err )
    {
        if (m_ErrorSet == err.m_ErrorSet &&
            m_FileIndex == err.m_FileIndex &&
            m_job == err.m_job &&
            m_ErrInfo == err.m_ErrInfo)
            {
            return true;
            }

        return false;
    }

    HRESULT Serialize( HANDLE hFile ) const;

    void Unserialize( HANDLE hFile, CJob * job );

protected:

    bool            m_ErrorSet;
    LONG            m_FileIndex;
    CJob *          m_job;
    QMErrInfo       m_ErrInfo;

};

class CJobErrorExternal : public CSimpleExternalIUnknown<IBackgroundCopyError>
{
public:

    // All external methods are read only so no locks are needed.

    // IBackgroundCopyError methods

    HRESULT STDMETHODCALLTYPE GetErrorInternal(
        /* [ in, out, unique ] */ BG_ERROR_CONTEXT *pContext,
        /* [ in, out, unique ] */ HRESULT *pCode );

    HRESULT STDMETHODCALLTYPE GetError(
        /* [ in, out, unique ] */ BG_ERROR_CONTEXT *pContext,
        /* [ in, out, unique ] */ HRESULT *pCode )
    {
        EXTERNAL_FUNC_WRAP( GetErrorInternal( pContext, pCode ) )
    }


    HRESULT STDMETHODCALLTYPE GetFileInternal(
        /* [ in, out, unique ] */ IBackgroundCopyFile ** pVal );

    HRESULT STDMETHODCALLTYPE GetFile(
        /* [ in, out, unique ] */ IBackgroundCopyFile ** pVal )
    {
        EXTERNAL_FUNC_WRAP( GetFileInternal( pVal ) )
    }

    // Retusn a human readable description of the error.
    // Use CoTaskMemAlloc to free the description.
    HRESULT STDMETHODCALLTYPE GetErrorDescriptionInternal(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription );

    HRESULT STDMETHODCALLTYPE GetErrorDescription(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription )
    {
        EXTERNAL_FUNC_WRAP( GetErrorDescriptionInternal( LanguageId, pErrorDescription ) )
    }


    // Return a human readable description of the error context.
    // Use CoTaskMemAlloc to free the description.
    HRESULT STDMETHODCALLTYPE GetErrorContextDescriptionInternal(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription );

    HRESULT STDMETHODCALLTYPE GetErrorContextDescription(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription )
    {
        EXTERNAL_FUNC_WRAP( GetErrorContextDescriptionInternal( LanguageId, pErrorDescription ) )
    }


    HRESULT STDMETHODCALLTYPE GetProtocolInternal(
        /* [out,ref] */ LPWSTR *pProtocol );

    HRESULT STDMETHODCALLTYPE GetProtocol(
        /* [out,ref] */ LPWSTR *pProtocol )
    {
        EXTERNAL_FUNC_WRAP( GetProtocolInternal( pProtocol ) )
    }

    // other member functions

    CJobErrorExternal( CJobError const * JobError );

    CJobErrorExternal( );

protected:

    virtual ~CJobErrorExternal();

    BG_ERROR_CONTEXT m_Context;
    HRESULT          m_Code;
    CFileExternal *  m_FileExternal;

    HRESULT GetErrorDescription(
        HRESULT hResult,
        DWORD LanguageId,
        LPWSTR *pErrorDescription );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cjob.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.cpp

Abstract :

    Main code file for handling jobs and files.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include <malloc.h>
#include <numeric>
#include <functional>
#include <algorithm>
#include <sddl.h>
#include "cjob.tmh"

// infinite retry wait time
//
#define INFINITE_RETRY_DELAY UINT64(-1)

//
// This is the number of seconds to keep trying to cancel an upload session in progress.
//
#define UPLOAD_CANCEL_TIMEOUT (24 * 60 * 60)

#define DEFAULT_JOB_TIMEOUT_TIME (90 * 24 * 60 * 60)

#define PROGRESS_SERIALIZE_INTERVAL (15 * NanoSec100PerSec)

// largest reply blob that can be returned via GetReplyData
//
#define MAX_EASY_REPLY_DATA (1024 * 1024)

#define MAX_LOGGED_UNSUCCESSFUL_FILES 50

//------------------------------------------------------------------------

CJob::CJob()
    :
        m_ExternalInterface( new CJobExternal),
        m_state( BG_JOB_STATE_SUSPENDED ),
        m_NotifyPointer( NULL ),
        m_sd( NULL ),
        m_CurrentFile( 0 ),
        m_OldExternalJobInterface( NULL ),
        m_OldExternalGroupInterface( NULL ),
        m_FilesVerified( false )
{
    //
    // constructor has succeeded; allow CJobExternal to manage our lifetime.
    //
    GetExternalInterface()->SetInterfaceClass(this);
}

CJob::CJob(
    LPCWSTR     DisplayName,
    BG_JOB_TYPE Type,
    REFGUID     JobId,
    SidHandle   NotifySid
    ) :
        m_ExternalInterface( new CJobExternal),
        m_id( JobId ),
        m_name( DisplayName ),
        m_type( Type ),
        m_priority( BG_JOB_PRIORITY_NORMAL ),
        m_state( BG_JOB_STATE_SUSPENDED ),
        m_retries( 0 ),
        m_NotifySid( NotifySid ),
        m_NotifyPointer( NULL ),
        m_sd( NULL ),
        m_CurrentFile( 0 ),
        m_MinimumRetryDelay( g_GlobalInfo->m_DefaultMinimumRetryDelay ),
        m_NoProgressTimeout( g_GlobalInfo->m_DefaultNoProgressTimeout ),
        m_OldExternalJobInterface( NULL ),
        m_OldExternalGroupInterface( NULL ),
        m_TransferCompletionTime( UINT64ToFILETIME( 0 )),
        m_SerializeTime( UINT64ToFILETIME( 0 )),
        m_fVolumeLocked( false ),
        m_NotifyFlags( BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR ),
        m_fGroupNotifySid( FALSE ),
        m_FilesVerified( false )
{
    LogInfo( "new job %p : ID is %!guid!, external %p", this, &m_id, m_ExternalInterface );

    GetSystemTimeAsFileTime( &m_CreationTime );

    m_ModificationTime = m_CreationTime;
    m_LastAccessTime   = m_CreationTime;

    // we don't support group SIDs yet.
    //        THROW_HRESULT( IsGroupSid( m_NotifySid, &m_fGroupNotifySid ))

    m_sd = new CJobSecurityDescriptor( NotifySid );

    //
    // constructor has succeeded; allow CJobExternal to manage our lifetime.
    //
    GetExternalInterface()->SetInterfaceClass(this);
}


CJob::~CJob()
{
    //
    // This should be redundant, but let's be safe.
    //
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobModificationItem *> (this)  );

    CancelWorkitems();

    delete m_sd;

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        delete (*iter);
        }

    m_files.clear();

    if (g_LastServiceControl != SERVICE_CONTROL_SHUTDOWN)
        {
        SafeRelease( m_NotifyPointer );
        }
}

void CJob::UnlinkFromExternalInterfaces()
{
    //
    // These objects np longer control the CJob's lifetime...
    //
    if (m_ExternalInterface)
        {
        m_ExternalInterface->SetInterfaceClass( NULL );
        }

    if (m_OldExternalJobInterface)
        {
        m_OldExternalJobInterface->SetInterfaceClass( NULL );
        }

    if (m_OldExternalGroupInterface)
        {
        m_OldExternalGroupInterface->SetInterfaceClass( NULL );
        }

    //
    // ...and the CJob no longer holds a reference to them.
    //
    SafeRelease( m_ExternalInterface );
    SafeRelease( m_OldExternalJobInterface );
    SafeRelease( m_OldExternalGroupInterface );
}

void
CJob::HandleAddFile()
{

    if ( m_state == BG_JOB_STATE_TRANSFERRED )
        {
        SetState( BG_JOB_STATE_QUEUED );

        m_TransferCompletionTime = UINT64ToFILETIME( 0 );

        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobRetryItem *) this );
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobCallbackItem *) this );
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobNoProgressItem *) this );
        }

    UpdateModificationTime();

    // restart the downloader if its running.
    g_Manager->RetaskJob( this );
}

//
// Returns E_INVALIDARG if one of the filesets has
//      - local name is blank
//      - local name contains invalid characters
//      - remote name is blank
//      - remote name has invalid format
//
// Returns CO_E_NOT_SUPPORTED if
//      - remote URL contains unsupported protocol
//
HRESULT
CJob::AddFileSet(
    IN  ULONG cFileCount,
    IN  BG_FILE_INFO *pFileSet
    )
{
    ULONG FirstNewIndex = m_files.size();

    try
        {
        ULONG i;

        g_Manager->ExtendMetadata( ( METADATA_FOR_FILE * cFileCount ) + METADATA_PADDING );

        for (i=0; i < cFileCount; ++i)
            {
            THROW_HRESULT( AddFile( pFileSet[i].RemoteName,
                                    pFileSet[i].LocalName,
                                    false
                                    ));
            }

        HandleAddFile();

        return S_OK;
        }
    catch ( ComError exception )
        {
        if (m_type == BG_JOB_TYPE_DOWNLOAD)
            {
            try
                {
                // Delete temp files for new file objects.
                //
                RemoveTemporaryFiles( FirstNewIndex );
                }
            catch ( ComError err )
                {
                LogError("exception 0x%x at line %d", err.m_error, err.m_line ); 
                
                // carry on
                }            
            }

        // Delete new files objects.
        // This assumes that new files are added at the back of the sequence.
        //

        m_files.Delete( m_files.begin() + FirstNewIndex, m_files.end() );
        g_Manager->ShrinkMetadata();

        return exception.Error();
        }
}

HRESULT
CJob::AddFile(
    IN     LPCWSTR RemoteName,
    IN     LPCWSTR LocalName,
    IN     bool SingleAdd
    )
{
    HRESULT hr = S_OK;
    CFile * file = NULL;

    //
    // This check must be completed outside the try..except; otherwise
    // the attempt to add a 2nd file would delete the generated reply file
    // for the 1st file.
    //
    if (m_type != BG_JOB_TYPE_DOWNLOAD && m_files.size() > 0)
        {
        return BG_E_TOO_MANY_FILES;
        }

    try
        {
        if ( !RemoteName || !LocalName )
            THROW_HRESULT( E_INVALIDARG );

        LogInfo("job %p addfile( %S, %S )", this, RemoteName, LocalName );

        if ( ( _GetState() == BG_JOB_STATE_CANCELLED ) ||
             ( _GetState() == BG_JOB_STATE_ACKNOWLEDGED ) )
            throw ComError( BG_E_INVALID_STATE );

        if ( SingleAdd )
            g_Manager->ExtendMetadata( METADATA_FOR_FILE + METADATA_PADDING );

        //
        // Impersonate the user while checking file access.
        //
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        file = new CFile( this, m_type, RemoteName, LocalName );

        // WARNING: if you change this, also update the cleanup logic in AddFileSet.
        //
        m_files.push_back( file );

        //
        // Try to create the default reply file.  Ignore error, because the app
        // may be planning to set the reply file somewhere else.
        //
        if (m_type == BG_JOB_TYPE_UPLOAD_REPLY)
            {
            ((CUploadJob *) this)->GenerateReplyFile( false );
            }

        m_FilesVerified = false;

        }
    catch ( ComError exception )
        {
        delete file;
        file = NULL;

        if (m_type == BG_JOB_TYPE_UPLOAD_REPLY)
            {
            ((CUploadJob *) this)->DeleteGeneratedReplyFile();
            ((CUploadJob *) this)->ClearOwnFileNameBit();
            }

        if ( SingleAdd )
            g_Manager->ShrinkMetadata();

        hr = exception.Error();
        }

    if ( SUCCEEDED(hr) && SingleAdd )
        {
        HandleAddFile();
        }

    return hr;
}

HRESULT
CJob::SetDisplayName(
    LPCWSTR Val
    )
{
    return SetLimitedString( m_name, Val, MAX_DISPLAYNAME );
}

HRESULT
CJob::GetDisplayName(
    LPWSTR * pVal
    ) const
{
    *pVal = MidlCopyString( m_name );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::SetDescription(
    LPCWSTR Val
    )
{
    return SetLimitedString( m_description, Val, MAX_DESCRIPTION );
}

HRESULT
CJob::GetDescription(
    LPWSTR *pVal
    ) const
{
    *pVal = MidlCopyString( m_description );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::SetNotifyCmdLine(
    LPCWSTR Program,
    LPCWSTR Parameters
    )
{
    StringHandle OldProgram;
    StringHandle OldParameters;

    if (Program == NULL && Parameters != NULL)
        {
        return E_INVALIDARG;
        }

    try
        {
        OldProgram = m_NotifyProgram;
        OldParameters = m_NotifyParameters;

        THROW_HRESULT( SetLimitedString( m_NotifyProgram, Program, MAX_NOTIFY_PROGRAM ));
        THROW_HRESULT( SetLimitedString( m_NotifyParameters, Parameters, MAX_NOTIFY_PARAMETERS ));

        return S_OK;
        }
    catch ( ComError err )
        {
        m_NotifyProgram = OldProgram;
        m_NotifyParameters = OldParameters;

        return err.Error();
        }
}

HRESULT
CJob::GetNotifyCmdLine(
    LPWSTR *pProgram,
    LPWSTR *pParameters
    ) const
{
    *pProgram = NULL;
    *pParameters = NULL;

    if (m_NotifyProgram.Size() > 0)
        {
        *pProgram = MidlCopyString( m_NotifyProgram );
        if (!*pProgram)
            {
            return E_OUTOFMEMORY;
            }
        }

    if (m_NotifyParameters.Size() > 0)
        {
        *pParameters = MidlCopyString( m_NotifyParameters );
        if (!*pParameters)
            {
            CoTaskMemFree( *pProgram );
            *pProgram = NULL;

            return E_OUTOFMEMORY;
            }
        }

    return S_OK;
}

HRESULT
CJob::SetProxySettings(
    BG_JOB_PROXY_USAGE ProxyUsage,
    LPCWSTR ProxyList,
    LPCWSTR ProxyBypassList
    )
{
    HRESULT hr = S_OK;

    if ( ProxyUsage != BG_JOB_PROXY_USAGE_PRECONFIG &&
         ProxyUsage != BG_JOB_PROXY_USAGE_NO_PROXY &&
         ProxyUsage != BG_JOB_PROXY_USAGE_OVERRIDE )
        {
        return E_INVALIDARG;
        }

    if ( BG_JOB_PROXY_USAGE_PRECONFIG == ProxyUsage ||
         BG_JOB_PROXY_USAGE_NO_PROXY == ProxyUsage )
        {

        if ( NULL != ProxyList ||
             NULL != ProxyBypassList )
            return E_INVALIDARG;

        }
    else
        {
        // BG_PROXY_USAGE_OVERRIDE == ProxyUsage
        if ( NULL == ProxyList )
            return E_INVALIDARG;
        }

    try
        {
        //
        // Allocate space for the new proxy settings.
        //
        CAutoString ProxyListTemp(NULL);
        CAutoString ProxyBypassListTemp(NULL);

        g_Manager->ExtendMetadata();

        if ( ProxyList )
            {
            if ( wcslen( ProxyList ) > MAX_PROXYLIST )
                throw ComError( BG_E_PROXY_LIST_TOO_LARGE );

            ProxyListTemp = CAutoString( CopyString( ProxyList ));
            }

        if ( ProxyBypassList )
           {
           if ( wcslen( ProxyBypassList ) > MAX_PROXYBYPASSLIST )
               throw ComError( BG_E_PROXY_BYPASS_LIST_TOO_LARGE );

           ProxyBypassListTemp = CAutoString( CopyString( ProxyBypassList ));
           }

        //
        // Interrupt the job if it is downloading, and resume at the end of this fn.
        // This keeps the downloader from referring to the memory that we are deleting,
        // and ensures that the most current job settings are used during the download.
        //
        CRescheduleDownload r( this );

        //
        // Swap the old proxy settings for the new ones.
        //
        delete[] m_ProxySettings.ProxyList;
        delete[] m_ProxySettings.ProxyBypassList;

        m_ProxySettings.ProxyUsage = ProxyUsage;
        m_ProxySettings.ProxyList = ProxyListTemp.release();
        m_ProxySettings.ProxyBypassList = ProxyBypassListTemp.release();

        UpdateModificationTime();
        return S_OK;
        }
    catch( ComError error )
        {
        g_Manager->ShrinkMetadata();
        return error.Error();
        }
}

HRESULT
CJob::GetProxySettings(
    BG_JOB_PROXY_USAGE *pProxyUsage,
    LPWSTR *pProxyList,
    LPWSTR *pProxyBypassList
    ) const
{
    HRESULT Hr = S_OK;

    *pProxyUsage      = m_ProxySettings.ProxyUsage;
    *pProxyList       = NULL;
    *pProxyBypassList = NULL;

    try
    {
         if ( m_ProxySettings.ProxyList )
             {
             *pProxyList = MidlCopyString( m_ProxySettings.ProxyList );
             if (!*pProxyList)
                 throw ComError( E_OUTOFMEMORY );
             }

         if ( m_ProxySettings.ProxyBypassList )
             {
             *pProxyBypassList = MidlCopyString( m_ProxySettings.ProxyBypassList );
             if (!*pProxyBypassList)
                 throw ComError( E_OUTOFMEMORY );
             }
    }
    catch( ComError exception )
    {
        Hr = exception.Error();
        CoTaskMemFree( *pProxyList );
        CoTaskMemFree( *pProxyBypassList );

        *pProxyList = *pProxyBypassList = NULL;
    }

    return Hr;
}

void
CJob::GetTimes(
    BG_JOB_TIMES * s
    ) const
{
    s->CreationTime             = m_CreationTime;
    s->ModificationTime         = m_ModificationTime;
    s->TransferCompletionTime   = m_TransferCompletionTime;
}

void
CJob::GetProgress(
    BG_JOB_PROGRESS * s
    ) const
{

    s->BytesTransferred = 0;
    s->BytesTotal       = 0;

    CFileList::const_iterator iter;

    for (iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        BG_FILE_PROGRESS s2;

        (*iter)->GetProgress( &s2 );

        s->BytesTransferred += s2.BytesTransferred;

        if (s2.BytesTotal != BG_SIZE_UNKNOWN &&
            s->BytesTotal != BG_SIZE_UNKNOWN )
            {
            s->BytesTotal += s2.BytesTotal;
            }
        else
            {
            s->BytesTotal = BG_SIZE_UNKNOWN;
            }
        }

    s->FilesTransferred = (ULONG) m_CurrentFile;
    s->FilesTotal       = m_files.size();
}

HRESULT
CJob::GetOwner(
    LPWSTR * pVal
    ) const
{
    wchar_t * buf;
    wchar_t * str;

    if (!ConvertSidToStringSid( m_NotifySid.get(), &str))
        {
        return HRESULT_FROM_WIN32( GetLastError());
        }

    *pVal = MidlCopyString( str );

    LocalFree( str );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::SetPriority(
    BG_JOB_PRIORITY Val
    )
{
    if (Val > BG_JOB_PRIORITY_LOW ||
        Val < BG_JOB_PRIORITY_FOREGROUND)
        {
        return E_NOTIMPL;
        }

    if (Val == m_priority)
        {
        return S_OK;
        }

    m_priority = Val;

    g_Manager->RetaskJob( this );

    UpdateModificationTime();

    return S_OK;
}

HRESULT
CJob::SetNotifyFlags(
    ULONG Val
    )
{

    // Note, this flag will have no affect on a callback already in progress.

    if ( Val & ~(BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR | BG_NOTIFY_DISABLE | BG_NOTIFY_JOB_MODIFICATION ) )
        {
        return E_NOTIMPL;
        }

    m_NotifyFlags = Val;

    UpdateModificationTime();
    return S_OK;
}

HRESULT
CJob::SetNotifyInterface(
    IUnknown * Val
    )
{

    // Note, this flag may not have any affect on a callback already in progress.

    IBackgroundCopyCallback *pICB = NULL;

    if ( Val )
        {
        try
            {
            CNestedImpersonation imp;

            imp.SwitchToLogonToken();

            THROW_HRESULT( SetStaticCloaking( Val ) );

            THROW_HRESULT( Val->QueryInterface( __uuidof(IBackgroundCopyCallback),
                                                (void **) &pICB ) );

            // All callbacks should happen in the context of the
            // person who set the interface pointer.

            HRESULT Hr = SetStaticCloaking( pICB );

            if ( FAILED( Hr ) )
                {
                SafeRelease( pICB );
                throw ComError( Hr );
                }
            }
        catch( ComError Error )
            {
            return Error.Error();
            }
        }

    // Release the old pointer if it exists
    SafeRelease( m_NotifyPointer );
    m_NotifyPointer = pICB;

    return S_OK;
}

HRESULT
CJob::GetNotifyInterface(
    IUnknown ** ppVal
    ) const
{
    try
        {
        CNestedImpersonation imp;

        if (m_NotifyPointer)
            {
            m_NotifyPointer->AddRef();
            }

        *ppVal = m_NotifyPointer;

        return S_OK;
        }
    catch ( ComError err )
        {
        *ppVal = NULL;
        return err.Error();
        }
}

// CJob::TestNotifyInterface()
//
// See if a notification interface is provide, if so, test it to see if it is
// valid. If so, then return TRUE, else return FALSE.
BOOL
CJob::TestNotifyInterface()
{
    BOOL fValidNotifyInterface = TRUE;

    try
        {
        CNestedImpersonation imp;
        IUnknown *pPrevIntf = NULL;

        // Ok, see if there was a previously registered interface, and if
        // there is, see if it's still valid.
        if (m_NotifyPointer)
            {
            m_NotifyPointer->AddRef();
            if ( (FAILED(m_NotifyPointer->QueryInterface(IID_IUnknown,(void**)&pPrevIntf)))
                ||(pPrevIntf == NULL) )
                {
                fValidNotifyInterface = FALSE;
                }
            else
                {
                fValidNotifyInterface = TRUE;
                pPrevIntf->Release();
                }
            m_NotifyPointer->Release();
            }
        else
            {
            fValidNotifyInterface = FALSE;
            }
        }
    catch( ComError err )
        {
        fValidNotifyInterface = FALSE;
        }

    return fValidNotifyInterface;
}

HRESULT
CJob::GetMinimumRetryDelay(
    ULONG * pVal
    ) const
{
    *pVal = m_MinimumRetryDelay;
    return S_OK;
}

HRESULT
CJob::SetMinimumRetryDelay(
    ULONG Val
    )
{
    m_MinimumRetryDelay = Val;

    g_Manager->m_TaskScheduler.RescheduleDelayedTask(
        (CJobRetryItem *)this,
        (UINT64)m_MinimumRetryDelay * (UINT64) NanoSec100PerSec);

    UpdateModificationTime();
    return S_OK;
}

HRESULT
CJob::GetNoProgressTimeout(
    ULONG * pVal
    ) const
{
    *pVal = m_NoProgressTimeout;
    return S_OK;
}

HRESULT
CJob::SetNoProgressTimeout(
    ULONG Val
    )
{
    m_NoProgressTimeout = Val;

    g_Manager->m_TaskScheduler.RescheduleDelayedTask(
        (CJobNoProgressItem *)this,
        (UINT64)m_NoProgressTimeout * (UINT64) NanoSec100PerSec);

    UpdateModificationTime();
    return S_OK;
}

HRESULT
CJob::GetErrorCount(
    ULONG * pVal
    ) const
{
    *pVal = m_retries;
    return S_OK;
}

HRESULT
CJob::SetCredentials(
    BG_AUTH_CREDENTIALS * Credentials
    )
{
    try
        {
        THROW_HRESULT( ValidateCredentials( Credentials ));

        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        //
        // Interrupt the job if it is downloading, and resume at the end of this fn.
        // This keeps the downloader from referring to the memory that we are deleting,
        // and ensures that the most current job settings are used during the download.
        //
        CRescheduleDownload r( this );

        g_Manager->ExtendMetadata( m_Credentials.GetSizeEstimate( Credentials ));

        THROW_HRESULT( m_Credentials.Update( Credentials ));

        g_Manager->Serialize();
        return S_OK;
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();
        return err.Error();
        }
}

HRESULT
CJob::RemoveCredentials(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme
    )
{
    try
        {
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        //
        // Interrupt the job if it is downloading, and resume at the end of this fn.
        // This keeps the downloader from referring to the memory that we are deleting,
        // and ensures that the most current job settings are used during the download.
        //
        CRescheduleDownload r( this );

        HRESULT hr = m_Credentials.Remove( Target, Scheme );

        THROW_HRESULT( hr );

        g_Manager->Serialize();

        return hr;  // may be S_FALSE if the credential was never in the collection
        }
    catch ( ComError err )
        {
        return err.Error();
        }

}


HRESULT
CJob::SetReplyFileName(
    LPCWSTR Val
    )
{
    return E_NOTIMPL;
}

HRESULT
CJob::GetReplyFileName(
    LPWSTR * pVal
    ) const
{
    return E_NOTIMPL;
}

HRESULT
CJob::GetReplyProgress(
    BG_JOB_REPLY_PROGRESS *pProgress
    ) const
{
    return E_NOTIMPL;
}


HRESULT
CJob::GetReplyData(
    byte **ppBuffer,
    UINT64 *pLength
    ) const
{
    return E_NOTIMPL;
}

HRESULT
CJob::IsVisible()
{
    HRESULT hr;

    hr = CheckClientAccess( BG_JOB_READ );

    if (hr == S_OK)
        {
        return S_OK;
        }

    if (hr == E_ACCESSDENIED)
        {
        return S_FALSE;
        }

    return hr;
}

bool
CJob::IsOwner(
    SidHandle sid
    )
{
    return (sid == m_NotifySid);
}

void CJob::SetState( BG_JOB_STATE state )
{
    if (m_state == state)
        {
        return;
        }

    LogInfo("job %p state %d -> %d", this, m_state, state);

    #if DBG
    CheckStateTransition( m_state, state );
    #endif

    m_state = state;

    bool ShouldClearError = false;

    switch( state )
    {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_CONNECTING:
            ShouldClearError = false;
            break;

        case BG_JOB_STATE_TRANSFERRING:
        case BG_JOB_STATE_SUSPENDED:
            ShouldClearError = true;
            break;

        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_TRANSIENT_ERROR:
            ShouldClearError = false;
            break;

        case BG_JOB_STATE_TRANSFERRED:
        case BG_JOB_STATE_ACKNOWLEDGED:
        case BG_JOB_STATE_CANCELLED:
            ShouldClearError = true;
            break;

        default:
            ASSERT(0);
            break;
    }

    if (ShouldClearError)
       m_error.ClearError();

    if (state != BG_JOB_STATE_TRANSIENT_ERROR)
        {
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobRetryItem *) this );
        }

    UpdateModificationTime( false );
}

#if DBG

bool
CJob::CheckStateTransition(
    BG_JOB_STATE Old,
    BG_JOB_STATE New
    )
{
    bool ok = true;

    switch (Old)
        {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_TRANSFERRED:
            {
            break;
            }

        case BG_JOB_STATE_TRANSFERRING:
            {
            if (New == BG_JOB_STATE_CONNECTING)
                {
                ok = false;
                }
            break;
            }

        case BG_JOB_STATE_ACKNOWLEDGED:
        case BG_JOB_STATE_CANCELLED:
        default:
            {
            ok = false;
            break;
            }
        }

    if (!ok)
        {
        ASSERT( "invalid state transition" );
        #if DBG
        DbgPrint("old state is %d, new state is %d", Old, New );
        #endif
        }

    #if DBG
    //
    // Check for the stress failure where a download job with all files transferred goes into ERROR state.
    //
    if (New == BG_JOB_STATE_TRANSIENT_ERROR ||
        New == BG_JOB_STATE_ERROR)
        {
        if (m_type == BG_JOB_TYPE_DOWNLOAD && GetCurrentFile() == NULL)
            {
            DbgPrint("assert failure: BITS: transferred job %p going into error state.  assign the failure to jroberts\n", this);
            DbgBreakPoint();
            }
        }
    #endif

    return ok;
}

#endif

GENERIC_MAPPING CJob::s_AccessMapping =
{
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_ALL
};

HRESULT
CJob::CheckClientAccess(
    IN DWORD RequestedAccess
    ) const
/*

    Checks the current thread's access to this group.  The token must allow impersonation.

    RequestedAccess lists the standard access bits that the client needs.

*/
{
    HRESULT hr = S_OK;
    BOOL fSuccess = FALSE;
    DWORD AllowedAccess = 0;
    HANDLE hToken = 0;

    //
    // Convert generic bits into specific bits.
    //
    MapGenericMask( &RequestedAccess, &s_AccessMapping );

    try
        {

        if ( ( RequestedAccess & ~BG_JOB_READ ) &&
             ( ( m_state == BG_JOB_STATE_CANCELLED ) || ( m_state == BG_JOB_STATE_ACKNOWLEDGED ) ) )
            {
            LogError("Denying non-read access since job/file is cancelled or acknowledged");
            throw ComError(BG_E_INVALID_STATE);
            }

        CNestedImpersonation imp;

        if (imp.CopySid() == g_GlobalInfo->m_AnonymousSid)
            {
            throw ComError( E_ACCESSDENIED );
            }

        hr = IsRemoteUser();

        if (FAILED(hr) )
            throw ComError( hr );

        if ( S_OK == hr )
            throw ComError( BG_E_REMOTE_NOT_SUPPORTED );

        if (IsTokenRestricted( imp.QueryToken()))
            {
            throw ComError( E_ACCESSDENIED );
            }

        THROW_HRESULT(
            m_sd->CheckTokenAccess( imp.QueryToken(),
                                    RequestedAccess,
                                    &AllowedAccess,
                                    &fSuccess
                                    ));

        if (!fSuccess || AllowedAccess != RequestedAccess)
            {
            LogWarning( "denied access %s 0x%x", fSuccess ? "TRUE" : "FALSE", AllowedAccess );

            throw ComError( E_ACCESSDENIED );
            }

        hr = S_OK;
        }
    catch (ComError exception)
        {
        hr = exception.Error();
        }

    if (hToken)
        {
        CloseHandle( hToken );
        }

    return hr;
}

bool
CJob::IsCallbackEnabled(
    DWORD bit
    )
{
    //
    // Only one bit, please.
    //
    ASSERT( 0 == (bit & (bit-1)) );

    if ((m_NotifyFlags & bit) == 0 ||
        (m_NotifyFlags & BG_NOTIFY_DISABLE))
        {
        return false;
        }

    if (m_OldExternalGroupInterface)
        {
        IBackgroundCopyCallback1 * pif = m_OldExternalGroupInterface->GetNotificationPointer();

        if (pif == NULL)
            {
            return false;
            }

        pif->Release();
        }
    else
        {
        if (m_NotifyPointer == NULL && m_NotifyProgram.Size() == 0)
            {
            return false;
            }
        }

    return true;
}

void
CJob::ScheduleCompletionCallback(
    DWORD Seconds
    )
{
    //
    // See whether any notification regime has been established.
    // The callback procedure will check this again, in case something has changed
    // between queuing the workitem and dispatching it.
    //
    if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
        {
        LogInfo("completion callback is not enabled");
        return;
        }

    if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( static_cast<CJobCallbackItem *>(this) ))
        {
        LogInfo("callback is already scheduled");
        return;
        }

    g_Manager->ScheduleDelayedTask( (CJobCallbackItem *) this, Seconds );
}

void
CJob::ScheduleErrorCallback(
    DWORD Seconds
    )
{
    //
    // See whether any notification regime has been established.
    // The callback procedure will check this again, in case something has changed
    // between queuing the workitem and dispatching it.
    //
    if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
        {
        LogInfo("error callback is not enabled");
        return;
        }

    if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( static_cast<CJobCallbackItem *>(this) ))
        {
        LogInfo("callback is already scheduled");
        return;
        }

    g_Manager->ScheduleDelayedTask( (CJobCallbackItem *) this, Seconds );
}

void
CJob::JobTransferred()
{
    // the file list is done
    SetState( BG_JOB_STATE_TRANSFERRED );

    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *>( this ));

    SetCompletionTime();

    ScheduleCompletionCallback();
}

void
CJob::Transfer()
{
    HRESULT hr;
    auto_HANDLE<NULL> AutoToken;

    if( LogLevelEnabled( LogFlagInfo ) )
       {
       LogDl( "current job: %!guid!", &m_id );
       }

    //
    // Get a copy of the user's token.
    //
    HANDLE      hToken = NULL;
    hr = g_Manager->CloneUserToken( GetOwnerSid(), ANY_SESSION, &hToken );

    if (FAILED(hr))
        {
        if (hr == HRESULT_FROM_WIN32( ERROR_NOT_LOGGED_ON ))
            {
            LogDl( "job owner is not logged on");

            // move the group off the main list.
            g_Manager->MoveJobOffline( this );

            RecalcTransientError();
            }
        else
            {
            LogError( "download : unable to get token %!winerr!", hr);

            QMErrInfo err( QM_FILE_TRANSIENT_ERROR, SOURCE_QMGR_QUEUE, ERROR_STYLE_HRESULT, hr, "CloneUserToken" );
            SetTransientError( err, m_CurrentFile, false, false );
            }

        g_Manager->m_TaskScheduler.CompleteWorkItem();
        return;
        }

    AutoToken = hToken;

    //
    // Download the current file.
    //
    QMErrInfo ErrInfo;
    long tries = 0;

    bool bThrottle = ShouldThrottle();

    LogDl( "Throttling %s", bThrottle ? "enabled" : "disabled" );

    if (bThrottle)
        {
        // ignore errors
        //
        (void) SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );
        }

    if (m_state != BG_JOB_STATE_TRANSFERRING)
        {
        SetState( BG_JOB_STATE_CONNECTING );
        ScheduleModificationCallback();
        }

    if (!VerifyFileSizes( hToken ))
        {
        goto restore_thread;
        }

    ASSERT( GetCurrentFile() );     // if no more files, it shouldn't be the current job

retry:
    ErrInfo.Clear();

    if (!GetCurrentFile()->Transfer( hToken,
                                     m_priority,
                                     m_ProxySettings,
                                     &m_Credentials,
                                     ErrInfo ))
        {
        goto restore_thread;
        }

    //
    // Interpret the download result.
    //
    switch (ErrInfo.result)
        {
        case QM_FILE_TRANSIENT_ERROR: FileTransientError( &ErrInfo ); break;
        case QM_FILE_DONE:            FileComplete();                 break;
        case QM_FILE_FATAL_ERROR:     FileFatalError( &ErrInfo );     break;
        case QM_FILE_ABORTED:         break;
        default:                      ASSERT( 0 && "unhandled download result" ); break;

        case QM_SERVER_FILE_CHANGED:
            {
            FileChangedOnServer();

            if (++tries < 3)
                {
                goto retry;
                }

            ErrInfo.result = QM_FILE_FATAL_ERROR;
            ErrInfo.Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_INVALID_SERVER_RESPONSE );
            FileFatalError( &ErrInfo );
            break;
            }
        }

restore_thread:

    if (bThrottle)
        {
        while (!SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL ))
            {
            Sleep(100);
            }
        }
}

void
CJob::FileComplete()
{
    if ( GetOldExternalJobInterface() )
        {
        // Need to rename the files as they are completed for Mars.
        HRESULT Hr = GetCurrentFile()->MoveTempFile();
        if (FAILED(Hr))
            {
            QMErrInfo ErrorInfo;
            ErrorInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, Hr, "Unable to rename file" );
            FileFatalError( &ErrorInfo );
            return;
            }
        }

    ++m_CurrentFile;

    if (m_CurrentFile == m_files.size())
        {
        JobTransferred();
        g_Manager->Serialize();
        }
    else
        {
        // more files to download
        ScheduleModificationCallback();

        //
        // To avoid hammering the disk,
        // don't serialize every interim progress notification.
        //
        FILETIME time;
        GetSystemTimeAsFileTime( &time );

        if (FILETIMEToUINT64(time) - FILETIMEToUINT64(m_SerializeTime) > PROGRESS_SERIALIZE_INTERVAL )
            {
            UpdateModificationTime();
            }
        else
            SetModificationTime( &time );
        }
}

bool CJob::VerifyFileSizes(
    HANDLE hToken
    )
{
    if ( m_FilesVerified )
        return true;

    if ( AreRemoteSizesKnown() )
        {
        m_FilesVerified = true;
        return true;
        }

    try
        {
        // retrieve file infomation on the file list.
        // Ignore any errors.
        LogDl("Need to retrieve file sizes before download can start");

        auto_ptr<CUnknownFileSizeList> pFileSizeList = auto_ptr<CUnknownFileSizeList>( GetUnknownFileSizeList() );

        QMErrInfo   ErrInfo;

        //
        // Release the global lock while the download is in progress.
        //
        g_Manager->m_TaskScheduler.UnlockWriter();

        LogDl( "UpdateRemoteSizes starting..." );

        g_Manager->UpdateRemoteSizes( pFileSizeList.get(),
                                      hToken,
                                      &ErrInfo,
                                      &m_ProxySettings,
                                      &m_Credentials
                                      );

        LogDl( "UpdateRemoteSizes complete." );

        ErrInfo.Log();

        ASSERT( ErrInfo.result != QM_IN_PROGRESS );

        bool fSuccessful = (ErrInfo.result != QM_FILE_ABORTED);

        //
        // Take the writer lock, since the caller expects it to be taken
        // upon return.
        //
        while (g_Manager->m_TaskScheduler.LockWriter() )
            {
            g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
            fSuccessful = false;
            }

        return fSuccessful;
        }
    catch (ComError err)
        {
        LogWarning("caught exception %u", err.Error() );
        return false;
        }
}

bool CJob::IsRunning()
{
    if (m_state == BG_JOB_STATE_TRANSFERRING ||
        m_state == BG_JOB_STATE_CONNECTING)
        {
        return true;
        }

    return false;
}


bool CJob::IsRunnable()
{
    if (m_fVolumeLocked)
        {
        return false;
        }

    if (m_state == BG_JOB_STATE_TRANSFERRING ||
        m_state == BG_JOB_STATE_CONNECTING   ||
        m_state == BG_JOB_STATE_QUEUED )
        {
        return true;
        }

    return false;
}

void
CJob::SetTransientError(
    QMErrInfo & ErrInfo,
    LONG FileIndex,
    bool fRetryLater,
    bool fUpdateTime
    )
{
    LogWarning( "job %p transient failure, interrupt count = %d", this, m_retries );

    if (_GetState() == BG_JOB_STATE_TRANSFERRING)
        {
        ++m_retries;
        }

    //
    // This is written to work withc both upload and download jobs.
    // Be sure that an upload job never transits from CANCELLING state back to QUEUED
    // or TRANSIENT_ERROR.
    //
    if (m_state != BG_JOB_STATE_CANCELLED &&
        m_state != BG_JOB_STATE_ACKNOWLEDGED)
        {
        SetState( BG_JOB_STATE_TRANSIENT_ERROR );
        }
    else
        {
        ASSERT( m_type != BG_JOB_TYPE_DOWNLOAD );
        }

    RecordError( &ErrInfo, FileIndex );

    if ( m_NoProgressTimeout != INFINITE &&
        !g_Manager->m_TaskScheduler.IsWorkItemInScheduler((CJobNoProgressItem *) this))
        {
        g_Manager->ScheduleDelayedTask( (CJobNoProgressItem *) this, m_NoProgressTimeout );
        }

    if (fRetryLater && !g_Manager->m_TaskScheduler.IsWorkItemInScheduler(static_cast<CJobRetryItem *>( this )))
        {
        g_Manager->ScheduleDelayedTask( static_cast<CJobRetryItem *>( this ), m_MinimumRetryDelay );
        }

    if (fUpdateTime)
        {
        UpdateModificationTime();
        }
}

bool
CJob::RecordError(
    QMErrInfo * ErrInfo,
    LONG FileIndex
    )
{
    m_error.Set( this, FileIndex, ErrInfo );
    return true;
}

CFile *
CJob::_GetFileIndex( LONG index ) const
{
    if (index < 0)
        {
        LogError("invalid file index %d", index );
        return NULL;
        }

    if (index >= m_files.size())
        {
        return NULL;
        }

    return m_files[ index ];
}

void
CJob::FileTransientError(
    QMErrInfo * ErrInfo
    )
{
    SetTransientError( *ErrInfo, m_CurrentFile, true, true );
}

void
CJob::FileFatalError(
    QMErrInfo * ErrInfo
    )
/*
    Puts the job into ERROR state, cancelling any existing callback and no-progress timer
    and scheduling a new error callback.

    If ErrInfo is non-NULL, then the existing error info is overwritten with the new data.
    Otherwise the existing info is retained.  This is useful for the no-progress timeout.

*/
{
    if ( BG_JOB_STATE_TRANSFERRING == m_state )
        {
        ++m_retries;
        }

    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *>(this) );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobCallbackItem *>(this) );

    SetState( BG_JOB_STATE_ERROR );

    if ( ErrInfo )
        {
        RecordError( ErrInfo, m_CurrentFile );
        }

    ScheduleErrorCallback();
    g_Manager->Serialize();
}

void CJob::OnRetryJob()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    ASSERT( m_state == BG_JOB_STATE_TRANSIENT_ERROR );

    SetState( BG_JOB_STATE_QUEUED );

    g_Manager->AppendOnline( this );
    UpdateModificationTime();

    g_Manager->ScheduleAnotherGroup();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

void CJob::RetryNow()
{
    RecalcTransientError();
    UpdateModificationTime( false );

    //
    // Normally UpdateModificationTime() would do these things for us,
    // but we chose not to serialize.
    //
    if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( (CJobInactivityTimeout *) this))
        {
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobInactivityTimeout *) this );
        g_Manager->m_TaskScheduler.InsertDelayedWorkItem( (CJobInactivityTimeout *) this, g_GlobalInfo->m_JobInactivityTimeout );
        }
}

void CJob::OnNoProgress()
{
    LogInfo("job %p no-progress timeout", this);

    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    //
    // Make sure the downloader thread isn't using the job.
    // Otherwise MoveActiveJobToListEnd may get confused.
    //
    switch (m_state)
        {
        case BG_JOB_STATE_TRANSFERRING:
            {
            // The job is making progress, after all.
            //
            g_Manager->m_TaskScheduler.CompleteWorkItem();

            g_Manager->m_TaskScheduler.UnlockWriter();
            return;
            }

        case BG_JOB_STATE_CONNECTING:
            {
            g_Manager->InterruptDownload();
            break;
            }
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    FileFatalError( NULL );

    g_Manager->ScheduleAnotherGroup();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

void CJob::UpdateProgress(
    UINT64 BytesTransferred,
    UINT64 BytesTotal
    )
{
    //
    // Upload jobs may see their progress reset to zero if the server changes;
    // better to leave the job in CONNECTING state in that situation.
    // The test is harmless for download jobs.
    //
    if (BytesTransferred > 0)
        {
        SetState( BG_JOB_STATE_TRANSFERRING );
        }

    g_Manager->m_TaskScheduler.CancelWorkItem( (CJobNoProgressItem *) this );

    ScheduleModificationCallback();

    //
    // To avoid hammering the disk,
    // don't serialize every interim progress notification.
    //
    FILETIME time;
    GetSystemTimeAsFileTime( &time );

    if (FILETIMEToUINT64(time) - FILETIMEToUINT64(m_SerializeTime) > PROGRESS_SERIALIZE_INTERVAL )
        {
        UpdateModificationTime();
        }
}

void CJob::OnInactivityTimeout()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    try
        {
        //
        // Temp files will be deleted using the local system account, because we cannot guarantee
        // that any other account is available.  Although not ideal, it should not provide much of a
        // security breach because the file names were generated by BITS, and the directory was
        // accessible to the job owner when the files were created.
        //
        THROW_HRESULT( RemoveTemporaryFiles() );

        SetState( BG_JOB_STATE_CANCELLED );

        RemoveFromManager();
        }
    catch ( ComError err )
        {
        }

    g_Manager->m_TaskScheduler.UnlockWriter();
}

BOOL IsInterfacePointerDead(
    IUnknown * punk,
    HRESULT hr
    )
{
    if (hr == MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE ))
        {
        return TRUE;
        }

    return FALSE;
}


void CJob::OnMakeCallback()
/*++

Description:

    Used to notify the client app of job completion or a non-recoverable error.
    Impersonates the user, CoCreates a notification object, and calls the method.
    If the call fails, the fn posts a delayed task to retry.

At entry:

        m_method:       the method to call
        m_notifysid:    the user to impersonate
        m_error:        (if m_method is CM_ERROR)    the error that halted the job
                        (if m_method is CM_COMPLETE) zero
        m_RetryTime:    sleep time before retrying after a failed notification attempt

At exit:


--*/

{
    //
    // check for cancel, and take a reference so the job cannot be deleted
    // while this precedure is using it.
    //
    if (g_Manager->m_TaskScheduler.LockReader())
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    bool OldInterface = (m_OldExternalGroupInterface != NULL);

    GetExternalInterface()->AddRef();

    g_Manager->m_TaskScheduler.UnlockReader();

    //
    // Need to have this item out of the queue before the call,
    // otherwise an incoming CompleteJob() call may block trying to remove it
    // from the task scheduler queue.
    // Also prevents CancelWorkItem calls from interfering with our mutex access.
    //
    g_Manager->m_TaskScheduler.CompleteWorkItem();

    if (OldInterface)
        {
        if (FAILED(OldInterfaceCallback()))
            {
            RescheduleCallback();
            }
        }
    else
        {
        if (FAILED(InterfaceCallback()) &&
            FAILED(CmdLineCallback()))
            {
            RescheduleCallback();
            }
        }

    GetExternalInterface()->Release();
}

HRESULT
CJob::RescheduleCallback()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        LogInfo( "callback was cancelled" );
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return S_FALSE;
        }

    switch (m_state)
        {
        case BG_JOB_STATE_TRANSFERRED:
            {
            ScheduleCompletionCallback( m_MinimumRetryDelay );
            break;
            }

        case BG_JOB_STATE_ERROR:
            {
            ScheduleErrorCallback( m_MinimumRetryDelay );
            break;
            }

        default:
            {
            LogInfo("callback failed; job state is %d so no retry is planned", m_state );
            }
        }

    g_Manager->m_TaskScheduler.UnlockWriter();

    return S_OK;
}

void
CJob::OnModificationCallback()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        LogInfo( "Modification call cancelled, ack cancel" );
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    if (!IsCallbackEnabled( BG_NOTIFY_JOB_MODIFICATION ))
        {
        LogInfo( "Modification call cancelled via flag/interface change" );
        m_ModificationsPending = 0;
        g_Manager->m_TaskScheduler.CancelWorkItem(
            g_Manager->m_TaskScheduler.GetCurrentWorkItem());
        GetExternalInterface()->Release();

        g_Manager->m_TaskScheduler.UnlockWriter();
        return;
        }

    IBackgroundCopyCallback *pICB = m_NotifyPointer;
    pICB->AddRef();

    g_Manager->m_TaskScheduler.UnlockWriter();

    HRESULT Hr = pICB->JobModification( GetExternalInterface(), 0 );

    LogInfo( "JobModification call complete, result %!winerr!", Hr );

    SafeRelease( pICB );

    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        LogInfo( "Modification work item canceled before lock reaquire" );
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    m_ModificationsPending--;

    if ( FAILED(Hr) && IsInterfacePointerDead( m_NotifyPointer, Hr ) )
       {
       LogInfo( "Modification interface pointer is dead, no more modifications" );
       m_ModificationsPending = 0;
       }

    if ( m_ModificationsPending )
        {
        LogInfo( "%u more modification callbacks pending, reinsert work item", m_ModificationsPending );
        g_Manager->m_TaskScheduler.InsertWorkItem( static_cast<CJobModificationItem*>(this) );
        }
    else
        {
        LogInfo( "no more modification callbacks pending, release interface ref" );
        GetExternalInterface()->Release();
        }

    g_Manager->m_TaskScheduler.UnlockWriter();

}

void
CJob::ScheduleModificationCallback()
{

    // Requires writer lock

    //
    // The old interface doesn't support this.
    //
    if (m_OldExternalGroupInterface)
        {
        return;
        }

    if (!IsCallbackEnabled( BG_NOTIFY_JOB_MODIFICATION ))
        {
        return;
        }

   if ( !m_ModificationsPending )
       {
       LogInfo( "New modification callback, adding work item for job %p", this );
       GetExternalInterface()->AddRef();
       g_Manager->m_TaskScheduler.InsertWorkItem( static_cast<CJobModificationItem*>(this) );
       }

   m_ModificationsPending++;
   min( m_ModificationsPending, 0x7FFFFFFE );
   LogInfo( "Added modification callback, new count of %u for job %p", m_ModificationsPending, this );
}

HRESULT
CJob::InterfaceCallback()
{
    bool bLocked = true;
    HRESULT hr;
    IBackgroundCopyCallback * pICB = 0;
    IBackgroundCopyError *    pJobErrorExternal = 0;

    try
        {
        CallbackMethod method;
        IBackgroundCopyJob * pJobExternal = 0;

        {
        HoldReaderLock lock ( g_Manager->m_TaskScheduler );

        pJobExternal = GetExternalInterface();

        //
        // It is possible that the job state changed after the callback was queued.
        // Make the callback based on the current job state.
        //
        if (!m_NotifyPointer)
            {
            LogInfo( "Notification pointer for job %p is NULL, skipping callback", this );
            return E_FAIL;
            }

        switch (m_state)
            {
            case BG_JOB_STATE_TRANSFERRED:
                {
                if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_COMPLETE;
                break;
                }

            case BG_JOB_STATE_ERROR:
                {
                ASSERT( m_error.IsErrorSet() );

                if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_ERROR;
                pJobErrorExternal = new CJobErrorExternal( &m_error );
                break;
                }

            default:
                {
                LogInfo("callback has become irrelevant, job state is %d", m_state );
                return S_OK;
                }
            }

        pICB = m_NotifyPointer;
        pICB->AddRef();
        }

        //
        // Free from the mutex, make the call.
        //
        switch (method)
            {
            case CM_COMPLETE:
                LogInfo( "callback : job %p completion", this );
                hr = pICB->JobTransferred( pJobExternal );
                break;

            case CM_ERROR:
                LogInfo( "callback : job %p error", this );
                hr = pICB->JobError( pJobExternal, pJobErrorExternal );

                break;

            default:
                LogError( "job %p: invalid callback type 0x%x", this, method );
                hr = S_OK;
                break;
            }

        LogInfo("callback completed with 0x%x", hr);

        //
        // Clear the notification pointer if it is unusable.
        //
        if (FAILED(hr))
            {
            HoldWriterLock lock ( g_Manager->m_TaskScheduler );

            if (m_NotifyPointer && IsInterfacePointerDead( m_NotifyPointer, hr ))
                {
                m_NotifyPointer->Release();
                m_NotifyPointer = NULL;
                }

            throw ComError( hr );
            }

        hr = S_OK;
        }
    catch ( ComError exception )
        {
        LogWarning( "exception %x while dispatching callback", exception.Error() );
        hr = exception.Error();
        }

    SafeRelease( pJobErrorExternal );
    SafeRelease( pICB );

    return hr;
}

HRESULT
CJob::CmdLineCallback()
{
    ASSERT( GetOldExternalGroupInterface() == 0 );

    HRESULT hr;
    CUser * user = 0;

    try
        {
        StringHandle Program;
        StringHandle Parameters;

        {
        HoldReaderLock lock ( g_Manager->m_TaskScheduler );

        switch (m_state)
            {
            case BG_JOB_STATE_TRANSFERRED:
                {
                if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                break;
                }

            case BG_JOB_STATE_ERROR:
                {
                ASSERT( m_error.IsErrorSet() );

                if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                break;
                }

            default:
                {
                LogInfo("callback has become irrelevant, job state is %d", m_state );
                return S_OK;
                }
            }

        Program = m_NotifyProgram;
        Parameters = m_NotifyParameters;
        }

        //
        // Free from the mutex, launch the application.
        //
        user = g_Manager->m_Users.FindUser( GetOwnerSid(), ANY_SESSION );
        if (!user)
            {
            throw ComError( HRESULT_FROM_WIN32( ERROR_NOT_LOGGED_ON ));
            }

        THROW_HRESULT( user->LaunchProcess( Program, Parameters ) );

        hr = S_OK;
        }
    catch ( ComError err )
        {
        LogWarning( "exception %x while launching callback process", err.Error() );
        hr = err.Error();
        }

    if (user)
        {
        user->DecrementRefCount();
        }

    return hr;
}

HRESULT
CJob::OldInterfaceCallback()
{

   HRESULT Hr = S_OK;
   IBackgroundCopyCallback1 *pICB = NULL;
   IBackgroundCopyGroup *pGroup = NULL;
   IBackgroundCopyJob1 *pJob = NULL;

   try
        {
        CallbackMethod method;
        DWORD dwCurrentFile = 0;
        DWORD dwRetries = 0;
        DWORD dwWin32Result = 0;
        DWORD dwTransportResult = 0;

        {
        CLockedJobReadPointer LockedJob(this);

        pGroup = GetOldExternalGroupInterface();
        ASSERT( pGroup );
        pGroup->AddRef();

        //
        // It is possible that the job state changed after the callback was queued.
        // Make the callback based on the current job state.
        //
        pICB = GetOldExternalGroupInterface()->GetNotificationPointer();
        if (!pICB)
            {
            return S_FALSE;
            }

        switch (m_state)
            {
            case BG_JOB_STATE_TRANSFERRED:
                {
                if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_COMPLETE;
                break;
                }

            case BG_JOB_STATE_ERROR:
                {
                ASSERT( m_error.IsErrorSet() );

                if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_ERROR;

                pJob = GetOldExternalJobInterface();
                pJob->AddRef();

                dwCurrentFile = m_error.GetFileIndex();
                m_error.GetOldInterfaceErrors( &dwWin32Result, &dwTransportResult );
                THROW_HRESULT( GetErrorCount(&dwRetries) );
                break;
                }

            default:
                {
                LogInfo("callback has become irrelevant, job state is %d", m_state );
                return S_OK;
                }
            }
        }

        // Outside of lock, do the callback
        switch( method )
            {
            case CM_ERROR:
                THROW_HRESULT( pICB->OnStatus(pGroup, pJob, dwCurrentFile,
                                              QM_STATUS_GROUP_ERROR | QM_STATUS_GROUP_SUSPENDED,
                                              dwRetries,
                                              dwWin32Result,
                                              dwTransportResult) );
                break;
            case CM_COMPLETE:
                THROW_HRESULT( pICB->OnStatus(pGroup, NULL, -1, QM_STATUS_GROUP_COMPLETE, 0, 0, 0));

                GetOldExternalGroupInterface()->SetNotificationPointer( __uuidof(IBackgroundCopyCallback1),
                                                                        NULL );

                break;
            default:
                ASSERT(0);
                throw ComError( E_FAIL );
            }

        Hr = S_OK;
        }

    catch ( ComError exception )
        {
        LogWarning( "exception %x while dispatching callback", exception.Error() );
        Hr = exception.Error();
        }

   SafeRelease( pICB );
   SafeRelease( pGroup );
   SafeRelease( pJob );

   return Hr;
}

//
// Pause all activity on the job.  The service will take no action until one of
// Resume(), Cancel(), Complete() is called.
//
// if already suspended, just returns S_OK.
//
HRESULT
CJob::Suspend()
{
    return g_Manager->SuspendJob( this );
}

//
// Enable downloading for this job.
//
// if already running, just returns S_OK.
//
HRESULT
CJob::Resume()
{
    if (IsEmpty())
        {
        return BG_E_EMPTY;
        }

    switch (m_state)
        {
        case BG_JOB_STATE_SUSPENDED:
            {
            CFile * file = GetCurrentFile();
            if (!file)
                {
                // job was already transferred when it was suspended
                JobTransferred();
                return S_OK;
                }
            }

            // fall through here

        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_ERROR:

            RecalcTransientError( true );

            if (IsRunnable())
                {
                g_Manager->AppendOnline( this );
                }

            g_Manager->ScheduleAnotherGroup();
            UpdateModificationTime();

            return S_OK;

        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSFERRED: // no-op
            {
            return S_OK;
            }

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return S_OK;
            }
        }

    ASSERT( 0 );
    return S_OK;
}

//
// Permanently stop the job.  The service will delete the job metadata and downloaded files.
//
HRESULT
CJob::Cancel()
{
    HRESULT Hr = S_OK;

    switch (m_state)
        {
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
            {
            g_Manager->InterruptDownload();
            // OK to fall through here
            }

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_TRANSFERRED:
            {
            try
                {
                //
                // For file deletion to work, we need IMPERSONATE level impersonation,
                // not the COM default of IDENTIFY.
                //
                CNestedImpersonation imp;

                imp.SwitchToLogonToken();

                RETURN_HRESULT( NonOwnerModificationCheck( imp.CopySid(), CHG_CANCEL, PROP_NONE ));

                // abandon temporary files
                RETURN_HRESULT( Hr = RemoveTemporaryFiles() );

                SetState( BG_JOB_STATE_CANCELLED );

                RemoveFromManager();

                return Hr;
                }
            catch ( ComError err )
                {
                return err.Error();
                }
            }

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return Hr;
            }
        }

    ASSERT( 0 );
    return Hr;
}

//
// Acknowledges receipt of the job-complete notification.  The service will delete
// the job metadata and leave the downloaded files.
//
HRESULT
CJob::Complete( )
{
    HRESULT hr;

    switch (m_state)
        {
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:

            Suspend();
            // OK to fall through here

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_TRANSFERRED:

            hr = S_OK;

            // move downloaded files to final destination(skip for Mars)
            if ( !GetOldExternalJobInterface() )
                {
                RETURN_HRESULT( hr = CommitTemporaryFiles() );
                }

            // hr may be S_OK, or BG_S_PARTIAL_COMPLETE.

            SetState( BG_JOB_STATE_ACKNOWLEDGED );

            RemoveFromManager();

            return hr;

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return BG_E_INVALID_STATE;
            }
        }

    ASSERT(0);
    return BG_E_INVALID_STATE;
}


HRESULT
CJob::CommitTemporaryFiles()
{
    HRESULT Hr = S_OK;

    try
        {
        bool fPartial = false;
        CNestedImpersonation imp( GetOwnerSid() );

        CFileList::iterator iter;

        LogInfo("commit job %p", this );

        //
        // First loop, rename completed temp files.
        //
        SIZE_T FilesMoved = 0;
        for (iter = m_files.begin(); iter != m_files.end(); ++iter, FilesMoved++)
            {
            if (false == (*iter)->IsCompleted())
                {
                if ((*iter)->ReceivedAllData())
                    {
                    //
                    // Retain the first error encountered.
                    //
                    HRESULT LastResult = (*iter)->MoveTempFile();

                    if (FAILED(LastResult))
                        {
                        LogError( "commit: failed 0x%x", LastResult );
                        if (Hr == S_OK)
                            {
                            Hr = LastResult;
                            }
                        }
                    }
                else
                    {
                    fPartial = true;
                    LogInfo("commit: skipping partial file '%S'", (const WCHAR*)(*iter)->GetLocalName());
                    }
                }
            else
                {
                LogInfo("commit: skipping previously completed file '%S'", (const WCHAR*)(*iter)->GetLocalName());
                }
            }

        if (SUCCEEDED(Hr))
            {
            Hr = RemoveTemporaryFiles();

            //
            // Return S_OK if all files are returned, otherwise BG_S_PARTIAL_COMPLETE.
            //
            if (fPartial)
                {
                Hr = BG_S_PARTIAL_COMPLETE;
                }
            }
        }
    catch ( ComError exception )
        {
        Hr = exception.Error();
        LogError( "commit: exception 0x%x", Hr );
        }

    //
    // If commitment failed, the job will not be deleted.
    // Update its modification time, and schedule the modification callback.
    //
    if (FAILED(Hr))
        {
        UpdateModificationTime();
        }

    return Hr;
}

HRESULT
CJob::RemoveTemporaryFiles(
    DWORD StartingIndex
    )
/*

    This fn deletes the temporary local files of the job.  It attempts to keep track of failures
    and log an event, but failures in this part will not cause the fn to abort.

*/
{
    CFileList * FailedFiles = NULL;

    //
    // Delete each temporary file.  Record failures in FailedFiles, if possible.
    //
    for (CFileList::iterator iter = m_files.begin() + StartingIndex; iter != m_files.end(); ++iter)
        {
        if (false == (*iter)->IsCompleted())
            {
            HRESULT hr = (*iter)->DeleteTempFile();
            if (FAILED(hr) && IsReportableFileDeletionError(hr, (*iter)->GetTemporaryName()))
                {
                try
                    {
                    if (!FailedFiles)
                        {
                        FailedFiles = new CFileList;
                        }
                    FailedFiles->push_back( *iter );
                    }
                catch ( ComError err )
                    {
                    // ignore failures
                    }
                }
            }
        }

    //
    // If some files were not deleted, log an event with their names.
    //
    if (FailedFiles && FailedFiles->size() > 0)
        {
        LogUnsuccessfulFileDeletion( *FailedFiles );

        delete FailedFiles;
        return BG_S_UNABLE_TO_DELETE_FILES;
        }

    ASSERT( FailedFiles == NULL );

    return S_OK;
}

void
CJob::LogUnsuccessfulFileDeletion(
    CFileList & files
    )
/*

This function generates an event log entry when BITS is not able to delete temporary files.

*/
{
    int FileCount = 0;
    size_t CharCount = 0;

    const WCHAR Template[] = L"    %s\n";

    //
    // Record the total length of the files we are going to log.
    //
    CFileList::iterator iter = files.begin();
    while (iter != files.end() && (++FileCount < MAX_LOGGED_UNSUCCESSFUL_FILES))
        {
        CharCount += ((*iter)->GetTemporaryName().Size() + RTL_NUMBER_OF(Template));   //
        ++iter;
        }

    LogInfo("%d temp files were not deleted", FileCount);

    WCHAR * FileNames = new WCHAR[ CharCount+1 ];

    WCHAR * Start = FileNames;
    WCHAR * End;

    //
    // Construct the string of all files.
    //
    HRESULT hr;

    FileCount = 0;
    iter = files.begin();
    while (iter != files.end() && (++FileCount < MAX_LOGGED_UNSUCCESSFUL_FILES))
        {
        hr = StringCchPrintfEx(
            Start,
            CharCount,
            &End,
            &CharCount,
            0, // no special flags
            Template,
            LPCWSTR( (*iter)->GetTemporaryName() )
            );

        Start = End;

        if (FAILED(hr))
            {
            LogWarning("printf on file %d failed with %x", FileCount, hr);
            break;
            }

        ++iter;
        }

    //
    // Log the event.
    //
    bool fMoreFiles = (iter != files.end());

    g_EventLogger->ReportFileDeletionFailure( m_id, m_name, FileNames, fMoreFiles );

    delete [] FileNames;
}

void
CJob::SetCompletionTime( const FILETIME *pftCompletionTime )
{
    FILETIME ftCurrentTime;
    if ( !pftCompletionTime )
        {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        pftCompletionTime = &ftCurrentTime;
        }

    m_TransferCompletionTime = *pftCompletionTime;

    SetModificationTime( pftCompletionTime );
}

void
CJob::SetModificationTime( const FILETIME *pftModificationTime )
{
    FILETIME ftCurrentTime;
    if ( !pftModificationTime )
        {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        pftModificationTime = &ftCurrentTime;
        }

    m_ModificationTime = *pftModificationTime;
}

void
CJob::SetLastAccessTime( const FILETIME *pftModificationTime )
{
    FILETIME ftCurrentTime;
    if ( !pftModificationTime )
        {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        pftModificationTime = &ftCurrentTime;
        }

    m_LastAccessTime = *pftModificationTime;
}

void
CJob::OnDiskChange(
    const WCHAR *CanonicalVolume,
    DWORD VolumeSerialNumber )
{
    switch(m_state)
        {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        break;

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        return;

        case BG_JOB_STATE_TRANSIENT_ERROR:
        break;

        case BG_JOB_STATE_TRANSFERRED:
        case BG_JOB_STATE_ACKNOWLEDGED:
        case BG_JOB_STATE_CANCELLED:
        return;

        default:
            ASSERTMSG("Invalid job state", 0);
        }

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        if (!(*iter)->OnDiskChange( CanonicalVolume, VolumeSerialNumber ))
            {
            // If one file fails, the whole job fails.
            return;
            }
        }
}

void
CJob::OnDismount(
    const WCHAR *CanonicalVolume )
{
    switch(m_state)
        {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        break;

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        return;

        case BG_JOB_STATE_TRANSIENT_ERROR:
        break;

        case BG_JOB_STATE_TRANSFERRED:
        case BG_JOB_STATE_ACKNOWLEDGED:
        case BG_JOB_STATE_CANCELLED:
        return;

        default:
            ASSERTMSG("Invalid job state", 0);
        }

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        if (!(*iter)->OnDismount( CanonicalVolume ))
            {
            // If one file fails, the whole job fails.
            return;
            }
        }
}

bool CJob::IsTransferringToDrive( const WCHAR *CanonicalVolume )
{
    CFile *CurrentFile = GetCurrentFile();
    if ( !CurrentFile )
        return false;

    if ( CurrentFile->IsCanonicalVolume( CanonicalVolume ) )
        return true;
    else
        return false;
}

bool
CJob::OnDeviceLock(
    const WCHAR * CanonicalVolume
    )
{

    LogInfo( "job %p", this );


    //
    // Currently this same code works for all jobs, upload and download.
    // If this code changes in a way that breaks upload jobs in CANCELLING state,
    // then you will need to write CUploadJob::OnDeviceLock and OnDeviceUnlock.
    //

    if ( IsTransferringToDrive( CanonicalVolume ) )
        {
        if (IsRunning() )
            {
            g_Manager->InterruptDownload();
            }

        m_fVolumeLocked = true;

        RecalcTransientError();
        return true;
        }

    return false;
}

bool
CJob::OnDeviceUnlock(
    const WCHAR * CanonicalVolume
    )
{

    LogInfo( "job %p", this );

    //
    // Currently this same code works for all jobs, upload and download.
    // If this code changes in a way that breaks upload jobs in CANCELLING state,
    // then you will need to write CUploadJob::OnDeviceLock and OnDeviceUnlock.
    //

    if ( IsTransferringToDrive( CanonicalVolume ) )
        {
        m_fVolumeLocked = false;

        RecalcTransientError();
        return true;
        }

    return false;
}

void CJob::OnNetworkDisconnect()
{
    RecalcTransientError();
}

void CJob::OnNetworkConnect()
{
    RecalcTransientError();
}

void CJob::RecalcTransientError( bool ForResume )
{

    if ( !ForResume )
        {

        if ( BG_JOB_STATE_ERROR == m_state ||
             BG_JOB_STATE_TRANSFERRED == m_state ||
             BG_JOB_STATE_SUSPENDED == m_state )
            return;

        }

    BG_JOB_STATE OldState = m_state;
    CJobError OldError = m_error;

    //
    // This is written to work withc both upload and download jobs.
    // Be sure that an upload job never transits from CANCELLING state back to QUEUED
    // or TRANSIENT_ERROR.
    //
    if (m_state != BG_JOB_STATE_CANCELLED &&
        m_state != BG_JOB_STATE_ACKNOWLEDGED)
        {
        SetState( BG_JOB_STATE_QUEUED );
        }
    else
        {
        ASSERT( m_type != BG_JOB_TYPE_DOWNLOAD );
        }

    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobRetryItem *>( this ));

    if (m_fVolumeLocked)
        {
        QMErrInfo err( QM_FILE_TRANSIENT_ERROR, SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_DESTINATION_LOCKED, NULL );
        SetTransientError( err, m_CurrentFile, false, false );
        }
    else if (g_Manager->m_NetworkMonitor.GetAddressCount() == 0)
        {
        QMErrInfo err( QM_FILE_TRANSIENT_ERROR, SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_NETWORK_DISCONNECTED, NULL );
        SetTransientError( err, m_CurrentFile, false, false );
        }

    if (m_state != OldState ||
        !(m_error == OldError))
        {
        ScheduleModificationCallback();
        }

    //
    // SetTransientError has a similar test, but RecalcTransientError always sets the job to QUEUED state.
    // Thus, the SetTransientError test will never succeed when called from here.
    //
    if (OldState == BG_JOB_STATE_TRANSFERRING &&
        m_state == BG_JOB_STATE_TRANSIENT_ERROR)
        {
        ++m_retries;
        }
}

HRESULT
CJob::TakeOwnership()
{
    HRESULT Hr = S_OK;

    CJobSecurityDescriptor *newsd = NULL;

    try
        {
        SidHandle sid =  GetThreadClientSid();

        // If we are being called by the current
        // owner, then we have nothing to do.

        if ( sid == m_NotifySid )
            return S_OK;

        if ( IsRunning() )
            {
            g_Manager->InterruptDownload();
            }

        // revalidate access to all the local files

        for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
            {
            Hr = (*iter)->ValidateAccessForUser( sid,
                                                 (m_type == BG_JOB_TYPE_DOWNLOAD) ? true : false );

            if (FAILED(Hr))
                {
                g_Manager->ScheduleAnotherGroup();
                return Hr;
                }
            }

        // actually reassign ownership

        SidHandle OldSid = m_NotifySid;

        g_Manager->ExtendMetadata();

        newsd = new CJobSecurityDescriptor( sid );

        // replace the old notify sid and SECURITY_DESCRIPTOR
        delete m_sd;

        m_sd = newsd;
        m_NotifySid = sid;

        //
        // Clear explicit credentials, because they are too important to leave open to the new owner.
        // Also clear the notification command line, because it will be run in the context of the new owner.
        // This could be the basis for a Trojan horse.  The COM notification is not affected because it always
        // makes calls as the original owner.
        //
        m_Credentials.Clear();

        m_NotifyProgram = NULL;
        m_NotifyParameters = NULL;

        //
        // Move the job to the online list if necessary.
        //
        g_Manager->ResetOnlineStatus( this, sid );

        //
        // Serialize and notify the client app of changes.
        //
        UpdateModificationTime();

        //
        // The old qmgr interface automatically changes the owner during each call to GetGroupInternal.
        // Don't record those ownership changes.
        //
        if (NULL == GetOldExternalGroupInterface())
            {
            g_EventLogger->ReportJobOwnershipChange( m_id, m_name, OldSid, sid );
            }

        g_Manager->ScheduleAnotherGroup();
        return Hr;
        }
    catch( ComError Error )
        {
        Hr = Error.Error();
        delete newsd;
        g_Manager->ScheduleAnotherGroup();
        g_Manager->ShrinkMetadata();
        return Hr;
        }
}

CUnknownFileSizeList*
CJob::GetUnknownFileSizeList()
{
    auto_ptr<CUnknownFileSizeList> pList( new CUnknownFileSizeList );

    if (m_type == BG_JOB_TYPE_DOWNLOAD)
        {
        for(CFileList::iterator iter = m_files.begin(); iter != m_files.end(); iter++ )
             {
             if ( (*iter)->_GetBytesTotal() == -1 )
                 {
                 if (!pList->Add( (*iter), (*iter)->GetRemoteName() ) )
                     {
                     throw ComError( E_OUTOFMEMORY );
                     }
                 }
             }
        }

    return pList.release();
}

void
CJob::UpdateModificationTime(
    bool   fNotify
    )
{
    FILETIME ftCurrentTime;

    GetSystemTimeAsFileTime( &ftCurrentTime );

    SetModificationTime( &ftCurrentTime );

    UpdateLastAccessTime( );

    if (fNotify)
        {
        if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( (CJobInactivityTimeout *) this))
            {
            g_Manager->m_TaskScheduler.CancelWorkItem( (CJobInactivityTimeout *) this );
            g_Manager->m_TaskScheduler.InsertDelayedWorkItem( (CJobInactivityTimeout *) this, g_GlobalInfo->m_JobInactivityTimeout );
            }

        ScheduleModificationCallback();
        g_Manager->Serialize();
        }
}

void
CJob::UpdateLastAccessTime(
    )
{
    FILETIME ftCurrentTime;

    GetSystemTimeAsFileTime( &ftCurrentTime );

    SetLastAccessTime( &ftCurrentTime );
}

void CJob::CancelWorkitems()
{
    ASSERT( g_Manager );

    //
    // While the job-modification item is pending, it keeps a separate ref to the job.
    // The other work items share a single ref.
    //
    // g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobModificationItem *> (this)  );

    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobInactivityTimeout *> (this) );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *> (this)    );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobCallbackItem *> (this)      );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobRetryItem *> (this)         );
}

void
CJob::RemoveFromManager()
{
    //
    // The job is dead, except perhaps for a few references held by app threads.
    // Ensure that no more action is taken on this job.
    //
    CancelWorkitems();

    //
    // If the job is not already removed from the job list, remove it
    // and remove the refcount for the job's membership in the list.
    //
    if (g_Manager->RemoveJob( this ))
        {
        g_Manager->ScheduleAnotherGroup();
        g_Manager->Serialize();
        NotifyInternalDelete();
        }
}

HRESULT
CJob::SetLimitedString(
    StringHandle & destination,
    const LPCWSTR Val,
    SIZE_T limit
    )
{
    try
        {
        StringHandle name = Val;

        // If the string is too long then reject it...
        if (name.Size() > limit)
            {
            return BG_E_STRING_TOO_LONG;
            }

        UpdateString( destination, name );

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
CJob::UpdateString(
    StringHandle & destination,
    const StringHandle & Val
    )
{
    try
        {
        if ( destination.Size() < Val.Size() )
            g_Manager->ExtendMetadata( sizeof(wchar_t) * (Val.Size() - destination.Size()) );

        destination = Val;

        UpdateModificationTime();

        return S_OK;
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();

        return err.Error();
        }
}

HRESULT
CJob::ExcludeFilesFromBackup(
    IN IVssCreateWriterMetadata *pMetadata
    )
{
    // defined in cmanager.cpp next to other backup writer code
    //
    extern void AddExcludeFile(
        IN IVssCreateWriterMetadata *pMetadata,
        LPCWSTR FileName
        );

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        try
            {
            if (false == (*iter)->IsCompleted())
                {
                AddExcludeFile( pMetadata, (*iter)->GetTemporaryName());
                }
            }
        catch ( ComError err )
            {
            return err.m_error;
            }
        }

    return S_OK;
}


//------------------------------------------------------------------------

// Change the GUID  when an incompatible Serialize change is made.

GUID UploadJobGuid_v1_5 = { /* 42a25c7d-96b2-483e-a225-e2f102b6a30b */
    0x42a25c7d,
    0x96b2,
    0x483e,
    {0xa2, 0x25, 0xe2, 0xf1, 0x02, 0xb6, 0xa3, 0x0b}
  };

GUID DownloadJobGuid_v1_5 = { /* 0b73f1e8-2f4c-44de-8533-98092b34a18b */
    0x0b73f1e8,
    0x2f4c,
    0x44de,
    {0x85, 0x33, 0x98, 0x09, 0x2b, 0x34, 0xa1, 0x8b}
  };

GUID DownloadJobGuid_v1_2 = { /* 85e5c459-ef86-4fcd-8ea0-5b4f00d27e35 */
    0x85e5c459,
    0xef86,
    0x4fcd,
    {0x8e, 0xa0, 0x5b, 0x4f, 0x00, 0xd2, 0x7e, 0x35}
  };

GUID DownloadJobGuid_v1_0 = { /* 5770fca4-cf9f-4513-8737-972b4ea1265d */
    0x5770fca4,
    0xcf9f,
    0x4513,
    {0x87, 0x37, 0x97, 0x2b, 0x4e, 0xa1, 0x26, 0x5d}
  };

/* static */
CJob *
CJob::UnserializeJob(
    HANDLE hFile
    )
{
#define JOB_DOWNLOAD_V1_5   0
#define JOB_UPLOAD_V1_5     1
#define JOB_DOWNLOAD_V1     2
#define JOB_DOWNLOAD_V1_2   3

    const GUID * JobGuids[] =
        {
        &DownloadJobGuid_v1_5,
        &UploadJobGuid_v1_5,
        &DownloadJobGuid_v1_0,
        &DownloadJobGuid_v1_2,
        NULL
        };

    CJob * job = NULL;

    try
        {
        int Type = SafeReadGuidChoice( hFile, JobGuids );
        switch (Type)
            {
            case JOB_DOWNLOAD_V1:   job = new CJob;        break;
            case JOB_DOWNLOAD_V1_2: job = new CJob;        break;
            case JOB_DOWNLOAD_V1_5: job = new CJob;        break;
            case JOB_UPLOAD_V1_5:   job = new CUploadJob;  break;

            default: THROW_HRESULT( E_FAIL );
            }

        // rewind  to the front of the GUID
        //
        SetFilePointer( hFile, -1 * LONG(sizeof(GUID)), NULL, FILE_CURRENT );

        job->Unserialize( hFile, Type );
        }
    catch( ComError err )
        {
        if (job)
            {
            job->UnlinkFromExternalInterfaces();
            delete job;
            }

        throw;
        }

    return job;
}

HRESULT
CJob::Serialize(
    HANDLE hFile
    )
{
    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    SafeWriteBlockBegin( hFile, DownloadJobGuid_v1_5 );

    long Was_m_refs = 0;
    SafeWriteFile( hFile, Was_m_refs );

    SafeWriteFile( hFile, m_priority );
    SafeWriteFile( hFile, IsRunning() ? BG_JOB_STATE_QUEUED : m_state );
    SafeWriteFile( hFile, m_type );
    SafeWriteFile( hFile, m_id );

    SafeWriteStringHandle( hFile, m_name );
    SafeWriteStringHandle( hFile, m_description );
    SafeWriteStringHandle( hFile, m_NotifyProgram );
    SafeWriteStringHandle( hFile, m_NotifyParameters );

    SafeWriteSid( hFile, m_NotifySid );

    SafeWriteFile( hFile, m_NotifyFlags );
    SafeWriteFile( hFile, m_fGroupNotifySid );
    SafeWriteFile( hFile, m_CurrentFile );

    m_sd->Serialize( hFile );
    m_files.Serialize( hFile );

    m_error.Serialize( hFile );

    SafeWriteFile( hFile, m_retries );
    SafeWriteFile( hFile, m_MinimumRetryDelay );
    SafeWriteFile( hFile, m_NoProgressTimeout );

    SafeWriteFile( hFile, m_CreationTime );
    SafeWriteFile( hFile, m_LastAccessTime );
    SafeWriteFile( hFile, m_ModificationTime );
    SafeWriteFile( hFile, m_TransferCompletionTime );

    if ( GetOldExternalGroupInterface() )
        {
        SafeWriteFile( hFile, (bool)true );
        GetOldExternalGroupInterface()->Serialize( hFile );
        }
    else
        {
        SafeWriteFile( hFile, (bool)false );
        }

    SafeWriteFile( hFile, m_method );

    ((CJobInactivityTimeout *) this)->Serialize( hFile );
    ((CJobNoProgressItem *) this)->Serialize( hFile );
    ((CJobCallbackItem *) this)->Serialize( hFile );
    ((CJobRetryItem *) this)->Serialize( hFile );

    SafeWriteFile( hFile, m_ProxySettings.ProxyUsage );
    SafeWriteFile( hFile, m_ProxySettings.ProxyList );
    SafeWriteFile( hFile, m_ProxySettings.ProxyBypassList );

    m_Credentials.Serialize( hFile );

    SafeWriteBlockEnd( hFile, DownloadJobGuid_v1_5 );

    GetSystemTimeAsFileTime( &m_SerializeTime );
    return S_OK;
}

void
CJob::Unserialize(
    HANDLE hFile,
    int Type
    )
{
    try
        {
        switch (Type)
            {
            case JOB_DOWNLOAD_V1:
                LogInfo("unserializing v1.0 job %p", this);
                SafeReadBlockBegin( hFile, DownloadJobGuid_v1_0 );
                break;
            case JOB_DOWNLOAD_V1_2:
                LogInfo("unserializing v1.2 job %p", this);
                SafeReadBlockBegin( hFile, DownloadJobGuid_v1_2 );
                break;

            case JOB_UPLOAD_V1_5:
            case JOB_DOWNLOAD_V1_5:
                LogInfo("unserializing v1.5 job %p", this);
                SafeReadBlockBegin( hFile, DownloadJobGuid_v1_5 );
                break;

            default:
                ASSERT( 0 );
            }

        long Was_m_refs = 0;
        SafeReadFile( hFile, &Was_m_refs );

        SafeReadFile( hFile, &m_priority );
        SafeReadFile( hFile, &m_state );
        SafeReadFile( hFile, &m_type );
        SafeReadFile( hFile, &m_id );

        m_name = SafeReadStringHandle( hFile );
        m_description = SafeReadStringHandle( hFile );

        switch (Type)
            {
            case JOB_DOWNLOAD_V1:
                break;

            case JOB_DOWNLOAD_V1_2:
                // The 1.2 version internally allowed for a single notification command line,
                // even though this was not exposed by the 1.0 interface.  Ignore it.
                //
                {
                StringHandle Unused = SafeReadStringHandle( hFile );
                break;
                }

            case JOB_DOWNLOAD_V1_5:
            case JOB_UPLOAD_V1_5:
                m_NotifyProgram = SafeReadStringHandle( hFile );
                m_NotifyParameters = SafeReadStringHandle( hFile );
                break;

            default:
                ASSERT( 0 );
            }

        SafeReadSid( hFile, m_NotifySid );

        SafeReadFile( hFile, &m_NotifyFlags );
        SafeReadFile( hFile, &m_fGroupNotifySid );
        SafeReadFile( hFile, &m_CurrentFile );

        m_sd = CJobSecurityDescriptor::Unserialize( hFile );
        m_files.Unserialize( hFile, this );

        m_error.Unserialize( hFile, this );

        SafeReadFile( hFile, &m_retries );
        SafeReadFile( hFile, &m_MinimumRetryDelay );
        SafeReadFile( hFile, &m_NoProgressTimeout );

        SafeReadFile( hFile, &m_CreationTime );
        SafeReadFile( hFile, &m_LastAccessTime );
        SafeReadFile( hFile, &m_ModificationTime );
        SafeReadFile( hFile, &m_TransferCompletionTime );

        bool bHasOldExternalGroupInterface = false;
        SafeReadFile( hFile, &bHasOldExternalGroupInterface );

        if (bHasOldExternalGroupInterface)
            {
            COldGroupInterface *OldGroup = COldGroupInterface::UnSerialize( hFile, this );
            SetOldExternalGroupInterface( OldGroup );
            }

        SafeReadFile( hFile, &m_method );

        ((CJobInactivityTimeout *) this)->Unserialize( hFile );
        ((CJobNoProgressItem *) this)->Unserialize( hFile );
        ((CJobCallbackItem *) this)->Unserialize( hFile );
        ((CJobRetryItem *) this)->Unserialize( hFile );

        SafeReadFile( hFile, &m_ProxySettings.ProxyUsage );
        SafeReadFile( hFile, &m_ProxySettings.ProxyList );
        SafeReadFile( hFile, &m_ProxySettings.ProxyBypassList );

        if (Type != JOB_DOWNLOAD_V1)
            {
            m_Credentials.Unserialize( hFile );
            }

        m_fVolumeLocked = false;

        switch (Type)
            {
            case JOB_DOWNLOAD_V1:   SafeReadBlockEnd( hFile, DownloadJobGuid_v1_0 ); break;
            case JOB_DOWNLOAD_V1_2: SafeReadBlockEnd( hFile, DownloadJobGuid_v1_2 ); break;
            case JOB_UPLOAD_V1_5:   SafeReadBlockEnd( hFile, DownloadJobGuid_v1_5 ); break;
            case JOB_DOWNLOAD_V1_5: SafeReadBlockEnd( hFile, DownloadJobGuid_v1_5 ); break;
            default:                THROW_HRESULT( E_INVALIDARG );                   break;
            }
        }
    catch( ComError Error )
        {
        LogError("invalid job data, exception 0x%x at line %d", Error.m_error, Error.m_line);
        throw;
        }
}

CUploadJob::CUploadJob(
    LPCWSTR     DisplayName,
    BG_JOB_TYPE Type,
    REFGUID     JobId,
    SidHandle   NotifySid
    )
    : CJob( DisplayName, Type, JobId, NotifySid ),
      m_ReplyFile( 0 )
{
}

CUploadJob::~CUploadJob()
{
    delete m_ReplyFile;
}

HRESULT
CUploadJob::Serialize(
    HANDLE hFile
    )
{
    LogInfo("serializing upload job %p", this);

    SafeWriteBlockBegin( hFile, UploadJobGuid_v1_5 );

    CJob::Serialize( hFile );

    // additional data not in a download job
    //
    m_UploadData.Serialize( hFile );

    SafeWriteFile( hFile, m_fOwnReplyFileName );
    SafeWriteStringHandle( hFile, m_ReplyFileName );

    if (m_ReplyFile)
        {
        SafeWriteFile( hFile, true );
        m_ReplyFile->Serialize( hFile );
        }
    else
        {
        SafeWriteFile( hFile, false );
        }

    SafeWriteBlockEnd( hFile, UploadJobGuid_v1_5 );

    return S_OK;
}

void
CUploadJob::Unserialize(
    HANDLE hFile,
    int Type
    )
{
    ASSERT( Type == JOB_UPLOAD_V1_5 );

    LogInfo("unserializing upload job %p", this);

    SafeReadBlockBegin( hFile, UploadJobGuid_v1_5 );

    CJob::Unserialize( hFile, Type );

    // additional data not in a download job
    //
    m_UploadData.Unserialize( hFile );

    SafeReadFile( hFile, &m_fOwnReplyFileName );
    m_ReplyFileName = SafeReadStringHandle( hFile );

    bool fReplyFile;
    SafeReadFile( hFile, &fReplyFile );

    if (fReplyFile)
        {
        m_ReplyFile = CFile::Unserialize( hFile, this );
        }

    SafeReadBlockEnd( hFile, UploadJobGuid_v1_5 );

    if (m_state == BG_JOB_STATE_CANCELLED ||
        m_state == BG_JOB_STATE_ACKNOWLEDGED)
        {
        if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler(static_cast<CJobRetryItem *>(this)))
            {
            m_UploadData.fSchedulable = false;
            }
        }
}


CFile *
CUploadJob::_GetFileIndex( LONG index ) const
{
    if (index == REPLY_FILE_INDEX)
        {
        return m_ReplyFile;
        }

    if (index == NO_FILE_INDEX)
        {
        return NULL;
        }

    if (index < 0)
        {
        LogError("invalid index %d", index);
        return NULL;
        }

    if (index >= m_files.size())
        {
        return NULL;
        }

    return m_files[ index ];
}


UPLOAD_DATA::UPLOAD_DATA()
{
    State = UPLOAD_STATE_CREATE_SESSION;
    fSchedulable = true;

    Protocol = GUID_NULL;

    HostId = NULL;
    HostIdFallbackTimeout = 0xFFFFFFFF;

    memset( &HostIdNoProgressStartTime, 0, sizeof(HostIdNoProgressStartTime) );
}

UPLOAD_DATA::~UPLOAD_DATA()
{
}

void
UPLOAD_DATA::SetUploadState(
    UPLOAD_STATE NewState
    )
{
    if (State != NewState)
        {
        LogInfo( "upload state: %d -> %d", State, NewState );
        State = NewState;
        }
}

void
UPLOAD_DATA::Serialize(
    HANDLE hFile
    )
{
    SafeWriteFile( hFile, State );
    SafeWriteFile( hFile, Protocol );

    SafeWriteStringHandle( hFile, SessionId );
    SafeWriteStringHandle( hFile, ReplyUrl );
    SafeWriteStringHandle( hFile, HostId );
    SafeWriteFile( hFile, HostIdFallbackTimeout );
    SafeWriteFile( hFile, HostIdNoProgressStartTime );

}

void
UPLOAD_DATA::Unserialize(
    HANDLE hFile
    )
{

    SafeReadFile( hFile, &State );
    SafeReadFile( hFile, &Protocol );

    SessionId = SafeReadStringHandle( hFile );
    ReplyUrl = SafeReadStringHandle( hFile );
    HostId   = SafeReadStringHandle( hFile );
    SafeReadFile( hFile, &HostIdFallbackTimeout );
    SafeReadFile( hFile, &HostIdNoProgressStartTime );

    fSchedulable = true;

}


HRESULT
CUploadJob::GetReplyData(
    byte **ppBuffer,
    UINT64 *pLength
    ) const
{
    if (!ppBuffer || !pLength)
        {
        return E_INVALIDARG;
        }

    *pLength = 0;
    *ppBuffer = 0;

    if (m_type != BG_JOB_TYPE_UPLOAD_REPLY)
        {
        return E_NOTIMPL;
        }

    if (m_state != BG_JOB_STATE_TRANSFERRED &&
        m_state != BG_JOB_STATE_ACKNOWLEDGED)
        {
        return BG_E_INVALID_STATE;
        }

    byte * buffer = 0;

    try
        {
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        //
        // Open the file.
        //
        auto_HANDLE<INVALID_HANDLE_VALUE> hFile;

        hFile = CreateFile( (m_state == BG_JOB_STATE_ACKNOWLEDGED)
                                ? m_ReplyFile->GetLocalName()
                                : m_ReplyFile->GetTemporaryName(),
                            GENERIC_READ,
                            0,                              // no file sharing
                            NULL,                           // gneeric security descriptor
                            OPEN_EXISTING,
                            0,
                            NULL                            // no template file
                            );

        if (hFile.get() == INVALID_HANDLE_VALUE)
            {
            ThrowLastError();
            }

        //
        // Allocate a buffer.
        //
        LARGE_INTEGER size;
        if (!GetFileSizeEx( hFile.get(), &size ))
            {
            ThrowLastError();
            }

        if ( size.QuadPart > MAX_EASY_REPLY_DATA )
            {
            *pLength = size.QuadPart;
            THROW_HRESULT( BG_E_TOO_LARGE );
            }

        buffer = (byte *) CoTaskMemAlloc( size.QuadPart );
        if (!buffer)
            {
            THROW_HRESULT( E_OUTOFMEMORY );
            }

        //
        // Read the file data.
        //
        DWORD BytesRead;

        if (!ReadFile( hFile.get(),
                       buffer,
                       size.QuadPart,
                       &BytesRead,
                       0 ))   // no OVERLAPPED
            {
            ThrowLastError();
            }

        if (BytesRead != size.QuadPart)
            {
            throw ComError( E_FAIL );
            }

        //
        // store it in the user pointers.
        //
        *pLength = BytesRead;
        *ppBuffer = buffer;

        return S_OK;
        }
    catch ( ComError err )
        {
        if (buffer)
            {
            CoTaskMemFree( buffer );
            }
        return err.Error();
        }
}


HRESULT
CUploadJob::SetReplyFileName(
    LPCWSTR Val
    )
{
    if (m_type != BG_JOB_TYPE_UPLOAD_REPLY)
        {
        return E_NOTIMPL;
        }

    if (m_ReplyFile)
        {
        return BG_E_INVALID_STATE;
        }

    try
        {
        StringHandle name = Val;

        //
        // Impersonate the user while checking file access.
        //
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        if (Val)
            {
            RETURN_HRESULT( CFile::VerifyLocalFileName( Val, BG_JOB_TYPE_DOWNLOAD ));
            }

        //
        // Four cases:
        //
        // 1. new name NULL, old name NULL:
        //    no change
        //
        // 2. new name NULL, old name non-NULL:
        //    overwrite the file name, set ownership correctly.  No need to
        //    delete the old file because it wasn't created yet.
        //
        // 3. new name non-NULL, old name NULL:
        //    overwrite the file name, set ownership correctly.  Delete the
        //    temporary old file name.
        //
        // 4. new name non-NULL, old name non-NULL:
        //    overwrite the file name.  no file to delete.
        //
        if (name.Size() > 0)
            {
            THROW_HRESULT( BITSCheckFileWritability( name ));

            DeleteGeneratedReplyFile();

            THROW_HRESULT( UpdateString( m_ReplyFileName, name));

            m_fOwnReplyFileName = false;
            }
        else
            {
            THROW_HRESULT( UpdateString( m_ReplyFileName, name));

            (void) GenerateReplyFile( false );
            }

        g_Manager->Serialize();

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
CUploadJob::GetReplyFileName(
    LPWSTR * pVal
    ) const
{
    if (m_ReplyFileName.Size() == 0)
        {
        *pVal = NULL;
        return S_OK;
        }

    *pVal = MidlCopyString( m_ReplyFileName );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CUploadJob::GetReplyProgress(
    BG_JOB_REPLY_PROGRESS *pProgress
    ) const
{
    if (m_type != BG_JOB_TYPE_UPLOAD_REPLY)
        {
        return E_NOTIMPL;
        }

    if (m_ReplyFile)
        {
        pProgress->BytesTotal       = m_ReplyFile->_GetBytesTotal();
        pProgress->BytesTransferred = m_ReplyFile->_GetBytesTransferred();
        }
    else
        {
        pProgress->BytesTotal       = BG_SIZE_UNKNOWN;
        pProgress->BytesTransferred = 0;
        }

    return S_OK;
}

HRESULT
CUploadJob::Resume()
{
    if (m_type == BG_JOB_TYPE_UPLOAD_REPLY)
        {
        RETURN_HRESULT( GenerateReplyFile(true ) );
        }

    return CJob::Resume();
}

HRESULT
CUploadJob::GenerateReplyFile(
    bool fSerialize
    )
{
    if (0 != wcscmp( m_ReplyFileName, L"" ))
        {
        return S_OK;
        }

    //
    // Gotta create a reply file name.
    //
    try
        {
        if (IsEmpty())
            {
            return BG_E_EMPTY;
            }

        g_Manager->ExtendMetadata();

        //
        // Impersonate the user while checking file access.
        //
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        StringHandle Ignore;
        StringHandle Directory = BITSCrackFileName( GetUploadFile()->GetLocalName(), Ignore );

        m_ReplyFileName = BITSCreateTempFile( Directory );

        m_fOwnReplyFileName = true;

        if (fSerialize)
            {
            g_Manager->Serialize();
            }

        return S_OK;
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();
        return err.Error();
        }
}

HRESULT
CUploadJob::DeleteGeneratedReplyFile()
{
    if (m_fOwnReplyFileName && wcslen( m_ReplyFileName ) > 0)
        {
        if (!DeleteFile( m_ReplyFileName ))
            {
            HRESULT hr = HRESULT_FROM_WIN32( GetLastError());

            LogWarning("unable to delete generated reply file '%S', %!winerr!", LPCWSTR(m_ReplyFileName), hr);

            if (IsReportableFileDeletionError( hr, m_ReplyFileName ))
                {
                g_EventLogger->ReportFileDeletionFailure( m_id, m_name, LPCWSTR(m_ReplyFileName), false );
                }

            return hr;
            }
        }

    return S_OK;
}

void
CUploadJob::SetReplyFile(
    CFile * file
    )
{
    try
        {
        g_Manager->ExtendMetadata( file->GetSizeEstimate() );

        m_ReplyFile = file;

        g_Manager->Serialize();
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();
        throw;
        }
}

void CUploadJob::Transfer()
{
    HRESULT hr;
    HANDLE      hToken = NULL;

    if( LogLevelEnabled( LogFlagInfo ) )
       {
       LogDl( "current job: %!guid!", &m_id );
       }

    //
    // Get a copy of the user's token.
    //
    hr = g_Manager->CloneUserToken( GetOwnerSid(), ANY_SESSION, &hToken );

    if (FAILED(hr))
        {
        if (hr == HRESULT_FROM_WIN32( ERROR_NOT_LOGGED_ON ))
            {
            LogDl( "job owner is not logged on");

            // move the group off the main list.
            g_Manager->MoveJobOffline( this );

            RecalcTransientError();
            }
        else
            {
            LogError( "download : unable to get token %!winerr!", hr);

            QMErrInfo err( QM_FILE_TRANSIENT_ERROR, SOURCE_QMGR_QUEUE, ERROR_STYLE_HRESULT, hr, "CloneUserToken" );
            SetTransientError( err, m_CurrentFile, false, false );
            }

        g_Manager->m_TaskScheduler.CompleteWorkItem();
        g_Manager->ScheduleAnotherGroup();
        return;
        }

    //
    // Switch states and begin uploading.
    //
    bool bThrottle = ShouldThrottle();

    LogDl( "Throttling %s", bThrottle ? "enabled" : "disabled" );

    if (bThrottle)
        {
        // ignore errors
        //
        (void) SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );
        }

    if (m_state == BG_JOB_STATE_QUEUED)
        {
        SetState( BG_JOB_STATE_CONNECTING );
        ScheduleModificationCallback();
        }

    QMErrInfo ErrInfo;
    long tries = 0;

retry:
    ErrInfo.Clear();

    LogDl("Upload Starting, tries = %d", tries);

    ASSERT( g_Manager->m_TaskScheduler.IsWriter() );

    g_Manager->m_pPD->Upload( this,
                              GetUploadFile(),
                              hToken,
                              ErrInfo
                              );

    ASSERT( g_Manager->m_TaskScheduler.IsWriter() );

    LogDl( "Upload Ended." );

    ErrInfo.Log();

    ASSERT( ErrInfo.result != QM_IN_PROGRESS );

    if (ErrInfo.result == QM_SERVER_FILE_CHANGED && ++tries < 3)
        {
        goto retry;
        }

    //
    // Update state based on the upload result.
    //
    g_Manager->m_TaskScheduler.CompleteWorkItem();

    switch (ErrInfo.result)
        {
        case QM_FILE_TRANSIENT_ERROR: FileTransientError( &ErrInfo ); break;
        case QM_FILE_DONE:          FileComplete();               break;
        case QM_FILE_FATAL_ERROR:   FileFatalError( &ErrInfo );   break;
        case QM_FILE_ABORTED:       break;
        case QM_SERVER_FILE_CHANGED: g_Manager->AppendOnline( this ); break;
        default:                    ASSERT( 0 && "unhandled download result" ); break;
        }

    CloseHandle( hToken );

    if (bThrottle)
        {
        while (!SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL ))
            {
            Sleep(100);
            }
        }
}

HRESULT
CUploadJob::Complete()
{
    HRESULT hr;

    switch (m_state)
        {
        case BG_JOB_STATE_TRANSFERRED:

            {
            try
                {
                hr = S_OK;

                //
                // In order to manipulate files, we need to have IMPERSONATE level access rather
                // than the COM default of IDENTIFY access.  The files will be committed as the called
                // rather than the job owner (assuming they are different).
                //
                CNestedImpersonation imp;

                imp.SwitchToLogonToken();

                RETURN_HRESULT( hr = CommitReplyFile() );

                // hr may be S_OK, or BG_S_PARTIAL_COMPLETE.

                SetState( BG_JOB_STATE_ACKNOWLEDGED );

                RemoveFromManager();

                return hr;
                }
            catch ( ComError err )
                {
                return err.Error();
                }
            }

        default:
            {
            return BG_E_INVALID_STATE;
            }
        }

    ASSERT(0);
    return BG_E_INVALID_STATE;
}

HRESULT
CUploadJob::Cancel()
{
    HRESULT Hr = S_OK;

    switch (m_state)
        {
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
            {
            g_Manager->InterruptDownload();
            // OK to fall through here
            }

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_TRANSFERRED:
            {
            try
                {
                //
                // In order to manipulate files, we need to have IMPERSONATE level access rather
                // than the COM default of IDENTIFY access.  The files will be committed as the called
                // rather than the job owner (assuming they are different).
                //
                CNestedImpersonation imp;

                imp.SwitchToLogonToken();

                RETURN_HRESULT( NonOwnerModificationCheck( imp.CopySid(), CHG_CANCEL, PROP_NONE ));

                RETURN_HRESULT( Hr = RemoveReplyFile() );

                // Hr may be BG_S_UNABLE_TO_REMOVE_FILES

                SetState( BG_JOB_STATE_CANCELLED );

                //
                // If the close-session exchange has not happened yet,
                // begin a cancel-session exchange.
                //
                if (SessionInProgress())
                    {
                    LogInfo("job %p: upload session in state %d, cancelling", this, m_UploadData.State );

                    g_Manager->m_TaskScheduler.CancelWorkItem( (CJobCallbackItem *) this );

                    SetNoProgressTimeout( UPLOAD_CANCEL_TIMEOUT );

                    m_UploadData.SetUploadState( UPLOAD_STATE_CANCEL_SESSION );

                    g_Manager->ScheduleAnotherGroup();
                    g_Manager->Serialize();
                    }
                else
                    {
                    RemoveFromManager();
                    }

                return Hr;
                }
            catch ( ComError err )
                {
                return err.Error();
                }
            }

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return Hr;
            }
        }

    ASSERT( 0 );
    return Hr;
}

void
CUploadJob::FileComplete()
{
    //
    // The downloader successfully completed one of three things:
    //
    // 1. job type is UPLOAD. The file was uploaded and the session closed.
    // 2. job type is UPLOAD_REPLY.  The file was uploaded, reply downloaded, and session closed.
    // 3. either job type; an early Cancel required the job to cancel the session.
    //
    switch (m_state)
        {
        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            ASSERT (m_UploadData.State == UPLOAD_STATE_CLOSED || m_UploadData.State == UPLOAD_STATE_CANCELLED);

            RemoveFromManager();
            break;
            }

        default:
            {
            ++m_CurrentFile;

            JobTransferred();
            g_Manager->Serialize();
            }
        }
}

void
CUploadJob::UpdateProgress(
    UINT64 BytesTransferred,
    UINT64 BytesTotal
    )
{

    memset( &GetUploadData().HostIdNoProgressStartTime, 0,
            sizeof( GetUploadData().HostIdNoProgressStartTime ) );

    CJob::UpdateProgress( BytesTransferred, BytesTotal );

}

bool
CUploadJob::CheckHostIdFallbackTimeout()
{

    if ( GetUploadData().HostIdFallbackTimeout != 0xFFFFFFFF )
        {

        UINT64 HostIdNoProgressStartTime = FILETIMEToUINT64( GetUploadData().HostIdNoProgressStartTime );

        if ( HostIdNoProgressStartTime )
            {

            UINT64 TimeoutTime = HostIdNoProgressStartTime +
                GetUploadData().HostIdFallbackTimeout * NanoSec100PerSec;


            if ( TimeoutTime < HostIdNoProgressStartTime )
                return true; //wraparound


            FILETIME CurrentTimeAsFileTime;
            GetSystemTimeAsFileTime( &CurrentTimeAsFileTime );

            UINT64 CurrentTime = FILETIMEToUINT64( CurrentTimeAsFileTime );

            if ( CurrentTime > TimeoutTime )
                return true;

            }

        }

    return false;

}

void
CUploadJob::FileFatalError(
    QMErrInfo * ErrInfo
    )
{
    switch (m_state)
        {
        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            //
            // Our attempt to cancel or close the session has failed.  The job is finished.
            //
            ASSERT (m_UploadData.State == UPLOAD_STATE_CLOSE_SESSION || m_UploadData.State == UPLOAD_STATE_CANCEL_SESSION);

            RemoveFromManager();
            break;
            }

        default:
            {
            if ( CheckHostIdFallbackTimeout() )
                {
                LogError( "Reverting back to main URL since the timeout has expired" );
                FileTransientError( ErrInfo );
                return;
                }

            // If ErrInfo is NULL, use the current error.

            if ( BG_JOB_STATE_TRANSFERRING == m_state )
                {
                ++m_retries;
                }

            g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *>(this) );
            g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobCallbackItem *>(this) );

            SetState( BG_JOB_STATE_ERROR );

            if ( ErrInfo )
                {
                if (m_UploadData.State == UPLOAD_STATE_GET_REPLY)
                    {
                    RecordError( ErrInfo, REPLY_FILE_INDEX );
                    }
                else
                    {
                    RecordError( ErrInfo, m_CurrentFile );
                    }
                }

            ScheduleErrorCallback();
            g_Manager->Serialize();
            }
        }
}

void
CUploadJob::FileTransientError(
    QMErrInfo * ErrInfo
    )
{
    switch (m_state)
        {
        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            //
            // Cancelling or completing a session is not subject to the host-ID back-off policy, because
            // we do not intend to create a new session if the current one is gone.
            //
            SetTransientError( *ErrInfo, NO_FILE_INDEX, true, true );

            m_UploadData.fSchedulable = false;
            break;
            }

        default:
            {
            if (m_UploadData.State == UPLOAD_STATE_GET_REPLY)
                {
                //
                // Once the reply is generated, we do not want to back off to a different server.
                //
                SetTransientError( *ErrInfo, REPLY_FILE_INDEX, true, true );
                }
            else
                {
                //
                // Establishing a session or uploading a file is subject to the host-ID back-off policy:
                // If the HostId server has been unavailable for <HostIdFallbackTimeout> seconds,
                // then clear the HostId field and retry the upload with the original server name.
                //
                bool ShouldRevertToOriginalURL = CheckHostIdFallbackTimeout();

                if ( ShouldRevertToOriginalURL )
                    {
                    LogError( "Reverting back to main URL since the timeout has expired" );

                    GetUploadData().HostId = StringHandle();
                    GetUploadData().HostIdFallbackTimeout = 0xFFFFFFFF;

                    SetState( BG_JOB_STATE_QUEUED );
                    }
                else
                    {
                    //
                    // Note the time of first failure, if we haven't already.
                    //
                    if ( GetUploadData().HostIdFallbackTimeout != 0xFFFFFFFF &&
                              !FILETIMEToUINT64( GetUploadData().HostIdNoProgressStartTime ) )
                        {
                        GetSystemTimeAsFileTime( &GetUploadData().HostIdNoProgressStartTime );
                        }

                    SetTransientError( *ErrInfo, m_CurrentFile, true, true );
                    }
                }
            }
        }
}

void CUploadJob::OnRetryJob()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    if (m_state == BG_JOB_STATE_TRANSIENT_ERROR)
        {
        SetState( BG_JOB_STATE_QUEUED );

        g_Manager->AppendOnline( this );
        UpdateModificationTime();
        }
    else if (m_state == BG_JOB_STATE_CANCELLED ||
             m_state == BG_JOB_STATE_ACKNOWLEDGED)
        {
        m_UploadData.fSchedulable = true;
        g_Manager->AppendOnline( this );
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    g_Manager->ScheduleAnotherGroup();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

void CUploadJob::OnInactivityTimeout()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    RemoveFromManager();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

bool CUploadJob::IsTransferringToDrive( const WCHAR *CanonicalVolume )
{
    CFile *file = GetCurrentFile();
    if ( !file )
        {
        file = m_ReplyFile;

        if (!file)
            {
            return false;
            }
        }

    if ( file->IsCanonicalVolume( CanonicalVolume ) )
        return true;
    else
        return false;
}

bool CUploadJob::IsRunnable()
{
    if (m_fVolumeLocked)
        {
        return false;
        }

    switch (m_state)
        {
        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_TRANSIENT_ERROR:

            return false;

        default:

            if (m_UploadData.fSchedulable &&
                m_UploadData.State != UPLOAD_STATE_CLOSED &&
                m_UploadData.State != UPLOAD_STATE_CANCELLED )
                {
                return true;
                }

            return false;
        }
}

HRESULT
CUploadJob::RemoveReplyFile()
{
    //
    // Delete the reply file, if it was created by BITS.
    // Delete the temporary reply file
    //
    HRESULT Hr;
    HRESULT FinalHr = S_OK;

    if (FAILED( DeleteGeneratedReplyFile() ))
        {
        FinalHr = BG_S_UNABLE_TO_DELETE_FILES;
        }

    m_fOwnReplyFileName = false;

    if (m_ReplyFile)
        {
        Hr = m_ReplyFile->DeleteTempFile();

        if (FAILED(Hr))
            {
			LPCWSTR FileName = m_ReplyFile->GetTemporaryName();

            LogWarning("unable to delete temporary reply file '%S', %!winerr!", FileName, Hr);
            
			if (IsReportableFileDeletionError( Hr, FileName ))
                {
                g_EventLogger->ReportFileDeletionFailure( m_id, m_name, FileName, false );
                }

            FinalHr = BG_S_UNABLE_TO_DELETE_FILES;
            }
        }

    return FinalHr;
}

HRESULT
CUploadJob::CommitReplyFile()
{
    //
    // Commit the reply file if it is complete.
    // Otherwise, clean it up.
    //
    if (m_ReplyFile && m_ReplyFile->ReceivedAllData())
        {
        RETURN_HRESULT( m_ReplyFile->MoveTempFile() );
        }
    else
        {
        LogInfo("commit reply: skipping partial file '%S'",
                m_ReplyFile ? (const WCHAR*) m_ReplyFile->GetLocalName() : L"(null)");

        RemoveReplyFile();

        return BG_S_PARTIAL_COMPLETE;
        }

    return S_OK;
}

HRESULT CJob::NonOwnerModificationCheck(
    SidHandle CurrentSid,
    enum ChangeType Change,
    enum PropertyType Property
    )
{
    try
        {
        if (CurrentSid == m_NotifySid)
            {
            return S_OK;
            }

        switch (Change)
            {
            case CHG_CANCEL:
                {
                g_EventLogger->ReportJobCancellation( m_id, m_name, m_NotifySid, CurrentSid );
                break;
                }


            }

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
CUploadJob::ExcludeFilesFromBackup(
    IN IVssCreateWriterMetadata *pMetadata
    )
{
    // defined in cmanager.cpp next to other backup writer code
    //
    extern void AddExcludeFile(
        IN IVssCreateWriterMetadata *pMetadata,
        LPCWSTR FileName
        );

    if (m_ReplyFile && false == m_ReplyFile->IsCompleted())
        {
        try
            {
            AddExcludeFile( pMetadata, m_ReplyFile->GetTemporaryName());
            }
        catch ( ComError err )
            {
            return err.m_error;
            }
        }

    return S_OK;
}

//------------------------------------------------------------------------

GUID FileListStorageGuid = { /* 7756da36-516f-435a-acac-44a248fff34d */
    0x7756da36,
    0x516f,
    0x435a,
    {0xac, 0xac, 0x44, 0xa2, 0x48, 0xff, 0xf3, 0x4d}
  };

HRESULT
CJob::CFileList::Serialize(
    HANDLE hFile
    )
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    iterator iter;

    SafeWriteBlockBegin( hFile, FileListStorageGuid );

    DWORD count = size();

    SafeWriteFile( hFile, count );

    for (iter=begin(); iter != end(); ++iter)
        {
        (*iter)->Serialize( hFile );
        }

    SafeWriteBlockEnd( hFile, FileListStorageGuid );

    return S_OK;
}

void
CJob::CFileList::Unserialize(
    HANDLE hFile,
    CJob*  Job
    )
{
    DWORD i, count;

    SafeReadBlockBegin( hFile, FileListStorageGuid );

    SafeReadFile( hFile, &count );

    for (i=0; i < count; ++i)
        {
        CFile * file = CFile::Unserialize( hFile, Job );

        push_back( file );
        }

    SafeReadBlockEnd( hFile, FileListStorageGuid );

}

void
CJob::CFileList::Delete(
    CFileList::iterator Initial,
    CFileList::iterator Terminal
    )
{
    //
    // delete the CFile objects
    //
    iterator iter = Initial;

    while (iter != Terminal)
        {
        CFile * file = (*iter);

        ++iter;

        delete file;
        }

    //
    // erase them from the dictionary
    //
    erase( Initial, Terminal );
}


//------------------------------------------------------------------------

HRESULT CLockedJobWritePointer::ValidateAccess()
{
    HRESULT hr = CLockedWritePointer<CJob, BG_JOB_WRITE>::ValidateAccess();

    if (SUCCEEDED(hr))
        {
        m_Pointer->UpdateLastAccessTime();
        }

    return hr;
}

HRESULT CLockedJobReadPointer::ValidateAccess()
{
    HRESULT hr = CLockedReadPointer<CJob, BG_JOB_READ>::ValidateAccess();

    if (SUCCEEDED(hr))
        {
        ((CJob *) m_Pointer)->UpdateLastAccessTime();
        }

    return hr;
}


CJobExternal::CJobExternal()
    : m_ServiceInstance( g_ServiceInstance ),
      pJob( NULL ),
      m_refs(1)
{
}

CJobExternal::~CJobExternal()
{
    //
    // Delete the underlying job object, unless it was already deleted when the service stopped.
    //
    if (g_ServiceInstance != m_ServiceInstance ||
        (g_ServiceState != MANAGER_ACTIVE && g_ServiceState != MANAGER_STARTING))
        {
        return;
        }

    delete pJob;
}

STDMETHODIMP
CJobExternal::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if (iid == __uuidof(IUnknown)
        || iid == __uuidof(IBackgroundCopyJob)
#if !defined( BITS_V12 )
        || iid == __uuidof(IBackgroundCopyJob2)
#endif
        )
        {
        *ppvObject = (IBackgroundCopyJob2 *) this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "job %p, iid %!guid!, Hr %x", pJob, &iid, Hr );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG
CJobExternal::AddRef()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "job %p, refs = %d", pJob, newrefs );

    return newrefs;

    END_EXTERNAL_FUNC

}

ULONG
CJobExternal::Release()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "job %p, refs = %d", pJob, newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}


STDMETHODIMP
CJobExternal::AddFileSetInternal(
    /* [in] */ ULONG cFileCount,
    /* [size_is][in] */ BG_FILE_INFO *pFileSet
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "cFileCount %u, pFileSet %p", cFileCount, pFileSet );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->AddFileSet( cFileCount, pFileSet );
        }

    LogPublicApiEnd( "cFileCount %u, pFileSet %p", cFileCount, pFileSet );
    return Hr;
}

STDMETHODIMP
CJobExternal::AddFileInternal(
    /* [in] */ LPCWSTR RemoteUrl,
    /* [in] */ LPCWSTR LocalName
    )
{

    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "RemoteUrl %S, LocalName %S", RemoteUrl, LocalName );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->AddFile( RemoteUrl, LocalName, true );
        }
    LogPublicApiEnd( "RemoteUrl %S, LocalName %S", RemoteUrl, LocalName );
    return Hr;

}

STDMETHODIMP
CJobExternal::EnumFilesInternal(
    /* [out] */ IEnumBackgroundCopyFiles **ppEnum
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "ppEnum %p", ppEnum );
    HRESULT Hr = S_OK;

    CEnumFiles *pEnum = NULL;
    try
        {

        *ppEnum = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess());

        pEnum = new CEnumFiles;

        for (CJob::CFileList::const_iterator iter = LockedJob->m_files.begin();
             iter != LockedJob->m_files.end(); ++iter)
            {
            CFileExternal * file = (*iter)->CreateExternalInterface();

            pEnum->Add( file );

            file->Release();
            }

        *ppEnum = pEnum;

        Hr = S_OK;
        }

    catch ( ComError exception )
        {
        Hr = exception.Error();
        SafeRelease( pEnum );
        }

    LogPublicApiEnd( "ppEnum %p(%p)", ppEnum, *ppEnum );
    return Hr;
}

STDMETHODIMP
CJobExternal::SuspendInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Suspend();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::ResumeInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Resume();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::CancelInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Cancel();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::CompleteInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Complete();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetIdInternal(
    /* [out] */ GUID *pVal
    )
{
CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "GetId pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->GetId();
        }
    LogPublicApiEnd( "pVal %p(%!guid!)", pVal, pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetTypeInternal(
    /* [out] */ BG_JOB_TYPE *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->GetType();
        }
    LogPublicApiEnd( "pVal %p(%u)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetProgressInternal(
    /* [out] */ BG_JOB_PROGRESS *pVal
    )
{

    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        LockedJob->GetProgress( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetTimesInternal(
    /* [out] */ BG_JOB_TIMES *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        LockedJob->GetTimes( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetStateInternal(
    /* [out] */ BG_JOB_STATE *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->_GetState();
        }
    LogPublicApiEnd( "state %d", *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetErrorInternal(
    /* [out] */ IBackgroundCopyError **ppError
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "ppError %p", ppError );

    *ppError = NULL;

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        const CJobError *Error = LockedJob->GetError();

        if ( !Error )
            {
            Hr = BG_E_ERROR_INFORMATION_UNAVAILABLE;
            }
        else
            {
            try
                {
                *ppError = new CJobErrorExternal( Error );
                Hr = S_OK;
                }
            catch ( ComError err )
                {
                Hr = err.Error();
                }
            }
        }
    LogPublicApiEnd( "pError %p", *ppError );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetDisplayNameInternal(
    /* [in] */ LPCWSTR Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %S", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetDisplayName( Val );
        }
    LogPublicApiEnd( "Val %S", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetDisplayNameInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetDisplayName( pVal );
        }
    LogPublicApiEnd( "pVal %p(%S)", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetDescriptionInternal(
    /* [in] */ LPCWSTR Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %S", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetDescription( Val );
        }
    LogPublicApiEnd( "Val %S", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetDescriptionInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin("pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetDescription( pVal );
        }
    LogPublicApiEnd("pVal %p(%S)", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetPriorityInternal(
    /* [in] */ BG_JOB_PRIORITY Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin("Val %u", Val);
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetPriority( Val );
        }
    LogPublicApiEnd("Val %u", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetPriorityInternal(
     /* [out] */ BG_JOB_PRIORITY *pVal
     )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->_GetPriority();
        }
    LogPublicApiEnd( "pVal %p(%u)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetOwnerInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetOwner( pVal );
        }
    LogPublicApiEnd( "pVal %p(%S)", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetNotifyFlagsInternal(
    /* [in] */ ULONG Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %u", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetNotifyFlags( Val );
        }
    LogPublicApiEnd( "Val %u", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetNotifyFlagsInternal(
    /* [out] */ ULONG *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->GetNotifyFlags();
        }
    LogPublicApiEnd( "pVal %p(%u)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetNotifyInterfaceInternal(
    /* [in] */ IUnknown * Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %p", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        BOOL  fValidNotifyInterface = pJob->TestNotifyInterface();

        Hr = pJob->SetNotifyInterface( Val );

        // If there was no previous notification interface (or it's
        // no longer valid) and the job is already in the Transferred
        // state or fatal error state then go ahead and do the callback:
        if ((SUCCEEDED(Hr))&&(Val)&&(!fValidNotifyInterface))
            {
            if (pJob->_GetState() == BG_JOB_STATE_TRANSFERRED)
                {
                pJob->ScheduleCompletionCallback();
                }
            else if (pJob->_GetState() == BG_JOB_STATE_ERROR)
                {
                pJob->ScheduleErrorCallback();
                }
            }
        }

    LogPublicApiEnd( "Val %p", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetNotifyInterfaceInternal(
    /* [out] */ IUnknown ** pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetNotifyInterface( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetMinimumRetryDelayInternal(
    /* [in] */ ULONG Seconds
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %u", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetMinimumRetryDelay( Seconds );
        }
    LogPublicApiEnd( "Seconds %u", Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetMinimumRetryDelayInternal(
    /* [out] */ ULONG *Seconds
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %p", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetMinimumRetryDelay( Seconds );
        }
    LogPublicApiEnd( "Seconds %p(%u)", Seconds, *Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetNoProgressTimeoutInternal(
    /* [in] */ ULONG Seconds
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %u", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetNoProgressTimeout( Seconds );
        }
    LogPublicApiEnd( "Seconds %u", Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetNoProgressTimeoutInternal(
    /* [out] */ ULONG *Seconds
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %p", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetNoProgressTimeout( Seconds );
        }
    LogPublicApiEnd( "Seconds %p(%u)", Seconds, *Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetErrorCountInternal(
    /* [out] */ ULONG * Retries
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "retries %p", Retries );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetErrorCount( Retries );
        }
    LogPublicApiEnd( "retries %p(%u)", Retries, *Retries );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetProxySettingsInternal(
    BG_JOB_PROXY_USAGE ProxyUsage,
    LPCWSTR ProxyList,
    LPCWSTR ProxyBypassList
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "ProxyUsage %u, ProxyList %S, ProxyBypassList %S",
                       ProxyUsage,
                       ProxyList ? ProxyList : L"NULL",
                       ProxyBypassList ? ProxyBypassList : L"NULL" );

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetProxySettings( ProxyUsage, ProxyList, ProxyBypassList );
        }

    LogPublicApiEnd( "ProxyUsage %u, ProxyList %S, ProxyBypassList %S",
                     ProxyUsage,
                     ProxyList ? ProxyList : L"NULL",
                     ProxyBypassList ? ProxyBypassList : L"NULL" );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetProxySettingsInternal(
    BG_JOB_PROXY_USAGE *pProxyUsage,
    LPWSTR *pProxyList,
    LPWSTR *pProxyBypassList
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pProxyUsage %p, pProxyList %p, pProxyBypassList %p",
                       pProxyUsage, pProxyList, pProxyBypassList );

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetProxySettings( pProxyUsage, pProxyList, pProxyBypassList );
        }

    LogPublicApiEnd( "pProxyUsage %p, pProxyList %p, pProxyBypassList %p",
                     pProxyUsage, pProxyList, pProxyBypassList );

    return Hr;
}

STDMETHODIMP
CJobExternal::TakeOwnershipInternal()
{
    LogPublicApiBegin( " " );

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->TakeOwnership();
        }

    LogPublicApiEnd( " " );

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::SetNotifyCmdLineInternal(
     LPCWSTR Program,
     LPCWSTR Parameters
     )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "program '%S' parms '%S'",
                       (Program)?Program : L"?",
                       (Parameters)?Parameters : L"?" );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetNotifyCmdLine( Program, Parameters );
        }
    LogPublicApiEnd( " " );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetNotifyCmdLineInternal(
    LPWSTR *pProgram,
    LPWSTR *pParameters
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin(" ");
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetNotifyCmdLine( pProgram, pParameters );
        }
    LogPublicApiEnd( "program %p(%S), parms %p(%S)",
                     pProgram,
                     (SUCCEEDED(Hr)&&(*pProgram)) ? *pProgram : L"?",
                     pParameters,
                     (SUCCEEDED(Hr)&&(*pParameters)) ? *pParameters : L"?"
                     );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetReplyProgressInternal(
    BG_JOB_REPLY_PROGRESS *pProgress
    )
{
    LogPublicApiBegin( " " );

    CLockedJobReadPointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetReplyProgress( pProgress );
        }

    LogPublicApiEnd( "%I64d of %I64d transferred", pProgress->BytesTransferred, pProgress->BytesTotal );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetReplyDataInternal(
    byte **ppBuffer,
    UINT64 *pLength
    )
{
    LogPublicApiBegin( " " );

    CLockedJobReadPointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetReplyData( ppBuffer, pLength );
        }

    LogPublicApiEnd( " length %I64d", (pLength) ? *pLength : 0 );

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::SetReplyFileNameInternal(
    LPCWSTR Val
    )
{
    LogPublicApiBegin( "file '%S'", Val ? Val : L"(null)");

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetReplyFileName( Val );
        }

    LogPublicApiEnd( " " );

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetReplyFileNameInternal(
    LPWSTR *pReplyFileName
    )
{
    LogPublicApiBegin( " " );

    //
    // This can modify the job, if the reply file name is not yet created.
    //
    CLockedJobReadPointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetReplyFileName( pReplyFileName );
        }

    LogPublicApiEnd( "file '%S'", *pReplyFileName ? *pReplyFileName : L"(null)" );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::SetCredentialsInternal(
    BG_AUTH_CREDENTIALS * Credentials
    )
{
    LogPublicApiBegin( "cred %p, target %d, scheme %d", Credentials, Credentials->Target, Credentials->Scheme );

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetCredentials( Credentials );
        }

    LogPublicApiEnd( " " );

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::RemoveCredentialsInternal(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme
    )
{
    LogPublicApiBegin( "target %d, scheme %d", Target, Scheme );

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->RemoveCredentials( Target, Scheme );
        }

    LogPublicApiEnd( " " );

    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cjob.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.h

Abstract :

    Main header file for handling jobs and files.

Author :

Revision History :

 ***********************************************************************/
#include "qmgrlib.h"
#include <vector>
#include <list>
#include <xstring>
#include <stllock.h>
#include <limits.h>
#include "clist.h"

//
// Job Specific Access Rights.
//

#define BG_JOB_QUERY_PROP       (0x0001)
#define BG_JOB_SET_PROP         (0x0002)
#define BG_JOB_NOTIFY           (0x0004)
#define BG_JOB_MANAGE           (0x0008)

#define BG_JOB_ALL_ACCESS   ( BG_JOB_QUERY_PROP |\
                              BG_JOB_SET_PROP   |\
                              BG_JOB_NOTIFY     |\
                              BG_JOB_MANAGE )

#define BG_JOB_READ         ( STANDARD_RIGHTS_READ |\
                              BG_JOB_QUERY_PROP )

#define BG_JOB_WRITE        ( STANDARD_RIGHTS_WRITE |\
                              BG_JOB_SET_PROP       |\
                              BG_JOB_NOTIFY         |\
                              BG_JOB_MANAGE )

#define BG_JOB_EXECUTE      ( STANDARD_RIGHTS_EXECUTE )


class CFile;
class CJob;
class CJobError;
class CEnumJobs;
class CEnumFiles;
class CJobManager;
class CJobExternal;
class CFileExternal;

class CJobInactivityTimeout : public TaskSchedulerWorkItem
{
public:
    virtual void OnInactivityTimeout() = 0;
    virtual void OnDispatch() { return OnInactivityTimeout(); }
};

class CJobNoProgressItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnNoProgress() = 0;
    virtual void OnDispatch() { return OnNoProgress(); }
};

class CJobCallbackItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnMakeCallback() = 0;
    virtual void OnDispatch() { return OnMakeCallback(); }

protected:

    enum CallbackMethod
        {
        CM_COMPLETE,
        CM_ERROR
        }
    m_method;
};

class CJobRetryItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnRetryJob() = 0;
    virtual void OnDispatch() { return OnRetryJob(); }
};

class CJobModificationItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnModificationCallback() = 0;
    virtual void OnDispatch() { return OnModificationCallback(); }
    ULONG m_ModificationsPending;

    CJobModificationItem() :
        m_ModificationsPending(0) {}
};

class CLockedJobReadPointer : public CLockedReadPointer<CJob, BG_JOB_READ>
{
public:

    CLockedJobReadPointer( CJob * job) : CLockedReadPointer<CJob, BG_JOB_READ>( job )
    {
    }

    HRESULT ValidateAccess();
};

class CLockedJobWritePointer : public CLockedWritePointer<CJob, BG_JOB_WRITE>
{
public:

    CLockedJobWritePointer( CJob * job) : CLockedWritePointer<CJob, BG_JOB_WRITE>( job )
    {
    }

    HRESULT ValidateAccess();
};

//------------------------------------------------------------------------

class CJobExternal : public IBackgroundCopyJob2
{

friend CJob;

public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyJob methods

    HRESULT STDMETHODCALLTYPE AddFileSetInternal(
        /* [in] */ ULONG cFileCount,
        /* [size_is][in] */ BG_FILE_INFO *pFileSet);

    HRESULT STDMETHODCALLTYPE AddFileSet(
        /* [in] */ ULONG cFileCount,
        /* [size_is][in] */ BG_FILE_INFO *pFileSet)
    {
        EXTERNAL_FUNC_WRAP( AddFileSetInternal( cFileCount, pFileSet ) )
    }


    HRESULT STDMETHODCALLTYPE AddFileInternal(
        /* [in] */ LPCWSTR RemoteUrl,
        /* [in] */ LPCWSTR LocalName);

    HRESULT STDMETHODCALLTYPE AddFile(
        /* [in] */ LPCWSTR RemoteUrl,
        /* [in] */ LPCWSTR LocalName)
    {
        EXTERNAL_FUNC_WRAP( AddFileInternal( RemoteUrl, LocalName ) )
    }


    HRESULT STDMETHODCALLTYPE EnumFilesInternal(
        /* [out] */ IEnumBackgroundCopyFiles **pEnum);

    HRESULT STDMETHODCALLTYPE EnumFiles(
        /* [out] */ IEnumBackgroundCopyFiles **ppEnum
        )
    {
        EXTERNAL_FUNC_WRAP( EnumFilesInternal( ppEnum ) )
    }

    HRESULT STDMETHODCALLTYPE SuspendInternal( void);

    HRESULT STDMETHODCALLTYPE Suspend( void)
    {
        EXTERNAL_FUNC_WRAP( SuspendInternal() )
    }


    HRESULT STDMETHODCALLTYPE ResumeInternal( void);

    HRESULT STDMETHODCALLTYPE Resume( void)
    {
        EXTERNAL_FUNC_WRAP( ResumeInternal() )
    }


    HRESULT STDMETHODCALLTYPE CancelInternal( void);

    HRESULT STDMETHODCALLTYPE Cancel( void)
    {
        EXTERNAL_FUNC_WRAP( CancelInternal() )
    }


    HRESULT STDMETHODCALLTYPE CompleteInternal( void);

    HRESULT STDMETHODCALLTYPE Complete( void)
    {
        EXTERNAL_FUNC_WRAP( CompleteInternal() )
    }

    HRESULT STDMETHODCALLTYPE GetIdInternal(
        /* [out] */ GUID *pVal);

    HRESULT STDMETHODCALLTYPE GetId(
        /* [out] */ GUID *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetIdInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetTypeInternal(
        /* [out] */ BG_JOB_TYPE *pVal);

    HRESULT STDMETHODCALLTYPE GetType(
        /* [out] */ BG_JOB_TYPE *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetTypeInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetProgressInternal(
        /* [out] */ BG_JOB_PROGRESS *pVal);

    HRESULT STDMETHODCALLTYPE GetProgress(
        /* [out] */ BG_JOB_PROGRESS *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetProgressInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetTimesInternal(
        /* [out] */ BG_JOB_TIMES *pVal);

    HRESULT STDMETHODCALLTYPE GetTimes(
        /* [out] */ BG_JOB_TIMES *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetTimesInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetStateInternal(
        /* [out] */ BG_JOB_STATE *pVal);

    HRESULT STDMETHODCALLTYPE GetState(
        /* [out] */ BG_JOB_STATE *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetStateInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetErrorInternal(
        /* [out] */ IBackgroundCopyError **ppError);

    HRESULT STDMETHODCALLTYPE GetError(
        /* [out] */ IBackgroundCopyError **ppError)
    {
        EXTERNAL_FUNC_WRAP( GetErrorInternal( ppError ) )
    }


    HRESULT STDMETHODCALLTYPE GetOwnerInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetOwner(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetOwnerInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetDisplayNameInternal(
        /* [in] */ LPCWSTR Val);

    HRESULT STDMETHODCALLTYPE SetDisplayName(
        /* [in] */ LPCWSTR Val)
    {
        EXTERNAL_FUNC_WRAP( SetDisplayNameInternal( Val ) )
    }

    HRESULT STDMETHODCALLTYPE GetDisplayNameInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetDisplayName(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetDisplayNameInternal( pVal ) )
    }

    HRESULT STDMETHODCALLTYPE SetDescriptionInternal(
        /* [in] */ LPCWSTR Val);

    HRESULT STDMETHODCALLTYPE SetDescription(
        /* [in] */ LPCWSTR Val)
    {
        EXTERNAL_FUNC_WRAP( SetDescriptionInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE GetDescriptionInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetDescription(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetDescriptionInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetPriorityInternal(
        /* [in] */ BG_JOB_PRIORITY Val);

    HRESULT STDMETHODCALLTYPE SetPriority(
        /* [in] */ BG_JOB_PRIORITY Val)
    {
        EXTERNAL_FUNC_WRAP( SetPriorityInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE GetPriorityInternal(
        /* [out] */ BG_JOB_PRIORITY *pVal);

    HRESULT STDMETHODCALLTYPE GetPriority(
        /* [out] */ BG_JOB_PRIORITY *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetPriorityInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetNotifyFlagsInternal(
        /* [in] */ ULONG Val);

    HRESULT STDMETHODCALLTYPE SetNotifyFlags(
        /* [in] */ ULONG Val)
    {
        EXTERNAL_FUNC_WRAP( SetNotifyFlagsInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE GetNotifyFlagsInternal(
        /* [out] */ ULONG *pVal);

    HRESULT STDMETHODCALLTYPE GetNotifyFlags(
        /* [out] */ ULONG *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetNotifyFlagsInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE
    SetNotifyInterfaceInternal(
        IUnknown * Val
        );

    HRESULT STDMETHODCALLTYPE
    SetNotifyInterface(
        IUnknown * Val
        )
    {
        EXTERNAL_FUNC_WRAP( SetNotifyInterfaceInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE
    GetNotifyInterfaceInternal(
        IUnknown ** ppVal
        );

    HRESULT STDMETHODCALLTYPE
    GetNotifyInterface(
        IUnknown ** ppVal
        )
    {
        EXTERNAL_FUNC_WRAP( GetNotifyInterfaceInternal( ppVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetMinimumRetryDelayInternal(
        /* [in] */ ULONG Seconds);

    HRESULT STDMETHODCALLTYPE SetMinimumRetryDelay(
        /* [in] */ ULONG Seconds)
    {
        EXTERNAL_FUNC_WRAP( SetMinimumRetryDelayInternal( Seconds ) )
    }


    HRESULT STDMETHODCALLTYPE GetMinimumRetryDelayInternal(
        /* [out] */ ULONG *Seconds);

    HRESULT STDMETHODCALLTYPE GetMinimumRetryDelay(
        /* [out] */ ULONG *Seconds)
    {
        EXTERNAL_FUNC_WRAP( GetMinimumRetryDelayInternal( Seconds ) )
    }


    HRESULT STDMETHODCALLTYPE SetNoProgressTimeoutInternal(
        /* [in] */ ULONG Seconds);

    HRESULT STDMETHODCALLTYPE SetNoProgressTimeout(
        /* [in] */ ULONG Seconds)
    {
        EXTERNAL_FUNC_WRAP( SetNoProgressTimeoutInternal( Seconds ) )
    }

    HRESULT STDMETHODCALLTYPE GetNoProgressTimeoutInternal(
        /* [out] */ ULONG *Seconds);

    HRESULT STDMETHODCALLTYPE GetNoProgressTimeout(
        /* [out] */ ULONG *Seconds)
    {
        EXTERNAL_FUNC_WRAP( GetNoProgressTimeoutInternal( Seconds ) )
    }


    HRESULT STDMETHODCALLTYPE GetErrorCountInternal(
        /* [out] */ ULONG *Errors);

    HRESULT STDMETHODCALLTYPE GetErrorCount(
        /* [out] */ ULONG *Errors)
    {
        EXTERNAL_FUNC_WRAP( GetErrorCountInternal( Errors ) )
    }


    HRESULT STDMETHODCALLTYPE SetProxySettingsInternal(
       /* [in] */ BG_JOB_PROXY_USAGE ProxyUsage,
       /* [in] */ LPCWSTR ProxyList,
       /* [in] */ LPCWSTR ProxyBypassList );

    HRESULT STDMETHODCALLTYPE SetProxySettings(
       /* [in] */ BG_JOB_PROXY_USAGE ProxyUsage,
       /* [in] */ LPCWSTR ProxyList,
       /* [in] */ LPCWSTR ProxyBypassList )
    {
       EXTERNAL_FUNC_WRAP( SetProxySettingsInternal( ProxyUsage, ProxyList, ProxyBypassList ) )
    }


    HRESULT STDMETHODCALLTYPE GetProxySettingsInternal(
       /* [out] */ BG_JOB_PROXY_USAGE *pProxyUsage,
       /* [out] */ LPWSTR *pProxyList,
       /* [out] */ LPWSTR *pProxyBypassList );

    HRESULT STDMETHODCALLTYPE GetProxySettings(
       /* [out] */ BG_JOB_PROXY_USAGE *pProxyUsage,
       /* [out] */ LPWSTR *pProxyList,
       /* [out] */ LPWSTR *pProxyBypassList )
    {
        EXTERNAL_FUNC_WRAP( GetProxySettingsInternal( pProxyUsage, pProxyList, pProxyBypassList ) )
    }



    HRESULT STDMETHODCALLTYPE TakeOwnershipInternal();

    HRESULT STDMETHODCALLTYPE TakeOwnership()
    {
        EXTERNAL_FUNC_WRAP( TakeOwnershipInternal( ) )
    }

    // IBackgroundCopyJob2 methods (external)

    HRESULT STDMETHODCALLTYPE SetNotifyCmdLine(
        /* [in] */ LPCWSTR Program,
        /* [in] */ LPCWSTR Parameters )
    {
        EXTERNAL_FUNC_WRAP( SetNotifyCmdLineInternal( Program, Parameters ) );
    }

    HRESULT STDMETHODCALLTYPE GetNotifyCmdLine(
        /* [out] */ LPWSTR *pProgram,
        /* [out] */ LPWSTR *pParameters )
    {
        EXTERNAL_FUNC_WRAP( GetNotifyCmdLineInternal( pProgram, pParameters ) );
    }

    HRESULT STDMETHODCALLTYPE GetReplyProgress(
        /* [in] */ BG_JOB_REPLY_PROGRESS *pProgress)
    {
        EXTERNAL_FUNC_WRAP( GetReplyProgressInternal( pProgress) );
    }

    HRESULT STDMETHODCALLTYPE GetReplyData(
        /* [size_is][size_is][out] */ byte **ppBuffer,
        /* [unique][out][in] */ UINT64 *pLength)
    {
        EXTERNAL_FUNC_WRAP( GetReplyDataInternal(ppBuffer, pLength) );
    }

    HRESULT STDMETHODCALLTYPE SetReplyFileName(
        /* [unique][in] */ LPCWSTR ReplyFileName)
    {
        EXTERNAL_FUNC_WRAP( SetReplyFileNameInternal( ReplyFileName) );
    }

    HRESULT STDMETHODCALLTYPE GetReplyFileName(
        /* [out] */ LPWSTR *pReplyFileName)
    {
        EXTERNAL_FUNC_WRAP( GetReplyFileNameInternal( pReplyFileName) );
    }

    HRESULT STDMETHODCALLTYPE SetCredentials(
        /* [unique][switch_is][in] */ BG_AUTH_CREDENTIALS *pCredentials)
    {
        EXTERNAL_FUNC_WRAP( SetCredentialsInternal( pCredentials ) );
    }

    HRESULT STDMETHODCALLTYPE RemoveCredentials(
        /* [unique][switch_is][in] */ BG_AUTH_TARGET Target,
                                      BG_AUTH_SCHEME Scheme )
    {
        EXTERNAL_FUNC_WRAP( RemoveCredentialsInternal( Target, Scheme ) );
    }


    // internal versions of IBackgroundCopyJob2 methods

    HRESULT STDMETHODCALLTYPE SetNotifyCmdLineInternal(
        /* [in] */ LPCWSTR Program,
        /* [in] */ LPCWSTR Parameters );

    HRESULT STDMETHODCALLTYPE GetNotifyCmdLineInternal(
        /* [out] */ LPWSTR *pProgram,
        /* [out] */ LPWSTR *pParameters );

    HRESULT STDMETHODCALLTYPE GetReplyProgressInternal(
        /* [in] */ BG_JOB_REPLY_PROGRESS *pProgress);

    HRESULT STDMETHODCALLTYPE GetReplyDataInternal(
        /* [size_is][size_is][out] */ byte **ppBuffer,
        /* [unique][out][in] */ UINT64 *pLength);

    HRESULT STDMETHODCALLTYPE SetReplyFileNameInternal(
        /* [unique][in] */ LPCWSTR ReplyFileName);

    HRESULT STDMETHODCALLTYPE GetReplyFileNameInternal(
        /* [out] */ LPWSTR *pReplyFileName);

    HRESULT STDMETHODCALLTYPE SetCredentialsInternal(
        /* [unique][switch_is][in] */ BG_AUTH_CREDENTIALS *pCredentials);

    HRESULT STDMETHODCALLTYPE RemoveCredentialsInternal(
        /* [unique][switch_is][in] */ BG_AUTH_TARGET Target,
                                      BG_AUTH_SCHEME Scheme );

    // Other methods

    CJobExternal();
    ~CJobExternal();

private:

    CJob *pJob;

    long m_refs;

    long m_ServiceInstance;

    void SetInterfaceClass(
        CJob *pVal
        )
    {
        pJob = pVal;
    }

    void NotifyInternalDelete()
    {
        // Release the internal refcount
        Release();
    }

};

class CUnknownFileSizeItem
{
public:
    CFile *const    m_file;
    StringHandle    m_url;

    CUnknownFileSizeItem(
        CFile *pFile,
        StringHandle URL ) :
    m_file( pFile ),
    m_url( URL )
    {
    }
};

class CUnknownFileSizeList : public list<CUnknownFileSizeItem>
{
public:
    bool Add( CFile *pFile, const StringHandle & URL )
    {
        try
        {
            push_back( CUnknownFileSizeItem( pFile, URL ) );
        }
        catch( ComError Error )
        {
            return false;
        }
        return true;
    }
};

class COldJobInterface;
class COldGroupInterface;

class CJob :
            public IntrusiveList<CJob>::Link,
            public CJobInactivityTimeout,
            public CJobRetryItem,
            public CJobCallbackItem,
            public CJobNoProgressItem,
            public CJobModificationItem
{

friend class CGroupList;
friend class CJobExternal;
friend class COldJobInterface;
friend class COldGroupInterface;

public:

    class CFileList : public vector<CFile *>
    {
    public:

        HRESULT Serialize( HANDLE hFile );
        void    Unserialize( HANDLE hFile, CJob* Job );

        void    Delete( iterator Initial, iterator Terminal );
    };

    void    HandleAddFile();

    HRESULT AddFileSet(
        /* [in] */ ULONG cFileCount,
        /* [size_is][in] */ BG_FILE_INFO *pFileSet
        );

    HRESULT AddFile(
        /* [in] */ LPCWSTR RemoteUrl,
        /* [in] */ LPCWSTR LocalName,
        bool SingleAdd );

    virtual HRESULT Suspend();

    virtual HRESULT Resume();

    virtual HRESULT Cancel();

    virtual HRESULT Complete();

    GUID GetId() const
    {
        return m_id;
    }

    BG_JOB_TYPE GetType() const
    {
        return m_type;
    }

    void GetProgress(
        /* [out] */ BG_JOB_PROGRESS *pVal) const;

    void GetTimes(
        /* [out] */ BG_JOB_TIMES *pVal) const;

    HRESULT SetDisplayName(
        /* [in] */ LPCWSTR Val);

    HRESULT GetDisplayName(
        /* [out] */ LPWSTR *pVal) const;

    HRESULT SetDescription(
        /* [in] */ LPCWSTR Val);

    HRESULT GetDescription(
        /* [out] */ LPWSTR *pVal) const;

    HRESULT SetPriority(
        /* [in] */ BG_JOB_PRIORITY Val);

    HRESULT GetOwner(
        /* [out] */ LPWSTR *pVal) const;

    HRESULT SetNotifyFlags(
        /* [in] */ ULONG Val);

    ULONG GetNotifyFlags() const
    {
        return m_NotifyFlags;
    }

    HRESULT
    SetNotifyInterface(
        IUnknown * Val
        );

    HRESULT
    GetNotifyInterface(
        IUnknown ** ppVal
        ) const;

    BOOL
    TestNotifyInterface();

    HRESULT SetMinimumRetryDelay(
        /* [in] */ ULONG Seconds);

    HRESULT GetMinimumRetryDelay(
        /* [out] */ ULONG *Seconds) const;

    HRESULT SetNoProgressTimeout(
        /* [in] */ ULONG Seconds);

    HRESULT GetNoProgressTimeout(
        /* [out] */ ULONG *Seconds) const;

    HRESULT STDMETHODCALLTYPE GetErrorCount(
        /* [out] */ ULONG *Errors) const;


    HRESULT
    SetProxySettings(
        BG_JOB_PROXY_USAGE ProxyUsage,
        LPCWSTR ProxyList,
        LPCWSTR ProxyBypassList
        );

    HRESULT
    GetProxySettings(
        BG_JOB_PROXY_USAGE *pProxyUsage,
        LPWSTR *pProxyList,
        LPWSTR *pProxyBypassList
        ) const;

    HRESULT TakeOwnership();

    virtual HRESULT
    GetReplyProgress(
        BG_JOB_REPLY_PROGRESS *pProgress
        ) const;

    virtual HRESULT
    GetReplyFileName(
        LPWSTR * pVal
        ) const;

    virtual HRESULT
    SetReplyFileName(
        LPCWSTR Val
        );

    virtual HRESULT
    GetReplyData(
        byte **ppBuffer,
        UINT64 *pLength
        ) const;

    virtual HRESULT
    SetNotifyCmdLine(
        LPCWSTR Program,
        LPCWSTR Parameters
        );

    virtual HRESULT
    GetNotifyCmdLine(
        LPWSTR *pProgram,
        LPWSTR *pParameters
        ) const;

    HRESULT
    SetCredentials(
        BG_AUTH_CREDENTIALS *pCredentials
        );

    HRESULT
    RemoveCredentials(
        BG_AUTH_TARGET Target,
        BG_AUTH_SCHEME Scheme
        );

    // CJobCallbackItem methods

    void OnMakeCallback();

    // CJobRetryItem methods

    virtual void OnRetryJob();

    // CJobInactivityTimeout methods

    virtual void OnInactivityTimeout();

    // CJobNoProgressItem methods

    virtual void OnNoProgress();

    // CJobModificationItem methods
    virtual void OnModificationCallback();

    // other methods

    virtual void OnNetworkConnect();
    virtual void OnNetworkDisconnect();

    void RemoveFromManager();
    void CancelWorkitems();

    // TaskSchedulerWorkItem

    SidHandle GetSid()
    {
        return m_NotifySid;
    }


    bool
    IsCallbackEnabled(
        DWORD bit
        );

    void ScheduleModificationCallback();

    CJob(
        LPCWSTR     Name,
        BG_JOB_TYPE Type,
        REFGUID     JobId,
        SidHandle   NotifySid
        );

protected:

    #define NO_FILE_INDEX LONG_MIN
    #define REPLY_FILE_INDEX (-1)

    bool
    RecordError(
        QMErrInfo * ErrInfo,
        LONG FileIndex
        );

    void
    LogUnsuccessfulFileDeletion(
        CFileList & files
        );

    //
    // used only by unserialize
    //
    CJob();

public:

    virtual ~CJob();

    BG_JOB_PRIORITY _GetPriority() const
    {
        return m_priority;
    }

    BG_JOB_STATE _GetState() const
    {
        return m_state;
    }

    void SetState( BG_JOB_STATE state );

    bool
    CheckStateTransition(
        BG_JOB_STATE Old,
        BG_JOB_STATE New
        );

    inline SidHandle GetOwnerSid()
    {
        return m_sd->GetOwnerSid();
    }

    BOOL IsIncomplete() const
    {
        if (m_state < BG_JOB_STATE_TRANSFERRED)
            {
            return TRUE;
            }

        return FALSE;
    }

    bool ShouldThrottle() const
    {
        return (m_priority!=BG_JOB_PRIORITY_FOREGROUND);
    }

    HRESULT DeleteFileIndex( ULONG index );

    HRESULT IsVisible();

    bool IsOwner( SidHandle user );

    virtual bool IsRunning();
    virtual bool IsRunnable();
    virtual void Transfer();

    void
    SetTransientError(
        QMErrInfo & ErrInfo,
        LONG FileIndex,
        bool fRetryLater,
        bool fUpdateTime
        );

    virtual void
    FileComplete();

    virtual void
    FileTransientError(
        QMErrInfo * ErrInfo
        );

    virtual void
    FileFatalError(
        QMErrInfo * ErrInfo
        );

    virtual void
    FileChangedOnServer()
    {
        UpdateModificationTime();
    }

    virtual void UpdateProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        );

    void  JobTransferred();

    HRESULT CommitTemporaryFiles();
    HRESULT RemoveTemporaryFiles( DWORD StartingIndex=0 );

    void
    UpdateModificationTime(
        bool   fReplace = TRUE
        );

    void
    UpdateLastAccessTime(
        );

    void SetCompletionTime( const FILETIME *pftCompletionTime = 0 );
    void SetModificationTime( const FILETIME *pftModificationTime = 0 );
    void SetLastAccessTime( const FILETIME *pftModificationTime = 0 );

    CFile * GetCurrentFile() const
    {
        if (m_CurrentFile < m_files.size())
            {
            return m_files[ m_CurrentFile ];
            }
        else
            {
            return NULL;
            }
    }

    virtual bool IsTransferringToDrive( const WCHAR *CanonicalVolume );

    BOOL IsEmpty() const
    {
        if (m_files.size() == 0)
            {
            return TRUE;
            }

        return FALSE;
    }

    virtual CFile * _GetFileIndex( LONG index ) const;

    virtual HRESULT Serialize( HANDLE hFile );

    virtual void Unserialize( HANDLE hFile, int Type );

    static CJob * UnserializeJob( HANDLE hFile );

    CJobExternal* GetExternalInterface()
    {
        return m_ExternalInterface;
    }

    COldGroupInterface *GetOldExternalGroupInterface()
    {
        return m_OldExternalGroupInterface;
    }

    void SetOldExternalGroupInterface( COldGroupInterface *GroupInterface )
    {
        ASSERT( !m_OldExternalGroupInterface );
        m_OldExternalGroupInterface = GroupInterface;
    }

    COldJobInterface *GetOldExternalJobInterface() const
    {
        return m_OldExternalJobInterface;
    }

    void SetOldExternalJobInterface( COldJobInterface *JobInterface )
    {
        ASSERT( !m_OldExternalJobInterface );
        m_OldExternalJobInterface = JobInterface;
    }

    void UnlinkFromExternalInterfaces();

    void NotifyInternalDelete()
    {
        GetExternalInterface()->NotifyInternalDelete();
    }

    ULONG AddRef(void)
    {
        return GetExternalInterface()->AddRef();
    }

    ULONG Release(void)
    {
        return GetExternalInterface()->Release();
    }

    HRESULT CheckClientAccess(
        IN DWORD RequestedAccess
        ) const;


    void ScheduleCompletionCallback(
        DWORD Seconds = 0
        );

    void ScheduleErrorCallback(
        DWORD Seconds = 0
        );

    void RetryNow();
    void RecalcTransientError( bool ForResume=false );

    const CJobError *GetError() const
    {
        if ( !m_error.IsErrorSet() )
            return NULL;

        return &m_error;
    }

    //--------------------------------------------------------------------

    BG_JOB_PRIORITY     m_priority;
    BG_JOB_STATE        m_state;
    BG_JOB_TYPE         m_type;

    void OnDiskChange(   const WCHAR *CanonicalVolume, DWORD VolumeSerialNumber );
    void OnDismount(     const WCHAR *CanonicalVolume );
    bool OnDeviceLock(   const WCHAR *CanonicalVolume );
    bool OnDeviceUnlock( const WCHAR *CanonicalVolume );

    bool AreRemoteSizesKnown()
    {
        for(CFileList::iterator iter = m_files.begin(); iter != m_files.end(); iter++ )
            {
            if ( (*iter)->_GetBytesTotal() == -1 )
                return false;
            }
        return true;
    }

    bool
    VerifyFileSizes(
        HANDLE hToken
        );

    CUnknownFileSizeList* GetUnknownFileSizeList() throw( ComError );

    const PROXY_SETTINGS & QueryProxySettings() const
    {
        return m_ProxySettings;
    }


    const CCredentialsContainer & QueryCredentialsList() const
    {
        return m_Credentials;
    }

    virtual StringHandle GetHostId() const
    {
        return StringHandle();
    }

    virtual DWORD GetHostIdFallbackTimeout() const
    {
        return 0xFFFFFFFF;
    }

    enum ChangeType
    {
        CHG_CANCEL,
        CHG_TAKE_OWNERSHIP,
        CHG_SETPROP
    };

    enum PropertyType
    {
        PROP_NONE,
        PROP_NAME,
        PROP_DESCRIPTION
    };

    HRESULT NonOwnerModificationCheck(
        SidHandle CurrentSid,
        enum ChangeType Change,
        enum PropertyType Property
        );

    virtual HRESULT
    ExcludeFilesFromBackup(
        IN IVssCreateWriterMetadata *pMetadata
        );

protected:

    GUID                m_id;
    StringHandle        m_name;
    StringHandle        m_description;
    StringHandle        m_appid;

    SidHandle           m_NotifySid;
    IBackgroundCopyCallback * m_NotifyPointer;
    DWORD               m_NotifyFlags;
    BOOL                m_fGroupNotifySid;

    StringHandle        m_NotifyProgram;
    StringHandle        m_NotifyParameters;
    long                m_NotifyLaunchAttempts;

    CJobSecurityDescriptor * m_sd;

    LONG                m_CurrentFile;
    CFileList           m_files;

    CJobError           m_error;

    ULONG               m_retries;
    ULONG               m_MinimumRetryDelay;
    ULONG               m_NoProgressTimeout;

    FILETIME            m_CreationTime;
    FILETIME            m_LastAccessTime;
    FILETIME            m_ModificationTime;
    FILETIME            m_TransferCompletionTime;

    FILETIME            m_SerializeTime;

    CJobExternal *      m_ExternalInterface;

    static GENERIC_MAPPING s_AccessMapping;

    COldGroupInterface *m_OldExternalGroupInterface;
    COldJobInterface   *m_OldExternalJobInterface;

    PROXY_SETTINGS m_ProxySettings;

    CCredentialsContainer m_Credentials;

    bool                m_fVolumeLocked;
    bool                m_FilesVerified;

    //--------------------------------------------------------------------

    HRESULT InterfaceCallback();
    HRESULT CmdLineCallback();
    HRESULT RescheduleCallback();

    HRESULT OldInterfaceCallback();

    HRESULT
    UpdateString(
        StringHandle & destination,
        const StringHandle & Val
        );

    HRESULT
    SetLimitedString(
        StringHandle & destination,
        LPCWSTR Val,
        SIZE_T limit
        );
};

class CUploadJob : public CJob
{
public:
    virtual HRESULT Serialize(HANDLE hFile);
    virtual void Unserialize(HANDLE hFile, int Type);

    CUploadJob(
        LPCWSTR     Name,
        BG_JOB_TYPE Type,
        REFGUID     JobId,
        SidHandle   NotifySid
        );

    CUploadJob() : m_ReplyFile( 0 )
    {
    }

    virtual ~CUploadJob();

    virtual HRESULT Resume();
    virtual HRESULT Cancel();
    virtual HRESULT Complete();

    UPLOAD_DATA & GetUploadData() { return m_UploadData; }

    CFile * GetUploadFile() { return m_files[ 0 ]; }

    virtual StringHandle GetHostId() const
    {
        return m_UploadData.HostId;
    }

    virtual DWORD GetHostIdFallbackTimeout() const
    {
        return m_UploadData.HostIdFallbackTimeout;
    }

    virtual CFile * _GetFileIndex( LONG index ) const;

    virtual bool IsRunnable();
    virtual void Transfer();

    virtual bool IsTransferringToDrive( const WCHAR *CanonicalVolume );

    virtual void
    FileComplete();

    virtual void
    FileTransientError(
        QMErrInfo * ErrInfo
        );

    virtual void
    FileFatalError(
        QMErrInfo * ErrInfo
        );

    virtual void OnRetryJob();
    virtual void OnInactivityTimeout();

    bool SessionInProgress()
    {
        if (m_UploadData.State > UPLOAD_STATE_CREATE_SESSION &&
            m_UploadData.State < UPLOAD_STATE_CLOSED)
            {
            return true;
            }

        return false;
    }

    void SetReplyFile( CFile * file ) throw( ComError );
    CFile * QueryReplyFile()  { return m_ReplyFile; }

    StringHandle QueryReplyFileName() { return m_ReplyFileName; }

    HRESULT GenerateReplyFile( bool fSerialize );

    HRESULT DeleteGeneratedReplyFile();

    HRESULT RemoveReplyFile();

    HRESULT CommitReplyFile();

    virtual HRESULT
    GetReplyProgress(
        BG_JOB_REPLY_PROGRESS *pProgress
        ) const;

    virtual HRESULT
    GetReplyFileName(
        LPWSTR * pVal
        ) const;

    virtual HRESULT
    SetReplyFileName(
        LPCWSTR Val
        );

    virtual HRESULT
    GetReplyData(
        byte **ppBuffer,
        UINT64 *pLength
        ) const;

    // This is a hack because CJob cannot access a protected member of CUploadJob
    //
    void ClearOwnFileNameBit() { m_fOwnReplyFileName = false; }

    virtual void UpdateProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        );

    bool CheckHostIdFallbackTimeout();

    virtual HRESULT
    ExcludeFilesFromBackup(
        IN IVssCreateWriterMetadata *pMetadata
        );

protected:

    UPLOAD_DATA     m_UploadData;
    CFile *         m_ReplyFile;
    StringHandle    m_ReplyFileName;
    bool            m_fOwnReplyFileName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\clist.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    clist.h

Abstract :

    Header file for IntrusiveList.

Author :

Revision History :

 ***********************************************************************/

#ifndef __CLIST_H__
#define __CLIST_H__

template<class T> class IntrusiveList
{
public:

    struct Link
    {
        Link * m_left;
        Link * m_right;
        IntrusiveList * m_list;

        Link()
        {
            m_left = this;
            m_right = this;
            m_list = NULL;
        }

        void prepend( Link & val )
        {
            ASSERT( val.m_left  == &val );
            ASSERT( val.m_right == &val );
            ASSERT( val.m_list  == NULL );

            ASSERT( m_list != NULL );

            val.m_right = this;
            val.m_left  = m_left;
            val.m_list  = m_list;

            val.m_right->m_left = &val;
            val.m_left->m_right = &val;
        }

        void excise()
        {
            if (m_list == NULL)
                {
                ASSERT( m_left  == this );
                ASSERT( m_right == this );
                return;
                }

            m_right->m_left = m_left;
            m_left->m_right = m_right;

            m_left  = this;
            m_right = this;
            m_list  = NULL;
        }

    };

    class iterator
    {
    public:

        iterator() : m_current(0)
        {
        }

        iterator operator--()
        {
            m_current = m_current->m_left;
            return *this;
        }

        iterator operator--(int)
        {
            // postfix operator

            iterator temp = *this;

            -- *this;

            return temp;
        }

        iterator operator-(int count)
        {
            iterator temp = *this;

            while (count > 0)
                {
                --temp;
                }

            return temp;
        }

        iterator operator+(int count)
        {
            iterator temp = *this;

            while (count > 0)
                {
                ++temp;
                }

            return temp;
        }

        iterator operator++()
        {
            // prefix operator

            m_current = m_current->m_right;
            return *this;
        }

        iterator operator++(int)
        {
            // postfix operator

            iterator temp = *this;

            ++ *this;

            return temp;
        }

        T & operator*()
        {
            return *static_cast<T *> ( m_current );
        }

        T * operator->()
        {
            return &(**this);
        }

        bool operator==(const iterator& _X) const
        {
        return (m_current == _X.m_current);
        }

        bool operator!=(const iterator& _X) const
        {
        return !(*this == _X);
        }

        iterator( Link * p ) : m_current( p )
        {
        }

        Link * next()
        {
            return m_current->m_right;
        }

        Link * prev()
        {
            return m_current->m_left;
        }

        void prepend( Link & val )
        {
            m_current->prepend( val );
        }

        void excise()
        {
            m_current->excise();
        }

    protected:

        Link * m_current;

    };

    //--------------------------------------------------------------------

    IntrusiveList() : m_size(0)
    {
        m_head.m_list = this;
    }

    iterator begin()
    {
        return ++iterator( &m_head );
    }

    iterator end()
    {
        return iterator( &m_head );
    }

    iterator push( T& val )
    {
        return insert( begin(), val );
    }

    iterator push_back( T& val )
    {
        return insert( end(), val );
    }

    iterator insert( iterator pos,  T & val)
    {
        pos.prepend( val );
        ++m_size;

        return iterator( &val );
    }

    size_t erase( T & val )
    {
        if (val.m_list != this)
            {
            return 0;
            }

        val.excise();
        --m_size;

        return 1;
    }

    void erase( iterator & pos )
    {
        if (pos == end())
            {
            return;
            }

        pos.excise();
        --m_size;
    }

    void erase(iterator pos, iterator term)
    {
        while (pos != term)
            {
            erase(pos++);
            }
    }

    iterator find( const T& val )
    {
        for (iterator iter=begin(); iter != end(); ++iter)
            {
            if (&(*iter) == &val)
                {
                return iter;
                }
            }

        return end();
    }

    void clear()
    {
        erase( begin(), end() );
    }

    size_t size()
    {
        if (m_size == 0)
            {
            ASSERT( begin() == end() );
            }
        else
            {
            ASSERT( begin() != end() );
            }

        return m_size;
    }

    bool empty()
    {
        if (m_size == 0)
            {
            ASSERT( begin() == end() );
            }
        else
            {
            ASSERT( begin() != end() );
            }

        return (size() == 0);
    }

protected:

    Link        m_head;
    size_t      m_size;

};

#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cfile.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.h

Abstract :

    Main header file for files.

Author :

Revision History :

 ***********************************************************************/

class CFile;
class CJob;
class CFileExternal;
class CJobExternal;

class CFileExternal : public IBackgroundCopyFile
{
public:

    friend CFile;

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyFile methods

    HRESULT STDMETHODCALLTYPE GetRemoteNameInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetRemoteName(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetRemoteNameInternal( pVal ) )
    }

    HRESULT STDMETHODCALLTYPE GetLocalNameInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetLocalName(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetLocalNameInternal( pVal ) )
    }

    HRESULT STDMETHODCALLTYPE GetProgressInternal(
        /* [out] */ BG_FILE_PROGRESS *pVal);

    HRESULT STDMETHODCALLTYPE GetProgress(
        /* [out] */ BG_FILE_PROGRESS *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetProgressInternal( pVal ) )
    }

    // other methods

    CFileExternal(
        CFile * file,
        CJobExternal * JobExternal
        );

    ~CFileExternal();

private:

    long m_refs;
    long m_ServiceInstance;

    CFile *         m_file;
    CJobExternal *  m_JobExternal;
};

class CFile : public ITransferCallback
{
public:

    friend CFileExternal;

    // ITransferCallback methods

    virtual bool
    DownloaderProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        );

    virtual bool PollAbort();

    virtual bool
    UploaderProgress(
        UINT64 BytesTransferred
        );

    // other methods

    CFile(
        CJob*   Job,
        BG_JOB_TYPE FileType,
        StringHandle RemoteName,
        StringHandle LocalName
        );

    virtual ~CFile();

    bool Transfer( HANDLE                       hToken,
                   BG_JOB_PRIORITY              priority,
                   const PROXY_SETTINGS &       ProxySettings,
                   const CCredentialsContainer *Credentials,
                   QMErrInfo                  & ErrInfo
                   );

    void
    DiscoverBytesTotal(
        HANDLE Token,
        const PROXY_SETTINGS & ProxySettings,
        const CCredentialsContainer * Credentials,
        QMErrInfo & ErrorInfo
        );

    HRESULT GetRemoteName( LPWSTR *pVal ) const;

    HRESULT GetLocalName( LPWSTR *pVal ) const;

    const StringHandle & GetRemoteName() const
    {
        return m_RemoteName;
    }

    const StringHandle & GetLocalName() const
    {
        return m_LocalName;
    }

    const StringHandle & GetTemporaryName() const
    {
        return m_TemporaryName;
    }

    void GetProgress( BG_FILE_PROGRESS *pVal ) const;

    HRESULT Serialize( HANDLE hFile );
    static CFile * Unserialize( HANDLE hFile, CJob* Job );

    UINT64 _GetBytesTransferred() const
    {
        return m_BytesTransferred;
    }

    UINT64 _GetBytesTotal() const
    {
       return m_BytesTotal;
    }

    void SetBytesTotal( UINT64 BytesTotal )
    {
        m_BytesTotal = BytesTotal;
    }

    void SetBytesTransferred( UINT64 BytesTransferred )
    {
        m_BytesTransferred = BytesTransferred;
    }

    bool IsCompleted()
    {
        return m_Completed;
    }

    bool ReceivedAllData()
    {
        return (m_BytesTotal == m_BytesTransferred);
    }

    CFileExternal * CreateExternalInterface();

    CJob* GetJob() const
    {
        return m_Job;
    }

    HRESULT CheckClientAccess(
        IN DWORD RequestedAccess
        ) const;

    HRESULT MoveTempFile();
    HRESULT DeleteTempFile();

    HRESULT VerifyLocalName( LPCWSTR name, BG_JOB_TYPE JobType );
    BOOL    VerifyRemoteName( LPCWSTR name );

    static HRESULT VerifyLocalFileName( LPCWSTR name, BG_JOB_TYPE JobType );

    bool IsCanonicalVolume( const WCHAR *CanonicalVolume )
    {
        return ( _wcsicmp( m_CanonicalVolumePath, CanonicalVolume ) == 0 );
    }

    HRESULT ValidateAccessForUser( SidHandle sid, bool fWrite );

    bool ValidateDriveInfo( HANDLE hToken, QMErrInfo & ErrInfo );

    bool OnDiskChange(  const WCHAR *CanonicalVolume, DWORD VolumeSerialNumber );
    bool OnDismount(  const WCHAR *CanonicalVolume );

    void ChangedOnServer();

    static bool IsDriveTypeRemote( UINT DriveType )
    {
        return
            ( DriveType == DRIVE_UNKNOWN ) ||
            ( DriveType == DRIVE_NO_ROOT_DIR ) ||
            ( DriveType == DRIVE_REMOTE );
    }

    static bool IsAbsolutePath( const WCHAR * Path )
    {
        bool ret;

        if ( (Path [0] == L'\\' && Path[1] == L'\\') ||
             (iswalpha ( Path [0] ) && Path [1] == L':' && Path[ 2 ] == L'\\') ) {
            ret = true;
        } else {
            ret = false;
        }
        return ret;
    }

	static bool IsUncPath( LPCWSTR Path )
	{
		if (Path [0] == L'\\' && Path[1] == L'\\')
			{
			return true;
			}

		return false;
	}

    DWORD GetSizeEstimate()
    {
        //
        // Serialize() will store five file paths and five constants
        //
        return (5 * MAX_PATH * sizeof(WCHAR)) + 5 * sizeof( UINT64 );
    }

    HANDLE OpenLocalFileForUpload() throw( ComError );

    HRESULT SetLocalFileTime( FILETIME Time );

private:

    CFile(
        CJob*   Job
        );

    StringHandle    m_RemoteName;
    StringHandle    m_LocalName;
    StringHandle    m_TemporaryName;

    FILETIME        m_LocalFileTime;

    UINT64          m_BytesTotal;
    UINT64          m_BytesTransferred;

    bool            m_Completed;

    CJob *          m_Job;

    // Drive information
    StringHandle    m_VolumePath;
    StringHandle    m_CanonicalVolumePath;
    UINT            m_DriveType;
    DWORD           m_VolumeSerialNumber;
};


/**
 * When deleting a file, some errors are OK to ignore because they imply that
 * the file has already been deleted by an external agent.  This fn filters 
 * out those errors.
 * 
 * @param Hr     HRESULT form of the error from deletion
 * @param Path   the file being deleted
 * 
 * @return true if the error should be reported,
 *         false if the error should be ignored
 */
inline bool 
IsReportableFileDeletionError(
	HRESULT Hr,
	LPCWSTR Path
	)
{
	if (Hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ))
		{
		return false;
		}

	//
	// ERROR_PATH_NOT_FOUND is returned when we try to delete a UNC path while
	// the Workstation service is halted.  Tn this case, report the error.
	//
	if (Hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) &&
		false == CFile::IsUncPath(Path))
		{
		return false;
		}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cmanager.cpp ===
/************************************************************************

Copyright (c) 2000 - 2002 Microsoft Corporation

Module Name :

    cmgr.cpp

Abstract :

    implements CJobManager

 ***********************************************************************/


#include "stdafx.h"
#include <dbt.h>
#include <ioevent.h>
#include <malloc.h>

#include "cmanager.tmh"

//
// If DownloadCurrentFile fails with TRANSIENT_ERROR, the downloader will sleep for this many seconds.
//
const DWORD DELAY_AFTER_TRANSIENT_ERROR = 60;

//
// After a network-alive notification, we wait this long before attempting a download.
//
const UINT64 NETWORK_INIT_TOLERANCE_SECS = 60;   // in seconds

//
// This is the windows message ID that is sent when a user logs on or off.
// wParam == true for logon, false for logoff
// lParam == session ID
//
#define WM_SESSION_CHANGE   (WM_USER+1)

//------------------------------------------------------------------------

CJobManager * g_Manager;

extern SERVICE_STATUS_HANDLE ghServiceHandle;

extern DWORD   g_dwBackgroundThreadId;

//------------------------------------------------------------------------

void GetGuidString( GUID Guid, wchar_t pStr[] )
{
    if (!StringFromGUID2( Guid, pStr, MAX_GUID_CHARS ))
        {
        wcsncpy( pStr, L"(can't convert)", MAX_GUID_CHARS );
        }
}

long g_cCalls = 0;
//
// COM uses this to determine when a DLL can unload safely.
//
long g_cLocks = 0;

HRESULT GlobalLockServer(BOOL fLock)
{

    if (WPP_LEVEL_ENABLED(LogFlagRefCount))
        {
        LogInfo("%d", fLock );
        }

    if (fLock)
        InterlockedIncrement(&g_cLocks);
    else
        InterlockedDecrement(&g_cLocks);

    return S_OK;
}

//
// The job manager.
//

MANAGER_STATE g_ServiceState    = MANAGER_INACTIVE;
long          g_ServiceInstance = 0;

//
// Static data used by the backup writer.
//
VSS_ID s_WRITERID = { /* 4969d978-be47-48b0-b100-f328f07ac1e0 */
    0x4969d978,
    0xbe47,
    0x48b0,
    {0xb1, 0x00, 0xf3, 0x28, 0xf0, 0x7a, 0xc1, 0xe0}
  };

static LPCWSTR  s_WRITERNAME         = L"BITS Writer";

#define COMPONENTNAME           L"BITS_temporary_files"

//------------------------------------------------------------------------

CJobManager::CJobManager() :
    m_ComId_0_5( 0 ),
    m_ComId_1_0( 0 ),
    m_ComId_1_5( 0 ),
    m_hWininet(NULL),
    m_pPD( NULL ),
    m_CurrentJob( NULL ),
    m_Users( m_TaskScheduler ),
    m_ExternalInterface( new CJobManagerExternal ),
    m_OldQmgrInterface( new COldQmgrInterface ),
    m_BackupWriter(NULL),
    m_hVssapi_dll(NULL),
    m_hQuantumTimer(NULL)
{
    try
        {
        QMErrInfo   ErrInfo;

        // use manual reset to insure that we are reseting it when
        // the downloader task is reinserted.
        m_hQuantumTimer = CreateWaitableTimer( NULL, TRUE, NULL );
        if ( !m_hQuantumTimer )
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError()));
            }

        THROW_HRESULT( m_NetworkMonitor.Listen( NetworkChangeCallback, this ));

        //
        // Create the HTTP downloader.
        //
        THROW_HRESULT( CreateHttpDownloader( &m_pPD, &ErrInfo ));

        //
        // This object is fully constructed now.
        //
        GetExternalInterface()->SetInterfaceClass( this );
        GetOldExternalInterface()->SetInterfaceClass( this );

        g_ServiceState = MANAGER_STARTING;
        }
    catch( ComError Error )
        {
        LogError("exception %x at line %d", Error.m_error, Error.m_line );
        Cleanup();
        throw;
        }
}

HRESULT
CJobManager::RegisterClassObjects()
{
    try
        {
        g_ServiceState = MANAGER_ACTIVE;

        THROW_HRESULT( CreateBackupWriter() );

        THROW_HRESULT(
            CoRegisterClassObject(CLSID_BackgroundCopyManager1_5,
                                  (LPUNKNOWN) static_cast<IClassFactory *>(GetExternalInterface() ),
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_MULTIPLEUSE,
                                  &m_ComId_1_5 ) );

        THROW_HRESULT(
            CoRegisterClassObject(CLSID_BackgroundCopyManager,
                                  (LPUNKNOWN) static_cast<IClassFactory *>(GetExternalInterface() ),
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_MULTIPLEUSE,
                                  &m_ComId_1_0 ) );

        THROW_HRESULT(
            CoRegisterClassObject(CLSID_BackgroundCopyQMgr,
                                  (LPUNKNOWN) static_cast<IClassFactory *>(GetOldExternalInterface() ),
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_MULTIPLEUSE,
                                  &m_ComId_0_5 ) );

        return S_OK;
        }
    catch ( ComError error )
        {
        RevokeClassObjects();
        return error.Error();
        }
}

void
CJobManager::RevokeClassObjects()
{
    DeleteBackupWriter();

    if (m_ComId_1_5)
        {
        CoRevokeClassObject( m_ComId_1_5 );
        m_ComId_1_5 = 0;
        }

    if (m_ComId_1_0)
        {
        CoRevokeClassObject( m_ComId_1_0 );
        m_ComId_1_0 = 0;
        }

    if (m_ComId_0_5)
        {
        CoRevokeClassObject( m_ComId_0_5 );
        m_ComId_0_5 = 0;
        }
}

void CJobManager::Cleanup()
{
    RevokeClassObjects();

    if (m_pPD)
        {
        DeleteHttpDownloader( m_pPD );
        m_pPD = NULL;
        }

    if (m_hWininet)
        {
        FreeLibrary(m_hWininet);
        m_hWininet = NULL;
        }

    if ( m_hQuantumTimer )
        {
        CloseHandle( m_hQuantumTimer );
        m_hQuantumTimer = NULL;
        }

    LogInfo( "cleanup: marking manager inactive" );

    g_ServiceState = MANAGER_INACTIVE;
}

CJobManager::~CJobManager()
{
    Cleanup();
}

HRESULT CJobManager::CreateBackupWriter()
/*
    This function creates the backup writer object.

    Note: the vssapi.dll library is not available on Windows 2000. Also, even though
    it is present on Windows XP, it is not binary compatable with the version on 
    Windows Server. So, vssapi.dll is set to delay load and the APIs are only 
    called if this is Windows Server (v 5.2) or greater.
    
*/
{
    // Only initialize the vss writer if this is an OS whose version is later than
    // Windows Server (5.2)
    if (  (g_PlatformMajorVersion > 5)
       ||((g_PlatformMajorVersion == 5)&&(g_PlatformMinorVersion >= 2)) )
        {
        try
            {
            //
            // system support for the backup writer exists.  Initialize it.
            //
            m_BackupWriter = new CBitsVssWriter;

            //
            // Initialize the backup writer, if the infrastructure is present.
            //
            THROW_HRESULT( m_BackupWriter->Initialize( s_WRITERID,
                                                       s_WRITERNAME,
                                                       VSS_UT_SYSTEMSERVICE,
                                                       VSS_ST_OTHER
                                                       ));

            THROW_HRESULT( m_BackupWriter->Subscribe());
            }
        catch ( ComError err )
            {
            LogWarning("unable to init backup writer, hr %x at line %d", err.m_error, err.m_line );
            delete m_BackupWriter;  m_BackupWriter = NULL;
            // ignore the lack of writer
            }
        }

    return S_OK;
}

void CJobManager::DeleteBackupWriter()
{
    if (m_BackupWriter)
        {
        m_BackupWriter->Unsubscribe();
        delete m_BackupWriter;  m_BackupWriter = NULL;
        }

    if (m_hVssapi_dll)
        {
        FreeLibrary( m_hVssapi_dll );
        m_hVssapi_dll = NULL;
        }
}

void
CJobManager::Shutdown()
{
    g_ServiceState = MANAGER_TERMINATING;

    // 1. Block creation of new manager proxies.

    LogInfo( "shutdown: revoking class objects" );

    RevokeClassObjects();

    m_TaskScheduler.KillBackgroundTasks();

    // 1.5 halt network-change notification

    m_NetworkMonitor.CancelListen();

    // 5. Wait for calls in progress to finish.

    // releasing the reference for the hook thread, added during the constructor.
    //
    LogInfo("release: internal usage");
    NotifyInternalDelete();

    while (ActiveCallCount() > 0)
        {
        Sleep(50);
        }

    LogInfo( "shutdown: finished" );
}


void
CJobManager::TaskThread()
{
    HANDLE hWorkItemAvailable = m_TaskScheduler.GetWaitableObject();

    while (1)
        {
        DWORD dwRet = MsgWaitForMultipleObjectsEx( 1,
                                                   &hWorkItemAvailable,
                                                   INFINITE,
                                                   QS_ALLINPUT,
                                                   MWMO_ALERTABLE
                                                   );

        switch ( dwRet )
            {
            case WAIT_OBJECT_0:
                m_TaskScheduler.DispatchWorkItem();
                break;
            case WAIT_OBJECT_0 + 1:
                // There is one or more window message available. Dispatch them
                MSG msg;

                while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                    {
                    if ( msg.message == WM_QUIT )
                        return;

                    if (msg.message == WM_SESSION_CHANGE)
                        {
                        DWORD Session = (DWORD) msg.lParam;

                        if (msg.wParam)
                            {
                            m_Users.LogonSession( Session );
                            }
                        else
                            {
                            m_Users.LogoffSession( Session );
                            }
                        }

                    TranslateMessage(&msg);
                    DispatchMessage(&msg);

                    if (WaitForSingleObject(hWorkItemAvailable, 0) == WAIT_OBJECT_0)
                        m_TaskScheduler.DispatchWorkItem();
                    }
                break;

            case WAIT_IO_COMPLETION:
                //
                // an APC fired.
                //
                break;

            default:
                Sleep( 20 * 1000 );
                break;
            }
        }
}

//------------------------------------------------------------------------

HRESULT
CJobManager::CreateJob(
    LPCWSTR     DisplayName,
    BG_JOB_TYPE Type,
    GUID        Id,
    SidHandle   sid,
    CJob  **    ppJob,
    bool        OldStyleJob
    )
{
    HRESULT Hr = S_OK;
    *ppJob = NULL;
    //
    // create the job
    //
    try
        {
        if (Type != BG_JOB_TYPE_DOWNLOAD
#if !defined(BITS_V12)
            && Type != BG_JOB_TYPE_UPLOAD
            && Type != BG_JOB_TYPE_UPLOAD_REPLY
#endif
            )
            {
            throw ComError( E_NOTIMPL );
            }

        // Do not allow duplicate guids
        if ( m_OnlineJobs.Find( Id ) ||
             m_OfflineJobs.Find( Id ) )
            throw ComError( E_INVALIDARG );

        auto_ptr<WCHAR> TempDisplayName(NULL);
        DisplayName = TruncateString( DisplayName, MAX_DISPLAYNAME, TempDisplayName );

        ExtendMetadata();

        if (Type == BG_JOB_TYPE_DOWNLOAD)
            {
            *ppJob = new CJob( DisplayName, Type, Id, sid );

            if ( OldStyleJob )
                {
                COldGroupInterface *pOldGroup = new COldGroupInterface( *ppJob );

                (*ppJob)->SetOldExternalGroupInterface( pOldGroup );
                }
            }
        else
            {
            *ppJob = new CUploadJob( DisplayName, Type, Id, sid );
            }

        m_OnlineJobs.Add( *ppJob );

        m_TaskScheduler.InsertDelayedWorkItem( static_cast<CJobInactivityTimeout *>(*ppJob),
                                               g_GlobalInfo->m_JobInactivityTimeout
                                               );
        Serialize();
        }
    catch( ComError exception )
    {
        Hr = exception.Error();

        if (*ppJob)
            {
            (*ppJob)->UnlinkFromExternalInterfaces();
            delete *ppJob;
            *ppJob = NULL;
            }

        ShrinkMetadata();
    }

    return Hr;
}

HRESULT
CJobManager::GetJob(
    REFGUID id,
    CJob ** ppJob
    )
{
    *ppJob = NULL;

    CJob * job = m_OnlineJobs.Find( id );
    if (job != NULL)
        {
        if (S_OK != job->IsVisible())
            {
            return E_ACCESSDENIED;
            }

        job->UpdateLastAccessTime();
        *ppJob = job;
        return S_OK;
        }

    job = m_OfflineJobs.Find( id );
    if (job != NULL)
        {
        if (S_OK != job->IsVisible())
            {
            return E_ACCESSDENIED;
            }

        job->UpdateLastAccessTime();
        *ppJob = job;
        return S_OK;
        }

    return BG_E_NOT_FOUND;
}

HRESULT
CJobManager::SuspendJob(
    CJob * job
    )
{
    BG_JOB_STATE state = job->_GetState();

    switch (state)
        {
        case BG_JOB_STATE_SUSPENDED:
            {
            return S_OK;
            }

        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:

            InterruptDownload();
            // OK to fall through here

        case BG_JOB_STATE_TRANSFERRED:

            m_TaskScheduler.CancelWorkItem( static_cast<CJobCallbackItem *>(job) );

            // fall through

        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_ERROR:

            m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *>(job) );

            job->SetState( BG_JOB_STATE_SUSPENDED );
            job->UpdateModificationTime();

            ScheduleAnotherGroup();
            return S_OK;

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return S_OK;
            }
        }

    ASSERT( 0 );
    return S_OK;
}

bool
CJobManager::IsUserLoggedOn( SidHandle sid )
{
    CUser * user = m_Users.FindUser( sid, ANY_SESSION );

    if (!user)
        {
        return false;
        }

    user->DecrementRefCount();

    return true;
}

HRESULT
CJobManager::CloneUserToken(
    SidHandle sid,
    DWORD     session,
    HANDLE *  pToken
    )
{
    CUser * user = m_Users.FindUser( sid, session );

    if (!user)
        {
        return HRESULT_FROM_WIN32( ERROR_NOT_LOGGED_ON );
        }

    HRESULT hr = user->CopyToken( pToken );

    user->DecrementRefCount();

    return hr;
}

void CJobManager::TransferCurrentJob()
{
    LogDl("***********START********************");

    if (m_TaskScheduler.LockWriter() )
        {
        m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    if (NULL == m_CurrentJob)
        {
        LogDl( "no more items" );
        }
    else
        {
        LogDl("transferring job %p", m_CurrentJob);
        m_CurrentJob->Transfer();
        }

    // It's OK if the item has already been completed.
    //
    m_TaskScheduler.CompleteWorkItem();

    ScheduleAnotherGroup();

    m_TaskScheduler.UnlockWriter();

    LogDl("************END*********************");
}

void CJobManager::MoveJobOffline(
    CJob * job
    )
{
    m_OnlineJobs.Remove( job );
    m_OfflineJobs.Add( job );
}

void CJobManager::AppendOnline(
    CJob * job
    )
//
// moves a job to the end of the active list.
//
{
    if (!m_OnlineJobs.Remove( job ))
        {
        m_OfflineJobs.Remove( job );
        }

    m_OnlineJobs.Add( job );
}

void
CJobManager::UpdateRemoteSizes(
    CUnknownFileSizeList *pUnknownFileSizeList,
    HANDLE hToken,
    QMErrInfo *pErrorInfo,
    const PROXY_SETTINGS *ProxySettings,
    const CCredentialsContainer * Credentials
     )
{

    bool bTimeout = false;

    for(CUnknownFileSizeList::iterator iter = pUnknownFileSizeList->begin();
        iter != pUnknownFileSizeList->end() && !bTimeout; iter++ )
        {

        CFile *pFile        = iter->m_file;
        const WCHAR *pURL   = (const WCHAR*)iter->m_url;

        pErrorInfo->Clear();


        LogDl( "Retrieving remote infomation for %ls", pURL );


        UINT64 FileSize;
        FILETIME FileTime;

        m_pPD->GetRemoteFileInformation(
            hToken,
            pURL,
            &FileSize,
            &FileTime,
            pErrorInfo,
            ProxySettings,
            Credentials
            );

        // If we can't get the size for one file, skip that file
        // and move to other files in the file.

        if (pErrorInfo->result != QM_FILE_DONE )
            {
            LogWarning( "Unable to retrieve remote information for %ls", pURL );
            continue;
            }

        // Update size in file.

        if ( m_TaskScheduler.LockWriter() )
            {
            m_TaskScheduler.AcknowledgeWorkItemCancel();
            pErrorInfo->result = QM_FILE_ABORTED;
            return;
            }

        pFile->SetBytesTotal( FileSize );

        //
        // A zero-length file will not be downloading any info, so it skips the normal path
        // for setting the correct creation time. Set it here.
        //
        if (FileSize == 0 &&
            (FileTime.dwLowDateTime != 0 || FileTime.dwHighDateTime != 0))
            {
            DWORD err = pFile->SetLocalFileTime( FileTime );

            if (err)
                {
                pErrorInfo->result = QM_FILE_TRANSIENT_ERROR;
                pErrorInfo->Set( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, err, NULL );
                }
            }

        if (CheckForQuantumTimeout())
            {
            bTimeout = true;
            }

        m_TaskScheduler.UnlockWriter();
        }

}

void
CJobManager::InterruptDownload()
{
    LogInfo( "Interrupting download...\n");

    // Cancel the downloader workitem.  CancelWorkItem
    // should ignore the request if the a download isn't running or pending.
    // Writer lock required!!!!!

    m_TaskScheduler.CancelWorkItem( this );

    // Now you must call ScheduleAnotherGroup, in order for the downloader to download anything.
}

void
CJobManager::ScheduleAnotherGroup(
    bool fInsertNetworkDelay
    )
/*++

Description:

    Called by any thread to make sure that the highest-priority available job is being downloaded.
    It finds the highest-priority job that is in the QUEUED or RUNNING state.
    If this job is different from the current download job, the current job is cancelled and
    the new job is started.  If no job is currently running, the new job is started.

    Starting the new job requires interrupting the download thread.

At entry:

    m_CurrentJob is the job being downloaded
    If the downloader thread is active, then the manager's work item is in the scheduler.
    Otherwise it is not.

At exit:

    the best available job to download is in m_CurrentJob, or NULL if none available
    If a job is available, the work item is in the task scheduler.


--*/
{
    CJob *pOldCurrentJob = m_CurrentJob;

    if (IsServiceShuttingDown())
        {
        LogInfo("no job scheduled; service is shutting down.");
        m_CurrentJob = NULL;
        }
    else
        {
        //
        // Choose the best candidate, which may be the old current job.
        //
        ChooseCurrentJob();

        #if DBG

        // do some validation checking on the queue

        ULONG RunningJobs = 0;

        for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
            {
            if ( iter->IsRunning() )
                RunningJobs++;
            }

        if (m_CurrentJob == NULL)
            {
            ASSERT( RunningJobs == 0 );
            }
        else
            {
            // zero if the download item is queued, one if running
            //
            ASSERT( RunningJobs == 0 || RunningJobs == 1 );
            }

        #endif
        }

    if (m_CurrentJob)
        {

        if ( m_CurrentJob != pOldCurrentJob )
            m_TaskScheduler.CancelWorkItem( this );

        if (!m_TaskScheduler.IsWorkItemInScheduler( this ))
            {
            if (fInsertNetworkDelay)
                {
                m_TaskScheduler.InsertDelayedWorkItem( this,
                                                       NETWORK_INIT_TOLERANCE_SECS * NanoSec100PerSec );
                }
            else
                {
                m_TaskScheduler.InsertWorkItem( this );
                }
            }
        }
    else
        {
        m_TaskScheduler.CancelWorkItem( this );
        }
}

void
CJobManager::ChooseCurrentJob()
{
    CJob * NewJob = NULL;

    if (m_NetworkMonitor.GetAddressCount() == 0)
        {
        NewJob = NULL;
        }
    else
        {
        // Look at all the jobs and choose the best one
        for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
            {
            if (iter->IsRunnable())
                {
                BG_JOB_PRIORITY priority = iter->_GetPriority();

                if ( !NewJob || ( priority < NewJob->_GetPriority() ) )
                    {
                    NewJob = &(*iter);
                    }
                }
            }
        }

    LogInfo( "scheduler: current=%p   new=%p", m_CurrentJob, NewJob );

    if (m_CurrentJob == NewJob)
        {
        return;
        }

    if ( m_CurrentJob )
        {
        LogInfo( "scheduler: current priority %u", m_CurrentJob->_GetPriority() );

        //
        // an inactive job goes to QUEUED state if we have network connectivity,
        // TRANSIENT_ERROR state otherwise.
        //
        if ( m_CurrentJob->IsRunning() )
            {
            m_CurrentJob->RecalcTransientError();
            }
        }

    if ( NewJob )
        {
        LogInfo( "scheduler: new priority %u", NewJob->_GetPriority() );
        SetQuantumTimeout();
        }

    m_CurrentJob = NewJob;
}

void
CJobManager::RetaskJob( CJob *pJob )
{
    if ( pJob->IsRunning() )
        {
        InterruptDownload();
        }

    ScheduleAnotherGroup();
}

void CALLBACK
CJobManager::NetworkChangeCallback(
    PVOID arg
    )
{
    reinterpret_cast<CJobManager *>(arg)->OnNetworkChange();
}

void
CJobManager::OnNetworkChange()
{

    if (g_ServiceState == MANAGER_TERMINATING)
        {
        LogInfo("network change: manager terminating");
        return;
        }

    LogInfo("network adapters changed: now %d active", m_NetworkMonitor.GetAddressCount());

    if (m_NetworkMonitor.GetAddressCount() > 0)
        {
        ReactivateTransientErrorJobs();
        }
    else
        {
        MarkJobsWithNetDisconnected();
        }

    {
    HoldWriterLock lock( &m_TaskScheduler );

    //
    // The previous proxy data is  incorrect if we have switched from a corporate net to roaming or vice-versa..
    //
    g_ProxyCache->Invalidate();

    ScheduleAnotherGroup();
    }

    for (int i=1; i <= 3; ++i)
        {
        HRESULT hr;

        hr = m_NetworkMonitor.Listen( NetworkChangeCallback, this );
        if (SUCCEEDED(hr))
            {
            return;
            }

        LogError( "re-listen failed %x", hr);
        Sleep( 1000 );
        }
}

void
CJobManager::MarkJobsWithNetDisconnected()
{
    HoldWriterLock lock( &m_TaskScheduler );

    for (CJobList::iterator iter=m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnNetworkDisconnect();
        }

    for (CJobList::iterator iter=m_OfflineJobs.begin(); iter != m_OfflineJobs.end(); ++iter)
        {
        iter->OnNetworkDisconnect();
        }

    ScheduleAnotherGroup();
}


void
CJobManager::ReactivateTransientErrorJobs()
{
    HoldWriterLock lock( &m_TaskScheduler );

    for (CJobList::iterator iter=m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnNetworkConnect();
        }

    for (CJobList::iterator iter=m_OfflineJobs.begin(); iter != m_OfflineJobs.end(); ++iter)
        {
        iter->OnNetworkConnect();
        }

    ScheduleAnotherGroup( true );
}

void
CJobManager::UserLoggedOn(
    SidHandle sid
    )
{
    HoldWriterLock LockHolder( &m_TaskScheduler );

    CJobList::iterator iter = m_OfflineJobs.begin();

    while (iter != m_OfflineJobs.end())
        {
        if (false == iter->IsOwner( sid ))
            {
            ++iter;
            continue;
            }

        LogInfo("manager : moving job %p to online list", &(*iter) );

        //
        // move the job to the online list.
        //
        CJobList::iterator next = iter;

        ++next;

        m_OfflineJobs.erase( iter );
        m_OnlineJobs.push_back( *iter );

        iter = next;
        }

    //
    // Make sure a group is running.
    //
    ScheduleAnotherGroup();
}

void
CJobManager::UserLoggedOff(
    SidHandle sid
    )
{
    bool fReschedule = false;

    HoldWriterLock LockHolder( &m_TaskScheduler );

    //
    // If a job is in progress and the user owns it, cancel it.
    //
    if (m_CurrentJob &&
        m_CurrentJob->IsOwner( sid ))
        {
        InterruptDownload();
        fReschedule = true;
        }

    //
    // Move all the user's jobs into the offline list.
    //
    CJobList::iterator iter = m_OnlineJobs.begin();

    while (iter != m_OnlineJobs.end())
        {
        //
        // Skip over other users' job.
        // Also skip over the currently downloading job, which will be handled by the download thread.
        //
        if (false == iter->IsOwner( sid ) ||
            &(*iter) == m_CurrentJob)
            {
            ++iter;
            continue;
            }

        LogInfo("manager : moving job %p to offline list", &(*iter) );

/*
this should't ever be true, since we skip over m_CurrentJob.

*/      ASSERT( false == iter->IsRunning() );

        //
        // move the job to the online list.
        //
        CJobList::iterator next = iter;

        ++next;

        m_OnlineJobs.erase( iter );
        m_OfflineJobs.push_back( *iter );

        iter = next;
        }

    if (fReschedule)
        {
        ScheduleAnotherGroup();
        }
}

void
CJobManager::ResetOnlineStatus(
    CJob *pJob,
    SidHandle sid
    )
//
// Called when a job owner changes.  This fn checks whether the job needs to be moved
// from the offline list to the online list.  (If the job needs to move from the online
// list to the offline list, the downloader thread will take care of it when the job
// becomes the current job.)
//
{

    if ( IsUserLoggedOn( sid ) &&
         m_OfflineJobs.Remove( pJob ) )
        {
        m_OnlineJobs.Add( pJob );
        }
}

size_t
CJobManager::MoveActiveJobToListEnd(
    CJob *pJob
    )
{

    if (m_NetworkMonitor.GetAddressCount() == 0)
        {
        // if the net is disconnected, no need to rearrange jobs.
        //
        return 1;
        }

    ASSERT( m_TaskScheduler.IsWriter() );

    // Returns the number of queue or running jobs with a higher or same priority as ourself.

    ASSERT( pJob->IsRunnable() );

    size_t PossibleActiveJobs = 0;

    CJobList::iterator jobpos = m_OnlineJobs.end();

    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        if ( iter->IsRunnable() &&
             iter->_GetPriority() <= pJob->_GetPriority() )
            {
            PossibleActiveJobs++;
            }

        if ( &(*iter) == pJob )
            {
            jobpos = iter;
            }
        }

    //
    // If the job is online, and another job can be pushed to the front,
    // push our job to the back.
    //
    if ( PossibleActiveJobs > 1 && jobpos != m_OnlineJobs.end())
        {
        // move job to the end of the list.
        m_OnlineJobs.erase( jobpos );

        m_OnlineJobs.push_back( *pJob );
        }
    else if (jobpos == m_OnlineJobs.end())
        {
        LogWarning("resuming an offline job");
        }

    return PossibleActiveJobs;
}

void
CJobManager::SetQuantumTimeout()
{
   LARGE_INTEGER QuantumTime;
   QuantumTime.QuadPart = -g_GlobalInfo->m_TimeQuantaLength;

   BOOL bResult =
   SetWaitableTimer(
       m_hQuantumTimer,
       &QuantumTime,
       0,
       NULL,
       NULL,
       FALSE );
   ASSERT( bResult );
}

bool
CJobManager::CheckForQuantumTimeout()
{

    DWORD dwResult =
        WaitForSingleObject( m_hQuantumTimer, 0 );

    if ( WAIT_OBJECT_0 != dwResult)
        {
        // The timer didn't expire, so we have nothing to do.
        return false;
        }

    // The timeout fired so we need to move the current job
    // to the end of the list and signal the downloader to abort.
    // Do not cancel the current work item and do not change the current
    // job. Just let the downloader exit and let it call ScheduleAnotherGroup
    // to switch jobs if needed.

    // Special case.  If only one RUNNING or QUEUED job exists in the list with
    // a priority >= our own, then we have no reason to switch tasks.
    // Just reset the timer and continue.

    bool fTookWriter = false;

    if (!m_TaskScheduler.IsWriter())
        {
        if (m_TaskScheduler.LockWriter() )
            {
            // cancelled; can't tell whether there is more than one job - assume the worst.
            return true;
            }

        fTookWriter = true;
        }

    ASSERT( m_CurrentJob );
    size_t PossibleActiveJobs = MoveActiveJobToListEnd( m_CurrentJob );

    if (fTookWriter)
        {
        m_TaskScheduler.UnlockWriter();
        }

    if ( 1 == PossibleActiveJobs )
        {

        LogInfo( "Time quantum fired, but nothing else can run.  Ignoring and resetting timer.");

        SetQuantumTimeout();

        return false;

        }

    LogInfo( "Time quantum fired, moving job to the end of the queue.");
    return true; // signal downloader to abort
}

extern HMODULE g_hInstance;

HRESULT
CJobManager::GetErrorDescription(
    HRESULT hResult,
    DWORD LanguageId,
    LPWSTR *pErrorDescription )
{
    // Do not allow 0 for now, untill propagation of thread error is investigated more.
    if (!LanguageId)
        {
        return E_INVALIDARG;
        }

    TCHAR *pBuffer = NULL;

    //
    // Use the following search path to find the message.
    //
    // 1. This DLL
    // 2. wininet.dll
    // 3. the system

    DWORD dwSize =
        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
            g_hInstance,
            (DWORD)hResult,
            LanguageId,
            (LPTSTR)&pBuffer,
            0,
            NULL );

    if ( !dwSize )
        {

        if ( GetLastError() == ERROR_OUTOFMEMORY )
            {
            return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
            }

        {

        if (!m_hWininet)
            {
            m_hWininet =
                LoadLibraryEx( _T("winhttp.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
            }

        if ( m_hWininet )
            {

            dwSize =
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                    m_hWininet,
                    (DWORD)(0x0000FFFF & (hResult)),
                    LanguageId,
                    (LPTSTR)&pBuffer,
                    0,
                    NULL );

            if ( !dwSize && ( GetLastError() == ERROR_OUTOFMEMORY ) )
                {
                return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                }

            }


        }

        if ( !dwSize )
            {

            dwSize =
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    (DWORD)hResult,
                    LanguageId,
                    (LPTSTR)&pBuffer,
                    0,
                    NULL );


            if (!dwSize)
                {
                return HRESULT_FROM_WIN32( GetLastError() );
                }

            }

        }

    ++dwSize;       // needs to include trailing NULL

    ASSERT( pBuffer );

#if !defined(_UNICODE)
#error need to add ASCII to unicode conversion here
#else

    *pErrorDescription = MidlCopyString( pBuffer );

    LocalFree( pBuffer );

    return (*pErrorDescription) ? S_OK : E_OUTOFMEMORY;
#endif
}


HRESULT
CJobManager::Serialize()
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    HRESULT hr;

    try
    {
        //
        // Serialization requires the thread to run in local-system context.
        // If the thread is impersonating a COM client, it must revert.
        //
        CSaveThreadToken tok;

        RevertToSelf();

        // The service should automatically start if any groups
        // are in the waiting/Running state or a logged off user has groups.
        bool bAutomaticStart;
        bAutomaticStart = (m_OnlineJobs.size() > 0) || (m_OfflineJobs.size() > 0);

        LogSerial("Need to set service to %s start", bAutomaticStart ? "auto" : "manual" );
        if ( bAutomaticStart )
            {
            // If we can't set the service to autostart, it's a fatal error.
            // Fail the serialize at this point.
            THROW_HRESULT( SetServiceStartup( bAutomaticStart ) );
            }

        CQmgrWriteStateFile StateFile( *this );

        HANDLE hFile = StateFile.GetHandle();

        SafeWriteBlockBegin( hFile, PriorityQueuesStorageGUID );

        m_OnlineJobs.Serialize( hFile );
        m_OfflineJobs.Serialize( hFile );

        SafeWriteBlockEnd( hFile, PriorityQueuesStorageGUID );

        StateFile.CommitFile();

        if ( !bAutomaticStart )
            {
            // If we can't set the service to manual, its not a big deal.  The worst
            // that should happen is we start when we really don't need to.
            hr = SetServiceStartup( bAutomaticStart );
            if ( !SUCCEEDED( hr ) )
                {
                LogWarning("Couldn't set service startup to manual, ignoring. Hr 0x%8.8X", hr );
                }
            }

        LogSerial( "finished");
        hr = S_OK;
    }

    catch( ComError Error )
    {
       LogWarning("Error %u writing metadata\n", Error.Error() );
       hr = Error.Error();
    }

    return hr;
}

HRESULT
CJobManager::Unserialize()
{
    HRESULT hr;

    try
        {
        BOOL fIncludeLogoffList;
        CQmgrReadStateFile StateFile( *this );

        HANDLE hFile = StateFile.GetHandle();

        SafeReadBlockBegin( hFile, PriorityQueuesStorageGUID );

        //
        // In the Serialize() code, the first is online jobs and the second is offline.
        // When unserializing, the set of logged-in users is likely to be different, so
        // we pull them all in and then lazily move them to the offline list.
        //
        m_OnlineJobs.Unserialize( hFile );
        m_OnlineJobs.Unserialize( hFile );

        SafeReadBlockEnd( hFile, PriorityQueuesStorageGUID );

        StateFile.ValidateEndOfFile();

        hr = S_OK;
        }
    catch( ComError err )
        {
        //
        // File corruption is reason to delete the group data and start fresh.
        // Other errors, like out-of-memory, are not.
        //
        LogError( "Error %u reading metadata", err.Error() );

        hr = err.Error();

        if (hr == E_INVALIDARG ||
            hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ))
            {
            LogSerial("clearing job list");

            if (hr == E_INVALIDARG )
                {
                g_EventLogger->ReportStateFileCleared();
                }

            m_OnlineJobs.Clear();
            m_OfflineJobs.Clear();
            hr = S_OK;
            }
        }

    return hr;
}

void
CJobManager::OnDeviceLock(
    const WCHAR *CanonicalVolume )
{
    bool fChanged = false;

    // Look at all the jobs and move the ones for this drive to the
    // transient error state.
    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        fChanged |= iter->OnDeviceLock( CanonicalVolume );
        }

    if (fChanged)
        {
        ScheduleAnotherGroup();
        Serialize();
        }
}

void
CJobManager::OnDeviceUnlock(
    const WCHAR *CanonicalVolume )
{
    bool fChanged = false;

    // Look at all the jobs and retry the ones that are in the transient error state
    // do to this drive being locked.
    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        fChanged |= iter->OnDeviceUnlock( CanonicalVolume );
        }

    if (fChanged)
        {
        ScheduleAnotherGroup();
        Serialize();
        }
}

void
CJobManager::OnDiskChange(
    const WCHAR *CanonicalVolume,
    DWORD VolumeSerialNumber )
{

    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnDiskChange( CanonicalVolume, VolumeSerialNumber );
        }
    ScheduleAnotherGroup();
    Serialize();
}

void
CJobManager::OnDismount(
    const WCHAR *CanonicalVolume )
{
    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnDismount( CanonicalVolume );
        }
    ScheduleAnotherGroup();
    Serialize();
}


BOOL
CJobList::Add(
    CJob * job
    )
//
// adds a single group to the list.
//
{
    push_back( *job );

    return TRUE;
}

CJob *
CJobList::Find(
    REFGUID id
    )
{
    iterator iter;

    for (iter=begin(); iter != end(); ++iter)
        {
        GUID jobid = iter->GetId();

        if (id == jobid)
            {
            return &(*iter);
            }
        }

    return NULL;
}

BOOL
CJobList::Remove(
    CJob * job
    )
//
// removes a single group to the list.  Quite inefficient for large lists.
//
{
    iterator iter;

    for (iter=begin(); iter != end(); ++iter)
        {
        if (job == &(*iter))
            {
            erase( iter );

            return TRUE;
            }
        }

    return FALSE;
}

void
CJobList::Clear()
{
    iterator iter;

    while ((iter=begin()) != end())
        {
        CJob * job = &(*iter);

        LogInfo("clearing %p", job);

        erase( iter );

        job->Release();
        }
}


void
CJobList::Serialize( HANDLE hFile )
{
    DWORD dwNumberOfGroups = 0;

    dwNumberOfGroups = size();

    SafeWriteBlockBegin( hFile, GroupListStorageGUID );
    SafeWriteFile( hFile, dwNumberOfGroups );

    iterator iter;
    for (iter=begin(); iter != end(); ++iter)
        {
        iter->Serialize(hFile);
        }

    SafeWriteBlockEnd( hFile, GroupListStorageGUID );
}

void
CJobList::Unserialize(
    HANDLE hFile
    )
{
    SafeReadBlockBegin( hFile, GroupListStorageGUID );

    DWORD dwNumberOfGroups;
    SafeReadFile( hFile, &dwNumberOfGroups );

    for (int i = 0; i < dwNumberOfGroups; i++)
        {
        CJob * job = NULL;

        try
            {
            job = CJob::UnserializeJob( hFile );

            push_back( *job );

            LogSerial( "added job %p to queue %p, priority %d",
                       job, this, job->_GetPriority() );
            }
        catch ( ComError err )
            {
            LogError( "error in joblist unserialize 0x%x", err.Error() );
            throw;
            }
        }

    SafeReadBlockEnd( hFile, GroupListStorageGUID );

}

CJobList::~CJobList()
{
    ASSERT( g_ServiceState != MANAGER_ACTIVE );

    iterator iter;

    while ( (iter=begin()) != end() )
        {
        CJob * job = &(*iter);

        LogInfo("deleting job %p", job );

        iter.excise();

        job->UnlinkFromExternalInterfaces();
        delete job;
        }
}

CJobManagerExternal::CJobManagerExternal() :
    m_ServiceInstance( g_ServiceInstance ),
    m_refs(1),
    m_pJobManager( NULL )
{
}

STDMETHODIMP
CJobManagerExternal::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if (iid == IID_IUnknown)
        {
        *ppvObject = static_cast<IBackgroundCopyManager *>(this);

        LogInfo("mgr: QI for IUnknown");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if (iid == IID_IBackgroundCopyManager)
        {
        *ppvObject = static_cast<IBackgroundCopyManager *>(this);

        LogInfo("mgr: QI for IManager");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if (iid == IID_IClassFactory)
        {
        *ppvObject = static_cast<IClassFactory *>(this);

        LogInfo("mgr: QI for IFactory");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if (iid == __uuidof(IBitsTest1))
        {
        *ppvObject = static_cast<IBitsTest1 *>(this);

        LogInfo("mgr: QI for IFactory");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "iid %!guid!, Hr %x", &iid, Hr );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG
CJobManagerExternal::AddRef()
{
    BEGIN_EXTERNAL_FUNC;

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    return newrefs;

    END_EXTERNAL_FUNC;
}

ULONG
CJobManagerExternal::Release()
{
    BEGIN_EXTERNAL_FUNC;

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC;
}

/************************************************************************************
IClassFactory Implementation
************************************************************************************/
HRESULT CJobManagerExternal::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject)
{
    BEGIN_EXTERNAL_FUNC

    HRESULT hr = S_OK;

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        if ((iid == IID_IBackgroundCopyManager) || (iid == IID_IUnknown))
        {
            hr = QueryInterface(iid, ppvObject);
        }
        else
        {
            hr = E_NOTIMPL;
        }
    }

    LogRef( "iid %!guid!, Hr %x, object at %p", &iid, hr, *ppvObject );

    return hr;

    END_EXTERNAL_FUNC
}

HRESULT CJobManagerExternal::LockServer(BOOL fLock)
{
    BEGIN_EXTERNAL_FUNC

    LogRef( "LockServer(%d)", fLock);

    return GlobalLockServer( fLock );

    END_EXTERNAL_FUNC
}

/************************************************************************************
IBackgroundCopyManager Implementation
************************************************************************************/
HRESULT STDMETHODCALLTYPE
CJobManagerExternal::CreateJobInternal (
    /* [in] */ LPCWSTR DisplayName,
    /* [in] */ BG_JOB_TYPE Type,
    /* [out] */ GUID *pJobId,
    /* [out] */ IBackgroundCopyJob **ppJob)
{
    CLockedJobManagerWritePointer LockedJobManager(m_pJobManager );
    LogPublicApiBegin( "DisplayName %S, Type %u", DisplayName, Type );

    HRESULT Hr = S_OK;
    CJob * job = NULL;
    //
    // create the job
    //
    try
        {
        THROW_HRESULT( LockedJobManager.ValidateAccess());

        //
        // validate parameters
        //
        if (DisplayName == NULL ||
            pJobId      == NULL ||
            ppJob       == NULL)
            {
            throw ComError( E_INVALIDARG );
            }

        *ppJob = NULL;

        GUID Id;

        if (0 !=UuidCreate( &Id ))
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ));
            }

        THROW_HRESULT( LockedJobManager->CreateJob( DisplayName, Type, Id, GetThreadClientSid(), &job ));

        *ppJob = job->GetExternalInterface();
        (*ppJob)->AddRef();

        *pJobId = Id;
        Hr = S_OK;
        }

    catch( ComError exception )
        {
        Hr = exception.Error();
        memset(pJobId, 0, sizeof(*pJobId) );
        }

    LogPublicApiEnd( "pJobId %p(%!guid!), ppJob %p(%p)",
                     pJobId, pJobId, ppJob, *ppJob );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobManagerExternal::GetJobInternal(
    /* [in] */ REFGUID jobID,
    /* [out] */ IBackgroundCopyJob **ppJob)
{
    CLockedJobManagerReadPointer LockedJobManager(m_pJobManager);
    LogPublicApiBegin( "jobID %!guid!", &jobID );

    HRESULT Hr = LockedJobManager.ValidateAccess();

    if (SUCCEEDED( Hr ) )
        {
        Hr = BG_E_NOT_FOUND;
        *ppJob = NULL;

        CJob *pJob = NULL;

        Hr = LockedJobManager->GetJob( jobID, &pJob );
        if (SUCCEEDED(Hr))
            {
            *ppJob = pJob->GetExternalInterface();
            (*ppJob)->AddRef();
            Hr = S_OK;
            }
        }

    LogPublicApiEnd( "jobID %!guid!, pJob %p", &jobID, *ppJob );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobManagerExternal::EnumJobsInternal(
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumBackgroundCopyJobs **ppEnum)
{
    HRESULT Hr = S_OK;

    CLockedJobManagerReadPointer LockedJobManager(m_pJobManager );
    LogPublicApiBegin( "dwFlags %u, ppEnum %p", dwFlags, ppEnum );

    *ppEnum = NULL;

    CEnumJobs *pEnum = NULL;

    try
        {
        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        if ( dwFlags & ~(BG_JOB_ENUM_ALL_USERS) )
            {
            throw ComError(E_NOTIMPL);
            }

        bool bHideJobs = !( dwFlags & BG_JOB_ENUM_ALL_USERS );

        if (!bHideJobs)
            THROW_HRESULT( DenyNonAdminAccess() );

        SidHandle sid;

        if (bHideJobs)
            {
            sid = GetThreadClientSid();
            }

        pEnum = new CEnumJobs;

        for (CJobList::iterator iter = LockedJobManager->m_OnlineJobs.begin();
             iter != LockedJobManager->m_OnlineJobs.end();
             ++iter)
            {

            if ( bHideJobs )
                {
                if (!iter->IsOwner( sid ))
                    {
                    continue;
                    }
                }

            pEnum->Add( iter->GetExternalInterface() );
            }

        for (CJobList::iterator iter = LockedJobManager->m_OfflineJobs.begin();
             iter != LockedJobManager->m_OfflineJobs.end();
             ++iter)
            {

            if ( bHideJobs )
                {
                if (!iter->IsOwner( sid ))
                    {
                    continue;
                    }
                }

            pEnum->Add( iter->GetExternalInterface() );
            }

        *ppEnum = pEnum;
        }

    catch( ComError exception )
        {
        Hr = exception.Error();
        SafeRelease( pEnum );
        }

    LogPublicApiEnd( "dwFlags %u, ppEnum %p(%p)", dwFlags, ppEnum, *ppEnum );
    return Hr;
}

STDMETHODIMP
CJobManagerExternal::GetErrorDescriptionInternal(
    HRESULT hResult,
    DWORD LanguageId,
    LPWSTR *pErrorDescription
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "hResult %!winerr!, LanguageId %u, pErrorDescription %p", hResult, LanguageId, pErrorDescription );
    *pErrorDescription = NULL;

    Hr = g_Manager->CheckClientAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = g_Manager->GetErrorDescription( hResult, LanguageId, pErrorDescription );
        }

    LogPublicApiEnd( "hResult %!winerr!, LanguageId %u, pErrorDescription %p(%S)", hResult, LanguageId, pErrorDescription,
                     (*pErrorDescription ? *pErrorDescription : L"NULL") );
    return Hr;
}


STDMETHODIMP
CJobManagerExternal::GetBitsDllPath(
    LPWSTR *pVal
    )
{
    HRESULT Hr = S_OK;

    *pVal = NULL;

    Hr = g_Manager->CheckClientAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = (LPWSTR) CoTaskMemAlloc((1+MAX_PATH)*sizeof(wchar_t));
        if (*pVal == NULL)
            {
            Hr = E_OUTOFMEMORY;
            }
        else
            {
            if (!GetModuleFileName( g_hInstance, *pVal, 1+MAX_PATH))
                {
                Hr = HRESULT_FROM_WIN32( GetLastError() );
                CoTaskMemFree( *pVal );
                }
            }
        }

    LogPublicApiEnd( "hResult %!winerr!, path (%S)", Hr, (*pVal ? *pVal : L"NULL") );
    return Hr;
}

HRESULT
CJobManager::CheckClientAccess()
{
    try
        {
        CNestedImpersonation imp;

        if (imp.CopySid() == g_GlobalInfo->m_AnonymousSid)
            {
            throw ComError( E_ACCESSDENIED );
            }

        HRESULT hr = IsRemoteUser();

        if (FAILED(hr) )
            throw ComError( hr );

        if ( S_OK == hr )
            throw ComError( BG_E_REMOTE_NOT_SUPPORTED );

        if (IsTokenRestricted( imp.QueryToken()))
            {
            throw ComError( E_ACCESSDENIED );
            }

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

CDeviceNotificationController::~CDeviceNotificationController()
{
    for( CHandleToNotify::iterator iter = m_HandleToNotify.begin(); iter != m_HandleToNotify.end(); iter++ )
        {
        UnregisterDeviceNotification( iter->second->m_hDeviceNotify );
        delete iter->second;
        }
}

void
CDeviceNotificationController::DeleteNotify(
    CDriveNotify *pNotify
    )
{
    RTL_VERIFY( m_HandleToNotify.erase(  pNotify->m_hDeviceNotify ) );
    RTL_VERIFY( m_CanonicalVolumeToNotify.erase( pNotify->m_CanonicalName ) );
    UnregisterDeviceNotification( pNotify->m_hDeviceNotify );
    ASSERT( NULL != pNotify );
    delete pNotify;
}


DWORD
CDeviceNotificationController::OnDeviceEvent(
    DWORD dwEventType,
    LPVOID lpEventData )
{
    switch( dwEventType )
        {
        case DBT_CUSTOMEVENT:
            {

            PDEV_BROADCAST_HANDLE pdev = (PDEV_BROADCAST_HANDLE)lpEventData;

            LogInfo( "Received DBT_CUSTOMEVENT(%!guid!) event for handle %p",
                     &pdev->dbch_eventguid, pdev->dbch_hdevnotify );

            CHandleToNotify::iterator iter = m_HandleToNotify.find( pdev->dbch_hdevnotify );
            if ( m_HandleToNotify.end() == iter )
                {
                LogWarning("DBT_CUSTOMEVENT(%!guid!) received for unknown notify handle %p",
                           &pdev->dbch_eventguid, pdev->dbch_hdevnotify );
                return NO_ERROR;
                }
            CDriveNotify *pNotify = iter->second;
            ASSERT( pNotify );

            if ( ( GUID_IO_VOLUME_LOCK == pdev->dbch_eventguid ) ||
                 ( GUID_IO_VOLUME_DISMOUNT == pdev->dbch_eventguid ) )
                {
                ++pNotify->m_LockCount;

                LogInfo( "GUID_IO_VOLUME_LOCK or _VOLUME_DISMOUNT received for drive %ls, new locks %d / %d",
                         (const WCHAR*)pNotify->m_CanonicalName, pNotify->m_RemoveCount, pNotify->m_LockCount );

                if ((0 == pNotify->m_RemoveCount) && (1 == pNotify->m_LockCount))
                    OnDeviceLock( pNotify->m_CanonicalName );

                return NO_ERROR;
                }
            else if ( ( GUID_IO_VOLUME_UNLOCK == pdev->dbch_eventguid ) ||
                      ( GUID_IO_VOLUME_LOCK_FAILED == pdev->dbch_eventguid ) ||
                      ( GUID_IO_VOLUME_MOUNT == pdev->dbch_eventguid ) ||
                      ( GUID_IO_VOLUME_DISMOUNT_FAILED == pdev->dbch_eventguid ) )
                {
                --pNotify->m_LockCount;

                LogInfo( "GUID_IO_VOLUME_UNLOCK, _LOCK_FAILED or _DISMOUNT_FAILED received for drive %ls, new locks %d / %d",
                         (const WCHAR*)pNotify->m_CanonicalName, pNotify->m_RemoveCount, pNotify->m_LockCount);

                if ((0 == pNotify->m_RemoveCount) && (0 == pNotify->m_LockCount))
                    OnDeviceUnlock( pNotify->m_CanonicalName );

                return NO_ERROR;
                }
            else
                {

                LogWarning("Received unknown DBT_CUSTOMEVENT(%!guid!) event for handle %p",
                           &pdev->dbch_eventguid, pdev->dbch_hdevnotify );
                return NO_ERROR;

                }

            }

        case DBT_DEVICEQUERYREMOVE:
        case DBT_DEVICEQUERYREMOVEFAILED:
        case DBT_DEVICEREMOVEPENDING:
        case DBT_DEVICEREMOVECOMPLETE:
            {
                PDEV_BROADCAST_HANDLE pdev = (PDEV_BROADCAST_HANDLE)lpEventData;
                LogInfo( "Received devicechange event %u received for handle %p", dwEventType, pdev->dbch_hdevnotify );

                CHandleToNotify::iterator iter = m_HandleToNotify.find( pdev->dbch_hdevnotify );
                if ( m_HandleToNotify.end() == iter )
                    {
                    LogWarning("device change event received for unknown notify handle %p", pdev->dbch_hdevnotify );
                    return NO_ERROR;
                    }
                CDriveNotify *pNotify = iter->second;
                ASSERT( pNotify );

                switch( dwEventType )
                    {

                    case DBT_DEVICEQUERYREMOVE:

                        ++pNotify->m_RemoveCount;

                        LogInfo( "DBT_DEVICEQUERYREMOVE received for drive %ls, new locks %d / %d",
                                 (const WCHAR*)pNotify->m_CanonicalName, pNotify->m_RemoveCount, pNotify->m_LockCount );

                        if ((1 == pNotify->m_RemoveCount) && (0 == pNotify->m_LockCount))
                            OnDeviceLock( pNotify->m_CanonicalName );

                        return NO_ERROR;

                    case DBT_DEVICEQUERYREMOVEFAILED:

                        if (pNotify->m_RemoveCount > 0)
                            {
                            --pNotify->m_RemoveCount;

                            LogInfo( "DBT_DEVICEQUERYREMOVEFAILED received for drive %ls, new locks %d / %d",
                                     (const WCHAR*)pNotify->m_CanonicalName, pNotify->m_RemoveCount, pNotify->m_LockCount );

                            if ((0 == pNotify->m_RemoveCount) && (0 == pNotify->m_LockCount))
                                OnDeviceUnlock( pNotify->m_CanonicalName );
                            }
                        else
                            {
                            LogWarning("DBT_DEVICEQUERYREMOVEFAILED received for drive %ls, duplicate notification; ignoring",
                                       (const WCHAR*)pNotify->m_CanonicalName );
                            }

                        return NO_ERROR;

                    case DBT_DEVICEREMOVECOMPLETE:
                    case DBT_DEVICEREMOVEPENDING:
                        LogInfo( "DBT_DEVICEREMOVECOMPLETE or DBT_DEVICEREMOVEPENDING received for drive %ls, failing jobs",
                                 ( const WCHAR*) pNotify->m_CanonicalName );
                        OnDismount( pNotify->m_CanonicalName );
                        DeleteNotify( pNotify );
                        return NO_ERROR;

                    default:
                        ASSERT(0);
                        return NO_ERROR;
                    }

        }

        default:
            LogInfo( "Unknown device event %u", dwEventType );
            return NO_ERROR;
        }
}

HRESULT
CDeviceNotificationController::IsVolumeLocked(
    const WCHAR *CanonicalVolume
    )
{

    HRESULT Hr = S_OK;
    try
    {
        CCanonicalVolumeToNotify::iterator iter = m_CanonicalVolumeToNotify.find( CanonicalVolume );
        if ( m_CanonicalVolumeToNotify.end() == iter )
            {
            LogInfo( "Canonical volume %ls has not been registered, register now\n", CanonicalVolume );

            //
            // Register for device-lock notification.  If it fails, it is of small consequence:
            // if CHKDSK and BITS try to access a file simultanteously, the job would go into
            // ERROR state instead of TRANSIENT_ERROR state.
            //
            Hr = RegisterNotification( CanonicalVolume );
            if (FAILED(Hr))
                {
                LogWarning("unable to register: 0x%x", Hr);
                }

            Hr = S_OK;
            }
        else
            {
            CDriveNotify *pNotify = iter->second;

            if ((pNotify->m_LockCount > 0) || (pNotify->m_RemoveCount > 0))
                throw ComError( BG_E_DESTINATION_LOCKED );
            }
    }
    catch(ComError Error)
    {
        Hr = Error.Error();
    }
    return Hr;
}

HRESULT
CDeviceNotificationController::RegisterNotification(
    const WCHAR *CanonicalVolume
    )
{
    HRESULT Hr = S_OK;
    HANDLE hDriveHandle = INVALID_HANDLE_VALUE;
    HDEVNOTIFY hNotify = NULL;
    CDriveNotify *pNotify = NULL;

    StringHandle wCanonicalVolume;

    try
    {
        wCanonicalVolume = CanonicalVolume;

        CCanonicalVolumeToNotify::iterator iter = m_CanonicalVolumeToNotify.find( wCanonicalVolume );
        if ( m_CanonicalVolumeToNotify.end() != iter )
            {
            LogInfo( "Canonical volume %ls has already been registered, nothing to do.", CanonicalVolume );
            return S_OK;
            }

        // Need to remove the trailing / from the volume name.
        ASSERTMSG( "Canonical name has an unexpected size", wCanonicalVolume.Size() );

        CAutoString TempVolumePath = CAutoString( CopyString( wCanonicalVolume ));

        ASSERT( wCanonicalVolume.Size() > 0 );
        TempVolumePath.get()[ wCanonicalVolume.Size() - 1 ] = L'\0';

        hDriveHandle =
            CreateFile( TempVolumePath.get(),
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
        if ( INVALID_HANDLE_VALUE == hDriveHandle )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        DEV_BROADCAST_HANDLE DbtHandle;
        memset( &DbtHandle, 0, sizeof(DbtHandle) );

        DbtHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        DbtHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
        DbtHandle.dbch_handle = hDriveHandle;

        hNotify =
            RegisterDeviceNotification( (HANDLE) ghServiceHandle,
                                         &DbtHandle,
                                         DEVICE_NOTIFY_SERVICE_HANDLE );

        if ( !hNotify )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
        CloseHandle( hDriveHandle );
        hDriveHandle = NULL;

        pNotify = new CDriveNotify( hNotify, CanonicalVolume );
        if ( !pNotify )
            throw ComError( E_OUTOFMEMORY );

        RTL_VERIFY( m_CanonicalVolumeToNotify.insert( CCanonicalVolumeToNotify::value_type( wCanonicalVolume, pNotify ) ).second );
        RTL_VERIFY( m_HandleToNotify.insert( CHandleToNotify::value_type( hNotify, pNotify ) ).second );


    }
    catch(ComError Error)
    {
        Hr = Error.Error();
    }
    if ( FAILED(Hr) )
        {

        if ( hNotify )
            UnregisterDeviceNotification( hNotify );
        if ( hDriveHandle != INVALID_HANDLE_VALUE )
            CloseHandle( hDriveHandle );

        if ( pNotify )
            {
            m_CanonicalVolumeToNotify.erase( wCanonicalVolume );
            m_HandleToNotify.erase( hNotify );
            delete pNotify;
            }

        }

    return Hr;

}

HRESULT
SessionLogonCallback(
    DWORD SessionId
    )
{
    if (!PostThreadMessage(g_dwBackgroundThreadId, WM_SESSION_CHANGE, true, SessionId))
        {
        return E_FAIL;
        }

    return S_OK;
}

HRESULT
SessionLogoffCallback(
    DWORD SessionId
    )
{
    if (!PostThreadMessage(g_dwBackgroundThreadId, WM_SESSION_CHANGE, false, SessionId))
        {
        return E_FAIL;
        }

    return S_OK;
}

DWORD
DeviceEventCallback(
    DWORD dwEventType,
    LPVOID lpEventData
    )
{
    return g_Manager->OnDeviceEvent( dwEventType, lpEventData );
}

bool
CJobManager::OnIdentify(
    IN IVssCreateWriterMetadata *pMetadata
    )
/*
    This is called by CBitsVssWriter::OnIdentify, used by backup programs.
    Our implementation simply excludes the metadata and job temporary files
    from the backup set.
*/
{
    // Exclude the BITS metadata files.
    //
    THROW_HRESULT( pMetadata->AddExcludeFiles( g_GlobalInfo->m_QmgrDirectory, L"*", FALSE ));

    // Enumerate and exclude every temp file created by BITS.
    //
    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        THROW_HRESULT( iter->ExcludeFilesFromBackup( pMetadata ));
        }

    for (CJobList::iterator iter = m_OfflineJobs.begin(); iter != m_OfflineJobs.end(); ++iter)
        {
        THROW_HRESULT( iter->ExcludeFilesFromBackup( pMetadata ));
        }

    return TRUE;
}

bool STDMETHODCALLTYPE
CBitsVssWriter::OnIdentify(
    IN IVssCreateWriterMetadata *pMetadata
    )
{
    LogInfo("called");

    ASSERT( g_Manager );

    try
        {
        // This increments the global call count, preventing the service from exiting
        // until the call completes.
        //
        DispatchedCall c;

        HoldReaderLock lock ( g_Manager->m_TaskScheduler );

        if (g_ServiceState != MANAGER_ACTIVE)
            {
            // Since we are shutting down or starting up, a second attempt will probably succeed.
            //
            SetWriterFailure( VSS_E_WRITERERROR_RETRYABLE );
            return false;
            }

        return g_Manager->OnIdentify( pMetadata );
        }
    catch ( ComError err )
        {
        LogError("exception 0x%x raised at line %d", err.m_error, err.m_line);
        SetWriterFailure( VSS_E_WRITERERROR_OUTOFRESOURCES );
        return false;
        }
}

void
AddExcludeFile(
    IN IVssCreateWriterMetadata *pMetadata,
    LPCWSTR FileName
    )
/*
    Adds a file to the backup exclusion list.  <FileName> must be a complete path.
*/
{
    //
    // Convert the filename into its long-name equivalent.
    //
    #define LONG_NAME_BUFFER_CHARS (1+MAX_PATH)

    CAutoStringW LongName(new WCHAR[LONG_NAME_BUFFER_CHARS]);

    DWORD s;
    s = GetLongPathName( FileName, LongName.get(), LONG_NAME_BUFFER_CHARS );
    if (s == 0)
        {
        ThrowLastError();
        }
    if (s > LONG_NAME_BUFFER_CHARS)
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ));
        }

    // Break the file into path and file components, as required by the snapshot API.
    //
    StringHandle PathSpec;
    StringHandle FileSpec;

    PathSpec = BITSCrackFileName( LongName.get(), FileSpec );

    // Actually exclude the file.
    //
    HRESULT hr;
    if (FAILED(hr=pMetadata->AddExcludeFiles( PathSpec,
                                              FileSpec,
                                              FALSE
                                              )))
        {
        LogError("unable to exclude file '%S', hr=%x", FileName, hr);
        THROW_HRESULT( hr );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cmarshal.h ===
//-------------------------------------------------------------

inline void *
AdvanceBuffer(
    void * Buffer,
    size_t Bytes
    )
/*
    Adds a given number of bytes to a pointer, returning the result.
    The original pointer is not changed.
*/
{
    char * buf = reinterpret_cast<char *>( Buffer );

    return (buf + Bytes);
}

inline void
ScrubBuffer(
    void * Buffer,
    size_t Length
    )
{
    SecureZeroMemory( Buffer, Length );
}

inline void
ScrubStringW(
    LPWSTR String
    )
{
    if (String == 0)
        {
        return;
        }

    //
    // The volatile attribute ensures that the loop cannot be optimized away.
    //
    volatile wchar_t * p = String;

    while (*p != 0)
        {
        *p = 0;
        ++p;
        }
}

inline void
ScrubBasicCredentials(
    BG_BASIC_CREDENTIALS & cred
    )
{
    ScrubStringW( cred.UserName );
    ScrubStringW( cred.Password );
}

inline void
ScrubCredentials(
    BG_AUTH_CREDENTIALS & val
    )
{
    switch (val.Scheme)
        {
        case BG_AUTH_SCHEME_BASIC:
        case BG_AUTH_SCHEME_DIGEST:
        case BG_AUTH_SCHEME_NTLM:
        case BG_AUTH_SCHEME_NEGOTIATE:
        case BG_AUTH_SCHEME_PASSPORT:

             ScrubBasicCredentials( val.Credentials.Basic );
             break;

        default:

            ASSERT( 0 && "unknown auth scheme" );
            THROW_HRESULT( E_FAIL );
        }
}

class CMarshalCursor
{
public:

    CMarshalCursor( void * Buffer, size_t Length )
    {
        m_BufferStart = Buffer;
        m_BufferCurrent = Buffer;
        m_Length = Length;
    }

    void * GetBufferStart()
    {
        return m_BufferStart;
    }

    void * GetBufferCurrent()
    {
        return m_BufferCurrent;
    }

    void * Advance( size_t Length )
    {
        if (GetLengthRemaining() < Length)
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        m_BufferCurrent = AdvanceBuffer( m_BufferCurrent, Length );
    }

    size_t GetLengthUsed()
    {
        char * b1 = reinterpret_cast<char *>( m_BufferStart );
        char * b2 = reinterpret_cast<char *>( m_BufferCurrent );

        return (b2-b1);
    }

    size_t GetLengthRemaining()
    {
        return m_Length - GetLengthUsed();
    }

    CMarshalCursor GetSubCursor()
    {
        CMarshalCursor SubCursor( m_BufferCurrent, GetLengthRemaining() );

        return SubCursor;
    }

    void CommitSubCursor( CMarshalCursor & SubCursor )
    {
        if (SubCursor.m_BufferStart   < m_BufferStart ||
            SubCursor.m_BufferCurrent > AdvanceBuffer( m_BufferStart, m_Length ))
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        m_BufferCurrent = SubCursor.m_BufferCurrent;
    }

    void Rewind()
    {
        m_BufferCurrent = m_BufferStart;
    }

    void Scrub()
    {
        ScrubBuffer( m_BufferStart, GetLengthUsed() );
    }

    void ScrubUnusedSpace()
    {
        ScrubBuffer( m_BufferCurrent, GetLengthRemaining() );
    }

    inline void Read( void * Buffer, size_t Length );
    inline void Write( const void * Buffer, size_t Length );

private:

    void * m_BufferStart;
    void * m_BufferCurrent;

    size_t  m_Length;
};

void CMarshalCursor::Write( const void * Buffer, size_t Length )
{
    if (GetLengthRemaining() < Length)
        {
        THROW_HRESULT( E_INVALIDARG );
        }

    memcpy( m_BufferCurrent, Buffer, Length );

    m_BufferCurrent = AdvanceBuffer( m_BufferCurrent, Length );
}

void CMarshalCursor::Read( void * Buffer, size_t Length )
{
    if (GetLengthRemaining() < Length)
        {
        THROW_HRESULT( E_INVALIDARG );
        }

    memcpy( Buffer, m_BufferCurrent, Length );

    m_BufferCurrent = AdvanceBuffer( m_BufferCurrent, Length );
}

class CBufferMarshaller
{
public:

    CBufferMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBufferMarshaller( CMarshalCursor & Cursor, const void * Buffer, size_t Length ) : m_Cursor( Cursor )
    {
        Marshal( Buffer, Length );
    }

    void Marshal( const void * Buffer, size_t Length )
    {
        m_Cursor.Write( Buffer, Length );
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CBufferUnmarshaller
{
public:

    CBufferUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBufferUnmarshaller( CMarshalCursor & Cursor, void * Buffer, size_t Length ) : m_Cursor( Cursor )
    {
        Unmarshal( Buffer, Length );
    }

    void Unmarshal( void * Buffer, size_t Length )
    {
        m_Cursor.Read( Buffer, Length );
    }

protected:

    CMarshalCursor & m_Cursor;
};

template<class T> class CBasicMarshaller
{
public:

    CBasicMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicMarshaller( CMarshalCursor & Cursor, const T & val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const T & val )
    {
        return sizeof(T);
    }

    virtual void Marshal( const T & val )
    {
        m_Cursor.Write( &val, sizeof(T));
    }

protected:

    CMarshalCursor & m_Cursor;
};

template<class T> class CBasicUnmarshaller
{
public:

    CBasicUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicUnmarshaller( CMarshalCursor & Cursor, T & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( T & val )
    {
        m_Cursor.Read( &val, sizeof(T));
    }

protected:

    CMarshalCursor & m_Cursor;
};


typedef CBasicMarshaller<DWORD> CDwordMarshaller;
typedef CBasicMarshaller<BG_AUTH_SCHEME> CSchemeMarshaller;
typedef CBasicMarshaller<BG_AUTH_TARGET> CTargetMarshaller;

typedef CBasicUnmarshaller<DWORD> CDwordUnmarshaller;
typedef CBasicUnmarshaller<BG_AUTH_SCHEME> CSchemeUnmarshaller;
typedef CBasicUnmarshaller<BG_AUTH_TARGET> CTargetUnmarshaller;

class CUnicodeStringMarshaller
{
public:

    CUnicodeStringMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CUnicodeStringMarshaller( CMarshalCursor & Cursor, const LPWSTR & val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const LPWSTR & val )
    {
        DWORD StringBytes;

        if (val)
            {
            StringBytes = sizeof(wchar_t) * (1+wcslen(val));
            }
        else
            {
            StringBytes = 0;
            }

        return CDwordMarshaller::Size( StringBytes ) + StringBytes;
    }

    void Marshal( const LPWSTR & val )
    {
        CMarshalCursor Cursor =  m_Cursor.GetSubCursor();

        try
            {
            DWORD StringBytes;

            if (val)
                {
                StringBytes = sizeof(wchar_t) * (1+wcslen(val));

                CDwordMarshaller m1( Cursor, StringBytes );
                CBufferMarshaller m2( Cursor, val, StringBytes );
                }
            else
                {
                StringBytes = 0;
                CDwordMarshaller m1( Cursor, StringBytes );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            m_Cursor.Scrub();
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CUnicodeStringUnmarshaller
{
public:

    CUnicodeStringUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CUnicodeStringUnmarshaller( CMarshalCursor & Cursor, LPWSTR & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( LPWSTR & val )
    {
        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            DWORD StringBytes;
            val = 0;

            CDwordUnmarshaller m1( Cursor, StringBytes );

            if (StringBytes)
                {
                val = reinterpret_cast<LPWSTR>( new char[ StringBytes ] );
                CBufferUnmarshaller m2( Cursor, val, StringBytes );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            delete val;
            val = 0;
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CBasicCredentialsMarshaller
{
public:

    CBasicCredentialsMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicCredentialsMarshaller( CMarshalCursor & Cursor, const BG_BASIC_CREDENTIALS & val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const BG_BASIC_CREDENTIALS & val )
    {
        return    CUnicodeStringMarshaller::Size( val.UserName )
                + CUnicodeStringMarshaller::Size( val.Password );
    }

    void Marshal( const BG_BASIC_CREDENTIALS & val )
    {
        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            CUnicodeStringMarshaller m1( Cursor, val.UserName );
            CUnicodeStringMarshaller m2( Cursor, val.Password );

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            Cursor.Scrub();
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CBasicCredentialsUnmarshaller
{
public:

    CBasicCredentialsUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicCredentialsUnmarshaller( CMarshalCursor & Cursor, BG_BASIC_CREDENTIALS & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( BG_BASIC_CREDENTIALS & val )
    {
        val.UserName = 0;
        val.Password = 0;

        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            CUnicodeStringUnmarshaller m1( Cursor, val.UserName );
            CUnicodeStringUnmarshaller m2( Cursor, val.Password );

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            ScrubStringW( val.UserName );
            delete val.UserName;

            ScrubStringW( val.Password );
            delete val.Password;
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CAuthCredentialsMarshaller
{
public:

    CAuthCredentialsMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CAuthCredentialsMarshaller( CMarshalCursor & Cursor, const BG_AUTH_CREDENTIALS * val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const BG_AUTH_CREDENTIALS * val )
    {
        switch (val->Scheme)
            {
            case BG_AUTH_SCHEME_BASIC:
            case BG_AUTH_SCHEME_DIGEST:
            case BG_AUTH_SCHEME_NTLM:
            case BG_AUTH_SCHEME_NEGOTIATE:
            case BG_AUTH_SCHEME_PASSPORT:
                {
                return    CDwordMarshaller::Size( val->Scheme )
                        + CDwordMarshaller::Size( val->Target )
                        + CBasicCredentialsMarshaller::Size( val->Credentials.Basic );
                }

            default:

                ASSERT( 0 && "size: unknown auth scheme" );
                throw ComError( E_FAIL );
            }
    }

    void Marshal( const BG_AUTH_CREDENTIALS * val )
    {
        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            CSchemeMarshaller m1( Cursor, val->Scheme );
            CTargetMarshaller m2( Cursor, val->Target );

            switch (val->Scheme)
                {
                case BG_AUTH_SCHEME_BASIC:
                case BG_AUTH_SCHEME_DIGEST:
                case BG_AUTH_SCHEME_NTLM:
                case BG_AUTH_SCHEME_NEGOTIATE:
                case BG_AUTH_SCHEME_PASSPORT:
                    {
                    CBasicCredentialsMarshaller m3( Cursor, val->Credentials.Basic );
                    break;
                    }

                default:

                    ASSERT( 0 && "marshal: unknown auth scheme" );
                    throw ComError( E_FAIL );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            Cursor.Scrub();
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};


class CAuthCredentialsUnmarshaller
{
public:

    CAuthCredentialsUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CAuthCredentialsUnmarshaller( CMarshalCursor & Cursor, BG_AUTH_CREDENTIALS & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    CAuthCredentialsUnmarshaller( CMarshalCursor & Cursor, BG_AUTH_CREDENTIALS ** val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( BG_AUTH_CREDENTIALS & val )
    {
        CMarshalCursor Cursor =  m_Cursor.GetSubCursor();

        try
            {
            CSchemeUnmarshaller m1( Cursor, val.Scheme );
            CTargetUnmarshaller m2( Cursor, val.Target );

            switch (val.Scheme)
                {
                case BG_AUTH_SCHEME_BASIC:
                case BG_AUTH_SCHEME_DIGEST:
                case BG_AUTH_SCHEME_NTLM:
                case BG_AUTH_SCHEME_NEGOTIATE:
                case BG_AUTH_SCHEME_PASSPORT:
                    {
                    CBasicCredentialsUnmarshaller m3( Cursor, val.Credentials.Basic );
                    break;
                    }

                default:

                    ASSERT( 0 && "unmarshal: unknown auth scheme" );
                    THROW_HRESULT( E_FAIL );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            throw;
            }
    }

    void Unmarshal( BG_AUTH_CREDENTIALS ** ppval )
    {
        BG_AUTH_CREDENTIALS * pval = 0;

        try
            {
            pval = new BG_AUTH_CREDENTIALS;

            Unmarshal( *pval );

            *ppval = pval;
            }
        catch ( ComError err )
            {
            delete pval;
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cmanager.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cmanager.h

Abstract :

    Header file for the CJobManager interface.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include "qmgrlib.h"
#include <list>
#include "clist.h"
#include "logontable.h"
#include "drizcpat.h"
#include "bitstest.h"
#include <map>

using namespace std;

class CJob;
class CJobManagerFactory;
class CJobManager;
class CJobManagerExternal;

class CJobList : public IntrusiveList<CJob>
{
public:

    BOOL
    Add(
        CJob * job
        );

    CJob *
    Find(
        REFGUID id
        );

    BOOL
    Remove(
        CJob * job
        );

    ~CJobList();

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );
    void Clear();

    typedef IntrusiveList<CJob>::iterator iterator;

};

class CJobManagerExternal  : public IBackgroundCopyManager,
                             public IClassFactory,
                             public IBitsTest1
{
public:

    friend CJobManager;

    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID iid, void** ppvObject);
    ULONG __stdcall AddRef(void);
    ULONG __stdcall Release(void);

    // IBackgroundCopyManager methods

    HRESULT STDMETHODCALLTYPE CreateJobInternal(
        /* [in] */ LPCWSTR DisplayName,
        /* [in] */ BG_JOB_TYPE Type,
        /* [out] */ GUID *pJobId,
        /* [out] */ IBackgroundCopyJob **ppJob);

    HRESULT STDMETHODCALLTYPE CreateJob(
        /* [in] */ LPCWSTR DisplayName,
        /* [in] */ BG_JOB_TYPE Type,
        /* [out] */ GUID *pJobId,
        /* [out] */ IBackgroundCopyJob **ppJob)
    {
        EXTERNAL_FUNC_WRAP( CreateJobInternal( DisplayName, Type, pJobId, ppJob ) )
    }

    HRESULT STDMETHODCALLTYPE GetJobInternal(
        /* [in] */ REFGUID jobID,
        /* [out] */ IBackgroundCopyJob **ppJob);

    HRESULT STDMETHODCALLTYPE GetJob(
        /* [in] */ REFGUID jobID,
        /* [out] */ IBackgroundCopyJob **ppJob)
    {
        EXTERNAL_FUNC_WRAP( GetJobInternal( jobID, ppJob ) )
    }


    HRESULT STDMETHODCALLTYPE EnumJobsInternal(
        /* [in] */ DWORD dwFlags,
        /* [out] */ IEnumBackgroundCopyJobs **ppEnum);

    HRESULT STDMETHODCALLTYPE EnumJobs(
        /* [in] */ DWORD dwFlags,
        /* [out] */ IEnumBackgroundCopyJobs **ppEnum)
    {
        EXTERNAL_FUNC_WRAP( EnumJobsInternal( dwFlags, ppEnum ) )
    }

    HRESULT STDMETHODCALLTYPE GetErrorDescriptionInternal(
        /* [in] */ HRESULT hResult,
        /* [in] */ DWORD LanguageId,
        /* [out] */ LPWSTR *pErrorDescription );

    HRESULT STDMETHODCALLTYPE GetErrorDescription(
        /* [in] */ HRESULT hResult,
        /* [in] */ DWORD LanguageId,
        /* [out] */ LPWSTR *pErrorDescription )
    {
        EXTERNAL_FUNC_WRAP( GetErrorDescriptionInternal( hResult, LanguageId, pErrorDescription ) )
    }

    // IClassFactory methods

    HRESULT __stdcall CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject);
    HRESULT __stdcall LockServer(BOOL fLock);

    // IBitsTest1 methods

    virtual HRESULT STDMETHODCALLTYPE GetBitsDllPath(
        /* [out] */ LPWSTR *pVal);

protected:

    long m_ServiceInstance;

    CJobManager *m_pJobManager;
    long m_refs;

    CJobManagerExternal();

    void SetInterfaceClass(
        CJobManager *pVal
        )
    {
        m_pJobManager = pVal;
    }

    void NotifyInternalDelete()
    {
        // Release the internal refcount
        Release();
    }
};

class CDeviceNotificationController
{
public:
    virtual ~CDeviceNotificationController();

    // General message cracker
    DWORD OnDeviceEvent( DWORD dwEventType, LPVOID lpEventData );

    // Event methods
    virtual void OnDeviceLock( const WCHAR *CanonicalVolume ) = 0;
    virtual void OnDeviceUnlock( const WCHAR *CanonicalVolume ) = 0;
    virtual void OnDismount( const WCHAR *CanonicalVolume ) = 0;

    HRESULT RegisterNotification( const WCHAR *CanonicalVolume );
    HRESULT IsVolumeLocked( const WCHAR *CanonicalVolume );

private:

    class CDriveNotify
        {
    public:
        HDEVNOTIFY m_hDeviceNotify;
        StringHandle m_CanonicalName;
        LONG m_LockCount;
        LONG m_RemoveCount;
        CDriveNotify( HDEVNOTIFY hDeviceNotify,
                      StringHandle CanonicalName ) :
            m_hDeviceNotify( hDeviceNotify ),
            m_CanonicalName( CanonicalName ),
            m_RemoveCount( 0 ),
            m_LockCount( 0 )
            {
            }
        };
    typedef map<HDEVNOTIFY, CDriveNotify*> CHandleToNotify;
    typedef map<StringHandle, CDriveNotify*> CCanonicalVolumeToNotify;

    CHandleToNotify m_HandleToNotify;
    CCanonicalVolumeToNotify m_CanonicalVolumeToNotify;
    void DeleteNotify( CDriveNotify *pNotify );
};

class CBitsVssWriter : public CVssWriter
/*
    CVssWriter is a backup-related class implemented by the system.  In October 2002
    it was available only on Windows XP and higher.  The default implementation does
    nothing; BITS ovverrides OnIdentify() to exclude its job temporary and metadata files
    from the list to be backed up.
*/
{
public:
    virtual bool STDMETHODCALLTYPE OnIdentify(IVssCreateWriterMetadata *pMetadata);

    //
    // Additional vitrual functions required by CVssWriter but not used by our implementation.
    //

    // callback if current sequence is aborted
    virtual bool STDMETHODCALLTYPE OnAbort()
    {
        return true;
    }
    // callback for prepare snapsot event
    virtual bool STDMETHODCALLTYPE OnPrepareSnapshot()
    {
        return true;
    }
    // callback for freeze event
    virtual bool STDMETHODCALLTYPE OnFreeze()
    {
        return true;
    }
    // callback for thaw event
    virtual bool STDMETHODCALLTYPE OnThaw()
    {
        return true;
    }
};

class CJobManager : public TaskSchedulerWorkItem,
                    private CDeviceNotificationController,
                    public CQmgrStateFiles
{
public:

    friend CJobManagerExternal;
    friend COldQmgrInterface;

    HRESULT
    CreateJob(
        LPCWSTR     DisplayName,
        BG_JOB_TYPE Type,
        GUID        Id,
        SidHandle   sid,
        CJob  **    ppJob,
        bool        OldStyleJob = false
        );

    // Returns NULL if job not found
    HRESULT GetJob(
        REFGUID jobID,
        CJob ** ppJob
        );

    //
    // TaskSchedulerWorkItem methods
    //
    void OnDispatch() { TransferCurrentJob(); }

    SidHandle GetSid()
    {
        return g_GlobalInfo->m_LocalSystemSid;
    }

    // CDeviceNotificationController methods

    DWORD OnDeviceEvent( DWORD dwEventType, LPVOID lpEventData )
    {
         LockWriter();
         DWORD dwResult = CDeviceNotificationController::OnDeviceEvent( dwEventType, lpEventData );
         UnlockWriter();
         return dwResult;
    }

    //
    // additional functions
    //

    CJobManager();
    virtual ~CJobManager();

    //
    // Notification that a user has logged on.
    //
    void SYNCHRONIZED_WRITE
    UserLoggedOn(
        SidHandle sid
        );

    //
    // Notification that a user has logged off.
    //
    void SYNCHRONIZED_WRITE
    UserLoggedOff(
        SidHandle sid
        );

    //
    // Notification that there was a change in the number of active network adapters.
    //
    void OnNetworkChange();

    //
    // Called by m_BackupWriter->OnIdentify.
    //
    bool
    OnIdentify(
        IN IVssCreateWriterMetadata *pMetadata
        );

    //
    // Adjust the job's online/offline state after its owner changes.
    //
    void
    ResetOnlineStatus(
        CJob *pJob,
        SidHandle sid
        );

    void ScheduleDelayedTask(
        TaskSchedulerWorkItem * task,
        ULONG SecondsOfDelay
        )
    {
        FILETIME TimeToRun = GetTimeAfterDelta( (UINT64) NanoSec100PerSec * SecondsOfDelay );

        m_TaskScheduler.InsertWorkItem( task, &TimeToRun );
    }

    void TaskThread();

    HRESULT SuspendJob ( CJob * job );
    HRESULT ResumeJob  ( CJob * job );
    HRESULT CancelJob  ( CJob * job );
    HRESULT CompleteJob( CJob * job );

    HRESULT Serialize();
    HRESULT Unserialize();

    bool LockReader()
    {
        return m_TaskScheduler.LockReader();
    }
    void UnlockReader()
    {
        m_TaskScheduler.UnlockReader();
    }

    bool LockWriter()
    {
        return m_TaskScheduler.LockWriter();
    }

    void UnlockWriter()
    {
        m_TaskScheduler.UnlockWriter();
    }

    //
    // recalculates which job should be downloading and kicks the download thread if necessary.
    //
    void ScheduleAnotherGroup( bool fInsertNetworkDelay = false );

    void MoveJobOffline(
        CJob * job
        );

    void AppendOnline(
        CJob * job
        );

    void Shutdown();

    HRESULT
    CloneUserToken(
        SidHandle psid,
        DWORD     session,
        HANDLE *  pToken
        );

    bool IsUserLoggedOn( SidHandle psid );

    HRESULT RegisterClassObjects();

    void RevokeClassObjects();

    HRESULT CreateBackupWriter();

    void DeleteBackupWriter();

    //--------------------------------------------------------------------

    CJobManagerExternal* GetExternalInterface()
    {
        return m_ExternalInterface;
    }

    COldQmgrInterface* GetOldExternalInterface()
    {
        return m_OldQmgrInterface;
    }

    void NotifyInternalDelete()
    {
        GetExternalInterface()->NotifyInternalDelete();
    }

    HRESULT
    GetErrorDescription(
        HRESULT hResult,
        DWORD LanguageId,
        LPWSTR *pErrorDescription );

    Downloader *        m_pPD;
    TaskScheduler       m_TaskScheduler;

    void OnDiskChange(  const WCHAR *CanonicalVolume, DWORD VolumeSerialNumber );

    HRESULT IsVolumeLocked( const WCHAR *CanonicalPath )
    {
        return CDeviceNotificationController::IsVolumeLocked( CanonicalPath );
    }

    void RetaskJob( CJob *pJob );

    void InterruptDownload();

    void MoveJobToInactiveState( CJob * job );

    bool RemoveJob( CJob * job )
    {
        if (m_OnlineJobs.Remove( job ))
            {
            return true;
            }

        if (m_OfflineJobs.Remove( job ))
            {
            return true;
            }

        return false;
    }

    HRESULT CheckClientAccess();

private:

    CJob *              m_CurrentJob;

    HMODULE             m_hWininet;
    HANDLE              m_hQuantumTimer;

    // cookies from CoRegisterClassObject.
    // used later to unregister.
    //
    DWORD               m_ComId_1_5;
    DWORD               m_ComId_1_0;
    DWORD               m_ComId_0_5;

    CJobList            m_OnlineJobs;
    CJobList            m_OfflineJobs;

    CJobManagerExternal * m_ExternalInterface;
    COldQmgrInterface   * m_OldQmgrInterface;

public:
    CLoggedOnUsers      m_Users;

    CIpAddressMonitor   m_NetworkMonitor;

private:

    CBitsVssWriter *    m_BackupWriter;
    HMODULE             m_hVssapi_dll;

    //--------------------------------------------------------------------

    HRESULT
    GetCurrentGroupAndToken(
        HANDLE * pToken
        );

    void TransferCurrentJob();

    void ChooseCurrentJob();

    void Cleanup();

    // Returns the runing or queued jobs that have
    // a priority >= current priority.
    size_t MoveActiveJobToListEnd( CJob *pJob );

    void SetQuantumTimeout();

public:
    bool CheckForQuantumTimeout();

    void UpdateRemoteSizes(
        CUnknownFileSizeList *pUnknownFileSizeList,
        HANDLE hToken,
        QMErrInfo *pErrorInfo,
        const PROXY_SETTINGS * ProxySettings,
        const CCredentialsContainer * Credentials
        );

private:

    // Event methods
    void OnDeviceLock( const WCHAR *CanonicalVolume );
    void OnDeviceUnlock( const WCHAR *CanonicalVolume );
    void OnDismount( const WCHAR *CanonicalVolume );

    // methods for dealing with network topology changes
    //
    static void CALLBACK
    NetworkChangeCallback(
        PVOID arg
        );

    void MarkJobsWithNetDisconnected();
    void ReactivateTransientErrorJobs();

};

class CLockedJobManagerReadPointer
    {
    CJobManager * const m_Pointer;
public:
    CLockedJobManagerReadPointer( CJobManager * Pointer) :
       m_Pointer(Pointer)
    { m_Pointer->LockReader(); }
    ~CLockedJobManagerReadPointer()
    { m_Pointer->UnlockReader(); }
    CJobManager * operator->() const { return m_Pointer; }
    HRESULT ValidateAccess() { return m_Pointer->CheckClientAccess(); }
    };

class CLockedJobManagerWritePointer
    {
    CJobManager * const m_Pointer;
public:
    CLockedJobManagerWritePointer( CJobManager * Pointer) :
        m_Pointer(Pointer)
    { m_Pointer->LockWriter(); }
    ~CLockedJobManagerWritePointer()
    { m_Pointer->UnlockWriter(); }
    CJobManager * operator->() const { return m_Pointer; }
    HRESULT ValidateAccess() { return m_Pointer->CheckClientAccess(); }
    };

extern CJobManagerFactory * g_ManagerFactory;
extern CJobManager * g_Manager;

// SENS logon notification

void ActivateSensLogonNotification();
void DeactiveateSensLogonNotification();

extern MANAGER_STATE g_ServiceState;
extern long          g_ServiceInstance;

/**
 * Checks to see if a given job is being downloaded.
 * If so, the constructor interrupts the download, and
 * the destructor calls CJobManager::ScheduleAnotherJob().
 * 
 * This is useful for methods that change job properties,
 * when those changes affect the download itself.
 */
class CRescheduleDownload
{
    bool bRunning;

public:

    CRescheduleDownload( CJob * job )
    {
        bRunning = job->IsRunning();

        if (bRunning)
            {
            g_Manager->InterruptDownload();
            }
    }

    ~CRescheduleDownload()
    {
        if (bRunning)
            {
            g_Manager->ScheduleAnotherGroup();
            }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\csd.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    csd.cpp

Abstract :

    Main code file for SID and SECURITY_DESCRIPTOR abstraction.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include <accctrl.h>
#include <malloc.h>
#include <aclapi.h>

#if !defined(BITS_V12_ON_NT4)
#include "csd.tmh"
#endif

//------------------------------------------------------------------------

CNestedImpersonation::CNestedImpersonation(
    SidHandle sid
    )
    : m_Sid( sid ),
      m_ImpersonationToken( NULL ),
      m_fImpersonated( false ),
      m_fDeleteToken( true )
{
    try
        {
        THROW_HRESULT( g_Manager->CloneUserToken( m_Sid, ANY_SESSION, &m_ImpersonationToken ));

        Impersonate();
        }
    catch( ComError Error )
        {
        Revert();

        if (m_ImpersonationToken && m_fDeleteToken)
            {
            CloseHandle( m_ImpersonationToken );
            }

        throw;
        }
}

CNestedImpersonation::CNestedImpersonation(
    HANDLE token
    )
    : m_ImpersonationToken( token ),
      m_fImpersonated( false ),
      m_fDeleteToken( false )
{
    Impersonate();
}

CNestedImpersonation::CNestedImpersonation()
    : m_ImpersonationToken( NULL ),
      m_fImpersonated( false ),
      m_fDeleteToken( true )
{
    //
    // Failure will cause the base object's destructor to restore the old thread token.
    //

    try
        {
        HRESULT hr = CoImpersonateClient();

        switch (hr)
            {
            case S_OK:
                {
                m_fImpersonated = true;
                m_ImpersonationToken = CopyThreadToken();

#if defined(BITS_V12_ON_NT4)
                RTL_VERIFY( SUCCEEDED( CoRevertToSelf() ) );
                m_fImpersonated = false;
                RTL_VERIFY( SetThreadToken( NULL, m_ImpersonationToken ) );
                m_fImpersonated = true;
#endif
                break;
                }

            case RPC_E_CALL_COMPLETE:
                {
                m_ImpersonationToken = CopyThreadToken();
                if (m_ImpersonationToken)
                    {
                    //
                    // thread was already impersonating someone when it called the BITS routine.
                    //
                    m_fImpersonated = true;
                    }
                else
                    {
                    //
                    // Thread is not impersonating.  Impersonate the process owner.
                    //
                    if (!ImpersonateSelf( SecurityImpersonation ))
                        {
                        throw ComError( HRESULT_FROM_WIN32( GetLastError() ));
                        }

                    m_fImpersonated = true;
                    m_ImpersonationToken = CopyThreadToken();
                    }
                break;
                }

            default:
                throw ComError( hr );
            }
        }
    catch( ComError err )
        {
        if (m_ImpersonationToken)
            {
            CloseHandle( m_ImpersonationToken );
            m_ImpersonationToken = NULL;
            }

        throw;
        }
}

void
CNestedImpersonation::SwitchToLogonToken()
{
    HANDLE token = m_ImpersonationToken;

    SidHandle sid = CopyTokenSid( m_ImpersonationToken );

    THROW_HRESULT( g_Manager->CloneUserToken( sid,
                                              GetSession(),
                                              &m_ImpersonationToken ));

    m_fImpersonated = false;

    if (m_fDeleteToken)
        {
        CloseHandle( token );
        }

    m_fDeleteToken = true;

    Impersonate();
}

DWORD
CNestedImpersonation::GetSession()
{

#if defined(BITS_V12_ON_NT4)
    return 0;
#else
    DWORD session;
    DWORD used;

    if (!GetTokenInformation( m_ImpersonationToken,
                              TokenSessionId,
                              &session,
                              sizeof(DWORD),
                              &used))
        {
        ThrowLastError();
        }

    return session;
#endif
}

//------------------------------------------------------------------------

GENERIC_MAPPING CJobSecurityDescriptor::s_AccessMapping =
{
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_ALL
};

CJobSecurityDescriptor::CJobSecurityDescriptor(
    SidHandle OwnerSid
    )
{
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = 0;

    try
        {
        EXPLICIT_ACCESS ea[2];
        size_t  SizeNeeded;

        pSD = (PSECURITY_DESCRIPTOR) new char[SECURITY_DESCRIPTOR_MIN_LENGTH];

        if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "InitializeSecurityDescriptor Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        if (!SetSecurityDescriptorOwner( pSD, OwnerSid.get(), TRUE))
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorOwner Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        if (!SetSecurityDescriptorGroup( pSD, OwnerSid.get(), TRUE))
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorGroup Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE will allow the Administrators group full access to the key.
        memset(ea, 0, sizeof(ea));

        ea[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance= NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[0].Trustee.ptstrName  = (LPTSTR) OwnerSid.get();

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE will allow the Administrators group full access to the key.

        ea[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance= NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[1].Trustee.ptstrName  = (LPTSTR) g_GlobalInfo->m_AdministratorsSid.get();

        // Create a new ACL that contains the new ACEs.

        DWORD s = SetEntriesInAcl(2, ea, NULL, &pACL);
        if (s != ERROR_SUCCESS)
            {
            HRESULT HrError = HRESULT_FROM_WIN32( s );
            LogError( "create SD : SetEntriesInAcl failed %!winerr!", HrError );
            throw ComError( HrError );
            }

        // Add the ACL to the security descriptor.

        if (!SetSecurityDescriptorDacl( pSD,
                                        TRUE,     // fDaclPresent flag
                                        pACL,
                                        TRUE))   // a default DACL
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorDacl Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        //
        // Add the pointers our object.
        //
        m_sd         = pSD;
        m_sdOwnerSid = OwnerSid;
        m_sdGroupSid = OwnerSid;
        m_Dacl       = pACL;
        }
    catch( ComError exception )
        {
        if (pACL)
            LocalFree(pACL);

        if (pSD)
            delete[] ((char*)pSD);

        throw;
        }
}

CJobSecurityDescriptor::CJobSecurityDescriptor(
    PSECURITY_DESCRIPTOR sd,
    SidHandle   sdOwnerSid,
    SidHandle   sdGroupSid,
    PACL        sdDacl
    )
{
    m_sd         = sd;
    m_sdOwnerSid = sdOwnerSid;
    m_sdGroupSid = sdGroupSid;
    m_Dacl       = sdDacl;
}


CJobSecurityDescriptor::~CJobSecurityDescriptor()
{
    if (m_Dacl)
        LocalFree(m_Dacl);

    delete m_sd;
}


HRESULT
CJobSecurityDescriptor::_ModifyAcl(
    PSID sid,
    BOOL fGroupSid,
    DWORD access,
    BOOL  fAdd
    )
{
    HRESULT hr;
    DWORD dwRes;
    PACL pNewAcl = NULL;
    EXPLICIT_ACCESS ea;

    // Initialize an EXPLICIT_ACCESS structure for the new ACE.

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = access;
    ea.grfAccessMode        = (fAdd) ? SET_ACCESS : REVOKE_ACCESS;
    ea.grfInheritance       = NO_INHERITANCE;
    ea.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType  = (fGroupSid) ? TRUSTEE_IS_GROUP : TRUSTEE_IS_USER;
    ea.Trustee.ptstrName    = LPTSTR(sid);

    // Create a new ACL that merges the new ACE
    // into the existing DACL.

    dwRes = SetEntriesInAcl( 1, &ea, m_Dacl, &pNewAcl );
    if (ERROR_SUCCESS != dwRes)
        {
        hr = HRESULT_FROM_WIN32( dwRes );
        goto Cleanup;
        }

    // Attach the new ACL as the object's DACL.

    if (!SetSecurityDescriptorDacl( m_sd,
                                    TRUE,     // fDaclPresent flag
                                    pNewAcl,
                                    FALSE ))   // a default DACL
        {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "SetSecurityDescriptorDacl Error %!winerr!", hr );
        goto Cleanup;
        }

    LocalFree( m_Dacl );

    m_Dacl = pNewAcl;

    pNewAcl = NULL;

    hr = S_OK;

Cleanup:

    if(pNewAcl)
        LocalFree((HLOCAL) pNewAcl);

    return hr;
}

HRESULT
CJobSecurityDescriptor::CheckTokenAccess(
    HANDLE hToken,
    DWORD RequestedAccess,
    DWORD * pAllowedAccess,
    BOOL * pSuccess
    )
{

    PRIVILEGE_SET * PrivilegeSet = 0;
    DWORD PrivilegeSetSize;
    //
    // Get space for the privilege set.  I don't expect to use any...
    //
    PrivilegeSetSize = sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES);
    auto_ptr<char> Buffer;

    try
        {
        Buffer = auto_ptr<char>( new char[ PrivilegeSetSize ] );
        }
    catch( ComError Error )
        {
        return Error.Error();
        }

    PrivilegeSet = (PRIVILEGE_SET *) Buffer.get();

    //
    // See whether the security descriptor allows access.
    //
    if (!AccessCheck( m_sd,
                      hToken,
                      RequestedAccess,
                      &s_AccessMapping,
                      PrivilegeSet,
                      &PrivilegeSetSize,
                      pAllowedAccess,
                      pSuccess
                      ))
    {
        HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "AccessCheck failed, error %!winerr!", HrError );
        return HrError;
    }

    return S_OK;

}

HRESULT
CJobSecurityDescriptor::Serialize(
    HANDLE hFile
    )
{
    try
        {
        ULONG   SdSize;
        auto_ptr<char> pSD;    // auto_ptr<void> apparently doesn't work

        //
        // Convert the security descriptor into self-relative format for storage.
        //
        SdSize = 0;
        MakeSelfRelativeSD( m_sd, NULL, &SdSize );
        if (SdSize == 0)
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()) );
            }

        pSD = auto_ptr<char>( new char[ SdSize ] );

        if (!MakeSelfRelativeSD( m_sd, pSD.get(), &SdSize ))
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()) );
            }

        SafeWriteFile( hFile, SdSize );
        SafeWriteFile( hFile, pSD.get(), SdSize );
        }
    catch( ComError err )
        {
        LogError("SD serialize failed with %!winerr!", err.Error() );

        throw;
        }

    return S_OK;
}


CJobSecurityDescriptor *
CJobSecurityDescriptor::Unserialize(
    HANDLE hFile
    )
{
    //
    // Allocations here must match the deletes in the destructor.
    //
    char * SdBuf = 0;
    char * DaclBuf = 0;
    CJobSecurityDescriptor * pObject = NULL;

    try
        {
        DWORD SdSize = 0;
        DWORD DaclSize = 0;
        DWORD SaclSize = 0;
        DWORD OwnerSize = 0;
        DWORD GroupSize = 0;

        PSECURITY_DESCRIPTOR sd;
        auto_ptr<char> pSD;    // auto_ptr<void> apparently doesn't work

        PACL    sdDacl;
        PACL    sdSacl;


        SafeReadFile( hFile, &SdSize );

        pSD = auto_ptr<char>( new char[ SdSize ] );

        SafeReadFile( hFile, pSD.get(), SdSize );

        MakeAbsoluteSD( pSD.get(),
                        NULL, &SdSize,
                        NULL, &DaclSize,
                        NULL, &SaclSize,
                        NULL, &OwnerSize,
                        NULL, &GroupSize
                        );

        if (!SdSize || !DaclSize || !OwnerSize || !GroupSize)
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
            }

        SdBuf      = new char[ SdSize + SaclSize ];
        SidHandle OwnerSid = new char[ OwnerSize ];
        SidHandle GroupSid = new char[ GroupSize ];

        DaclBuf = (char *) LocalAlloc( LMEM_FIXED, DaclSize );

        sdDacl     = (PACL) DaclBuf;
        sd         = (PSECURITY_DESCRIPTOR) SdBuf;
        sdSacl     = (PACL) (SdBuf+SdSize);

        if (!MakeAbsoluteSD( pSD.get(),
                             sd, &SdSize,
                             sdDacl, &DaclSize,
                             sdSacl, &SaclSize,
                             OwnerSid.get(), &OwnerSize,
                             GroupSid.get(), &GroupSize
                             ))
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
            }

        pObject = new CJobSecurityDescriptor( sd,
                                              OwnerSid,
                                              GroupSid,
                                              sdDacl
                                              );
        }
    catch (ComError exception)
        {
        delete[] SdBuf;

        LocalFree( DaclBuf );
        delete pObject;

        throw;
        }

    return pObject;
}

//------------------------------------------------------------------------

PSID
CopyTokenSid(
    HANDLE Token
    )
{
    TOKEN_USER * TokenData;
    DWORD SizeNeeded;

    // Get the size first.
    if (!GetTokenInformation(
             Token,
             TokenUser,
             0,
             0,
             &SizeNeeded
             ))
        {
        DWORD dwLastError = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
            {
            THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError()));
            }
        }

    auto_ptr<char> Buffer( new char[ SizeNeeded ] );
    TokenData = (TOKEN_USER *) Buffer.get();

    if (!GetTokenInformation(
             Token,
             TokenUser,
             TokenData,
             SizeNeeded,
             &SizeNeeded
             ))
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError()));
        }

    PSID sid = DuplicateSid( TokenData->User.Sid );
    if (sid == NULL)
        {
        THROW_HRESULT( E_OUTOFMEMORY);
        }

    return sid;
}


HANDLE
CopyThreadToken()
/*

    Makes a copy of the current thread's impersonation token.
    Returns NULL if not impersonating.
    Throws an exception if an error occurs.

*/
{
    HANDLE token = NULL;

    if (OpenThreadToken( GetCurrentThread(),
                     MAXIMUM_ALLOWED,
                     TRUE,
                     &token))
        {
        return token;
        }
    else if (GetLastError() == ERROR_NO_TOKEN)
        {
        return NULL;
        }
    else
        {
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ));
        }
}

SidHandle
GetThreadClientSid()
/*

    Returns the SID of the current thread's COM client.
    Throws an exception if an error occurs.

*/
{
    CNestedImpersonation imp;

    return imp.CopySid();
}



HRESULT
IsRemoteUser()
{
    return CheckClientGroupMembership( g_GlobalInfo->m_NetworkUsersSid );
}


HRESULT
CheckClientGroupMembership(
    SidHandle group
    )
{
    try
        {
        BOOL fIsMember;

        CNestedImpersonation imp;

        if (!CheckTokenMembership( imp.QueryToken(),
                                   group.get(),
                                   &fIsMember))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        if (fIsMember)
            {
            return S_OK;
            }

        return S_FALSE;
        }
    catch( ComError Error )
        {
        return Error.Error();
        }
}

HRESULT
DenyRemoteAccess()
{
    HRESULT hr = CheckClientGroupMembership( g_GlobalInfo->m_NetworkUsersSid );

    if (FAILED(hr))
        {
        return hr;
        }

    if (hr == S_OK)
        {
        return BG_E_REMOTE_NOT_SUPPORTED;
        }

    return S_OK;
}

HRESULT
DenyNonAdminAccess()
{
    HRESULT hr = CheckClientGroupMembership( g_GlobalInfo->m_AdministratorsSid );

    if (FAILED(hr))
        {
        return hr;
        }

    if (hr == S_FALSE)
        {
        return E_ACCESSDENIED;
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\csens.h ===
class CLogonNotification : public CSimpleExternalIUnknown<ISensLogon>
{

public:
    CLogonNotification();
    ~CLogonNotification() { Cleanup(); }

private:

    IEventSubscription * m_EventSubscriptions[2];
    IEventSystem *m_EventSystem;
    ITypeLib *m_TypeLib;
    ITypeInfo *m_TypeInfo;

    void Cleanup();

public:

    HRESULT SetEnableState( bool fEnable );

    void DeRegisterNotification();

    HRESULT STDMETHODCALLTYPE GetIDsOfNames(
        REFIID riid,
        OLECHAR FAR* FAR* rgszNames,
        unsigned int cNames,
        LCID lcid,
        DISPID FAR*
        rgDispId );

    HRESULT STDMETHODCALLTYPE GetTypeInfo(
        unsigned int iTInfo,
        LCID lcid,
        ITypeInfo FAR* FAR* ppTInfo );

    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(
        unsigned int FAR* pctinfo );

    HRESULT STDMETHODCALLTYPE Invoke(
        DISPID dispIdMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS FAR* pDispParams,
        VARIANT FAR* pVarResult,
        EXCEPINFO FAR* pExcepInfo,
        unsigned int FAR* puArgErr );

    HRESULT STDMETHODCALLTYPE DisplayLock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE DisplayUnlock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StopScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logon( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logoff( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartShell( BSTR UserName );
};

class CTerminalServerLogonNotification : public CLogonNotification
{
public:
    CTerminalServerLogonNotification();
    ~CTerminalServerLogonNotification();

protected:

    void ConsoleUserCheck();

    HRESULT QueueConsoleUserCheck();

    static DWORD WINAPI
    UserCheckThreadProc(
        LPVOID arg
        );

    // true if we believe that a user is logged in at the console.
    //
    bool m_fConsoleUser;

    // number of queued calls to ConsoleUserCheck()
    //
    LONG m_PendingUserChecks;

public:

    HRESULT STDMETHODCALLTYPE Logon( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logoff( BSTR UserName );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\csd.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    csd.h

Abstract :

    Header file for SID and SECURITY_DESCRIPTOR abstraction.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include "qmgrlib.h"

HRESULT
IsGroupSid(
    PSID sid,
    BOOL * pGroup
    );

PSID
CopyTokenSid(
    HANDLE Token
    );

HANDLE CopyThreadToken() throw( ComError );

//------------------------------------------------------------------------

class CSaveThreadToken
/*

    A simple class to save and restore the active thread token.
    This allows code to impersonate other users without having to save
    and restore the old token.

    The constructor throws a ComError if it cannot copy the previous thread token.

*/
{
public:

    CSaveThreadToken() throw( ComError )
    {
        m_SavedToken = CopyThreadToken();
    }

    ~CSaveThreadToken()
    {
        RTL_VERIFY( SetThreadToken( NULL, m_SavedToken ));
        if (m_SavedToken)
            {
            RTL_VERIFY(CloseHandle( m_SavedToken ));
            }
    }

protected:

    HANDLE  m_SavedToken;
};


//------------------------------------------------------------------------

class CNestedImpersonation : protected CSaveThreadToken
/*

    A class to impersonate a user.  It saves the old impersonation token, if any,
    during the constructor and restores it in the destructor.

    Revert() restores the old thread token, unlike RevertToSelf() which
    stops impersonating entirely.

    Most member functions throw a ComError exception if an error occurs.

*/
{
public:

    //
    // Impersonate the COM client, using CoImpersonateClient.
    //
    CNestedImpersonation() throw( ComError );

    //
    // Impersonate a particular token.  The token must remain valid for the object's lifetime.
    //
    CNestedImpersonation( HANDLE token ) throw( ComError );

    //
    // Impersonate a logged-on user by SID.  g_Manager must be initialized for this to work.
    //
    CNestedImpersonation( SidHandle sid ) throw( ComError );

    //
    // This is for use with the COM-client constructor.  COM defaults to IDENTIFY-level
    // impersonation, but some of our code requires IMPERSONATE level.  This function
    // gets the COM client's SID and finds a matching token in our logged-on-users list.
    // This becomes the new impersonation token.
    //
    void SwitchToLogonToken() throw( ComError );

    //
    // the destructor restores the previous impersonation context.
    //
    ~CNestedImpersonation()
    {
        Revert();

        if (m_ImpersonationToken && m_fDeleteToken)
            {
            CloseHandle( m_ImpersonationToken );
            }
    }

    //
    // Impersonates the new token.
    //
    void Impersonate() throw( ComError )
    {
        if (!m_fImpersonated)
            {
            if (!ImpersonateLoggedOnUser( m_ImpersonationToken ))
                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            m_fImpersonated = true;
            }
    }

    //
    // Restores the old impersonation context.
    //
    void Revert()
    {
        if (m_fImpersonated)
            {
            RTL_VERIFY( SetThreadToken( NULL, m_SavedToken ));
            m_fImpersonated = false;
            }
    }

    //
    // Returns a copy of the SID associated with the impersonation token.
    //
    SidHandle CopySid() throw( ComError )
    {
        if (m_Sid.get() == NULL)
            {
            m_Sid = CopyTokenSid( m_ImpersonationToken );
            }

        return m_Sid;
    }

    //
    // Returns the original impersonation token.  Not a copy !
    //
    HANDLE QueryToken()
    {
        return m_ImpersonationToken;
    }

    //
    // Gets the Terminal Services session ID.
    //
    DWORD GetSession() throw( ComError );


protected:

    bool        m_fDeleteToken;
    bool        m_fImpersonated;

    HANDLE      m_ImpersonationToken;

    SidHandle   m_Sid;
};

//------------------------------------------------------------------------

class CJobSecurityDescriptor
{
public:

    CJobSecurityDescriptor( SidHandle sid );

    ~CJobSecurityDescriptor();

    HRESULT Clone( CJobSecurityDescriptor ** );

    inline HRESULT
    AddAce(
        PSID sid,
        BOOL fGroupSid,
        DWORD access
        );

    inline HRESULT
    RemoveAce(
        PSID sid,
        BOOL fGroupSid
        );

    HRESULT
    CheckTokenAccess(
        HANDLE hToken,
        DWORD RequestedAccess,
        DWORD * pAllowedAccess,
        BOOL * pSuccess
        );

    inline SidHandle GetOwnerSid()
    {
        return m_sdOwnerSid;
    }

    HRESULT Serialize( HANDLE hFile );
    static  CJobSecurityDescriptor * Unserialize( HANDLE hFile );

private:

    HRESULT
    CJobSecurityDescriptor::_ModifyAcl(
        PSID sid,
        BOOL fGroupSid,
        DWORD access,
        BOOL  fAdd
        );

    CJobSecurityDescriptor( PSECURITY_DESCRIPTOR pSD,
                            SidHandle owner,
                            SidHandle group,
                            PACL pAcl
                            );

    PSECURITY_DESCRIPTOR m_sd;

    SidHandle   m_sdOwnerSid;
    SidHandle   m_sdGroupSid;
    PACL        m_Dacl;

    static GENERIC_MAPPING s_AccessMapping;
};

HRESULT
CJobSecurityDescriptor::AddAce(
    PSID sid,
    BOOL fGroupSid,
    DWORD access
    )
{
    return _ModifyAcl( sid, fGroupSid, access, TRUE );
}


HRESULT
CJobSecurityDescriptor::RemoveAce(
    PSID sid,
    BOOL fGroupSid
    )
{
    return _ModifyAcl( sid, fGroupSid, 0, FALSE );
}

HRESULT
CheckClientGroupMembership(
    SidHandle group
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cunknown.cpp ===
#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "cunknown.tmh"
#endif

template<class T>
CSimpleExternalIUnknown<T>::CSimpleExternalIUnknown() :
    m_ServiceInstance( g_ServiceInstance ),
    m_refs(1) // always start with one ref count!
{
    GlobalLockServer( TRUE );
}

template<class T>
CSimpleExternalIUnknown<T>::~CSimpleExternalIUnknown()
{
    GlobalLockServer( FALSE );
}

template<class T>
STDMETHODIMP
CSimpleExternalIUnknown<T>::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{

    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == _uuidof(T)))
        {
        *ppvObject = static_cast<T *> (this);
        (static_cast<IUnknown *>(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "IUnknown %p QueryInterface: iid %!guid!, Hr %x", this, &iid, Hr );

    return Hr;

    END_EXTERNAL_FUNC
}

template<class T>
ULONG
CSimpleExternalIUnknown<T>::AddRef()
{
    BEGIN_EXTERNAL_FUNC

    ASSERT( m_refs != 0 );

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "IUnknown %p addref: new refs = %d", this, newrefs );

    return newrefs;

    END_EXTERNAL_FUNC
}

template<class T>
ULONG
CSimpleExternalIUnknown<T>::Release()
{

    BEGIN_EXTERNAL_FUNC;

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "IUnknown %p release: new refs = %d", this, newrefs );

    if (newrefs == 0)
        {
        LogInfo( "Deleting object due to ref count hitting 0" );

        delete this;
        return 0;
        }

    return m_refs;

    END_EXTERNAL_FUNC
}


// Work around problem in logging where functions in headers can't have logging

template CSimpleExternalIUnknown<IBackgroundCopyError>;

template CSimpleExternalIUnknown<IEnumBackgroundCopyFiles>;
template CSimpleExternalIUnknown<IEnumBackgroundCopyGroups>;
template CSimpleExternalIUnknown<IEnumBackgroundCopyJobs>;
template CSimpleExternalIUnknown<IEnumBackgroundCopyJobs1>;
template CSimpleExternalIUnknown<ISensLogon>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\cunknown.h ===
template<SIZE_T Offset>
class TrackedClassObject
{
   static LONG* GetCounter()
   {
      return reinterpret_cast<LONG*>( reinterpret_cast<char*>( g_GlobalInfo->m_StatSection ) + Offset );
   }
protected:
   TrackedClassObject()
   {
      InterlockedIncrement( GetCounter() );
   }
   ~TrackedClassObject()
   {
       if (g_ServiceState == MANAGER_INACTIVE)
           {
           return;
           }
       InterlockedDecrement( GetCounter() );
   }
};

//------------------------------------------------------------------------

template<class T>
class CSimpleExternalIUnknown : public T
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

protected:
    CSimpleExternalIUnknown();
    virtual ~CSimpleExternalIUnknown();

    long m_ServiceInstance;
    LONG m_refs;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\csens.cpp ===
/************************************************************************

Copyright (c) 2001 - Microsoft Corporation

Module Name :

    csens.cpp

Abstract :

    Code for recieving logon notifications from SENS.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include <wtsapi32.h>

#if !defined(BITS_V12_ON_NT4)
#include "csens.tmh"
#endif

HRESULT GetConsoleUserPresent( bool * pfPresent );

HRESULT GetConsoleUsername( LPWSTR * User );

//------------------------------------------------------------------------

CLogonNotification::CLogonNotification() :
m_EventSystem( NULL ),
m_TypeLib( NULL ),
m_TypeInfo( NULL )
{
   try
   {
       m_EventSubscriptions[0] = NULL;
       m_EventSubscriptions[1] = NULL;

#if defined( BITS_V12_ON_NT4 )

        {

        // try to load the SENS typelibrary
        // {D597DEED-5B9F-11D1-8DD2-00AA004ABD5E}

        HRESULT Hr;
        static const GUID SensTypeLibGUID =
            { 0xD597DEED, 0x5B9F, 0x11D1, { 0x8D, 0xD2, 0x00, 0xAA, 0x00, 0x4A, 0xBD, 0x5E } };


        Hr = LoadRegTypeLib( SensTypeLibGUID, 2, 0, GetSystemDefaultLCID(), &m_TypeLib);

        if ( TYPE_E_CANTLOADLIBRARY == Hr || TYPE_E_LIBNOTREGISTERED == Hr )
            {

            Hr = LoadRegTypeLib( SensTypeLibGUID, 1, 0, GetSystemDefaultLCID(), &m_TypeLib );

            if ( TYPE_E_CANTLOADLIBRARY == Hr || TYPE_E_LIBNOTREGISTERED == Hr )
                Hr = LoadTypeLibEx( L"SENS.DLL", REGKIND_NONE, &m_TypeLib );

            }

        THROW_HRESULT( Hr );

        }

#else

        THROW_HRESULT( LoadTypeLibEx( L"SENS.DLL", REGKIND_NONE, &m_TypeLib ) );

#endif

        THROW_HRESULT( m_TypeLib->GetTypeInfoOfGuid( __uuidof( ISensLogon ), &m_TypeInfo ) );

        THROW_HRESULT( CoCreateInstance( CLSID_CEventSystem,
                                         NULL,
                                         CLSCTX_SERVER,
                                         IID_IEventSystem,
                                         (void**)&m_EventSystem
                                         ) );


        // Register for the individual methods
        const WCHAR *MethodNames[] =
            {
            L"Logon",
            L"Logoff"
            };

        const WCHAR *UniqueIdentifies[] =
            {
            L"{c69c8f03-b25c-45d1-96fa-6dfb1f292b26}",
            L"{5f4f5e8d-4599-4ba0-b53d-1de5440b8770}"
            };

        for( SIZE_T i = 0; i < ( sizeof(MethodNames) / sizeof(*MethodNames) ); i++ )
            {

            WCHAR EventGuidString[ 50 ];

            THROW_HRESULT( CoCreateInstance( CLSID_CEventSubscription,
                                             NULL,
                                             CLSCTX_SERVER,
                                             IID_IEventSubscription,
                                             (LPVOID *) &m_EventSubscriptions[i]
                                             ) );


            StringFromGUID2( SENSGUID_EVENTCLASS_LOGON, EventGuidString, 50 );

            THROW_HRESULT( m_EventSubscriptions[i]->put_EventClassID( EventGuidString ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_SubscriberInterface( this ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_SubscriptionName( (BSTR) L"Microsoft-BITS" ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_Description( (BSTR) L"BITS Notification" ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_Enabled( FALSE ) );

            THROW_HRESULT( m_EventSubscriptions[i]->put_MethodName( (BSTR)MethodNames[i] ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_SubscriptionID( (BSTR)UniqueIdentifies[i] ) );

            THROW_HRESULT( m_EventSystem->Store(PROGID_EventSubscription, m_EventSubscriptions[i] ) );
            }
   }
   catch( ComError Error )
   {
       Cleanup();

       throw;
   }
}

void
CLogonNotification::DeRegisterNotification()
{
    SafeRelease( m_EventSubscriptions[0] );
    SafeRelease( m_EventSubscriptions[1] );

    if ( m_EventSystem )
        {
        int ErrorIndex;

        m_EventSystem->Remove( PROGID_EventSubscription,
                               L"EventClassID == {D5978630-5B9F-11D1-8DD2-00AA004ABD5E} AND SubscriptionName == Microsoft-BITS",
                               &ErrorIndex );

        SafeRelease( m_EventSystem );
        }
}

void
CLogonNotification::Cleanup()
{
    DeRegisterNotification();

    SafeRelease( m_TypeInfo );
    SafeRelease( m_TypeLib );

    LogInfo("cleanup complete");
}

HRESULT CLogonNotification::SetEnableState( bool fEnable )
{
    try
        {
        for (int i=0; i <= 1; ++i)
            {
            THROW_HRESULT( m_EventSubscriptions[i]->put_Enabled( fEnable ) );
            }

        for (int i=0; i <= 1; ++i)
            {
            THROW_HRESULT( m_EventSystem->Store(PROGID_EventSubscription, m_EventSubscriptions[i] ) );
            }

        LogInfo("SENS enable state is %d", fEnable);
        return S_OK;
        }
    catch ( ComError err )
        {
        LogInfo("SENS set enable state (%d) returned %x", fEnable, err.Error());
        return err.Error();
        }
}

STDMETHODIMP
CLogonNotification::GetIDsOfNames(
    REFIID,
    OLECHAR FAR* FAR* rgszNames,
    unsigned int cNames,
    LCID,
    DISPID FAR* rgDispId )
{

    return m_TypeInfo->GetIDsOfNames(
        rgszNames,
        cNames,
        rgDispId );

}


STDMETHODIMP
CLogonNotification::GetTypeInfo(
    unsigned int iTInfo,
    LCID,
    ITypeInfo FAR* FAR* ppTInfo )
{

    if ( iTInfo != 0 )
        return DISP_E_BADINDEX;

    *ppTInfo = m_TypeInfo;
    m_TypeInfo->AddRef();

    return S_OK;
}

STDMETHODIMP
CLogonNotification::GetTypeInfoCount(
    unsigned int FAR* pctinfo )
{
    *pctinfo = 1;
    return S_OK;

}

STDMETHODIMP
CLogonNotification::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID,
    WORD wFlags,
    DISPPARAMS FAR* pDispParams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pExcepInfo,
    unsigned int FAR* puArgErr )
{

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    return m_TypeInfo->Invoke(
        (IDispatch*) this,
        dispID,
        wFlags,
        pDispParams,
        pvarResult,
        pExcepInfo,
        puArgErr
        );

}


STDMETHODIMP
CLogonNotification::DisplayLock(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::DisplayUnlock(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::StartScreenSaver(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::StopScreenSaver(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::Logon(
    BSTR UserName )
{
    LogInfo( "SENS logon notification for %S", (WCHAR*)UserName );

    HRESULT Hr = SessionLogonCallback( 0 );

    LogInfo( "SENS logon notification for %S processed, %!winerr!", (WCHAR*)UserName, Hr );

    return Hr;
}

STDMETHODIMP
CLogonNotification::Logoff(
    BSTR UserName )
{
    LogInfo( "SENS logoff notification for %S", (WCHAR*)UserName );

    HRESULT Hr = SessionLogoffCallback( 0 );

    LogInfo( "SENS logoff notification for %S processed, %!winerr!", (WCHAR*)UserName, Hr );

    return Hr;
}

STDMETHODIMP
CLogonNotification::StartShell(
    BSTR UserName )
{
    return S_OK;
}

//------------------------------------------------------------------------

CTerminalServerLogonNotification::CTerminalServerLogonNotification()
    : m_PendingUserChecks( 0 ),
    m_fConsoleUser( false )
{
}

CTerminalServerLogonNotification::~CTerminalServerLogonNotification()
{
    while (m_PendingUserChecks)
        {
        LogInfo("m_PendingUserChecks is %d", m_PendingUserChecks);
        Sleep(50);
        }
}

STDMETHODIMP
CTerminalServerLogonNotification::Logon(
    BSTR UserName )
{
    HRESULT Hr = S_OK;

    LogInfo( "TS SENS logon notification for %S", (WCHAR*)UserName );

    if (!m_fConsoleUser)
        {
        // Wait a few seconds in case TS hasn't seen the notification yet, then
        // check whetherthe notification was for the console.
        // if it fails, not much recourse.
        //
        Hr = QueueConsoleUserCheck();
        }

    LogInfo( "hr = %!winerr!", Hr );

    return Hr;
}

STDMETHODIMP
CTerminalServerLogonNotification::Logoff(
    BSTR UserName )
{
    HRESULT Hr = S_OK;

    LogInfo( "TS SENS logoff notification for %S", (WCHAR*)UserName );

    if (m_fConsoleUser)
        {
        bool fSame;
        LPWSTR ConsoleUserName = NULL;

        Hr = GetConsoleUsername( &ConsoleUserName );

        if (FAILED( Hr ))
            {
            //
            // unable to check.  Security dictates that we be conservative and remove the user.
            //
            LogError("unable to fetch console username %x, thus logoff callback", Hr);

            Hr = SessionLogoffCallback( 0 );
            m_fConsoleUser = false;
            }
        else if (ConsoleUserName == NULL)
            {
            //
            // no user logged in at the console
            //
            LogInfo("no one logged in at the console, thus logoff callback");

            Hr = SessionLogoffCallback( 0 );
            m_fConsoleUser = false;
            }
        else if (0 != _wcsicmp( UserName, ConsoleUserName))
            {
            LogInfo("console user is %S; doesn't match", ConsoleUserName);

            delete [] ConsoleUserName;
            Hr = S_OK;
            }
        else
            {
            // correct user, but (s)he might have logged off from a TS session.
            // We should wait a few seconds before checking the console state because the
            // TS code may not have seen the logoff notification yet.  Because Logoff is a synchronous
            // notification, we cannot just Sleep before checking..
            //
            delete [] ConsoleUserName;

            if (FAILED(QueueConsoleUserCheck()))
                {
                //
                // unable to check.  Security dictates that we be conservative and remove the user.
                //
                LogError("unable to queue check, thus logoff callback");
                Hr = SessionLogoffCallback( 0 );
                m_fConsoleUser = false;
                }
            }
        }
    else
        {
        LogInfo("ignoring, no console user");
        }

    LogInfo( "hr = %!winerr!", Hr );

    return Hr;
}

HRESULT
CTerminalServerLogonNotification::QueueConsoleUserCheck()
{
    if (QueueUserWorkItem( UserCheckThreadProc, this, WT_EXECUTELONGFUNCTION ))
        {
        InterlockedIncrement( &m_PendingUserChecks );
        LogInfo("queued user check: about %d pending", m_PendingUserChecks );
        return S_OK;
        }
    else
        {
        DWORD s = GetLastError();
        LogError("unable to queue user check %!winerr!", s);
        return HRESULT_FROM_WIN32( s );
        }
}

DWORD WINAPI
CTerminalServerLogonNotification::UserCheckThreadProc(
    LPVOID arg
    )
{
    CTerminalServerLogonNotification * _this = reinterpret_cast<CTerminalServerLogonNotification *>(arg);

    LogInfo("sleeping before user check");
    Sleep( 5 * 1000 );

    _this->ConsoleUserCheck();

    return 0;
}

void CTerminalServerLogonNotification::ConsoleUserCheck()
{
    HRESULT Hr;

    LogInfo("SENS console user check");

    if (IsServiceShuttingDown())
        {
        LogWarning("service is shutting down.");
        InterlockedDecrement( &m_PendingUserChecks );
        return;
        }

    bool bConsoleUser;

    Hr = GetConsoleUserPresent( &bConsoleUser );

    //
    // Security requires us to be conservative: if we can't tell whether the user
    // is logged in, we must release his token.
    //
    if (FAILED(Hr))
        {
        LogError("GetConsoleUserPresent returned %x", Hr );
        }

    if (FAILED(Hr) || !bConsoleUser)
        {
        LogInfo("logoff callback");
        if (FAILED(SessionLogoffCallback( 0 )))
            {
            // unusual: the only obvious generator is
            // - no known user at console
            // - TS logon or failing console logon
            // - memory allocation failure referring to m_ActiveSessions[ session ]
            // either way, we don't think a user is at the console, so m_fConsoleUser should be false.
            }
        m_fConsoleUser = false;
        }
    else
        {
        LogInfo("logon callback");
        m_fConsoleUser = true;
        if (FAILED(SessionLogonCallback( 0 )))
            {
            // no user token available, but we still know that there is a console user.
            }
        }

    InterlockedDecrement( &m_PendingUserChecks );
}

HRESULT
GetConsoleUserPresent( bool * pfPresent )
{
    /*
    If logon fails, we still know that there is a user at the console.  
    Setting the flag will prevent queued checks for further logons, and 
    logoff handles the no-user case.

    For Logoff, regardless of exit path there is no user recorded for that session.  
    Setting the flag prevents queued checks for future logoffs.
    */

    INT * pConnectState = 0;
    DWORD size;
    if (WTSQuerySessionInformation( WTS_CURRENT_SERVER,
                                    0,
                                    WTSConnectState,
                                    reinterpret_cast<LPTSTR *>(&pConnectState),
                                    &size))
        {
        LogInfo("console session state is %d", *pConnectState);
        if (*pConnectState == WTSActive ||
            *pConnectState == WTSDisconnected)
            {
            LogInfo("console user present");
            *pfPresent = true;
            }
        else
            {
            LogInfo("no console user");
            *pfPresent = false;
            }

        WTSFreeMemory( pConnectState );
        return S_OK;
        }
    else
        {
        DWORD s = GetLastError();
        LogInfo("WTSQuerySessionInformation returned %!winerr!", s);
        return HRESULT_FROM_WIN32( s );
        }
}

HRESULT GetConsoleUsername( LPWSTR * pFinalName )
{
    HRESULT hr;

    LPWSTR UserName = NULL;
    LPWSTR DomainName = NULL;

    *pFinalName = NULL;

   try
       {
       DWORD UserSize;
       DWORD DomainSize;

       if (!WTSQuerySessionInformationW( WTS_CURRENT_SERVER,
                                       0,
                                       WTSUserName,
                                       &UserName,
                                       &UserSize))
           {
           ThrowLastError();
           }

       if (!WTSQuerySessionInformationW( WTS_CURRENT_SERVER,
                                       0,
                                       WTSDomainName,
                                       &DomainName,
                                       &DomainSize))
           {
           ThrowLastError();
           }

       *pFinalName = new WCHAR[ DomainSize + 1 + UserSize + 1 ];

       hr = StringCchPrintf( *pFinalName,
                             UserSize + 1 + DomainSize + 1,
                             L"%s\\%s", DomainName, UserName
                             );
       }
   catch ( ComError err )
       {
       delete [] *pFinalName;
       *pFinalName = NULL;

       hr = err.Error();
       }

   if (DomainName)
       {
       WTSFreeMemory( DomainName );
       }

   if (UserName)
       {
       WTSFreeMemory( UserName );
       }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\drizcpat.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    drizcpat.cpp

Abstract :

    Compatibility wrapper against the old AU bits.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "drizcpat.tmh"
#endif

DWORD NewJobSizeToOldSize( UINT64 NewSize )
{
    if ( NewSize == UINT64(-1))
        return 0;

    return (DWORD)NewSize;
}

DWORD MapOldNotifyToNewNotify( DWORD dwOldNotify )
{
     // The mars interface has error on by default.
     DWORD dwReturnVal = BG_NOTIFY_JOB_ERROR;

     if ( dwOldNotify &
          ~(  QM_NOTIFY_GROUP_DONE | QM_NOTIFY_DISABLE_NOTIFY ) )
         throw ComError( E_NOTIMPL );

     if ( dwOldNotify & QM_NOTIFY_GROUP_DONE )
         dwReturnVal |= BG_NOTIFY_JOB_TRANSFERRED;

     if ( dwOldNotify & QM_NOTIFY_DISABLE_NOTIFY )
         dwReturnVal |= BG_NOTIFY_DISABLE;

     return dwReturnVal;
}

DWORD MapNewNotifyToOldNotify( DWORD dwNewNotify )
{
     DWORD dwReturnVal = 0;

     if ( dwNewNotify & BG_NOTIFY_JOB_TRANSFERRED )
         dwReturnVal |= QM_NOTIFY_GROUP_DONE;

     if ( dwNewNotify & BG_NOTIFY_DISABLE )
         dwReturnVal |= QM_NOTIFY_DISABLE_NOTIFY;

     return dwReturnVal;
}

COldGroupInterface::COldGroupInterface(
    CJob *pJob ) :
    m_refs(1),
    m_ServiceInstance( g_ServiceInstance ),
    m_NotifyPointer( NULL ),
    m_NotifyClsid( GUID_NULL ),
    m_pJob(pJob),
    m_pJobExternal( pJob->GetExternalInterface() )
{
    m_pJobExternal->AddRef();
}

COldGroupInterface::~COldGroupInterface()
{
    m_pJobExternal->Release();
}


STDMETHODIMP
COldGroupInterface::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    LogPublicApiBegin( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == _uuidof(IUnknown)) || (iid == __uuidof(IBackgroundCopyGroup)) )
        {
        *ppvObject = (IBackgroundCopyGroup *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogPublicApiEnd( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldGroupInterface::AddRef(void)
{
   BEGIN_EXTERNAL_FUNC

   ULONG newrefs = InterlockedIncrement(&m_refs);

   LogRef( "job %p, refs = %d", m_pJob, newrefs );

   return newrefs;

   END_EXTERNAL_FUNC
}

ULONG _stdcall
COldGroupInterface::Release(void)
{
   BEGIN_EXTERNAL_FUNC

   ULONG newrefs = InterlockedDecrement(&m_refs);

   LogRef( "job %p, refs = %d", m_pJob, newrefs );

   if (newrefs == 0)
       {
       delete this;
       }

   return newrefs;

   END_EXTERNAL_FUNC
}


STDMETHODIMP
COldGroupInterface::GetPropInternal(
    GROUPPROP property,
    VARIANT * pVal
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "property %u, pVal %p", property, pVal );

    WCHAR * pString = NULL;

    try
    {
       ASSERT( pVal );

       VariantClear( pVal );

       THROW_HRESULT( LockedJob.ValidateAccess() );

       switch (property)
           {
           case GROUPPROP_PRIORITY:
               pVal->vt = VT_INT;
               pVal->intVal = 1;
               break;

           case GROUPPROP_PROTOCOLFLAGS:
               pVal->vt = VT_INT;
               pVal->intVal = QM_PROTOCOL_HTTP;
               break;

           case GROUPPROP_NOTIFYFLAGS:
               pVal->vt = VT_INT;
               pVal->intVal = MapNewNotifyToOldNotify( LockedJob->GetNotifyFlags() );
               break;

           case GROUPPROP_NOTIFYCLSID:
               {
               THROW_HRESULT( StringFromIID( m_NotifyClsid, &pString ));

               pVal->vt = VT_BSTR;
               pVal->bstrVal = SysAllocString( pString );

               if ( !pVal->bstrVal )
                   throw ComError( E_OUTOFMEMORY );

               break;
               }

           case GROUPPROP_DISPLAYNAME:
               {

               THROW_HRESULT( LockedJob->GetDisplayName( &pString ) );

               pVal->vt = VT_BSTR;
               pVal->bstrVal = SysAllocString( pString );

               if ( !pVal->bstrVal )
                   throw ComError( E_OUTOFMEMORY );

               break;
               }

           case GROUPPROP_DESCRIPTION:
               {

               THROW_HRESULT( LockedJob->GetDescription( &pString ) );

               pVal->vt = VT_BSTR;
               pVal->bstrVal = SysAllocString( pString );

               if ( !pVal->bstrVal )
                   throw ComError( E_OUTOFMEMORY );

               break;
               }

           default:
               return E_NOTIMPL;
           }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        VariantClear( pVal );
    }

    CoTaskMemFree( pString );

    LogPublicApiEnd( "property %u, pVal %p", property, pVal );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::SetPropInternal(
    GROUPPROP property,
    VARIANT *pvarVal
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "property %u, Val %p", property, pvarVal );

    DWORD dwValue = -1;
    BSTR bstrIn = NULL;

    try
    {
        if (!pvarVal)
            throw ComError(E_INVALIDARG);

        THROW_HRESULT( LockedJob.ValidateAccess() );

        //
        // This is how the old code did it.  Unfortunate, but compatible.
        //
        switch (pvarVal->vt)
            {
            case VT_I4:
                dwValue = (DWORD)(pvarVal->lVal < 0) ? -1 : pvarVal->lVal;
                break;
            case VT_I2:
                dwValue = (DWORD)(pvarVal->iVal < 0) ? -1 : pvarVal->iVal;
                break;
            case VT_UI2:
                dwValue = (DWORD)pvarVal->uiVal;
                break;
            case VT_UI4:
                dwValue = (DWORD)pvarVal->ulVal;
                break;
            case VT_INT:
                dwValue = (DWORD)(pvarVal->intVal < 0) ? -1 : pvarVal->intVal;
                break;
            case VT_UINT:
                dwValue = (DWORD)pvarVal->uintVal;
                break;
            case VT_BSTR:
                bstrIn = pvarVal->bstrVal;
                break;
            default:
                return E_INVALIDARG;
            }

        switch (property)
           {
           case GROUPPROP_PRIORITY:
               //
               // Only one priority was supported.  No need to store it.
               //
               if (dwValue != 1)
                   {
                   throw ComError( E_NOTIMPL );
                   }
               break;

           case GROUPPROP_PROTOCOLFLAGS:

               //
               // Only HTTP was supported.  No need to store it.
               //
               if (dwValue != QM_PROTOCOL_HTTP)
                   {
                   throw ComError( E_NOTIMPL );
                   }
               break;

           case GROUPPROP_NOTIFYFLAGS:

               THROW_HRESULT( LockedJob->SetNotifyFlags( MapOldNotifyToNewNotify( dwValue ) ) );
               break;

            case GROUPPROP_NOTIFYCLSID:
                {
                if (NULL == bstrIn)
                    {
                    throw ComError( E_INVALIDARG );
                    }

                GUID clsid;
                THROW_HRESULT( IIDFromString( bstrIn, &clsid ) );

                m_NotifyClsid = clsid;
                break;
                }

           case GROUPPROP_DISPLAYNAME:
               THROW_HRESULT( LockedJob->SetDisplayName( (WCHAR *)bstrIn ) );
               break;

           case GROUPPROP_DESCRIPTION:
               THROW_HRESULT( LockedJob->SetDescription( (WCHAR *)bstrIn ) );
               break;

           default:
               return E_NOTIMPL;
           }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "property %u, pVal %p", property, pvarVal );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::GetProgressInternal(
    DWORD flags,
    DWORD * pProgress
    )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "flags %u", flags );

    try
    {

        ASSERT( pProgress );
        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS JobProgress;
        LockedJob->GetProgress( &JobProgress );

        switch( flags )
            {
            case QM_PROGRESS_SIZE_DONE:
                {

                *pProgress = NewJobSizeToOldSize( JobProgress.BytesTransferred );
                break;
                }

            case QM_PROGRESS_PERCENT_DONE:
                {

                if ( ( -1 == JobProgress.BytesTotal ) ||
                     ( -1 == JobProgress.BytesTransferred ) ||
                     ( 0 == JobProgress.BytesTotal ) )
                    {
                    *pProgress = 0;
                    }
                else
                    {
                    double ratio = double(JobProgress.BytesTransferred) / double(JobProgress.BytesTotal );
                    *pProgress = DWORD( ratio * 100.0 );
                    }
                break;
                }

            default:
                {
                throw ComError( E_NOTIMPL );
                }
            }
    }
    catch( ComError Error )
    {
       Hr = Error.Error();
       *pProgress = 0;
    }

    LogPublicApiEnd( "progress %d", *pProgress );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::GetStatusInternal(
    DWORD *pdwStatus,
    DWORD *pdwJobIndex)
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pdwStatus %p, pdwJobIndex %p", pdwStatus, pdwJobIndex );

    try
    {
        ASSERT( pdwStatus && pdwJobIndex );
        *pdwStatus = *pdwJobIndex = 0;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        // Note: we never increment the JobIndex anymore

        BG_JOB_STATE State = LockedJob->_GetState();
        BG_JOB_PRIORITY Priority = LockedJob->_GetPriority();

        if ( BG_JOB_PRIORITY_FOREGROUND == Priority )
            *pdwStatus |= QM_STATUS_GROUP_FOREGROUND;

        switch( State )
            {
            case BG_JOB_STATE_QUEUED:
            case BG_JOB_STATE_CONNECTING:
            case BG_JOB_STATE_TRANSFERRING:
                *pdwStatus |= QM_STATUS_GROUP_INCOMPLETE;
                break;

            case BG_JOB_STATE_SUSPENDED:
                *pdwStatus |= ( QM_STATUS_GROUP_SUSPENDED | QM_STATUS_GROUP_INCOMPLETE );
                break;

            case BG_JOB_STATE_ERROR:
                *pdwStatus |= ( QM_STATUS_GROUP_ERROR | QM_STATUS_GROUP_INCOMPLETE | QM_STATUS_GROUP_SUSPENDED );
                break;

            case BG_JOB_STATE_TRANSIENT_ERROR:
                *pdwStatus |= ( QM_STATUS_GROUP_INCOMPLETE );
                break;

            case BG_JOB_STATE_TRANSFERRED:
                *pdwStatus |= ( QM_STATUS_GROUP_COMPLETE | QM_STATUS_GROUP_SUSPENDED );
                break;

            case BG_JOB_STATE_ACKNOWLEDGED:
                *pdwStatus |= ( QM_STATUS_GROUP_COMPLETE | QM_STATUS_GROUP_SUSPENDED );
                break;

            case BG_JOB_STATE_CANCELLED:
                break;
            }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        *pdwStatus = 0;
    }

    LogPublicApiEnd( "pdwStatus %p, pdwJobIndex %p", pdwStatus, pdwJobIndex );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::GetJobInternal(
    GUID jobID,
    IBackgroundCopyJob1 **ppJob)
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "jobID %!guid!, ppJob %p", &jobID, ppJob );

    try
    {
        ASSERT( ppJob );
        *ppJob = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        COldJobInterface *pOldJob = m_pJob->GetOldExternalJobInterface();

        if (!pOldJob)
            throw ComError( QM_E_ITEM_NOT_FOUND );

        if (jobID != pOldJob->GetOldJobId() )
            throw ComError( QM_E_ITEM_NOT_FOUND );

        *ppJob = pOldJob;
        (*ppJob)->AddRef();

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "jobID %!guid!, ppJob %p", &jobID, ppJob );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::SuspendGroupInternal(
    )
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "void" );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );
        THROW_HRESULT( LockedJob->Suspend() );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "void" );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::ResumeGroupInternal(
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );

        THROW_HRESULT( LockedJob->Resume() );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::CancelGroupInternal(
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );
        THROW_HRESULT( LockedJob->Complete() );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::get_SizeInternal(
    DWORD *pdwSize
    )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        ASSERT( pdwSize );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS Progress;
        LockedJob->GetProgress( &Progress );

        *pdwSize = NewJobSizeToOldSize( Progress.BytesTotal );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        *pdwSize = 0;
    }


    LogPublicApiEnd( "dwSize %d", *pdwSize );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::get_GroupIDInternal(
    GUID *pguidGroupID )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        ASSERT( pguidGroupID );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        *pguidGroupID = LockedJob->GetId();

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        memset( pguidGroupID, 0 , sizeof(*pguidGroupID) );
    }

    LogPublicApiEnd( "id %!guid!", pguidGroupID );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::CreateJobInternal(
    GUID guidJobID,
    IBackgroundCopyJob1 **ppJob )
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "guidJobID %!guid!", &guidJobID );

    try
    {
        ASSERT( ppJob );
        *ppJob = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_STATE State = LockedJob->_GetState();
        switch( State )
            {

            case BG_JOB_STATE_QUEUED:
            case BG_JOB_STATE_CONNECTING:
            case BG_JOB_STATE_TRANSFERRING:
                throw ComError( QM_E_INVALID_STATE );
                break;

            case BG_JOB_STATE_SUSPENDED:
            case BG_JOB_STATE_ERROR:
                break;

            case BG_JOB_STATE_TRANSIENT_ERROR:
            case BG_JOB_STATE_TRANSFERRED:
            case BG_JOB_STATE_ACKNOWLEDGED:
            case BG_JOB_STATE_CANCELLED:
                throw ComError( QM_E_INVALID_STATE );
                break;

            default:
                throw ComError( QM_E_INVALID_STATE );
                break;
            }

        if (LockedJob->GetOldExternalJobInterface())
            throw ComError( E_NOTIMPL );

        COldJobInterface *pOldJob = new COldJobInterface( guidJobID, m_pJob );

        LockedJob->SetOldExternalJobInterface( pOldJob );

        *ppJob = pOldJob;
        (*ppJob)->AddRef();

        g_Manager->Serialize();

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "ppJob %p", *ppJob );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::EnumJobsInternal(
    DWORD dwFlags,
    IEnumBackgroundCopyJobs1 **ppEnumJobs )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "dwFlags %u, ppEnumJobs %p", dwFlags, ppEnumJobs );

    CEnumOldJobs* pEnum = NULL;
    try
    {
        ASSERT( ppEnumJobs );
        *ppEnumJobs = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        if (dwFlags)
            throw ComError( E_NOTIMPL );

        pEnum = new CEnumOldJobs;

        COldJobInterface *pOldJob = LockedJob->GetOldExternalJobInterface();
        if (pOldJob)
            {
            GUID guid = pOldJob->GetOldJobId();
            pEnum->Add( guid );
            }

        *ppEnumJobs = pEnum;

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "dwFlags %u, ppEnumJobs %p", dwFlags, ppEnumJobs );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::SwitchToForegroundInternal(
    )
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );

        THROW_HRESULT( LockedJob->SetPriority( BG_JOB_PRIORITY_FOREGROUND ) );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( " " );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::QueryNewJobInterface(
    REFIID iid,
    IUnknown **pUnk
    )
{
    LogInfo("QueryNewJobInterface %!guid!", &iid);

    if (iid != __uuidof(IBackgroundCopyJob))
        {
        LogError("E_NOTIMPL");
        *pUnk = NULL;
        return E_NOTIMPL;
        }

    *pUnk = m_pJob->GetExternalInterface();
    (*pUnk)->AddRef();

    LogInfo("OK");
    return S_OK;
}

STDMETHODIMP
COldGroupInterface::SetNotificationPointer(
    REFIID iid,
    IUnknown *pUnk
    )
{
    HRESULT Hr = S_OK;

    IBackgroundCopyCallback1 *pICB = NULL;

    LogPublicApiBegin( "IID %!guid!  ptr %p", &iid, pUnk );

    if (iid != __uuidof(IBackgroundCopyCallback1))
        {
        Hr = E_NOTIMPL;
        }
    else if ( pUnk )
        {
        try
            {
            CNestedImpersonation imp;

            //
            // Gotta do it twice, because SwitchToLogonToken will fail
            // if the user is not interactively logged in.
            //
            THROW_HRESULT( SetStaticCloaking( pUnk ) );

            imp.SwitchToLogonToken();

            THROW_HRESULT( SetStaticCloaking( pUnk ) );

            THROW_HRESULT( pUnk->QueryInterface( iid, (void**)&pICB ) );

            THROW_HRESULT( SetStaticCloaking( pICB ) );

            SafeRelease( m_NotifyPointer );

            m_NotifyPointer = pICB;
            }
        catch( ComError Error )
            {
            SafeRelease( pICB );
            Hr = Error.Error();
            }
        }

    LogPublicApiEnd( " " );

    return Hr;
}

IBackgroundCopyCallback1 *
COldGroupInterface::GetNotificationPointer()
{
    if (m_NotifyPointer)
        {
        m_NotifyPointer->AddRef();
        }

    return m_NotifyPointer;
}


void
COldGroupInterface::Serialize(
    HANDLE hFile
    )
{
    SafeWriteFile( hFile, m_NotifyClsid );

    if ( m_pJob->GetOldExternalJobInterface() )
        {
        SafeWriteFile( hFile, (bool)true );
        m_pJob->GetOldExternalJobInterface()->Serialize( hFile );
        }
    else
        {
        SafeWriteFile( hFile, (bool)false );
        }
    return;
}

COldGroupInterface *
COldGroupInterface::UnSerialize(
    HANDLE  hFile,
    CJob*   Job
    )
{
    COldGroupInterface * group = NULL;

    try
        {
        group = new COldGroupInterface(Job);
        if (!group)
            {
            throw ComError( E_OUTOFMEMORY );
            }

        SafeReadFile( hFile, &group->m_NotifyClsid );

        bool bHasOldExternalJobInterface;

        SafeReadFile( hFile, &bHasOldExternalJobInterface );

        if ( bHasOldExternalJobInterface )
            {
            COldJobInterface *OldJobInterface = COldJobInterface::Unserialize( hFile, Job );
            Job->SetOldExternalJobInterface( OldJobInterface );
            }

        }
    catch ( ComError Error )
        {
        delete group;
        throw;
        }

    return group;
}

COldJobInterface::COldJobInterface(
    GUID JobGuid,
    CJob *pJob ) :
    m_refs(1),
    m_ServiceInstance( g_ServiceInstance ),
    m_OldJobGuid( JobGuid ),
    m_pJob( pJob ),
    m_pJobExternal( pJob->GetExternalInterface() )
{
    m_pJobExternal->AddRef();
}

COldJobInterface::~COldJobInterface()
{
    m_pJobExternal->Release();
}

STDMETHODIMP
COldJobInterface::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    LogPublicApiBegin( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == _uuidof(IUnknown)) || (iid == __uuidof(IBackgroundCopyJob1)) )
        {
        *ppvObject = (IBackgroundCopyJob1 *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogPublicApiEnd( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldJobInterface::AddRef(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "job %p, refs = %d", m_pJob, newrefs );

    return newrefs;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldJobInterface::Release(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "job %p, refs = %d", m_pJob, newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}


STDMETHODIMP
COldJobInterface::AddFilesInternal(
    ULONG cFileCount,
    FILESETINFO **ppFileSet
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "cFileCount %u, ppFileSet %p", cFileCount, ppFileSet );

    BG_FILE_INFO *pFileInfo = NULL;

    try
    {
        ASSERT( ppFileSet );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        pFileInfo = new BG_FILE_INFO[cFileCount];
        if (!pFileInfo )
            {
            throw ComError(E_OUTOFMEMORY);
            }

        for(ULONG c = 0; c < cFileCount; c++ )
            {
            if ( !ppFileSet[c])
                throw ComError(E_INVALIDARG);

            // BSTRS act like WCHAR *
            pFileInfo[c].LocalName  = LPWSTR( (ppFileSet[c])->bstrLocalFile );
            pFileInfo[c].RemoteName = LPWSTR( (ppFileSet[c])->bstrRemoteFile );

            }

        THROW_HRESULT( LockedJob->AddFileSet( cFileCount,
                                              pFileInfo ) );

    }
    catch(ComError Error )
    {
        Hr = Error.Error();
    }

    // Should handle NULL
    delete[] pFileInfo;

    LogPublicApiEnd( "cFileCount %u, ppFileSet %p", cFileCount, ppFileSet );
    return Hr;
}

STDMETHODIMP
COldJobInterface::GetFileCountInternal(
    DWORD * pCount
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pCount %p", pCount );

    try
    {
        ASSERT( pCount );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS JobProgress;
        LockedJob->GetProgress( &JobProgress );

        *pCount = JobProgress.FilesTotal;

    }
    catch(ComError Error )
    {
        Hr = Error.Error();
        *pCount = 0;
    }

    LogPublicApiEnd( "pCount %p", pCount );
    return Hr;

}

STDMETHODIMP
COldJobInterface::GetFileInternal(
    ULONG cFileIndex,
    FILESETINFO *pFileInfo
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "cFileIndex %u, pFileInfo %p", cFileIndex, pFileInfo );

    WCHAR *pLocalName = NULL;
    WCHAR *pRemoteName = NULL;
    try
        {

        ASSERT( pFileInfo );
        memset( pFileInfo, 0, sizeof(FILESETINFO) );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        CFile *pFile = LockedJob->_GetFileIndex( cFileIndex );
        if (!pFile)
            throw ComError ( QM_E_ITEM_NOT_FOUND );


        THROW_HRESULT( pFile->GetLocalName( &pLocalName ) );
        THROW_HRESULT( pFile->GetRemoteName( &pRemoteName ) );

        pFileInfo->bstrLocalFile = SysAllocString( pLocalName );
        pFileInfo->bstrRemoteFile = SysAllocString( pRemoteName );

        if ( !pFileInfo->bstrLocalFile ||
             !pFileInfo->bstrRemoteFile )
            throw ComError( E_OUTOFMEMORY );

        BG_FILE_PROGRESS FileProgress;
        pFile->GetProgress( &FileProgress );

        pFileInfo->dwSizeHint = NewJobSizeToOldSize( FileProgress.BytesTotal );

        }
    catch ( ComError Error )
        {
        Hr = Error.Error();

        if ( pFileInfo )
            {
            SysFreeString( pFileInfo->bstrLocalFile );
            SysFreeString( pFileInfo->bstrRemoteFile );
            memset( pFileInfo, 0, sizeof(FILESETINFO) );
            }
        }

    // CoTaskMemFree handles NULL
    CoTaskMemFree( pLocalName );
    CoTaskMemFree( pRemoteName );

    LogPublicApiEnd( "cFileIndex %u, pFileInfo %p", cFileIndex, pFileInfo );
    return Hr;
}

STDMETHODIMP
COldJobInterface::CancelJobInternal()
{
    HRESULT Hr = E_NOTIMPL;
    LogPublicApiBegin( "void" );
    LogPublicApiEnd( "void" );
    return Hr;
}


STDMETHODIMP
COldJobInterface::get_JobIDInternal(
    GUID * pId
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pId %p", pId );

    try
    {
        ASSERT( pId );
        THROW_HRESULT( LockedJob.ValidateAccess() );

        *pId = GetOldJobId();
    }
    catch(ComError Error )
    {
        Hr = Error.Error();
        memset( pId, 0, sizeof(*pId) );
    }

    LogPublicApiEnd( "pId %p", pId );
    return Hr;
}



STDMETHODIMP
COldJobInterface::GetProgressInternal(
    DWORD flags,
    DWORD * pProgress
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "flags %u, pProgress %p", flags, pProgress );

    try
    {

        ASSERT( pProgress );
        *pProgress = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS JobProgress;
        LockedJob->GetProgress( &JobProgress );

        switch (flags)
            {
            case QM_PROGRESS_SIZE_DONE:
                {

                *pProgress = NewJobSizeToOldSize( JobProgress.BytesTransferred );
                break;
                }

            case QM_PROGRESS_PERCENT_DONE:
                {

                if ( ( -1 == JobProgress.BytesTotal ) ||
                     ( -1 == JobProgress.BytesTransferred ) ||
                     ( 0 == JobProgress.BytesTotal ) )
                    {
                    *pProgress = 0;
                    }
                else
                    {
                    double ratio = double(JobProgress.BytesTransferred) / double(JobProgress.BytesTotal );
                    *pProgress = DWORD( ratio * 100.0 );
                    }
                break;
                }

            default:
                {
                throw ComError( E_NOTIMPL );
                }
            }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "flags %u, pProgress %p", flags, pProgress );
    return Hr;
}

STDMETHODIMP
COldJobInterface::SwitchToForegroundInternal()
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "void" );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );
        Hr = E_NOTIMPL;
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "void" );
    return Hr;
}

STDMETHODIMP
COldJobInterface::GetStatusInternal(
    DWORD *pdwStatus,
    DWORD *pdwWin32Result,
    DWORD *pdwTransportResult,
    DWORD *pdwNumOfRetries
    )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pdwStatus %p, pdwWin32Result %p, pdwTransportResult %p, pdwNumOfRetries %p",
                       pdwStatus, pdwWin32Result, pdwTransportResult, pdwNumOfRetries );

    try
    {
        ASSERT( pdwStatus && pdwWin32Result &&
                pdwTransportResult && pdwNumOfRetries );

        *pdwStatus = *pdwWin32Result = *pdwTransportResult = *pdwNumOfRetries = 0;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PRIORITY Priority = LockedJob->_GetPriority();
        BG_JOB_STATE State       = LockedJob->_GetState();

        THROW_HRESULT( LockedJob->GetErrorCount( pdwNumOfRetries ) );

        if ( BG_JOB_PRIORITY_FOREGROUND == Priority )
            *pdwStatus |= QM_STATUS_JOB_FOREGROUND;

        switch( State )
            {
            case BG_JOB_STATE_QUEUED:
            case BG_JOB_STATE_CONNECTING:
            case BG_JOB_STATE_TRANSFERRING:
                *pdwStatus |= QM_STATUS_JOB_INCOMPLETE;
                break;
            case BG_JOB_STATE_SUSPENDED:
                *pdwStatus |= QM_STATUS_JOB_INCOMPLETE;
                break;
            case BG_JOB_STATE_ERROR:
                *pdwStatus |= QM_STATUS_JOB_ERROR;
                break;
            case BG_JOB_STATE_TRANSIENT_ERROR:
                *pdwStatus |= QM_STATUS_JOB_INCOMPLETE;
                break;
            case BG_JOB_STATE_TRANSFERRED:
                *pdwStatus |= QM_STATUS_JOB_COMPLETE;
                break;
            case BG_JOB_STATE_ACKNOWLEDGED:
                *pdwStatus |= QM_STATUS_JOB_COMPLETE;
                break;
            case BG_JOB_STATE_CANCELLED:
                break;
            default:
                ASSERT(0);
                break;
            }

        if ( BG_JOB_STATE_ERROR == State )
            {

            const CJobError * pError = LockedJob->GetError();

            ASSERT( pError );

            if ( pError )
                {
                pError->GetOldInterfaceErrors( pdwWin32Result, pdwTransportResult );
                }

            }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();

        *pdwStatus = 0;
        *pdwWin32Result = 0;
        *pdwTransportResult = 0;
        *pdwNumOfRetries = 0;
    }

    LogPublicApiEnd( "pdwStatus %p, pdwWin32Result %p, pdwTransportResult %p, pdwNumOfRetries %p",
                     pdwStatus, pdwWin32Result, pdwTransportResult, pdwNumOfRetries );
    return Hr;
}

void
COldJobInterface::Serialize(
    HANDLE hFile
    )
{
    SafeWriteFile( hFile, m_OldJobGuid );
}

COldJobInterface *
COldJobInterface::Unserialize(
    HANDLE  hFile,
    CJob*   Job
    )
{
    COldJobInterface * OldJob = NULL;

    try
        {
        GUID OldJobGuid;
        SafeReadFile( hFile, &OldJobGuid );
        OldJob = new COldJobInterface( OldJobGuid, Job );
        if (!OldJob)
            {
            throw ComError( E_OUTOFMEMORY );
            }
        }
    catch ( ComError Error )
        {
        delete OldJob;
        throw;
        }

    return OldJob;
}

COldQmgrInterface::COldQmgrInterface() :
    m_refs(1),
    m_ServiceInstance( g_ServiceInstance )
{
}


STDMETHODIMP
COldQmgrInterface::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    LogPublicApiBegin( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == _uuidof(IUnknown)) || (iid == __uuidof(IBackgroundCopyQMgr)) )
        {
        *ppvObject = (IBackgroundCopyQMgr *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if ( iid == __uuidof(IClassFactory) )
        {
        *ppvObject = (IClassFactory *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogPublicApiEnd( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldQmgrInterface::AddRef(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    return newrefs;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldQmgrInterface::Release(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}

STDMETHODIMP
COldQmgrInterface::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void ** ppvObject )
{

    BEGIN_EXTERNAL_FUNC

    HRESULT hr = S_OK;

    if (g_ServiceInstance != m_ServiceInstance ||
        g_ServiceState    != MANAGER_ACTIVE)
        {
        hr = CO_E_SERVER_STOPPING;
        }
    else if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        if ((riid == IID_IBackgroundCopyQMgr) || (riid == IID_IUnknown))
        {
            hr = QueryInterface(riid, ppvObject);
        }
        else
        {
            //
            // This seems like an odd choice, but we keep it in case some app depends upon it.
            //
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;

    END_EXTERNAL_FUNC

}

STDMETHODIMP
COldQmgrInterface::LockServer(
    BOOL fLock
    )
{
    BEGIN_EXTERNAL_FUNC

    return GlobalLockServer( fLock );

    END_EXTERNAL_FUNC
}

STDMETHODIMP
COldQmgrInterface::CreateGroupInternal(
    GUID id,
    IBackgroundCopyGroup **ppGroup
    )
{
    HRESULT Hr = S_OK;
    CLockedJobManagerWritePointer LockedJobManager( m_pJobManager );
    LogPublicApiBegin( "id %!guid!", &id );

    CJob *job = NULL;

    //
    // create the job
    //
    try
        {

        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        ASSERT( ppGroup );

        const WCHAR *DisplayName = L"";
        CLSID *CallbackClass = NULL;
        BG_JOB_TYPE Type = BG_JOB_TYPE_DOWNLOAD;

        THROW_HRESULT( LockedJobManager->CreateJob( DisplayName,
                                                    Type,
                                                    id,
                                                    GetThreadClientSid(),
                                                    &job,
                                                    true
                                                    ));

        THROW_HRESULT( job->SetNotifyFlags( MapOldNotifyToNewNotify(0) ) );

        *ppGroup = ( IBackgroundCopyGroup * )job->GetOldExternalGroupInterface();
        ASSERT( *ppGroup );

        (*ppGroup)->AddRef();

        }

    catch( ComError exception )
        {
        Hr = exception.Error();

        if ( job )
            job->Cancel();
        }

    LogPublicApiEnd( "id %!guid!, group %p", &id, *ppGroup );
    return Hr;
}


STDMETHODIMP
COldQmgrInterface::GetGroupInternal(
    GUID id,
    IBackgroundCopyGroup ** ppGroup
    )
{
    HRESULT Hr = S_OK;
    CLockedJobManagerWritePointer LockedJobManager( m_pJobManager );
    LogPublicApiBegin( "id %!guid!", &id );

    CJob *pJob = NULL;

    try
    {
        ASSERT( ppGroup );
        *ppGroup = NULL;

        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        Hr = LockedJobManager->GetJob( id, &pJob );

        if (FAILED(Hr))
            {
            if (Hr == BG_E_NOT_FOUND)
                {
                Hr = QM_E_ITEM_NOT_FOUND;
                }

            throw ComError( Hr );
            }

        COldGroupInterface *pOldGroup = pJob->GetOldExternalGroupInterface();
        if ( !pOldGroup )
            throw ComError( QM_E_ITEM_NOT_FOUND );

        // try to take ownership of the job/group
        // this should suceed even if we are the current owner

        THROW_HRESULT( pJob->TakeOwnership());

        pOldGroup->AddRef();

        *ppGroup = (IBackgroundCopyGroup*)pOldGroup;
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "id %!guid!, group %p", &id, *ppGroup );
    return Hr;

}

STDMETHODIMP
COldQmgrInterface::EnumGroupsInternal(
    DWORD flags,
    IEnumBackgroundCopyGroups **ppEnum
    )
{

    HRESULT Hr = S_OK;
    CLockedJobManagerWritePointer LockedJobManager( m_pJobManager );
    LogPublicApiBegin( "flags %u, ppEnum %p", flags, ppEnum );

    CEnumOldGroups *pEnum = NULL;

    try
    {

        ASSERT( ppEnum );
        *ppEnum = NULL;

        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        if (flags)
            {
            LogWarning( "rejecting nonzero dwFlags");
            throw ComError( E_NOTIMPL );
            }

        pEnum = new CEnumOldGroups;

        for (CJobList::iterator iter = LockedJobManager->m_OnlineJobs.begin();
             iter != LockedJobManager->m_OnlineJobs.end();
             ++iter)
            {

            Hr = (*iter).IsVisible();
            if (FAILED(Hr))
                {
                throw ComError( Hr );
                }

            if (Hr == S_FALSE)
                {
                continue;
                }

            // Skip jobs that were not created with the old interface.
            if (!(*iter).GetOldExternalGroupInterface())
                {
                continue;
                }

            GUID guid = (*iter).GetId();
            pEnum->Add( guid );
            }

        *ppEnum = pEnum;
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        delete pEnum;
    }

    LogPublicApiEnd( "flags %u, ppEnum %p", flags, ppEnum );
    return Hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\downloader.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    progressivedl.h

Abstract :

    Main header file for downloader.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#define MIN(a, b)       (a>b ? b:a)
#define MAX(a, b)       (a>b ? a:b)

#define MAX_REPLY_DATA (2 * INTERNET_MAX_URL_LENGTH)

#define E_RETRY                     HRESULT_FROM_WIN32( ERROR_RETRY )
#define BG_E_HEADER_NOT_FOUND       HRESULT_FROM_WIN32( ERROR_HTTP_HEADER_NOT_FOUND )

//
// valid in HTTP 1.1, but not defined in the Windows-XP version of wininet.h
//
#define HTTP_STATUS_RANGE_NOT_SATISFIABLE    416

//----------------------------------------------------------------------

typedef HRESULT (*QMCALLBACK)(DWORD, DWORD, LPBYTE, DWORD);

#define             MAX_VIA_HEADER_LENGTH  300

//
// This is the size of the read buffer for downloads.  48kb is dramatically better than 32kb or 64kb,
// for obscure reasons.
//
#define FILE_DATA_BUFFER_LEN (48*1024)

extern BYTE g_FileDataBuffer[];

//--------------------------------------------

struct URL_INFO
{
    HINTERNET           hInternet;
    HINTERNET           hConnect;

    FILETIME            UrlModificationTime;
    UINT64              FileSize;
    DWORD               dwFlags;

    bool                bHttp11;
    bool                bRange;
    bool                fProxy;

    //
    // Most of these could be stack variables, but they are too big.
    //

    TCHAR               HostName[INTERNET_MAX_URL_LENGTH + 1];

    // host-relative URL
    //
    TCHAR               UrlPath[INTERNET_MAX_URL_LENGTH + 1];

    INTERNET_PORT Port;

    // a copy of <UrlPath> with range information appended as parameters
    //
    TCHAR               BlockUrl[INTERNET_MAX_URL_LENGTH + 1];

    TCHAR               UserName[UNLEN + 1];
    TCHAR               Password[UNLEN + 1];

    PROXY_SETTINGS_CONTAINER * ProxySettings;

    CAutoString         ProxyHost;

    TCHAR               ViaHeader[ MAX_VIA_HEADER_LENGTH + 1];

    const CCredentialsContainer * Credentials;

    //--------

    URL_INFO(
        LPCTSTR a_Url,
        const PROXY_SETTINGS * a_ProxySettings,
        const CCredentialsContainer * a_Credentials,
        LPCTSTR HostId = NULL
        );

    ~URL_INFO();

    void Cleanup();

    QMErrInfo Connect();

    void Disconnect();

    BOOL
    GetProxyUsage(
        HINTERNET   hRequest,
        QMErrInfo   *pQMErrInfo
        );

};

//---------------------------------------------

class CUploadJob;

class CJobManager;

class ITransferCallback
{
public:

    virtual bool
    DownloaderProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        ) = 0;

    virtual bool
    PollAbort() = 0;

    virtual bool
    UploaderProgress(
        UINT64 BytesTransferred
        ) = 0;

};

class Downloader
{
public:

    virtual HRESULT Download( LPCTSTR szURL,
                              LPCTSTR szDest,
                              UINT64  Offset,
                              ITransferCallback *CallBack,
                              QMErrInfo *pErrInfo,
                              HANDLE hToken,
                              BOOL   bThrottle,
                              const PROXY_SETTINGS * pProxySettings, // optional
                              const CCredentialsContainer * Credentials,
                              const StringHandle HostId = StringHandle() // optional
                              ) = 0;

    virtual HRESULT GetRemoteFileInformation(
        HANDLE hToken,
        LPCTSTR szURL,
        UINT64 *  pFileSize,
        FILETIME *pFileTime,
        QMErrInfo *pErrInfo,
        const PROXY_SETTINGS * pProxySettings, //optional
        const CCredentialsContainer * Credentials, // optional
        const StringHandle HostId = StringHandle() // optional
        ) = 0;

    virtual void
    Upload(
        CUploadJob *        job,
        ITransferCallback * CallBack,
        HANDLE              Token,
        QMErrInfo &         ErrInfo
        ) = 0;

    virtual ~Downloader()  {}

protected:

};

HRESULT CreateHttpDownloader( Downloader **ppDownloader, QMErrInfo *pErrInfo );
void    DeleteHttpDownloader( Downloader *  pDownloader );

extern DWORD g_dwDownloadThread;
extern HWND ghPDWnd;

//
// conversion factor to go from time in milliseconds to time in 100-nanoseconds.
//
#define ONE_MSEC_IN_100_NSEC  (10 * 1000)

class CPeriodicTimer
{
public:

    CPeriodicTimer(
        LPSECURITY_ATTRIBUTES Security = NULL,
        BOOL ManualReset               = FALSE,
        LPCTSTR Name                   = NULL
        )
    {
        m_handle = CreateWaitableTimer( Security, ManualReset, Name );
        if (!m_handle)
            {
            ThrowLastError();
            }
    }

    ~CPeriodicTimer()
    {
        if (m_handle)
            {
            CloseHandle( m_handle );
            }
    }

    BOOL Start(
        LONG Period,
        BOOL fResume        = FALSE,
        PTIMERAPCROUTINE fn = NULL,
        LPVOID arg          = NULL
        )
    {
        LARGE_INTEGER Time;

        //
        // negative values are relative; positive values are absolute.
        // The period is in milliseconds, but the start time is in units of 100-nanoseconds,
        //
        Time.QuadPart = -1 * Period * ONE_MSEC_IN_100_NSEC;

        return SetWaitableTimer( m_handle, &Time, Period, fn, arg, fResume );
    }

    BOOL Stop()
    {
        return CancelWaitableTimer( m_handle );
    }

    BOOL Wait(
        LONG msec = INFINITE
        )
    {
        if (WAIT_OBJECT_0 != WaitForSingleObject( m_handle, msec ))
            {
            return FALSE;
            }

        return TRUE;
    }

private:

    HANDLE m_handle;
};

//
// Network rate is in bytes per second.
//
typedef float NETWORK_RATE;

class CNetworkInterface
{
public:

    //
    // snapshot indices
    //
    enum
    {
        BLOCK_START = 0,
        BLOCK_END,
        BLOCK_INTERVAL_END,
        BLOCK_COUNT
    };

    typedef float SECONDS;

    //
    // public interface
    //

    CNetworkInterface();

    void Reset();

    void SetInterfaceSpeed();

    HRESULT
    TakeSnapshot(
        int SnapshotIndex
        );

    HRESULT
    SetInterfaceIndex(
        const TCHAR host[]
        );

    BOOL
    SetTimerInterval(
        SECONDS interval
        );

    NETWORK_RATE GetInterfaceSpeed()
    {
        return m_ServerSpeed;
    }

    float GetPercentFree()
    {
        return m_PercentFree;
    }

    void ResetInterface()
    {
        m_InterfaceIndex = -1;
    }

    void Wait()      { m_Timer.Wait(); }
    void StopTimer() { m_Timer.Stop(); }

    void CalculateIntervalAndBlockSize( UINT64 MaxBlockSize );

    DWORD               m_BlockSize;

    SECONDS             m_BlockInterval;

private:

    static const NETWORK_RATE DEFAULT_SPEED;

    struct NET_SNAPSHOT
    {
        LARGE_INTEGER   TimeStamp;
        UINT   BytesIn;
        UINT   BytesOut;
    };

    //
    // index of the interface that Wininet would use to talk to the server.
    //
    DWORD           m_InterfaceIndex;

    //
    // the "start" and "end" pictures of network activity.
    //
    NET_SNAPSHOT    m_Snapshots[BLOCK_COUNT];

    //
    // the apparent speed of the connection to our server
    //
    NETWORK_RATE    m_ServerSpeed;

    //
    // The local interface's apparent speed
    //
    NETWORK_RATE    m_NetcardSpeed;

    //
    //
    //
    float           m_PercentFree;

    //
    // Error value from previous snapshots in the current series {BLOCK_START, BLOCK_END, INTERVAL_END}.
    //
    HRESULT         m_SnapshotError;

    //
    // true if all three snapshots in the current series are valid.
    // If so, then it is safe to calculate network speed and server speed.
    //
    bool            m_SnapshotsValid;

    MIB_IFROW       m_TempRow;

    //
    // The download thread sends only one packet per timer notification.
    // This is the timer.
    //
    CPeriodicTimer      m_Timer;

    enum DOWNLOAD_STATE
    {
        DOWNLOADED_BLOCK = 0x55,
        SKIPPED_ONE_BLOCK,
        SKIPPED_TWO_BLOCKS
    };

    enum DOWNLOAD_STATE m_state;

    static HRESULT
    FindInterfaceIndex(
        const TCHAR host[],
        DWORD * pIndex
        );

    float GetTimeDifference( int start, int finish );

    //throttle related

    DWORD
    BlockSizeFromInterval(
        SECONDS interval
        );

    SECONDS
    IntervalFromBlockSize(
        DWORD BlockSize
        );

};

/////////////////////////////////////////////////////////////////////////////
// CProgressiveDL
//
class CProgressiveDL : public Downloader
{
public:
    CProgressiveDL( QMErrInfo *pErrInfo );
    ~CProgressiveDL();

    // pure virtual method from class Downloader

    virtual HRESULT
    Download( LPCTSTR szURL,
              LPCTSTR szDest,
              UINT64  Offset,
              ITransferCallback * CallBack,
              QMErrInfo *pErrInfo,
              HANDLE hToken,
              BOOL   bThrottle,
              const PROXY_SETTINGS *pProxySettings,
              const CCredentialsContainer * Credentials,
              const StringHandle HostId = StringHandle()
              );

    virtual HRESULT
    GetRemoteFileInformation(
        HANDLE hToken,
        LPCTSTR szURL,
        UINT64 *  pFileSize,
        FILETIME *pFileTime,
        QMErrInfo *pErrInfo,
        const PROXY_SETTINGS * pProxySettings,
        const CCredentialsContainer * Credentials,
        const StringHandle HostId = StringHandle()
        );

    virtual void
    Upload(
        CUploadJob *        job,
        ITransferCallback * CallBack,
        HANDLE              Token,
        QMErrInfo &         ErrInfo
        );

// other methods

private:

    //download related

    BOOL
    OpenLocalDownloadFile( LPCTSTR Path,
                           UINT64  Offset,
                           UINT64  Size,
                           FILETIME UrlModificationTime,
                           FILETIME * pFileTime
                           );

    BOOL CloseLocalFile();

    BOOL    WriteBlockToCache(LPBYTE lpBuffer, DWORD dwRead);

    BOOL    SetFileTimes();

    HRESULT
    DownloadFile(
        HANDLE  hToken,
        const PROXY_SETTINGS * ProxySettings,
        const CCredentialsContainer * Credentials,
        LPCTSTR Url,
        LPCWSTR Path,
        UINT64  Offset,
        StringHandle HostId
        );

    HRESULT GetNextBlock( );
    BOOL    DownloadBlock( void * Buffer, DWORD * pdwRead);

    HRESULT OpenConnection();
    void    CloseHandles();

    BOOL IsAbortRequested()
    {
        return m_Callbacks->PollAbort();
    }

    BOOL IsFileComplete()
    {
        if (m_CurrentOffset == m_wupdinfo->FileSize)
            {
            return TRUE;
            }

        return FALSE;
    }

    void ClearError();

    void
    SetError(
        ERROR_SOURCE  Source,
        ERROR_STYLE   Style,
        UINT64        Code,
        char *        comment = 0
        );

    BOOL IsErrorSet()
    {

        // If the file was aborted, the error wont
        // be set.
        if (QM_FILE_ABORTED == m_pQMInfo->result)
            {
            return TRUE;
            }

        if (QM_SERVER_FILE_CHANGED == m_pQMInfo->result )
            {
            return TRUE;
            }

        if (m_pQMInfo->Style != 0)
            {
            return TRUE;
            }

        return FALSE;
    }

    BOOL
    GetRemoteResourceInformation(
        URL_INFO * Info,
        QMErrInfo * pQMErrInfo
        );

    HRESULT
    SetRequestProxy(
        HINTERNET hRequest,
        URL_INFO & Info,
        const PROXY_SETTINGS * ProxySettings
        );

    //
    // These are static so they they don't mess with member data accidentally
    //

    static bool
    DoesErrorIndicateNoISAPI(
        DWORD dwHttpError
        );

    HRESULT CreateBlockUrl( LPTSTR lpszNewUrl, DWORD Length);

    HRESULT StartEncodedRangeRequest( DWORD Length );

    HRESULT StartRangeRequest( DWORD Length );

    //--------------------------------------------------------------------

    HANDLE m_hFile;

    //download related

    URL_INFO    *   m_wupdinfo;

    UINT64          m_CurrentOffset;

    HINTERNET       m_hOpenRequest;

    QMErrInfo       *m_pQMInfo;

    ITransferCallback * m_Callbacks;

    BOOL            m_bThrottle;

    HRESULT DownloadForegroundFile();

public:

    //
    // Tracks network statistics.
    //
    CNetworkInterface   m_Network;

};

extern CACHED_AUTOPROXY * g_ProxyCache;


class CAbstractDataReader
{
public:

    virtual DWORD GetLength() const = 0;
    virtual HRESULT Rewind() = 0;
    virtual HRESULT Read( PVOID Buffer, DWORD Length, DWORD * pBytesRead ) = 0;
    virtual bool IsCancelled( DWORD BytesRead ) = 0;
};

HRESULT
SendRequest(
    HINTERNET hRequest,
    URL_INFO * Info,
    CAbstractDataReader * Reader = 0
    );

HRESULT
SetRequestCredentials(
    HINTERNET hRequest,
    const CCredentialsContainer & Container
    );

HRESULT
SetRequestProxy(
    HINTERNET hRequest,
    PROXY_SETTINGS_CONTAINER * ProxySettings
    );

HRESULT
OpenHttpRequest(
    LPCTSTR Verb,
    LPCTSTR Protocol,
    URL_INFO & Info,
    HINTERNET * phRequest
    );

URL_INFO *
ConnectToUrl(
    LPCTSTR          Url,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    LPCTSTR          HostId,
    QMErrInfo * pErrInfo
    );

HRESULT
GetRequestHeader(
    HINTERNET hRequest,
    DWORD HeaderIndex,
    LPCWSTR HeaderName,
    CAutoString & Destination,
    size_t MaxChars
    );

HRESULT
GetResponseVersion(
    HINTERNET hRequest,
    unsigned * MajorVersion,
    unsigned * MinorVersion
    );

HRESULT
AddRangeHeader(
    HINTERNET hRequest,
    UINT64 Start,
    UINT64 End
    );

HRESULT
AddIf_Unmodified_SinceHeader(
    HINTERNET hRequest,
    const FILETIME &Time
    );

HRESULT CheckLanManHashDisabled ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\drizcpat.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    drizcpat.h

Abstract :

    Compatibility wrapper against the old AU bits.

Author :

Revision History :

 ***********************************************************************/

#pragma once
#if !defined(___DRIZCPAT_H___)
#define ___DRIZCPAT_H___

#include "qmgrlib.h"
#include "qmgr.h"

class COldJobInterface : public IBackgroundCopyJob1
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyJob1 methods

    STDMETHOD(AddFilesInternal)( ULONG cFileCount, FILESETINFO **ppFileSet );
    STDMETHOD(AddFiles)( ULONG cFileCount, FILESETINFO **ppFileSet )
        { EXTERNAL_FUNC_WRAP( AddFilesInternal( cFileCount, ppFileSet ) ) }
    STDMETHOD(GetFileCountInternal)( DWORD *pCount );
    STDMETHOD(GetFileCount)( DWORD *pCount )
        { EXTERNAL_FUNC_WRAP( GetFileCountInternal( pCount ) ) }
    STDMETHOD(GetFileInternal)( ULONG cFileIndex, FILESETINFO *pFileInfo );
    STDMETHOD(GetFile)( ULONG cFileIndex, FILESETINFO *pFileInfo )
        { EXTERNAL_FUNC_WRAP( GetFileInternal( cFileIndex, pFileInfo ) ) }
    STDMETHOD(CancelJobInternal)();
    STDMETHOD(CancelJob)()
        { EXTERNAL_FUNC_WRAP( CancelJobInternal( ) ) }
    STDMETHOD(get_JobIDInternal)(GUID *pId);
    STDMETHOD(get_JobID)(GUID *pId)
        { EXTERNAL_FUNC_WRAP( get_JobIDInternal( pId ) ) }
    STDMETHOD(GetProgressInternal)(DWORD flags, DWORD *pProgress);
    STDMETHOD(GetProgress)(DWORD flags, DWORD *pProgress)
        { EXTERNAL_FUNC_WRAP( GetProgressInternal( flags, pProgress ) ) }
    STDMETHOD(SwitchToForegroundInternal)();
    STDMETHOD(SwitchToForeground)()
        { EXTERNAL_FUNC_WRAP( SwitchToForegroundInternal( ) ) }
    STDMETHOD(GetStatusInternal)(DWORD *pdwStatus,DWORD *pdwWin32Result, DWORD *pdwTransportResult, DWORD *pdwNumOfRetries );
    STDMETHOD(GetStatus)(DWORD *pdwStatus,DWORD *pdwWin32Result, DWORD *pdwTransportResult, DWORD *pdwNumOfRetries )
        { EXTERNAL_FUNC_WRAP( GetStatusInternal( pdwStatus, pdwWin32Result, pdwTransportResult, pdwNumOfRetries ) ) }

    GUID GetOldJobId()
    {
        return m_OldJobGuid;
    }

    COldJobInterface( GUID JobGuid, CJob *pJob );
    ~COldJobInterface();

    void Serialize( HANDLE hFile );

    static COldJobInterface *Unserialize(
        HANDLE  hFile,
        CJob*   Job
        );

    void SetInterfaceClass(
        CJob *pVal
        )
    {
        m_pJob = pVal;
    }

private:

    long    m_refs;
    long    m_ServiceInstance;

    const GUID              m_OldJobGuid;
    CJob *                  m_pJob;
    CJobExternal * const    m_pJobExternal;
};

class COldGroupInterface : public IBackgroundCopyGroup
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyGroup methods

    STDMETHOD(GetPropInternal)( GROUPPROP property, VARIANT * pVal );
    STDMETHOD(GetProp)( GROUPPROP property, VARIANT * pVal )
        { EXTERNAL_FUNC_WRAP( GetPropInternal( property, pVal ) ) }
    STDMETHOD(SetPropInternal)( GROUPPROP property, VARIANT *pvarVal );
    STDMETHOD(SetProp)( GROUPPROP property, VARIANT *pvarVal )
        { EXTERNAL_FUNC_WRAP( SetPropInternal( property, pvarVal ) ) }
    STDMETHOD(GetProgressInternal)( DWORD flags, DWORD * pProgress );
    STDMETHOD(GetProgress)( DWORD flags, DWORD * pProgress )
        { EXTERNAL_FUNC_WRAP( GetProgressInternal( flags, pProgress ) ) }
    STDMETHOD(GetStatusInternal)( DWORD *pdwStatus, DWORD *pdwJobIndex );
    STDMETHOD(GetStatus)( DWORD *pdwStatus, DWORD *pdwJobIndex )
        { EXTERNAL_FUNC_WRAP( GetStatusInternal( pdwStatus, pdwJobIndex ) ) }
    STDMETHOD(GetJobInternal)( GUID jobID, IBackgroundCopyJob1 **ppJob );
    STDMETHOD(GetJob)( GUID jobID, IBackgroundCopyJob1 **ppJob )
        { EXTERNAL_FUNC_WRAP( GetJobInternal( jobID, ppJob ) ) }
    STDMETHOD(SuspendGroupInternal)();
    STDMETHOD(SuspendGroup)()
        { EXTERNAL_FUNC_WRAP( SuspendGroupInternal() ) }
    STDMETHOD(ResumeGroupInternal)();
    STDMETHOD(ResumeGroup)()
        { EXTERNAL_FUNC_WRAP( ResumeGroupInternal() ) }
    STDMETHOD(CancelGroupInternal)();
    STDMETHOD(CancelGroup)()
        { EXTERNAL_FUNC_WRAP( CancelGroupInternal() ) }
    STDMETHOD(get_SizeInternal)( DWORD *pdwSize );
    STDMETHOD(get_Size)( DWORD *pdwSize )
        { EXTERNAL_FUNC_WRAP( get_SizeInternal( pdwSize ) ) }
    STDMETHOD(get_GroupIDInternal)( GUID *pguidGroupID );
    STDMETHOD(get_GroupID)( GUID *pguidGroupID )
        { EXTERNAL_FUNC_WRAP( get_GroupIDInternal( pguidGroupID ) ) }
    STDMETHOD(CreateJobInternal)( GUID guidJobID, IBackgroundCopyJob1 **ppJob );
    STDMETHOD(CreateJob)( GUID guidJobID, IBackgroundCopyJob1 **ppJob )
        { EXTERNAL_FUNC_WRAP( CreateJobInternal( guidJobID, ppJob ) ) }
    STDMETHOD(EnumJobsInternal)( DWORD dwFlags, IEnumBackgroundCopyJobs1 **ppEnumJobs );
    STDMETHOD(EnumJobs)( DWORD dwFlags, IEnumBackgroundCopyJobs1 **ppEnumJobs )
        { EXTERNAL_FUNC_WRAP( EnumJobsInternal( dwFlags, ppEnumJobs ) ) }
    STDMETHOD(SwitchToForegroundInternal)();
    STDMETHOD(SwitchToForeground)()
        { EXTERNAL_FUNC_WRAP( SwitchToForegroundInternal() ) }

    // extensions to IBackgroundCopyGroup, not in original Mars interface

    STDMETHOD(QueryNewJobInterface)( REFIID iid, IUnknown ** pUnk );
    STDMETHOD(SetNotificationPointer)( REFIID iid, IUnknown * pUnk );

    COldGroupInterface( CJob *pJob );
    ~COldGroupInterface();

    void Serialize( HANDLE hFile );
    static COldGroupInterface *UnSerialize(HANDLE  hFile, CJob* Job);

    IBackgroundCopyCallback1 * GetNotificationPointer();

    void SetInterfaceClass(
        CJob *pVal
        )
    {
        m_pJob = pVal;
    }

private:

    long m_refs;
    long m_ServiceInstance;

    CJob *                  m_pJob;
    CJobExternal * const    m_pJobExternal;

    IBackgroundCopyCallback1 * m_NotifyPointer;
    GUID                       m_NotifyClsid;
};


class COldQmgrInterface : public IBackgroundCopyQMgr,
                          public IClassFactory
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IClassFactory
    STDMETHOD(CreateInstance)( IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
    STDMETHOD(LockServer)( BOOL fLock );

    // IBackgroundCopyQmgr
    STDMETHOD(CreateGroupInternal)(GUID id, IBackgroundCopyGroup **ppGroup);
    STDMETHOD(CreateGroup)(GUID id, IBackgroundCopyGroup **ppGroup)
        { EXTERNAL_FUNC_WRAP( CreateGroupInternal( id, ppGroup ) ) }
    STDMETHOD(GetGroupInternal)(GUID id, IBackgroundCopyGroup ** ppGroup);
    STDMETHOD(GetGroup)(GUID id, IBackgroundCopyGroup ** ppGroup)
        { EXTERNAL_FUNC_WRAP( GetGroupInternal( id, ppGroup ) ) }
    STDMETHOD(EnumGroupsInternal)(DWORD flags, IEnumBackgroundCopyGroups **ppEnum );
    STDMETHOD(EnumGroups)(DWORD flags, IEnumBackgroundCopyGroups **ppEnum )
        { EXTERNAL_FUNC_WRAP( EnumGroupsInternal( flags, ppEnum ) ) }

    // other methods

    COldQmgrInterface();

    void SetInterfaceClass(
        CJobManager *pVal
        )
    {
        m_pJobManager = pVal;
    }

private:

    long m_refs;
    long m_ServiceInstance;

    CJobManager *m_pJobManager;
};

class CEnumOldGroups : public CEnumItem<IEnumBackgroundCopyGroups,GUID>
{
public:
    CEnumOldGroups();
};

class CEnumOldJobs : public CEnumItem<IEnumBackgroundCopyJobs1,GUID>
{
public:
    CEnumOldJobs();
};

#endif //__DRIZCPAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\downloader.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    downloader.cpp

Abstract :

    Main Source file for downloader.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include "malloc.h"

#if !defined(BITS_V12_ON_NT4)
#include "downloader.tmh"
#endif

BOOL bLanManHashDisabled;

//
// Maximum request size.  Larger is more efficient because the HTTP headers are not repeated;
// multiples of the disk block size are probably more efficient to write.
//
// I chose 128kb because throughput degrades by a factor of 5 with 144kb, 256kb and 1024kb.
// 96kb is OK but not quite as good on my machine.
//
#define MAX_IIS_SEND_SIZE (128*1024)

void SafeCloseInternetHandle( HINTERNET & h )
{
    if (h)
        {
        InternetCloseHandle( h );
        h = NULL;
        }
}

#define ACCEPT_ENCODING_STRING _T("Accept-encoding: identity")

BOOL NeedRetry( QMErrInfo * );
bool NeedCredentials( HINTERNET hRequest, DWORD err );
bool IsPossibleProxyFailure( DWORD err );

DWORD GetRequestStatus( HINTERNET hRequest ) throw( ComError );

struct CredentialsApplied
{
    bool  bIsDefault;   // TRUE if the default credentials where applied.
    DWORD dwTarget;     // proxy or server
    DWORD dwScheme;     // the type of security required
};

bool
ApplyCredentials(
    HINTERNET hRequest,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[],
    CredentialsApplied *pCredentials=NULL
    ) throw( ComError );

bool
ApplySchemeCredentials(
    HINTERNET hRequest,
    DWORD dwTarget,
    DWORD dwScheme,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[]
    ) throw( ComError );

void
EnablePassport(
    HINTERNET hInternet
    ) throw( ComError );

HRESULT
CheckReplyRange(
    HINTERNET hRequest,
    UINT64 CorrectStart,
    UINT64 CorrectEnd,
    UINT64 CorrectTotal
    );

HRESULT
CheckReplyLength(
    HINTERNET hRequest,
    UINT64 CorrectOffset,
    UINT64 CorrectTotal
    );

#ifndef USE_WININET

VOID CALLBACK
HttpRequestCallback(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

DWORD
MapSecureHttpErrorCode(
    DWORD flags
    );

#endif

CACHED_AUTOPROXY * g_ProxyCache;

BYTE g_FileDataBuffer[ FILE_DATA_BUFFER_LEN ];

HRESULT
CreateHttpDownloader(
    Downloader **ppDownloader,
    QMErrInfo *pErrInfo
    )
{
    Downloader * pDownloader = 0;

    try
        {
        *ppDownloader = NULL;

        g_ProxyCache = new CACHED_AUTOPROXY;
        pDownloader = new CProgressiveDL( pErrInfo );

        *ppDownloader = pDownloader;
        return S_OK;
        }
    catch ( ComError err )
        {
        delete g_ProxyCache; g_ProxyCache = 0;
        delete pDownloader;

        return err.Error();
        }
}

void
DeleteHttpDownloader(
    Downloader *pDownloader
    )
{
    CProgressiveDL * ptr = (CProgressiveDL *) pDownloader;

    delete ptr;

    delete g_ProxyCache; g_ProxyCache = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CProgressiveDL
CProgressiveDL::CProgressiveDL(
    QMErrInfo *pErrInfo
    ) :
    m_bThrottle( TRUE ),
    m_wupdinfo( NULL ),
    m_hOpenRequest( NULL ),
    m_hFile( INVALID_HANDLE_VALUE )
{
    m_pQMInfo = pErrInfo;
}

CProgressiveDL::~CProgressiveDL()
{
    ASSERT( m_hFile == INVALID_HANDLE_VALUE );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Public function Download()
//          Accepts a URL and destination to download, callback to report various status
// Input: url, destination, flags, callback for status
// Output: todo handle
// Return: hresult
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT
CProgressiveDL::Download(
    LPCTSTR szURL,
    LPCTSTR szDest,
    UINT64  Offset,
    ITransferCallback * Callbacks,
    QMErrInfo *pQMErrInfo,
    HANDLE hToken,
    BOOL bThrottle,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    const StringHandle HostId
    )
{
    HRESULT hr = S_OK;
    DWORD dwThreadID;

    m_Callbacks = Callbacks;
    m_pQMInfo = pQMErrInfo;
    m_bThrottle = bThrottle;
    m_pQMInfo->result = QM_FILE_FATAL_ERROR;

    ASSERT( Callbacks );
    ASSERT( pQMErrInfo );

    if (!m_pQMInfo)
        {
        return E_FAIL;
        }

    if ((!szURL) || (!szDest))
        {
        SetError( SOURCE_HTTP_UNKNOWN, ERROR_STYLE_HRESULT, E_INVALIDARG, "NULL file name" );
        return E_FAIL;
        }

    ASSERT( wcslen( szURL ) <= INTERNET_MAX_URL_LENGTH );
    ASSERT( wcslen( szDest ) <= MAX_PATH );

    LogDl( "---------------------------------------------------------------------" );

    LogDl( "Downloading file %!ts! offset %d", szDest, DWORD(Offset) );

    m_pQMInfo->result = QM_IN_PROGRESS;

    do
        {
        hr = DownloadFile( hToken, ProxySettings, Credentials, szURL, szDest, Offset, HostId );
        }
    while ( hr == E_RETRY );

    if (hr == S_OK)
        {
        m_pQMInfo->result = QM_FILE_DONE;
        LogDl( "Done file %!ts!", szDest );
        }
    else if ( hr == S_FALSE )
        {
        m_pQMInfo->result = QM_FILE_ABORTED;
        LogDl( "File %!ts! aborted", szDest );
        }
    else if ( m_pQMInfo->result != QM_SERVER_FILE_CHANGED )
        {
        ASSERT( IsErrorSet() );

        if (NeedRetry(m_pQMInfo))
            {
            m_pQMInfo->result = QM_FILE_TRANSIENT_ERROR;
            }
        else
            {
            m_pQMInfo->result = QM_FILE_FATAL_ERROR;
            }
        }

    ASSERT( m_pQMInfo->result != QM_IN_PROGRESS );

    LogDl( "---------------------------------------------------------------------" );

    // if abort request came in after file failed, overwrite failed flag.
    if ( (QM_FILE_DONE != m_pQMInfo->result) && IsAbortRequested() )
    {
        m_pQMInfo->result = QM_FILE_ABORTED;
    }

    ASSERT( m_hFile == INVALID_HANDLE_VALUE );

    return hr;
}


HRESULT
CProgressiveDL::DownloadFile(
    HANDLE  hToken,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    LPCTSTR Url,
    LPCWSTR Path,
    UINT64  Offset,
    StringHandle HostId
    )
{
    HRESULT hr = S_OK;

    ASSERT( m_wupdinfo == NULL );
    ASSERT( m_hOpenRequest == NULL );

    m_pQMInfo->Clear();

    try
        {
        THROW_HRESULT( CheckLanManHashDisabled() );

        CNestedImpersonation imp( hToken );

        //
        // Open a connection to the server, and use that data for our first estimate of the line speed.
        //
        m_wupdinfo = ConnectToUrl( Url, ProxySettings, Credentials, (const TCHAR*)HostId, m_pQMInfo );
        if (!m_wupdinfo)
            {
            ASSERT( IsErrorSet() );
            throw ComError( E_FAIL );
            }


        //
        // Get file size and time stamp.
        //
        if (! GetRemoteResourceInformation( m_wupdinfo, m_pQMInfo ))
            {
            ASSERT( IsErrorSet() );
            throw ComError( E_FAIL );
            }

        FILETIME FileTime = UINT64ToFILETIME( 0 );
        if (!OpenLocalDownloadFile(Path, Offset, m_wupdinfo->FileSize, m_wupdinfo->UrlModificationTime, &FileTime))
            {
            ASSERT( IsErrorSet() );
            throw ComError( E_FAIL );
            }

        if (m_wupdinfo->UrlModificationTime == UINT64ToFILETIME( 0 ))
            {
            ASSERT( FileTime != UINT64ToFILETIME( 0 ));
            m_wupdinfo->UrlModificationTime = FileTime;
            }

        // Be sure to check for an end of file before attempting
        // to download more bytes.
        if (IsFileComplete())
           {
            LogDl( "File is done already.\n" );

           if (!SetFileTimes())
              {
              ASSERT( IsErrorSet() );
              hr = E_FAIL;
              }

            hr = S_OK;
            }
        //
        // Transfer data from the server.
        //
        else if ( !m_bThrottle )
            {
            hr = DownloadForegroundFile();
            }
        else
            {
            if (IsAbortRequested())
                {
                throw ComError( S_FALSE );
                }

            //
            // Use either the server's host name or the proxy's host name to find the right network adapter..
            //
            hr = m_Network.SetInterfaceIndex( m_wupdinfo->fProxy ? m_wupdinfo->ProxyHost.get() : m_wupdinfo->HostName );
            if (FAILED(hr))
                {
                SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "GetInterfaceIndex" );
                throw ComError( E_FAIL );
                }

            while (1)
               {
               hr = GetNextBlock();

               if ( S_FALSE == hr )
                   break;

               if (FAILED(hr) )
                   {
                   ASSERT( hr == E_RETRY || IsErrorSet() );
                   break;
                   }

               if (IsFileComplete())
                   {
                   if (!SetFileTimes())
                       {
                       ASSERT( IsErrorSet() );
                       hr = E_FAIL;
                       break;
                       }

                   hr = S_OK;
                   break;
                   }
               }
            }
        }
    catch( ComError exception )
        {
        hr = exception.Error();
        ASSERT( IsErrorSet() || (hr == S_FALSE) );
        }

    if ( m_bThrottle )
       {
       m_Network.StopTimer();
       }

    CloseLocalFile();

    delete m_wupdinfo; m_wupdinfo = NULL;

    SafeCloseInternetHandle( m_hOpenRequest );

    if (FAILED(hr))
        {
        ASSERT( hr == E_RETRY || IsErrorSet() );
        }

    return hr;
}

HRESULT
CProgressiveDL::DownloadForegroundFile()
{
    HRESULT hr = E_FAIL;
    LogDl( "Starting foreground file download" );

    while( 1 )
        {

        //
        // Loop of HTTP requests.  This is to work around a wininet/winhttp limitation
        // where request sizes can be a maximum of 4GB.
        //

        UINT64 BlockSize64  = m_wupdinfo->FileSize - m_CurrentOffset;
        DWORD BlockSize     = (DWORD)min( BlockSize64, 2147483648 );
        LogDl( "Starting foreground file download request block: file size %d, offset %d, block %d",
               DWORD( m_wupdinfo->FileSize ), DWORD(m_CurrentOffset), BlockSize );

        //
        // Send a block request and read the reply headers.
        //
        hr = StartRangeRequest( BlockSize );
        if (FAILED(hr))
            {
            ASSERT( IsErrorSet() );
            return hr;
            }

        const DWORD MIN_FOREGROUND_BLOCK = 4096;
        const DWORD MAX_FOREGROUND_BLOCK = FILE_DATA_BUFFER_LEN;
        const DWORD FOREGROUND_BLOCK_INCREMENT = 1024;
        const DWORD FOREGROUND_UPDATE_RATE = 2000;

        DWORD ForegroundBlockSize = min( MIN_FOREGROUND_BLOCK, BlockSize );
        DWORD dwPrevTick = GetTickCount();

        while( 1 )
            {

            //
            //  Loop of read blocks inside an individual request.
            //

            if (IsAbortRequested())
                {
                return S_FALSE;
                }

            if ( IsFileComplete() )
                {
                LogDl( "File is done, exiting.\n" );

                if (!SetFileTimes())
                    {
                    ASSERT( IsErrorSet() );
                    return E_FAIL;
                    }
                return S_OK;
                }

            BYTE *p = g_FileDataBuffer;
            DWORD dwTotalBytesRead = 0;
            DWORD dwBytesToRead = ForegroundBlockSize;
            DWORD dwRead;

            while( 1 )
                {

                if (! InternetReadFile(m_hOpenRequest, p, dwBytesToRead, &dwRead) )
                    {
                    SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "InternetReadFile" );

                    LogWarning( "InternetReadFile failed: len=%d, offset=%I64d, err=%d",
                                ForegroundBlockSize, m_CurrentOffset, GetLastError());
                    return E_FAIL;
                    }

                if ( !dwRead )
                   break;

                dwTotalBytesRead += dwRead;
                dwBytesToRead -= dwRead;
                p += dwRead;

                if ( !dwBytesToRead )
                   break;

                if (m_Callbacks->PollAbort())
                    {
                    LogInfo("time slice has run out");
                    return S_FALSE;
                    }
                }

            if (!WriteBlockToCache( (LPBYTE) g_FileDataBuffer, dwTotalBytesRead ))
                {
                ASSERT( IsErrorSet() );
                return hr;
                }

            if (dwTotalBytesRead != ForegroundBlockSize &&
                m_CurrentOffset != m_wupdinfo->FileSize)
                {
                LogError("Download block : EOF after %d", dwRead );
                SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, ERROR_INTERNET_CONNECTION_RESET, "DownloadBlock" );
                return E_FAIL;
                }

            if (m_Callbacks->DownloaderProgress( m_CurrentOffset, m_wupdinfo->FileSize ))
                {
                // abort was requested
                return S_FALSE;
                }

            DWORD dwNewTick = GetTickCount();
            DWORD dwTimeDelta = dwNewTick - dwPrevTick;

            if ( dwTimeDelta < FOREGROUND_UPDATE_RATE )
                ForegroundBlockSize = min( ForegroundBlockSize + FOREGROUND_BLOCK_INCREMENT, MAX_FOREGROUND_BLOCK );
            else if ( dwTimeDelta > FOREGROUND_UPDATE_RATE )
                ForegroundBlockSize = max( ForegroundBlockSize - FOREGROUND_BLOCK_INCREMENT, MIN_FOREGROUND_BLOCK );

            ForegroundBlockSize = min( ForegroundBlockSize, ( m_wupdinfo->FileSize - m_CurrentOffset ) );
            dwPrevTick = dwNewTick;

            //
            // End loop of read blocks
            //
            }

        //
        // End loop of requests
        //
        }
}

HRESULT
CProgressiveDL::GetNextBlock()
{
    HRESULT hr = E_FAIL;

    LogDl( "file size %d, offset %d", DWORD(m_wupdinfo->FileSize), DWORD(m_CurrentOffset) );

    m_Network.CalculateIntervalAndBlockSize( min( m_wupdinfo->FileSize - m_CurrentOffset, MAX_IIS_SEND_SIZE) );

    DWORD BlockSize = m_Network.m_BlockSize;

    if (BlockSize == 0)
        {
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_START );
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_END );
        }
    else
        {
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_START );

        //
        // Request a block from the server.
        //
        hr = StartRangeRequest( BlockSize );
        if (FAILED(hr))
            {
            ASSERT( IsErrorSet() );
            return hr;
            }

        //
        // A single call to InternetReadFile may return only part of the requested data,
        // so loop until the entire block has arrived.
        //
        DWORD dwBytesRead = 0;
        while (dwBytesRead < BlockSize )
            {
            DWORD dwSize = min( (BlockSize - dwBytesRead) , FILE_DATA_BUFFER_LEN );
            DWORD dwRead = 0;

            if (! InternetReadFile( m_hOpenRequest,
                                    g_FileDataBuffer,
                                    dwSize,
                                    &dwRead ))
                {
                SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "InternetReadFile" );

                LogWarning( "InternetReadFile failed: len=%d, offset=%I64d, err=%d",
                            dwSize, m_CurrentOffset, GetLastError());

                return E_FAIL;
                }
            else if (dwRead == 0)
                {
                break;
                }

            dwBytesRead += dwRead;

            //
            // Save the data.
            //
            if (!WriteBlockToCache( (LPBYTE) g_FileDataBuffer, dwRead ))
                {
                ASSERT( IsErrorSet() );
                return hr;
                }

            if (m_Callbacks->PollAbort())
                {
                LogInfo("an abort was requested before the whole block was read.");
                return S_FALSE;
                }
            }

        if (dwBytesRead != BlockSize)
            {
            LogError("Download block : EOF after %d", dwBytesRead );

            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, ERROR_INTERNET_CONNECTION_RESET, "DownloadBlock" );

            return E_FAIL;
            }

        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_END );

        if (m_Callbacks->DownloaderProgress( m_CurrentOffset, m_wupdinfo->FileSize ))
            {
            LogInfo("an abort was requested during the progress update.");
            // abort was requested
            return S_FALSE;
            }
        }

    //
    // Allow other apps to use the network for the rest of the time interval,
    // then take the end-of-interval snapshot.
    //
    m_Network.Wait();

    hr = m_Network.TakeSnapshot( CNetworkInterface::BLOCK_INTERVAL_END );
    if (SUCCEEDED(hr))
        {
        m_Network.SetInterfaceSpeed();
        }
    else if (hr == HRESULT_FROM_WIN32( ERROR_INVALID_DATA ))
        {
        //
        // If the snapshot fails with ERROR_INVALID_DATA and the downloads
        // keep working, then our NIC has been removed and the networking
        // layer has silently transferred our connection to another available
        // NIC.  We need to identify the NIC that we are now using.
        //
        LogWarning("NIC is no longer valid.  Requesting retry.");
        hr = E_RETRY;
        }
    else
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "TakeSnapshot" );

    return hr;
}

URL_INFO::URL_INFO(
    LPCTSTR Url,
    const PROXY_SETTINGS * a_ProxySettings,
    const CCredentialsContainer * a_Credentials,
    LPCTSTR HostId
    ) :
    hInternet( 0 ),
    hConnect( 0 ),
    FileSize( 0 ),
    dwFlags( 0 ),
    bHttp11( true ),
    ProxySettings( 0 ),
    fProxy( false ),
    Credentials( a_Credentials )
{
    try
        {
        LogInfo("new URL_INFO at %p", this );

        //
        // Split the URL into server, path, name, and password components.
        //
        URL_COMPONENTS  UrlComponents;

        ZeroMemory(&UrlComponents, sizeof(UrlComponents));

        UrlComponents.dwStructSize        = sizeof(UrlComponents);
        UrlComponents.lpszHostName        = HostName;
        UrlComponents.dwHostNameLength    = RTL_NUMBER_OF(HostName);
        UrlComponents.lpszUrlPath         = UrlPath;
        UrlComponents.dwUrlPathLength     = RTL_NUMBER_OF(UrlPath);
        UrlComponents.lpszUserName        = UserName;
        UrlComponents.dwUserNameLength    = RTL_NUMBER_OF(UserName);
        UrlComponents.lpszPassword        = Password;
        UrlComponents.dwPasswordLength    = RTL_NUMBER_OF(Password);

        if (! InternetCrackUrl(Url, 0, 0, &UrlComponents))
            {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {
                THROW_HRESULT( HRESULT_FROM_WIN32( ERROR_WINHTTP_INVALID_URL ));
                }
            ThrowLastError();
            }

        if (-1 == UrlComponents.dwHostNameLength ||
            -1 == UrlComponents.dwUrlPathLength ||
            -1 == UrlComponents.dwUserNameLength ||
            -1 == UrlComponents.dwPasswordLength)
            {
            THROW_HRESULT( HRESULT_FROM_WIN32( ERROR_WINHTTP_INVALID_URL ));
            }

        Port = UrlComponents.nPort;

        if (0 == _tcslen(HostName))
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        if ( HostId && *HostId )
            {
            // redirected to another host.

            THROW_HRESULT( StringCbCopy( HostName, sizeof(HostName), HostId ));

            LogDl( "Stuck to %!ts!...", UrlComponents.lpszHostName );
            }

        //
        // Set the connect flags.
        //
        dwFlags = WINHTTP_FLAG_ESCAPE_DISABLE_QUERY;

        if(UrlComponents.nScheme == INTERNET_SCHEME_HTTPS)
            {
            dwFlags |= WINHTTP_FLAG_SECURE;
            }

        ProxySettings = new PROXY_SETTINGS_CONTAINER( Url, a_ProxySettings );
        }
    catch ( ComError err )
        {
        Cleanup();
        throw;
        }
}

//
// Splitting the explicit cleanup into a separate function allows the constructor to re-use the code.
// The constructor *cannot* explicitly call the destructor if it is going to throw an exception,
// because the destructor will call the StringHandle member destructors and then the constructor
// will call them again (because it is throwing an exception and cleans up the already-constructed
// members).
//
URL_INFO::~URL_INFO()
{
    Cleanup();
}

void URL_INFO::Cleanup()
{
    LogInfo("deleting URL_INFO at %p", this );

    Disconnect();

    SecureZeroMemory( UserName, sizeof(UserName) );
    SecureZeroMemory( Password, sizeof(Password) );

    delete ProxySettings; ProxySettings = NULL;
}

void
URL_INFO::Disconnect()
{
    SafeCloseInternetHandle( hConnect );
    SafeCloseInternetHandle( hInternet );
}

QMErrInfo
URL_INFO::Connect()
{
    try
        {
        //
        // The proxy stuff is ignored because we will set an explicit proxy on each request.
        //
        hInternet = WinHttpOpen( C_BITS_USER_AGENT,
                                  WINHTTP_ACCESS_TYPE_NO_PROXY,
                                  NULL,
                                  NULL,
                                  0 );

        if (! hInternet )
            {
            ThrowLastError();
            }

        //
        // Enable passport authentication, which will only work if the user provides
        // explicit passport credentials.
        //
        // We have to enable the passport support here and not "as needed" right before
        // we apply the credentials because winhttp needs to know this before we send our first request.
        // If the site if passport enabled, the server will return 302 Object Moved,
        // which will be handled appropriately by winhttp only if this flag is set.
        // If everything goes fine, winhttp will hide the 302 from us and we will see in fact
        // a 401 respond -- to which we will approprietely respond with passport credentials.
        // In the case where we are not given explicit credentials, we will fail and we will
        // propagate the access denied error.
        //
        EnablePassport( hInternet );

        if (! (hConnect = WinHttpConnect( hInternet,
                                          HostName,
                                          Port,
                                          0)))                //context
            {
            ThrowLastError();
            }

        QMErrInfo Success;

        return Success;
        }
    catch ( ComError err )
        {
        LogError( "error %x connecting to server", err.Error() );

        QMErrInfo QmError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, err.Error() );

        return QmError;
        }
}

void
EnablePassport(
    HINTERNET hInternet
    )
{
    DWORD dwPassportFlags = WINHTTP_ENABLE_PASSPORT_AUTH | WINHTTP_DISABLE_PASSPORT_KEYRING;

    //
    // Enable Passport authentication scheme and
    // make sure we will NOT support the keyring scenario.
    // With disable keyring flag, implicit credentials will not be accepted and
    // the client application will need to specify explicit passport
    // credentials in order to be authorized.
    //
    if (!WinHttpSetOption( hInternet,
                           WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH,
                           &dwPassportFlags,
                           sizeof(DWORD)
                           ))
        {
        LogError("Couldn't set passport flags");
        ThrowLastError();
        }
}

URL_INFO *
ConnectToUrl(
    LPCTSTR                Url,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    const TCHAR *          HostId,
    QMErrInfo * pErrInfo
    )
{
    //
    // Open a connection to the server.
    //
    LogDl( "Connecting to %!ts!...", Url);

    //
    // This should have been checked by the caller.
    //
    ASSERT( HostId == NULL || wcslen(HostId) < INTERNET_MAX_HOST_NAME_LENGTH );

    try
        {
        URL_INFO * Info = new URL_INFO( Url, ProxySettings, Credentials, HostId );

        *pErrInfo =  Info->Connect();

        if (pErrInfo->IsSet())
            {
            delete Info;
            return NULL;
            }

        return Info;
        }
    catch ( ComError err )
        {
        pErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, err.Error(), "untracked API" );
        return NULL;
        }
}


BOOL
CProgressiveDL::GetRemoteResourceInformation(
    URL_INFO * Info,
    QMErrInfo *pQMErrInfo
    )
/*

    We begin with an HTTP 1.1 HEAD request.
    If the server replies with version 1.1, we have a persistent connection and the proxy, if present, can cache our requests.
    If the server replies with version 1.0, we do not have either characteristic.  Our GET requests will add "Connection: keep-alive"
    but it may not do any good.  The proxy server, if present, may not understand ranges and if we allow caching then it will
    cache a range request as if it were the entire file.
    If the server replies with any other version or the call fails, then we should bail with BG_E_INSUFFICIENT_SERVER_SUPPORT.
    If an error occurs, we report it and bail.

*/
{
    HRESULT FailureCode = 0;
    unsigned FailureLine = 0;

#define CHECK_HRESULT( x )   \
    { \
    HRESULT _hr_ = x;  \
    if (FAILED(_hr_))  \
        {  \
        FailureCode = _hr_; \
        FailureLine = __LINE__; \
        goto exit;  \
        }   \
    }

#define CHECK_BOOL( x )  \
    { \
    if (! x )  \
        {  \
        FailureCode = HRESULT_FROM_WIN32( GetLastError() ); \
        FailureLine = __LINE__; \
        goto exit;  \
        }   \
    }

    // Assume HTTP1.1 with no proxy until we determine otherwise.
    //
    Info->bHttp11 = TRUE;
    Info->bRange = TRUE;
    Info->fProxy = FALSE;

    BOOL b = FALSE;
    HRESULT hr;
    HINTERNET hRequest = NULL;
    DWORD dwErr, dwLength = 0, dwStatus = 0, dwState = 0;



    CHECK_HRESULT( OpenHttpRequest( _T("HEAD"), _T("HTTP/1.1"), *Info, &hRequest ) );

    CHECK_HRESULT( SendRequest( hRequest, Info ));

    // check status
    dwLength = sizeof(dwStatus);

    CHECK_BOOL( HttpQueryInfo( hRequest,
                         HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                         (LPVOID)&dwStatus,
                         &dwLength,
                         NULL));

    if (dwStatus != HTTP_STATUS_OK)
        {
        pQMErrInfo->Set( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
        goto exit;
        }

    //
    // We know that the server replied with a success code.  Now determine the HTTP version.
    //
    unsigned MajorVersion;
    unsigned MinorVersion;

    CHECK_HRESULT( GetResponseVersion( hRequest, &MajorVersion, &MinorVersion ));

    if (MajorVersion != 1)
        {
        LogWarning("server version %d.%d is outside our supported range", MajorVersion, MinorVersion );
        pQMErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_HTTP_SUPPORT );
        goto exit;
        }

    if (MinorVersion < 1)
        {
        Info->bHttp11   = FALSE;
        Info->dwFlags |= WINHTTP_FLAG_REFRESH;
        }

    //
    // Now determine the proxy server.
    //
    CHECK_BOOL( Info->GetProxyUsage( hRequest, pQMErrInfo ));

    // check file size
    WCHAR FileSizeText[ INT64_DIGITS+1 ];
    dwLength = sizeof( FileSizeText );

    CHECK_BOOL( HttpQueryInfo( hRequest,
                               HTTP_QUERY_CONTENT_LENGTH,
                               FileSizeText,
                               &dwLength,
                               NULL));

    if ( 1 != swscanf( FileSizeText, L"%I64u", &Info->FileSize ) )
        {
        pQMErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_MISSING_FILE_SIZE, "swscanf: content length" );
        goto exit;
        }

    LogDl( "File size of %!ts! = %I64u", Info->UrlPath, Info->FileSize);

    // check file time
    //
    SYSTEMTIME sysTime;
    dwLength = sizeof(sysTime);
    if (HttpQueryInfo( hRequest,
                         HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME,
                         (LPVOID)&sysTime,
                         &dwLength,
                         NULL))
        {
        CHECK_BOOL( SystemTimeToFileTime(&sysTime, &Info->UrlModificationTime ));
        }
    else
        {
        //
        // If the header is invalid, fail.
        //
        DWORD s = GetLastError();
        if (s != ERROR_WINHTTP_HEADER_NOT_FOUND)
            {
            FailureCode = HRESULT_FROM_WIN32(s); FailureLine = __LINE__; goto exit;
            }

        // The header is missing; allow it and set set modification time to zero.
        //
        LogWarning("server did not provide a Last-Modified header");
        Info->UrlModificationTime = UINT64ToFILETIME( 0 );
        }

    b = TRUE;

exit:

    if (FailureCode)
        {
        //
        // If a header is missing or invalid, map it to something more understandable.
        //
        if (FailureCode == HRESULT_FROM_WIN32( ERROR_WINHTTP_INVALID_QUERY_REQUEST) ||
            FailureCode == HRESULT_FROM_WIN32( ERROR_WINHTTP_HEADER_NOT_FOUND) ||
            FailureCode == HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER) ||
            FailureCode == HRESULT_FROM_WIN32( ERROR_INTERNET_INTERNAL_ERROR) ||
            FailureCode == HRESULT_FROM_WIN32( ERROR_WINHTTP_INVALID_SERVER_RESPONSE) ||
            FailureCode == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER))
            {
            FailureCode = BG_E_INVALID_SERVER_RESPONSE;
            }

        LogError("failure at line %d; hresult = %x", FailureLine, FailureCode );
        pQMErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, FailureCode );
        }

    // release allocated objects
    //
    SafeCloseInternetHandle( hRequest );

    return b;

#undef CHECK_HRESULT
#undef CHECK_BOOL
}

BOOL
URL_INFO::GetProxyUsage(
    HINTERNET hRequest,
    QMErrInfo *ErrInfo
    )
/*

    This function determines whether the completed request in <hRequest> used a proxy server,
    and if so which one.  In BITS 1.0 (Windows XP), it looked in the HTTP 1.1 Via header, but
    that header isn't present in HTTP 1.0 replies, and a server is allowed to return a fake host name.
    (see RFC 2616 section 14.45 for details.)

    The current version parses the current proxy value in this->ProxySettings, which was calculated
    by the HTTP layer.  The format of a proxy-server entry is as follows:

                ([<scheme>=][<scheme>"://"]<server>[":"<port>])

    this->ProxyHost should include only the server name.

On exit:

    if TRUE, fProxy and ProxyHost are set.
    if FALSE, fProxy and ProxyHost are unchanged and ErrInfo is set.

*/
{
    try
        {
        LPCWSTR p = ProxySettings->GetCurrentProxy();

        if (!p)
            {
            fProxy = FALSE;
            return TRUE;
            }

        LPCWSTR p2;

        //
        // Skip past the [<scheme>=] segment.
        //
        p2 = wcschr( p, '=' );
        if (p2)
            {
            ++p2;
            p = p2;
            }

        //
        // Skip past the [<scheme>"://"] segment.
        //
        p2 = wcschr( p, '/' );
        if (p2)
            {
            ++p2;
            if (*p2 == '/')
                {
                ++p2;
                }

            p = p2;
            }

        //
        // p now points to the beginning of the server name.  Copy it.
        //

        ProxyHost = CAutoString( CopyString( p ));

        //
        // Find the [":"<port>] segment.
        //
        LPWSTR pColon = wcschr( ProxyHost.get(), ':' );
        if (pColon)
            {
            *pColon = '\0';
            }

        fProxy = TRUE;
        return TRUE;
        }
    catch ( ComError err )
        {
        ErrInfo->Set( SOURCE_HTTP_UNKNOWN, ERROR_STYLE_HRESULT, err.Error() );
        return FALSE;
        }
}

HRESULT
CProgressiveDL::StartRangeRequest(
    DWORD   Length
    )
{
    HRESULT hr;
    DWORD  dwBegin, dwEnd, dwTotalRead = 0, dwRead = 0, dwErr, dwLength, dwStatus;

    UINT64 Offset = m_CurrentOffset;

    //todo cleanup by goto exit and close handles

    if ( !m_hOpenRequest )
        {
        HINTERNET hRequest;

        hr = OpenHttpRequest( NULL,             // default is "GET"
                              m_wupdinfo->bHttp11 ? _T("HTTP/1.1") : _T("HTTP/1.0"),
                              *m_wupdinfo,
                              &hRequest
                              );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "CreateHttpRequest");
            return E_FAIL;
            }

        m_hOpenRequest = hRequest;

        //
        // These headers are constant for a particular file download attempt.
        //
        hr = AddIf_Unmodified_SinceHeader( m_hOpenRequest, m_wupdinfo->UrlModificationTime );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr );
            LogError( "unable to add If-Unmodified-Since header: %x", hr);
            return E_FAIL;
            }

        if (! HttpAddRequestHeaders(m_hOpenRequest, ACCEPT_ENCODING_STRING, -1L, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "add header: accept-encoding" );
            return E_FAIL;
            }
        }

    hr = AddRangeHeader( m_hOpenRequest, Offset, Offset + Length - 1 );
    if (FAILED(hr))
        {
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "AddRangeHeader" );
        return E_FAIL;
        }

    hr = SendRequest( m_hOpenRequest, m_wupdinfo );
    if (FAILED(hr))
        {
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "HttpSendRequest" );
        LogError( "HttpSendRequest failed in progressive download loop - offset=%I64d",
                   m_CurrentOffset );
        return E_FAIL;
        }

    //
    // The server sent a reply.  See if it was successful.
    //
    dwLength = sizeof(dwStatus);
    if (! HttpQueryInfo(m_hOpenRequest,
                HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                (LPVOID)&dwStatus,
                &dwLength,
                NULL))
        {
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "HttpQueryInfo" );
        return E_FAIL;
        }

    //
    // If the server file changed, stop downloading and indicate that to the caller.
    //
    if ( HTTP_STATUS_PRECOND_FAILED == dwStatus )
        {
        SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
        m_pQMInfo->result = QM_SERVER_FILE_CHANGED;
        return E_FAIL;
        }

    //
    // If the server sent an error, fail.
    //
    if ( dwStatus != HTTP_STATUS_PARTIAL_CONTENT &&
         dwStatus != HTTP_STATUS_OK)
        {
        SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
        return E_FAIL;
        }

    if (dwStatus == HTTP_STATUS_PARTIAL_CONTENT)
        {
        //
        // Now see whether the server understood the range request.
        // If it understands ranges, then it should have responded with a Content-Range header
        // matching our request.
        //
        hr = CheckReplyRange( m_hOpenRequest,
                              m_CurrentOffset,
                              m_CurrentOffset + Length - 1,
                              m_wupdinfo->FileSize
                              );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "Reply range" );
            return hr;
            }

        //
        // If the server appears not to support ranges, give up.
        //
        if (S_FALSE == hr)
            {
            m_wupdinfo->Disconnect();
            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_RANGE_SUPPORT );
            return BG_E_INSUFFICIENT_RANGE_SUPPORT;
            }
        }
    else
        {
        //
        // The server replied with status 200.  This could mean that the server doesn't understand
        // range requests, or that the request encompassed the entire file.
        // (In this situation, IIS 5.0 and 6.0 return 206, but some Apache versions return 200.)
        // To distinguish them, make sure the starting offset of the request was zero and the
        // file length is equal to the original request length.
        //
        hr = CheckReplyLength( m_hOpenRequest, m_CurrentOffset, Length );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "content length" );
            return hr;
            }

        //
        // If the server did not include a Content-Length header, give up.
        //
        if (S_FALSE == hr)
            {
            m_wupdinfo->Disconnect();
            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_RANGE_SUPPORT );
            return BG_E_INSUFFICIENT_RANGE_SUPPORT;
            }
        }


    //
    // Here is the code to switch to encoded range format, in case we need it later.
    //
    //    if (S_FALSE == hr)
    //        {
    //        LogDl( "server does not support ranges." );
    //
    //        m_wupdinfo->bHttp11 = FALSE;
    //        m_wupdinfo->bRange = FALSE;
    //
    //        //
    //        // We can't just drain the rest of the server response and send again, because the server
    //        // response is very likely the entire file.  Closing the connection will prevent the server
    //        // from writing, at max, any more than the client socket buffer size (16K).
    //        //
    //        m_wupdinfo->Disconnect();
    //
    //        *m_pQMInfo = m_wupdinfo->Connect();
    //        if (m_pQMInfo->IsSet())
    //            {
    //            return E_FAIL;
    //            }
    //
    //        HRESULT HrReadUrl = StartEncodedRangeRequest( Length );
    //
    //        if ( BG_E_INSUFFICIENT_HTTP_SUPPORT == HrReadUrl )
    //            {
    //            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_RANGE_SUPPORT );
    //            return BG_E_INSUFFICIENT_RANGE_SUPPORT;
    //            }
    //
    //        return HrReadUrl;
    //        }

    //
    // Getting here means the range request succeeded.
    //

    return S_OK;
}

bool
CProgressiveDL::DoesErrorIndicateNoISAPI(
    DWORD dwHttpError
    )
{
    // This function is used on the HTTP return code on an attept
    // to use the isapi dll to estimate if the isapi is installed.
    // Note, that the ISAPI should only be used after trying
    // native HTTP/1.1 and this table assume 1.1 was tried first.

    // From RFC 2616

    switch( dwHttpError )
        {
        case 100: return false; // Continue
        case 101: return false; // Switching Protocols
        case 200: return false; // OK
        case 201: return false; // Created
        case 202: return false; // Accepted
        case 203: return false; // Non-Authoritative
        case 204: return false; // No Content
        case 205: return false; // Reset Context
        case 206: return false; // Partial Content
        case 300: return false; // Multiple Choices
        case 301: return false; // Moved Permanently
        case 302: return false; // Found
        case 303: return false; // See other
        case 304: return false; // Not Modified
        case 305: return false; // Use Proxy
        case 306: return false; // Unused
        case 307: return false; // Temporary Redirect
        case 400: return true;  // Bad Request
        case 401: return false; // Unauthorized
        case 402: return false; // Payment Required
        case 403: return false; // Forbidden
        case 404: return true;  // Not Found
        case 405: return false; // Method Not Allowed
        case 406: return false; // Not Acceptable
        case 407: return false; // Proxy Authentication Required
        case 408: return false; // Request Timeout
        case 409: return false; // Conflict
        case 410: return true;  // Gone
        case 411: return false; // Length Required
        case 412: return false; // Precondition Failed
        case 413: return false; // Request Entity Too Large
        case 414: return false; // Request URI too long
        case 415: return false; // Unsupported Media Type
        case 416: return false; // Requested Range Not Satisfiable
        case 417: return false; // Expectation Failed
        case 500: return true;  // Internal Server Error
        case 501: return true;  // Not Implemented
        case 502: return true;  // Bad Gateway
        case 503: return false; // Service Unavailable
        case 504: return false; // Gateway Timeout
        case 505: return false; // HTTP Version Not Supported

        default:
            // As indicated in the spec, map unknown codes
            // to first code in the catagory
            if ( dwHttpError >= 100 && dwHttpError < 200 )
                return DoesErrorIndicateNoISAPI( 100 );
            else if ( dwHttpError >= 200 && dwHttpError < 300 )
                return DoesErrorIndicateNoISAPI( 200 );
            else if ( dwHttpError >= 300 && dwHttpError < 400 )
                return DoesErrorIndicateNoISAPI( 300 );
            else if ( dwHttpError >= 400 && dwHttpError < 500 )
                return DoesErrorIndicateNoISAPI( 400 );
            else if ( dwHttpError >= 500 && dwHttpError < 500 )
                return DoesErrorIndicateNoISAPI( 500 );
            else
                // No clue what the error is, assume this has nothing to do with the ISAPI
                return false;
        }

}

BOOL
NeedRetry(
    QMErrInfo  * ErrInfo
    )

{
    BOOL bRetry = FALSE;

    if (ErrInfo->Source == SOURCE_HTTP_SERVER)
        {
        // Almost all of the 400 series HTTP errors( client errors ) are
        // fatal. A few such as request timeout may happen during
        // stress conditions...
        // Note that RFC 2616 says to handle unknown 400 errors as error 400.

        if ( ( ErrInfo->Code >= 400 ) &&
             ( ErrInfo->Code < 500 ) )
            {

            switch( ErrInfo->Code )
                {
                case 408: // request timeout
                case 409: // Conflict - Isn't really clear what this is about...
                    return TRUE;  // retry these error
                default:
                   return FALSE; // don't retry other 400

                }
            }
        }


    if ( ErrInfo->Style == ERROR_STYLE_HRESULT )
        {

        switch( LONG(ErrInfo->Code) )
            {
            // These codes indicate dynamic content or
            // an unsupported server so no retries are necessary.
            case BG_E_INVALID_SERVER_RESPONSE:
            case BG_E_MISSING_FILE_SIZE:
            case BG_E_INSUFFICIENT_HTTP_SUPPORT:
            case BG_E_INSUFFICIENT_RANGE_SUPPORT:
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_ERRORS ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_INVALID_CA ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_CN_INVALID ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_DATE_INVALID ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_REV_FAILED ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_REVOKED ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_NO_REV ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_INVALID_CERT ):

            return FALSE;
            }

        }

    if (COMPONENT_TRANS == (ErrInfo->Source & COMPONENT_MASK))
        {
        return TRUE;
        }

    switch (ErrInfo->Style)
        {
        case ERROR_STYLE_WIN32:
            {
            switch (ErrInfo->Code)
                {
                case ERROR_NOT_ENOUGH_MEMORY:
                    return TRUE;
                }
            }
        }

    return FALSE;
}

HRESULT
CProgressiveDL::GetRemoteFileInformation(
    HANDLE hToken,
    LPCTSTR szURL,
    UINT64 *  pFileSize,
    FILETIME *pFileTime,
    QMErrInfo *pErrInfo,
    const PROXY_SETTINGS * pProxySettings,
    const CCredentialsContainer * Credentials,
    StringHandle HostId
    )
{
    *pFileSize = 0;
    memset( pFileTime, 0, sizeof(FILETIME) );
    pErrInfo->result = QM_IN_PROGRESS;

    HRESULT Hr = S_OK;

    try
        {
        CNestedImpersonation imp( hToken );

        auto_ptr<URL_INFO> UrlInfo = auto_ptr<URL_INFO>( ConnectToUrl( szURL, pProxySettings, Credentials, (const WCHAR*)HostId, pErrInfo ));

        if (!UrlInfo.get())
            {
            ASSERT( pErrInfo->IsSet() );
            throw ComError( E_FAIL );
            }

        //
        // Get file size and time stamp.
        //
        if (! GetRemoteResourceInformation( UrlInfo.get(), pErrInfo ))
            {
            ASSERT( pErrInfo->IsSet() );
            throw ComError( E_FAIL );
            }

        *pFileTime = UrlInfo.get()->UrlModificationTime;
        *pFileSize = UrlInfo.get()->FileSize;

        pErrInfo->result = QM_FILE_DONE;
        return S_OK;
        }
    catch( ComError Error )
        {
        Hr = Error.Error();

        if (!pErrInfo->IsSet())
            {
            pErrInfo->Set( SOURCE_HTTP_UNKNOWN, ERROR_STYLE_HRESULT, Hr );
            }

        if (NeedRetry(pErrInfo))
            {
            pErrInfo->result = QM_FILE_TRANSIENT_ERROR;
            }
        else
            {
            pErrInfo->result = QM_FILE_FATAL_ERROR;
            }
        return E_FAIL;
        }

    return Hr;
}


void
CProgressiveDL::SetError(
    ERROR_SOURCE  Source,
    ERROR_STYLE   Style,
    UINT64        Code,
    char *        comment
    )
{
    m_pQMInfo->Set( Source, Style, Code, comment );
}

void QMErrInfo::Log()
{
    LogDl( "errinfo: result=%d, error style=%d, code=0x%x, source=%x, description='%S'",
             result, (DWORD) Style, (DWORD) Code, (DWORD) Source, Description ? Description : L"" );
}

QMErrInfo::QMErrInfo(
    ERROR_SOURCE  Source,
    ERROR_STYLE   Style,
    UINT64        Code,
    char *        comment
    )
{
    result = QM_FILE_TRANSIENT_ERROR;
    Description = NULL;

    Set( Source, Style, Code, comment );
}

void
QMErrInfo::Set(
    ERROR_SOURCE  Source,
    ERROR_STYLE   Style,
    UINT64        Code,
    char *        comment
    )
{
    this->Source   = Source;
    this->Style    = Style;
    this->Code     = Code;

    LogWarning( " errinfo: error %s %s : style %d, source %x, code 0x%x",
                comment ? "in" : "",
                comment ? comment : "",
                (DWORD) Style,
                (DWORD) Source,
                (DWORD) Code
                );
}

HRESULT
OpenHttpRequest(
    LPCTSTR Verb,
    LPCTSTR Protocol,
    URL_INFO & Info,
    HINTERNET * phRequest
    )
{
    HINTERNET hRequest = 0;

    *phRequest = 0;

    try
        {
        LPCTSTR AcceptTypes[] = {_T("*/*"), NULL};

        if (! (hRequest = WinHttpOpenRequest( Info.hConnect, Verb,
                                           Info.UrlPath,
                                           Protocol,
                                           NULL,               //referer
                                           AcceptTypes,
                                           Info.dwFlags
                                           )))
            {
            ThrowLastError();
            }

        //
        // Initially disallow default credentials, to allow explicit credentials to take precedence.
        //
        DWORD flag = WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH;

        if (!WinHttpSetOption( hRequest,
                               WINHTTP_OPTION_AUTOLOGON_POLICY,
                               &flag,
                               sizeof(DWORD)
                               ))
            {
            ThrowLastError();
            }

        LogInfo("blocked default credentials");

        *phRequest = hRequest;
        return S_OK;
        }
    catch ( ComError err )
        {
        SafeCloseInternetHandle( hRequest );
        return err.Error();
        }
}

HRESULT
SendRequest(
    HINTERNET hRequest,
    URL_INFO * Info,
    CAbstractDataReader * Reader
    )
{
    DWORD err = 0;

    PVOID Address = &err;

    try
        {
        if (!WinHttpSetOption( hRequest,
                               WINHTTP_OPTION_CONTEXT_VALUE,
                               &Address,
                               sizeof(PVOID)
                               ))
            {
            err = GetLastError();

            LogWarning( "can't set context option: %!winerr!", err );
            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        //
        // Catch errors in the server certificate.
        //
        if (WINHTTP_INVALID_STATUS_CALLBACK  == WinHttpSetStatusCallback( hRequest,
                                                                          HttpRequestCallback,
                                                                          WINHTTP_CALLBACK_FLAG_SECURE_FAILURE,
                                                                          NULL
                                                                          ))
            {
            err = GetLastError();
            LogError("WinHttpSetStatusCallback failed %d", err );
            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        bool fProxyCredentials = false;
        bool fServerCredentials = false;
        int  AuthChallenges = 0;
        CredentialsApplied ProxyCredentials;

new_proxy:

        RETURN_HRESULT( SetRequestProxy( Info->hInternet, Info->ProxySettings ));

retry:

        if (AuthChallenges > 6)
            {
            //
            // The client received several 401 and/or 407 statuses, but has not 
            // reached the server yet.  Either the server is broken, or a denial-of-service
            // attack is in progress.
            //
            // Return S_OK; the request status is still 401 or 407 and that will become the
            // error code from the download.
            //
            return S_OK;
            }

        if ( fProxyCredentials & fServerCredentials )
            {

            // This code is needed since Winhttp will clear credentials after every request.
            // It will reapply the proxy credentials.  The server credentials were already applied.
            // Default credentials do not need to be reapplied since the logon policy is 
            // retain for every request.

            if ( !ProxyCredentials.bIsDefault )
                {
                ApplySchemeCredentials( hRequest, ProxyCredentials.dwTarget, ProxyCredentials.dwScheme, 
                                        Info->Credentials, Info->UserName, Info->Password );
                }
            }

        err = 0;

        BOOL b;

        if (Reader)
            {
            b = WinHttpSendRequest( hRequest,
                                   NULL,
                                   0,
                                   NULL,
                                   WINHTTP_NO_REQUEST_DATA,
                                   Reader->GetLength(),
                                   0
                                   );
            }
        else
            {
            b = WinHttpSendRequest( hRequest,
                                   NULL,
                                   0,
                                   NULL,
                                   0,
                                   0,
                                   0
                                   );
            if (b)
                {
                b = WinHttpReceiveResponse( hRequest, 0 );
                }
            }

        // err is modified by the callback routine if something was wrong with the server certificate

        if (!b)
            {
            if (!err)
                {
                err = GetLastError();
                }

            LogError("SendRequest failed %!winerr!", err );
            }

        //
        // If the proxy failed, try the next proxy in the list.
        //
        if (IsPossibleProxyFailure( err ))
            {
            LogInfo("trying next proxy");
            if (Info->ProxySettings->UseNextProxy())
                {
                fProxyCredentials = false;
                goto new_proxy;
                }

            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        if (err == ERROR_INTERNET_FORCE_RETRY)
            {
            goto retry;
            }

        //
        // If the request wasn't sent or the security callback routine reported an error, fail.
        //
        if (err)
            {
            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        //
        // Send the bulk data if present.
        //
        if (Reader)
            {
            DWORD Total = 0;

            while ( Total < Reader->GetLength())
                {
                DWORD ReadLength = min( Reader->GetLength() - Total, FILE_DATA_BUFFER_LEN);
                DWORD BytesMoved;

                THROW_HRESULT( Reader->Read( g_FileDataBuffer, ReadLength, &BytesMoved ));

                if (ReadLength != BytesMoved)
                    {
                    THROW_HRESULT( BG_E_LOCAL_FILE_CHANGED );
                    }

                LogInfo("sending %d bytes", ReadLength);

                BytesMoved = 0;
                if (!InternetWriteFile( hRequest, g_FileDataBuffer, ReadLength, &BytesMoved))
                    {
                    DWORD s = GetLastError();
                    LogError("InternetWriteFile failed %!winerr!", s);
                    THROW_HRESULT( HRESULT_FROM_WIN32( s ));
                    }

                ASSERT(ReadLength == BytesMoved);

                Total += ReadLength;
                }

            if (! HttpEndRequest( hRequest, NULL, NULL, 0 ))
                {
                DWORD s = GetLastError();
                if (s == ERROR_INTERNET_FORCE_RETRY)
                    {
                    THROW_HRESULT( Reader->Rewind() );
                    goto retry;
                    }

                LogError("HttpEndRequest failed %!winerr!", s);
                THROW_HRESULT( HRESULT_FROM_WIN32( s ));
                }
            }

        //
        // If the server or proxy server asked for auth information and we haven't already set it,
        // find matching credentials and try again.  If bulk data was sent, the reader must be rewound.
        //
        switch (GetRequestStatus( hRequest ))
            {
            case HTTP_STATUS_PROXY_AUTH_REQ:
                {
                LogInfo("server returned HTTP_STATUS_PROXY_AUTH_REQ" );

                ++AuthChallenges;

                if (ApplyCredentials( hRequest, Info->Credentials, Info->UserName, 
                                                            Info->Password, &ProxyCredentials ))
                    {
                    fProxyCredentials = true;
                    if (Reader)
                        {
                        THROW_HRESULT( Reader->Rewind() );
                        }
                    goto retry;
                    }
                else
                    {
                    // return S_OK and the caller will find the status code
                    }
                break;
                }

            case HTTP_STATUS_DENIED:
                {
                LogInfo("server returned HTTP_STATUS_DENIED");

                ++AuthChallenges;

                if (ApplyCredentials( hRequest, Info->Credentials, Info->UserName, Info->Password ))
                    {
                    fServerCredentials = true;
                    if (Reader)
                        {
                        THROW_HRESULT( Reader->Rewind() );
                        }
                    goto retry;
                    }
                else
                    {
                    // return S_OK and the caller will find the status code
                    }
                break;
                }
            }

        return S_OK;
        }
    catch ( ComError err )
        {
        LogError("exception %x", err.Error() );
        return err.Error();
        }
}

HRESULT
GetResponseVersion(
    HINTERNET hRequest,
    unsigned * MajorVersion,
    unsigned * MinorVersion
    )
{
    HRESULT hr;

    CAutoString Value;

    wchar_t Template[] = L"HTTP/%u.%u";
    const MaxChars = RTL_NUMBER_OF( Template ) + INT_DIGITS + INT_DIGITS;

    hr = GetRequestHeader( hRequest,
                           WINHTTP_QUERY_VERSION,
                           WINHTTP_HEADER_NAME_BY_INDEX,
                           Value,
                           MaxChars
                           );
    if (FAILED(hr))
        {
        LogError("error %x retrieving the response version", hr);
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    if (hr == S_FALSE)
        {
        LogError("no response version!");
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    if (2 != swscanf(Value.get(), Template, MajorVersion, MinorVersion ))
        {
        LogError("invalid response version");
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    LogInfo("server HTTP version is %d.%d", *MajorVersion, *MinorVersion );

    return S_OK;
}

HRESULT
CheckReplyLength(
    HINTERNET hRequest,
    UINT64 CorrectOffset,
    UINT64 CorrectTotal
    )
{
    HRESULT hr;

    UINT64 ReplyTotal;

    CAutoString Value;

    if (CorrectOffset != 0)
        {
        LogError( "received a 200 reply when the requested offset is nonzero: %I64d", CorrectOffset );
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    wchar_t Template[] = L"%I64d";
    const MaxChars = RTL_NUMBER_OF( Template ) + INT64_DIGITS;

    hr = GetRequestHeader( hRequest,
                           WINHTTP_QUERY_CONTENT_LENGTH,
                           WINHTTP_HEADER_NAME_BY_INDEX,
                           Value,
                           MaxChars
                           );
    if (FAILED(hr))
        {
        LogError("error %x retrieving the content-length header", hr);
        return hr;
        }

    if (hr == S_FALSE)
        {
        LogWarning("no content-length header");
        return S_FALSE;
        }

    if (1 != swscanf(Value.get(), Template, &ReplyTotal))
        {
        LogError("invalid content-length header");
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    if (ReplyTotal != CorrectTotal)
        {
        LogError("incorrect content-length header: %S", Value.get());
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    return S_OK;
}

HRESULT
CheckReplyRange(
    HINTERNET hRequest,
    UINT64 CorrectStart,
    UINT64 CorrectEnd,
    UINT64 CorrectTotal
    )
{
    HRESULT hr;

    UINT64 RangeStart;
    UINT64 RangeEnd;
    UINT64 RangeTotal;

    CAutoString Value;

    wchar_t Template[] = L"bytes %I64d-%I64d/%I64d";
    const MaxChars = RTL_NUMBER_OF( Template ) + INT64_DIGITS + INT64_DIGITS + INT64_DIGITS;

    hr = GetRequestHeader( hRequest,
                           WINHTTP_QUERY_CONTENT_RANGE,
                           WINHTTP_HEADER_NAME_BY_INDEX,
                           Value,
                           MaxChars
                           );
    if (FAILED(hr))
        {
        LogError("error %x retrieving the content-range header", hr);
        return hr;
        }

    if (hr == S_FALSE)
        {
        LogWarning("no reply range header");
        return S_FALSE;
        }

    if (3 != swscanf(Value.get(), Template, &RangeStart, &RangeEnd, &RangeTotal))
        {
        LogError("invalid reply range header");
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    if (RangeStart != CorrectStart ||
        RangeEnd != CorrectEnd ||
        RangeTotal != CorrectTotal)
        {
        LogError("incorrect reply range header: %I64d-%I64d/%I64d", RangeStart, RangeEnd, RangeTotal);
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    return S_OK;
}

HRESULT
GetRequestHeader(
    HINTERNET hRequest,
    DWORD HeaderIndex,
    LPCWSTR HeaderName,
    CAutoString & Destination,
    size_t MaxChars
    )
/*

    Fetch an arbitrary header's value from the request, allocating a string to hold it.

Input:

    HeaderIndex and HeaderName follow the rules for WinHttpQueryHeaders() parameters
    dwInfoLevel and pwszName respectively.

Returns:

    S_OK: header found, and Destination holds the value.
    S_FALSE: header not found
    all others: an error occurred along the way

*/
{
    try
        {
        DWORD s;
        HRESULT hr;
        DWORD ValueLength;
        CAutoString Value;

        WinHttpQueryHeaders( hRequest, HeaderIndex, HeaderName, NULL, &ValueLength, WINHTTP_NO_HEADER_INDEX  );

        s = GetLastError();
        if (s == ERROR_WINHTTP_HEADER_NOT_FOUND)
            {
            return S_FALSE;
            }

        if (s != ERROR_INSUFFICIENT_BUFFER)
            {
            return HRESULT_FROM_WIN32( s );
            }

        if (ValueLength > ((MaxChars+1) * sizeof(wchar_t)))
            {
            return BG_E_INVALID_SERVER_RESPONSE;
            }

        Value = CAutoString( new wchar_t[ ValueLength ] );

        if (!WinHttpQueryHeaders( hRequest, HeaderIndex, HeaderName, Value.get(), &ValueLength, WINHTTP_NO_HEADER_INDEX  ))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        Destination = Value;

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
AddRangeHeader(
    HINTERNET hRequest,
    UINT64 Start,
    UINT64 End
    )
{
    static const TCHAR RangeTemplate[] =_T("Range: bytes=%I64d-%I64d\r\n");

    HRESULT hr;
    TCHAR szHeader[ RTL_NUMBER_OF(RangeTemplate) + INT64_DIGITS + INT64_DIGITS ];

    hr = StringCbPrintf(szHeader, sizeof(szHeader), RangeTemplate, Start, End);
    if (FAILED(hr))
        {
        LogError( "range header is too large for its buffer.  start %I64d, end %I64d", Start, End );
        return hr;
        }

    if (! HttpAddRequestHeaders( hRequest, szHeader, -1L, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    return S_OK;
}

HRESULT
AddIf_Unmodified_SinceHeader(
    HINTERNET hRequest,
    const FILETIME &Time
    )
{
    const TCHAR szIfModifiedTemplate[] = _T("If-Unmodified-Since: %s\r\n");
    static TCHAR szIfModifiedHeader[ (sizeof(szIfModifiedTemplate) / sizeof(TCHAR)) + INTERNET_RFC1123_BUFSIZE*2 ];
    static TCHAR szIfModifiedTime[ INTERNET_RFC1123_BUFSIZE*2 ];

    HRESULT hr;

    SYSTEMTIME stFileCreationTime;
    if ( !FileTimeToSystemTime( &Time, &stFileCreationTime ) )
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if ( !InternetTimeFromSystemTime( &stFileCreationTime, INTERNET_RFC1123_FORMAT, szIfModifiedTime,
                                      sizeof( szIfModifiedTime ) ) )
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    hr = StringCbPrintf( szIfModifiedHeader, sizeof(szIfModifiedHeader), szIfModifiedTemplate, szIfModifiedTime );
    if (FAILED(hr))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (! HttpAddRequestHeaders( hRequest, szIfModifiedHeader, -1L, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    return S_OK;
}

bool
ApplyCredentials(
    HINTERNET hRequest,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[],
    CredentialsApplied *pAppliedCreds
    )
{
    HRESULT hr;
    DWORD dwSupportedSchemes;
    DWORD dwPreferredScheme;
    DWORD dwTarget;

   if (!WinHttpQueryAuthSchemes( hRequest,
                                 &dwSupportedSchemes,
                                 &dwPreferredScheme,
                                 &dwTarget ))
       {
       if (GetLastError() == ERROR_INVALID_OPERATION)
           {
           // no schemes available at all
           LogWarning("the server listed no auth schemes");
           return false;
           }

       ThrowLastError();
       }

   LogInfo("target %d, preferred scheme %x, supported schemes %x", dwTarget, dwPreferredScheme, dwSupportedSchemes );

   //
   // First look for credentials supporting the preferred scheme.
   //
   if (ApplySchemeCredentials( hRequest, dwTarget, dwPreferredScheme, Credentials, UserName, Password ))
       {
       if ( pAppliedCreds )
           {
           pAppliedCreds->bIsDefault = false;
           pAppliedCreds->dwTarget = dwTarget;
           pAppliedCreds->dwScheme = dwPreferredScheme;
           }
       return true;
       }

   //
   // Look for any other credential scheme supported by both sides.
   //
   signed bit;
   for (bit=31; bit >= 0; --bit)
       {
       DWORD dwScheme = (1 << bit);

       if (0 != (dwSupportedSchemes & dwScheme))
           {
           if (ApplySchemeCredentials( hRequest, dwTarget, dwScheme, Credentials, UserName, Password ))
               {
               if ( pAppliedCreds )
                   {
                   pAppliedCreds->bIsDefault = false;
                   pAppliedCreds->dwTarget = dwTarget;
                   pAppliedCreds->dwScheme = dwScheme;
                   }
               return true;
               }
           }
       }

   //
   // No matching explicit security credential.  Try default credentials, if we are allowed to.
   //
   if (bLanManHashDisabled)
       {
       //
       // The WinHTTP MEDIUM level doesn't work with auto-proxy detection; it always
       // believes that the client is directly connected to the Internet and disallows
       // default credentials.  Since BITS doesn't know reliably either, we allow it only
       // when the unsecure pre-NT logon protocol is disabled.
       //
       LogInfo("Enabling default credentials");
       DWORD flag = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;

       if (!WinHttpSetOption( hRequest,
                              WINHTTP_OPTION_AUTOLOGON_POLICY,
                              &flag,
                              sizeof(DWORD)
                              ))
           {
           ThrowLastError();
           }

       if ( pAppliedCreds )
           {
           pAppliedCreds->bIsDefault = true;
           pAppliedCreds->dwTarget = 0;
           pAppliedCreds->dwScheme = 0;
           }

       return true;
       }

   return false;
}

DWORD GetRequestStatus( HINTERNET hRequest )
{
    DWORD Status;
    DWORD dwLength = sizeof(Status);
    if (! HttpQueryInfo( hRequest,
                HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                (LPVOID)&Status,
                &dwLength,
                NULL))
        {
        ThrowLastError();
        }

    return Status;
}

bool
SchemeFromWinHttp(
    DWORD Scheme,
    BG_AUTH_SCHEME * pScheme
    )
{
    switch (Scheme)
        {
        case WINHTTP_AUTH_SCHEME_BASIC:     *pScheme = BG_AUTH_SCHEME_BASIC;     return true;
        case WINHTTP_AUTH_SCHEME_DIGEST:    *pScheme = BG_AUTH_SCHEME_DIGEST;    return true;
        case WINHTTP_AUTH_SCHEME_NTLM:      *pScheme = BG_AUTH_SCHEME_NTLM;      return true;
        case WINHTTP_AUTH_SCHEME_NEGOTIATE: *pScheme = BG_AUTH_SCHEME_NEGOTIATE; return true;
        case WINHTTP_AUTH_SCHEME_PASSPORT:  *pScheme = BG_AUTH_SCHEME_PASSPORT;  return true;
        default:
            LogWarning("unknown WinHttp scheme 0x%x", Scheme );
            return false;
        }
}

BG_AUTH_TARGET TargetFromWinHttp(  DWORD Target )
{
    if (Target == WINHTTP_AUTH_TARGET_PROXY)
        {
        return BG_AUTH_TARGET_PROXY;
        }

    if (Target == WINHTTP_AUTH_TARGET_SERVER)
        {
        return BG_AUTH_TARGET_SERVER;
        }

    LogWarning("unknown WinHttp target 0x%x", Target );
    ASSERT( 0 );

    return BG_AUTH_TARGET_SERVER;
}


bool
ApplySchemeCredentials(
    HINTERNET hRequest,
    DWORD dwTarget,
    DWORD dwScheme,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[]
    )
{
    BG_AUTH_TARGET BitsTarget;
    BG_AUTH_SCHEME BitsScheme;
    BG_AUTH_CREDENTIALS * cred = 0;

    BitsTarget = TargetFromWinHttp( dwTarget );

    //
    // Translate the scheme into the BITS ID and see if a matching credential is available.
    //
    if (!SchemeFromWinHttp( dwScheme, &BitsScheme ))
        {
        // BITS doesn't understand this scheme.
        LogInfo("skipping unknown scheme 0x%x", dwScheme);
        return false;
        }

    if (BitsScheme == BG_AUTH_SCHEME_BASIC && UserName && UserName[0])
        {
        // use credentials embedded in URL
        //
        }
    else
        {
        HRESULT hr;
        THROW_HRESULT( hr = Credentials->Find( BitsTarget, BitsScheme, &cred ));

        if (hr != S_OK)
            {
            // no credential available for this scheme.
            return false;
            }

        // use the credential in the dictionary.
        //
        UserName = cred->Credentials.Basic.UserName;
        Password = cred->Credentials.Basic.Password;
        }

    //
    // Apply a workaround for WinHTTP bug 754006, which is present in Windows XP earlier than SP4
    // and Windows 2003 RTM.  
    //
    if (UserName == NULL &&
        Password == NULL &&
        (dwScheme == WINHTTP_AUTH_SCHEME_NTLM || 
         dwScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE))
        {
        LogInfo("Enabling default credentials to support the explicitly specified implicit user");

        DWORD flag = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;

        if (!WinHttpSetOption( hRequest,
                               WINHTTP_OPTION_AUTOLOGON_POLICY,
                               &flag,
                               sizeof(DWORD)
                               ))
            {
            if (cred)
                {
                ScrubCredentials( *cred );
                delete [] cred->Credentials.Basic.UserName;
                delete [] cred->Credentials.Basic.Password;
                delete cred;
                cred = NULL;
                }

            ThrowLastError();
            }
        }

    //
    // Apply the credentials we found.
    //
    LogInfo("found credentials for target %d scheme 0x%x (BITS scheme %d)", dwTarget, dwScheme, BitsScheme );

    if (!WinHttpSetCredentials( hRequest,
                                dwTarget,
                                dwScheme,
                                UserName,
                                Password,
                                NULL
                                ))
        {
        if (cred)
            {
            ScrubCredentials( *cred );
            delete [] cred->Credentials.Basic.UserName;
            delete [] cred->Credentials.Basic.Password;
            delete cred;
            cred = NULL;
            }

        ThrowLastError();
        }

    if (cred)
        {
        ScrubCredentials( *cred );
        delete [] cred->Credentials.Basic.UserName;
        delete [] cred->Credentials.Basic.Password;
        delete cred;
        cred = NULL;
        }

    return true;
}

#ifndef USE_WININET

DWORD
MapSecureHttpErrorCode(
    DWORD flags
    )
{
    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT)
        {
        return ERROR_INTERNET_SEC_CERT_ERRORS;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA)
        {
        return ERROR_INTERNET_INVALID_CA;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID)
        {
        return ERROR_INTERNET_SEC_CERT_CN_INVALID;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID)
        {
        return ERROR_INTERNET_SEC_CERT_DATE_INVALID;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED)
        {
        return ERROR_ACCESS_DENIED;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR)
        {
        return ERROR_INTERNET_INTERNAL_ERROR;
        }

    //
    // Since we have not asked for revocation checking, this shouldn't happen.
    //
    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)
        {
        ASSERT( 0 );
        return 0;
        }

    ASSERT( flags );

    if (flags)
        {
        return ERROR_ACCESS_DENIED;
        }

    return 0;
}

VOID CALLBACK
HttpRequestCallback(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    )
{
    switch (dwInternetStatus)
        {
        case WINHTTP_CALLBACK_STATUS_SECURE_FAILURE:
            {
            DWORD * pErr = LPDWORD( dwContext );
            DWORD * pFlags = LPDWORD( lpvStatusInformation );

            ASSERT( pErr != NULL );

            LogWarning("SSL error: flags %x", *pFlags );

            *pErr = MapSecureHttpErrorCode( *pFlags );
            break;
            }
        default:
            LogWarning("bogus HTTP notification %x", dwInternetStatus );
            break;
        }
}

#endif

// N.B. This value must agree with the key specified in the system.adm file
static const WCHAR LM_COMPATIBILITY_LEVEL_KEY[] =
    L"System\\Currentcontrolset\\Control\\Lsa";

HRESULT CheckLanManHashDisabled ()
/*++

Routine Description:

    Check in the registry whether the lan man hash was disabled.

Arguments:

    Disabled - on successful output, if true, the lan man hash was disabled.
        Undefined on failure.

--*/
{
    HKEY h = 0;
    DWORD DwordSize;
    DWORD Type;
    DWORD Result;
    char Buffer[20];

    bLanManHashDisabled = FALSE;

    DWORD Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  LM_COMPATIBILITY_LEVEL_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        // no key, proceed as if the hash is enabled
        return S_OK;
        }
    else if (Status != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32( Status );
        }

    DwordSize = sizeof(DWORD);

    Status = RegQueryValueExW(
                    h,
                    L"lmcompatibilitylevel",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        if (h)
            {
            RegCloseKey(h);
            }
        // no key, proceed as if hash is enabled
        return S_OK;
        }

    if (Status == ERROR_SUCCESS
        && Type == REG_DWORD
        && Result >= 2)
        {
        bLanManHashDisabled = TRUE;
        }

    // if the type was not REG_DWORD or out of range, probably registry is corrupted
    // in this case, assume hash is enabled

    if (h)
        {
        RegCloseKey(h);
        }

    if (Status != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32( Status );
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\eventlog.cpp ===
//--------------------------------------------------------------------
// Copyright (C) Microsoft Corporation, 1999 - 2002, All Rights Reserved
//
// eventlog.cpp
//
// Implementation of a simple event logging class.
//
//--------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#if !defined(BITS_V12_ON_NT4)
#include "eventlog.tmh"
#endif

//--------------------------------------------------------------------
// EVENT_LOG::EVENT_LOG()
//
//--------------------------------------------------------------------
EVENT_LOG::EVENT_LOG()
: m_OwnerString( new WCHAR[USER_NAME_LENGTH] ),
   m_UserString( new WCHAR[USER_NAME_LENGTH] )
    {
    m_hEventLog = RegisterEventSourceW( NULL, WS_EVENT_SOURCE );
    if (!m_hEventLog)
        {
        ThrowLastError();
        }
    }

//--------------------------------------------------------------------
// EVENT_LOG:;~EVENT_LOG()
//
//--------------------------------------------------------------------
EVENT_LOG::~EVENT_LOG()
    {
    if (m_hEventLog)
        {
        DeregisterEventSource(m_hEventLog);
        }

    delete m_OwnerString;
    delete m_UserString;
    }

HRESULT  EVENT_LOG::ReportGenericJobChange(
    GUID & Id,
    LPCWSTR Title,
    SidHandle Owner,
    SidHandle User,
    DWORD EventType
    )
/*
    This is a helper routine for a couple of different events that use the same insertion strings.
    Currently there are two, for job cancellation and for take-ownership.
    <EventType> should be the event ID from the .MC file.  This fn doesn't verify that
    the event in question expects these insertion strings.

*/
{
    GUIDSTR GuidString;

    StringFromGUID2( Id, GuidString, RTL_NUMBER_OF( GuidString ));

    SidToUser( Owner.get(), m_OwnerString, USER_NAME_LENGTH );
    SidToUser( User.get(), m_UserString, USER_NAME_LENGTH );

    //
    LPCWSTR Strings[4];

    Strings[0] = GuidString;
    Strings[1] = Title;
    Strings[2] = m_OwnerString;
    Strings[3] = m_UserString;

    BOOL b;
    b = ReportEvent(
        m_hEventLog,
        EVENTLOG_INFORMATION_TYPE,
        0, // no category
        EventType,
        NULL,   // no user
        RTL_NUMBER_OF(Strings),
        0,      // no additional data
        Strings,
        NULL    // no additional data
        );

    if (!b)
        {
        DWORD s = GetLastError();
        LogError("unable to log job-change event (%x) %!winerr!", EventType, s);
        return HRESULT_FROM_WIN32( s );
        }

    return S_OK;
}

HRESULT  EVENT_LOG::ReportFileDeletionFailure(
    GUID & Id,
    LPCWSTR Title,
    LPCWSTR FileList,
    bool fMoreFiles
    )
{
    GUIDSTR GuidString;

    StringFromGUID2( Id, GuidString, RTL_NUMBER_OF( GuidString ));

    LPCWSTR Strings[3];

    Strings[0] = GuidString;
    Strings[1] = Title;
    Strings[2] = FileList;

    BOOL b;
    b = ReportEvent(
        m_hEventLog,
        EVENTLOG_WARNING_TYPE,
        0, // no category
        fMoreFiles ? MC_FILE_DELETION_FAILED_MORE : MC_FILE_DELETION_FAILED,
        NULL,   // no user
        RTL_NUMBER_OF(Strings),
        0,      // no additional data
        Strings,
        NULL    // no additional data
        );

    if (!b)
        {
        DWORD s = GetLastError();
        LogError("unable to log file-deletion-failure event %!winerr!", s);
        return HRESULT_FROM_WIN32( s );
        }

    return S_OK;
}

HRESULT  EVENT_LOG::ReportStateFileCleared()
{
    BOOL b;
    b = ReportEvent(
        m_hEventLog,
        EVENTLOG_ERROR_TYPE,
        0, // no category
        MC_STATE_FILE_CORRUPT,
        NULL,   // no user
        0,      // no plug-in strings
        0,      // no additional data
        NULL,   // no plug-in strings
        NULL    // no additional data
        );

    if (!b)
        {
        DWORD s = GetLastError();
        LogError("unable to log state-file-cleared event %!winerr!", s);
        return HRESULT_FROM_WIN32( s );
        }

    return S_OK;
}


HRESULT EVENT_LOG::SidToUser( PSID Sid, LPWSTR Name, size_t Length )
{
    DWORD s;
    DWORD NameLength = 0;
    DWORD DomainLength = 0;
    SID_NAME_USE Use;

    //
    // Determine the usern-name and domain-name lengths.
    //
    LookupAccountSid( NULL, // default lookup spaces
                      Sid,
                      NULL,
                      &NameLength,
                      NULL,
                      &DomainLength,
                      &Use
                      );

    s = GetLastError();

    if (s == ERROR_NONE_MAPPED)
        {
        return GetUnknownUserName( Name, Length );
        }

    if (s != ERROR_INSUFFICIENT_BUFFER)
        {
        LogError("LookupAccountSid #1 failed %!winerr!", s);
        return HRESULT_FROM_WIN32(s);
        }

    if (NameLength + DomainLength > Length)
        {
        return HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
        }

    //
    // Capture the user-name and domain-name.
    //
    NameLength = Length - DomainLength;
    if (!LookupAccountSid( NULL,
                           Sid,
                           Name + DomainLength,
                           &NameLength,
                           Name,
                           &DomainLength,
                           &Use ))
        {
        s = GetLastError();
        LogError("LookupAccountSid #2 failed %!winerr!", s);
        return HRESULT_FROM_WIN32(s);
        }

    //
    // The domain and user name are separated by a NULL instead of a backslash; fix that.
    //
    Name[wcslen(Name)] = '\\';
    return S_OK;
}

HRESULT
EVENT_LOG::GetUnknownUserName(
    WCHAR Name[],
    size_t Length
    )
{
    DWORD s;

    if (!LoadString( g_hInstance, IDS_UNKNOWN_USER, Name, Length ))
        {
        s = GetLastError();
        LogError("LoadString failed %!winerr!", s);
        return HRESULT_FROM_WIN32(s);
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\eventlog.h ===
//--------------------------------------------------------------------
// Copyright (c) 2002 Microsoft Corporation, All Rights Reserved
//
// eventlog.h
//
// Definitions and constants for writing event log events.
//
//--------------------------------------------------------------------

//
// This is the event source for BITS system events.  If it changes, also change
// the INF files to create a matching subdirectory in SYSTEM\CurrentControlSet\Services\EventLog\System\
//
#define WS_EVENT_SOURCE L"BITS"

#define USER_NAME_LENGTH 200

//
// A simple log to write error and informational events to the
// system event log.
//
class EVENT_LOG
{
public:

    EVENT_LOG() throw( ComError );

    ~EVENT_LOG();

    static HRESULT GetUnknownUserName(
        WCHAR Name[],
        size_t Length
        );

    static HRESULT SidToUser( PSID Sid, LPWSTR Name, size_t Length );

    HRESULT  ReportStateFileCleared();

    HRESULT
    ReportFileDeletionFailure(
        GUID & Id,
        LPCWSTR Title,
        LPCWSTR FileList,
        bool fMoreFiles
        );

    HRESULT
    ReportGenericJobChange(
        GUID & Id,
        LPCWSTR Title,
        SidHandle Owner,
        SidHandle User,
        DWORD EventType
        );

    inline HRESULT  ReportJobCancellation(
        GUID & Id,
        LPCWSTR Title,
        SidHandle Owner,
        SidHandle User
        )
    {
        return ReportGenericJobChange( Id, Title, Owner, User, MC_JOB_CANCELLED );
    }

    inline HRESULT  ReportJobOwnershipChange(
        GUID & Id,
        LPCWSTR Title,
        SidHandle Owner,
        SidHandle User
        )
    {
        return ReportGenericJobChange( Id, Title, Owner, User, MC_JOB_TAKE_OWNERSHIP );
    }

private:
    HANDLE  m_hEventLog;
    WCHAR * m_OwnerString;
    WCHAR * m_UserString;

};

extern EVENT_LOG * g_EventLogger;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\init.cpp ===
#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "init.tmh"
#endif

EVENT_LOG * g_EventLogger;

BOOL
CreateAndWaitForThread(
    LPTHREAD_START_ROUTINE fn,
    HANDLE * pThreadHandle,
    DWORD *  pThreadId
    );



//
// The whole block of code is an attempt to work
// around the C++ termination handler.   The idea is to
// intercept the C++ exception code and map it to
// a bogus code which probably won't be handled.
// This should give us the Dr. Watson.
//

// The NT exception # used by C runtime
#define EH_EXCEPTION_NUMBER ('msc' | 0xE0000000)

DWORD BackgroundThreadProcFilter(
    LPEXCEPTION_POINTERS ExceptionPointers )
{

    //  Values are 32 bit values layed out as follows:
    //
    //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    //  +---+-+-+-----------------------+-------------------------------+
    //  |Sev|C|R|     Facility          |               Code            |
    //  +---+-+-+-----------------------+-------------------------------+

    //  pick a random code that probably won't be handled.


    if ( EH_EXCEPTION_NUMBER == ExceptionPointers->ExceptionRecord->ExceptionCode )
        ExceptionPointers->ExceptionRecord->ExceptionCode = 0xE0000001;

    return EXCEPTION_CONTINUE_SEARCH;
}

DWORD BackgroundThreadProc( void *lp );

DWORD WINAPI BackgroundThreadProcWrap( void *lp )
{
    __try
    {
        return BackgroundThreadProc( lp );
    }
    __except( BackgroundThreadProcFilter(
                  GetExceptionInformation() ) )
    {
        ASSERT( 0 );
    }
    ASSERT( 0 );

    return 0;
}


DWORD BackgroundThreadProc( void *lp )
//
// 5-18-2001: I'm avoiding LogInfo calls before g_Manager is initialized,
//            in order to catch a bug where init and Uninit seem to overlap.
//
{
    MSG msg;
    HRESULT hr = S_OK;
    DWORD   dwRegCONew = 0;
    DWORD   dwRegCOOld = 0;

    DWORD  instance = g_ServiceInstance;

    HANDLE hEvent = (HANDLE) lp;

    //CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);   //not on Win95!
    //hr = CoInitialize(NULL);
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if (FAILED(hr))
        {
        LogInfo( "background thread failed CoInit, instance %d, hr %x", instance, hr );

        return hr;
        }

    //force it to create a msg queue
    PeekMessage(&msg, NULL, WM_APP, WM_APP, PM_NOREMOVE);

    try
        {
        ASSERT( g_Manager == NULL );

        g_EventLogger = new EVENT_LOG;
        g_Manager = new CJobManager;

        LogInfo( "background thread starting, instance %d, manager %p", instance, g_Manager );

        THROW_HRESULT( g_Manager->Unserialize() );

        //
        // List currently active users as logged in.
        // List the Big Three service accounts as logged in.
        //
        THROW_HRESULT( g_Manager->m_Users.AddActiveUsers() );
        THROW_HRESULT( g_Manager->m_Users.AddServiceAccounts() );

        g_Manager->m_Users.Dump();

        //
        // If any networks are active, begin processing jobs.
        //
        g_Manager->OnNetworkChange();

        //
        // Allow client calls.
        //
        THROW_HRESULT( g_Manager->RegisterClassObjects() );


        LogInfo( "Background thread initialized.");

        //
        // The thread has set up completely.
        //
        SetEvent( hEvent );
        }
    catch (ComError exception)
        {
        hr = exception.Error();
        LogInfo( "background thread failed, instance %d, hr %x", instance, hr );
        goto exit;
        }
    catch (HRESULT exception )
        {
        LogError( "init : caught unhandled HRESULT %x", exception);

        #ifdef DBG
        DbgBreakPoint();
        #endif

        hr = exception;
        goto exit;
        }
    catch (DWORD exception )
        {
        LogError( "init : caught unhandled error %d", exception);

        #ifdef DBG


        DbgBreakPoint();
        #endif

        hr = exception;

        goto exit;

        }

    //
    // Message & task pump: returns only when the object shuts down.
    // Intentionally, call this function outside of a try/catch
    // since any unhandled exception in this function should
    // be an AV.
    g_Manager->TaskThread();

exit:
    LogInfo("task thread exiting, hr %x", hr);

    if (g_Manager)
        {
        ASSERT( instance == g_ServiceInstance );

        g_Manager->Shutdown();
        delete g_Manager;
        g_Manager = NULL;
        }

    delete g_EventLogger; g_EventLogger = NULL;

    CoUninitialize();
    return hr;
}

HANDLE  g_hBackgroundThread;
DWORD   g_dwBackgroundThreadId;

// void TestImpersonationObjects();

HRESULT WINAPI
InitQmgr()
{
    ++g_ServiceInstance;

    if (!CreateAndWaitForThread( BackgroundThreadProcWrap,
                                 &g_hBackgroundThread,
                                 &g_dwBackgroundThreadId
                                 ))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    LogInfo( "Finishing InitQmgr()" );

    return S_OK;
}

HRESULT WINAPI
UninitQmgr()
{
    DWORD s;
    HANDLE hThread = g_hBackgroundThread;

    if (hThread == NULL)
        {
        // never set up
        LogInfo("Uninit Qmgr: nothing to do");
        return S_OK;
        }

    LogInfo("Uninit Qmgr: beginning");

    //
    // Tell the thread to terminate.
    //
    // 3.5 interrupt the downloader.

    g_Manager->LockWriter();

    // Hold the writer lock while killing the downloader.

    g_Manager->InterruptDownload();

    g_Manager->UnlockWriter();

    PostThreadMessage(g_dwBackgroundThreadId, WM_QUIT, 0, 0);

    g_dwBackgroundThreadId = 0;
    g_hBackgroundThread = NULL;

    //
    // Wait until the thread actually terminates.
    //
    s = WaitForSingleObject( hThread, INFINITE );

    LogInfo("Uninit Qmgr: wait finished with %d", s);

    CloseHandle(hThread);

    if (s != WAIT_OBJECT_0)
        {
        return HRESULT_FROM_WIN32( s );
        }

    return S_OK;
}


HRESULT
CheckServerInstance(
    long ObjectServiceInstance
    )
{
    IncrementCallCount();

    if (g_ServiceInstance != ObjectServiceInstance ||
        g_ServiceState    != MANAGER_ACTIVE)
        {
        LogWarning("call blocked: mgr state %d, instance %d vs. %d",
                   g_ServiceState, g_ServiceInstance, ObjectServiceInstance);

        DecrementCallCount();

        return CO_E_SERVER_STOPPING;
        }

    return S_OK;
}

BOOL
CreateAndWaitForThread(
    LPTHREAD_START_ROUTINE fn,
    HANDLE * pThreadHandle,
    DWORD *  pThreadId
    )
{
    HANDLE  hThread = NULL;
    HANDLE  hEvent  = NULL;
    HANDLE  Handles[2];
    DWORD   dwThreadID;
    DWORD   s = 0;

    *pThreadHandle = NULL;
    *pThreadId     = 0;

    //
    // Create the message-pump thread, then wait for the thread to exit or to signal success.
    //
    hEvent = CreateEvent( NULL,     // no security
                          FALSE,    // not manual reset
                          FALSE,    // initially not set
                          NULL
                          );
    if (!hEvent)
        {
        goto Cleanup;
        }

    hThread = CreateThread(NULL, 0, fn, PVOID(hEvent), 0, &dwThreadID);
    if (hThread == NULL)
        {
        goto Cleanup;
        }

    enum
    {
        THREAD_INDEX = 0,
        EVENT_INDEX = 1
    };

    Handles[ THREAD_INDEX ] = hThread;
    Handles[ EVENT_INDEX ] = hEvent;

    s = WaitForMultipleObjects( 2,          // 2 handles
                                Handles,
                                FALSE,      // don't wait for all
                                INFINITE
                                );
    switch (s)
        {
        case WAIT_OBJECT_0 + THREAD_INDEX:
            {
            // the thread exited.
            if (GetExitCodeThread( hThread, &s))
                {
                SetLastError( s );
                }
            goto Cleanup;
            }

        case WAIT_OBJECT_0 + EVENT_INDEX:
            {
            // success
            break;
            }

        default:
            {
            // some random error.  We are really toasted if
            // WaitForMultipleObjects is failing.
            ASSERT(0);
            goto Cleanup;
            }
        }

    CloseHandle( hEvent );
    hEvent = NULL;

    *pThreadHandle = hThread;
    *pThreadId     = dwThreadID;

    return TRUE;

Cleanup:


    if (hThread)
        {
        CloseHandle( hThread );
        }

    if (hEvent)
        {
        CloseHandle( hEvent );
        }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\metadata.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    metadata.h

Abstract :

    Main header for code for reading and writting to the metadata.

Author :

Revision History :

 ***********************************************************************/

// These functions may throw a ComError.
//
void SafeWriteFile( HANDLE hFile, void *pBuffer, DWORD dwSize );
void SafeReadFile( HANDLE hFile, void *pBuffer, DWORD dwSize );
void SafeWriteStringHandle( HANDLE hFile, StringHandle & str );
StringHandle SafeReadStringHandle( HANDLE hFile );

void SafeWriteFile( HANDLE hFile, WCHAR * str );
void SafeReadFile( HANDLE hFile, WCHAR ** pStr );


void SafeWriteSid( HANDLE hFile, SidHandle & Sid );
void SafeReadSid( HANDLE hFile, SidHandle & sid );

template <class T>
void SafeWriteFile( HANDLE hFile, T Data )
{
    SafeWriteFile( hFile, &Data, sizeof( Data ) );
}

template <class T>
void SafeReadFile( HANDLE hFile, T *pBuffer)
{
    SafeReadFile( hFile, pBuffer, sizeof(*pBuffer) );
}

void SafeWriteBlockBegin( HANDLE hFile, GUID BlockGuid );
void SafeWriteBlockEnd( HANDLE hFile, GUID BlockGuid );
void SafeReadBlockBegin( HANDLE hFile, GUID BlockGuid );
void SafeReadBlockEnd( HANDLE hFile, GUID BlockGuid );

//
// allows any one of several GUIDs.
//
int SafeReadGuidChoice( HANDLE hFile, const GUID * guids[] );


class CQmgrStateFiles
    {
    auto_FILE_HANDLE m_Files[2];
    auto_ptr<WCHAR> m_FileNames[2];
    UINT64 m_ExpandSize[2];
    INT64 m_OriginalFileSizes[2];
    DWORD m_CurrentIndex;

    static auto_ptr<WCHAR> GetNameFromIndex( DWORD dwIndex );
    static auto_FILE_HANDLE OpenMetadataFile( auto_ptr<WCHAR> FileName );
    static void WriteEmptyMetadataFile( HANDLE hFile );

public:
    CQmgrStateFiles();
    HANDLE GetNextStateFile();
    void UpdateStateFile();
    HANDLE GetCurrentStateFile();

    void ExtendMetadata( INT64 ExtendAmount = ( METADATA_PREALLOC_SIZE + METADATA_PADDING ) );
    void ShrinkMetadata();
    };

class CQmgrReadStateFile
    {
private:
    CQmgrStateFiles & m_StateFiles;
    HANDLE m_FileHandle;

public:
    CQmgrReadStateFile( CQmgrStateFiles & StateFiles );
    HANDLE GetHandle() { return m_FileHandle;}
    void ValidateEndOfFile();
    };


class CQmgrWriteStateFile
    {
private:
    CQmgrStateFiles & m_StateFiles;
    HANDLE m_FileHandle;

public:
    CQmgrWriteStateFile( CQmgrStateFiles & StateFiles );
    HANDLE GetHandle() { return m_FileHandle;}
    void CommitFile();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\logontable.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    logontable.h

Abstract :

    Header file for the logon table

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include <wtypes.h>
#include <unknwn.h>

#include <utility>
#include <set>
#include <map>
#include "tasksched.h"

class CUser
{
public:

    CUser( HANDLE Token );
    ~CUser();

    long IncrementRefCount();
    long DecrementRefCount();

    void SetCookie( DWORD cookie )
    {
        _Cookie = cookie;
    }

    DWORD GetCookie()
    {
        return _Cookie;
    }

    DWORD CopyToken( HANDLE * pToken )
    {
        if (!DuplicateHandle( GetCurrentProcess(),
                              _Token,
                              GetCurrentProcess(),
                              pToken,
                              TOKEN_ALL_ACCESS,
                              FALSE,              // no inheritance
                              0                   // no extra options
                              ))
            {
            return GetLastError();
            }

        return 0;
    }

    HRESULT Impersonate()
    {
        if (!ImpersonateLoggedOnUser(_Token))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        return S_OK;
    }

    SidHandle & QuerySid()
    {
        return _Sid;
    }

    void Dump();

    HRESULT
    LaunchProcess(
        StringHandle Program,
        StringHandle Parameters
        );

private:

    long            _ReferenceCount;
    HANDLE          _Token;
    SidHandle       _Sid;
    DWORD           _Cookie;

    //--------------------------------------------------------------------

};


class CLoggedOnUsers
{
    class  CSessionList : public std::map<DWORD, CUser *>
    {
    public:

        void Dump();
    };

    class CUserList : public std::multimap<SidHandle, CUser *, CSidSorter>
    {
    public:

        ~CUserList();

        CUser *
        RemoveByCookie(
            SidHandle sid,
            DWORD cookie
            );

        bool
        RemovePair(
            SidHandle sid,
            CUser * user
            );

        CUser *
        FindSid(
            SidHandle sid
            );

        void Dump();
    };

public:

    CLoggedOnUsers( TaskScheduler & sched );
    ~CLoggedOnUsers();

    HRESULT AddServiceAccounts();
    HRESULT AddActiveUsers();

    HRESULT LogonSession( DWORD session );
    HRESULT LogoffSession( DWORD session );

    HRESULT LogonService( HANDLE token, DWORD * cookie );
    HRESULT LogoffService( SidHandle Sid, DWORD  cookie );

    CUser * FindUser( SidHandle sid, DWORD session );

    void Dump();

private:

    //--------------------------------------------------------------------

    TaskScheduler & m_TaskScheduler;
    CSessionList    m_ActiveSessions;
    CUserList       m_ActiveUsers;
    CUserList       m_ActiveServiceAccounts;
    long            m_CurrentCookie;

    CLogonNotification * m_SensNotifier;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\metadata.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    metadata.cpp

Abstract :

    Main code for reading and writting to the metadata.

Author :

Revision History :

NOTES:

   For robustness, the code preallocates disk space at the begining of a
change which might have a large impact on the metadata file size.  This
preallocation eliminates most of the errors which can occure during the serialize
operation. After serializing, metedata files are shrunk to the size used.  The
metadata files are not expanded for operations such as Resume which won't have
a large effect on the file sizes.  Instead a 4K pad is maintained at the end for
these operations to use.

  Several of the check in the code can be clasified as paranoia checks.

 ***********************************************************************/

#include "stdafx.h"
#include <malloc.h>
#include <sddl.h>
#include <limits>

#include "metadata.tmh"

void BITSSetEndOfFile( HANDLE File )
{
    if ( !SetEndOfFile( File ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "SetEndOfFile failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }
}

INT64 BITSSetFilePointer(
    HANDLE File,
    INT64 Offset,
    DWORD MoveMethod
)
{
    LARGE_INTEGER LargeIntegerOffset;
    LargeIntegerOffset.QuadPart = Offset;

    LARGE_INTEGER LargeIntegerNewPointer;

    if ( !SetFilePointerEx( File, LargeIntegerOffset, &LargeIntegerNewPointer, MoveMethod ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "SetFilePointerEx failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }

    return LargeIntegerNewPointer.QuadPart;
}

INT64 BITSGetFileSize( HANDLE File )
{

    LARGE_INTEGER LargeIntegerSize;

    if ( !GetFileSizeEx( File, &LargeIntegerSize ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "GetFileSize failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }

    return LargeIntegerSize.QuadPart;
}

void BITSFlushFileBuffers( HANDLE File )
{
    if ( !FlushFileBuffers( File ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "FlushFileBuffers failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }
}

bool
printable( char c )
{
    if ( c < 32 )
        {
        return false;
        }

    if ( c > 126 )
        {
        return false;
        }

    return true;
}

void
DumpBuffer(
          void * Buffer,
          unsigned Length
          )
{
    if( false == LogLevelEnabled( LogFlagSerialize ) )
       {
        return;
       }

    const BYTES_PER_LINE = 16;

    unsigned char FAR *p = (unsigned char FAR *) Buffer;

    //
    // 3 chars per byte for hex display, plus an extra space every 4 bytes,
    // plus a byte for the printable representation, plus the \0.
    //
    char Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+BYTES_PER_LINE+1];
    Outbuf[0] = 0;
    Outbuf[sizeof(Outbuf)-1] = 0;
    char * HexDigits = "0123456789abcdef";

    unsigned Index;
    for ( unsigned Offset=0; Offset < Length; Offset++ )
        {
        Index = Offset % BYTES_PER_LINE;

        if ( Index == 0 )
            {
            LogSerial( "   %s", Outbuf);

            memset(Outbuf, ' ', sizeof(Outbuf)-1);
            }

        Outbuf[Index*3+Index/4  ] = HexDigits[p[Offset] / 16];
        Outbuf[Index*3+Index/4+1] = HexDigits[p[Offset] % 16];
        Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+Index] = printable(p[Offset]) ? p[Offset] : '.';
        }

    LogSerial( "   %s", Outbuf);
}

// All of these methods and functions throw a ComError

void SafeWriteFile( HANDLE hFile, void *pBuffer, DWORD dwSize )
{
    DWORD dwBytesWritten;

    LogSerial("safe-write: writing file data, %d bytes:", dwSize );

    DumpBuffer( pBuffer, dwSize );

    BOOL bResult =
    WriteFile( hFile, pBuffer, dwSize, &dwBytesWritten, NULL );

    if ( !bResult ) throw ComError( HRESULT_FROM_WIN32(GetLastError()) );

    if ( dwBytesWritten != dwSize )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
}

void SafeReadFile( HANDLE hFile, void *pBuffer, DWORD dwSize )
{
    DWORD dwBytesRead;

    LogSerial("safe-read: reading %d bytes", dwSize );

    BOOL bResult =
    ReadFile( hFile, pBuffer, dwSize, &dwBytesRead, NULL );

    HRESULT Hr = ( bResult ) ? S_OK : HRESULT_FROM_WIN32( GetLastError() );

    DumpBuffer( pBuffer, dwBytesRead );

    if ( !bResult )
        {
        LogSerial("safe-read: only %d bytes read: %!winerr!", dwBytesRead, Hr );
        throw ComError( Hr );
        }

    if ( dwBytesRead != dwSize )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
}

void SafeWriteStringHandle( HANDLE hFile, StringHandle & str )
{
    DWORD dwStringSize = str.Size() + 1;

    SafeWriteFile( hFile, dwStringSize );

    SafeWriteFile( hFile, (void*)(const WCHAR*) str, dwStringSize * sizeof(wchar_t) );

}

StringHandle SafeReadStringHandle( HANDLE hFile )
{
    DWORD dwStringSize;
    bool bResult;

    SafeReadFile( hFile, &dwStringSize, sizeof(dwStringSize) );

    auto_ptr<wchar_t> buf( new wchar_t[ dwStringSize ] );

    SafeReadFile( hFile, buf.get(),  dwStringSize * sizeof(wchar_t) );

    if ( buf.get()[ dwStringSize-1 ] != L'\0' )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

    return StringHandle( buf.get() );
}

void SafeWriteFile( HANDLE hFile, WCHAR * str )
{

    bool bString = (NULL != str );
    SafeWriteFile( hFile, bString );
    if ( bString )
        {
        DWORD dwStringSize = (DWORD)wcslen(str) + 1;
        SafeWriteFile( hFile, dwStringSize );
        SafeWriteFile( hFile, (void*)str, dwStringSize * sizeof(WCHAR) );
        }
}

void SafeReadFile( HANDLE hFile, WCHAR ** pStr )
{

    bool bString;

    SafeReadFile( hFile, &bString );

    if ( !bString )
        {
        *pStr = NULL;
        return;
        }

    DWORD dwStringSize;
    SafeReadFile( hFile, &dwStringSize );

    *pStr = new WCHAR[ dwStringSize ];
    if ( !*pStr )
        throw ComError( E_OUTOFMEMORY );

    try
        {
        SafeReadFile( hFile, (void*)*pStr, dwStringSize * sizeof(WCHAR));

        if ( (*pStr)[ dwStringSize - 1] != L'\0' )
            throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
        }
    catch ( ComError Error )
        {
        delete[] *pStr;
        *pStr = NULL;
        throw;
        }
}


void SafeWriteSid( HANDLE hFile,  SidHandle & sid  )
{
    DWORD length;
    LPWSTR str = NULL;

    try
        {
        if ( !ConvertSidToStringSid( sid.get(), &str) )
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError()));
            }

        length = 1+wcslen( str );

        SafeWriteFile( hFile, length );
        SafeWriteFile( hFile, str, length * sizeof(wchar_t));

        LocalFree( str );
        }
    catch ( ComError Error )
        {
        if ( str )
            {
            LocalFree( str );
            }

        throw;
        }
}

void SafeReadSid( HANDLE hFile, SidHandle & sid )
{
    DWORD dwStringSize;
    bool bResult;

    SafeReadFile( hFile, &dwStringSize, sizeof(dwStringSize) );

    auto_ptr<wchar_t> buf( new wchar_t[ dwStringSize ] );

    SafeReadFile( hFile, buf.get(),  dwStringSize * sizeof(wchar_t) );

    if ( buf.get()[ dwStringSize-1 ] != L'\0' )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

    PSID TempSid;
    if (!ConvertStringSidToSid( buf.get(), &TempSid ))
        {
        if (GetLastError() == ERROR_INVALID_SID)
            {
            THROW_HRESULT( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
            }
        THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError() ));
        }

    try
        {
        sid = DuplicateSid( TempSid );
        LocalFree( TempSid );
        }
    catch( ComError err )
        {
        LocalFree( TempSid );
        throw;
        }
}


int SafeReadGuidChoice( HANDLE hFile, const GUID * guids[] )
{
    GUID guid;
    SafeReadFile( hFile, &guid );

    int i = 0;

    for ( i=0; guids[i] != NULL; ++i )
        {
        if ( guid == *guids[i] )
            {
            return i;
            }
        }

    throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
}

void SafeWriteBlockBegin( HANDLE hFile, GUID BlockGuid )
{
    SafeWriteFile( hFile, BlockGuid );
}

void SafeWriteBlockEnd( HANDLE hFile, GUID BlockGuid )
{
    SafeWriteFile( hFile, BlockGuid );
}

void SafeReadBlockBegin( HANDLE hFile, GUID BlockGuid )
{
    GUID FileBlockGuid;
    SafeReadFile( hFile, &FileBlockGuid );

    if ( memcmp( &FileBlockGuid, &BlockGuid, sizeof(GUID)) != 0 )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

}

void SafeReadBlockEnd( HANDLE hFile, GUID BlockGuid )
{
    GUID FileBlockGuid;
    SafeReadFile( hFile, &FileBlockGuid );

    if ( memcmp( &FileBlockGuid, &BlockGuid, sizeof(GUID)) != 0 )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

}


CQmgrStateFiles::CQmgrStateFiles()
{

    for ( unsigned int i = 0; i < 2; i++ )
        {
        m_FileNames[i]           = GetNameFromIndex(i);
        m_Files[i]               = OpenMetadataFile( m_FileNames[i] );
        m_ExpandSize[i]          = 0;
        m_OriginalFileSizes[i]   = 0;
        }

    HRESULT hResult =
    GetRegDWordValue( C_QMGR_STATE_INDEX, &m_CurrentIndex);

    if ((!SUCCEEDED(hResult)) || (m_CurrentIndex > 1))
        {
        m_CurrentIndex = 0;
        }
}

auto_ptr<WCHAR> CQmgrStateFiles::GetNameFromIndex( DWORD dwIndex )
{
    using namespace std;

    TCHAR Template[] =  _T("%sqmgr%u.dat");

    SIZE_T StringSize = _tcslen(g_GlobalInfo->m_QmgrDirectory)
                                + RTL_NUMBER_OF( Template )
                                + numeric_limits<unsigned long>::digits10;

    auto_ptr<TCHAR> ReturnString(new TCHAR[StringSize] );

    THROW_HRESULT( StringCchPrintf( ReturnString.get(), StringSize, Template, g_GlobalInfo->m_QmgrDirectory, dwIndex ));

    return ReturnString;
}

// WriteEmptyMetadataFile()
//
// The overall structure of the state file is:
//
//   QmgrStateFiles GUID
//   PriorityQueuesStorage GUID
//     GroupList GUID
//     0                          -- Count of online jobs
//     GroupList GUID
//     GroupList GUID
//     0                          -- Count of offline jobs
//   PriorityQueuesStorage GUID
//   QmgrStateFiles GUID
//
// If there are jobs in the state file, then the counts would be greater than zero and the jobs would follow.
// 
void CQmgrStateFiles::WriteEmptyMetadataFile( HANDLE hFile )
{
    const int dwZeroGroups = 0;

    BITSSetFilePointer( hFile, 0, FILE_BEGIN );

    SafeWriteBlockBegin(hFile,QmgrStateStorageGUID);
    SafeWriteBlockBegin(hFile,PriorityQueuesStorageGUID);

    SafeWriteBlockBegin(hFile,GroupListStorageGUID);
    SafeWriteFile(hFile,dwZeroGroups);
    SafeWriteBlockEnd(hFile,GroupListStorageGUID);

    SafeWriteBlockBegin(hFile,GroupListStorageGUID);
    SafeWriteFile(hFile,dwZeroGroups);
    SafeWriteBlockEnd(hFile,GroupListStorageGUID);

    SafeWriteBlockEnd(hFile,PriorityQueuesStorageGUID);
    SafeWriteBlockEnd(hFile,QmgrStateStorageGUID);
}

auto_FILE_HANDLE CQmgrStateFiles::OpenMetadataFile( auto_ptr<WCHAR> FileName )
{

    SECURITY_ATTRIBUTES SecurityAttributes;
    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = (void*)g_GlobalInfo->m_MetadataSecurityDescriptor;
    SecurityAttributes.bInheritHandle = FALSE;

    HANDLE hFileHandle =
    CreateFile( FileName.get(),
                GENERIC_READ | GENERIC_WRITE,
                0,
                &SecurityAttributes,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( INVALID_HANDLE_VALUE == hFileHandle )
        throw ComError( HRESULT_FROM_WIN32(GetLastError()) );

    auto_FILE_HANDLE FileHandle( hFileHandle );

    // Ensure file size is at least METADATA_PADDING

    if ( BITSGetFileSize( hFileHandle ) < METADATA_PADDING )
        {
        BITSSetFilePointer( hFileHandle, METADATA_PADDING, FILE_BEGIN );
        BITSSetEndOfFile( hFileHandle );

        WriteEmptyMetadataFile(hFileHandle);

        BITSSetFilePointer( hFileHandle, 0, FILE_BEGIN );
        }

    return FileHandle;
}


HANDLE CQmgrStateFiles::GetNextStateFile()
{
    DWORD dwNextIndex = ( m_CurrentIndex + 1) % 2;

    HANDLE hFile = m_Files[ dwNextIndex ].get();

    BITSSetFilePointer( hFile, 0, FILE_BEGIN );

    return hFile;
}

void CQmgrStateFiles::UpdateStateFile()
{

    DWORD OldCurrentIndex = m_CurrentIndex;
    DWORD NewCurrentIndex = ( m_CurrentIndex + 1) % 2;

    // Truncate the current file only if more then METADATA_PADDING remains

    HANDLE CurrentFileHandle = m_Files[ NewCurrentIndex ].get();

    INT64 CurrentPosition = BITSSetFilePointer( CurrentFileHandle, 0, FILE_CURRENT );
    INT64 CurrentFileSize = BITSGetFileSize( CurrentFileHandle );

#if DBG
    // ASSERT( CurrentPosition <= ( m_OriginalFileSizes[ NewCurrentIndex ] + m_ExpandSize[ NewCurrentIndex ] ) );
    if (CurrentPosition > ( m_OriginalFileSizes[ NewCurrentIndex ] + m_ExpandSize[ NewCurrentIndex ] ) &&
        (m_OriginalFileSizes[ NewCurrentIndex ] > 0))
        {
        LogError("new idx %d, position %u, original size %u, expanded by %u",
                 NewCurrentIndex,
                 DWORD(CurrentPosition),
                 DWORD(m_OriginalFileSizes[ NewCurrentIndex ]),
                 DWORD(m_ExpandSize[ NewCurrentIndex ])
                 );

        Log_Close();

        Sleep(30 * 1000);

        ASSERT( 0 && "BITS: encountered bug 483866");
        }
#endif

    if ( ( CurrentFileSize - CurrentPosition ) > METADATA_PADDING )
        {
        BITSSetFilePointer( CurrentFileHandle, METADATA_PADDING, FILE_CURRENT );
        BITSSetEndOfFile( CurrentFileHandle );
        }

    BITSFlushFileBuffers( CurrentFileHandle );

    m_ExpandSize[ NewCurrentIndex ] = 0;
    m_OriginalFileSizes[ NewCurrentIndex ] = 0;

    HRESULT hResult = SetRegDWordValue( C_QMGR_STATE_INDEX, NewCurrentIndex);

    if ( !SUCCEEDED( hResult ) )
        throw ComError( hResult );

    m_CurrentIndex = NewCurrentIndex;

    //
    // Shrink the backup files if necessary
    //

    if ( m_ExpandSize[ OldCurrentIndex ] )
        {
        try
            {
            INT64 NewSize = BITSGetFileSize( m_Files[ NewCurrentIndex ].get() );

            if ( NewSize > m_OriginalFileSizes[ OldCurrentIndex ] )
                {
                BITSSetFilePointer( m_Files[ OldCurrentIndex ].get(), NewSize, FILE_BEGIN );
                BITSSetEndOfFile( m_Files[ OldCurrentIndex ].get() );
                }

            m_OriginalFileSizes[ OldCurrentIndex ] = 0;
            m_ExpandSize[ OldCurrentIndex ] = 0;

            }
        catch ( ComError Error )
            {
            LogError( "Unable to shrink file %u, error %!winerr!", OldCurrentIndex, Error.Error() );
            return;
            }

        }

}

HANDLE CQmgrStateFiles::GetCurrentStateFile()
{

    HANDLE hFile = m_Files[ m_CurrentIndex ].get();

    BITSSetFilePointer( hFile, 0, FILE_BEGIN );

    return hFile;
}

void
CQmgrStateFiles::ExtendMetadata( INT64 ExtendAmount )
{

    //
    // Get the original file sizes
    //

    SIZE_T OriginalExpansion[2] =
    { m_ExpandSize[0], m_ExpandSize[1]};

    for ( unsigned int i=0; i < 2; i++ )
        {
        if ( !m_ExpandSize[i] )
            {
            m_OriginalFileSizes[i] = BITSGetFileSize( m_Files[i].get() );
            }
        }

    bool WasExpanded[2] = { false, false};

    try
        {
        for ( unsigned int i=0; i < 2; i++ )
            {
            BITSSetFilePointer( m_Files[i].get(), ExtendAmount, FILE_END );
            BITSSetEndOfFile( m_Files[i].get() );

            WasExpanded[i] = true;
            m_ExpandSize[i] += ExtendAmount;
            }
        }

    catch ( ComError Error )
        {

        LogError( "Unable to extend the size of the metadata files, error %!winerr!", Error.Error() );

        for ( unsigned int i=0; i < 2; i++ )
            {

            try
                {
                if ( WasExpanded[i] )
                    {

                    BITSSetFilePointer( m_Files[i].get(), -ExtendAmount, FILE_END );
                    BITSSetEndOfFile( m_Files[i].get() );

                    m_ExpandSize[i] = OriginalExpansion[i];
                    }

                }
            catch ( ComError Error )
                {
                LogError( "Unable to reshrink file %u, error %!winerr!", i, Error.Error() );
                continue;
                }

            }

        throw;

        }

}

void
CQmgrStateFiles::ShrinkMetadata()
{

    for ( unsigned int i = 0; i < 2; i++ )
        {

        try
            {
            if ( m_ExpandSize[i] )
                {

                BITSSetFilePointer( m_Files[i].get(), m_OriginalFileSizes[i], FILE_BEGIN );
                BITSSetEndOfFile( m_Files[i].get() );

                m_ExpandSize[i] = 0;
                m_OriginalFileSizes[i] = 0;

                }

            }
        catch ( ComError Error )
            {
            LogError( "Unable to shrink file %u, error %!winerr!", i, Error.Error() );
            continue;
            }

        }
}


CQmgrReadStateFile::CQmgrReadStateFile( CQmgrStateFiles & StateFiles ) :
m_StateFiles( StateFiles ),
m_FileHandle(  StateFiles.GetCurrentStateFile() )
{
    // Validate the file
    SafeReadBlockBegin( m_FileHandle, QmgrStateStorageGUID );
}

void CQmgrReadStateFile::ValidateEndOfFile()
{
    SafeReadBlockEnd( m_FileHandle, QmgrStateStorageGUID );
}

CQmgrWriteStateFile::CQmgrWriteStateFile( CQmgrStateFiles & StateFiles ) :
m_StateFiles( StateFiles ),
m_FileHandle( StateFiles.GetNextStateFile() )
{

    SafeWriteBlockBegin( m_FileHandle, QmgrStateStorageGUID );

}

void CQmgrWriteStateFile::CommitFile()
{
    SafeWriteBlockEnd( m_FileHandle, QmgrStateStorageGUID );

    m_StateFiles.UpdateStateFile();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\netspeed.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    netspeed.cpp

Abstract :

    Main source file for throttle control.

Author :

Revision History :


---> for small files, we need to feed the file size in to the block calculator,
     because the server-speed estimator will be incorrect if m_BlockSize is 65000
     but the download time is based on a file size of 2002 bytes.

 ***********************************************************************/


#include "stdafx.h"
#include <malloc.h>
#include <limits.h>

#if !defined(BITS_V12_ON_NT4)
#include "netspeed.tmh"
#endif

//
// the maximum % of the perceived bandwidth that BITS will use for itself
//
const float MAX_BANDWIDTH_FRACTION = 0.95f;

//
// timer periods in seconds
//
const float DEFAULT_BLOCK_INTERVAL = 2.0f;
const float MIN_BLOCK_INTERVAL = 0.001f;
const float MAX_BLOCK_INTERVAL = 5.0f;

//
// observed header sizes.  request = 250, reply = 300
//
#define REQUEST_OVERHEAD 550

//
// smallest block we will pull down
//
#define MIN_BLOCK_SIZE 2000

//
// size when we occasionally pull down a block on a full network
//
#define BUSY_BLOCK_SIZE 1500

//
// Very small blocks give unreliable speed measurements.
//
#define MIN_BLOCK_SIZE_TO_MEASURE 500

const NETWORK_RATE  CNetworkInterface::DEFAULT_SPEED = 1600.0f;

// Work around limitations of the protocol stack

const DWORD MAX_BLOCK_SIZE = 2147483648;

//------------------------------------------------------------------------

//
// The observed server speed is reported as the average of this many usable samples.
//
const float SERVER_SPEED_SAMPLE_COUNT = 3.0F;

/*

The algorithm used to determine the speed and loading of the network is as follows:

1.  After contacting the web site with Wininet calls, see whether an HTTP 1.1 "Via" header is present.
    If so, a proxy was used, and we locate the proper net card to talk with the proxy.  Otherwise,
    a proxy was not used, and we locate the proper net card to talk with the HTTP server itself.

2.  Chop time into 1/2-second intervals, and measure the interface's bytes-in and bytes-out count
    three times per interval: first at the beginning, just before a block is downloaded, second at
    the completion of the block, and third at the end of the interval.


*/

HRESULT
CNetworkInterface::TakeSnapshot(
    int StatIndex
    )
{
    DWORD s;
    ULONG size = 0;

    //
    // The network speed can be calculated only if all three snapshots succeeded.
    // We keep track of the error status of the current series of snapshots.
    //
    if (StatIndex == BLOCK_START)
        {
        m_SnapshotError = S_OK;
        m_SnapshotsValid = false;
        }

    m_TempRow.dwIndex = m_InterfaceIndex;
    DWORD dwGetIfEntryError = GetIfEntry( &m_TempRow );
    if ( dwGetIfEntryError )
        {
        LogWarning( "[%d] : GetIfRow(%d)  failed %!winerr!", StatIndex, m_InterfaceIndex, dwGetIfEntryError );
        m_SnapshotError = HRESULT_FROM_WIN32( dwGetIfEntryError );
        return m_SnapshotError;
        }

    QueryPerformanceCounter( &m_Snapshots[ StatIndex ].TimeStamp );

    m_Snapshots[ StatIndex ].BytesIn   = m_TempRow.dwInOctets;
    m_Snapshots[ StatIndex ].BytesOut  = m_TempRow.dwOutOctets;

    LogDl( "[%d] : in=%d, out=%d, timestamp=%d",
         StatIndex,
         m_Snapshots[ StatIndex ].BytesIn,
         m_Snapshots[ StatIndex ].BytesOut,
         m_Snapshots[ StatIndex ].TimeStamp.u.LowPart );

    if (StatIndex == BLOCK_INTERVAL_END &&
        m_SnapshotError == S_OK)
        {
        m_SnapshotsValid = true;
        }

    return S_OK;
}


float
CNetworkInterface::GetTimeDifference(
    int start,
    int finish
    )
{
    float TotalTime;

    TotalTime = m_Snapshots[ finish ].TimeStamp.QuadPart - m_Snapshots[ start ].TimeStamp.QuadPart;

    TotalTime /= g_GlobalInfo->m_PerformanceCounterFrequency.QuadPart;  // convert to seconds

    if (TotalTime <= 0)
        {
        // pretend it was half a tick.
        TotalTime = 1 / float(2 * g_GlobalInfo->m_PerformanceCounterFrequency.QuadPart);
        }

    return TotalTime;
}


CNetworkInterface::CNetworkInterface()
{
    Reset();
}

HRESULT
CNetworkInterface::SetInterfaceIndex(
    const TCHAR host[]
    )
{
    DWORD index;

    HRESULT Hr = FindInterfaceIndex( host, &index );
    if (FAILED(Hr))
        return Hr;

    if (m_InterfaceIndex != index)
        {
        m_InterfaceIndex = index;
        Reset();
        }

    return S_OK;
}

void
CNetworkInterface::Reset()
{
    m_ServerSpeed = DEFAULT_SPEED;
    m_NetcardSpeed = DEFAULT_SPEED;
    m_PercentFree = 0.5f;

    m_SnapshotsValid = false;
    m_SnapshotError = E_FAIL;
    m_state = DOWNLOADED_BLOCK;
}


void
CNetworkInterface::SetInterfaceSpeed()
{
    float TotalTime, ratio;
    NETWORK_RATE rate = 0;

    //
    // Adjust server speed based on block download stats.
    //
    if (m_SnapshotsValid && m_BlockSize)
        {
        float ExpectedTime = m_BlockInterval * m_PercentFree;

        //
        // Calculate interface speed from the time the last block took.
        //
        TotalTime = GetTimeDifference( BLOCK_START, BLOCK_END );

        if (ExpectedTime > 0)
            {
            ratio = ExpectedTime / TotalTime;

            rate = m_ServerSpeed * ratio;
            }
        else
            {
            // either m_PercentFree was zero, or the interval was zero.  The ordinary calculation
            // would always produce a ratio of zero and drag down our average speed incorrectly.

            // use strict bytes per second measure
            rate = m_BlockSize / TotalTime;
            if (rate < m_ServerSpeed)
                {
                rate = m_ServerSpeed;
                }
            }

        m_ServerSpeed *= (SERVER_SPEED_SAMPLE_COUNT-1) / SERVER_SPEED_SAMPLE_COUNT;
        m_ServerSpeed += (rate / SERVER_SPEED_SAMPLE_COUNT);

        LogDl("expected interval %f, actual= %f, rate= %!netrate!, avg %!netrate!",
              ExpectedTime, TotalTime, rate, m_ServerSpeed );
        }

    //
    // Adjust usage and netcard speed based on interval stats.
    //
    if (m_SnapshotsValid)
        {
        float Bytes;

        Bytes  = m_Snapshots[ BLOCK_END ].BytesIn  - m_Snapshots[ BLOCK_START ].BytesIn;
        Bytes += m_Snapshots[ BLOCK_END ].BytesOut - m_Snapshots[ BLOCK_START ].BytesOut;

        ASSERT( Bytes >= 0 );

        TotalTime = GetTimeDifference( BLOCK_START, BLOCK_END );

        rate = Bytes/TotalTime;

        // use whichever estimate is larger

        if (rate < m_ServerSpeed)
            {
            rate = m_ServerSpeed;
            }

        if (m_NetcardSpeed == 0)
            {
            m_NetcardSpeed = rate;
            }
        else
            {
            if (rate < m_NetcardSpeed * 0.9f)
                {
                //
                // If the rate drops precipitously, it's probably just a quiet moment on the Net;
                // a strict average would unduly lower our estimated throughput.
                // But reduce the average a little in case it's a long-term slowdown.  If so,
                // eventually the average will be lowered enough that the incoming rates are greater
                // than m_NetcardSpeed / 2.
                //
                rate = m_NetcardSpeed * 0.9f;
                }

            //
            // Keep a running average of the perceived rate.
            //
            m_NetcardSpeed *= (SERVER_SPEED_SAMPLE_COUNT-1) / SERVER_SPEED_SAMPLE_COUNT;
            m_NetcardSpeed += (rate / SERVER_SPEED_SAMPLE_COUNT);
            }

        LogDl("bandwidth: bytes %f, time %f, rate %f, avg. %f", Bytes, TotalTime, rate, m_NetcardSpeed);

        //
        // Subtract our usage from the calculated usage.  Compare usage to top speed to get free bandwidth.
        //
        Bytes  = m_Snapshots[ BLOCK_INTERVAL_END ].BytesIn  - m_Snapshots[ BLOCK_START ].BytesIn;
        Bytes += m_Snapshots[ BLOCK_INTERVAL_END ].BytesOut - m_Snapshots[ BLOCK_START ].BytesOut;
        Bytes -= m_BlockSize;

        if (Bytes < 0)
            {
            Bytes = 0;
            }

        TotalTime = GetTimeDifference( BLOCK_START, BLOCK_INTERVAL_END );

        rate = Bytes/TotalTime;

        m_PercentFree = 1 - (rate / m_NetcardSpeed);
        }

    LogDl("usage: %f / %f, percent free %f", rate, m_NetcardSpeed, m_PercentFree);

    if (m_PercentFree < 0)
        {
        m_PercentFree = 0;
        }
    else if (m_PercentFree > MAX_BANDWIDTH_FRACTION)      // never monopolize the net
        {
        m_PercentFree = MAX_BANDWIDTH_FRACTION;
        }
}

//------------------------------------------------------------------------

DWORD
CNetworkInterface::BlockSizeFromInterval(
    SECONDS interval
    )
{
    NETWORK_RATE FreeBandwidth = GetInterfaceSpeed() * GetPercentFree() * interval;

    if (FreeBandwidth <= REQUEST_OVERHEAD)
        {
        return 0;
        }

    return FreeBandwidth - REQUEST_OVERHEAD;
}

CNetworkInterface::SECONDS
CNetworkInterface::IntervalFromBlockSize(
    DWORD BlockSize
    )
{
    NETWORK_RATE FreeBandwidth = GetInterfaceSpeed() * GetPercentFree();

    BlockSize += REQUEST_OVERHEAD;

    if (BlockSize / MAX_BLOCK_INTERVAL > FreeBandwidth )
        {
        return -1;
        }

    return BlockSize / FreeBandwidth;
}

void
CNetworkInterface::CalculateIntervalAndBlockSize(
    UINT64 MaxBlockSize
    )
{
    MaxBlockSize = min( MaxBlockSize, MAX_BLOCK_SIZE );

    if (MaxBlockSize == 0)
        {
        m_BlockInterval = 0;
        m_BlockSize     = 0;

        SetTimerInterval( m_BlockInterval );
        LogDl( "block %d bytes, interval %f seconds", m_BlockSize, m_BlockInterval );
        return;
        }

    //
    // Calculate new block size from the average interface speed.
    //
    DWORD OldState = m_state;

    m_BlockInterval = DEFAULT_BLOCK_INTERVAL;
    m_BlockSize     = BlockSizeFromInterval( m_BlockInterval );

    if (m_BlockSize > MaxBlockSize)
        {
        m_BlockSize     = MaxBlockSize;
        m_BlockInterval = IntervalFromBlockSize( m_BlockSize );

        ASSERT( m_BlockInterval > 0 );
        }
    else if (m_BlockSize < MIN_BLOCK_SIZE)
        {
        m_BlockSize     = min( MIN_BLOCK_SIZE, MaxBlockSize );
        m_BlockInterval = IntervalFromBlockSize( m_BlockSize );
        }

    if (m_BlockInterval < 0)
        {
        m_BlockSize = 0;
        }

    //
    // choose the new block download state.
    //
    if (m_BlockSize > 0)
        {
        m_state = DOWNLOADED_BLOCK;
        }
    else
        {
        //
        // The first time m_BlockSize is set to zero, retain the default interval.
        // If blocksize is zero twice in a row, expand to MAX_BLOCK_INTERVAL.
        // Then force a small download.
        //
        switch (OldState)
            {
            case DOWNLOADED_BLOCK:
                {
                m_BlockInterval = DEFAULT_BLOCK_INTERVAL;
                m_state         = SKIPPED_ONE_BLOCK;
                break;
                }

            case SKIPPED_ONE_BLOCK:
                {
                m_BlockInterv